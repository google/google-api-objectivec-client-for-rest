// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Asset API (cloudasset/v1)
// Description:
//   The cloud asset API manages the history and inventory of cloud resources.
// Documentation:
//   https://cloud.google.com/asset-inventory/docs/quickstart

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCloudAsset_AccessSelector;
@class GTLRCloudAsset_Asset;
@class GTLRCloudAsset_AttachedResource;
@class GTLRCloudAsset_AuditConfig;
@class GTLRCloudAsset_AuditLogConfig;
@class GTLRCloudAsset_BigQueryDestination;
@class GTLRCloudAsset_Binding;
@class GTLRCloudAsset_ConditionContext;
@class GTLRCloudAsset_ConditionEvaluation;
@class GTLRCloudAsset_Date;
@class GTLRCloudAsset_EffectiveIamPolicy;
@class GTLRCloudAsset_Explanation;
@class GTLRCloudAsset_Explanation_MatchedPermissions;
@class GTLRCloudAsset_Expr;
@class GTLRCloudAsset_Feed;
@class GTLRCloudAsset_FeedOutputConfig;
@class GTLRCloudAsset_GcsDestination;
@class GTLRCloudAsset_GoogleCloudAssetV1Access;
@class GTLRCloudAsset_GoogleCloudAssetV1AccessControlList;
@class GTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination;
@class GTLRCloudAsset_GoogleCloudAssetV1Edge;
@class GTLRCloudAsset_GoogleCloudAssetV1GcsDestination;
@class GTLRCloudAsset_GoogleCloudAssetV1Identity;
@class GTLRCloudAsset_GoogleCloudAssetV1IdentityList;
@class GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelatedAsset;
@class GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelatedAssets;
@class GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelationshipAttributes;
@class GTLRCloudAsset_GoogleCloudAssetV1p7beta1Resource;
@class GTLRCloudAsset_GoogleCloudAssetV1p7beta1Resource_Data;
@class GTLRCloudAsset_GoogleCloudAssetV1Resource;
@class GTLRCloudAsset_GoogleCloudOrgpolicyV1BooleanPolicy;
@class GTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy;
@class GTLRCloudAsset_GoogleCloudOrgpolicyV1Policy;
@class GTLRCloudAsset_GoogleCloudOrgpolicyV1RestoreDefault;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessLevel;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessPolicy;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ApiOperation;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1Condition;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1CustomLevel;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressPolicy;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressTo;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressPolicy;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressSource;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressTo;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1MethodSelector;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeterConfig;
@class GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1VpcAccessibleServices;
@class GTLRCloudAsset_IamPolicyAnalysis;
@class GTLRCloudAsset_IamPolicyAnalysisOutputConfig;
@class GTLRCloudAsset_IamPolicyAnalysisQuery;
@class GTLRCloudAsset_IamPolicyAnalysisResult;
@class GTLRCloudAsset_IamPolicyAnalysisState;
@class GTLRCloudAsset_IamPolicySearchResult;
@class GTLRCloudAsset_IdentitySelector;
@class GTLRCloudAsset_Inventory;
@class GTLRCloudAsset_Inventory_Items;
@class GTLRCloudAsset_Item;
@class GTLRCloudAsset_MoveAnalysis;
@class GTLRCloudAsset_MoveAnalysisResult;
@class GTLRCloudAsset_MoveImpact;
@class GTLRCloudAsset_Operation_Metadata;
@class GTLRCloudAsset_Operation_Response;
@class GTLRCloudAsset_Options;
@class GTLRCloudAsset_OsInfo;
@class GTLRCloudAsset_OutputConfig;
@class GTLRCloudAsset_PartitionSpec;
@class GTLRCloudAsset_Permissions;
@class GTLRCloudAsset_Policy;
@class GTLRCloudAsset_PolicyInfo;
@class GTLRCloudAsset_PubsubDestination;
@class GTLRCloudAsset_QueryContent;
@class GTLRCloudAsset_RelatedAsset;
@class GTLRCloudAsset_RelatedAssets;
@class GTLRCloudAsset_RelatedResource;
@class GTLRCloudAsset_RelatedResources;
@class GTLRCloudAsset_RelationshipAttributes;
@class GTLRCloudAsset_Resource;
@class GTLRCloudAsset_Resource_Data;
@class GTLRCloudAsset_ResourceSearchResult;
@class GTLRCloudAsset_ResourceSearchResult_AdditionalAttributes;
@class GTLRCloudAsset_ResourceSearchResult_Labels;
@class GTLRCloudAsset_ResourceSearchResult_Relationships;
@class GTLRCloudAsset_ResourceSelector;
@class GTLRCloudAsset_SavedQuery;
@class GTLRCloudAsset_SavedQuery_Labels;
@class GTLRCloudAsset_SoftwarePackage;
@class GTLRCloudAsset_Status;
@class GTLRCloudAsset_Status_Details_Item;
@class GTLRCloudAsset_TemporalAsset;
@class GTLRCloudAsset_TimeWindow;
@class GTLRCloudAsset_VersionedPackage;
@class GTLRCloudAsset_VersionedResource;
@class GTLRCloudAsset_VersionedResource_Resource;
@class GTLRCloudAsset_WindowsApplication;
@class GTLRCloudAsset_WindowsQuickFixEngineeringPackage;
@class GTLRCloudAsset_WindowsUpdateCategory;
@class GTLRCloudAsset_WindowsUpdatePackage;
@class GTLRCloudAsset_ZypperPatch;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCloudAsset_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_ConditionEvaluation.evaluationValue

/**
 *  The evaluation result is `conditional` when the condition expression
 *  contains variables that are either missing input values or have not been
 *  supported by Analyzer yet.
 *
 *  Value: "CONDITIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_Conditional;
/**
 *  Reserved for future use.
 *
 *  Value: "EVALUATION_VALUE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_EvaluationValueUnspecified;
/**
 *  The evaluation result is `false`.
 *
 *  Value: "FALSE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_False;
/**
 *  The evaluation result is `true`.
 *
 *  Value: "TRUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_True;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_ExportAssetsRequest.contentType

/**
 *  The Cloud Access context manager Policy set on an asset.
 *
 *  Value: "ACCESS_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_AccessPolicy;
/**
 *  Unspecified content type.
 *
 *  Value: "CONTENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_ContentTypeUnspecified;
/**
 *  The actual IAM policy set on a resource.
 *
 *  Value: "IAM_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_IamPolicy;
/**
 *  The Cloud Organization Policy set on an asset.
 *
 *  Value: "ORG_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_OrgPolicy;
/**
 *  The runtime OS Inventory information.
 *
 *  Value: "OS_INVENTORY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_OsInventory;
/**
 *  The related resources.
 *
 *  Value: "RELATIONSHIP"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_Relationship;
/**
 *  Resource metadata.
 *
 *  Value: "RESOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_ExportAssetsRequest_ContentType_Resource;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_Feed.contentType

/**
 *  The Cloud Access context manager Policy set on an asset.
 *
 *  Value: "ACCESS_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_AccessPolicy;
/**
 *  Unspecified content type.
 *
 *  Value: "CONTENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_ContentTypeUnspecified;
/**
 *  The actual IAM policy set on a resource.
 *
 *  Value: "IAM_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_IamPolicy;
/**
 *  The Cloud Organization Policy set on an asset.
 *
 *  Value: "ORG_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_OrgPolicy;
/**
 *  The runtime OS Inventory information.
 *
 *  Value: "OS_INVENTORY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_OsInventory;
/**
 *  The related resources.
 *
 *  Value: "RELATIONSHIP"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_Relationship;
/**
 *  Resource metadata.
 *
 *  Value: "RESOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Feed_ContentType_Resource;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination.partitionKey

/**
 *  Unspecified partition key. Tables won't be partitioned using this option.
 *
 *  Value: "PARTITION_KEY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination_PartitionKey_PartitionKeyUnspecified;
/**
 *  The time when the request is received. If specified as partition key, the
 *  result table(s) is partitoned by the RequestTime column, an additional
 *  timestamp column representing when the request was received.
 *
 *  Value: "REQUEST_TIME"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination_PartitionKey_RequestTime;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy.allValues

/**
 *  A policy with this set allows all values.
 *
 *  Value: "ALLOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy_AllValues_Allow;
/**
 *  Indicates that allowed_values or denied_values must be set.
 *
 *  Value: "ALL_VALUES_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy_AllValues_AllValuesUnspecified;
/**
 *  A policy with this set denies all values.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy_AllValues_Deny;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel.combiningFunction

/**
 *  All `Conditions` must be true for the `BasicLevel` to be true.
 *
 *  Value: "AND"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel_CombiningFunction_And;
/**
 *  If at least one `Condition` is true, then the `BasicLevel` is true.
 *
 *  Value: "OR"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel_CombiningFunction_Or;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy.allowedDeviceManagementLevels

/**
 *  Basic management is enabled, which is generally limited to monitoring and
 *  wiping the corporate account.
 *
 *  Value: "BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedDeviceManagementLevels_Basic;
/**
 *  Complete device management. This includes more thorough monitoring and the
 *  ability to directly manage the device (such as remote wiping). This can be
 *  enabled through the Android Enterprise Platform.
 *
 *  Value: "COMPLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedDeviceManagementLevels_Complete;
/**
 *  The device's management level is not specified or not known.
 *
 *  Value: "MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedDeviceManagementLevels_ManagementUnspecified;
/**
 *  The device is not managed.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedDeviceManagementLevels_None;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy.allowedEncryptionStatuses

/**
 *  The device is encrypted.
 *
 *  Value: "ENCRYPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedEncryptionStatuses_Encrypted;
/**
 *  The encryption status of the device is not specified or not known.
 *
 *  Value: "ENCRYPTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedEncryptionStatuses_EncryptionUnspecified;
/**
 *  The device does not support encryption.
 *
 *  Value: "ENCRYPTION_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedEncryptionStatuses_EncryptionUnsupported;
/**
 *  The device supports encryption, but is currently unencrypted.
 *
 *  Value: "UNENCRYPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy_AllowedEncryptionStatuses_Unencrypted;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom.identityType

/**
 *  Authorize access from all identities outside the perimeter.
 *
 *  Value: "ANY_IDENTITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_AnyIdentity;
/**
 *  Authorize access from all service accounts outside the perimeter.
 *
 *  Value: "ANY_SERVICE_ACCOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_AnyServiceAccount;
/**
 *  Authorize access from all human users outside the perimeter.
 *
 *  Value: "ANY_USER_ACCOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_AnyUserAccount;
/**
 *  No blanket identity group specified.
 *
 *  Value: "IDENTITY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_IdentityTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom.identityType

/**
 *  Authorize access from all identities outside the perimeter.
 *
 *  Value: "ANY_IDENTITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_AnyIdentity;
/**
 *  Authorize access from all service accounts outside the perimeter.
 *
 *  Value: "ANY_SERVICE_ACCOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_AnyServiceAccount;
/**
 *  Authorize access from all human users outside the perimeter.
 *
 *  Value: "ANY_USER_ACCOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_AnyUserAccount;
/**
 *  No blanket identity group specified.
 *
 *  Value: "IDENTITY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_IdentityTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint.osType

/**
 *  An Android operating system.
 *
 *  Value: "ANDROID"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_Android;
/**
 *  A desktop ChromeOS operating system.
 *
 *  Value: "DESKTOP_CHROME_OS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopChromeOs;
/**
 *  A desktop Linux operating system.
 *
 *  Value: "DESKTOP_LINUX"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopLinux;
/**
 *  A desktop Mac operating system.
 *
 *  Value: "DESKTOP_MAC"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopMac;
/**
 *  A desktop Windows operating system.
 *
 *  Value: "DESKTOP_WINDOWS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopWindows;
/**
 *  An iOS operating system.
 *
 *  Value: "IOS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_Ios;
/**
 *  The operating system of the device is not specified or not known.
 *
 *  Value: "OS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_OsUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter.perimeterType

/**
 *  Perimeter Bridge.
 *
 *  Value: "PERIMETER_TYPE_BRIDGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter_PerimeterType_PerimeterTypeBridge;
/**
 *  Regular Perimeter.
 *
 *  Value: "PERIMETER_TYPE_REGULAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter_PerimeterType_PerimeterTypeRegular;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_IamPolicyAnalysisState.code

/**
 *  The operation was aborted, typically due to a concurrency issue such as a
 *  sequencer check failure or transaction abort. See the guidelines above for
 *  deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP
 *  Mapping: 409 Conflict
 *
 *  Value: "ABORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Aborted;
/**
 *  The entity that a client attempted to create (e.g., file or directory)
 *  already exists. HTTP Mapping: 409 Conflict
 *
 *  Value: "ALREADY_EXISTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_AlreadyExists;
/**
 *  The operation was cancelled, typically by the caller. HTTP Mapping: 499
 *  Client Closed Request
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Cancelled;
/**
 *  Unrecoverable data loss or corruption. HTTP Mapping: 500 Internal Server
 *  Error
 *
 *  Value: "DATA_LOSS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_DataLoss;
/**
 *  The deadline expired before the operation could complete. For operations
 *  that change the state of the system, this error may be returned even if the
 *  operation has completed successfully. For example, a successful response
 *  from a server could have been delayed long enough for the deadline to
 *  expire. HTTP Mapping: 504 Gateway Timeout
 *
 *  Value: "DEADLINE_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_DeadlineExceeded;
/**
 *  The operation was rejected because the system is not in a state required for
 *  the operation's execution. For example, the directory to be deleted is
 *  non-empty, an rmdir operation is applied to a non-directory, etc. Service
 *  implementors can use the following guidelines to decide between
 *  `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE`
 *  if the client can retry just the failing call. (b) Use `ABORTED` if the
 *  client should retry at a higher level. For example, when a client-specified
 *  test-and-set fails, indicating the client should restart a read-modify-write
 *  sequence. (c) Use `FAILED_PRECONDITION` if the client should not retry until
 *  the system state has been explicitly fixed. For example, if an "rmdir" fails
 *  because the directory is non-empty, `FAILED_PRECONDITION` should be returned
 *  since the client should not retry unless the files are deleted from the
 *  directory. HTTP Mapping: 400 Bad Request
 *
 *  Value: "FAILED_PRECONDITION"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_FailedPrecondition;
/**
 *  Internal errors. This means that some invariants expected by the underlying
 *  system have been broken. This error code is reserved for serious errors.
 *  HTTP Mapping: 500 Internal Server Error
 *
 *  Value: "INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Internal;
/**
 *  The client specified an invalid argument. Note that this differs from
 *  `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are
 *  problematic regardless of the state of the system (e.g., a malformed file
 *  name). HTTP Mapping: 400 Bad Request
 *
 *  Value: "INVALID_ARGUMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_InvalidArgument;
/**
 *  Some requested entity (e.g., file or directory) was not found. Note to
 *  server developers: if a request is denied for an entire class of users, such
 *  as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be
 *  used. If a request is denied for some users within a class of users, such as
 *  user-based access control, `PERMISSION_DENIED` must be used. HTTP Mapping:
 *  404 Not Found
 *
 *  Value: "NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_NotFound;
/**
 *  Not an error; returned on success. HTTP Mapping: 200 OK
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Ok;
/**
 *  The operation was attempted past the valid range. E.g., seeking or reading
 *  past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem
 *  that may be fixed if the system state changes. For example, a 32-bit file
 *  system will generate `INVALID_ARGUMENT` if asked to read at an offset that
 *  is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked
 *  to read from an offset past the current file size. There is a fair bit of
 *  overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using
 *  `OUT_OF_RANGE` (the more specific error) when it applies so that callers who
 *  are iterating through a space can easily look for an `OUT_OF_RANGE` error to
 *  detect when they are done. HTTP Mapping: 400 Bad Request
 *
 *  Value: "OUT_OF_RANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_OutOfRange;
/**
 *  The caller does not have permission to execute the specified operation.
 *  `PERMISSION_DENIED` must not be used for rejections caused by exhausting
 *  some resource (use `RESOURCE_EXHAUSTED` instead for those errors).
 *  `PERMISSION_DENIED` must not be used if the caller can not be identified
 *  (use `UNAUTHENTICATED` instead for those errors). This error code does not
 *  imply the request is valid or the requested entity exists or satisfies other
 *  pre-conditions. HTTP Mapping: 403 Forbidden
 *
 *  Value: "PERMISSION_DENIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_PermissionDenied;
/**
 *  Some resource has been exhausted, perhaps a per-user quota, or perhaps the
 *  entire file system is out of space. HTTP Mapping: 429 Too Many Requests
 *
 *  Value: "RESOURCE_EXHAUSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_ResourceExhausted;
/**
 *  The request does not have valid authentication credentials for the
 *  operation. HTTP Mapping: 401 Unauthorized
 *
 *  Value: "UNAUTHENTICATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unauthenticated;
/**
 *  The service is currently unavailable. This is most likely a transient
 *  condition, which can be corrected by retrying with a backoff. Note that it
 *  is not always safe to retry non-idempotent operations. See the guidelines
 *  above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and
 *  `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
 *
 *  Value: "UNAVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unavailable;
/**
 *  The operation is not implemented or is not supported/enabled in this
 *  service. HTTP Mapping: 501 Not Implemented
 *
 *  Value: "UNIMPLEMENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unimplemented;
/**
 *  Unknown error. For example, this error may be returned when a `Status` value
 *  received from another address space belongs to an error space that is not
 *  known in this address space. Also errors raised by APIs that do not return
 *  enough error information may be converted to this error. HTTP Mapping: 500
 *  Internal Server Error
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unknown;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_Item.originType

/**
 *  This inventory item was discovered as the result of the agent reporting
 *  inventory via the reporting API.
 *
 *  Value: "INVENTORY_REPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Item_OriginType_InventoryReport;
/**
 *  Invalid. An origin type must be specified.
 *
 *  Value: "ORIGIN_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Item_OriginType_OriginTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_Item.type

/**
 *  This represents an update that is available for a package.
 *
 *  Value: "AVAILABLE_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Item_Type_AvailablePackage;
/**
 *  This represents a package that is installed on the VM.
 *
 *  Value: "INSTALLED_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Item_Type_InstalledPackage;
/**
 *  Invalid. An type must be specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_Item_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_PartitionSpec.partitionKey

/**
 *  Unspecified partition key. If used, it means using non-partitioned table.
 *
 *  Value: "PARTITION_KEY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_PartitionSpec_PartitionKey_PartitionKeyUnspecified;
/**
 *  The time when the snapshot is taken. If specified as partition key, the
 *  result table(s) is partitoned by the additional timestamp column, readTime.
 *  If [read_time] in ExportAssetsRequest is specified, the readTime column's
 *  value will be the same as it. Otherwise, its value will be the current time
 *  that is used to take the snapshot.
 *
 *  Value: "READ_TIME"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_PartitionSpec_PartitionKey_ReadTime;
/**
 *  The time when the request is received and started to be processed. If
 *  specified as partition key, the result table(s) is partitoned by the
 *  requestTime column, an additional timestamp column representing when the
 *  request was received.
 *
 *  Value: "REQUEST_TIME"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_PartitionSpec_PartitionKey_RequestTime;

// ----------------------------------------------------------------------------
// GTLRCloudAsset_TemporalAsset.priorAssetState

/**
 *  prior_asset is a deletion.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_TemporalAsset_PriorAssetState_Deleted;
/**
 *  Current asset is the first known state.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_TemporalAsset_PriorAssetState_DoesNotExist;
/**
 *  Failed to set prior_asset.
 *
 *  Value: "INVALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_TemporalAsset_PriorAssetState_Invalid;
/**
 *  prior_asset is populated correctly.
 *
 *  Value: "PRESENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_TemporalAsset_PriorAssetState_Present;
/**
 *  prior_asset is not applicable for the current asset.
 *
 *  Value: "PRIOR_ASSET_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudAsset_TemporalAsset_PriorAssetState_PriorAssetStateUnspecified;

/**
 *  Specifies roles and/or permissions to analyze, to determine both the
 *  identities possessing them and the resources they control. If multiple
 *  values are specified, results will include roles or permissions matching any
 *  of them. The total number of roles and permissions should be equal or less
 *  than 10.
 */
@interface GTLRCloudAsset_AccessSelector : GTLRObject

/** Optional. The permissions to appear in result. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

/** Optional. The roles to appear in result. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *roles;

@end


/**
 *  Represents the metadata of the longrunning operation for the
 *  AnalyzeIamPolicyLongrunning rpc.
 */
@interface GTLRCloudAsset_AnalyzeIamPolicyLongrunningMetadata : GTLRObject

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

@end


/**
 *  A request message for AssetService.AnalyzeIamPolicyLongrunning.
 */
@interface GTLRCloudAsset_AnalyzeIamPolicyLongrunningRequest : GTLRObject

/** Required. The request query. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisQuery *analysisQuery;

/**
 *  Required. Output configuration indicating where the results will be output
 *  to.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisOutputConfig *outputConfig;

/**
 *  Optional. The name of a saved query, which must be in the format of: *
 *  projects/project_number/savedQueries/saved_query_id *
 *  folders/folder_number/savedQueries/saved_query_id *
 *  organizations/organization_number/savedQueries/saved_query_id If both
 *  `analysis_query` and `saved_analysis_query` are provided, they will be
 *  merged together with the `saved_analysis_query` as base and the
 *  `analysis_query` as overrides. For more details of the merge behavior,
 *  please refer to the
 *  [MergeFrom](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message#Message.MergeFrom.details)
 *  doc. Note that you cannot override primitive fields with default value, such
 *  as 0 or empty string, etc., because we use proto3, which doesn't support
 *  field presence yet.
 */
@property(nonatomic, copy, nullable) NSString *savedAnalysisQuery;

@end


/**
 *  A response message for AssetService.AnalyzeIamPolicyLongrunning.
 */
@interface GTLRCloudAsset_AnalyzeIamPolicyLongrunningResponse : GTLRObject
@end


/**
 *  A response message for AssetService.AnalyzeIamPolicy.
 */
@interface GTLRCloudAsset_AnalyzeIamPolicyResponse : GTLRObject

/**
 *  Represents whether all entries in the main_analysis and
 *  service_account_impersonation_analysis have been fully explored to answer
 *  the query in the request.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fullyExplored;

/** The main analysis that matches the original request. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysis *mainAnalysis;

/**
 *  The service account impersonation analysis if
 *  AnalyzeIamPolicyRequest.analyze_service_account_impersonation is enabled.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_IamPolicyAnalysis *> *serviceAccountImpersonationAnalysis;

@end


/**
 *  The response message for resource move analysis.
 */
@interface GTLRCloudAsset_AnalyzeMoveResponse : GTLRObject

/**
 *  The list of analyses returned from performing the intended resource move
 *  analysis. The analysis is grouped by different Cloud services.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_MoveAnalysis *> *moveAnalysis;

@end


/**
 *  An asset in Google Cloud. An asset can be any resource in the Google Cloud
 *  [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  a resource outside the Google Cloud resource hierarchy (such as Google
 *  Kubernetes Engine clusters and objects), or a policy (e.g. Cloud IAM
 *  policy), or a relationship (e.g. an INSTANCE_TO_INSTANCEGROUP relationship).
 *  See [Supported asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@interface GTLRCloudAsset_Asset : GTLRObject

/**
 *  Please also refer to the [access level user
 *  guide](https://cloud.google.com/access-context-manager/docs/overview#access-levels).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessLevel *accessLevel;

/**
 *  Please also refer to the [access policy user
 *  guide](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessPolicy *accessPolicy;

/**
 *  The ancestry path of an asset in Google Cloud [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  represented as a list of relative resource names. An ancestry path starts
 *  with the closest ancestor in the hierarchy and ends at root. If the asset is
 *  a project, folder, or organization, the ancestry path starts from the asset
 *  itself. Example: `["projects/123456789", "folders/5432",
 *  "organizations/1234"]`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ancestors;

/**
 *  The type of the asset. Example: `compute.googleapis.com/Disk` See [Supported
 *  asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  A representation of the Cloud IAM policy set on a Google Cloud resource.
 *  There can be a maximum of one Cloud IAM policy set on any given resource. In
 *  addition, Cloud IAM policies inherit their granted access scope from any
 *  policies set on parent resources in the resource hierarchy. Therefore, the
 *  effectively policy is the union of both the policy set on this resource and
 *  each policy set on all of the resource's ancestry resource levels in the
 *  hierarchy. See [this
 *  topic](https://cloud.google.com/iam/help/allow-policies/inheritance) for
 *  more information.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Policy *iamPolicy;

/**
 *  The full name of the asset. Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
 *  See [Resource
 *  names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A representation of an [organization
 *  policy](https://cloud.google.com/resource-manager/docs/organization-policy/overview#organization_policy).
 *  There can be more than one organization policy with different constraints
 *  set on a given resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudOrgpolicyV1Policy *> *orgPolicy;

/**
 *  A representation of runtime OS Inventory information. See [this
 *  topic](https://cloud.google.com/compute/docs/instances/os-inventory-management)
 *  for more information.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Inventory *osInventory;

/** One related asset of the current asset. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_RelatedAsset *relatedAsset;

/**
 *  DEPRECATED. This field only presents for the purpose of
 *  backward-compatibility. The server will never generate responses with this
 *  field. The related assets of the asset of one relationship type. One asset
 *  only represents one type of relationship.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_RelatedAssets *relatedAssets;

/** A representation of the resource. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Resource *resource;

/**
 *  Please also refer to the [service perimeter user
 *  guide](https://cloud.google.com/vpc-service-controls/docs/overview).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter *servicePerimeter;

/**
 *  The last update timestamp of an asset. update_time is updated when
 *  create/update/delete operation is performed.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Attached resource representation, which is defined by the corresponding
 *  service provider. It represents an attached resource's payload.
 */
@interface GTLRCloudAsset_AttachedResource : GTLRObject

/**
 *  The type of this attached resource. Example:
 *  `osconfig.googleapis.com/Inventory` You can find the supported attached
 *  asset types of each resource in this table:
 *  `https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types`
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  Versioned resource representations of this attached resource. This is
 *  repeated because there could be multiple versions of the attached resource
 *  representations during version migration.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_VersionedResource *> *versionedResources;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRCloudAsset_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRCloudAsset_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRCloudAsset_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRCloudAsset_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRCloudAsset_AuditLogConfig_LogType_LogTypeUnspecified Default
 *        case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Batch get assets history response.
 */
@interface GTLRCloudAsset_BatchGetAssetsHistoryResponse : GTLRObject

/** A list of assets with valid time windows. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_TemporalAsset *> *assets;

@end


/**
 *  A response message for AssetService.BatchGetEffectiveIamPolicies.
 */
@interface GTLRCloudAsset_BatchGetEffectiveIamPoliciesResponse : GTLRObject

/**
 *  The effective policies for a batch of resources. Note that the results order
 *  is the same as the order of BatchGetEffectiveIamPoliciesRequest.names. When
 *  a resource does not have any effective IAM policies, its corresponding
 *  policy_result will contain empty EffectiveIamPolicy.policies.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_EffectiveIamPolicy *> *policyResults;

@end


/**
 *  A BigQuery destination for exporting assets to.
 */
@interface GTLRCloudAsset_BigQueryDestination : GTLRObject

/**
 *  Required. The BigQuery dataset in format
 *  "projects/projectId/datasets/datasetId", to which the snapshot result should
 *  be exported. If this dataset does not exist, the export call returns an
 *  INVALID_ARGUMENT error. Setting the `contentType` for `exportAssets`
 *  determines the
 *  [schema](/asset-inventory/docs/exporting-to-bigquery#bigquery-schema) of the
 *  BigQuery table. Setting `separateTablesPerAssetType` to `TRUE` also
 *  influences the schema.
 */
@property(nonatomic, copy, nullable) NSString *dataset;

/**
 *  If the destination table already exists and this flag is `TRUE`, the table
 *  will be overwritten by the contents of assets snapshot. If the flag is
 *  `FALSE` or unset and the destination table already exists, the export call
 *  returns an INVALID_ARGUMEMT error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *force;

/**
 *  [partition_spec] determines whether to export to partitioned table(s) and
 *  how to partition the data. If [partition_spec] is unset or
 *  [partition_spec.partition_key] is unset or `PARTITION_KEY_UNSPECIFIED`, the
 *  snapshot results will be exported to non-partitioned table(s). [force] will
 *  decide whether to overwrite existing table(s). If [partition_spec] is
 *  specified. First, the snapshot results will be written to partitioned
 *  table(s) with two additional timestamp columns, readTime and requestTime,
 *  one of which will be the partition key. Secondly, in the case when any
 *  destination table already exists, it will first try to update existing
 *  table's schema as necessary by appending additional columns. Then, if
 *  [force] is `TRUE`, the corresponding partition will be overwritten by the
 *  snapshot results (data in different partitions will remain intact); if
 *  [force] is unset or `FALSE`, it will append the data. An error will be
 *  returned if the schema update or data appension fails.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_PartitionSpec *partitionSpec;

/**
 *  If this flag is `TRUE`, the snapshot results will be written to one or
 *  multiple tables, each of which contains results of one asset type. The
 *  [force] and [partition_spec] fields will apply to each of them. Field
 *  [table] will be concatenated with "_" and the asset type names (see
 *  https://cloud.google.com/asset-inventory/docs/supported-asset-types for
 *  supported asset types) to construct per-asset-type table names, in which all
 *  non-alphanumeric characters like "." and "/" will be substituted by "_".
 *  Example: if field [table] is "mytable" and snapshot results contain
 *  "storage.googleapis.com/Bucket" assets, the corresponding table name will be
 *  "mytable_storage_googleapis_com_Bucket". If any of these tables does not
 *  exist, a new table with the concatenated name will be created. When
 *  [content_type] in the ExportAssetsRequest is `RESOURCE`, the schema of each
 *  table will include RECORD-type columns mapped to the nested fields in the
 *  Asset.resource.data field of that asset type (up to the 15 nested level
 *  BigQuery supports
 *  (https://cloud.google.com/bigquery/docs/nested-repeated#limitations)). The
 *  fields in >15 nested levels will be stored in JSON format string as a child
 *  column of its parent RECORD column. If error occurs when exporting to any
 *  table, the whole export call will return an error but the export results
 *  that already succeed will persist. Example: if exporting to table_type_A
 *  succeeds when exporting to table_type_B fails during one export call, the
 *  results in table_type_A will persist and there will not be partial results
 *  persisting in a table.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *separateTablesPerAssetType;

/**
 *  Required. The BigQuery table to which the snapshot result should be written.
 *  If this table does not exist, a new table with the given name will be
 *  created.
 */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRCloudAsset_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
 *  An email address (plus unique identifier) representing a user that has been
 *  recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  The IAM conditions context.
 */
@interface GTLRCloudAsset_ConditionContext : GTLRObject

/**
 *  The hypothetical access timestamp to evaluate IAM conditions. Note that this
 *  value must not be earlier than the current time; otherwise, an
 *  INVALID_ARGUMENT error will be returned.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *accessTime;

@end


/**
 *  The Condition evaluation.
 */
@interface GTLRCloudAsset_ConditionEvaluation : GTLRObject

/**
 *  The evaluation result.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_Conditional
 *        The evaluation result is `conditional` when the condition expression
 *        contains variables that are either missing input values or have not
 *        been supported by Analyzer yet. (Value: "CONDITIONAL")
 *    @arg @c kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_EvaluationValueUnspecified
 *        Reserved for future use. (Value: "EVALUATION_VALUE_UNSPECIFIED")
 *    @arg @c kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_False The
 *        evaluation result is `false`. (Value: "FALSE")
 *    @arg @c kGTLRCloudAsset_ConditionEvaluation_EvaluationValue_True The
 *        evaluation result is `true`. (Value: "TRUE")
 */
@property(nonatomic, copy, nullable) NSString *evaluationValue;

@end


/**
 *  Create asset feed request.
 */
@interface GTLRCloudAsset_CreateFeedRequest : GTLRObject

/**
 *  Required. The feed details. The field `name` must be empty and it will be
 *  generated in the format of: projects/project_number/feeds/feed_id
 *  folders/folder_number/feeds/feed_id
 *  organizations/organization_number/feeds/feed_id
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Feed *feed;

/**
 *  Required. This is the client-assigned asset feed identifier and it needs to
 *  be unique under a specific parent project/folder/organization.
 */
@property(nonatomic, copy, nullable) NSString *feedId;

@end


/**
 *  Represents a whole or partial calendar date, such as a birthday. The time of
 *  day and time zone are either specified elsewhere or are insignificant. The
 *  date is relative to the Gregorian Calendar. This can represent one of the
 *  following: * A full date, with non-zero year, month, and day values. * A
 *  month and day, with a zero year (for example, an anniversary). * A year on
 *  its own, with a zero month and a zero day. * A year and month, with a zero
 *  day (for example, a credit card expiration date). Related types: *
 *  google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
 */
@interface GTLRCloudAsset_Date : GTLRObject

/**
 *  Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
 *  to specify a year by itself or a year and month where the day isn't
 *  significant.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *day;

/**
 *  Month of a year. Must be from 1 to 12, or 0 to specify a year without a
 *  month and day.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *month;

/**
 *  Year of the date. Must be from 1 to 9999, or 0 to specify a date without a
 *  year.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *year;

@end


/**
 *  The effective IAM policies on one resource.
 */
@interface GTLRCloudAsset_EffectiveIamPolicy : GTLRObject

/**
 *  The [full_resource_name]
 *  (https://cloud.google.com/asset-inventory/docs/resource-name-format) for
 *  which the policies are computed. This is one of the
 *  BatchGetEffectiveIamPoliciesRequest.names the caller provides in the
 *  request.
 */
@property(nonatomic, copy, nullable) NSString *fullResourceName;

/**
 *  The effective policies for the full_resource_name. These policies include
 *  the policy set on the full_resource_name and those set on its parents and
 *  ancestors up to the BatchGetEffectiveIamPoliciesRequest.scope. Note that
 *  these policies are not filtered according to the resource type of the
 *  full_resource_name. These policies are hierarchically ordered by
 *  PolicyInfo.attached_resource starting from full_resource_name itself to its
 *  parents and ancestors, such that policies[i]'s PolicyInfo.attached_resource
 *  is the child of policies[i+1]'s PolicyInfo.attached_resource, if
 *  policies[i+1] exists.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_PolicyInfo *> *policies;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRCloudAsset_Empty : GTLRObject
@end


/**
 *  Explanation about the IAM policy search result.
 */
@interface GTLRCloudAsset_Explanation : GTLRObject

/**
 *  The map from roles to their included permissions that match the permission
 *  query (i.e., a query containing `policy.role.permissions:`). Example: if
 *  query `policy.role.permissions:compute.disk.get` matches a policy binding
 *  that contains owner role, the matched_permissions will be `{"roles/owner":
 *  ["compute.disk.get"]}`. The roles can also be found in the returned `policy`
 *  bindings. Note that the map is populated only for requests with permission
 *  queries.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Explanation_MatchedPermissions *matchedPermissions;

@end


/**
 *  The map from roles to their included permissions that match the permission
 *  query (i.e., a query containing `policy.role.permissions:`). Example: if
 *  query `policy.role.permissions:compute.disk.get` matches a policy binding
 *  that contains owner role, the matched_permissions will be `{"roles/owner":
 *  ["compute.disk.get"]}`. The roles can also be found in the returned `policy`
 *  bindings. Note that the map is populated only for requests with permission
 *  queries.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudAsset_Permissions. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_Explanation_MatchedPermissions : GTLRObject
@end


/**
 *  Export asset request.
 */
@interface GTLRCloudAsset_ExportAssetsRequest : GTLRObject

/**
 *  A list of asset types to take a snapshot for. For example:
 *  "compute.googleapis.com/Disk". Regular expressions are also supported. For
 *  example: * "compute.googleapis.com.*" snapshots resources whose asset type
 *  starts with "compute.googleapis.com". * ".*Instance" snapshots resources
 *  whose asset type ends with "Instance". * ".*Instance.*" snapshots resources
 *  whose asset type contains "Instance". See
 *  [RE2](https://github.com/google/re2/wiki/Syntax) for all supported regular
 *  expression syntax. If the regular expression does not match any supported
 *  asset type, an INVALID_ARGUMENT error will be returned. If specified, only
 *  matching assets will be returned, otherwise, it will snapshot all asset
 *  types. See [Introduction to Cloud Asset
 *  Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
 *  supported asset types.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *assetTypes;

/**
 *  Asset content type. If not specified, no content but the asset name will be
 *  returned.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_AccessPolicy The
 *        Cloud Access context manager Policy set on an asset. (Value:
 *        "ACCESS_POLICY")
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_ContentTypeUnspecified
 *        Unspecified content type. (Value: "CONTENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_IamPolicy The
 *        actual IAM policy set on a resource. (Value: "IAM_POLICY")
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_OrgPolicy The
 *        Cloud Organization Policy set on an asset. (Value: "ORG_POLICY")
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_OsInventory The
 *        runtime OS Inventory information. (Value: "OS_INVENTORY")
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_Relationship The
 *        related resources. (Value: "RELATIONSHIP")
 *    @arg @c kGTLRCloudAsset_ExportAssetsRequest_ContentType_Resource Resource
 *        metadata. (Value: "RESOURCE")
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  Required. Output configuration indicating where the results will be output
 *  to.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_OutputConfig *outputConfig;

/**
 *  Timestamp to take an asset snapshot. This can only be set to a timestamp
 *  between the current time and the current time minus 35 days (inclusive). If
 *  not specified, the current time will be used. Due to delays in resource data
 *  collection and indexing, there is a volatile window during which running the
 *  same query may get different results.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTime;

/**
 *  A list of relationship types to export, for example:
 *  `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
 *  content_type=RELATIONSHIP. * If specified: it snapshots specified
 *  relationships. It returns an error if any of the [relationship_types]
 *  doesn't belong to the supported relationship types of the [asset_types] or
 *  if any of the [asset_types] doesn't belong to the source types of the
 *  [relationship_types]. * Otherwise: it snapshots the supported relationships
 *  for all [asset_types] or returns an error if any of the [asset_types] has no
 *  relationship support. An unspecified asset types field means all supported
 *  asset_types. See [Introduction to Cloud Asset
 *  Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
 *  supported asset types and relationship types.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *relationshipTypes;

@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRCloudAsset_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  An asset feed used to export asset updates to a destinations. An asset feed
 *  filter controls what updates are exported. The asset feed must be created
 *  within a project, organization, or folder. Supported destinations are:
 *  Pub/Sub topics.
 */
@interface GTLRCloudAsset_Feed : GTLRObject

/**
 *  A list of the full names of the assets to receive updates. You must specify
 *  either or both of asset_names and asset_types. Only asset updates matching
 *  specified asset_names or asset_types are exported to the feed. Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
 *  For a list of the full names for supported asset types, see [Resource name
 *  format](/asset-inventory/docs/resource-name-format).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *assetNames;

/**
 *  A list of types of the assets to receive updates. You must specify either or
 *  both of asset_names and asset_types. Only asset updates matching specified
 *  asset_names or asset_types are exported to the feed. Example:
 *  `"compute.googleapis.com/Disk"` For a list of all supported asset types, see
 *  [Supported asset types](/asset-inventory/docs/supported-asset-types).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *assetTypes;

/**
 *  A condition which determines whether an asset update should be published. If
 *  specified, an asset will be returned only when the expression evaluates to
 *  true. When set, `expression` field in the `Expr` must be a valid [CEL
 *  expression] (https://github.com/google/cel-spec) on a TemporalAsset with
 *  name `temporal_asset`. Example: a Feed with expression
 *  ("temporal_asset.deleted == true") will only publish Asset deletions. Other
 *  fields of `Expr` are optional. See our [user
 *  guide](https://cloud.google.com/asset-inventory/docs/monitoring-asset-changes-with-condition)
 *  for detailed instructions.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Expr *condition;

/**
 *  Asset content type. If not specified, no content but the asset name and type
 *  will be returned.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_AccessPolicy The Cloud Access
 *        context manager Policy set on an asset. (Value: "ACCESS_POLICY")
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_ContentTypeUnspecified
 *        Unspecified content type. (Value: "CONTENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_IamPolicy The actual IAM policy
 *        set on a resource. (Value: "IAM_POLICY")
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_OrgPolicy The Cloud Organization
 *        Policy set on an asset. (Value: "ORG_POLICY")
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_OsInventory The runtime OS
 *        Inventory information. (Value: "OS_INVENTORY")
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_Relationship The related
 *        resources. (Value: "RELATIONSHIP")
 *    @arg @c kGTLRCloudAsset_Feed_ContentType_Resource Resource metadata.
 *        (Value: "RESOURCE")
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  Required. Feed output configuration defining where the asset updates are
 *  published to.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_FeedOutputConfig *feedOutputConfig;

/**
 *  Required. The format will be
 *  projects/{project_number}/feeds/{client-assigned_feed_identifier} or
 *  folders/{folder_number}/feeds/{client-assigned_feed_identifier} or
 *  organizations/{organization_number}/feeds/{client-assigned_feed_identifier}
 *  The client-assigned feed identifier must be unique within the parent
 *  project/folder/organization.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A list of relationship types to output, for example:
 *  `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
 *  content_type=RELATIONSHIP. * If specified: it outputs specified relationship
 *  updates on the [asset_names] or the [asset_types]. It returns an error if
 *  any of the [relationship_types] doesn't belong to the supported relationship
 *  types of the [asset_names] or [asset_types], or any of the [asset_names] or
 *  the [asset_types] doesn't belong to the source types of the
 *  [relationship_types]. * Otherwise: it outputs the supported relationships of
 *  the types of [asset_names] and [asset_types] or returns an error if any of
 *  the [asset_names] or the [asset_types] has no replationship support. See
 *  [Introduction to Cloud Asset
 *  Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
 *  supported asset types and relationship types.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *relationshipTypes;

@end


/**
 *  Output configuration for asset feed destination.
 */
@interface GTLRCloudAsset_FeedOutputConfig : GTLRObject

/** Destination on Pub/Sub. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_PubsubDestination *pubsubDestination;

@end


/**
 *  A Cloud Storage location.
 */
@interface GTLRCloudAsset_GcsDestination : GTLRObject

/**
 *  The uri of the Cloud Storage object. It's the same uri that is used by
 *  gsutil. Example: "gs://bucket_name/object_name". See [Viewing and Editing
 *  Object
 *  Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
 *  for more information. If the specified Cloud Storage object already exists
 *  and there is no [hold](https://cloud.google.com/storage/docs/object-holds),
 *  it will be overwritten with the exported result.
 */
@property(nonatomic, copy, nullable) NSString *uri;

/**
 *  The uri prefix of all generated Cloud Storage objects. Example:
 *  "gs://bucket_name/object_name_prefix". Each object uri is in format:
 *  "gs://bucket_name/object_name_prefix// and only contains assets for that
 *  type. starts from 0. Example:
 *  "gs://bucket_name/object_name_prefix/compute.googleapis.com/Disk/0" is the
 *  first shard of output objects containing all compute.googleapis.com/Disk
 *  assets. An INVALID_ARGUMENT error will be returned if file with the same
 *  name "gs://bucket_name/object_name_prefix" already exists.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  An IAM role or permission under analysis.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1Access : GTLRObject

/** The analysis state of this access. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisState *analysisState;

/** The permission. */
@property(nonatomic, copy, nullable) NSString *permission;

/** The role. */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  An access control list, derived from the above IAM policy binding, which
 *  contains a set of resources and accesses. May include one item from each set
 *  to compose an access control entry. NOTICE that there could be multiple
 *  access control lists for one IAM policy binding. The access control lists
 *  are created based on resource and access combinations. For example, assume
 *  we have the following cases in one IAM policy binding: - Permission P1 and
 *  P2 apply to resource R1 and R2; - Permission P3 applies to resource R2 and
 *  R3; This will result in the following access control lists: -
 *  AccessControlList 1: [R1, R2], [P1, P2] - AccessControlList 2: [R2, R3],
 *  [P3]
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1AccessControlList : GTLRObject

/**
 *  The accesses that match one of the following conditions: - The
 *  access_selector, if it is specified in request; - Otherwise, access
 *  specifiers reachable from the policy binding's role.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1Access *> *accesses;

/**
 *  Condition evaluation for this AccessControlList, if there is a condition
 *  defined in the above IAM policy binding.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ConditionEvaluation *conditionEvaluation;

/**
 *  Resource edges of the graph starting from the policy attached resource to
 *  any descendant resources. The Edge.source_node contains the full resource
 *  name of a parent resource and Edge.target_node contains the full resource
 *  name of a child resource. This field is present only if the
 *  output_resource_edges option is enabled in request.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1Edge *> *resourceEdges;

/**
 *  The resources that match one of the following conditions: - The
 *  resource_selector, if it is specified in request; - Otherwise, resources
 *  reachable from the policy attached resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1Resource *> *resources;

@end


/**
 *  A BigQuery destination.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination : GTLRObject

/**
 *  Required. The BigQuery dataset in format
 *  "projects/projectId/datasets/datasetId", to which the analysis results
 *  should be exported. If this dataset does not exist, the export call will
 *  return an INVALID_ARGUMENT error.
 */
@property(nonatomic, copy, nullable) NSString *dataset;

/**
 *  The partition key for BigQuery partitioned table.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination_PartitionKey_PartitionKeyUnspecified
 *        Unspecified partition key. Tables won't be partitioned using this
 *        option. (Value: "PARTITION_KEY_UNSPECIFIED")
 *    @arg @c kGTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination_PartitionKey_RequestTime
 *        The time when the request is received. If specified as partition key,
 *        the result table(s) is partitoned by the RequestTime column, an
 *        additional timestamp column representing when the request was
 *        received. (Value: "REQUEST_TIME")
 */
@property(nonatomic, copy, nullable) NSString *partitionKey;

/**
 *  Required. The prefix of the BigQuery tables to which the analysis results
 *  will be written. Tables will be created based on this table_prefix if not
 *  exist: * _analysis table will contain export operation's metadata. *
 *  _analysis_result will contain all the IamPolicyAnalysisResult. When
 *  [partition_key] is specified, both tables will be partitioned based on the
 *  [partition_key].
 */
@property(nonatomic, copy, nullable) NSString *tablePrefix;

/**
 *  Optional. Specifies the action that occurs if the destination table or
 *  partition already exists. The following values are supported: *
 *  WRITE_TRUNCATE: If the table or partition already exists, BigQuery
 *  overwrites the entire table or all the partitions data. * WRITE_APPEND: If
 *  the table or partition already exists, BigQuery appends the data to the
 *  table or the latest partition. * WRITE_EMPTY: If the table already exists
 *  and contains data, an error is returned. The default value is WRITE_APPEND.
 *  Each action is atomic and only occurs if BigQuery is able to complete the
 *  job successfully. Details are at
 *  https://cloud.google.com/bigquery/docs/loading-data-local#appending_to_or_overwriting_a_table_using_a_local_file.
 */
@property(nonatomic, copy, nullable) NSString *writeDisposition;

@end


/**
 *  A directional edge.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1Edge : GTLRObject

/**
 *  The source node of the edge. For example, it could be a full resource name
 *  for a resource node or an email of an identity.
 */
@property(nonatomic, copy, nullable) NSString *sourceNode;

/**
 *  The target node of the edge. For example, it could be a full resource name
 *  for a resource node or an email of an identity.
 */
@property(nonatomic, copy, nullable) NSString *targetNode;

@end


/**
 *  A Cloud Storage location.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1GcsDestination : GTLRObject

/**
 *  Required. The uri of the Cloud Storage object. It's the same uri that is
 *  used by gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
 *  Editing Object
 *  Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
 *  for more information. If the specified Cloud Storage object already exists
 *  and there is no [hold](https://cloud.google.com/storage/docs/object-holds),
 *  it will be overwritten with the analysis result.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  An identity under analysis.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1Identity : GTLRObject

/** The analysis state of this identity. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisState *analysisState;

/**
 *  The identity name in any form of members appear in [IAM policy
 *  binding](https://cloud.google.com/iam/reference/rest/v1/Binding), such as: -
 *  user:foo\@google.com - group:group1\@google.com -
 *  serviceAccount:s1\@prj1.iam.gserviceaccount.com -
 *  projectOwner:some_project_id - domain:google.com - allUsers - etc.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The identities and group edges.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1IdentityList : GTLRObject

/**
 *  Group identity edges of the graph starting from the binding's group members
 *  to any node of the identities. The Edge.source_node contains a group, such
 *  as `group:parent\@google.com`. The Edge.target_node contains a member of the
 *  group, such as `group:child\@google.com` or `user:foo\@google.com`. This
 *  field is present only if the output_group_edges option is enabled in
 *  request.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1Edge *> *groupEdges;

/**
 *  Only the identities that match one of the following conditions will be
 *  presented: - The identity_selector, if it is specified in request; -
 *  Otherwise, identities reachable from the policy binding's members.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1Identity *> *identities;

@end


/**
 *  An asset in Google Cloud. An asset can be any resource in the Google Cloud
 *  [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  a resource outside the Google Cloud resource hierarchy (such as Google
 *  Kubernetes Engine clusters and objects), or a policy (e.g. Cloud IAM
 *  policy). See [Supported asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1p7beta1Asset : GTLRObject

/**
 *  Please also refer to the [access level user
 *  guide](https://cloud.google.com/access-context-manager/docs/overview#access-levels).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessLevel *accessLevel;

/**
 *  Please also refer to the [access policy user
 *  guide](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessPolicy *accessPolicy;

/**
 *  The ancestry path of an asset in Google Cloud [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  represented as a list of relative resource names. An ancestry path starts
 *  with the closest ancestor in the hierarchy and ends at root. If the asset is
 *  a project, folder, or organization, the ancestry path starts from the asset
 *  itself. Example: `["projects/123456789", "folders/5432",
 *  "organizations/1234"]`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ancestors;

/**
 *  The type of the asset. Example: `compute.googleapis.com/Disk` See [Supported
 *  asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  A representation of the Cloud IAM policy set on a Google Cloud resource.
 *  There can be a maximum of one Cloud IAM policy set on any given resource. In
 *  addition, Cloud IAM policies inherit their granted access scope from any
 *  policies set on parent resources in the resource hierarchy. Therefore, the
 *  effectively policy is the union of both the policy set on this resource and
 *  each policy set on all of the resource's ancestry resource levels in the
 *  hierarchy. See [this
 *  topic](https://cloud.google.com/iam/help/allow-policies/inheritance) for
 *  more information.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Policy *iamPolicy;

/**
 *  The full name of the asset. Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
 *  See [Resource
 *  names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A representation of an [organization
 *  policy](https://cloud.google.com/resource-manager/docs/organization-policy/overview#organization_policy).
 *  There can be more than one organization policy with different constraints
 *  set on a given resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudOrgpolicyV1Policy *> *orgPolicy;

/**
 *  The related assets of the asset of one relationship type. One asset only
 *  represents one type of relationship.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelatedAssets *relatedAssets;

/** A representation of the resource. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1p7beta1Resource *resource;

/**
 *  Please also refer to the [service perimeter user
 *  guide](https://cloud.google.com/vpc-service-controls/docs/overview).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter *servicePerimeter;

/**
 *  The last update timestamp of an asset. update_time is updated when
 *  create/update/delete operation is performed.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  An asset identify in Google Cloud which contains its name, type and
 *  ancestors. An asset can be any resource in the Google Cloud [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  a resource outside the Google Cloud resource hierarchy (such as Google
 *  Kubernetes Engine clusters and objects), or a policy (e.g. Cloud IAM
 *  policy). See [Supported asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelatedAsset : GTLRObject

/**
 *  The ancestors of an asset in Google Cloud [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  represented as a list of relative resource names. An ancestry path starts
 *  with the closest ancestor in the hierarchy and ends at root. Example:
 *  `["projects/123456789", "folders/5432", "organizations/1234"]`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ancestors;

/**
 *  The full name of the asset. Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
 *  See [Resource
 *  names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *asset;

/**
 *  The type of the asset. Example: `compute.googleapis.com/Disk` See [Supported
 *  asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *assetType;

@end


/**
 *  The detailed related assets with the `relationship_type`.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelatedAssets : GTLRObject

/** The peer resources of the relationship. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelatedAsset *> *assets;

/** The detailed relation attributes. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelationshipAttributes *relationshipAttributes;

@end


/**
 *  The relationship attributes which include `type`, `source_resource_type`,
 *  `target_resource_type` and `action`.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1p7beta1RelationshipAttributes : GTLRObject

/** The detail of the relationship, e.g. `contains`, `attaches` */
@property(nonatomic, copy, nullable) NSString *action;

/** The source asset type. Example: `compute.googleapis.com/Instance` */
@property(nonatomic, copy, nullable) NSString *sourceResourceType;

/** The target asset type. Example: `compute.googleapis.com/Disk` */
@property(nonatomic, copy, nullable) NSString *targetResourceType;

/**
 *  The unique identifier of the relationship type. Example:
 *  `INSTANCE_TO_INSTANCEGROUP`
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A representation of a Google Cloud resource.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1p7beta1Resource : GTLRObject

/**
 *  The content of the resource, in which some sensitive fields are removed and
 *  may not be present.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1p7beta1Resource_Data *data;

/**
 *  The URL of the discovery document containing the resource's JSON schema.
 *  Example: `https://www.googleapis.com/discovery/v1/apis/compute/v1/rest` This
 *  value is unspecified for resources that do not have an API based on a
 *  discovery document, such as Cloud Bigtable.
 */
@property(nonatomic, copy, nullable) NSString *discoveryDocumentUri;

/**
 *  The JSON schema name listed in the discovery document. Example: `Project`
 *  This value is unspecified for resources that do not have an API based on a
 *  discovery document, such as Cloud Bigtable.
 */
@property(nonatomic, copy, nullable) NSString *discoveryName;

/**
 *  The location of the resource in Google Cloud, such as its zone and region.
 *  For more information, see https://cloud.google.com/about/locations/.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The full name of the immediate parent of this resource. See [Resource
 *  Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
 *  for more information. For Google Cloud assets, this value is the parent
 *  resource defined in the [Cloud IAM policy
 *  hierarchy](https://cloud.google.com/iam/docs/overview#policy_hierarchy).
 *  Example: `//cloudresourcemanager.googleapis.com/projects/my_project_123` For
 *  third-party assets, this field may be set differently.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  The REST URL for accessing the resource. An HTTP `GET` request using this
 *  URL returns the resource itself. Example:
 *  `https://cloudresourcemanager.googleapis.com/v1/projects/my-project-123`
 *  This value is unspecified for resources without a REST API.
 */
@property(nonatomic, copy, nullable) NSString *resourceUrl;

/** The API version. Example: `v1` */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  The content of the resource, in which some sensitive fields are removed and
 *  may not be present.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1p7beta1Resource_Data : GTLRObject
@end


/**
 *  A Google Cloud resource under analysis.
 */
@interface GTLRCloudAsset_GoogleCloudAssetV1Resource : GTLRObject

/** The analysis state of this resource. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisState *analysisState;

/**
 *  The [full resource
 *  name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
 */
@property(nonatomic, copy, nullable) NSString *fullResourceName;

@end


/**
 *  Used in `policy_type` to specify how `boolean_policy` will behave at this
 *  resource.
 */
@interface GTLRCloudAsset_GoogleCloudOrgpolicyV1BooleanPolicy : GTLRObject

/**
 *  If `true`, then the `Policy` is enforced. If `false`, then any configuration
 *  is acceptable. Suppose you have a `Constraint`
 *  `constraints/compute.disableSerialPortAccess` with `constraint_default` set
 *  to `ALLOW`. A `Policy` for that `Constraint` exhibits the following
 *  behavior: - If the `Policy` at this resource has enforced set to `false`,
 *  serial port connection attempts will be allowed. - If the `Policy` at this
 *  resource has enforced set to `true`, serial port connection attempts will be
 *  refused. - If the `Policy` at this resource is `RestoreDefault`, serial port
 *  connection attempts will be allowed. - If no `Policy` is set at this
 *  resource or anywhere higher in the resource hierarchy, serial port
 *  connection attempts will be allowed. - If no `Policy` is set at this
 *  resource, but one exists higher in the resource hierarchy, the behavior is
 *  as if the`Policy` were set at this resource. The following examples
 *  demonstrate the different possible layerings: Example 1 (nearest
 *  `Constraint` wins): `organizations/foo` has a `Policy` with: {enforced:
 *  false} `projects/bar` has no `Policy` set. The constraint at `projects/bar`
 *  and `organizations/foo` will not be enforced. Example 2 (enforcement gets
 *  replaced): `organizations/foo` has a `Policy` with: {enforced: false}
 *  `projects/bar` has a `Policy` with: {enforced: true} The constraint at
 *  `organizations/foo` is not enforced. The constraint at `projects/bar` is
 *  enforced. Example 3 (RestoreDefault): `organizations/foo` has a `Policy`
 *  with: {enforced: true} `projects/bar` has a `Policy` with: {RestoreDefault:
 *  {}} The constraint at `organizations/foo` is enforced. The constraint at
 *  `projects/bar` is not enforced, because `constraint_default` for the
 *  `Constraint` is `ALLOW`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enforced;

@end


/**
 *  Used in `policy_type` to specify how `list_policy` behaves at this resource.
 *  `ListPolicy` can define specific values and subtrees of Cloud Resource
 *  Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that are
 *  allowed or denied by setting the `allowed_values` and `denied_values`
 *  fields. This is achieved by using the `under:` and optional `is:` prefixes.
 *  The `under:` prefix is used to denote resource subtree values. The `is:`
 *  prefix is used to denote specific values, and is required only if the value
 *  contains a ":". Values prefixed with "is:" are treated the same as values
 *  with no prefix. Ancestry subtrees must be in one of the following formats: -
 *  "projects/", e.g. "projects/tokyo-rain-123" - "folders/", e.g.
 *  "folders/1234" - "organizations/", e.g. "organizations/1234" The
 *  `supports_under` field of the associated `Constraint` defines whether
 *  ancestry prefixes can be used. You can set `allowed_values` and
 *  `denied_values` in the same `Policy` if `all_values` is
 *  `ALL_VALUES_UNSPECIFIED`. `ALLOW` or `DENY` are used to allow or deny all
 *  values. If `all_values` is set to either `ALLOW` or `DENY`, `allowed_values`
 *  and `denied_values` must be unset.
 */
@interface GTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy : GTLRObject

/**
 *  List of values allowed at this resource. Can only be set if `all_values` is
 *  set to `ALL_VALUES_UNSPECIFIED`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedValues;

/**
 *  The policy all_values state.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy_AllValues_Allow A
 *        policy with this set allows all values. (Value: "ALLOW")
 *    @arg @c kGTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy_AllValues_AllValuesUnspecified
 *        Indicates that allowed_values or denied_values must be set. (Value:
 *        "ALL_VALUES_UNSPECIFIED")
 *    @arg @c kGTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy_AllValues_Deny A
 *        policy with this set denies all values. (Value: "DENY")
 */
@property(nonatomic, copy, nullable) NSString *allValues;

/**
 *  List of values denied at this resource. Can only be set if `all_values` is
 *  set to `ALL_VALUES_UNSPECIFIED`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *deniedValues;

/**
 *  Determines the inheritance behavior for this `Policy`. By default, a
 *  `ListPolicy` set at a resource supersedes any `Policy` set anywhere up the
 *  resource hierarchy. However, if `inherit_from_parent` is set to `true`, then
 *  the values from the effective `Policy` of the parent resource are inherited,
 *  meaning the values set in this `Policy` are added to the values inherited up
 *  the hierarchy. Setting `Policy` hierarchies that inherit both allowed values
 *  and denied values isn't recommended in most circumstances to keep the
 *  configuration simple and understandable. However, it is possible to set a
 *  `Policy` with `allowed_values` set that inherits a `Policy` with
 *  `denied_values` set. In this case, the values that are allowed must be in
 *  `allowed_values` and not present in `denied_values`. For example, suppose
 *  you have a `Constraint` `constraints/serviceuser.services`, which has a
 *  `constraint_type` of `list_constraint`, and with `constraint_default` set to
 *  `ALLOW`. Suppose that at the Organization level, a `Policy` is applied that
 *  restricts the allowed API activations to {`E1`, `E2`}. Then, if a `Policy`
 *  is applied to a project below the Organization that has
 *  `inherit_from_parent` set to `false` and field all_values set to DENY, then
 *  an attempt to activate any API will be denied. The following examples
 *  demonstrate different possible layerings for `projects/bar` parented by
 *  `organizations/foo`: Example 1 (no inherited values): `organizations/foo`
 *  has a `Policy` with values: {allowed_values: "E1" allowed_values:"E2"}
 *  `projects/bar` has `inherit_from_parent` `false` and values:
 *  {allowed_values: "E3" allowed_values: "E4"} The accepted values at
 *  `organizations/foo` are `E1`, `E2`. The accepted values at `projects/bar`
 *  are `E3`, and `E4`. Example 2 (inherited values): `organizations/foo` has a
 *  `Policy` with values: {allowed_values: "E1" allowed_values:"E2"}
 *  `projects/bar` has a `Policy` with values: {value: "E3" value: "E4"
 *  inherit_from_parent: true} The accepted values at `organizations/foo` are
 *  `E1`, `E2`. The accepted values at `projects/bar` are `E1`, `E2`, `E3`, and
 *  `E4`. Example 3 (inheriting both allowed and denied values):
 *  `organizations/foo` has a `Policy` with values: {allowed_values: "E1"
 *  allowed_values: "E2"} `projects/bar` has a `Policy` with: {denied_values:
 *  "E1"} The accepted values at `organizations/foo` are `E1`, `E2`. The value
 *  accepted at `projects/bar` is `E2`. Example 4 (RestoreDefault):
 *  `organizations/foo` has a `Policy` with values: {allowed_values: "E1"
 *  allowed_values:"E2"} `projects/bar` has a `Policy` with values:
 *  {RestoreDefault: {}} The accepted values at `organizations/foo` are `E1`,
 *  `E2`. The accepted values at `projects/bar` are either all or none depending
 *  on the value of `constraint_default` (if `ALLOW`, all; if `DENY`, none).
 *  Example 5 (no policy inherits parent policy): `organizations/foo` has no
 *  `Policy` set. `projects/bar` has no `Policy` set. The accepted values at
 *  both levels are either all or none depending on the value of
 *  `constraint_default` (if `ALLOW`, all; if `DENY`, none). Example 6
 *  (ListConstraint allowing all): `organizations/foo` has a `Policy` with
 *  values: {allowed_values: "E1" allowed_values: "E2"} `projects/bar` has a
 *  `Policy` with: {all: ALLOW} The accepted values at `organizations/foo` are
 *  `E1`, E2`. Any value is accepted at `projects/bar`. Example 7
 *  (ListConstraint allowing none): `organizations/foo` has a `Policy` with
 *  values: {allowed_values: "E1" allowed_values: "E2"} `projects/bar` has a
 *  `Policy` with: {all: DENY} The accepted values at `organizations/foo` are
 *  `E1`, E2`. No value is accepted at `projects/bar`. Example 10 (allowed and
 *  denied subtrees of Resource Manager hierarchy): Given the following resource
 *  hierarchy O1->{F1, F2}; F1->{P1}; F2->{P2, P3}, `organizations/foo` has a
 *  `Policy` with values: {allowed_values: "under:organizations/O1"}
 *  `projects/bar` has a `Policy` with: {allowed_values: "under:projects/P3"}
 *  {denied_values: "under:folders/F2"} The accepted values at
 *  `organizations/foo` are `organizations/O1`, `folders/F1`, `folders/F2`,
 *  `projects/P1`, `projects/P2`, `projects/P3`. The accepted values at
 *  `projects/bar` are `organizations/O1`, `folders/F1`, `projects/P1`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inheritFromParent;

/**
 *  Optional. The Google Cloud Console will try to default to a configuration
 *  that matches the value specified in this `Policy`. If `suggested_value` is
 *  not set, it will inherit the value specified higher in the hierarchy, unless
 *  `inherit_from_parent` is `false`.
 */
@property(nonatomic, copy, nullable) NSString *suggestedValue;

@end


/**
 *  Defines a Cloud Organization `Policy` which is used to specify `Constraints`
 *  for configurations of Cloud Platform resources.
 */
@interface GTLRCloudAsset_GoogleCloudOrgpolicyV1Policy : GTLRObject

/** For boolean `Constraints`, whether to enforce the `Constraint` or not. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudOrgpolicyV1BooleanPolicy *booleanPolicy;

/**
 *  The name of the `Constraint` the `Policy` is configuring, for example,
 *  `constraints/serviceuser.services`. A [list of available
 *  constraints](/resource-manager/docs/organization-policy/org-policy-constraints)
 *  is available. Immutable after creation.
 */
@property(nonatomic, copy, nullable) NSString *constraint;

/**
 *  An opaque tag indicating the current version of the `Policy`, used for
 *  concurrency control. When the `Policy` is returned from either a `GetPolicy`
 *  or a `ListOrgPolicy` request, this `etag` indicates the version of the
 *  current `Policy` to use when executing a read-modify-write loop. When the
 *  `Policy` is returned from a `GetEffectivePolicy` request, the `etag` will be
 *  unset. When the `Policy` is used in a `SetOrgPolicy` method, use the `etag`
 *  value that was returned from a `GetOrgPolicy` request as part of a
 *  read-modify-write loop for concurrency control. Not setting the `etag`in a
 *  `SetOrgPolicy` request will result in an unconditional write of the
 *  `Policy`.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** List of values either allowed or disallowed. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudOrgpolicyV1ListPolicy *listPolicy;

/**
 *  Restores the default behavior of the constraint; independent of `Constraint`
 *  type.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudOrgpolicyV1RestoreDefault *restoreDefault;

/**
 *  The time stamp the `Policy` was previously updated. This is set by the
 *  server, not specified by the caller, and represents the last time a call to
 *  `SetOrgPolicy` was made for that `Policy`. Any value set by the client will
 *  be ignored.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Version of the `Policy`. Default version is 0;
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Ignores policies set above this resource and restores the
 *  `constraint_default` enforcement behavior of the specific `Constraint` at
 *  this resource. Suppose that `constraint_default` is set to `ALLOW` for the
 *  `Constraint` `constraints/serviceuser.services`. Suppose that organization
 *  foo.com sets a `Policy` at their Organization resource node that restricts
 *  the allowed service activations to deny all service activations. They could
 *  then set a `Policy` with the `policy_type` `restore_default` on several
 *  experimental projects, restoring the `constraint_default` enforcement of the
 *  `Constraint` for only those projects, allowing those projects to have all
 *  services activated.
 */
@interface GTLRCloudAsset_GoogleCloudOrgpolicyV1RestoreDefault : GTLRObject
@end


/**
 *  An `AccessLevel` is a label that can be applied to requests to Google Cloud
 *  services, along with a list of requirements necessary for the label to be
 *  applied.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessLevel : GTLRObject

/** A `BasicLevel` composed of `Conditions`. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel *basic;

/** A `CustomLevel` written in the Common Expression Language. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1CustomLevel *custom;

/**
 *  Description of the `AccessLevel` and its use. Does not affect behavior.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. Resource name for the Access Level. The `short_name` component
 *  must begin with a letter and only include alphanumeric and '_'. Format:
 *  `accessPolicies/{access_policy}/accessLevels/{access_level}`. The maximum
 *  length of the `access_level` component is 50 characters.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Human readable title. Must be unique within the Policy. */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  `AccessPolicy` is a container for `AccessLevels` (which define the necessary
 *  attributes to use Google Cloud services) and `ServicePerimeters` (which
 *  define regions of services able to freely pass data within a perimeter). An
 *  access policy is globally visible within an organization, and the
 *  restrictions it specifies apply to all projects within an organization.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1AccessPolicy : GTLRObject

/**
 *  Output only. An opaque identifier for the current version of the
 *  `AccessPolicy`. This will always be a strongly validated etag, meaning that
 *  two Access Polices will be identical if and only if their etags are
 *  identical. Clients should not expect this to be in any specific format.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. Resource name of the `AccessPolicy`. Format:
 *  `accessPolicies/{access_policy}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The parent of this `AccessPolicy` in the Cloud Resource Hierarchy.
 *  Currently immutable once created. Format: `organizations/{organization_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  The scopes of a policy define which resources an ACM policy can restrict,
 *  and where ACM resources can be referenced. For example, a policy with
 *  scopes=["folders/123"] has the following behavior: - vpcsc perimeters can
 *  only restrict projects within folders/123 - access levels can only be
 *  referenced by resources within folders/123. If empty, there are no
 *  limitations on which resources can be restricted by an ACM policy, and there
 *  are no limitations on where ACM resources can be referenced. Only one policy
 *  can include a given scope (attempting to create a second policy which
 *  includes "folders/123" will result in an error). Currently, scopes cannot be
 *  modified after a policy is created. Currently, policies can only have a
 *  single scope. Format: list of `folders/{folder_number}` or
 *  `projects/{project_number}`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *scopes;

/** Required. Human readable title. Does not affect behavior. */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Identification for an API Operation.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ApiOperation : GTLRObject

/**
 *  API methods or permissions to allow. Method or permission must belong to the
 *  service specified by `service_name` field. A single MethodSelector entry
 *  with `*` specified for the `method` field will allow all methods AND
 *  permissions for the service specified in `service_name`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1MethodSelector *> *methodSelectors;

/**
 *  The name of the API whose methods or permissions the IngressPolicy or
 *  EgressPolicy want to allow. A single ApiOperation with `service_name` field
 *  set to `*` will allow all methods AND permissions for all services.
 */
@property(nonatomic, copy, nullable) NSString *serviceName;

@end


/**
 *  `BasicLevel` is an `AccessLevel` using a set of recommended features.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel : GTLRObject

/**
 *  How the `conditions` list should be combined to determine if a request is
 *  granted this `AccessLevel`. If AND is used, each `Condition` in `conditions`
 *  must be satisfied for the `AccessLevel` to be applied. If OR is used, at
 *  least one `Condition` in `conditions` must be satisfied for the
 *  `AccessLevel` to be applied. Default behavior is AND.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel_CombiningFunction_And
 *        All `Conditions` must be true for the `BasicLevel` to be true. (Value:
 *        "AND")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1BasicLevel_CombiningFunction_Or
 *        If at least one `Condition` is true, then the `BasicLevel` is true.
 *        (Value: "OR")
 */
@property(nonatomic, copy, nullable) NSString *combiningFunction;

/** Required. A list of requirements for the `AccessLevel` to be granted. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1Condition *> *conditions;

@end


/**
 *  A condition necessary for an `AccessLevel` to be granted. The Condition is
 *  an AND over its fields. So a Condition is true if: 1) the request IP is from
 *  one of the listed subnetworks AND 2) the originating device complies with
 *  the listed device policy AND 3) all listed access levels are granted AND 4)
 *  the request was sent at a time allowed by the DateTimeRestriction.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1Condition : GTLRObject

/**
 *  Device specific restrictions, all restrictions must hold for the Condition
 *  to be true. If not specified, all devices are allowed.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy *devicePolicy;

/**
 *  CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a
 *  CIDR IP address block, the specified IP address portion must be properly
 *  truncated (i.e. all the host bits must be zero) or the input is considered
 *  malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is
 *  not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas
 *  "2001:db8::1/32" is not. The originating IP of a request must be in one of
 *  the listed subnets in order for this Condition to be true. If empty, all IP
 *  addresses are allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ipSubnetworks;

/**
 *  The request must be made by one of the provided user or service accounts.
 *  Groups are not supported. Syntax: `user:{emailid}`
 *  `serviceAccount:{emailid}` If not specified, a request may come from any
 *  user.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Whether to negate the Condition. If true, the Condition becomes a NAND over
 *  its non-empty fields, each field must be false for the Condition overall to
 *  be satisfied. Defaults to false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *negate;

/**
 *  The request must originate from one of the provided countries/regions. Must
 *  be valid ISO 3166-1 alpha-2 codes.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *regions;

/**
 *  A list of other access levels defined in the same `Policy`, referenced by
 *  resource name. Referencing an `AccessLevel` which does not exist is an
 *  error. All access levels listed must be granted for the Condition to be
 *  true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *requiredAccessLevels;

@end


/**
 *  `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language
 *  to represent the necessary conditions for the level to apply to a request.
 *  See CEL spec at: https://github.com/google/cel-spec
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1CustomLevel : GTLRObject

/** Required. A Cloud CEL expression evaluating to a boolean. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Expr *expr;

@end


/**
 *  `DevicePolicy` specifies device specific restrictions necessary to acquire a
 *  given access level. A `DevicePolicy` specifies requirements for requests
 *  from devices to be granted access levels, it does not do any enforcement on
 *  the device. `DevicePolicy` acts as an AND over all specified fields, and
 *  each repeated field is an OR over its elements. Any unset fields are
 *  ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type :
 *  DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be
 *  true for requests originating from encrypted Linux desktops and encrypted
 *  Windows desktops.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1DevicePolicy : GTLRObject

/**
 *  Allowed device management levels, an empty list allows all management
 *  levels.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedDeviceManagementLevels;

/** Allowed encryptions statuses, an empty list allows all statuses. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedEncryptionStatuses;

/** Allowed OS versions, an empty list allows all types and all versions. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint *> *osConstraints;

/**
 *  Whether the device needs to be approved by the customer admin.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requireAdminApproval;

/**
 *  Whether the device needs to be corp owned.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requireCorpOwned;

/**
 *  Whether or not screenlock is required for the DevicePolicy to be true.
 *  Defaults to `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requireScreenlock;

@end


/**
 *  Defines the conditions under which an EgressPolicy matches a request.
 *  Conditions based on information about the source of the request. Note that
 *  if the destination of the request is also protected by a ServicePerimeter,
 *  then that ServicePerimeter must have an IngressPolicy which allows access in
 *  order for this request to succeed.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom : GTLRObject

/**
 *  A list of identities that are allowed access through this [EgressPolicy].
 *  Should be in the format of email address. The email address should represent
 *  individual user or service account only.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *identities;

/**
 *  Specifies the type of identities that are allowed access to outside the
 *  perimeter. If left unspecified, then members of `identities` field will be
 *  allowed access.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_AnyIdentity
 *        Authorize access from all identities outside the perimeter. (Value:
 *        "ANY_IDENTITY")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_AnyServiceAccount
 *        Authorize access from all service accounts outside the perimeter.
 *        (Value: "ANY_SERVICE_ACCOUNT")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_AnyUserAccount
 *        Authorize access from all human users outside the perimeter. (Value:
 *        "ANY_USER_ACCOUNT")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom_IdentityType_IdentityTypeUnspecified
 *        No blanket identity group specified. (Value:
 *        "IDENTITY_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *identityType;

@end


/**
 *  Policy for egress from perimeter. EgressPolicies match requests based on
 *  `egress_from` and `egress_to` stanzas. For an EgressPolicy to match, both
 *  `egress_from` and `egress_to` stanzas must be matched. If an EgressPolicy
 *  matches a request, the request is allowed to span the ServicePerimeter
 *  boundary. For example, an EgressPolicy can be used to allow VMs on networks
 *  within the ServicePerimeter to access a defined set of projects outside the
 *  perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket
 *  or query against a BigQuery dataset). EgressPolicies are concerned with the
 *  *resources* that a request relates as well as the API services and API
 *  actions being used. They do not related to the direction of data movement.
 *  More detailed documentation for this concept can be found in the
 *  descriptions of EgressFrom and EgressTo.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressPolicy : GTLRObject

/**
 *  Defines conditions on the source of a request causing this EgressPolicy to
 *  apply.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressFrom *egressFrom;

/**
 *  Defines the conditions on the ApiOperation and destination resources that
 *  cause this EgressPolicy to apply.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressTo *egressTo;

@end


/**
 *  Defines the conditions under which an EgressPolicy matches a request.
 *  Conditions are based on information about the ApiOperation intended to be
 *  performed on the `resources` specified. Note that if the destination of the
 *  request is also protected by a ServicePerimeter, then that ServicePerimeter
 *  must have an IngressPolicy which allows access in order for this request to
 *  succeed. The request must match `operations` AND `resources` fields in order
 *  to be allowed egress out of the perimeter.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressTo : GTLRObject

/**
 *  A list of external resources that are allowed to be accessed. Only AWS and
 *  Azure resources are supported. For Amazon S3, the supported format is
 *  s3://BUCKET_NAME. For Azure Storage, the supported format is
 *  azure://myaccount.blob.core.windows.net/CONTAINER_NAME. A request matches if
 *  it contains an external resource in this list (Example: s3://bucket/path).
 *  Currently '*' is not allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *externalResources;

/**
 *  A list of ApiOperations allowed to be performed by the sources specified in
 *  the corresponding EgressFrom. A request matches if it uses an
 *  operation/service in this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ApiOperation *> *operations;

/**
 *  A list of resources, currently only projects in the form `projects/`, that
 *  are allowed to be accessed by sources defined in the corresponding
 *  EgressFrom. A request matches if it contains a resource in this list. If `*`
 *  is specified for `resources`, then this EgressTo rule will authorize access
 *  to all resources outside the perimeter.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resources;

@end


/**
 *  Defines the conditions under which an IngressPolicy matches a request.
 *  Conditions are based on information about the source of the request. The
 *  request must satisfy what is defined in `sources` AND identity related
 *  fields in order to match.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom : GTLRObject

/**
 *  A list of identities that are allowed access through this ingress policy.
 *  Should be in the format of email address. The email address should represent
 *  individual user or service account only.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *identities;

/**
 *  Specifies the type of identities that are allowed access from outside the
 *  perimeter. If left unspecified, then members of `identities` field will be
 *  allowed access.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_AnyIdentity
 *        Authorize access from all identities outside the perimeter. (Value:
 *        "ANY_IDENTITY")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_AnyServiceAccount
 *        Authorize access from all service accounts outside the perimeter.
 *        (Value: "ANY_SERVICE_ACCOUNT")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_AnyUserAccount
 *        Authorize access from all human users outside the perimeter. (Value:
 *        "ANY_USER_ACCOUNT")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom_IdentityType_IdentityTypeUnspecified
 *        No blanket identity group specified. (Value:
 *        "IDENTITY_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *identityType;

/** Sources that this IngressPolicy authorizes access from. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressSource *> *sources;

@end


/**
 *  Policy for ingress into ServicePerimeter. IngressPolicies match requests
 *  based on `ingress_from` and `ingress_to` stanzas. For an ingress policy to
 *  match, both the `ingress_from` and `ingress_to` stanzas must be matched. If
 *  an IngressPolicy matches a request, the request is allowed through the
 *  perimeter boundary from outside the perimeter. For example, access from the
 *  internet can be allowed either based on an AccessLevel or, for traffic
 *  hosted on Google Cloud, the project of the source network. For access from
 *  private networks, using the project of the hosting network is required.
 *  Individual ingress policies can be limited by restricting which services
 *  and/or actions they match using the `ingress_to` field.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressPolicy : GTLRObject

/**
 *  Defines the conditions on the source of a request causing this IngressPolicy
 *  to apply.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressFrom *ingressFrom;

/**
 *  Defines the conditions on the ApiOperation and request destination that
 *  cause this IngressPolicy to apply.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressTo *ingressTo;

@end


/**
 *  The source that IngressPolicy authorizes access from.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressSource : GTLRObject

/**
 *  An AccessLevel resource name that allow resources within the
 *  ServicePerimeters to be accessed from the internet. AccessLevels listed must
 *  be in the same policy as this ServicePerimeter. Referencing a nonexistent
 *  AccessLevel will cause an error. If no AccessLevel names are listed,
 *  resources within the perimeter can only be accessed via Google Cloud calls
 *  with request origins within the perimeter. Example:
 *  `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is
 *  specified for `access_level`, then all IngressSources will be allowed.
 */
@property(nonatomic, copy, nullable) NSString *accessLevel;

/**
 *  A Google Cloud resource that is allowed to ingress the perimeter. Requests
 *  from these resources will be allowed to access perimeter data. Currently
 *  only projects are allowed. Format: `projects/{project_number}` The project
 *  may be in any Google Cloud organization, not just the organization that the
 *  perimeter is defined in. `*` is not allowed, the case of allowing all Google
 *  Cloud resources only is not supported.
 */
@property(nonatomic, copy, nullable) NSString *resource;

@end


/**
 *  Defines the conditions under which an IngressPolicy matches a request.
 *  Conditions are based on information about the ApiOperation intended to be
 *  performed on the target resource of the request. The request must satisfy
 *  what is defined in `operations` AND `resources` in order to match.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressTo : GTLRObject

/**
 *  A list of ApiOperations allowed to be performed by the sources specified in
 *  corresponding IngressFrom in this ServicePerimeter.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ApiOperation *> *operations;

/**
 *  A list of resources, currently only projects in the form `projects/`,
 *  protected by this ServicePerimeter that are allowed to be accessed by
 *  sources defined in the corresponding IngressFrom. If a single `*` is
 *  specified, then access to all resources inside the perimeter are allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resources;

@end


/**
 *  An allowed method or permission of a service specified in ApiOperation.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1MethodSelector : GTLRObject

/**
 *  Value for `method` should be a valid method name for the corresponding
 *  `service_name` in ApiOperation. If `*` used as value for `method`, then ALL
 *  methods and permissions are allowed.
 */
@property(nonatomic, copy, nullable) NSString *method;

/**
 *  Value for `permission` should be a valid Cloud IAM permission for the
 *  corresponding `service_name` in ApiOperation.
 */
@property(nonatomic, copy, nullable) NSString *permission;

@end


/**
 *  A restriction on the OS type and version of devices making requests.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint : GTLRObject

/**
 *  The minimum allowed OS version. If not set, any version of this OS satisfies
 *  the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`,
 *  `"9.2.1"`.
 */
@property(nonatomic, copy, nullable) NSString *minimumVersion;

/**
 *  Required. The allowed OS type.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_Android
 *        An Android operating system. (Value: "ANDROID")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopChromeOs
 *        A desktop ChromeOS operating system. (Value: "DESKTOP_CHROME_OS")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopLinux
 *        A desktop Linux operating system. (Value: "DESKTOP_LINUX")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopMac
 *        A desktop Mac operating system. (Value: "DESKTOP_MAC")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_DesktopWindows
 *        A desktop Windows operating system. (Value: "DESKTOP_WINDOWS")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_Ios
 *        An iOS operating system. (Value: "IOS")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1OsConstraint_OsType_OsUnspecified
 *        The operating system of the device is not specified or not known.
 *        (Value: "OS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *osType;

/**
 *  Only allows requests from devices with a verified Chrome OS. Verifications
 *  includes requirements that the device is enterprise-managed, conformant to
 *  domain policies, and the caller has permission to call the API targeted by
 *  the request.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requireVerifiedChromeOs;

@end


/**
 *  `ServicePerimeter` describes a set of Google Cloud resources which can
 *  freely import and export data amongst themselves, but not export outside of
 *  the `ServicePerimeter`. If a request with a source within this
 *  `ServicePerimeter` has a target outside of the `ServicePerimeter`, the
 *  request will be blocked. Otherwise the request is allowed. There are two
 *  types of Service Perimeter - Regular and Bridge. Regular Service Perimeters
 *  cannot overlap, a single Google Cloud project can only belong to a single
 *  regular Service Perimeter. Service Perimeter Bridges can contain only Google
 *  Cloud projects as members, a single Google Cloud project may belong to
 *  multiple Service Perimeter Bridges.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter : GTLRObject

/**
 *  Description of the `ServicePerimeter` and its use. Does not affect behavior.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. Resource name for the ServicePerimeter. The `short_name` component
 *  must begin with a letter and only include alphanumeric and '_'. Format:
 *  `accessPolicies/{access_policy}/servicePerimeters/{service_perimeter}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Perimeter type indicator. A single project is allowed to be a member of
 *  single regular perimeter, but multiple service perimeter bridges. A project
 *  cannot be a included in a perimeter bridge without being included in regular
 *  perimeter. For perimeter bridges, the restricted service list as well as
 *  access level lists must be empty.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter_PerimeterType_PerimeterTypeBridge
 *        Perimeter Bridge. (Value: "PERIMETER_TYPE_BRIDGE")
 *    @arg @c kGTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeter_PerimeterType_PerimeterTypeRegular
 *        Regular Perimeter. (Value: "PERIMETER_TYPE_REGULAR")
 */
@property(nonatomic, copy, nullable) NSString *perimeterType;

/**
 *  Proposed (or dry run) ServicePerimeter configuration. This configuration
 *  allows to specify and test ServicePerimeter configuration without enforcing
 *  actual access restrictions. Only allowed to be set when the
 *  "use_explicit_dry_run_spec" flag is set.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeterConfig *spec;

/**
 *  Current ServicePerimeter configuration. Specifies sets of resources,
 *  restricted services and access levels that determine perimeter content and
 *  boundaries.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeterConfig *status;

/** Human readable title. Must be unique within the Policy. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists
 *  for all Service Perimeters, and that spec is identical to the status for
 *  those Service Perimeters. When this flag is set, it inhibits the generation
 *  of the implicit spec, thereby allowing the user to explicitly provide a
 *  configuration ("spec") to use in a dry-run version of the Service Perimeter.
 *  This allows the user to test changes to the enforced config ("status")
 *  without actually enforcing them. This testing is done through analyzing the
 *  differences between currently enforced and suggested restrictions.
 *  use_explicit_dry_run_spec must bet set to True if any of the fields in the
 *  spec are set to non-default values.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useExplicitDryRunSpec;

@end


/**
 *  `ServicePerimeterConfig` specifies a set of Google Cloud resources that
 *  describe specific Service Perimeter configuration.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1ServicePerimeterConfig : GTLRObject

/**
 *  A list of `AccessLevel` resource names that allow resources within the
 *  `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed
 *  must be in the same policy as this `ServicePerimeter`. Referencing a
 *  nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are
 *  listed, resources within the perimeter can only be accessed via Google Cloud
 *  calls with request origins within the perimeter. Example:
 *  `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter
 *  Bridge, must be empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accessLevels;

/**
 *  List of EgressPolicies to apply to the perimeter. A perimeter may have
 *  multiple EgressPolicies, each of which is evaluated separately. Access is
 *  granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1EgressPolicy *> *egressPolicies;

/**
 *  List of IngressPolicies to apply to the perimeter. A perimeter may have
 *  multiple IngressPolicies, each of which is evaluated separately. Access is
 *  granted if any Ingress Policy grants it. Must be empty for a perimeter
 *  bridge.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1IngressPolicy *> *ingressPolicies;

/**
 *  A list of Google Cloud resources that are inside of the service perimeter.
 *  Currently only projects are allowed. Format: `projects/{project_number}`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resources;

/**
 *  Google Cloud services that are subject to the Service Perimeter
 *  restrictions. For example, if `storage.googleapis.com` is specified, access
 *  to the storage buckets inside the perimeter must meet the perimeter's access
 *  restrictions.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *restrictedServices;

/** Configuration for APIs allowed within Perimeter. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1VpcAccessibleServices *vpcAccessibleServices;

@end


/**
 *  Specifies how APIs are allowed to communicate within the Service Perimeter.
 */
@interface GTLRCloudAsset_GoogleIdentityAccesscontextmanagerV1VpcAccessibleServices : GTLRObject

/**
 *  The list of APIs usable within the Service Perimeter. Must be empty unless
 *  'enable_restriction' is True. You can specify a list of individual services,
 *  as well as include the 'RESTRICTED-SERVICES' value, which automatically
 *  includes all of the services protected by the perimeter.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedServices;

/**
 *  Whether to restrict API calls within the Service Perimeter to the list of
 *  APIs specified in 'allowed_services'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableRestriction;

@end


/**
 *  An analysis message to group the query and results.
 */
@interface GTLRCloudAsset_IamPolicyAnalysis : GTLRObject

/** The analysis query. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisQuery *analysisQuery;

/**
 *  A list of IamPolicyAnalysisResult that matches the analysis query, or empty
 *  if no result is found.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_IamPolicyAnalysisResult *> *analysisResults;

/**
 *  Represents whether all entries in the analysis_results have been fully
 *  explored to answer the query.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fullyExplored;

/** A list of non-critical errors happened during the query handling. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_IamPolicyAnalysisState *> *nonCriticalErrors;

@end


/**
 *  Output configuration for export IAM policy analysis destination.
 */
@interface GTLRCloudAsset_IamPolicyAnalysisOutputConfig : GTLRObject

/** Destination on BigQuery. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1BigQueryDestination *bigqueryDestination;

/** Destination on Cloud Storage. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1GcsDestination *gcsDestination;

@end


/**
 *  IAM policy analysis query message.
 */
@interface GTLRCloudAsset_IamPolicyAnalysisQuery : GTLRObject

/**
 *  Optional. Specifies roles or permissions for analysis. This is optional.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_AccessSelector *accessSelector;

/** Optional. The hypothetical context for IAM conditions evaluation. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ConditionContext *conditionContext;

/** Optional. Specifies an identity for analysis. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IdentitySelector *identitySelector;

/** Optional. The query options. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Options *options;

/** Optional. Specifies a resource for analysis. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ResourceSelector *resourceSelector;

/**
 *  Required. The relative name of the root asset. Only resources and IAM
 *  policies within the scope will be analyzed. This can only be an organization
 *  number (such as "organizations/123"), a folder number (such as
 *  "folders/123"), a project ID (such as "projects/my-project-id"), or a
 *  project number (such as "projects/12345"). To know how to get organization
 *  id, visit [here
 *  ](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
 *  To know how to get folder or project id, visit [here
 *  ](https://cloud.google.com/resource-manager/docs/creating-managing-folders#viewing_or_listing_folders_and_projects).
 */
@property(nonatomic, copy, nullable) NSString *scope;

@end


/**
 *  IAM Policy analysis result, consisting of one IAM policy binding and derived
 *  access control lists.
 */
@interface GTLRCloudAsset_IamPolicyAnalysisResult : GTLRObject

/**
 *  The access control lists derived from the iam_binding that match or
 *  potentially match resource and access selectors specified in the request.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_GoogleCloudAssetV1AccessControlList *> *accessControlLists;

/**
 *  The [full resource
 *  name](https://cloud.google.com/asset-inventory/docs/resource-name-format) of
 *  the resource to which the iam_binding policy attaches.
 */
@property(nonatomic, copy, nullable) NSString *attachedResourceFullName;

/**
 *  Represents whether all analyses on the iam_binding have successfully
 *  finished.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fullyExplored;

/** The Cloud IAM policy binding under analysis. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Binding *iamBinding;

/**
 *  The identity list derived from members of the iam_binding that match or
 *  potentially match identity selector specified in the request.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GoogleCloudAssetV1IdentityList *identityList;

@end


/**
 *  Represents the detailed state of an entity under analysis, such as a
 *  resource, an identity or an access.
 */
@interface GTLRCloudAsset_IamPolicyAnalysisState : GTLRObject

/** The human-readable description of the cause of failure. */
@property(nonatomic, copy, nullable) NSString *cause;

/**
 *  The Google standard error code that best describes the state. For example: -
 *  OK means the analysis on this entity has been successfully finished; -
 *  PERMISSION_DENIED means an access denied error is encountered; -
 *  DEADLINE_EXCEEDED means the analysis on this entity hasn't been started in
 *  time;
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Aborted The operation
 *        was aborted, typically due to a concurrency issue such as a sequencer
 *        check failure or transaction abort. See the guidelines above for
 *        deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`.
 *        HTTP Mapping: 409 Conflict (Value: "ABORTED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_AlreadyExists The
 *        entity that a client attempted to create (e.g., file or directory)
 *        already exists. HTTP Mapping: 409 Conflict (Value: "ALREADY_EXISTS")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Cancelled The
 *        operation was cancelled, typically by the caller. HTTP Mapping: 499
 *        Client Closed Request (Value: "CANCELLED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_DataLoss Unrecoverable
 *        data loss or corruption. HTTP Mapping: 500 Internal Server Error
 *        (Value: "DATA_LOSS")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_DeadlineExceeded The
 *        deadline expired before the operation could complete. For operations
 *        that change the state of the system, this error may be returned even
 *        if the operation has completed successfully. For example, a successful
 *        response from a server could have been delayed long enough for the
 *        deadline to expire. HTTP Mapping: 504 Gateway Timeout (Value:
 *        "DEADLINE_EXCEEDED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_FailedPrecondition The
 *        operation was rejected because the system is not in a state required
 *        for the operation's execution. For example, the directory to be
 *        deleted is non-empty, an rmdir operation is applied to a
 *        non-directory, etc. Service implementors can use the following
 *        guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and
 *        `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the
 *        failing call. (b) Use `ABORTED` if the client should retry at a higher
 *        level. For example, when a client-specified test-and-set fails,
 *        indicating the client should restart a read-modify-write sequence. (c)
 *        Use `FAILED_PRECONDITION` if the client should not retry until the
 *        system state has been explicitly fixed. For example, if an "rmdir"
 *        fails because the directory is non-empty, `FAILED_PRECONDITION` should
 *        be returned since the client should not retry unless the files are
 *        deleted from the directory. HTTP Mapping: 400 Bad Request (Value:
 *        "FAILED_PRECONDITION")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Internal Internal
 *        errors. This means that some invariants expected by the underlying
 *        system have been broken. This error code is reserved for serious
 *        errors. HTTP Mapping: 500 Internal Server Error (Value: "INTERNAL")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_InvalidArgument The
 *        client specified an invalid argument. Note that this differs from
 *        `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are
 *        problematic regardless of the state of the system (e.g., a malformed
 *        file name). HTTP Mapping: 400 Bad Request (Value: "INVALID_ARGUMENT")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_NotFound Some
 *        requested entity (e.g., file or directory) was not found. Note to
 *        server developers: if a request is denied for an entire class of
 *        users, such as gradual feature rollout or undocumented allowlist,
 *        `NOT_FOUND` may be used. If a request is denied for some users within
 *        a class of users, such as user-based access control,
 *        `PERMISSION_DENIED` must be used. HTTP Mapping: 404 Not Found (Value:
 *        "NOT_FOUND")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Ok Not an error;
 *        returned on success. HTTP Mapping: 200 OK (Value: "OK")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_OutOfRange The
 *        operation was attempted past the valid range. E.g., seeking or reading
 *        past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a
 *        problem that may be fixed if the system state changes. For example, a
 *        32-bit file system will generate `INVALID_ARGUMENT` if asked to read
 *        at an offset that is not in the range [0,2^32-1], but it will generate
 *        `OUT_OF_RANGE` if asked to read from an offset past the current file
 *        size. There is a fair bit of overlap between `FAILED_PRECONDITION` and
 *        `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific
 *        error) when it applies so that callers who are iterating through a
 *        space can easily look for an `OUT_OF_RANGE` error to detect when they
 *        are done. HTTP Mapping: 400 Bad Request (Value: "OUT_OF_RANGE")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_PermissionDenied The
 *        caller does not have permission to execute the specified operation.
 *        `PERMISSION_DENIED` must not be used for rejections caused by
 *        exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those
 *        errors). `PERMISSION_DENIED` must not be used if the caller can not be
 *        identified (use `UNAUTHENTICATED` instead for those errors). This
 *        error code does not imply the request is valid or the requested entity
 *        exists or satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
 *        (Value: "PERMISSION_DENIED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_ResourceExhausted Some
 *        resource has been exhausted, perhaps a per-user quota, or perhaps the
 *        entire file system is out of space. HTTP Mapping: 429 Too Many
 *        Requests (Value: "RESOURCE_EXHAUSTED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unauthenticated The
 *        request does not have valid authentication credentials for the
 *        operation. HTTP Mapping: 401 Unauthorized (Value: "UNAUTHENTICATED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unavailable The
 *        service is currently unavailable. This is most likely a transient
 *        condition, which can be corrected by retrying with a backoff. Note
 *        that it is not always safe to retry non-idempotent operations. See the
 *        guidelines above for deciding between `FAILED_PRECONDITION`,
 *        `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
 *        (Value: "UNAVAILABLE")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unimplemented The
 *        operation is not implemented or is not supported/enabled in this
 *        service. HTTP Mapping: 501 Not Implemented (Value: "UNIMPLEMENTED")
 *    @arg @c kGTLRCloudAsset_IamPolicyAnalysisState_Code_Unknown Unknown error.
 *        For example, this error may be returned when a `Status` value received
 *        from another address space belongs to an error space that is not known
 *        in this address space. Also errors raised by APIs that do not return
 *        enough error information may be converted to this error. HTTP Mapping:
 *        500 Internal Server Error (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  A result of IAM Policy search, containing information of an IAM policy.
 */
@interface GTLRCloudAsset_IamPolicySearchResult : GTLRObject

/**
 *  The type of the resource associated with this IAM policy. Example:
 *  `compute.googleapis.com/Disk`. To search against the `asset_type`: * specify
 *  the `asset_types` field in your search request.
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  Explanation about the IAM policy search result. It contains additional
 *  information to explain why the search result matches the query.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Explanation *explanation;

/**
 *  The folder(s) that the IAM policy belongs to, in the form of
 *  folders/{FOLDER_NUMBER}. This field is available when the IAM policy belongs
 *  to one or more folders. To search against `folders`: * use a field query.
 *  Example: `folders:(123 OR 456)` * use a free text query. Example: `123` *
 *  specify the `scope` field as this folder in your search request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *folders;

/**
 *  The organization that the IAM policy belongs to, in the form of
 *  organizations/{ORGANIZATION_NUMBER}. This field is available when the IAM
 *  policy belongs to an organization. To search against `organization`: * use a
 *  field query. Example: `organization:123` * use a free text query. Example:
 *  `123` * specify the `scope` field as this organization in your search
 *  request.
 */
@property(nonatomic, copy, nullable) NSString *organization;

/**
 *  The IAM policy directly set on the given resource. Note that the original
 *  IAM policy can contain multiple bindings. This only contains the bindings
 *  that match the given query. For queries that don't contain a constrain on
 *  policies (e.g., an empty query), this contains all the bindings. To search
 *  against the `policy` bindings: * use a field query: - query by the policy
 *  contained members. Example: `policy:amy\@gmail.com` - query by the policy
 *  contained roles. Example: `policy:roles/compute.admin` - query by the policy
 *  contained roles' included permissions. Example:
 *  `policy.role.permissions:compute.instances.create`
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Policy *policy;

/**
 *  The project that the associated GCP resource belongs to, in the form of
 *  projects/{PROJECT_NUMBER}. If an IAM policy is set on a resource (like VM
 *  instance, Cloud Storage bucket), the project field will indicate the project
 *  that contains the resource. If an IAM policy is set on a folder or
 *  orgnization, this field will be empty. To search against the `project`: *
 *  specify the `scope` field as this project in your search request.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The full resource name of the resource associated with this IAM policy.
 *  Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
 *  See [Cloud Asset Inventory Resource Name
 *  Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
 *  for more information. To search against the `resource`: * use a field query.
 *  Example: `resource:organizations/123`
 */
@property(nonatomic, copy, nullable) NSString *resource;

@end


/**
 *  Specifies an identity for which to determine resource access, based on roles
 *  assigned either directly to them or to the groups they belong to, directly
 *  or indirectly.
 */
@interface GTLRCloudAsset_IdentitySelector : GTLRObject

/**
 *  Required. The identity appear in the form of principals in [IAM policy
 *  binding](https://cloud.google.com/iam/reference/rest/v1/Binding). The
 *  examples of supported forms are: "user:mike\@example.com",
 *  "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com". Notice that
 *  wildcard characters (such as * and ?) are not supported. You must give a
 *  specific identity.
 */
@property(nonatomic, copy, nullable) NSString *identity;

@end


/**
 *  This API resource represents the available inventory data for a Compute
 *  Engine virtual machine (VM) instance at a given point in time. You can use
 *  this API resource to determine the inventory data of your VM. For more
 *  information, see [Information provided by OS inventory
 *  management](https://cloud.google.com/compute/docs/instances/os-inventory-management#data-collected).
 */
@interface GTLRCloudAsset_Inventory : GTLRObject

/**
 *  Inventory items related to the VM keyed by an opaque unique identifier for
 *  each inventory item. The identifier is unique to each distinct and
 *  addressable inventory item and will change, when there is a new package
 *  version.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Inventory_Items *items;

/**
 *  Output only. The `Inventory` API resource name. Format:
 *  `projects/{project_number}/locations/{location}/instances/{instance_id}/inventory`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Base level operating system information for the VM. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_OsInfo *osInfo;

/** Output only. Timestamp of the last reported inventory for the VM. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Inventory items related to the VM keyed by an opaque unique identifier for
 *  each inventory item. The identifier is unique to each distinct and
 *  addressable inventory item and will change, when there is a new package
 *  version.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudAsset_Item. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_Inventory_Items : GTLRObject
@end


/**
 *  A single piece of inventory on a VM.
 */
@interface GTLRCloudAsset_Item : GTLRObject

/** Software package available to be installed on the VM instance. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_SoftwarePackage *availablePackage;

/** When this inventory item was first detected. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Identifier for this item, unique across items for this VM.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Software package present on the VM instance. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_SoftwarePackage *installedPackage;

/**
 *  The origin of this inventory item.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_Item_OriginType_InventoryReport This inventory
 *        item was discovered as the result of the agent reporting inventory via
 *        the reporting API. (Value: "INVENTORY_REPORT")
 *    @arg @c kGTLRCloudAsset_Item_OriginType_OriginTypeUnspecified Invalid. An
 *        origin type must be specified. (Value: "ORIGIN_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *originType;

/**
 *  The specific type of inventory, correlating to its specific details.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_Item_Type_AvailablePackage This represents an
 *        update that is available for a package. (Value: "AVAILABLE_PACKAGE")
 *    @arg @c kGTLRCloudAsset_Item_Type_InstalledPackage This represents a
 *        package that is installed on the VM. (Value: "INSTALLED_PACKAGE")
 *    @arg @c kGTLRCloudAsset_Item_Type_TypeUnspecified Invalid. An type must be
 *        specified. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

/** When this inventory item was last modified. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  ListAssets response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "assets" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudAsset_ListAssetsResponse : GTLRCollectionObject

/**
 *  Assets.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_Asset *> *assets;

/**
 *  Token to retrieve the next page of results. It expires 72 hours after the
 *  page token for the first page is generated. Set to empty if there are no
 *  remaining results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Time the snapshot was taken. */
@property(nonatomic, strong, nullable) GTLRDateTime *readTime;

@end


/**
 *  GTLRCloudAsset_ListFeedsResponse
 */
@interface GTLRCloudAsset_ListFeedsResponse : GTLRObject

/** A list of feeds. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_Feed *> *feeds;

@end


/**
 *  Response of listing saved queries.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "savedQueries" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudAsset_ListSavedQueriesResponse : GTLRCollectionObject

/**
 *  A token, which can be sent as `page_token` to retrieve the next page. If
 *  this field is omitted, there are no subsequent pages.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of savedQueries.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_SavedQuery *> *savedQueries;

@end


/**
 *  A message to group the analysis information.
 */
@interface GTLRCloudAsset_MoveAnalysis : GTLRObject

/** Analysis result of moving the target resource. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_MoveAnalysisResult *analysis;

/**
 *  The user friendly display name of the analysis. E.g. IAM, Organization
 *  Policy etc.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Description of error encountered when performing the analysis. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Status *error;

@end


/**
 *  An analysis result including blockers and warnings.
 */
@interface GTLRCloudAsset_MoveAnalysisResult : GTLRObject

/**
 *  Blocking information that would prevent the target resource from moving to
 *  the specified destination at runtime.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_MoveImpact *> *blockers;

/**
 *  Warning information indicating that moving the target resource to the
 *  specified destination might be unsafe. This can include important policy
 *  information and configuration changes, but will not block moves at runtime.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_MoveImpact *> *warnings;

@end


/**
 *  A message to group impacts of moving the target resource.
 */
@interface GTLRCloudAsset_MoveImpact : GTLRObject

/** User friendly impact detail in a free form message. */
@property(nonatomic, copy, nullable) NSString *detail;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRCloudAsset_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_Operation_Response : GTLRObject
@end


/**
 *  Contains query options.
 */
@interface GTLRCloudAsset_Options : GTLRObject

/**
 *  Optional. If true, the response will include access analysis from identities
 *  to resources via service account impersonation. This is a very expensive
 *  operation, because many derived queries will be executed. We highly
 *  recommend you use AssetService.AnalyzeIamPolicyLongrunning rpc instead. For
 *  example, if the request analyzes for which resources user A has permission
 *  P, and there's an IAM policy states user A has
 *  iam.serviceAccounts.getAccessToken permission to a service account SA, and
 *  there's another IAM policy states service account SA has permission P to a
 *  GCP folder F, then user A potentially has access to the GCP folder F. And
 *  those advanced analysis results will be included in
 *  AnalyzeIamPolicyResponse.service_account_impersonation_analysis. Another
 *  example, if the request analyzes for who has permission P to a GCP folder F,
 *  and there's an IAM policy states user A has iam.serviceAccounts.actAs
 *  permission to a service account SA, and there's another IAM policy states
 *  service account SA has permission P to the GCP folder F, then user A
 *  potentially has access to the GCP folder F. And those advanced analysis
 *  results will be included in
 *  AnalyzeIamPolicyResponse.service_account_impersonation_analysis. Only the
 *  following permissions are considered in this analysis: *
 *  `iam.serviceAccounts.actAs` * `iam.serviceAccounts.signBlob` *
 *  `iam.serviceAccounts.signJwt` * `iam.serviceAccounts.getAccessToken` *
 *  `iam.serviceAccounts.getOpenIdToken` *
 *  `iam.serviceAccounts.implicitDelegation` Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *analyzeServiceAccountImpersonation;

/**
 *  Optional. If true, the identities section of the result will expand any
 *  Google groups appearing in an IAM policy binding. If
 *  IamPolicyAnalysisQuery.identity_selector is specified, the identity in the
 *  result will be determined by the selector, and this flag is not allowed to
 *  set. If true, the default max expansion per group is 1000 for
 *  AssetService.AnalyzeIamPolicy][]. Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *expandGroups;

/**
 *  Optional. If true and IamPolicyAnalysisQuery.resource_selector is not
 *  specified, the resource section of the result will expand any resource
 *  attached to an IAM policy to include resources lower in the resource
 *  hierarchy. For example, if the request analyzes for which resources user A
 *  has permission P, and the results include an IAM policy with P on a GCP
 *  folder, the results will also include resources in that folder with
 *  permission P. If true and IamPolicyAnalysisQuery.resource_selector is
 *  specified, the resource section of the result will expand the specified
 *  resource to include resources lower in the resource hierarchy. Only project
 *  or lower resources are supported. Folder and organization resource cannot be
 *  used together with this option. For example, if the request analyzes for
 *  which users have permission P on a GCP project with this option enabled, the
 *  results will include all users who have permission P on that project or any
 *  lower resource. If true, the default max expansion per resource is 1000 for
 *  AssetService.AnalyzeIamPolicy][] and 100000 for
 *  AssetService.AnalyzeIamPolicyLongrunning][]. Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *expandResources;

/**
 *  Optional. If true, the access section of result will expand any roles
 *  appearing in IAM policy bindings to include their permissions. If
 *  IamPolicyAnalysisQuery.access_selector is specified, the access section of
 *  the result will be determined by the selector, and this flag is not allowed
 *  to set. Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *expandRoles;

/**
 *  Optional. If true, the result will output the relevant membership
 *  relationships between groups and other groups, and between groups and
 *  principals. Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outputGroupEdges;

/**
 *  Optional. If true, the result will output the relevant parent/child
 *  relationships between resources. Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outputResourceEdges;

@end


/**
 *  Operating system information for the VM.
 */
@interface GTLRCloudAsset_OsInfo : GTLRObject

/** The system architecture of the operating system. */
@property(nonatomic, copy, nullable) NSString *architecture;

/** The VM hostname. */
@property(nonatomic, copy, nullable) NSString *hostname;

/** The kernel release of the operating system. */
@property(nonatomic, copy, nullable) NSString *kernelRelease;

/** The kernel version of the operating system. */
@property(nonatomic, copy, nullable) NSString *kernelVersion;

/**
 *  The operating system long name. For example 'Debian GNU/Linux 9' or
 *  'Microsoft Window Server 2019 Datacenter'.
 */
@property(nonatomic, copy, nullable) NSString *longName;

/** The current version of the OS Config agent running on the VM. */
@property(nonatomic, copy, nullable) NSString *osconfigAgentVersion;

/** The operating system short name. For example, 'windows' or 'debian'. */
@property(nonatomic, copy, nullable) NSString *shortName;

/** The version of the operating system. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Output configuration for export assets destination.
 */
@interface GTLRCloudAsset_OutputConfig : GTLRObject

/**
 *  Destination on BigQuery. The output table stores the fields in asset
 *  Protobuf as columns in BigQuery.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_BigQueryDestination *bigqueryDestination;

/** Destination on Cloud Storage. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_GcsDestination *gcsDestination;

@end


/**
 *  Specifications of BigQuery partitioned table as export destination.
 */
@interface GTLRCloudAsset_PartitionSpec : GTLRObject

/**
 *  The partition key for BigQuery partitioned table.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_PartitionSpec_PartitionKey_PartitionKeyUnspecified
 *        Unspecified partition key. If used, it means using non-partitioned
 *        table. (Value: "PARTITION_KEY_UNSPECIFIED")
 *    @arg @c kGTLRCloudAsset_PartitionSpec_PartitionKey_ReadTime The time when
 *        the snapshot is taken. If specified as partition key, the result
 *        table(s) is partitoned by the additional timestamp column, readTime.
 *        If [read_time] in ExportAssetsRequest is specified, the readTime
 *        column's value will be the same as it. Otherwise, its value will be
 *        the current time that is used to take the snapshot. (Value:
 *        "READ_TIME")
 *    @arg @c kGTLRCloudAsset_PartitionSpec_PartitionKey_RequestTime The time
 *        when the request is received and started to be processed. If specified
 *        as partition key, the result table(s) is partitoned by the requestTime
 *        column, an additional timestamp column representing when the request
 *        was received. (Value: "REQUEST_TIME")
 */
@property(nonatomic, copy, nullable) NSString *partitionKey;

@end


/**
 *  IAM permissions
 */
@interface GTLRCloudAsset_Permissions : GTLRObject

/** A list of permissions. A sample permission string: `compute.disk.get`. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRCloudAsset_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  The IAM policy and its attached resource.
 */
@interface GTLRCloudAsset_PolicyInfo : GTLRObject

/** The full resource name the policy is directly attached to. */
@property(nonatomic, copy, nullable) NSString *attachedResource;

/** The IAM policy that's directly attached to the attached_resource. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Policy *policy;

@end


/**
 *  A Pub/Sub destination.
 */
@interface GTLRCloudAsset_PubsubDestination : GTLRObject

/**
 *  The name of the Pub/Sub topic to publish to. Example:
 *  `projects/PROJECT_ID/topics/TOPIC_ID`.
 */
@property(nonatomic, copy, nullable) NSString *topic;

@end


/**
 *  The query content.
 */
@interface GTLRCloudAsset_QueryContent : GTLRObject

/**
 *  An IAM Policy Analysis query, which could be used in the
 *  AssetService.AnalyzeIamPolicy rpc or the
 *  AssetService.AnalyzeIamPolicyLongrunning rpc.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_IamPolicyAnalysisQuery *iamPolicyAnalysisQuery;

@end


/**
 *  An asset identifier in Google Cloud which contains its name, type and
 *  ancestors. An asset can be any resource in the Google Cloud [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  a resource outside the Google Cloud resource hierarchy (such as Google
 *  Kubernetes Engine clusters and objects), or a policy (e.g. Cloud IAM
 *  policy). See [Supported asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@interface GTLRCloudAsset_RelatedAsset : GTLRObject

/**
 *  The ancestors of an asset in Google Cloud [resource
 *  hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 *  represented as a list of relative resource names. An ancestry path starts
 *  with the closest ancestor in the hierarchy and ends at root. Example:
 *  `["projects/123456789", "folders/5432", "organizations/1234"]`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ancestors;

/**
 *  The full name of the asset. Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
 *  See [Resource
 *  names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *asset;

/**
 *  The type of the asset. Example: `compute.googleapis.com/Disk` See [Supported
 *  asset
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 *  for more information.
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  The unique identifier of the relationship type. Example:
 *  `INSTANCE_TO_INSTANCEGROUP`
 */
@property(nonatomic, copy, nullable) NSString *relationshipType;

@end


/**
 *  DEPRECATED. This message only presents for the purpose of
 *  backward-compatibility. The server will never populate this message in
 *  responses. The detailed related assets with the `relationship_type`.
 */
@interface GTLRCloudAsset_RelatedAssets : GTLRObject

/** The peer resources of the relationship. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_RelatedAsset *> *assets;

/** The detailed relationship attributes. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_RelationshipAttributes *relationshipAttributes;

@end


/**
 *  The detailed related resource.
 */
@interface GTLRCloudAsset_RelatedResource : GTLRObject

/** The type of the asset. Example: `compute.googleapis.com/Instance` */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  The full resource name of the related resource. Example:
 *  `//compute.googleapis.com/projects/my_proj_123/zones/instance/instance123`
 */
@property(nonatomic, copy, nullable) NSString *fullResourceName;

@end


/**
 *  The related resources of the primary resource.
 */
@interface GTLRCloudAsset_RelatedResources : GTLRObject

/** The detailed related resources of the primary resource. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_RelatedResource *> *relatedResources;

@end


/**
 *  DEPRECATED. This message only presents for the purpose of
 *  backward-compatibility. The server will never populate this message in
 *  responses. The relationship attributes which include `type`,
 *  `source_resource_type`, `target_resource_type` and `action`.
 */
@interface GTLRCloudAsset_RelationshipAttributes : GTLRObject

/** The detail of the relationship, e.g. `contains`, `attaches` */
@property(nonatomic, copy, nullable) NSString *action;

/** The source asset type. Example: `compute.googleapis.com/Instance` */
@property(nonatomic, copy, nullable) NSString *sourceResourceType;

/** The target asset type. Example: `compute.googleapis.com/Disk` */
@property(nonatomic, copy, nullable) NSString *targetResourceType;

/**
 *  The unique identifier of the relationship type. Example:
 *  `INSTANCE_TO_INSTANCEGROUP`
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A representation of a Google Cloud resource.
 */
@interface GTLRCloudAsset_Resource : GTLRObject

/**
 *  The content of the resource, in which some sensitive fields are removed and
 *  may not be present.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Resource_Data *data;

/**
 *  The URL of the discovery document containing the resource's JSON schema.
 *  Example: `https://www.googleapis.com/discovery/v1/apis/compute/v1/rest` This
 *  value is unspecified for resources that do not have an API based on a
 *  discovery document, such as Cloud Bigtable.
 */
@property(nonatomic, copy, nullable) NSString *discoveryDocumentUri;

/**
 *  The JSON schema name listed in the discovery document. Example: `Project`
 *  This value is unspecified for resources that do not have an API based on a
 *  discovery document, such as Cloud Bigtable.
 */
@property(nonatomic, copy, nullable) NSString *discoveryName;

/**
 *  The location of the resource in Google Cloud, such as its zone and region.
 *  For more information, see https://cloud.google.com/about/locations/.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The full name of the immediate parent of this resource. See [Resource
 *  Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
 *  for more information. For Google Cloud assets, this value is the parent
 *  resource defined in the [Cloud IAM policy
 *  hierarchy](https://cloud.google.com/iam/docs/overview#policy_hierarchy).
 *  Example: `//cloudresourcemanager.googleapis.com/projects/my_project_123` For
 *  third-party assets, this field may be set differently.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  The REST URL for accessing the resource. An HTTP `GET` request using this
 *  URL returns the resource itself. Example:
 *  `https://cloudresourcemanager.googleapis.com/v1/projects/my-project-123`
 *  This value is unspecified for resources without a REST API.
 */
@property(nonatomic, copy, nullable) NSString *resourceUrl;

/** The API version. Example: `v1` */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  The content of the resource, in which some sensitive fields are removed and
 *  may not be present.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_Resource_Data : GTLRObject
@end


/**
 *  A result of Resource Search, containing information of a cloud resource.
 *  Next ID: 31
 */
@interface GTLRCloudAsset_ResourceSearchResult : GTLRObject

/**
 *  The additional searchable attributes of this resource. The attributes may
 *  vary from one resource type to another. Examples: `projectId` for Project,
 *  `dnsName` for DNS ManagedZone. This field contains a subset of the resource
 *  metadata fields that are returned by the List or Get APIs provided by the
 *  corresponding GCP service (e.g., Compute Engine). see [API references and
 *  supported searchable
 *  attributes](https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types)
 *  to see which fields are included. You can search values of these fields
 *  through free text search. However, you should not consume the field
 *  programically as the field names and values may change as the GCP service
 *  updates to a new incompatible API version. To search against the
 *  `additional_attributes`: * Use a free text query to match the attributes
 *  values. Example: to search `additional_attributes = { dnsName: "foobar" }`,
 *  you can issue a query `foobar`.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ResourceSearchResult_AdditionalAttributes *additionalAttributes;

/**
 *  The type of this resource. Example: `compute.googleapis.com/Disk`. To search
 *  against the `asset_type`: * Specify the `asset_type` field in your search
 *  request.
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  Attached resources of this resource. For example, an OSConfig Inventory is
 *  an attached resource of a Compute Instance. This field is repeated because a
 *  resource could have multiple attached resources. This `attached_resources`
 *  field is not searchable. Some attributes of the attached resources are
 *  exposed in `additional_attributes` field, so as to allow users to search on
 *  them.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_AttachedResource *> *attachedResources;

/**
 *  The create timestamp of this resource, at which the resource was created.
 *  The granularity is in seconds. Timestamp.nanos will always be 0. This field
 *  is available only when the resource's Protobuf contains it. To search
 *  against `create_time`: * Use a field query. - value in seconds since unix
 *  epoch. Example: `createTime > 1609459200` - value in date string. Example:
 *  `createTime > 2021-01-01` - value in date-time string (must be quoted).
 *  Example: `createTime > "2021-01-01T00:00:00"`
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  One or more paragraphs of text description of this resource. Maximum length
 *  could be up to 1M bytes. This field is available only when the resource's
 *  Protobuf contains it. To search against the `description`: * Use a field
 *  query. Example: `description:"important instance"` * Use a free text query.
 *  Example: `"important instance"`
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The display name of this resource. This field is available only when the
 *  resource's Protobuf contains it. To search against the `display_name`: * Use
 *  a field query. Example: `displayName:"My Instance"` * Use a free text query.
 *  Example: `"My Instance"`
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The folder(s) that this resource belongs to, in the form of
 *  folders/{FOLDER_NUMBER}. This field is available when the resource belongs
 *  to one or more folders. To search against `folders`: * Use a field query.
 *  Example: `folders:(123 OR 456)` * Use a free text query. Example: `123` *
 *  Specify the `scope` field as this folder in your search request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *folders;

/**
 *  The Cloud KMS
 *  [CryptoKey](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys)
 *  name or
 *  [CryptoKeyVersion](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions)
 *  name. This field only presents for the purpose of backward compatibility.
 *  Please use the `kms_keys` field to retrieve KMS key information. This field
 *  is available only when the resource's Protobuf contains it and will only be
 *  populated for [these resource
 *  types](https://cloud.google.com/asset-inventory/docs/legacy-field-names#resource_types_with_the_to_be_deprecated_kmskey_field)
 *  for backward compatible purposes. To search against the `kms_key`: * Use a
 *  field query. Example: `kmsKey:key` * Use a free text query. Example: `key`
 */
@property(nonatomic, copy, nullable) NSString *kmsKey;

/**
 *  The Cloud KMS
 *  [CryptoKey](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys)
 *  names or
 *  [CryptoKeyVersion](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions)
 *  names. This field is available only when the resource's Protobuf contains
 *  it. To search against the `kms_keys`: * Use a field query. Example:
 *  `kmsKeys:key` * Use a free text query. Example: `key`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kmsKeys;

/**
 *  Labels associated with this resource. See [Labelling and grouping GCP
 *  resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
 *  for more information. This field is available only when the resource's
 *  Protobuf contains it. To search against the `labels`: * Use a field query: -
 *  query on any label's key or value. Example: `labels:prod` - query by a given
 *  label. Example: `labels.env:prod` - query by a given label's existence.
 *  Example: `labels.env:*` * Use a free text query. Example: `prod`
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ResourceSearchResult_Labels *labels;

/**
 *  Location can be `global`, regional like `us-east1`, or zonal like
 *  `us-west1-b`. This field is available only when the resource's Protobuf
 *  contains it. To search against the `location`: * Use a field query. Example:
 *  `location:us-west*` * Use a free text query. Example: `us-west*`
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The full resource name of this resource. Example:
 *  `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
 *  See [Cloud Asset Inventory Resource Name
 *  Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
 *  for more information. To search against the `name`: * Use a field query.
 *  Example: `name:instance1` * Use a free text query. Example: `instance1`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Network tags associated with this resource. Like labels, network tags are a
 *  type of annotations used to group GCP resources. See [Labelling GCP
 *  resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
 *  for more information. This field is available only when the resource's
 *  Protobuf contains it. To search against the `network_tags`: * Use a field
 *  query. Example: `networkTags:internal` * Use a free text query. Example:
 *  `internal`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *networkTags;

/**
 *  The organization that this resource belongs to, in the form of
 *  organizations/{ORGANIZATION_NUMBER}. This field is available when the
 *  resource belongs to an organization. To search against `organization`: * Use
 *  a field query. Example: `organization:123` * Use a free text query. Example:
 *  `123` * Specify the `scope` field as this organization in your search
 *  request.
 */
@property(nonatomic, copy, nullable) NSString *organization;

/**
 *  The type of this resource's immediate parent, if there is one. To search
 *  against the `parent_asset_type`: * Use a field query. Example:
 *  `parentAssetType:"cloudresourcemanager.googleapis.com/Project"` * Use a free
 *  text query. Example: `cloudresourcemanager.googleapis.com/Project`
 */
@property(nonatomic, copy, nullable) NSString *parentAssetType;

/**
 *  The full resource name of this resource's parent, if it has one. To search
 *  against the `parent_full_resource_name`: * Use a field query. Example:
 *  `parentFullResourceName:"project-name"` * Use a free text query. Example:
 *  `project-name`
 */
@property(nonatomic, copy, nullable) NSString *parentFullResourceName;

/**
 *  The project that this resource belongs to, in the form of
 *  projects/{PROJECT_NUMBER}. This field is available when the resource belongs
 *  to a project. To search against `project`: * Use a field query. Example:
 *  `project:12345` * Use a free text query. Example: `12345` * Specify the
 *  `scope` field as this project in your search request.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  A map of related resources of this resource, keyed by the relationship type.
 *  A relationship type is in the format of {SourceType}_{ACTION}_{DestType}.
 *  Example: `DISK_TO_INSTANCE`, `DISK_TO_NETWORK`, `INSTANCE_TO_INSTANCEGROUP`.
 *  See [supported relationship
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#supported_relationship_types).
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ResourceSearchResult_Relationships *relationships;

/**
 *  The state of this resource. Different resources types have different state
 *  definitions that are mapped from various fields of different resource types.
 *  This field is available only when the resource's Protobuf contains it.
 *  Example: If the resource is an instance provided by Compute Engine, its
 *  state will include PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING,
 *  SUSPENDED, REPAIRING, and TERMINATED. See `status` definition in [API
 *  Reference](https://cloud.google.com/compute/docs/reference/rest/v1/instances).
 *  If the resource is a project provided by Cloud Resource Manager, its state
 *  will include LIFECYCLE_STATE_UNSPECIFIED, ACTIVE, DELETE_REQUESTED and
 *  DELETE_IN_PROGRESS. See `lifecycleState` definition in [API
 *  Reference](https://cloud.google.com/resource-manager/reference/rest/v1/projects).
 *  To search against the `state`: * Use a field query. Example: `state:RUNNING`
 *  * Use a free text query. Example: `RUNNING`
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  TagKey namespaced names, in the format of {ORG_ID}/{TAG_KEY_SHORT_NAME}. To
 *  search against the `tagKeys`: * Use a field query. Example: -
 *  `tagKeys:"123456789/env*"` - `tagKeys="123456789/env"` - `tagKeys:"env"` *
 *  Use a free text query. Example: - `env`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tagKeys;

/**
 *  TagValue IDs, in the format of tagValues/{TAG_VALUE_ID}. To search against
 *  the `tagValueIds`: * Use a field query. Example: - `tagValueIds:"456"` -
 *  `tagValueIds="tagValues/456"` * Use a free text query. Example: - `456`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tagValueIds;

/**
 *  TagValue namespaced names, in the format of
 *  {ORG_ID}/{TAG_KEY_SHORT_NAME}/{TAG_VALUE_SHORT_NAME}. To search against the
 *  `tagValues`: * Use a field query. Example: - `tagValues:"env"` -
 *  `tagValues:"env/prod"` - `tagValues:"123456789/env/prod*"` -
 *  `tagValues="123456789/env/prod"` * Use a free text query. Example: - `prod`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tagValues;

/**
 *  The last update timestamp of this resource, at which the resource was last
 *  modified or deleted. The granularity is in seconds. Timestamp.nanos will
 *  always be 0. This field is available only when the resource's Protobuf
 *  contains it. To search against `update_time`: * Use a field query. - value
 *  in seconds since unix epoch. Example: `updateTime < 1609459200` - value in
 *  date string. Example: `updateTime < 2021-01-01` - value in date-time string
 *  (must be quoted). Example: `updateTime < "2021-01-01T00:00:00"`
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Versioned resource representations of this resource. This is repeated
 *  because there could be multiple versions of resource representations during
 *  version migration. This `versioned_resources` field is not searchable. Some
 *  attributes of the resource representations are exposed in
 *  `additional_attributes` field, so as to allow users to search on them.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_VersionedResource *> *versionedResources;

@end


/**
 *  The additional searchable attributes of this resource. The attributes may
 *  vary from one resource type to another. Examples: `projectId` for Project,
 *  `dnsName` for DNS ManagedZone. This field contains a subset of the resource
 *  metadata fields that are returned by the List or Get APIs provided by the
 *  corresponding GCP service (e.g., Compute Engine). see [API references and
 *  supported searchable
 *  attributes](https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types)
 *  to see which fields are included. You can search values of these fields
 *  through free text search. However, you should not consume the field
 *  programically as the field names and values may change as the GCP service
 *  updates to a new incompatible API version. To search against the
 *  `additional_attributes`: * Use a free text query to match the attributes
 *  values. Example: to search `additional_attributes = { dnsName: "foobar" }`,
 *  you can issue a query `foobar`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_ResourceSearchResult_AdditionalAttributes : GTLRObject
@end


/**
 *  Labels associated with this resource. See [Labelling and grouping GCP
 *  resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
 *  for more information. This field is available only when the resource's
 *  Protobuf contains it. To search against the `labels`: * Use a field query: -
 *  query on any label's key or value. Example: `labels:prod` - query by a given
 *  label. Example: `labels.env:prod` - query by a given label's existence.
 *  Example: `labels.env:*` * Use a free text query. Example: `prod`
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudAsset_ResourceSearchResult_Labels : GTLRObject
@end


/**
 *  A map of related resources of this resource, keyed by the relationship type.
 *  A relationship type is in the format of {SourceType}_{ACTION}_{DestType}.
 *  Example: `DISK_TO_INSTANCE`, `DISK_TO_NETWORK`, `INSTANCE_TO_INSTANCEGROUP`.
 *  See [supported relationship
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#supported_relationship_types).
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudAsset_RelatedResources. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_ResourceSearchResult_Relationships : GTLRObject
@end


/**
 *  Specifies the resource to analyze for access policies, which may be set
 *  directly on the resource, or on ancestors such as organizations, folders or
 *  projects.
 */
@interface GTLRCloudAsset_ResourceSelector : GTLRObject

/**
 *  Required. The [full resource name]
 *  (https://cloud.google.com/asset-inventory/docs/resource-name-format) of a
 *  resource of [supported resource
 *  types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#analyzable_asset_types).
 */
@property(nonatomic, copy, nullable) NSString *fullResourceName;

@end


/**
 *  A saved query which can be shared with others or used later.
 */
@interface GTLRCloudAsset_SavedQuery : GTLRObject

/** The query content. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_QueryContent *content;

/** Output only. The create time of this saved query. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The account's email address who has created this saved query.
 */
@property(nonatomic, copy, nullable) NSString *creator;

/**
 *  The description of this saved query. This value should be fewer than 255
 *  characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Labels applied on the resource. This value should not contain more than 10
 *  entries. The key and value of each entry must be non-empty and fewer than 64
 *  characters.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_SavedQuery_Labels *labels;

/**
 *  Output only. The account's email address who has updated this saved query
 *  most recently.
 */
@property(nonatomic, copy, nullable) NSString *lastUpdater;

/** Output only. The last update time of this saved query. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdateTime;

/**
 *  The resource name of the saved query. The format must be: *
 *  projects/project_number/savedQueries/saved_query_id *
 *  folders/folder_number/savedQueries/saved_query_id *
 *  organizations/organization_number/savedQueries/saved_query_id
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Labels applied on the resource. This value should not contain more than 10
 *  entries. The key and value of each entry must be non-empty and fewer than 64
 *  characters.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudAsset_SavedQuery_Labels : GTLRObject
@end


/**
 *  Search all IAM policies response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "results" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudAsset_SearchAllIamPoliciesResponse : GTLRCollectionObject

/**
 *  Set if there are more results than those appearing in this response; to get
 *  the next set of results, call this method again, using this value as the
 *  `page_token`.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of IamPolicy that match the search query. Related information such as
 *  the associated resource is returned along with the policy.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_IamPolicySearchResult *> *results;

@end


/**
 *  Search all resources response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "results" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudAsset_SearchAllResourcesResponse : GTLRCollectionObject

/**
 *  If there are more results than those appearing in this response, then
 *  `next_page_token` is included. To get the next set of results, call this
 *  method again using the value of `next_page_token` as `page_token`.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of Resources that match the search query. It contains the resource
 *  standard metadata information.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_ResourceSearchResult *> *results;

@end


/**
 *  Software package information of the operating system.
 */
@interface GTLRCloudAsset_SoftwarePackage : GTLRObject

/**
 *  Details of an APT package. For details about the apt package manager, see
 *  https://wiki.debian.org/Apt.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_VersionedPackage *aptPackage;

/** Details of a COS package. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_VersionedPackage *cosPackage;

/**
 *  Details of a Googet package. For details about the googet package manager,
 *  see https://github.com/google/googet.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_VersionedPackage *googetPackage;

/**
 *  Details of a Windows Quick Fix engineering package. See
 *  https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
 *  for info in Windows Quick Fix Engineering.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_WindowsQuickFixEngineeringPackage *qfePackage;

/** Details of Windows Application. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_WindowsApplication *windowsApplication;

/**
 *  Details of a Windows Update package. See
 *  https://docs.microsoft.com/en-us/windows/win32/api/_wua/ for information
 *  about Windows Update.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_WindowsUpdatePackage *wuaPackage;

/**
 *  Yum package info. For details about the yum package manager, see
 *  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_VersionedPackage *yumPackage;

/**
 *  Details of a Zypper package. For details about the Zypper package manager,
 *  see https://en.opensuse.org/SDB:Zypper_manual.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_VersionedPackage *zypperPackage;

/**
 *  Details of a Zypper patch. For details about the Zypper package manager, see
 *  https://en.opensuse.org/SDB:Zypper_manual.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_ZypperPatch *zypperPatch;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRCloudAsset_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRCloudAsset_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_Status_Details_Item : GTLRObject
@end


/**
 *  An asset in Google Cloud and its temporal metadata, including the time
 *  window when it was observed and its status during that window.
 */
@interface GTLRCloudAsset_TemporalAsset : GTLRObject

/** An asset in Google Cloud. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Asset *asset;

/**
 *  Whether the asset has been deleted or not.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deleted;

/**
 *  Prior copy of the asset. Populated if prior_asset_state is PRESENT.
 *  Currently this is only set for responses in Real-Time Feed.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Asset *priorAsset;

/**
 *  State of prior_asset.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudAsset_TemporalAsset_PriorAssetState_Deleted prior_asset
 *        is a deletion. (Value: "DELETED")
 *    @arg @c kGTLRCloudAsset_TemporalAsset_PriorAssetState_DoesNotExist Current
 *        asset is the first known state. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRCloudAsset_TemporalAsset_PriorAssetState_Invalid Failed to
 *        set prior_asset. (Value: "INVALID")
 *    @arg @c kGTLRCloudAsset_TemporalAsset_PriorAssetState_Present prior_asset
 *        is populated correctly. (Value: "PRESENT")
 *    @arg @c kGTLRCloudAsset_TemporalAsset_PriorAssetState_PriorAssetStateUnspecified
 *        prior_asset is not applicable for the current asset. (Value:
 *        "PRIOR_ASSET_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *priorAssetState;

/** The time window when the asset data and state was observed. */
@property(nonatomic, strong, nullable) GTLRCloudAsset_TimeWindow *window;

@end


/**
 *  A time window specified by its `start_time` and `end_time`.
 */
@interface GTLRCloudAsset_TimeWindow : GTLRObject

/**
 *  End time of the time window (inclusive). If not specified, the current
 *  timestamp is used instead.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Start time of the time window (exclusive). */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Update asset feed request.
 */
@interface GTLRCloudAsset_UpdateFeedRequest : GTLRObject

/**
 *  Required. The new values of feed details. It must match an existing feed and
 *  the field `name` must be in the format of:
 *  projects/project_number/feeds/feed_id or folders/folder_number/feeds/feed_id
 *  or organizations/organization_number/feeds/feed_id.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Feed *feed;

/**
 *  Required. Only updates the `feed` fields indicated by this mask. The field
 *  mask must not be empty, and it must not contain fields that are immutable or
 *  only set by the server.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Information related to the a standard versioned package. This includes
 *  package info for APT, Yum, Zypper, and Googet package managers.
 */
@interface GTLRCloudAsset_VersionedPackage : GTLRObject

/** The system architecture this package is intended for. */
@property(nonatomic, copy, nullable) NSString *architecture;

/** The name of the package. */
@property(nonatomic, copy, nullable) NSString *packageName;

/** The version of the package. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Resource representation as defined by the corresponding service providing
 *  the resource for a given API version.
 */
@interface GTLRCloudAsset_VersionedResource : GTLRObject

/**
 *  JSON representation of the resource as defined by the corresponding service
 *  providing this resource. Example: If the resource is an instance provided by
 *  Compute Engine, this field will contain the JSON representation of the
 *  instance as defined by Compute Engine:
 *  `https://cloud.google.com/compute/docs/reference/rest/v1/instances`. You can
 *  find the resource definition for each supported resource type in this table:
 *  `https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types`
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_VersionedResource_Resource *resource;

/**
 *  API version of the resource. Example: If the resource is an instance
 *  provided by Compute Engine v1 API as defined in
 *  `https://cloud.google.com/compute/docs/reference/rest/v1/instances`, version
 *  will be "v1".
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  JSON representation of the resource as defined by the corresponding service
 *  providing this resource. Example: If the resource is an instance provided by
 *  Compute Engine, this field will contain the JSON representation of the
 *  instance as defined by Compute Engine:
 *  `https://cloud.google.com/compute/docs/reference/rest/v1/instances`. You can
 *  find the resource definition for each supported resource type in this table:
 *  `https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types`
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudAsset_VersionedResource_Resource : GTLRObject
@end


/**
 *  Contains information about a Windows application that is retrieved from the
 *  Windows Registry. For more information about these fields, see:
 *  https://docs.microsoft.com/en-us/windows/win32/msi/uninstall-registry-key
 */
@interface GTLRCloudAsset_WindowsApplication : GTLRObject

/** The name of the application or product. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** The version of the product or application in string format. */
@property(nonatomic, copy, nullable) NSString *displayVersion;

/** The internet address for technical support. */
@property(nonatomic, copy, nullable) NSString *helpLink;

/**
 *  The last time this product received service. The value of this property is
 *  replaced each time a patch is applied or removed from the product or the
 *  command-line option is used to repair the product.
 */
@property(nonatomic, strong, nullable) GTLRCloudAsset_Date *installDate;

/** The name of the manufacturer for the product or application. */
@property(nonatomic, copy, nullable) NSString *publisher;

@end


/**
 *  Information related to a Quick Fix Engineering package. Fields are taken
 *  from Windows QuickFixEngineering Interface and match the source names:
 *  https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
 */
@interface GTLRCloudAsset_WindowsQuickFixEngineeringPackage : GTLRObject

/** A short textual description of the QFE update. */
@property(nonatomic, copy, nullable) NSString *caption;

/**
 *  A textual description of the QFE update.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Unique identifier associated with a particular QFE update. */
@property(nonatomic, copy, nullable) NSString *hotFixId;

/** Date that the QFE update was installed. Mapped from installed_on field. */
@property(nonatomic, strong, nullable) GTLRDateTime *installTime;

@end


/**
 *  Categories specified by the Windows Update.
 */
@interface GTLRCloudAsset_WindowsUpdateCategory : GTLRObject

/**
 *  The identifier of the windows update category.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** The name of the windows update category. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Details related to a Windows Update package. Field data and names are taken
 *  from Windows Update API IUpdate Interface:
 *  https://docs.microsoft.com/en-us/windows/win32/api/_wua/ Descriptive fields
 *  like title, and description are localized based on the locale of the VM
 *  being updated.
 */
@interface GTLRCloudAsset_WindowsUpdatePackage : GTLRObject

/** The categories that are associated with this update package. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudAsset_WindowsUpdateCategory *> *categories;

/**
 *  The localized description of the update package.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A collection of Microsoft Knowledge Base article IDs that are associated
 *  with the update package.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kbArticleIds;

/** The last published date of the update, in (UTC) date and time. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastDeploymentChangeTime;

/**
 *  A collection of URLs that provide more information about the update package.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *moreInfoUrls;

/**
 *  The revision number of this update package.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *revisionNumber;

/**
 *  A hyperlink to the language-specific support information for the update.
 */
@property(nonatomic, copy, nullable) NSString *supportUrl;

/** The localized title of the update package. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  Gets the identifier of an update package. Stays the same across revisions.
 */
@property(nonatomic, copy, nullable) NSString *updateId;

@end


/**
 *  Details related to a Zypper Patch.
 */
@interface GTLRCloudAsset_ZypperPatch : GTLRObject

/** The category of the patch. */
@property(nonatomic, copy, nullable) NSString *category;

/** The name of the patch. */
@property(nonatomic, copy, nullable) NSString *patchName;

/** The severity specified for this patch */
@property(nonatomic, copy, nullable) NSString *severity;

/** Any summary information provided about this patch. */
@property(nonatomic, copy, nullable) NSString *summary;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
