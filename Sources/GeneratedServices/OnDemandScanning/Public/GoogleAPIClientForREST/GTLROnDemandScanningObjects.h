// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   On-Demand Scanning API (ondemandscanning/v1)
// Description:
//   A service to scan container images for vulnerabilities.
// Documentation:
//   https://cloud.google.com/container-analysis/docs/on-demand-scanning/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLROnDemandScanning_AliasContext;
@class GTLROnDemandScanning_AnalysisCompleted;
@class GTLROnDemandScanning_Artifact;
@class GTLROnDemandScanning_AttestationOccurrence;
@class GTLROnDemandScanning_BaseImage;
@class GTLROnDemandScanning_BinarySourceInfo;
@class GTLROnDemandScanning_BuildDefinition;
@class GTLROnDemandScanning_BuildDefinition_ExternalParameters;
@class GTLROnDemandScanning_BuildDefinition_InternalParameters;
@class GTLROnDemandScanning_BuilderConfig;
@class GTLROnDemandScanning_BuildMetadata;
@class GTLROnDemandScanning_BuildOccurrence;
@class GTLROnDemandScanning_BuildProvenance;
@class GTLROnDemandScanning_BuildProvenance_BuildOptions;
@class GTLROnDemandScanning_Category;
@class GTLROnDemandScanning_CISAKnownExploitedVulnerabilities;
@class GTLROnDemandScanning_CloudRepoSourceContext;
@class GTLROnDemandScanning_Command;
@class GTLROnDemandScanning_Completeness;
@class GTLROnDemandScanning_ComplianceOccurrence;
@class GTLROnDemandScanning_ComplianceVersion;
@class GTLROnDemandScanning_CVSS;
@class GTLROnDemandScanning_DeploymentOccurrence;
@class GTLROnDemandScanning_DiscoveryOccurrence;
@class GTLROnDemandScanning_DSSEAttestationOccurrence;
@class GTLROnDemandScanning_Envelope;
@class GTLROnDemandScanning_EnvelopeSignature;
@class GTLROnDemandScanning_ExploitPredictionScoringSystem;
@class GTLROnDemandScanning_File;
@class GTLROnDemandScanning_File_Digest;
@class GTLROnDemandScanning_FileHashes;
@class GTLROnDemandScanning_FileLocation;
@class GTLROnDemandScanning_Fingerprint;
@class GTLROnDemandScanning_GerritSourceContext;
@class GTLROnDemandScanning_GitSourceContext;
@class GTLROnDemandScanning_GrafeasV1BaseImage;
@class GTLROnDemandScanning_GrafeasV1FileLocation;
@class GTLROnDemandScanning_GrafeasV1LayerDetails;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaBuilder;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource_Digest;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Environment;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Parameters;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial_Digest;
@class GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMetadata;
@class GTLROnDemandScanning_Hash;
@class GTLROnDemandScanning_Identity;
@class GTLROnDemandScanning_ImageOccurrence;
@class GTLROnDemandScanning_InTotoProvenance;
@class GTLROnDemandScanning_InTotoSlsaProvenanceV1;
@class GTLROnDemandScanning_InTotoStatement;
@class GTLROnDemandScanning_Justification;
@class GTLROnDemandScanning_Jwt;
@class GTLROnDemandScanning_LanguagePackageDependency;
@class GTLROnDemandScanning_Layer;
@class GTLROnDemandScanning_LayerDetails;
@class GTLROnDemandScanning_License;
@class GTLROnDemandScanning_Location;
@class GTLROnDemandScanning_Maintainer;
@class GTLROnDemandScanning_Material;
@class GTLROnDemandScanning_Material_Digest;
@class GTLROnDemandScanning_Metadata;
@class GTLROnDemandScanning_NonCompliantFile;
@class GTLROnDemandScanning_Occurrence;
@class GTLROnDemandScanning_Operation;
@class GTLROnDemandScanning_Operation_Metadata;
@class GTLROnDemandScanning_Operation_Response;
@class GTLROnDemandScanning_PackageData;
@class GTLROnDemandScanning_PackageIssue;
@class GTLROnDemandScanning_PackageOccurrence;
@class GTLROnDemandScanning_PackageVersion;
@class GTLROnDemandScanning_ProjectRepoId;
@class GTLROnDemandScanning_ProvenanceBuilder;
@class GTLROnDemandScanning_ProvenanceBuilder_Version;
@class GTLROnDemandScanning_Recipe;
@class GTLROnDemandScanning_Recipe_Arguments_Item;
@class GTLROnDemandScanning_Recipe_Environment_Item;
@class GTLROnDemandScanning_RelatedUrl;
@class GTLROnDemandScanning_Remediation;
@class GTLROnDemandScanning_RepoId;
@class GTLROnDemandScanning_ResourceDescriptor;
@class GTLROnDemandScanning_ResourceDescriptor_Annotations;
@class GTLROnDemandScanning_ResourceDescriptor_Digest;
@class GTLROnDemandScanning_Risk;
@class GTLROnDemandScanning_RunDetails;
@class GTLROnDemandScanning_SbomReferenceIntotoPayload;
@class GTLROnDemandScanning_SbomReferenceIntotoPredicate;
@class GTLROnDemandScanning_SbomReferenceIntotoPredicate_Digest;
@class GTLROnDemandScanning_SBOMReferenceOccurrence;
@class GTLROnDemandScanning_SBOMStatus;
@class GTLROnDemandScanning_SecretLocation;
@class GTLROnDemandScanning_SecretOccurrence;
@class GTLROnDemandScanning_SecretStatus;
@class GTLROnDemandScanning_Signature;
@class GTLROnDemandScanning_SlsaBuilder;
@class GTLROnDemandScanning_SlsaCompleteness;
@class GTLROnDemandScanning_SlsaMetadata;
@class GTLROnDemandScanning_SlsaProvenance;
@class GTLROnDemandScanning_SlsaProvenanceV1;
@class GTLROnDemandScanning_SlsaProvenanceZeroTwo;
@class GTLROnDemandScanning_SlsaProvenanceZeroTwo_BuildConfig;
@class GTLROnDemandScanning_SlsaRecipe;
@class GTLROnDemandScanning_SlsaRecipe_Arguments;
@class GTLROnDemandScanning_SlsaRecipe_Environment;
@class GTLROnDemandScanning_Source;
@class GTLROnDemandScanning_Source_FileHashes;
@class GTLROnDemandScanning_SourceContext;
@class GTLROnDemandScanning_SourceContext_Labels;
@class GTLROnDemandScanning_Status;
@class GTLROnDemandScanning_Status_Details_Item;
@class GTLROnDemandScanning_Subject;
@class GTLROnDemandScanning_Subject_Digest;
@class GTLROnDemandScanning_UpgradeDistribution;
@class GTLROnDemandScanning_UpgradeOccurrence;
@class GTLROnDemandScanning_Version;
@class GTLROnDemandScanning_VexAssessment;
@class GTLROnDemandScanning_VulnerabilityOccurrence;
@class GTLROnDemandScanning_WindowsUpdate;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_AliasContext.kind

/**
 *  Git tag.
 *
 *  Value: "FIXED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_Fixed;
/**
 *  Unknown.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_KindUnspecified;
/**
 *  Git branch.
 *
 *  Value: "MOVABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_Movable;
/**
 *  Used to specify non-standard aliases. For example, if a Git repo has a ref
 *  named "refs/foo/bar".
 *
 *  Value: "OTHER"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_Other;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.attackComplexity

/** Value: "ATTACK_COMPLEXITY_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityHigh;
/** Value: "ATTACK_COMPLEXITY_LOW" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityLow;
/** Value: "ATTACK_COMPLEXITY_MEDIUM" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityMedium;
/** Value: "ATTACK_COMPLEXITY_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.attackVector

/** Value: "ATTACK_VECTOR_ADJACENT" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorAdjacent;
/** Value: "ATTACK_VECTOR_LOCAL" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorLocal;
/** Value: "ATTACK_VECTOR_NETWORK" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorNetwork;
/** Value: "ATTACK_VECTOR_PHYSICAL" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorPhysical;
/** Value: "ATTACK_VECTOR_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.authentication

/** Value: "AUTHENTICATION_MULTIPLE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Authentication_AuthenticationMultiple;
/** Value: "AUTHENTICATION_NONE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Authentication_AuthenticationNone;
/** Value: "AUTHENTICATION_SINGLE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Authentication_AuthenticationSingle;
/** Value: "AUTHENTICATION_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Authentication_AuthenticationUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.availabilityImpact

/** Value: "IMPACT_COMPLETE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactComplete;
/** Value: "IMPACT_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactHigh;
/** Value: "IMPACT_LOW" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactLow;
/** Value: "IMPACT_NONE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactNone;
/** Value: "IMPACT_PARTIAL" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactPartial;
/** Value: "IMPACT_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.confidentialityImpact

/** Value: "IMPACT_COMPLETE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactComplete;
/** Value: "IMPACT_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactHigh;
/** Value: "IMPACT_LOW" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactLow;
/** Value: "IMPACT_NONE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactNone;
/** Value: "IMPACT_PARTIAL" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactPartial;
/** Value: "IMPACT_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.integrityImpact

/** Value: "IMPACT_COMPLETE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactComplete;
/** Value: "IMPACT_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactHigh;
/** Value: "IMPACT_LOW" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactLow;
/** Value: "IMPACT_NONE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactNone;
/** Value: "IMPACT_PARTIAL" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactPartial;
/** Value: "IMPACT_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.privilegesRequired

/** Value: "PRIVILEGES_REQUIRED_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredHigh;
/** Value: "PRIVILEGES_REQUIRED_LOW" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredLow;
/** Value: "PRIVILEGES_REQUIRED_NONE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredNone;
/** Value: "PRIVILEGES_REQUIRED_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.scope

/** Value: "SCOPE_CHANGED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Scope_ScopeChanged;
/** Value: "SCOPE_UNCHANGED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Scope_ScopeUnchanged;
/** Value: "SCOPE_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_Scope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_CVSS.userInteraction

/** Value: "USER_INTERACTION_NONE" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_UserInteraction_UserInteractionNone;
/** Value: "USER_INTERACTION_REQUIRED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_UserInteraction_UserInteractionRequired;
/** Value: "USER_INTERACTION_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_CVSS_UserInteraction_UserInteractionUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_DeploymentOccurrence.platform

/**
 *  Custom user-defined platform.
 *
 *  Value: "CUSTOM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_Custom;
/**
 *  Google App Engine: Flexible Environment.
 *
 *  Value: "FLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_Flex;
/**
 *  Google Container Engine.
 *
 *  Value: "GKE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_Gke;
/**
 *  Unknown.
 *
 *  Value: "PLATFORM_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_PlatformUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_DiscoveryOccurrence.analysisStatus

/**
 *  Unknown.
 *
 *  Value: "ANALYSIS_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_AnalysisStatusUnspecified;
/**
 *  Analysis has completed.
 *
 *  Value: "COMPLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Complete;
/**
 *  Analysis has finished unsuccessfully, the analysis itself is in a bad state.
 *
 *  Value: "FINISHED_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedFailed;
/**
 *  Analysis has finished successfully.
 *
 *  Value: "FINISHED_SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedSuccess;
/**
 *  The resource is known not to be supported.
 *
 *  Value: "FINISHED_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedUnsupported;
/**
 *  Resource is known but no action has been taken yet.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Pending;
/**
 *  Resource is being analyzed.
 *
 *  Value: "SCANNING"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Scanning;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_DiscoveryOccurrence.continuousAnalysis

/**
 *  The resource is continuously analyzed.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Active;
/**
 *  Unknown.
 *
 *  Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_ContinuousAnalysisUnspecified;
/**
 *  The resource is ignored for continuous analysis.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Inactive;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_Justification.justificationType

/**
 *  The vulnerable component is not present in the product.
 *
 *  Value: "COMPONENT_NOT_PRESENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Justification_JustificationType_ComponentNotPresent;
/**
 *  The product includes built-in protections or features that prevent
 *  exploitation of the vulnerability. These built-in protections cannot be
 *  subverted by the attacker and cannot be configured or disabled by the user.
 *  These mitigations completely prevent exploitation based on known attack
 *  vectors.
 *
 *  Value: "INLINE_MITIGATIONS_ALREADY_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Justification_JustificationType_InlineMitigationsAlreadyExist;
/**
 *  JUSTIFICATION_TYPE_UNSPECIFIED.
 *
 *  Value: "JUSTIFICATION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Justification_JustificationType_JustificationTypeUnspecified;
/**
 *  The vulnerable code cannot be controlled by an attacker to exploit the
 *  vulnerability.
 *
 *  Value: "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Justification_JustificationType_VulnerableCodeCannotBeControlledByAdversary;
/**
 *  The vulnerable code can not be executed. Typically this case occurs when the
 *  product includes the vulnerable code but does not call or use the vulnerable
 *  code.
 *
 *  Value: "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Justification_JustificationType_VulnerableCodeNotInExecutePath;
/**
 *  The vulnerable code is not present. Typically this case occurs when source
 *  code is configured or built in a way that excludes the vulnerable code.
 *
 *  Value: "VULNERABLE_CODE_NOT_PRESENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Justification_JustificationType_VulnerableCodeNotPresent;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_Occurrence.kind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Attestation;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Build;
/**
 *  This represents a Compliance Note
 *
 *  Value: "COMPLIANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Compliance;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Deployment;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Discovery;
/**
 *  This represents a DSSE attestation Note
 *
 *  Value: "DSSE_ATTESTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_DsseAttestation;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Image;
/**
 *  Default value. This value is unused.
 *
 *  Value: "NOTE_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_NoteKindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Package;
/**
 *  This represents an SBOM Reference.
 *
 *  Value: "SBOM_REFERENCE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_SbomReference;
/**
 *  This represents a secret.
 *
 *  Value: "SECRET"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Secret;
/**
 *  This represents an available package upgrade.
 *
 *  Value: "UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Upgrade;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "VULNERABILITY"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Vulnerability;
/**
 *  This represents a Vulnerability Assessment.
 *
 *  Value: "VULNERABILITY_ASSESSMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_VulnerabilityAssessment;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_PackageData.packageType

/**
 *  PHP packages from Composer package manager.
 *
 *  Value: "COMPOSER"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Composer;
/**
 *  Go third-party packages.
 *
 *  Value: "GO"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Go;
/**
 *  Go toolchain + standard library packages.
 *
 *  Value: "GO_STDLIB"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_GoStdlib;
/**
 *  Java packages from Maven.
 *
 *  Value: "MAVEN"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Maven;
/**
 *  NPM packages.
 *
 *  Value: "NPM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Npm;
/**
 *  Nuget (C#/.NET) packages.
 *
 *  Value: "NUGET"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Nuget;
/**
 *  Operating System
 *
 *  Value: "OS"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Os;
/** Value: "PACKAGE_TYPE_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_PackageTypeUnspecified;
/**
 *  Python packages.
 *
 *  Value: "PYPI"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Pypi;
/**
 *  Ruby packges (from RubyGems package manager).
 *
 *  Value: "RUBYGEMS"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Rubygems;
/**
 *  Rust packages from Cargo (GitHub ecosystem is `RUST`).
 *
 *  Value: "RUST"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Rust;
/**
 *  Swift packages from Swift Package Manager (SwiftPM).
 *
 *  Value: "SWIFT"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageData_PackageType_Swift;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_PackageIssue.effectiveSeverity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_PackageOccurrence.architecture

/**
 *  Unknown architecture.
 *
 *  Value: "ARCHITECTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageOccurrence_Architecture_ArchitectureUnspecified;
/**
 *  X64 architecture.
 *
 *  Value: "X64"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageOccurrence_Architecture_X64;
/**
 *  X86 architecture.
 *
 *  Value: "X86"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_PackageOccurrence_Architecture_X86;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_Remediation.remediationType

/**
 *  A MITIGATION is available.
 *
 *  Value: "MITIGATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Remediation_RemediationType_Mitigation;
/**
 *  No fix is planned.
 *
 *  Value: "NO_FIX_PLANNED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Remediation_RemediationType_NoFixPlanned;
/**
 *  Not available.
 *
 *  Value: "NONE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Remediation_RemediationType_NoneAvailable;
/**
 *  No remediation type specified.
 *
 *  Value: "REMEDIATION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Remediation_RemediationType_RemediationTypeUnspecified;
/**
 *  A vendor fix is available.
 *
 *  Value: "VENDOR_FIX"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Remediation_RemediationType_VendorFix;
/**
 *  A workaround is available.
 *
 *  Value: "WORKAROUND"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Remediation_RemediationType_Workaround;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_SBOMStatus.sbomState

/**
 *  SBOM scanning has completed.
 *
 *  Value: "COMPLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SBOMStatus_SbomState_Complete;
/**
 *  SBOM scanning is pending.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SBOMStatus_SbomState_Pending;
/**
 *  Default unknown state.
 *
 *  Value: "SBOM_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SBOMStatus_SbomState_SbomStateUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_SecretOccurrence.kind

/**
 *  A GCP service account key per:
 *  https://cloud.google.com/iam/docs/creating-managing-service-account-keys
 *
 *  Value: "SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretOccurrence_Kind_SecretKindGcpServiceAccountKey;
/**
 *  The secret kind is unknown.
 *
 *  Value: "SECRET_KIND_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretOccurrence_Kind_SecretKindUnknown;
/**
 *  Unspecified
 *
 *  Value: "SECRET_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretOccurrence_Kind_SecretKindUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_SecretStatus.status

/**
 *  The secret is invalid.
 *
 *  Value: "INVALID"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretStatus_Status_Invalid;
/**
 *  Unspecified
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretStatus_Status_StatusUnspecified;
/**
 *  The status of the secret is unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretStatus_Status_Unknown;
/**
 *  The secret is valid.
 *
 *  Value: "VALID"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_SecretStatus_Status_Valid;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_Version.kind

/**
 *  A special version representing positive infinity.
 *
 *  Value: "MAXIMUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_Maximum;
/**
 *  A special version representing negative infinity.
 *
 *  Value: "MINIMUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_Minimum;
/**
 *  A standard package version.
 *
 *  Value: "NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_Normal;
/**
 *  Unknown.
 *
 *  Value: "VERSION_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_VersionKindUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_VexAssessment.state

/**
 *  This product is known to be affected by this vulnerability.
 *
 *  Value: "AFFECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VexAssessment_State_Affected;
/**
 *  This product contains a fix for this vulnerability.
 *
 *  Value: "FIXED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VexAssessment_State_Fixed;
/**
 *  This product is known to be not affected by this vulnerability.
 *
 *  Value: "NOT_AFFECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VexAssessment_State_NotAffected;
/**
 *  No state is specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VexAssessment_State_StateUnspecified;
/**
 *  It is not known yet whether these versions are or are not affected by the
 *  vulnerability. However, it is still under investigation.
 *
 *  Value: "UNDER_INVESTIGATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VexAssessment_State_UnderInvestigation;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_VulnerabilityOccurrence.cvssVersion

/** Value: "CVSS_VERSION_2" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_CvssVersion_CvssVersion2;
/** Value: "CVSS_VERSION_3" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_CvssVersion_CvssVersion3;
/** Value: "CVSS_VERSION_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_CvssVersion_CvssVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_VulnerabilityOccurrence.effectiveSeverity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_VulnerabilityOccurrence.severity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_SeverityUnspecified;

/**
 *  An alias to a repo revision.
 */
@interface GTLROnDemandScanning_AliasContext : GTLRObject

/**
 *  The alias kind.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_Fixed Git tag. (Value:
 *        "FIXED")
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_KindUnspecified Unknown.
 *        (Value: "KIND_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_Movable Git branch.
 *        (Value: "MOVABLE")
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_Other Used to specify
 *        non-standard aliases. For example, if a Git repo has a ref named
 *        "refs/foo/bar". (Value: "OTHER")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The alias name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Indicates which analysis completed successfully. Multiple types of analysis
 *  can be performed on a single resource.
 */
@interface GTLROnDemandScanning_AnalysisCompleted : GTLRObject

@property(nonatomic, strong, nullable) NSArray<NSString *> *analysisType;

@end


/**
 *  AnalyzePackagesMetadata contains metadata for an active scan of a container
 *  image.
 */
@interface GTLROnDemandScanning_AnalyzePackagesMetadata : GTLRObject

/** When the scan was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The resource URI of the container image being scanned. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  AnalyzePackagesMetadata contains metadata for an active scan of a container
 *  image.
 */
@interface GTLROnDemandScanning_AnalyzePackagesMetadataV1 : GTLRObject

/** When the scan was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The resource URI of the container image being scanned. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  AnalyzePackagesRequest is the request to analyze a list of packages and
 *  create Vulnerability Occurrences for it.
 */
@interface GTLROnDemandScanning_AnalyzePackagesRequestV1 : GTLRObject

/**
 *  [DEPRECATED] Whether to include OSV data in the scan. For backwards
 *  compatibility reasons, this field can be neither removed nor renamed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *includeOsvData GTLR_DEPRECATED;

/** The packages to analyze. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_PackageData *> *packages;

/** Required. The resource URI of the container image being scanned. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  AnalyzePackagesResponse contains the information necessary to find results
 *  for the given scan.
 */
@interface GTLROnDemandScanning_AnalyzePackagesResponse : GTLRObject

/** The name of the scan resource created by this successful scan. */
@property(nonatomic, copy, nullable) NSString *scan;

@end


/**
 *  AnalyzePackagesResponse contains the information necessary to find results
 *  for the given scan.
 */
@interface GTLROnDemandScanning_AnalyzePackagesResponseV1 : GTLRObject

/** The name of the scan resource created by this successful scan. */
@property(nonatomic, copy, nullable) NSString *scan;

@end


/**
 *  Artifact describes a build product.
 */
@interface GTLROnDemandScanning_Artifact : GTLRObject

/**
 *  Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
 *  container.
 */
@property(nonatomic, copy, nullable) NSString *checksum;

/**
 *  Artifact ID, if any; for container images, this will be a URL by digest like
 *  `gcr.io/projectID/imagename\@sha256:123456`.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Related artifact names. This may be the path to a binary or jar file, or in
 *  the case of a container build, the name used to push the container image to
 *  Google Container Registry, as presented to `docker push`. Note that a single
 *  Artifact ID can have multiple names, for example if two tags are applied to
 *  one image.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *names;

@end


/**
 *  Occurrence that represents a single "attestation". The authenticity of an
 *  attestation can be verified using the attached signature. If the verifier
 *  trusts the public key of the signer, then verifying the signature is
 *  sufficient to establish trust. In this circumstance, the authority to which
 *  this attestation is attached is primarily useful for lookup (how to find
 *  this attestation if you already know the authority and artifact to be
 *  verified) and intent (for which authority this attestation was intended to
 *  sign.
 */
@interface GTLROnDemandScanning_AttestationOccurrence : GTLRObject

/**
 *  One or more JWTs encoding a self-contained attestation. Each JWT encodes the
 *  payload that it verifies within the JWT itself. Verifier implementation
 *  SHOULD ignore the `serialized_payload` field when verifying these JWTs. If
 *  only JWTs are present on this AttestationOccurrence, then the
 *  `serialized_payload` SHOULD be left empty. Each JWT SHOULD encode a claim
 *  specific to the `resource_uri` of this Occurrence, but this is not validated
 *  by Grafeas metadata API implementations. The JWT itself is opaque to
 *  Grafeas.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Jwt *> *jwts;

/**
 *  Required. The serialized payload that is verified by one or more
 *  `signatures`.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *serializedPayload;

/**
 *  One or more signatures over `serialized_payload`. Verifier implementations
 *  should consider this attestation message verified if at least one
 *  `signature` verifies `serialized_payload`. See `Signature` in common.proto
 *  for more details on signature structure and verification.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Signature *> *signatures;

@end


/**
 *  BaseImage describes a base image of a container image.
 */
@interface GTLROnDemandScanning_BaseImage : GTLRObject

/**
 *  The number of layers that the base image is composed of.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *layerCount;

/** The name of the base image. */
@property(nonatomic, copy, nullable) NSString *name;

/** The repository name in which the base image is from. */
@property(nonatomic, copy, nullable) NSString *repository;

@end


/**
 *  GTLROnDemandScanning_BinarySourceInfo
 */
@interface GTLROnDemandScanning_BinarySourceInfo : GTLRObject

/**
 *  The binary package. This is significant when the source is different than
 *  the binary itself. Historically if they've differed, we've stored the name
 *  of the source and its version in the package/version fields, but we should
 *  also store the binary package info, as that's what's actually installed.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_PackageVersion *binaryVersion;

/**
 *  The source package. Similar to the above, this is significant when the
 *  source is different than the binary itself. Since the top-level
 *  package/version fields are based on an if/else, we need a separate field for
 *  both binary and source if we want to know definitively where the data is
 *  coming from.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_PackageVersion *sourceVersion;

@end


/**
 *  GTLROnDemandScanning_BuildDefinition
 */
@interface GTLROnDemandScanning_BuildDefinition : GTLRObject

@property(nonatomic, copy, nullable) NSString *buildType;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildDefinition_ExternalParameters *externalParameters;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildDefinition_InternalParameters *internalParameters;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_ResourceDescriptor *> *resolvedDependencies;

@end


/**
 *  GTLROnDemandScanning_BuildDefinition_ExternalParameters
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_BuildDefinition_ExternalParameters : GTLRObject
@end


/**
 *  GTLROnDemandScanning_BuildDefinition_InternalParameters
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_BuildDefinition_InternalParameters : GTLRObject
@end


/**
 *  GTLROnDemandScanning_BuilderConfig
 */
@interface GTLROnDemandScanning_BuilderConfig : GTLRObject

/**
 *  identifier
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

@end


/**
 *  GTLROnDemandScanning_BuildMetadata
 */
@interface GTLROnDemandScanning_BuildMetadata : GTLRObject

@property(nonatomic, strong, nullable) GTLRDateTime *finishedOn;
@property(nonatomic, copy, nullable) NSString *invocationId;
@property(nonatomic, strong, nullable) GTLRDateTime *startedOn;

@end


/**
 *  Details of a build occurrence.
 */
@interface GTLROnDemandScanning_BuildOccurrence : GTLRObject

/**
 *  Deprecated. See InTotoStatement for the replacement. In-toto Provenance
 *  representation as defined in spec.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_InTotoProvenance *intotoProvenance;

/**
 *  In-Toto Slsa Provenance V1 represents a slsa provenance meeting the slsa
 *  spec, wrapped in an in-toto statement. This allows for direct jsonification
 *  of a to-spec in-toto slsa statement with a to-spec slsa provenance.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_InTotoSlsaProvenanceV1 *inTotoSlsaProvenanceV1;

/**
 *  In-toto Statement representation as defined in spec. The intoto_statement
 *  can contain any type of provenance. The serialized payload of the statement
 *  can be stored and signed in the Occurrence's envelope.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_InTotoStatement *intotoStatement;

/** The actual provenance for the build. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildProvenance *provenance;

/**
 *  Serialized JSON representation of the provenance, used in generating the
 *  build signature in the corresponding build note. After verifying the
 *  signature, `provenance_bytes` can be unmarshalled and compared to the
 *  provenance to confirm that it is unchanged. A base64-encoded string
 *  representation of the provenance bytes is used for the signature in order to
 *  interoperate with openssl which expects this format for signature
 *  verification. The serialized form is captured both to avoid ambiguity in how
 *  the provenance is marshalled to json as well to prevent incompatibilities
 *  with future changes.
 */
@property(nonatomic, copy, nullable) NSString *provenanceBytes;

@end


/**
 *  Provenance of a build. Contains all information needed to verify the full
 *  details about the build from source to completion.
 */
@interface GTLROnDemandScanning_BuildProvenance : GTLRObject

/** Version string of the builder at the time this build was executed. */
@property(nonatomic, copy, nullable) NSString *builderVersion;

/**
 *  Special options applied to this build. This is a catch-all field where build
 *  providers can enter any desired additional details.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildProvenance_BuildOptions *buildOptions;

/** Output of the build. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Artifact *> *builtArtifacts;

/** Commands requested by the build. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Command *> *commands;

/** Time at which the build was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  E-mail address of the user who initiated this build. Note that this was the
 *  user's e-mail address at the time the build was initiated; this address may
 *  not represent the same end-user for all time.
 */
@property(nonatomic, copy, nullable) NSString *creator;

/** Time at which execution of the build was finished. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Required. Unique identifier of the build.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** URI where any logs for this provenance were written. */
@property(nonatomic, copy, nullable) NSString *logsUri;

/** ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Details of the Source input to the build. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Source *sourceProvenance;

/** Time at which execution of the build was started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Trigger identifier if the build was triggered automatically; empty if not.
 */
@property(nonatomic, copy, nullable) NSString *triggerId;

@end


/**
 *  Special options applied to this build. This is a catch-all field where build
 *  providers can enter any desired additional details.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_BuildProvenance_BuildOptions : GTLRObject
@end


/**
 *  The category to which the update belongs.
 */
@interface GTLROnDemandScanning_Category : GTLRObject

/** The identifier of the category. */
@property(nonatomic, copy, nullable) NSString *categoryId;

/** The localized name of the category. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  GTLROnDemandScanning_CISAKnownExploitedVulnerabilities
 */
@interface GTLROnDemandScanning_CISAKnownExploitedVulnerabilities : GTLRObject

/**
 *  Whether the vulnerability is known to have been leveraged as part of a
 *  ransomware campaign.
 */
@property(nonatomic, copy, nullable) NSString *knownRansomwareCampaignUse;

@end


/**
 *  A CloudRepoSourceContext denotes a particular revision in a Google Cloud
 *  Source Repo.
 */
@interface GTLROnDemandScanning_CloudRepoSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_AliasContext *aliasContext;

/** The ID of the repo. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_RepoId *repoId;

/** A revision ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  Command describes a step performed as part of the build pipeline.
 */
@interface GTLROnDemandScanning_Command : GTLRObject

/** Command-line arguments used when executing this command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

/**
 *  Working directory (relative to project source root) used when running this
 *  command.
 */
@property(nonatomic, copy, nullable) NSString *dir;

/** Environment variables set before running this command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *env;

/**
 *  Optional unique identifier for this command, used in wait_for to reference
 *  this command as a dependency.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Required. Name of the command, as presented on the command line, or if the
 *  command is packaged as a Docker container, as presented to `docker pull`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The ID(s) of the command(s) that this command depends on. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *waitFor;

@end


/**
 *  Indicates that the builder claims certain fields in this message to be
 *  complete.
 */
@interface GTLROnDemandScanning_Completeness : GTLRObject

/**
 *  If true, the builder claims that recipe.arguments is complete, meaning that
 *  all external inputs are properly captured in the recipe.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *arguments;

/**
 *  If true, the builder claims that recipe.environment is claimed to be
 *  complete.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *environment;

/**
 *  If true, the builder claims that materials are complete, usually through
 *  some controls to prevent network access. Sometimes called "hermetic".
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *materials;

@end


/**
 *  An indication that the compliance checks in the associated ComplianceNote
 *  were not satisfied for particular resources or a specified reason.
 */
@interface GTLROnDemandScanning_ComplianceOccurrence : GTLRObject

@property(nonatomic, copy, nullable) NSString *nonComplianceReason;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_NonCompliantFile *> *nonCompliantFiles;

/** The OS and config version the benchmark was run on. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ComplianceVersion *version;

@end


/**
 *  Describes the CIS benchmark version that is applicable to a given OS and os
 *  version.
 */
@interface GTLROnDemandScanning_ComplianceVersion : GTLRObject

/**
 *  The name of the document that defines this benchmark, e.g. "CIS
 *  Container-Optimized OS".
 */
@property(nonatomic, copy, nullable) NSString *benchmarkDocument;

/**
 *  The CPE URI (https://cpe.mitre.org/specification/) this benchmark is
 *  applicable to.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  The version of the benchmark. This is set to the version of the OS-specific
 *  CIS document the benchmark is defined in.
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Common Vulnerability Scoring System. For details, see
 *  https://www.first.org/cvss/specification-document This is a message we will
 *  try to use for storing various versions of CVSS rather than making a
 *  separate proto for storing a specific version.
 */
@interface GTLROnDemandScanning_CVSS : GTLRObject

/**
 *  attackComplexity
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityHigh
 *        Value "ATTACK_COMPLEXITY_HIGH"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityLow
 *        Value "ATTACK_COMPLEXITY_LOW"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityMedium
 *        Value "ATTACK_COMPLEXITY_MEDIUM"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackComplexity_AttackComplexityUnspecified
 *        Value "ATTACK_COMPLEXITY_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *attackComplexity;

/**
 *  Base Metrics Represents the intrinsic characteristics of a vulnerability
 *  that are constant over time and across user environments.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorAdjacent Value
 *        "ATTACK_VECTOR_ADJACENT"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorLocal Value
 *        "ATTACK_VECTOR_LOCAL"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorNetwork Value
 *        "ATTACK_VECTOR_NETWORK"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorPhysical Value
 *        "ATTACK_VECTOR_PHYSICAL"
 *    @arg @c kGTLROnDemandScanning_CVSS_AttackVector_AttackVectorUnspecified
 *        Value "ATTACK_VECTOR_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *attackVector;

/**
 *  authentication
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_Authentication_AuthenticationMultiple
 *        Value "AUTHENTICATION_MULTIPLE"
 *    @arg @c kGTLROnDemandScanning_CVSS_Authentication_AuthenticationNone Value
 *        "AUTHENTICATION_NONE"
 *    @arg @c kGTLROnDemandScanning_CVSS_Authentication_AuthenticationSingle
 *        Value "AUTHENTICATION_SINGLE"
 *    @arg @c kGTLROnDemandScanning_CVSS_Authentication_AuthenticationUnspecified
 *        Value "AUTHENTICATION_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *authentication;

/**
 *  availabilityImpact
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactComplete Value
 *        "IMPACT_COMPLETE"
 *    @arg @c kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactHigh Value
 *        "IMPACT_HIGH"
 *    @arg @c kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactLow Value
 *        "IMPACT_LOW"
 *    @arg @c kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactNone Value
 *        "IMPACT_NONE"
 *    @arg @c kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactPartial Value
 *        "IMPACT_PARTIAL"
 *    @arg @c kGTLROnDemandScanning_CVSS_AvailabilityImpact_ImpactUnspecified
 *        Value "IMPACT_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *availabilityImpact;

/**
 *  The base score is a function of the base metric scores.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *baseScore;

/**
 *  confidentialityImpact
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactComplete
 *        Value "IMPACT_COMPLETE"
 *    @arg @c kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactHigh Value
 *        "IMPACT_HIGH"
 *    @arg @c kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactLow Value
 *        "IMPACT_LOW"
 *    @arg @c kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactNone Value
 *        "IMPACT_NONE"
 *    @arg @c kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactPartial
 *        Value "IMPACT_PARTIAL"
 *    @arg @c kGTLROnDemandScanning_CVSS_ConfidentialityImpact_ImpactUnspecified
 *        Value "IMPACT_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *confidentialityImpact;

/**
 *  exploitabilityScore
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exploitabilityScore;

/**
 *  impactScore
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *impactScore;

/**
 *  integrityImpact
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactComplete Value
 *        "IMPACT_COMPLETE"
 *    @arg @c kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactHigh Value
 *        "IMPACT_HIGH"
 *    @arg @c kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactLow Value
 *        "IMPACT_LOW"
 *    @arg @c kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactNone Value
 *        "IMPACT_NONE"
 *    @arg @c kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactPartial Value
 *        "IMPACT_PARTIAL"
 *    @arg @c kGTLROnDemandScanning_CVSS_IntegrityImpact_ImpactUnspecified Value
 *        "IMPACT_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *integrityImpact;

/**
 *  privilegesRequired
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredHigh
 *        Value "PRIVILEGES_REQUIRED_HIGH"
 *    @arg @c kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredLow
 *        Value "PRIVILEGES_REQUIRED_LOW"
 *    @arg @c kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredNone
 *        Value "PRIVILEGES_REQUIRED_NONE"
 *    @arg @c kGTLROnDemandScanning_CVSS_PrivilegesRequired_PrivilegesRequiredUnspecified
 *        Value "PRIVILEGES_REQUIRED_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *privilegesRequired;

/**
 *  scope
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_Scope_ScopeChanged Value
 *        "SCOPE_CHANGED"
 *    @arg @c kGTLROnDemandScanning_CVSS_Scope_ScopeUnchanged Value
 *        "SCOPE_UNCHANGED"
 *    @arg @c kGTLROnDemandScanning_CVSS_Scope_ScopeUnspecified Value
 *        "SCOPE_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *scope;

/**
 *  userInteraction
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_CVSS_UserInteraction_UserInteractionNone
 *        Value "USER_INTERACTION_NONE"
 *    @arg @c kGTLROnDemandScanning_CVSS_UserInteraction_UserInteractionRequired
 *        Value "USER_INTERACTION_REQUIRED"
 *    @arg @c kGTLROnDemandScanning_CVSS_UserInteraction_UserInteractionUnspecified
 *        Value "USER_INTERACTION_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *userInteraction;

@end


/**
 *  The period during which some deployable was active in a runtime.
 */
@interface GTLROnDemandScanning_DeploymentOccurrence : GTLRObject

/** Address of the runtime element hosting this deployment. */
@property(nonatomic, copy, nullable) NSString *address;

/** Configuration used to create this deployment. */
@property(nonatomic, copy, nullable) NSString *config;

/** Required. Beginning of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *deployTime;

/**
 *  Platform hosting this deployment.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_Custom Custom
 *        user-defined platform. (Value: "CUSTOM")
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_Flex Google
 *        App Engine: Flexible Environment. (Value: "FLEX")
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_Gke Google
 *        Container Engine. (Value: "GKE")
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_PlatformUnspecified
 *        Unknown. (Value: "PLATFORM_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *platform;

/**
 *  Output only. Resource URI for the artifact being deployed taken from the
 *  deployable field with the same name.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceUri;

/** End of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *undeployTime;

/** Identity of the user that triggered this deployment. */
@property(nonatomic, copy, nullable) NSString *userEmail;

@end


/**
 *  Provides information about the analysis status of a discovered resource.
 */
@interface GTLROnDemandScanning_DiscoveryOccurrence : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_AnalysisCompleted *analysisCompleted;

/**
 *  Indicates any errors encountered during analysis of a resource. There could
 *  be 0 or more of these errors.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Status *> *analysisError;

/**
 *  The status of discovery for the resource.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_AnalysisStatusUnspecified
 *        Unknown. (Value: "ANALYSIS_STATUS_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Complete
 *        Analysis has completed. (Value: "COMPLETE")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedFailed
 *        Analysis has finished unsuccessfully, the analysis itself is in a bad
 *        state. (Value: "FINISHED_FAILED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedSuccess
 *        Analysis has finished successfully. (Value: "FINISHED_SUCCESS")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedUnsupported
 *        The resource is known not to be supported. (Value:
 *        "FINISHED_UNSUPPORTED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Pending
 *        Resource is known but no action has been taken yet. (Value: "PENDING")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Scanning
 *        Resource is being analyzed. (Value: "SCANNING")
 */
@property(nonatomic, copy, nullable) NSString *analysisStatus;

/**
 *  When an error is encountered this will contain a LocalizedMessage under
 *  details to show to the user. The LocalizedMessage is output only and
 *  populated by the API.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Status *analysisStatusError;

/**
 *  Output only. The time occurrences related to this discovery occurrence were
 *  archived.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *archiveTime;

/**
 *  Whether the resource is continuously analyzed.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Active
 *        The resource is continuously analyzed. (Value: "ACTIVE")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_ContinuousAnalysisUnspecified
 *        Unknown. (Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Inactive
 *        The resource is ignored for continuous analysis. (Value: "INACTIVE")
 */
@property(nonatomic, copy, nullable) NSString *continuousAnalysis;

/** The CPE of the resource being scanned. */
@property(nonatomic, copy, nullable) NSString *cpe;

/** Files that make up the resource described by the occurrence. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_File *> *files;

/** The last time this resource was scanned. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastScanTime;

/** The status of an SBOM generation. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SBOMStatus *sbomStatus;

@end


/**
 *  Deprecated. Prefer to use a regular Occurrence, and populate the Envelope at
 *  the top level of the Occurrence.
 */
@interface GTLROnDemandScanning_DSSEAttestationOccurrence : GTLRObject

/**
 *  If doing something security critical, make sure to verify the signatures in
 *  this metadata.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Envelope *envelope;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_InTotoStatement *statement;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLROnDemandScanning_Empty : GTLRObject
@end


/**
 *  MUST match
 *  https://github.com/secure-systems-lab/dsse/blob/master/envelope.proto. An
 *  authenticated message of arbitrary type.
 */
@interface GTLROnDemandScanning_Envelope : GTLRObject

/**
 *  payload
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *payload;

@property(nonatomic, copy, nullable) NSString *payloadType;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_EnvelopeSignature *> *signatures;

@end


/**
 *  GTLROnDemandScanning_EnvelopeSignature
 */
@interface GTLROnDemandScanning_EnvelopeSignature : GTLRObject

@property(nonatomic, copy, nullable) NSString *keyid;

/**
 *  sig
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *sig;

@end


/**
 *  GTLROnDemandScanning_ExploitPredictionScoringSystem
 */
@interface GTLROnDemandScanning_ExploitPredictionScoringSystem : GTLRObject

/**
 *  The percentile of the current score, the proportion of all scored
 *  vulnerabilities with the same or a lower EPSS score
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percentile;

/**
 *  The EPSS score representing the probability [0-1] of exploitation in the
 *  wild in the next 30 days
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *score;

@end


/**
 *  GTLROnDemandScanning_File
 */
@interface GTLROnDemandScanning_File : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_File_Digest *digest;
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  GTLROnDemandScanning_File_Digest
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_File_Digest : GTLRObject
@end


/**
 *  Container message for hashes of byte content of files, used in source
 *  messages to verify integrity of source input to the build.
 */
@interface GTLROnDemandScanning_FileHashes : GTLRObject

/** Required. Collection of file hashes. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Hash *> *fileHash;

@end


/**
 *  Indicates the location at which a package was found.
 */
@interface GTLROnDemandScanning_FileLocation : GTLRObject

/**
 *  For jars that are contained inside .war files, this filepath can indicate
 *  the path to war file combined with the path to jar file.
 */
@property(nonatomic, copy, nullable) NSString *filePath;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_LayerDetails *layerDetails;

@end


/**
 *  A set of properties that uniquely identify a given Docker image.
 */
@interface GTLROnDemandScanning_Fingerprint : GTLRObject

/**
 *  Required. The layer ID of the final layer in the Docker image's v1
 *  representation.
 */
@property(nonatomic, copy, nullable) NSString *v1Name;

/** Required. The ordered list of v2 blobs that represent a given image. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *v2Blob;

/**
 *  Output only. The name of the image's v2 blobs computed via: [bottom] :=
 *  v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of
 *  the final blob is kept.
 */
@property(nonatomic, copy, nullable) NSString *v2Name;

@end


/**
 *  A SourceContext referring to a Gerrit project.
 */
@interface GTLROnDemandScanning_GerritSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_AliasContext *aliasContext;

/**
 *  The full project name within the host. Projects may be nested, so
 *  "project/subproject" is a valid project name. The "repo name" is the
 *  hostURI/project.
 */
@property(nonatomic, copy, nullable) NSString *gerritProject;

/** The URI of a running Gerrit instance. */
@property(nonatomic, copy, nullable) NSString *hostUri;

/** A revision (commit) ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  A GitSourceContext denotes a particular revision in a third party Git
 *  repository (e.g., GitHub).
 */
@interface GTLROnDemandScanning_GitSourceContext : GTLRObject

/** Git commit hash. */
@property(nonatomic, copy, nullable) NSString *revisionId;

/** Git repository URL. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  BaseImage describes a base image of a container image.
 */
@interface GTLROnDemandScanning_GrafeasV1BaseImage : GTLRObject

/**
 *  The number of layers that the base image is composed of.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *layerCount;

/** The name of the base image. */
@property(nonatomic, copy, nullable) NSString *name;

/** The repository name in which the base image is from. */
@property(nonatomic, copy, nullable) NSString *repository;

@end


/**
 *  Indicates the location at which a package was found.
 */
@interface GTLROnDemandScanning_GrafeasV1FileLocation : GTLRObject

/**
 *  For jars that are contained inside .war files, this filepath can indicate
 *  the path to war file combined with the path to jar file.
 */
@property(nonatomic, copy, nullable) NSString *filePath;

/**
 *  Each package found in a file should have its own layer metadata (that is,
 *  information from the origin layer of the package).
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1LayerDetails *layerDetails;

@end


/**
 *  Details about the layer a package was found in.
 */
@interface GTLROnDemandScanning_GrafeasV1LayerDetails : GTLRObject

/** The base images the layer is found within. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_GrafeasV1BaseImage *> *baseImages;

/**
 *  The layer chain ID (sha256 hash) of the layer in the container image.
 *  https://github.com/opencontainers/image-spec/blob/main/config.md#layer-chainid
 */
@property(nonatomic, copy, nullable) NSString *chainId;

/**
 *  The layer build command that was used to build the layer. This may not be
 *  found in all layers depending on how the container image is built.
 */
@property(nonatomic, copy, nullable) NSString *command;

/**
 *  The diff ID (typically a sha256 hash) of the layer in the container image.
 */
@property(nonatomic, copy, nullable) NSString *diffId;

/**
 *  The index of the layer in the container image.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

@end


/**
 *  Identifies the entity that executed the recipe, which is trusted to have
 *  correctly performed the operation and populated this provenance.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaBuilder : GTLRObject

/**
 *  identifier
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

@end


/**
 *  Indicates that the builder claims certain fields in this message to be
 *  complete.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness : GTLRObject

/**
 *  environment
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *environment;

/**
 *  materials
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *materials;

/**
 *  parameters
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *parameters;

@end


/**
 *  Describes where the config file that kicked off the build came from. This is
 *  effectively a pointer to the source where buildConfig came from.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource_Digest *digest;
@property(nonatomic, copy, nullable) NSString *entryPoint;
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource_Digest
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource_Digest : GTLRObject
@end


/**
 *  Identifies the event that kicked off the build.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource *configSource;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Environment *environment;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Parameters *parameters;

@end


/**
 *  GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Environment
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Environment : GTLRObject
@end


/**
 *  GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Parameters
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation_Parameters : GTLRObject
@end


/**
 *  The collection of artifacts that influenced the build including sources,
 *  dependencies, build tools, base images, and so on.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial_Digest *digest;
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial_Digest
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial_Digest : GTLRObject
@end


/**
 *  Other properties of the build.
 */
@interface GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMetadata : GTLRObject

@property(nonatomic, strong, nullable) GTLRDateTime *buildFinishedOn;
@property(nonatomic, copy, nullable) NSString *buildInvocationId;
@property(nonatomic, strong, nullable) GTLRDateTime *buildStartedOn;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness *completeness;

/**
 *  reproducible
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reproducible;

@end


/**
 *  Container message for hash values.
 */
@interface GTLROnDemandScanning_Hash : GTLRObject

/** Required. The type of hash that was performed, e.g. "SHA-256". */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Required. The hash value.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  The unique identifier of the update.
 */
@interface GTLROnDemandScanning_Identity : GTLRObject

/**
 *  The revision number of the update.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *revision;

/** The revision independent identifier of the update. */
@property(nonatomic, copy, nullable) NSString *updateId;

@end


/**
 *  Details of the derived image portion of the DockerImage relationship. This
 *  image would be produced from a Dockerfile with FROM .
 */
@interface GTLROnDemandScanning_ImageOccurrence : GTLRObject

/**
 *  Output only. This contains the base image URL for the derived image
 *  occurrence.
 */
@property(nonatomic, copy, nullable) NSString *baseResourceUrl;

/**
 *  Output only. The number of layers by which this image differs from the
 *  associated image basis.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *distance;

/** Required. The fingerprint of the derived image. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Fingerprint *fingerprint;

/**
 *  This contains layer-specific metadata, if populated it has length "distance"
 *  and is ordered with [distance] being the layer immediately following the
 *  base image and [1] being the final layer.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Layer *> *layerInfo;

@end


/**
 *  GTLROnDemandScanning_InTotoProvenance
 */
@interface GTLROnDemandScanning_InTotoProvenance : GTLRObject

/** required */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuilderConfig *builderConfig;

/**
 *  The collection of artifacts that influenced the build including sources,
 *  dependencies, build tools, base images, and so on. This is considered to be
 *  incomplete unless metadata.completeness.materials is true. Unset or null is
 *  equivalent to empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *materials;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_Metadata *metadata;

/**
 *  Identifies the configuration used for the build. When combined with
 *  materials, this SHOULD fully describe the build, such that re-running this
 *  recipe results in bit-for-bit identical output (if the build is
 *  reproducible). required
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Recipe *recipe;

@end


/**
 *  GTLROnDemandScanning_InTotoSlsaProvenanceV1
 */
@interface GTLROnDemandScanning_InTotoSlsaProvenanceV1 : GTLRObject

/**
 *  InToto spec defined at
 *  https://github.com/in-toto/attestation/tree/main/spec#statement
 */
@property(nonatomic, copy, nullable) NSString *xType;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaProvenanceV1 *predicate;
@property(nonatomic, copy, nullable) NSString *predicateType;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Subject *> *subject;

@end


/**
 *  Spec defined at
 *  https://github.com/in-toto/attestation/tree/main/spec#statement The
 *  serialized InTotoStatement will be stored as Envelope.payload.
 *  Envelope.payloadType is always "application/vnd.in-toto+json".
 */
@interface GTLROnDemandScanning_InTotoStatement : GTLRObject

/** Always `https://in-toto.io/Statement/v0.1`. */
@property(nonatomic, copy, nullable) NSString *xType;

/** `https://slsa.dev/provenance/v0.1` for SlsaProvenance. */
@property(nonatomic, copy, nullable) NSString *predicateType;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_InTotoProvenance *provenance;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaProvenance *slsaProvenance;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaProvenanceZeroTwo *slsaProvenanceZeroTwo;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Subject *> *subject;

@end


/**
 *  Justification provides the justification when the state of the assessment if
 *  NOT_AFFECTED.
 */
@interface GTLROnDemandScanning_Justification : GTLRObject

/** Additional details on why this justification was chosen. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  The justification type for this vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_Justification_JustificationType_ComponentNotPresent
 *        The vulnerable component is not present in the product. (Value:
 *        "COMPONENT_NOT_PRESENT")
 *    @arg @c kGTLROnDemandScanning_Justification_JustificationType_InlineMitigationsAlreadyExist
 *        The product includes built-in protections or features that prevent
 *        exploitation of the vulnerability. These built-in protections cannot
 *        be subverted by the attacker and cannot be configured or disabled by
 *        the user. These mitigations completely prevent exploitation based on
 *        known attack vectors. (Value: "INLINE_MITIGATIONS_ALREADY_EXIST")
 *    @arg @c kGTLROnDemandScanning_Justification_JustificationType_JustificationTypeUnspecified
 *        JUSTIFICATION_TYPE_UNSPECIFIED. (Value:
 *        "JUSTIFICATION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_Justification_JustificationType_VulnerableCodeCannotBeControlledByAdversary
 *        The vulnerable code cannot be controlled by an attacker to exploit the
 *        vulnerability. (Value:
 *        "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY")
 *    @arg @c kGTLROnDemandScanning_Justification_JustificationType_VulnerableCodeNotInExecutePath
 *        The vulnerable code can not be executed. Typically this case occurs
 *        when the product includes the vulnerable code but does not call or use
 *        the vulnerable code. (Value: "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH")
 *    @arg @c kGTLROnDemandScanning_Justification_JustificationType_VulnerableCodeNotPresent
 *        The vulnerable code is not present. Typically this case occurs when
 *        source code is configured or built in a way that excludes the
 *        vulnerable code. (Value: "VULNERABLE_CODE_NOT_PRESENT")
 */
@property(nonatomic, copy, nullable) NSString *justificationType;

@end


/**
 *  GTLROnDemandScanning_Jwt
 */
@interface GTLROnDemandScanning_Jwt : GTLRObject

/**
 *  The compact encoding of a JWS, which is always three base64 encoded strings
 *  joined by periods. For details, see:
 *  https://tools.ietf.org/html/rfc7515.html#section-3.1
 */
@property(nonatomic, copy, nullable) NSString *compactJwt;

@end


/**
 *  Indicates a language package available between this package and the
 *  customer's resource artifact.
 */
@interface GTLROnDemandScanning_LanguagePackageDependency : GTLRObject

@property(nonatomic, copy, nullable) NSString *package;
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Layer holds metadata specific to a layer of a Docker image.
 */
@interface GTLROnDemandScanning_Layer : GTLRObject

/** The recovered arguments to the Dockerfile directive. */
@property(nonatomic, copy, nullable) NSString *arguments;

/**
 *  Required. The recovered Dockerfile directive used to construct this layer.
 *  See https://docs.docker.com/engine/reference/builder/ for more information.
 */
@property(nonatomic, copy, nullable) NSString *directive;

@end


/**
 *  Details about the layer a package was found in.
 */
@interface GTLROnDemandScanning_LayerDetails : GTLRObject

/** The base images the layer is found within. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_BaseImage *> *baseImages;

/**
 *  The layer chain ID (sha256 hash) of the layer in the container image.
 *  https://github.com/opencontainers/image-spec/blob/main/config.md#layer-chainid
 */
@property(nonatomic, copy, nullable) NSString *chainId;

/**
 *  The layer build command that was used to build the layer. This may not be
 *  found in all layers depending on how the container image is built.
 */
@property(nonatomic, copy, nullable) NSString *command;

/** The diff ID (sha256 hash) of the layer in the container image. */
@property(nonatomic, copy, nullable) NSString *diffId;

/**
 *  The index of the layer in the container image.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

@end


/**
 *  License information.
 */
@interface GTLROnDemandScanning_License : GTLRObject

/** Comments */
@property(nonatomic, copy, nullable) NSString *comments;

/**
 *  Often a single license can be used to represent the licensing terms.
 *  Sometimes it is necessary to include a choice of one or more licenses or
 *  some combination of license identifiers. Examples: "LGPL-2.1-only OR MIT",
 *  "LGPL-2.1-only AND MIT", "GPL-2.0-or-later WITH Bison-exception-2.2".
 */
@property(nonatomic, copy, nullable) NSString *expression;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLROnDemandScanning_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Operation *> *operations;

/**
 *  Unordered list. Unreachable resources. Populated when the request sets
 *  `ListOperationsRequest.return_partial_success` and reads across collections
 *  e.g. when attempting to list all resources across all supported locations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListVulnerabilitiesResponse contains a single page of vulnerabilities
 *  resulting from a scan.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "occurrences" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLROnDemandScanning_ListVulnerabilitiesResponseV1 : GTLRCollectionObject

/**
 *  A page token that can be used in a subsequent call to ListVulnerabilities to
 *  continue retrieving results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of Vulnerability Occurrences resulting from a scan.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Occurrence *> *occurrences;

@end


/**
 *  An occurrence of a particular package installation found within a system's
 *  filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
 */
@interface GTLROnDemandScanning_Location : GTLRObject

/**
 *  Deprecated. The CPE URI in [CPE
 *  format](https://cpe.mitre.org/specification/)
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The path from which we gathered that this package/version is installed. */
@property(nonatomic, copy, nullable) NSString *path;

/** Deprecated. The version installed at this location. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *version;

@end


/**
 *  GTLROnDemandScanning_Maintainer
 */
@interface GTLROnDemandScanning_Maintainer : GTLRObject

@property(nonatomic, copy, nullable) NSString *email;
@property(nonatomic, copy, nullable) NSString *kind;
@property(nonatomic, copy, nullable) NSString *name;
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  GTLROnDemandScanning_Material
 */
@interface GTLROnDemandScanning_Material : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_Material_Digest *digest;
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  GTLROnDemandScanning_Material_Digest
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_Material_Digest : GTLRObject
@end


/**
 *  Other properties of the build.
 */
@interface GTLROnDemandScanning_Metadata : GTLRObject

/** The timestamp of when the build completed. */
@property(nonatomic, strong, nullable) GTLRDateTime *buildFinishedOn;

/**
 *  Identifies the particular build invocation, which can be useful for finding
 *  associated logs or other ad-hoc analysis. The value SHOULD be globally
 *  unique, per in-toto Provenance spec.
 */
@property(nonatomic, copy, nullable) NSString *buildInvocationId;

/** The timestamp of when the build started. */
@property(nonatomic, strong, nullable) GTLRDateTime *buildStartedOn;

/**
 *  Indicates that the builder claims certain fields in this message to be
 *  complete.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Completeness *completeness;

/**
 *  If true, the builder claims that running the recipe on materials will
 *  produce bit-for-bit identical output.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reproducible;

@end


/**
 *  Details about files that caused a compliance check to fail. display_command
 *  is a single command that can be used to display a list of non compliant
 *  files. When there is no such command, we can also iterate a list of non
 *  compliant file using 'path'.
 */
@interface GTLROnDemandScanning_NonCompliantFile : GTLRObject

/** Command to display the non-compliant files. */
@property(nonatomic, copy, nullable) NSString *displayCommand;

/** Empty if `display_command` is set. */
@property(nonatomic, copy, nullable) NSString *path;

/** Explains why a file is non compliant for a CIS check. */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  An instance of an analysis type that has been found on a resource.
 */
@interface GTLROnDemandScanning_Occurrence : GTLRObject

/** Describes an attestation of an artifact. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_AttestationOccurrence *attestation;

/** Describes a verifiable build. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildOccurrence *build;

/** Describes a compliance violation on a linked resource. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ComplianceOccurrence *compliance;

/** Output only. The time this occurrence was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Describes the deployment of an artifact on a runtime. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_DeploymentOccurrence *deployment;

/** Describes when a resource was discovered. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_DiscoveryOccurrence *discovery;

/** Describes an attestation of an artifact using dsse. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_DSSEAttestationOccurrence *dsseAttestation;

/** https://github.com/secure-systems-lab/dsse */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Envelope *envelope;

/**
 *  Describes how this resource derives from the basis in the associated note.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ImageOccurrence *image;

/**
 *  Output only. This explicitly denotes which of the occurrence details are
 *  specified. This field can be used as a filter in list requests.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Attestation This represents
 *        a logical "role" that can attest to artifacts. (Value: "ATTESTATION")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Build The note and
 *        occurrence assert build provenance. (Value: "BUILD")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Compliance This represents a
 *        Compliance Note (Value: "COMPLIANCE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Deployment The note and
 *        occurrence track deployment events. (Value: "DEPLOYMENT")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Discovery The note and
 *        occurrence track the initial discovery status of a resource. (Value:
 *        "DISCOVERY")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_DsseAttestation This
 *        represents a DSSE attestation Note (Value: "DSSE_ATTESTATION")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Image This represents an
 *        image basis relationship. (Value: "IMAGE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_NoteKindUnspecified Default
 *        value. This value is unused. (Value: "NOTE_KIND_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Package This represents a
 *        package installed via a package manager. (Value: "PACKAGE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_SbomReference This
 *        represents an SBOM Reference. (Value: "SBOM_REFERENCE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Secret This represents a
 *        secret. (Value: "SECRET")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Upgrade This represents an
 *        available package upgrade. (Value: "UPGRADE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Vulnerability The note and
 *        occurrence represent a package vulnerability. (Value: "VULNERABILITY")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_VulnerabilityAssessment This
 *        represents a Vulnerability Assessment. (Value:
 *        "VULNERABILITY_ASSESSMENT")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Output only. The name of the occurrence in the form of
 *  `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Immutable. The analysis note associated with this occurrence, in
 *  the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be used
 *  as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *noteName;

/** Describes the installation of a package on the linked resource. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_PackageOccurrence *package;

/** A description of actions that can be taken to remedy the note. */
@property(nonatomic, copy, nullable) NSString *remediation;

/**
 *  Required. Immutable. A URI that represents the resource for which the
 *  occurrence applies. For example,
 *  `https://gcr.io/project/image\@sha256:123abc` for a Docker image.
 */
@property(nonatomic, copy, nullable) NSString *resourceUri;

/** Describes a specific SBOM reference occurrences. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SBOMReferenceOccurrence *sbomReference;

/** Describes a secret. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SecretOccurrence *secret;

/** Output only. The time this occurrence was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Describes an available package upgrade on the linked resource. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_UpgradeOccurrence *upgrade;

/** Describes a security vulnerability. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_VulnerabilityOccurrence *vulnerability;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLROnDemandScanning_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Operation_Response : GTLRObject
@end


/**
 *  GTLROnDemandScanning_PackageData
 */
@interface GTLROnDemandScanning_PackageData : GTLRObject

/** The architecture of the package. */
@property(nonatomic, copy, nullable) NSString *architecture;

/** A bundle containing the binary and source information. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_BinarySourceInfo *> *binarySourceInfo;

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_PackageVersion *binaryVersion;

/**
 *  The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in which
 *  the vulnerability may manifest. Examples include distro or storage location
 *  for vulnerable jar.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  The dependency chain between this package and the user's artifact. List in
 *  order from the customer's package under review first, to the current package
 *  last. Inclusive of the original package and the current package.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_LanguagePackageDependency *> *dependencyChain;

/** The path to the jar file / go binary file. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_FileLocation *> *fileLocation;

/**
 *  HashDigest stores the SHA512 hash digest of the jar file if the package is
 *  of type Maven. This field will be unset for non Maven packages.
 */
@property(nonatomic, copy, nullable) NSString *hashDigest;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_LayerDetails *layerDetails;

/**
 *  The list of licenses found that are related to a given package. Note that
 *  licenses may also be stored on the BinarySourceInfo. If there is no
 *  BinarySourceInfo (because there's no concept of source vs binary), then it
 *  will be stored here, while if there are BinarySourceInfos, it will be stored
 *  there, as one source can have multiple binaries with different licenses.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *licenses;

/** The maintainer of the package. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Maintainer *maintainer;

/**
 *  The OS affected by a vulnerability Used to generate the cpe_uri for OS
 *  packages
 */
@property(nonatomic, copy, nullable) NSString *os;

/** The version of the OS Used to generate the cpe_uri for OS packages */
@property(nonatomic, copy, nullable) NSString *osVersion;

/** The package being analysed for vulnerabilities */
@property(nonatomic, copy, nullable) NSString *package;

/**
 *  The type of package: os, maven, go, etc.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Composer PHP
 *        packages from Composer package manager. (Value: "COMPOSER")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Go Go third-party
 *        packages. (Value: "GO")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_GoStdlib Go
 *        toolchain + standard library packages. (Value: "GO_STDLIB")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Maven Java packages
 *        from Maven. (Value: "MAVEN")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Npm NPM packages.
 *        (Value: "NPM")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Nuget Nuget
 *        (C#/.NET) packages. (Value: "NUGET")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Os Operating System
 *        (Value: "OS")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_PackageTypeUnspecified
 *        Value "PACKAGE_TYPE_UNSPECIFIED"
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Pypi Python
 *        packages. (Value: "PYPI")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Rubygems Ruby
 *        packges (from RubyGems package manager). (Value: "RUBYGEMS")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Rust Rust packages
 *        from Cargo (GitHub ecosystem is `RUST`). (Value: "RUST")
 *    @arg @c kGTLROnDemandScanning_PackageData_PackageType_Swift Swift packages
 *        from Swift Package Manager (SwiftPM). (Value: "SWIFT")
 */
@property(nonatomic, copy, nullable) NSString *packageType;

/** CVEs that this package is no longer vulnerable to */
@property(nonatomic, strong, nullable) NSArray<NSString *> *patchedCve;

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_PackageVersion *sourceVersion;

@property(nonatomic, copy, nullable) NSString *unused;

/** The version of the package being analysed */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  A detail for a distro and package this vulnerability occurrence was found in
 *  and its associated fix (if one is available).
 */
@interface GTLROnDemandScanning_PackageIssue : GTLRObject

/**
 *  Required. The [CPE URI](https://cpe.mitre.org/specification/) this
 *  vulnerability was found in.
 */
@property(nonatomic, copy, nullable) NSString *affectedCpeUri;

/** Required. The package this vulnerability was found in. */
@property(nonatomic, copy, nullable) NSString *affectedPackage;

/**
 *  Required. The version of the package that is installed on the resource
 *  affected by this vulnerability.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *affectedVersion;

/**
 *  Output only. The distro or language system assigned severity for this
 *  vulnerability when that is available and note provider assigned severity
 *  when it is not available.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_High High
 *        severity. (Value: "HIGH")
 *    @arg @c kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Low Low
 *        severity. (Value: "LOW")
 *    @arg @c kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Medium Medium
 *        severity. (Value: "MEDIUM")
 *    @arg @c kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLROnDemandScanning_PackageIssue_EffectiveSeverity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *effectiveSeverity;

/** The location at which this package was found. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_GrafeasV1FileLocation *> *fileLocation;

/**
 *  Output only. Whether a fix is available for this package.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fixAvailable;

/**
 *  The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability was
 *  fixed in. It is possible for this to be different from the affected_cpe_uri.
 */
@property(nonatomic, copy, nullable) NSString *fixedCpeUri;

/**
 *  The package this vulnerability was fixed in. It is possible for this to be
 *  different from the affected_package.
 */
@property(nonatomic, copy, nullable) NSString *fixedPackage;

/**
 *  Required. The version of the package this vulnerability was fixed in.
 *  Setting this to VersionKind.MAXIMUM means no fix is yet available.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *fixedVersion;

/** The type of package (e.g. OS, MAVEN, GO). */
@property(nonatomic, copy, nullable) NSString *packageType;

@end


/**
 *  Details on how a particular software package was installed on a system.
 */
@interface GTLROnDemandScanning_PackageOccurrence : GTLRObject

/**
 *  Output only. The CPU architecture for which packages in this distribution
 *  channel were built. Architecture will be blank for language packages.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_PackageOccurrence_Architecture_ArchitectureUnspecified
 *        Unknown architecture. (Value: "ARCHITECTURE_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_PackageOccurrence_Architecture_X64 X64
 *        architecture. (Value: "X64")
 *    @arg @c kGTLROnDemandScanning_PackageOccurrence_Architecture_X86 X86
 *        architecture. (Value: "X86")
 */
@property(nonatomic, copy, nullable) NSString *architecture;

/**
 *  Output only. The cpe_uri in [CPE
 *  format](https://cpe.mitre.org/specification/) denoting the package manager
 *  version distributing a package. The cpe_uri will be blank for language
 *  packages.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** Licenses that have been declared by the authors of the package. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_License *license;

/**
 *  All of the places within the filesystem versions of this package have been
 *  found.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Location *> *location;

/** Required. Output only. The name of the installed package. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The type of package; whether native or non native (e.g., ruby
 *  gems, node.js packages, etc.).
 */
@property(nonatomic, copy, nullable) NSString *packageType;

/** Output only. The version of the package. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *version;

@end


/**
 *  GTLROnDemandScanning_PackageVersion
 */
@interface GTLROnDemandScanning_PackageVersion : GTLRObject

/**
 *  The licenses associated with this package. Note that this has to go on the
 *  PackageVersion level, because we can have cases with images with the same
 *  source having different licences. E.g. in Alpine, musl and musl-utils both
 *  have the same origin musl, but have different sets of licenses.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *licenses;

@property(nonatomic, copy, nullable) NSString *name;
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Selects a repo using a Google Cloud Platform project ID (e.g.,
 *  winged-cargo-31) and a repo name within that project.
 */
@interface GTLROnDemandScanning_ProjectRepoId : GTLRObject

/** The ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The name of the repo. Leave empty for the default repo. */
@property(nonatomic, copy, nullable) NSString *repoName;

@end


/**
 *  GTLROnDemandScanning_ProvenanceBuilder
 */
@interface GTLROnDemandScanning_ProvenanceBuilder : GTLRObject

@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_ResourceDescriptor *> *builderDependencies;

/**
 *  identifier
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_ProvenanceBuilder_Version *version;

@end


/**
 *  GTLROnDemandScanning_ProvenanceBuilder_Version
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_ProvenanceBuilder_Version : GTLRObject
@end


/**
 *  Steps taken to build the artifact. For a TaskRun, typically each container
 *  corresponds to one step in the recipe.
 */
@interface GTLROnDemandScanning_Recipe : GTLRObject

/**
 *  Collection of all external inputs that influenced the build on top of
 *  recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
 *  type were "make", then this might be the flags passed to make aside from the
 *  target, which is captured in recipe.entryPoint. Since the arguments field
 *  can greatly vary in structure, depending on the builder and recipe type,
 *  this is of form "Any".
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Recipe_Arguments_Item *> *arguments;

/**
 *  Index in materials containing the recipe steps that are not implied by
 *  recipe.type. For example, if the recipe type were "make", then this would
 *  point to the source containing the Makefile, not the make program itself.
 *  Set to -1 if the recipe doesn't come from a material, as zero is default
 *  unset value for int64.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *definedInMaterial;

/**
 *  String identifying the entry point into the build. This is often a path to a
 *  configuration file and/or a target label within that file. The syntax and
 *  meaning are defined by recipe.type. For example, if the recipe type were
 *  "make", then this would reference the directory in which to run make as well
 *  as which target to use.
 */
@property(nonatomic, copy, nullable) NSString *entryPoint;

/**
 *  Any other builder-controlled inputs necessary for correctly evaluating the
 *  recipe. Usually only needed for reproducing the build but not evaluated as
 *  part of policy. Since the environment field can greatly vary in structure,
 *  depending on the builder and recipe type, this is of form "Any".
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Recipe_Environment_Item *> *environment;

/**
 *  URI indicating what type of recipe was performed. It determines the meaning
 *  of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  GTLROnDemandScanning_Recipe_Arguments_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Recipe_Arguments_Item : GTLRObject
@end


/**
 *  GTLROnDemandScanning_Recipe_Environment_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Recipe_Environment_Item : GTLRObject
@end


/**
 *  Metadata for any related URL information.
 */
@interface GTLROnDemandScanning_RelatedUrl : GTLRObject

/** Label to describe usage of the URL. */
@property(nonatomic, copy, nullable) NSString *label;

/** Specific URL associated with the resource. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Specifies details on how to handle (and presumably, fix) a vulnerability.
 */
@interface GTLROnDemandScanning_Remediation : GTLRObject

/** Contains a comprehensive human-readable discussion of the remediation. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  The type of remediation that can be applied.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_Remediation_RemediationType_Mitigation A
 *        MITIGATION is available. (Value: "MITIGATION")
 *    @arg @c kGTLROnDemandScanning_Remediation_RemediationType_NoFixPlanned No
 *        fix is planned. (Value: "NO_FIX_PLANNED")
 *    @arg @c kGTLROnDemandScanning_Remediation_RemediationType_NoneAvailable
 *        Not available. (Value: "NONE_AVAILABLE")
 *    @arg @c kGTLROnDemandScanning_Remediation_RemediationType_RemediationTypeUnspecified
 *        No remediation type specified. (Value: "REMEDIATION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_Remediation_RemediationType_VendorFix A
 *        vendor fix is available. (Value: "VENDOR_FIX")
 *    @arg @c kGTLROnDemandScanning_Remediation_RemediationType_Workaround A
 *        workaround is available. (Value: "WORKAROUND")
 */
@property(nonatomic, copy, nullable) NSString *remediationType;

/** Contains the URL where to obtain the remediation. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_RelatedUrl *remediationUri;

@end


/**
 *  A unique identifier for a Cloud Repo.
 */
@interface GTLROnDemandScanning_RepoId : GTLRObject

/** A combination of a project ID and a repo name. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ProjectRepoId *projectRepoId;

/** A server-assigned, globally unique identifier. */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  GTLROnDemandScanning_ResourceDescriptor
 */
@interface GTLROnDemandScanning_ResourceDescriptor : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_ResourceDescriptor_Annotations *annotations;

/**
 *  content
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *content;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_ResourceDescriptor_Digest *digest;
@property(nonatomic, copy, nullable) NSString *downloadLocation;
@property(nonatomic, copy, nullable) NSString *mediaType;
@property(nonatomic, copy, nullable) NSString *name;
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  GTLROnDemandScanning_ResourceDescriptor_Annotations
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_ResourceDescriptor_Annotations : GTLRObject
@end


/**
 *  GTLROnDemandScanning_ResourceDescriptor_Digest
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_ResourceDescriptor_Digest : GTLRObject
@end


/**
 *  GTLROnDemandScanning_Risk
 */
@interface GTLROnDemandScanning_Risk : GTLRObject

/**
 *  CISA maintains the authoritative source of vulnerabilities that have been
 *  exploited in the wild.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_CISAKnownExploitedVulnerabilities *cisaKev;

/**
 *  The Exploit Prediction Scoring System (EPSS) estimates the likelihood
 *  (probability) that a software vulnerability will be exploited in the wild.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ExploitPredictionScoringSystem *epss;

@end


/**
 *  GTLROnDemandScanning_RunDetails
 */
@interface GTLROnDemandScanning_RunDetails : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_ProvenanceBuilder *builder;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_ResourceDescriptor *> *byproducts;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildMetadata *metadata;

@end


/**
 *  The actual payload that contains the SBOM Reference data. The payload
 *  follows the intoto statement specification. See
 *  https://github.com/in-toto/attestation/blob/main/spec/v1.0/statement.md for
 *  more details.
 */
@interface GTLROnDemandScanning_SbomReferenceIntotoPayload : GTLRObject

/** Identifier for the schema of the Statement. */
@property(nonatomic, copy, nullable) NSString *xType;

/**
 *  Additional parameters of the Predicate. Includes the actual data about the
 *  SBOM.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SbomReferenceIntotoPredicate *predicate;

/** URI identifying the type of the Predicate. */
@property(nonatomic, copy, nullable) NSString *predicateType;

/**
 *  Set of software artifacts that the attestation applies to. Each element
 *  represents a single software artifact.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Subject *> *subject;

@end


/**
 *  A predicate which describes the SBOM being referenced.
 */
@interface GTLROnDemandScanning_SbomReferenceIntotoPredicate : GTLRObject

/** A map of algorithm to digest of the contents of the SBOM. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SbomReferenceIntotoPredicate_Digest *digest;

/** The location of the SBOM. */
@property(nonatomic, copy, nullable) NSString *location;

/** The mime type of the SBOM. */
@property(nonatomic, copy, nullable) NSString *mimeType;

/** The person or system referring this predicate to the consumer. */
@property(nonatomic, copy, nullable) NSString *referrerId;

@end


/**
 *  A map of algorithm to digest of the contents of the SBOM.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_SbomReferenceIntotoPredicate_Digest : GTLRObject
@end


/**
 *  The occurrence representing an SBOM reference as applied to a specific
 *  resource. The occurrence follows the DSSE specification. See
 *  https://github.com/secure-systems-lab/dsse/blob/master/envelope.md for more
 *  details.
 */
@interface GTLROnDemandScanning_SBOMReferenceOccurrence : GTLRObject

/** The actual payload that contains the SBOM reference data. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SbomReferenceIntotoPayload *payload;

/**
 *  The kind of payload that SbomReferenceIntotoPayload takes. Since it's in the
 *  intoto format, this value is expected to be 'application/vnd.in-toto+json'.
 */
@property(nonatomic, copy, nullable) NSString *payloadType;

/** The signatures over the payload. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_EnvelopeSignature *> *signatures;

@end


/**
 *  The status of an SBOM generation.
 */
@interface GTLROnDemandScanning_SBOMStatus : GTLRObject

/**
 *  If there was an error generating an SBOM, this will indicate what that error
 *  was.
 */
@property(nonatomic, copy, nullable) NSString *error;

/**
 *  The progress of the SBOM generation.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_SBOMStatus_SbomState_Complete SBOM scanning
 *        has completed. (Value: "COMPLETE")
 *    @arg @c kGTLROnDemandScanning_SBOMStatus_SbomState_Pending SBOM scanning
 *        is pending. (Value: "PENDING")
 *    @arg @c kGTLROnDemandScanning_SBOMStatus_SbomState_SbomStateUnspecified
 *        Default unknown state. (Value: "SBOM_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sbomState;

@end


/**
 *  The location of the secret.
 */
@interface GTLROnDemandScanning_SecretLocation : GTLRObject

/** The secret is found from a file. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1FileLocation *fileLocation;

@end


/**
 *  The occurrence provides details of a secret.
 */
@interface GTLROnDemandScanning_SecretOccurrence : GTLRObject

/**
 *  Required. Type of secret.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_SecretOccurrence_Kind_SecretKindGcpServiceAccountKey
 *        A GCP service account key per:
 *        https://cloud.google.com/iam/docs/creating-managing-service-account-keys
 *        (Value: "SECRET_KIND_GCP_SERVICE_ACCOUNT_KEY")
 *    @arg @c kGTLROnDemandScanning_SecretOccurrence_Kind_SecretKindUnknown The
 *        secret kind is unknown. (Value: "SECRET_KIND_UNKNOWN")
 *    @arg @c kGTLROnDemandScanning_SecretOccurrence_Kind_SecretKindUnspecified
 *        Unspecified (Value: "SECRET_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** Optional. Locations where the secret is detected. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_SecretLocation *> *locations;

/** Optional. Status of the secret. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_SecretStatus *> *statuses;

@end


/**
 *  The status of the secret with a timestamp.
 */
@interface GTLROnDemandScanning_SecretStatus : GTLRObject

/** Optional. Optional message about the status code. */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  Optional. The status of the secret.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_SecretStatus_Status_Invalid The secret is
 *        invalid. (Value: "INVALID")
 *    @arg @c kGTLROnDemandScanning_SecretStatus_Status_StatusUnspecified
 *        Unspecified (Value: "STATUS_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_SecretStatus_Status_Unknown The status of
 *        the secret is unknown. (Value: "UNKNOWN")
 *    @arg @c kGTLROnDemandScanning_SecretStatus_Status_Valid The secret is
 *        valid. (Value: "VALID")
 */
@property(nonatomic, copy, nullable) NSString *status;

/** Optional. The time the secret status was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Verifiers (e.g. Kritis implementations) MUST verify signatures with respect
 *  to the trust anchors defined in policy (e.g. a Kritis policy). Typically
 *  this means that the verifier has been configured with a map from
 *  `public_key_id` to public key material (and any required parameters, e.g.
 *  signing algorithm). In particular, verification implementations MUST NOT
 *  treat the signature `public_key_id` as anything more than a key lookup hint.
 *  The `public_key_id` DOES NOT validate or authenticate a public key; it only
 *  provides a mechanism for quickly selecting a public key ALREADY CONFIGURED
 *  on the verifier through a trusted channel. Verification implementations MUST
 *  reject signatures in any of the following circumstances: * The
 *  `public_key_id` is not recognized by the verifier. * The public key that
 *  `public_key_id` refers to does not verify the signature with respect to the
 *  payload. The `signature` contents SHOULD NOT be "attached" (where the
 *  payload is included with the serialized `signature` bytes). Verifiers MUST
 *  ignore any "attached" payload and only verify signatures with respect to
 *  explicitly provided payload (e.g. a `payload` field on the proto message
 *  that holds this Signature, or the canonical serialization of the proto
 *  message that holds this signature).
 */
@interface GTLROnDemandScanning_Signature : GTLRObject

/**
 *  The identifier for the public key that verifies this signature. * The
 *  `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986
 *  conformant URI. * When possible, the `public_key_id` SHOULD be an immutable
 *  reference, such as a cryptographic digest. Examples of valid
 *  `public_key_id`s: OpenPGP V4 public key fingerprint: *
 *  "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See
 *  https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
 *  details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of
 *  the DER serialization): *
 *  "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" *
 *  "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
 */
@property(nonatomic, copy, nullable) NSString *publicKeyId;

/**
 *  The content of the signature, an opaque bytestring. The payload that this
 *  signature verifies MUST be unambiguously provided with the Signature during
 *  verification. A wrapper message might provide the payload explicitly.
 *  Alternatively, a message might have a canonical serialization that can
 *  always be unambiguously computed to derive the payload.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  GTLROnDemandScanning_SlsaBuilder
 */
@interface GTLROnDemandScanning_SlsaBuilder : GTLRObject

/**
 *  identifier
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

@end


/**
 *  Indicates that the builder claims certain fields in this message to be
 *  complete.
 */
@interface GTLROnDemandScanning_SlsaCompleteness : GTLRObject

/**
 *  If true, the builder claims that recipe.arguments is complete, meaning that
 *  all external inputs are properly captured in the recipe.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *arguments;

/**
 *  If true, the builder claims that recipe.environment is claimed to be
 *  complete.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *environment;

/**
 *  If true, the builder claims that materials are complete, usually through
 *  some controls to prevent network access. Sometimes called "hermetic".
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *materials;

@end


/**
 *  Other properties of the build.
 */
@interface GTLROnDemandScanning_SlsaMetadata : GTLRObject

/** The timestamp of when the build completed. */
@property(nonatomic, strong, nullable) GTLRDateTime *buildFinishedOn;

/**
 *  Identifies the particular build invocation, which can be useful for finding
 *  associated logs or other ad-hoc analysis. The value SHOULD be globally
 *  unique, per in-toto Provenance spec.
 */
@property(nonatomic, copy, nullable) NSString *buildInvocationId;

/** The timestamp of when the build started. */
@property(nonatomic, strong, nullable) GTLRDateTime *buildStartedOn;

/**
 *  Indicates that the builder claims certain fields in this message to be
 *  complete.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaCompleteness *completeness;

/**
 *  If true, the builder claims that running the recipe on materials will
 *  produce bit-for-bit identical output.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reproducible;

@end


/**
 *  GTLROnDemandScanning_SlsaProvenance
 */
@interface GTLROnDemandScanning_SlsaProvenance : GTLRObject

/** required */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaBuilder *builder;

/**
 *  The collection of artifacts that influenced the build including sources,
 *  dependencies, build tools, base images, and so on. This is considered to be
 *  incomplete unless metadata.completeness.materials is true. Unset or null is
 *  equivalent to empty.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Material *> *materials;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaMetadata *metadata;

/**
 *  Identifies the configuration used for the build. When combined with
 *  materials, this SHOULD fully describe the build, such that re-running this
 *  recipe results in bit-for-bit identical output (if the build is
 *  reproducible). required
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaRecipe *recipe;

@end


/**
 *  Keep in sync with schema at
 *  https://github.com/slsa-framework/slsa/blob/main/docs/provenance/schema/v1/provenance.proto
 *  Builder renamed to ProvenanceBuilder because of Java conflicts.
 */
@interface GTLROnDemandScanning_SlsaProvenanceV1 : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildDefinition *buildDefinition;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_RunDetails *runDetails;

@end


/**
 *  See full explanation of fields at slsa.dev/provenance/v0.2.
 */
@interface GTLROnDemandScanning_SlsaProvenanceZeroTwo : GTLRObject

@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaProvenanceZeroTwo_BuildConfig *buildConfig;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaBuilder *builder;
@property(nonatomic, copy, nullable) NSString *buildType;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaInvocation *invocation;
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial *> *materials;
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GrafeasV1SlsaProvenanceZeroTwoSlsaMetadata *metadata;

@end


/**
 *  GTLROnDemandScanning_SlsaProvenanceZeroTwo_BuildConfig
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_SlsaProvenanceZeroTwo_BuildConfig : GTLRObject
@end


/**
 *  Steps taken to build the artifact. For a TaskRun, typically each container
 *  corresponds to one step in the recipe.
 */
@interface GTLROnDemandScanning_SlsaRecipe : GTLRObject

/**
 *  Collection of all external inputs that influenced the build on top of
 *  recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
 *  type were "make", then this might be the flags passed to make aside from the
 *  target, which is captured in recipe.entryPoint. Depending on the recipe
 *  Type, the structure may be different.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaRecipe_Arguments *arguments;

/**
 *  Index in materials containing the recipe steps that are not implied by
 *  recipe.type. For example, if the recipe type were "make", then this would
 *  point to the source containing the Makefile, not the make program itself.
 *  Set to -1 if the recipe doesn't come from a material, as zero is default
 *  unset value for int64.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *definedInMaterial;

/**
 *  String identifying the entry point into the build. This is often a path to a
 *  configuration file and/or a target label within that file. The syntax and
 *  meaning are defined by recipe.type. For example, if the recipe type were
 *  "make", then this would reference the directory in which to run make as well
 *  as which target to use.
 */
@property(nonatomic, copy, nullable) NSString *entryPoint;

/**
 *  Any other builder-controlled inputs necessary for correctly evaluating the
 *  recipe. Usually only needed for reproducing the build but not evaluated as
 *  part of policy. Depending on the recipe Type, the structure may be
 *  different.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SlsaRecipe_Environment *environment;

/**
 *  URI indicating what type of recipe was performed. It determines the meaning
 *  of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Collection of all external inputs that influenced the build on top of
 *  recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
 *  type were "make", then this might be the flags passed to make aside from the
 *  target, which is captured in recipe.entryPoint. Depending on the recipe
 *  Type, the structure may be different.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_SlsaRecipe_Arguments : GTLRObject
@end


/**
 *  Any other builder-controlled inputs necessary for correctly evaluating the
 *  recipe. Usually only needed for reproducing the build but not evaluated as
 *  part of policy. Depending on the recipe Type, the structure may be
 *  different.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_SlsaRecipe_Environment : GTLRObject
@end


/**
 *  Source describes the location of the source used for the build.
 */
@interface GTLROnDemandScanning_Source : GTLRObject

/**
 *  If provided, some of the source code used for the build may be found in
 *  these locations, in the case where the source repository had multiple
 *  remotes or submodules. This list will not include the context specified in
 *  the context field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_SourceContext *> *additionalContexts;

/**
 *  If provided, the input binary artifacts for the build came from this
 *  location.
 */
@property(nonatomic, copy, nullable) NSString *artifactStorageSourceUri;

/**
 *  If provided, the source code used for the build came from this location.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SourceContext *context;

/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build. The keys to this map are file
 *  paths used as build source and the values contain the hash values for those
 *  files. If the build source came in a single package such as a gzipped
 *  tarfile (.tar.gz), the FileHash will be for the single path to that file.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Source_FileHashes *fileHashes;

@end


/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build. The keys to this map are file
 *  paths used as build source and the values contain the hash values for those
 *  files. If the build source came in a single package such as a gzipped
 *  tarfile (.tar.gz), the FileHash will be for the single path to that file.
 *
 *  @note This class is documented as having more properties of
 *        GTLROnDemandScanning_FileHashes. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Source_FileHashes : GTLRObject
@end


/**
 *  A SourceContext is a reference to a tree of files. A SourceContext together
 *  with a path point to a unique revision of a single file or directory.
 */
@interface GTLROnDemandScanning_SourceContext : GTLRObject

/** A SourceContext referring to a revision in a Google Cloud Source Repo. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_CloudRepoSourceContext *cloudRepo;

/** A SourceContext referring to a Gerrit project. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GerritSourceContext *gerrit;

/** A SourceContext referring to any third party Git repo (e.g., GitHub). */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GitSourceContext *git;

/** Labels with user defined metadata. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SourceContext_Labels *labels;

@end


/**
 *  Labels with user defined metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_SourceContext_Labels : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLROnDemandScanning_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLROnDemandScanning_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Status_Details_Item : GTLRObject
@end


/**
 *  GTLROnDemandScanning_Subject
 */
@interface GTLROnDemandScanning_Subject : GTLRObject

/**
 *  `"": ""` Algorithms can be e.g. sha256, sha512 See
 *  https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Subject_Digest *digest;

@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  `"": ""` Algorithms can be e.g. sha256, sha512 See
 *  https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_Subject_Digest : GTLRObject
@end


/**
 *  The Upgrade Distribution represents metadata about the Upgrade for each
 *  operating system (CPE). Some distributions have additional metadata around
 *  updates, classifying them into various categories and severities.
 */
@interface GTLROnDemandScanning_UpgradeDistribution : GTLRObject

/**
 *  The operating system classification of this Upgrade, as specified by the
 *  upstream operating system upgrade feed. For Windows the classification is
 *  one of the category_ids listed at
 *  https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803(v=vs.85)
 */
@property(nonatomic, copy, nullable) NSString *classification;

/**
 *  Required - The specific operating system this metadata applies to. See
 *  https://cpe.mitre.org/specification/.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The cve tied to this Upgrade. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *cve;

/** The severity as specified by the upstream operating system. */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  An Upgrade Occurrence represents that a specific resource_url could install
 *  a specific upgrade. This presence is supplied via local sources (i.e. it is
 *  present in the mirror and the running system has noticed its availability).
 *  For Windows, both distribution and windows_update contain information for
 *  the Windows update.
 */
@interface GTLROnDemandScanning_UpgradeOccurrence : GTLRObject

/**
 *  Metadata about the upgrade for available for the specific operating system
 *  for the resource_url. This allows efficient filtering, as well as making it
 *  easier to use the occurrence.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_UpgradeDistribution *distribution;

/** Required for non-Windows OS. The package this Upgrade is for. */
@property(nonatomic, copy, nullable) NSString *package;

/**
 *  Required for non-Windows OS. The version of the package in a machine + human
 *  readable form.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *parsedVersion;

/**
 *  Required for Windows OS. Represents the metadata about the Windows update.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_WindowsUpdate *windowsUpdate;

@end


/**
 *  Version contains structured information about the version of a package.
 */
@interface GTLROnDemandScanning_Version : GTLRObject

/**
 *  Used to correct mistakes in the version numbering scheme.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *epoch;

/**
 *  Human readable version string. This string is of the form :- and is only set
 *  when kind is NORMAL.
 */
@property(nonatomic, copy, nullable) NSString *fullName;

/**
 *  Whether this version is specifying part of an inclusive range. Grafeas does
 *  not have the capability to specify version ranges; instead we have fields
 *  that specify start version and end versions. At times this is insufficient -
 *  we also need to specify whether the version is included in the range or is
 *  excluded from the range. This boolean is expected to be set to true when the
 *  version is included in a range.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inclusive;

/**
 *  Required. Distinguishes between sentinel MIN/MAX versions and normal
 *  versions.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_Version_Kind_Maximum A special version
 *        representing positive infinity. (Value: "MAXIMUM")
 *    @arg @c kGTLROnDemandScanning_Version_Kind_Minimum A special version
 *        representing negative infinity. (Value: "MINIMUM")
 *    @arg @c kGTLROnDemandScanning_Version_Kind_Normal A standard package
 *        version. (Value: "NORMAL")
 *    @arg @c kGTLROnDemandScanning_Version_Kind_VersionKindUnspecified Unknown.
 *        (Value: "VERSION_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Required only when version kind is NORMAL. The main part of the version
 *  name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The iteration of the package build from the above version. */
@property(nonatomic, copy, nullable) NSString *revision;

@end


/**
 *  VexAssessment provides all publisher provided Vex information that is
 *  related to this vulnerability.
 */
@interface GTLROnDemandScanning_VexAssessment : GTLRObject

/**
 *  Holds the MITRE standard Common Vulnerabilities and Exposures (CVE) tracking
 *  number for the vulnerability. Deprecated: Use vulnerability_id instead to
 *  denote CVEs.
 */
@property(nonatomic, copy, nullable) NSString *cve GTLR_DEPRECATED;

/**
 *  Contains information about the impact of this vulnerability, this will
 *  change with time.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *impacts;

/**
 *  Justification provides the justification when the state of the assessment if
 *  NOT_AFFECTED.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Justification *justification;

/**
 *  The VulnerabilityAssessment note from which this VexAssessment was
 *  generated. This will be of the form:
 *  `projects/[PROJECT_ID]/notes/[NOTE_ID]`.
 */
@property(nonatomic, copy, nullable) NSString *noteName;

/**
 *  Holds a list of references associated with this vulnerability item and
 *  assessment.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_RelatedUrl *> *relatedUris;

/**
 *  Specifies details on how to handle (and presumably, fix) a vulnerability.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Remediation *> *remediations;

/**
 *  Provides the state of this Vulnerability assessment.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_VexAssessment_State_Affected This product is
 *        known to be affected by this vulnerability. (Value: "AFFECTED")
 *    @arg @c kGTLROnDemandScanning_VexAssessment_State_Fixed This product
 *        contains a fix for this vulnerability. (Value: "FIXED")
 *    @arg @c kGTLROnDemandScanning_VexAssessment_State_NotAffected This product
 *        is known to be not affected by this vulnerability. (Value:
 *        "NOT_AFFECTED")
 *    @arg @c kGTLROnDemandScanning_VexAssessment_State_StateUnspecified No
 *        state is specified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_VexAssessment_State_UnderInvestigation It is
 *        not known yet whether these versions are or are not affected by the
 *        vulnerability. However, it is still under investigation. (Value:
 *        "UNDER_INVESTIGATION")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The vulnerability identifier for this Assessment. Will hold one of common
 *  identifiers e.g. CVE, GHSA etc.
 */
@property(nonatomic, copy, nullable) NSString *vulnerabilityId;

@end


/**
 *  An occurrence of a severity vulnerability on a resource.
 */
@interface GTLROnDemandScanning_VulnerabilityOccurrence : GTLRObject

/**
 *  Output only. The CVSS score of this vulnerability. CVSS score is on a scale
 *  of 0 - 10 where 0 indicates low severity and 10 indicates high severity.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssScore;

/** The cvss v2 score for the vulnerability. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_CVSS *cvssV2;

/** The cvss v3 score for the vulnerability. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_CVSS *cvssv3;

/**
 *  Output only. CVSS version used to populate cvss_score and severity.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_CvssVersion_CvssVersion2
 *        Value "CVSS_VERSION_2"
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_CvssVersion_CvssVersion3
 *        Value "CVSS_VERSION_3"
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_CvssVersion_CvssVersionUnspecified
 *        Value "CVSS_VERSION_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *cvssVersion;

/**
 *  The distro assigned severity for this vulnerability when it is available,
 *  otherwise this is the note provider assigned severity. When there are
 *  multiple PackageIssues for this vulnerability, they can have different
 *  effective severities because some might be provided by the distro while
 *  others are provided by the language ecosystem for a language pack. For this
 *  reason, it is advised to use the effective severity on the PackageIssue
 *  level. In the case where multiple PackageIssues have differing effective
 *  severities, this field should be the highest severity for any of the
 *  PackageIssues.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_High
 *        High severity. (Value: "HIGH")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Low
 *        Low severity. (Value: "LOW")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *effectiveSeverity;

/** Occurrence-specific extra details about the vulnerability. */
@property(nonatomic, copy, nullable) NSString *extraDetails;

/**
 *  Output only. Whether at least one of the affected packages has a fix
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fixAvailable;

/** Output only. A detailed description of this vulnerability. */
@property(nonatomic, copy, nullable) NSString *longDescription;

/**
 *  Required. The set of affected locations and their fixes (if available)
 *  within the associated resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_PackageIssue *> *packageIssue;

/** Output only. URLs related to this vulnerability. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_RelatedUrl *> *relatedUrls;

/** Risk information about the vulnerability, such as CISA, EPSS, etc. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Risk *risk;

/**
 *  Output only. The note provider assigned severity of this vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_High High
 *        severity. (Value: "HIGH")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Low Low
 *        severity. (Value: "LOW")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** Output only. A one sentence description of this vulnerability. */
@property(nonatomic, copy, nullable) NSString *shortDescription;

/**
 *  The type of package; whether native or non native (e.g., ruby gems, node.js
 *  packages, etc.).
 */
@property(nonatomic, copy, nullable) NSString *type;

@property(nonatomic, strong, nullable) GTLROnDemandScanning_VexAssessment *vexAssessment;

@end


/**
 *  Windows Update represents the metadata about the update for the Windows
 *  operating system. The fields in this message come from the Windows Update
 *  API documented at
 *  https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate.
 */
@interface GTLROnDemandScanning_WindowsUpdate : GTLRObject

/** The list of categories to which the update belongs. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Category *> *categories;

/**
 *  The localized description of the update.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Required - The unique identifier for the update. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Identity *identity;

/**
 *  The Microsoft Knowledge Base article IDs that are associated with the
 *  update.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kbArticleIds;

/** The last published timestamp of the update. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPublishedTimestamp;

/** The hyperlink to the support information for the update. */
@property(nonatomic, copy, nullable) NSString *supportUrl;

/** The localized title of the update. */
@property(nonatomic, copy, nullable) NSString *title;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
