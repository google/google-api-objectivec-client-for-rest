// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Network Management API (networkmanagement/v1)
// Description:
//   The Network Management API provides a collection of network performance
//   monitoring and diagnostic capabilities.
// Documentation:
//   https://cloud.google.com/

#import <GoogleAPIClientForREST/GTLRNetworkManagementObjects.h>

// ----------------------------------------------------------------------------
// Constants

// GTLRNetworkManagement_AbortInfo.cause
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_CauseUnspecified = @"CAUSE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_DestinationEndpointNotFound = @"DESTINATION_ENDPOINT_NOT_FOUND";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_FirewallConfigNotFound = @"FIREWALL_CONFIG_NOT_FOUND";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_GkeKonnectivityProxyUnsupported = @"GKE_KONNECTIVITY_PROXY_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_GoogleManagedServiceAmbiguousPscEndpoint = @"GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_GoogleManagedServiceUnknownIp = @"GOOGLE_MANAGED_SERVICE_UNKNOWN_IP";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_InternalError = @"INTERNAL_ERROR";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_InvalidArgument = @"INVALID_ARGUMENT";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_MismatchedDestinationNetwork = @"MISMATCHED_DESTINATION_NETWORK";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_MismatchedIpVersion = @"MISMATCHED_IP_VERSION";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_MismatchedSourceNetwork = @"MISMATCHED_SOURCE_NETWORK";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_NetworkConfigNotFound = @"NETWORK_CONFIG_NOT_FOUND";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_NoExternalIp = @"NO_EXTERNAL_IP";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_NonRoutableIpAddress = @"NON_ROUTABLE_IP_ADDRESS";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_NoSourceLocation = @"NO_SOURCE_LOCATION";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_PermissionDenied = @"PERMISSION_DENIED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_PermissionDeniedNoCloudNatConfigs = @"PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_PermissionDeniedNoNegEndpointConfigs = @"PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_ResourceConfigNotFound = @"RESOURCE_CONFIG_NOT_FOUND";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_RouteConfigNotFound = @"ROUTE_CONFIG_NOT_FOUND";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourceEndpointNotFound = @"SOURCE_ENDPOINT_NOT_FOUND";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourceForwardingRuleUnsupported = @"SOURCE_FORWARDING_RULE_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourceIpAddressNotInSourceNetwork = @"SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourcePscCloudSqlUnsupported = @"SOURCE_PSC_CLOUD_SQL_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourceRedisClusterUnsupported = @"SOURCE_REDIS_CLUSTER_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourceRedisInstanceUnsupported = @"SOURCE_REDIS_INSTANCE_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_TraceTooLong = @"TRACE_TOO_LONG";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnintendedDestination = @"UNINTENDED_DESTINATION";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownIp = @"UNKNOWN_IP";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownIssueInGoogleManagedProject = @"UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownNetwork = @"UNKNOWN_NETWORK";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownProject = @"UNKNOWN_PROJECT";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_Unsupported = @"UNSUPPORTED";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnsupportedGoogleManagedProjectConfig = @"UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG";
NSString * const kGTLRNetworkManagement_AbortInfo_Cause_VmInstanceConfigNotFound = @"VM_INSTANCE_CONFIG_NOT_FOUND";

// GTLRNetworkManagement_AuditLogConfig.logType
NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_AdminRead = @"ADMIN_READ";
NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_DataRead = @"DATA_READ";
NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_DataWrite = @"DATA_WRITE";
NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_LogTypeUnspecified = @"LOG_TYPE_UNSPECIFIED";

// GTLRNetworkManagement_DeliverInfo.target
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_AppEngineVersion = @"APP_ENGINE_VERSION";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_CloudFunction = @"CLOUD_FUNCTION";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_CloudRunRevision = @"CLOUD_RUN_REVISION";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_CloudSqlInstance = @"CLOUD_SQL_INSTANCE";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_GkeMaster = @"GKE_MASTER";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_GoogleApi = @"GOOGLE_API";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_GoogleManagedService = @"GOOGLE_MANAGED_SERVICE";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_Instance = @"INSTANCE";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_Internet = @"INTERNET";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_PrivateNetwork = @"PRIVATE_NETWORK";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_PscGoogleApi = @"PSC_GOOGLE_API";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_PscPublishedService = @"PSC_PUBLISHED_SERVICE";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_PscVpcSc = @"PSC_VPC_SC";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_RedisCluster = @"REDIS_CLUSTER";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_RedisInstance = @"REDIS_INSTANCE";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_ServerlessNeg = @"SERVERLESS_NEG";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_StorageBucket = @"STORAGE_BUCKET";
NSString * const kGTLRNetworkManagement_DeliverInfo_Target_TargetUnspecified = @"TARGET_UNSPECIFIED";

// GTLRNetworkManagement_DropInfo.cause
NSString * const kGTLRNetworkManagement_DropInfo_Cause_BackendServiceNamedPortNotDefined = @"BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CauseUnspecified = @"CAUSE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudFunctionNotActive = @"CLOUD_FUNCTION_NOT_ACTIVE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudNatNoAddresses = @"CLOUD_NAT_NO_ADDRESSES";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudRunRevisionNotReady = @"CLOUD_RUN_REVISION_NOT_READY";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlConnectorRequired = @"CLOUD_SQL_CONNECTOR_REQUIRED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceNoIpAddress = @"CLOUD_SQL_INSTANCE_NO_IP_ADDRESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceNoRoute = @"CLOUD_SQL_INSTANCE_NO_ROUTE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceNotConfiguredForExternalTraffic = @"CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceNotRunning = @"CLOUD_SQL_INSTANCE_NOT_RUNNING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceUnauthorizedAccess = @"CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlPscNegUnsupported = @"CLOUD_SQL_PSC_NEG_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DestinationIsPrivateNatIpRange = @"DESTINATION_IS_PRIVATE_NAT_IP_RANGE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideCloudSqlService = @"DROPPED_INSIDE_CLOUD_SQL_SERVICE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideGkeService = @"DROPPED_INSIDE_GKE_SERVICE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideGoogleManagedService = @"DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsidePscServiceProducer = @"DROPPED_INSIDE_PSC_SERVICE_PRODUCER";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideRedisClusterService = @"DROPPED_INSIDE_REDIS_CLUSTER_SERVICE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideRedisInstanceService = @"DROPPED_INSIDE_REDIS_INSTANCE_SERVICE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_FirewallBlockingLoadBalancerBackendHealthCheck = @"FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_FirewallRule = @"FIREWALL_RULE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForeignIpDisallowed = @"FOREIGN_IP_DISALLOWED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleMismatch = @"FORWARDING_RULE_MISMATCH";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleNoInstances = @"FORWARDING_RULE_NO_INSTANCES";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleRegionMismatch = @"FORWARDING_RULE_REGION_MISMATCH";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GkeClusterNotRunning = @"GKE_CLUSTER_NOT_RUNNING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GkeControlPlaneNoRoute = @"GKE_CONTROL_PLANE_NO_ROUTE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GkeControlPlaneRegionMismatch = @"GKE_CONTROL_PLANE_REGION_MISMATCH";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GkeMasterUnauthorizedAccess = @"GKE_MASTER_UNAUTHORIZED_ACCESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GkePscEndpointMissing = @"GKE_PSC_ENDPOINT_MISSING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GoogleManagedServiceNoPeering = @"GOOGLE_MANAGED_SERVICE_NO_PEERING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_GoogleManagedServiceNoPscEndpoint = @"GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_HybridNegNonDynamicRouteMatched = @"HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_HybridNegNonLocalDynamicRouteMatched = @"HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_InstanceNotRunning = @"INSTANCE_NOT_RUNNING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_LoadBalancerBackendInvalidNetwork = @"LOAD_BALANCER_BACKEND_INVALID_NETWORK";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_LoadBalancerHasNoProxySubnet = @"LOAD_BALANCER_HAS_NO_PROXY_SUBNET";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoAdvertisedRouteToGcpDestination = @"NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoExternalAddress = @"NO_EXTERNAL_ADDRESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoNatSubnetsForPscServiceAttachment = @"NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoRoute = @"NO_ROUTE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoRouteFromInternetToPrivateIpv6Address = @"NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoTrafficSelectorToGcpDestination = @"NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PrivateGoogleAccessDisallowed = @"PRIVATE_GOOGLE_ACCESS_DISALLOWED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PrivateGoogleAccessViaVpnTunnelUnsupported = @"PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PrivateTrafficToInternet = @"PRIVATE_TRAFFIC_TO_INTERNET";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PscConnectionNotAccepted = @"PSC_CONNECTION_NOT_ACCEPTED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PscEndpointAccessedFromPeeredNetwork = @"PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PscNegProducerEndpointNoGlobalAccess = @"PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PscNegProducerForwardingRuleMultiplePorts = @"PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PscTransitivityNotPropagated = @"PSC_TRANSITIVITY_NOT_PROPAGATED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PublicCloudSqlInstanceToPrivateDestination = @"PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_PublicGkeControlPlaneToPrivateDestination = @"PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisClusterNoExternalIp = @"REDIS_CLUSTER_NO_EXTERNAL_IP";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisClusterNotRunning = @"REDIS_CLUSTER_NOT_RUNNING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisClusterUnsupportedPort = @"REDIS_CLUSTER_UNSUPPORTED_PORT";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisClusterUnsupportedProtocol = @"REDIS_CLUSTER_UNSUPPORTED_PROTOCOL";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisInstanceConnectingFromPupiAddress = @"REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisInstanceNoExternalIp = @"REDIS_INSTANCE_NO_EXTERNAL_IP";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisInstanceNoRouteToDestinationNetwork = @"REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisInstanceNotRunning = @"REDIS_INSTANCE_NOT_RUNNING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisInstanceUnsupportedPort = @"REDIS_INSTANCE_UNSUPPORTED_PORT";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RedisInstanceUnsupportedProtocol = @"REDIS_INSTANCE_UNSUPPORTED_PROTOCOL";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteBlackhole = @"ROUTE_BLACKHOLE";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopForwardingRuleIpMismatch = @"ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopForwardingRuleTypeInvalid = @"ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopInstanceNonPrimaryIp = @"ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopInstanceWrongNetwork = @"ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopIpAddressNotResolved = @"ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopResourceNotFound = @"ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteNextHopVpnTunnelNotEstablished = @"ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteWrongNetwork = @"ROUTE_WRONG_NETWORK";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_RoutingLoop = @"ROUTING_LOOP";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_TrafficTypeBlocked = @"TRAFFIC_TYPE_BLOCKED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_UnknownExternalAddress = @"UNKNOWN_EXTERNAL_ADDRESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_UnknownInternalAddress = @"UNKNOWN_INTERNAL_ADDRESS";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_VpcConnectorHealthCheckTrafficBlocked = @"VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_VpcConnectorNotRunning = @"VPC_CONNECTOR_NOT_RUNNING";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_VpcConnectorNotSet = @"VPC_CONNECTOR_NOT_SET";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_VpcConnectorServerlessTrafficBlocked = @"VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_VpnTunnelLocalSelectorMismatch = @"VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH";
NSString * const kGTLRNetworkManagement_DropInfo_Cause_VpnTunnelRemoteSelectorMismatch = @"VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH";

// GTLRNetworkManagement_Endpoint.forwardingRuleTarget
NSString * const kGTLRNetworkManagement_Endpoint_ForwardingRuleTarget_ForwardingRuleTargetUnspecified = @"FORWARDING_RULE_TARGET_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_Endpoint_ForwardingRuleTarget_Instance = @"INSTANCE";
NSString * const kGTLRNetworkManagement_Endpoint_ForwardingRuleTarget_LoadBalancer = @"LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_ForwardingRuleTarget_Psc = @"PSC";
NSString * const kGTLRNetworkManagement_Endpoint_ForwardingRuleTarget_VpnGateway = @"VPN_GATEWAY";

// GTLRNetworkManagement_Endpoint.loadBalancerType
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_HttpsAdvancedLoadBalancer = @"HTTPS_ADVANCED_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_HttpsLoadBalancer = @"HTTPS_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_InternalHttpsLoadBalancer = @"INTERNAL_HTTPS_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_InternalTcpProxyLoadBalancer = @"INTERNAL_TCP_PROXY_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_LegacyNetworkLoadBalancer = @"LEGACY_NETWORK_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_LoadBalancerTypeUnspecified = @"LOAD_BALANCER_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_NetworkLoadBalancer = @"NETWORK_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_RegionalHttpsLoadBalancer = @"REGIONAL_HTTPS_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_SslProxyLoadBalancer = @"SSL_PROXY_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_TcpProxyLoadBalancer = @"TCP_PROXY_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Endpoint_LoadBalancerType_TcpUdpInternalLoadBalancer = @"TCP_UDP_INTERNAL_LOAD_BALANCER";

// GTLRNetworkManagement_Endpoint.networkType
NSString * const kGTLRNetworkManagement_Endpoint_NetworkType_GcpNetwork = @"GCP_NETWORK";
NSString * const kGTLRNetworkManagement_Endpoint_NetworkType_NetworkTypeUnspecified = @"NETWORK_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_Endpoint_NetworkType_NonGcpNetwork = @"NON_GCP_NETWORK";

// GTLRNetworkManagement_FirewallInfo.firewallRuleType
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_FirewallRuleTypeUnspecified = @"FIREWALL_RULE_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_HierarchicalFirewallPolicyRule = @"HIERARCHICAL_FIREWALL_POLICY_RULE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_ImpliedVpcFirewallRule = @"IMPLIED_VPC_FIREWALL_RULE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_NetworkFirewallPolicyRule = @"NETWORK_FIREWALL_POLICY_RULE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_NetworkRegionalFirewallPolicyRule = @"NETWORK_REGIONAL_FIREWALL_POLICY_RULE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_ServerlessVpcAccessManagedFirewallRule = @"SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_TrackingState = @"TRACKING_STATE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_UnsupportedFirewallPolicyRule = @"UNSUPPORTED_FIREWALL_POLICY_RULE";
NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_VpcFirewallRule = @"VPC_FIREWALL_RULE";

// GTLRNetworkManagement_ForwardInfo.target
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_AnotherProject = @"ANOTHER_PROJECT";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_CloudSqlInstance = @"CLOUD_SQL_INSTANCE";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_GkeMaster = @"GKE_MASTER";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_ImportedCustomRouteNextHop = @"IMPORTED_CUSTOM_ROUTE_NEXT_HOP";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_Interconnect = @"INTERCONNECT";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_NccHub = @"NCC_HUB";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_PeeringVpc = @"PEERING_VPC";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_RouterAppliance = @"ROUTER_APPLIANCE";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_TargetUnspecified = @"TARGET_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_ForwardInfo_Target_VpnGateway = @"VPN_GATEWAY";

// GTLRNetworkManagement_GoogleServiceInfo.googleServiceType
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_CloudDns = @"CLOUD_DNS";
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_GfeProxyOrHealthCheckProber = @"GFE_PROXY_OR_HEALTH_CHECK_PROBER";
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_GoogleApi = @"GOOGLE_API";
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_GoogleApiPsc = @"GOOGLE_API_PSC";
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_GoogleApiVpcSc = @"GOOGLE_API_VPC_SC";
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_GoogleServiceTypeUnspecified = @"GOOGLE_SERVICE_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_GoogleServiceInfo_GoogleServiceType_Iap = @"IAP";

// GTLRNetworkManagement_LoadBalancerBackend.healthCheckFirewallState
NSString * const kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_Configured = @"CONFIGURED";
NSString * const kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_HealthCheckFirewallStateUnspecified = @"HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_Misconfigured = @"MISCONFIGURED";

// GTLRNetworkManagement_LoadBalancerBackendInfo.healthCheckFirewallsConfigState
NSString * const kGTLRNetworkManagement_LoadBalancerBackendInfo_HealthCheckFirewallsConfigState_FirewallsConfigured = @"FIREWALLS_CONFIGURED";
NSString * const kGTLRNetworkManagement_LoadBalancerBackendInfo_HealthCheckFirewallsConfigState_FirewallsNotConfigured = @"FIREWALLS_NOT_CONFIGURED";
NSString * const kGTLRNetworkManagement_LoadBalancerBackendInfo_HealthCheckFirewallsConfigState_FirewallsPartiallyConfigured = @"FIREWALLS_PARTIALLY_CONFIGURED";
NSString * const kGTLRNetworkManagement_LoadBalancerBackendInfo_HealthCheckFirewallsConfigState_FirewallsUnsupported = @"FIREWALLS_UNSUPPORTED";
NSString * const kGTLRNetworkManagement_LoadBalancerBackendInfo_HealthCheckFirewallsConfigState_HealthCheckFirewallsConfigStateUnspecified = @"HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED";

// GTLRNetworkManagement_LoadBalancerInfo.backendType
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_BackendService = @"BACKEND_SERVICE";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_BackendTypeUnspecified = @"BACKEND_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_TargetInstance = @"TARGET_INSTANCE";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_TargetPool = @"TARGET_POOL";

// GTLRNetworkManagement_LoadBalancerInfo.loadBalancerType
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_HttpProxy = @"HTTP_PROXY";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_InternalTcpUdp = @"INTERNAL_TCP_UDP";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_LoadBalancerTypeUnspecified = @"LOAD_BALANCER_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_NetworkTcpUdp = @"NETWORK_TCP_UDP";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_SslProxy = @"SSL_PROXY";
NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_TcpProxy = @"TCP_PROXY";

// GTLRNetworkManagement_NatInfo.type
NSString * const kGTLRNetworkManagement_NatInfo_Type_CloudNat  = @"CLOUD_NAT";
NSString * const kGTLRNetworkManagement_NatInfo_Type_ExternalToInternal = @"EXTERNAL_TO_INTERNAL";
NSString * const kGTLRNetworkManagement_NatInfo_Type_InternalToExternal = @"INTERNAL_TO_EXTERNAL";
NSString * const kGTLRNetworkManagement_NatInfo_Type_PrivateServiceConnect = @"PRIVATE_SERVICE_CONNECT";
NSString * const kGTLRNetworkManagement_NatInfo_Type_TypeUnspecified = @"TYPE_UNSPECIFIED";

// GTLRNetworkManagement_ProbingDetails.abortCause
NSString * const kGTLRNetworkManagement_ProbingDetails_AbortCause_NoSourceLocation = @"NO_SOURCE_LOCATION";
NSString * const kGTLRNetworkManagement_ProbingDetails_AbortCause_PermissionDenied = @"PERMISSION_DENIED";
NSString * const kGTLRNetworkManagement_ProbingDetails_AbortCause_ProbingAbortCauseUnspecified = @"PROBING_ABORT_CAUSE_UNSPECIFIED";

// GTLRNetworkManagement_ProbingDetails.result
NSString * const kGTLRNetworkManagement_ProbingDetails_Result_ProbingResultUnspecified = @"PROBING_RESULT_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_ProbingDetails_Result_ReachabilityInconsistent = @"REACHABILITY_INCONSISTENT";
NSString * const kGTLRNetworkManagement_ProbingDetails_Result_Reachable = @"REACHABLE";
NSString * const kGTLRNetworkManagement_ProbingDetails_Result_Undetermined = @"UNDETERMINED";
NSString * const kGTLRNetworkManagement_ProbingDetails_Result_Unreachable = @"UNREACHABLE";

// GTLRNetworkManagement_ReachabilityDetails.result
NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Ambiguous = @"AMBIGUOUS";
NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Reachable = @"REACHABLE";
NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_ResultUnspecified = @"RESULT_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Undetermined = @"UNDETERMINED";
NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Unreachable = @"UNREACHABLE";

// GTLRNetworkManagement_RouteInfo.nextHopType
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopBlackhole = @"NEXT_HOP_BLACKHOLE";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopIlb = @"NEXT_HOP_ILB";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInstance = @"NEXT_HOP_INSTANCE";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInterconnect = @"NEXT_HOP_INTERCONNECT";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInternetGateway = @"NEXT_HOP_INTERNET_GATEWAY";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopIp = @"NEXT_HOP_IP";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopNccHub = @"NEXT_HOP_NCC_HUB";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopNetwork = @"NEXT_HOP_NETWORK";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopPeering = @"NEXT_HOP_PEERING";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopRouterAppliance = @"NEXT_HOP_ROUTER_APPLIANCE";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopTypeUnspecified = @"NEXT_HOP_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopVpnGateway = @"NEXT_HOP_VPN_GATEWAY";
NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopVpnTunnel = @"NEXT_HOP_VPN_TUNNEL";

// GTLRNetworkManagement_RouteInfo.routeScope
NSString * const kGTLRNetworkManagement_RouteInfo_RouteScope_NccHub = @"NCC_HUB";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteScope_Network = @"NETWORK";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteScope_RouteScopeUnspecified = @"ROUTE_SCOPE_UNSPECIFIED";

// GTLRNetworkManagement_RouteInfo.routeType
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_Dynamic = @"DYNAMIC";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PeeringDynamic = @"PEERING_DYNAMIC";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PeeringStatic = @"PEERING_STATIC";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PeeringSubnet = @"PEERING_SUBNET";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PolicyBased = @"POLICY_BASED";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_RouteTypeUnspecified = @"ROUTE_TYPE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_Static = @"STATIC";
NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_Subnet = @"SUBNET";

// GTLRNetworkManagement_Step.state
NSString * const kGTLRNetworkManagement_Step_State_Abort       = @"ABORT";
NSString * const kGTLRNetworkManagement_Step_State_AnalyzeLoadBalancerBackend = @"ANALYZE_LOAD_BALANCER_BACKEND";
NSString * const kGTLRNetworkManagement_Step_State_ApplyEgressFirewallRule = @"APPLY_EGRESS_FIREWALL_RULE";
NSString * const kGTLRNetworkManagement_Step_State_ApplyForwardingRule = @"APPLY_FORWARDING_RULE";
NSString * const kGTLRNetworkManagement_Step_State_ApplyIngressFirewallRule = @"APPLY_INGRESS_FIREWALL_RULE";
NSString * const kGTLRNetworkManagement_Step_State_ApplyRoute  = @"APPLY_ROUTE";
NSString * const kGTLRNetworkManagement_Step_State_ArriveAtExternalLoadBalancer = @"ARRIVE_AT_EXTERNAL_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Step_State_ArriveAtInstance = @"ARRIVE_AT_INSTANCE";
NSString * const kGTLRNetworkManagement_Step_State_ArriveAtInternalLoadBalancer = @"ARRIVE_AT_INTERNAL_LOAD_BALANCER";
NSString * const kGTLRNetworkManagement_Step_State_ArriveAtVpcConnector = @"ARRIVE_AT_VPC_CONNECTOR";
NSString * const kGTLRNetworkManagement_Step_State_ArriveAtVpnGateway = @"ARRIVE_AT_VPN_GATEWAY";
NSString * const kGTLRNetworkManagement_Step_State_ArriveAtVpnTunnel = @"ARRIVE_AT_VPN_TUNNEL";
NSString * const kGTLRNetworkManagement_Step_State_Deliver     = @"DELIVER";
NSString * const kGTLRNetworkManagement_Step_State_Drop        = @"DROP";
NSString * const kGTLRNetworkManagement_Step_State_Forward     = @"FORWARD";
NSString * const kGTLRNetworkManagement_Step_State_Nat         = @"NAT";
NSString * const kGTLRNetworkManagement_Step_State_ProxyConnection = @"PROXY_CONNECTION";
NSString * const kGTLRNetworkManagement_Step_State_SpoofingApproved = @"SPOOFING_APPROVED";
NSString * const kGTLRNetworkManagement_Step_State_StartFromAppEngineVersion = @"START_FROM_APP_ENGINE_VERSION";
NSString * const kGTLRNetworkManagement_Step_State_StartFromCloudFunction = @"START_FROM_CLOUD_FUNCTION";
NSString * const kGTLRNetworkManagement_Step_State_StartFromCloudRunRevision = @"START_FROM_CLOUD_RUN_REVISION";
NSString * const kGTLRNetworkManagement_Step_State_StartFromCloudSqlInstance = @"START_FROM_CLOUD_SQL_INSTANCE";
NSString * const kGTLRNetworkManagement_Step_State_StartFromGkeMaster = @"START_FROM_GKE_MASTER";
NSString * const kGTLRNetworkManagement_Step_State_StartFromGoogleService = @"START_FROM_GOOGLE_SERVICE";
NSString * const kGTLRNetworkManagement_Step_State_StartFromInstance = @"START_FROM_INSTANCE";
NSString * const kGTLRNetworkManagement_Step_State_StartFromInternet = @"START_FROM_INTERNET";
NSString * const kGTLRNetworkManagement_Step_State_StartFromPrivateNetwork = @"START_FROM_PRIVATE_NETWORK";
NSString * const kGTLRNetworkManagement_Step_State_StartFromPscPublishedService = @"START_FROM_PSC_PUBLISHED_SERVICE";
NSString * const kGTLRNetworkManagement_Step_State_StartFromRedisCluster = @"START_FROM_REDIS_CLUSTER";
NSString * const kGTLRNetworkManagement_Step_State_StartFromRedisInstance = @"START_FROM_REDIS_INSTANCE";
NSString * const kGTLRNetworkManagement_Step_State_StartFromServerlessNeg = @"START_FROM_SERVERLESS_NEG";
NSString * const kGTLRNetworkManagement_Step_State_StartFromStorageBucket = @"START_FROM_STORAGE_BUCKET";
NSString * const kGTLRNetworkManagement_Step_State_StateUnspecified = @"STATE_UNSPECIFIED";
NSString * const kGTLRNetworkManagement_Step_State_ViewerPermissionMissing = @"VIEWER_PERMISSION_MISSING";

// GTLRNetworkManagement_VpnTunnelInfo.routingType
NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_Dynamic = @"DYNAMIC";
NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_PolicyBased = @"POLICY_BASED";
NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_RouteBased = @"ROUTE_BASED";
NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_RoutingTypeUnspecified = @"ROUTING_TYPE_UNSPECIFIED";

// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_AbortInfo
//

@implementation GTLRNetworkManagement_AbortInfo
@dynamic cause, ipAddress, projectsMissingPermission, resourceUri;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"projectsMissingPermission" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_AppEngineVersionEndpoint
//

@implementation GTLRNetworkManagement_AppEngineVersionEndpoint
@dynamic uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_AppEngineVersionInfo
//

@implementation GTLRNetworkManagement_AppEngineVersionInfo
@dynamic displayName, environment, runtime, uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_AuditConfig
//

@implementation GTLRNetworkManagement_AuditConfig
@dynamic auditLogConfigs, service;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"auditLogConfigs" : [GTLRNetworkManagement_AuditLogConfig class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_AuditLogConfig
//

@implementation GTLRNetworkManagement_AuditLogConfig
@dynamic exemptedMembers, logType;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"exemptedMembers" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Binding
//

@implementation GTLRNetworkManagement_Binding
@dynamic condition, members, role;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"members" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_CancelOperationRequest
//

@implementation GTLRNetworkManagement_CancelOperationRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_CloudFunctionEndpoint
//

@implementation GTLRNetworkManagement_CloudFunctionEndpoint
@dynamic uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_CloudFunctionInfo
//

@implementation GTLRNetworkManagement_CloudFunctionInfo
@dynamic displayName, location, uri, versionId;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_CloudRunRevisionEndpoint
//

@implementation GTLRNetworkManagement_CloudRunRevisionEndpoint
@dynamic uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_CloudRunRevisionInfo
//

@implementation GTLRNetworkManagement_CloudRunRevisionInfo
@dynamic displayName, location, serviceUri, uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_CloudSQLInstanceInfo
//

@implementation GTLRNetworkManagement_CloudSQLInstanceInfo
@dynamic displayName, externalIp, internalIp, networkUri, region, uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ConnectivityTest
//

@implementation GTLRNetworkManagement_ConnectivityTest
@dynamic bypassFirewallChecks, createTime, descriptionProperty, destination,
         displayName, labels, name, probingDetails, protocol,
         reachabilityDetails, relatedProjects, source, updateTime;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"relatedProjects" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ConnectivityTest_Labels
//

@implementation GTLRNetworkManagement_ConnectivityTest_Labels

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_DeliverInfo
//

@implementation GTLRNetworkManagement_DeliverInfo
@dynamic ipAddress, pscGoogleApiTarget, resourceUri, storageBucket, target;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_DropInfo
//

@implementation GTLRNetworkManagement_DropInfo
@dynamic cause, destinationIp, region, resourceUri, sourceIp;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_EdgeLocation
//

@implementation GTLRNetworkManagement_EdgeLocation
@dynamic metropolitanArea;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Empty
//

@implementation GTLRNetworkManagement_Empty
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Endpoint
//

@implementation GTLRNetworkManagement_Endpoint
@dynamic appEngineVersion, cloudFunction, cloudRunRevision, cloudSqlInstance,
         forwardingRule, forwardingRuleTarget, gkeMasterCluster, instance,
         ipAddress, loadBalancerId, loadBalancerType, network, networkType,
         port, projectId;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_EndpointInfo
//

@implementation GTLRNetworkManagement_EndpointInfo
@dynamic destinationIp, destinationNetworkUri, destinationPort, protocol,
         sourceAgentUri, sourceIp, sourceNetworkUri, sourcePort;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Expr
//

@implementation GTLRNetworkManagement_Expr
@dynamic descriptionProperty, expression, location, title;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_FirewallInfo
//

@implementation GTLRNetworkManagement_FirewallInfo
@dynamic action, direction, displayName, firewallRuleType, networkUri, policy,
         policyUri, priority, targetServiceAccounts, targetTags, uri;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"targetServiceAccounts" : [NSString class],
    @"targetTags" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ForwardInfo
//

@implementation GTLRNetworkManagement_ForwardInfo
@dynamic ipAddress, resourceUri, target;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ForwardingRuleInfo
//

@implementation GTLRNetworkManagement_ForwardingRuleInfo
@dynamic displayName, loadBalancerName, matchedPortRange, matchedProtocol,
         networkUri, pscGoogleApiTarget, pscServiceAttachmentUri, region,
         target, uri, vip;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_GKEMasterInfo
//

@implementation GTLRNetworkManagement_GKEMasterInfo
@dynamic clusterNetworkUri, clusterUri, externalIp, internalIp;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_GoogleServiceInfo
//

@implementation GTLRNetworkManagement_GoogleServiceInfo
@dynamic googleServiceType, sourceIp;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_InstanceInfo
//

@implementation GTLRNetworkManagement_InstanceInfo
@dynamic displayName, externalIp, interface, internalIp, networkTags,
         networkUri, pscNetworkAttachmentUri, serviceAccount, uri;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"networkTags" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_LatencyDistribution
//

@implementation GTLRNetworkManagement_LatencyDistribution
@dynamic latencyPercentiles;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"latencyPercentiles" : [GTLRNetworkManagement_LatencyPercentile class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_LatencyPercentile
//

@implementation GTLRNetworkManagement_LatencyPercentile
@dynamic latencyMicros, percent;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ListConnectivityTestsResponse
//

@implementation GTLRNetworkManagement_ListConnectivityTestsResponse
@dynamic nextPageToken, resources, unreachable;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"resources" : [GTLRNetworkManagement_ConnectivityTest class],
    @"unreachable" : [NSString class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"resources";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ListLocationsResponse
//

@implementation GTLRNetworkManagement_ListLocationsResponse
@dynamic locations, nextPageToken;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"locations" : [GTLRNetworkManagement_Location class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"locations";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ListOperationsResponse
//

@implementation GTLRNetworkManagement_ListOperationsResponse
@dynamic nextPageToken, operations;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"operations" : [GTLRNetworkManagement_Operation class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"operations";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_LoadBalancerBackend
//

@implementation GTLRNetworkManagement_LoadBalancerBackend
@dynamic displayName, healthCheckAllowingFirewallRules,
         healthCheckBlockingFirewallRules, healthCheckFirewallState, uri;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"healthCheckAllowingFirewallRules" : [NSString class],
    @"healthCheckBlockingFirewallRules" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_LoadBalancerBackendInfo
//

@implementation GTLRNetworkManagement_LoadBalancerBackendInfo
@dynamic backendBucketUri, backendServiceUri, healthCheckFirewallsConfigState,
         healthCheckUri, instanceGroupUri, instanceUri, name,
         networkEndpointGroupUri, pscGoogleApiTarget, pscServiceAttachmentUri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_LoadBalancerInfo
//

@implementation GTLRNetworkManagement_LoadBalancerInfo
@dynamic backends, backendType, backendUri, healthCheckUri, loadBalancerType;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"backends" : [GTLRNetworkManagement_LoadBalancerBackend class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Location
//

@implementation GTLRNetworkManagement_Location
@dynamic displayName, labels, locationId, metadata, name;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Location_Labels
//

@implementation GTLRNetworkManagement_Location_Labels

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Location_Metadata
//

@implementation GTLRNetworkManagement_Location_Metadata

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_NatInfo
//

@implementation GTLRNetworkManagement_NatInfo
@dynamic natGatewayName, networkUri, newDestinationIp, newDestinationPort,
         newSourceIp, newSourcePort, oldDestinationIp, oldDestinationPort,
         oldSourceIp, oldSourcePort, protocol, routerUri, type;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_NetworkInfo
//

@implementation GTLRNetworkManagement_NetworkInfo
@dynamic displayName, matchedIpRange, matchedSubnetUri, region, uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Operation
//

@implementation GTLRNetworkManagement_Operation
@dynamic done, error, metadata, name, response;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Operation_Metadata
//

@implementation GTLRNetworkManagement_Operation_Metadata

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Operation_Response
//

@implementation GTLRNetworkManagement_Operation_Response

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_OperationMetadata
//

@implementation GTLRNetworkManagement_OperationMetadata
@dynamic apiVersion, cancelRequested, createTime, endTime, statusDetail, target,
         verb;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Policy
//

@implementation GTLRNetworkManagement_Policy
@dynamic auditConfigs, bindings, ETag, version;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"ETag" : @"etag" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"auditConfigs" : [GTLRNetworkManagement_AuditConfig class],
    @"bindings" : [GTLRNetworkManagement_Binding class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ProbingDetails
//

@implementation GTLRNetworkManagement_ProbingDetails
@dynamic abortCause, destinationEgressLocation, endpointInfo, error,
         probingLatency, result, sentProbeCount, successfulProbeCount,
         verifyTime;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ProxyConnectionInfo
//

@implementation GTLRNetworkManagement_ProxyConnectionInfo
@dynamic networkUri, newDestinationIp, newDestinationPort, newSourceIp,
         newSourcePort, oldDestinationIp, oldDestinationPort, oldSourceIp,
         oldSourcePort, protocol, subnetUri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ReachabilityDetails
//

@implementation GTLRNetworkManagement_ReachabilityDetails
@dynamic error, result, traces, verifyTime;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"traces" : [GTLRNetworkManagement_Trace class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_RedisClusterInfo
//

@implementation GTLRNetworkManagement_RedisClusterInfo
@dynamic discoveryEndpointIpAddress, displayName, location, networkUri,
         secondaryEndpointIpAddress, uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_RedisInstanceInfo
//

@implementation GTLRNetworkManagement_RedisInstanceInfo
@dynamic displayName, networkUri, primaryEndpointIp, readEndpointIp, region,
         uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_RerunConnectivityTestRequest
//

@implementation GTLRNetworkManagement_RerunConnectivityTestRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_RouteInfo
//

@implementation GTLRNetworkManagement_RouteInfo
@dynamic advertisedRouteNextHopUri, advertisedRouteSourceRouterUri, destIpRange,
         destPortRanges, displayName, instanceTags, nccHubUri, nccSpokeUri,
         networkUri, nextHop, nextHopType, priority, protocols, region,
         routeScope, routeType, srcIpRange, srcPortRanges, uri;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"destPortRanges" : [NSString class],
    @"instanceTags" : [NSString class],
    @"protocols" : [NSString class],
    @"srcPortRanges" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_ServerlessNegInfo
//

@implementation GTLRNetworkManagement_ServerlessNegInfo
@dynamic negUri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_SetIamPolicyRequest
//

@implementation GTLRNetworkManagement_SetIamPolicyRequest
@dynamic policy, updateMask;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Status
//

@implementation GTLRNetworkManagement_Status
@dynamic code, details, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"details" : [GTLRNetworkManagement_Status_Details_Item class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Status_Details_Item
//

@implementation GTLRNetworkManagement_Status_Details_Item

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Step
//

@implementation GTLRNetworkManagement_Step
@dynamic abort, appEngineVersion, causesDrop, cloudFunction, cloudRunRevision,
         cloudSqlInstance, deliver, descriptionProperty, drop, endpoint,
         firewall, forward, forwardingRule, gkeMaster, googleService, instance,
         loadBalancer, loadBalancerBackendInfo, nat, network, projectId,
         proxyConnection, redisCluster, redisInstance, route, serverlessNeg,
         state, storageBucket, vpcConnector, vpnGateway, vpnTunnel;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_StorageBucketInfo
//

@implementation GTLRNetworkManagement_StorageBucketInfo
@dynamic bucket;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_TestIamPermissionsRequest
//

@implementation GTLRNetworkManagement_TestIamPermissionsRequest
@dynamic permissions;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"permissions" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_TestIamPermissionsResponse
//

@implementation GTLRNetworkManagement_TestIamPermissionsResponse
@dynamic permissions;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"permissions" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_Trace
//

@implementation GTLRNetworkManagement_Trace
@dynamic endpointInfo, forwardTraceId, steps;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"steps" : [GTLRNetworkManagement_Step class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_VpcConnectorInfo
//

@implementation GTLRNetworkManagement_VpcConnectorInfo
@dynamic displayName, location, uri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_VpnGatewayInfo
//

@implementation GTLRNetworkManagement_VpnGatewayInfo
@dynamic displayName, ipAddress, networkUri, region, uri, vpnTunnelUri;
@end


// ----------------------------------------------------------------------------
//
//   GTLRNetworkManagement_VpnTunnelInfo
//

@implementation GTLRNetworkManagement_VpnTunnelInfo
@dynamic displayName, networkUri, region, remoteGateway, remoteGatewayIp,
         routingType, sourceGateway, sourceGatewayIp, uri;
@end
