// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Solar API (solar/v1)
// Description:
//   Solar API.
// Documentation:
//   https://developers.google.com/maps/documentation/solar

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRSolar_CashPurchaseSavings;
@class GTLRSolar_Date;
@class GTLRSolar_FinancedPurchaseSavings;
@class GTLRSolar_FinancialAnalysis;
@class GTLRSolar_FinancialDetails;
@class GTLRSolar_HttpBody_Extensions_Item;
@class GTLRSolar_LatLng;
@class GTLRSolar_LatLngBox;
@class GTLRSolar_LeasingSavings;
@class GTLRSolar_Money;
@class GTLRSolar_Panel;
@class GTLRSolar_PanelConfig;
@class GTLRSolar_Potential;
@class GTLRSolar_RoofSegmentSizeAndSunshineStats;
@class GTLRSolar_RoofSegmentSummary;
@class GTLRSolar_SavingsOverTime;
@class GTLRSolar_SizeAndSunshineStats;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRSolar_BuildingInsights.imageryQuality

/**
 *  Solar data is derived from enhanced satellite imagery processed at 0.25
 *  m/pixel.
 *
 *  Value: "BASE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_BuildingInsights_ImageryQuality_Base;
/**
 *  Solar data is derived from aerial imagery captured at low-altitude and
 *  processed at 0.1 m/pixel.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_BuildingInsights_ImageryQuality_High;
/**
 *  No quality is known.
 *
 *  Value: "IMAGERY_QUALITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_BuildingInsights_ImageryQuality_ImageryQualityUnspecified;
/**
 *  Solar data is derived from enhanced satellite imagery processed at 0.25
 *  m/pixel.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_BuildingInsights_ImageryQuality_Low;
/**
 *  Solar data is derived from enhanced aerial imagery captured at high-altitude
 *  and processed at 0.25 m/pixel.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_BuildingInsights_ImageryQuality_Medium;

// ----------------------------------------------------------------------------
// GTLRSolar_DataLayers.imageryQuality

/**
 *  Solar data is derived from enhanced satellite imagery processed at 0.25
 *  m/pixel.
 *
 *  Value: "BASE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_DataLayers_ImageryQuality_Base;
/**
 *  Solar data is derived from aerial imagery captured at low-altitude and
 *  processed at 0.1 m/pixel.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_DataLayers_ImageryQuality_High;
/**
 *  No quality is known.
 *
 *  Value: "IMAGERY_QUALITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_DataLayers_ImageryQuality_ImageryQualityUnspecified;
/**
 *  Solar data is derived from enhanced satellite imagery processed at 0.25
 *  m/pixel.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_DataLayers_ImageryQuality_Low;
/**
 *  Solar data is derived from enhanced aerial imagery captured at high-altitude
 *  and processed at 0.25 m/pixel.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_DataLayers_ImageryQuality_Medium;

// ----------------------------------------------------------------------------
// GTLRSolar_Panel.orientation

/**
 *  A `LANDSCAPE` panel has its long edge perpendicular to the azimuth direction
 *  of the roof segment that it is placed on.
 *
 *  Value: "LANDSCAPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_Panel_Orientation_Landscape;
/**
 *  A `PORTRAIT` panel has its long edge parallel to the azimuth direction of
 *  the roof segment that it is placed on.
 *
 *  Value: "PORTRAIT"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_Panel_Orientation_Portrait;
/**
 *  No panel orientation is known.
 *
 *  Value: "SOLAR_PANEL_ORIENTATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSolar_Panel_Orientation_SolarPanelOrientationUnspecified;

/**
 *  Response message for `Solar.FindClosestBuildingInsights`. Information about
 *  the location, dimensions, and solar potential of a building.
 */
@interface GTLRSolar_BuildingInsights : GTLRObject

/**
 *  Administrative area 1 (e.g., in the US, the state) that contains this
 *  building. For example, in the US, the abbreviation might be "MA" or "CA."
 */
@property(nonatomic, copy, nullable) NSString *administrativeArea;

/** The bounding box of the building. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLngBox *boundingBox;

/** A point near the center of the building. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLng *center;

/** Date that the underlying imagery was acquired. This is approximate. */
@property(nonatomic, strong, nullable) GTLRSolar_Date *imageryDate;

/** When processing was completed on this imagery. */
@property(nonatomic, strong, nullable) GTLRSolar_Date *imageryProcessedDate;

/**
 *  The quality of the imagery used to compute the data for this building.
 *
 *  Likely values:
 *    @arg @c kGTLRSolar_BuildingInsights_ImageryQuality_Base Solar data is
 *        derived from enhanced satellite imagery processed at 0.25 m/pixel.
 *        (Value: "BASE")
 *    @arg @c kGTLRSolar_BuildingInsights_ImageryQuality_High Solar data is
 *        derived from aerial imagery captured at low-altitude and processed at
 *        0.1 m/pixel. (Value: "HIGH")
 *    @arg @c kGTLRSolar_BuildingInsights_ImageryQuality_ImageryQualityUnspecified
 *        No quality is known. (Value: "IMAGERY_QUALITY_UNSPECIFIED")
 *    @arg @c kGTLRSolar_BuildingInsights_ImageryQuality_Low Solar data is
 *        derived from enhanced satellite imagery processed at 0.25 m/pixel.
 *        (Value: "LOW")
 *    @arg @c kGTLRSolar_BuildingInsights_ImageryQuality_Medium Solar data is
 *        derived from enhanced aerial imagery captured at high-altitude and
 *        processed at 0.25 m/pixel. (Value: "MEDIUM")
 */
@property(nonatomic, copy, nullable) NSString *imageryQuality;

/**
 *  The resource name for the building, of the format `buildings/{place_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Postal code (e.g., US zip code) this building is contained by. */
@property(nonatomic, copy, nullable) NSString *postalCode;

/** Region code for the country (or region) this building is in. */
@property(nonatomic, copy, nullable) NSString *regionCode;

/** Solar potential of the building. */
@property(nonatomic, strong, nullable) GTLRSolar_Potential *solarPotential;

/** Statistical area (e.g., US census tract) this building is in. */
@property(nonatomic, copy, nullable) NSString *statisticalArea;

@end


/**
 *  Cost and benefit of an outright purchase of a particular configuration of
 *  solar panels with a particular electricity usage.
 */
@interface GTLRSolar_CashPurchaseSavings : GTLRObject

/**
 *  Initial cost before tax incentives: the amount that must be paid
 *  out-of-pocket. Contrast with `upfront_cost`, which is after tax incentives.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *outOfPocketCost;

/**
 *  Number of years until payback occurs. A negative value means payback never
 *  occurs within the lifetime period.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *paybackYears;

/** The value of all tax rebates. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *rebateValue;

/** How much is saved (or not) over the lifetime period. */
@property(nonatomic, strong, nullable) GTLRSolar_SavingsOverTime *savings;

/**
 *  Initial cost after tax incentives: it's the amount that must be paid during
 *  first year. Contrast with `out_of_pocket_cost`, which is before tax
 *  incentives.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *upfrontCost;

@end


/**
 *  Information about the solar potential of a region. The actual data are
 *  contained in a number of GeoTIFF files covering the requested region, for
 *  which this message contains URLs: Each string in the `DataLayers` message
 *  contains a URL from which the corresponding GeoTIFF can be fetched. These
 *  URLs are valid for a few hours after they've been generated. Most of the
 *  GeoTIFF files are at a resolution of 0.1m/pixel, but the monthly flux file
 *  is at 0.5m/pixel, and the hourly shade files are at 1m/pixel. If a
 *  `pixel_size_meters` value was specified in the `GetDataLayersRequest`, then
 *  the minimum resolution in the GeoTIFF files will be that value.
 */
@interface GTLRSolar_DataLayers : GTLRObject

/**
 *  The URL for the annual flux map (annual sunlight on roofs) of the region.
 *  Values are kWh/kW/year. This is *unmasked flux*: flux is computed for every
 *  location, not just building rooftops. Invalid locations are stored as -9999:
 *  locations outside our coverage area will be invalid, and a few locations
 *  inside the coverage area, where we were unable to calculate flux, will also
 *  be invalid.
 */
@property(nonatomic, copy, nullable) NSString *annualFluxUrl;

/**
 *  The URL for an image of the DSM (Digital Surface Model) of the region.
 *  Values are in meters above EGM96 geoid (i.e., sea level). Invalid locations
 *  (where we don't have data) are stored as -9999.
 */
@property(nonatomic, copy, nullable) NSString *dsmUrl;

/**
 *  Twelve URLs for hourly shade, corresponding to January...December, in order.
 *  Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of the
 *  day. Each pixel is a 32 bit integer, corresponding to the (up to) 31 days of
 *  that month; a 1 bit means that the corresponding location is able to see the
 *  sun at that day, of that hour, of that month. Invalid locations are stored
 *  as -9999 (since this is negative, it has bit 31 set, and no valid value
 *  could have bit 31 set as that would correspond to the 32nd day of the
 *  month). An example may be useful. If you want to know whether a point (at
 *  pixel location (x, y)) saw sun at 4pm on the 22nd of June you would: 1.
 *  fetch the sixth URL in this list (corresponding to June). 1. look up the
 *  17th channel (corresponding to 4pm). 1. read the 32-bit value at (x, y). 1.
 *  read bit 21 of the value (corresponding to the 22nd of the month). 1. if
 *  that bit is a 1, then that spot saw the sun at 4pm 22 June. More formally:
 *  Given `month` (1-12), `day` (1...month max; February has 28 days) and `hour`
 *  (0-23), the shade/sun for that month/day/hour at a position `(x, y)` is the
 *  bit ``` (hourly_shade[month - 1])(x, y)[hour] & (1 << (day - 1)) ``` where
 *  `(x, y)` is spatial indexing, `[month - 1]` refers to fetching the `month -
 *  1`st URL (indexing from zero), `[hour]` is indexing into the channels, and a
 *  final non-zero result means "sunny". There are no leap days, and DST doesn't
 *  exist (all days are 24 hours long; noon is always "standard time" noon).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *hourlyShadeUrls;

/**
 *  When the source imagery (from which all the other data are derived) in this
 *  region was taken. It is necessarily somewhat approximate, as the images may
 *  have been taken over more than one day.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Date *imageryDate;

/** When processing was completed on this imagery. */
@property(nonatomic, strong, nullable) GTLRSolar_Date *imageryProcessedDate;

/**
 *  The quality of the result's imagery.
 *
 *  Likely values:
 *    @arg @c kGTLRSolar_DataLayers_ImageryQuality_Base Solar data is derived
 *        from enhanced satellite imagery processed at 0.25 m/pixel. (Value:
 *        "BASE")
 *    @arg @c kGTLRSolar_DataLayers_ImageryQuality_High Solar data is derived
 *        from aerial imagery captured at low-altitude and processed at 0.1
 *        m/pixel. (Value: "HIGH")
 *    @arg @c kGTLRSolar_DataLayers_ImageryQuality_ImageryQualityUnspecified No
 *        quality is known. (Value: "IMAGERY_QUALITY_UNSPECIFIED")
 *    @arg @c kGTLRSolar_DataLayers_ImageryQuality_Low Solar data is derived
 *        from enhanced satellite imagery processed at 0.25 m/pixel. (Value:
 *        "LOW")
 *    @arg @c kGTLRSolar_DataLayers_ImageryQuality_Medium Solar data is derived
 *        from enhanced aerial imagery captured at high-altitude and processed
 *        at 0.25 m/pixel. (Value: "MEDIUM")
 */
@property(nonatomic, copy, nullable) NSString *imageryQuality;

/**
 *  The URL for the building mask image: one bit per pixel saying whether that
 *  pixel is considered to be part of a rooftop or not.
 */
@property(nonatomic, copy, nullable) NSString *maskUrl;

/**
 *  The URL for the monthly flux map (sunlight on roofs, broken down by month)
 *  of the region. Values are kWh/kW/year. The GeoTIFF pointed to by this URL
 *  will contain twelve bands, corresponding to January...December, in order.
 */
@property(nonatomic, copy, nullable) NSString *monthlyFluxUrl;

/** The URL for an image of RGB data (aerial photo) of the region. */
@property(nonatomic, copy, nullable) NSString *rgbUrl;

@end


/**
 *  Represents a whole or partial calendar date, such as a birthday. The time of
 *  day and time zone are either specified elsewhere or are insignificant. The
 *  date is relative to the Gregorian Calendar. This can represent one of the
 *  following: * A full date, with non-zero year, month, and day values. * A
 *  month and day, with a zero year (for example, an anniversary). * A year on
 *  its own, with a zero month and a zero day. * A year and month, with a zero
 *  day (for example, a credit card expiration date). Related types: *
 *  google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
 */
@interface GTLRSolar_Date : GTLRObject

/**
 *  Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
 *  to specify a year by itself or a year and month where the day isn't
 *  significant.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *day;

/**
 *  Month of a year. Must be from 1 to 12, or 0 to specify a year without a
 *  month and day.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *month;

/**
 *  Year of the date. Must be from 1 to 9999, or 0 to specify a date without a
 *  year.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *year;

@end


/**
 *  Cost and benefit of using a loan to buy a particular configuration of solar
 *  panels with a particular electricity usage.
 */
@interface GTLRSolar_FinancedPurchaseSavings : GTLRObject

/** Annual loan payments. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *annualLoanPayment;

/**
 *  The interest rate on loans assumed in this set of calculations.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *loanInterestRate;

/**
 *  The value of all tax rebates (including Federal Investment Tax Credit
 *  (ITC)).
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *rebateValue;

/** How much is saved (or not) over the lifetime period. */
@property(nonatomic, strong, nullable) GTLRSolar_SavingsOverTime *savings;

@end


/**
 *  Analysis of the cost and benefits of the optimum solar layout for a
 *  particular electric bill size.
 */
@interface GTLRSolar_FinancialAnalysis : GTLRObject

/**
 *  How much electricity the house uses in an average month, based on the bill
 *  size and the local electricity rates.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *averageKwhPerMonth;

/** Cost and benefit of buying the solar panels with cash. */
@property(nonatomic, strong, nullable) GTLRSolar_CashPurchaseSavings *cashPurchaseSavings;

/**
 *  Whether this is the bill size selected to be the default bill for the area
 *  this building is in. Exactly one `FinancialAnalysis` in
 *  `BuildingSolarPotential` should have `default_bill` set.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultBill;

/** Cost and benefit of buying the solar panels by financing the purchase. */
@property(nonatomic, strong, nullable) GTLRSolar_FinancedPurchaseSavings *financedPurchaseSavings;

/**
 *  Financial information that applies regardless of the financing method used.
 */
@property(nonatomic, strong, nullable) GTLRSolar_FinancialDetails *financialDetails;

/** Cost and benefit of leasing the solar panels. */
@property(nonatomic, strong, nullable) GTLRSolar_LeasingSavings *leasingSavings;

/** The monthly electric bill this analysis assumes. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *monthlyBill;

/**
 *  Index in solar_panel_configs of the optimum solar layout for this bill size.
 *  This can be -1 indicating that there is no layout. In this case, the
 *  remaining submessages will be omitted.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelConfigIndex;

@end


/**
 *  Details of a financial analysis. Some of these details are already stored at
 *  higher levels (e.g., out of pocket cost). Total money amounts are over a
 *  lifetime period defined by the panel_lifetime_years field in SolarPotential.
 *  Note: The out of pocket cost of purchasing the panels is given in the
 *  out_of_pocket_cost field in CashPurchaseSavings.
 */
@interface GTLRSolar_FinancialDetails : GTLRObject

/**
 *  Total cost of electricity the user would have paid over the lifetime period
 *  if they didn't install solar.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *costOfElectricityWithoutSolar;

/**
 *  Amount of money available from federal incentives; this applies if the user
 *  buys (with or without a loan) the panels.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *federalIncentive;

/**
 *  How many AC kWh we think the solar panels will generate in their first year.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialAcKwhPerYear;

/**
 *  Amount of money the user will receive from Solar Renewable Energy Credits
 *  over the panel lifetime; this applies if the user buys (with or without a
 *  loan) the panels.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *lifetimeSrecTotal;

/**
 *  Whether net metering is allowed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *netMeteringAllowed;

/**
 *  The percentage (0-100) of solar electricity production we assumed was
 *  exported to the grid, based on the first quarter of production. This affects
 *  the calculations if net metering is not allowed.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percentageExportedToGrid;

/**
 *  Utility bill for electricity not produced by solar, for the lifetime of the
 *  panels.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *remainingLifetimeUtilityBill;

/**
 *  Percentage (0-100) of the user's power supplied by solar. Valid for the
 *  first year but approximately correct for future years.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *solarPercentage;

/**
 *  Amount of money available from state incentives; this applies if the user
 *  buys (with or without a loan) the panels.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *stateIncentive;

/**
 *  Amount of money available from utility incentives; this applies if the user
 *  buys (with or without a loan) the panels.
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *utilityIncentive;

@end


/**
 *  Message that represents an arbitrary HTTP body. It should only be used for
 *  payload formats that can't be represented as JSON, such as raw binary or an
 *  HTML page. This message can be used both in streaming and non-streaming API
 *  methods in the request as well as the response. It can be used as a
 *  top-level request field, which is convenient if one wants to extract
 *  parameters from either the URL or HTTP template into the request fields and
 *  also want access to the raw HTTP body. Example: message GetResourceRequest {
 *  // A unique request id. string request_id = 1; // The raw HTTP body is bound
 *  to this field. google.api.HttpBody http_body = 2; } service ResourceService
 *  { rpc GetResource(GetResourceRequest) returns (google.api.HttpBody); rpc
 *  UpdateResource(google.api.HttpBody) returns (google.protobuf.Empty); }
 *  Example with streaming methods: service CaldavService { rpc
 *  GetCalendar(stream google.api.HttpBody) returns (stream
 *  google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
 *  (stream google.api.HttpBody); } Use of this type only changes how the
 *  request and response bodies are handled, all other features will continue to
 *  work unchanged.
 */
@interface GTLRSolar_HttpBody : GTLRObject

/**
 *  The HTTP Content-Type header value specifying the content type of the body.
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The HTTP request/response body as raw binary.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  Application specific response metadata. Must be set in the first response
 *  for streaming APIs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSolar_HttpBody_Extensions_Item *> *extensions;

@end


/**
 *  GTLRSolar_HttpBody_Extensions_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSolar_HttpBody_Extensions_Item : GTLRObject
@end


/**
 *  An object that represents a latitude/longitude pair. This is expressed as a
 *  pair of doubles to represent degrees latitude and degrees longitude. Unless
 *  specified otherwise, this object must conform to the WGS84 standard. Values
 *  must be within normalized ranges.
 */
@interface GTLRSolar_LatLng : GTLRObject

/**
 *  The latitude in degrees. It must be in the range [-90.0, +90.0].
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *latitude;

/**
 *  The longitude in degrees. It must be in the range [-180.0, +180.0].
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *longitude;

@end


/**
 *  A bounding box in lat/lng coordinates.
 */
@interface GTLRSolar_LatLngBox : GTLRObject

/** The northeast corner of the box. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLng *ne;

/** The southwest corner of the box. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLng *sw;

@end


/**
 *  Cost and benefit of leasing a particular configuration of solar panels with
 *  a particular electricity usage.
 */
@interface GTLRSolar_LeasingSavings : GTLRObject

/** Estimated annual leasing cost. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *annualLeasingCost;

/**
 *  Whether leases are allowed in this juristiction (leases are not allowed in
 *  some states). If this field is false, then the values in this message should
 *  probably be ignored.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *leasesAllowed;

/**
 *  Whether leases are supported in this juristiction by the financial
 *  calculation engine. If this field is false, then the values in this message
 *  should probably be ignored. This is independent of `leases_allowed`: in some
 *  areas leases are allowed, but under conditions that aren't handled by the
 *  financial models.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *leasesSupported;

/** How much is saved (or not) over the lifetime period. */
@property(nonatomic, strong, nullable) GTLRSolar_SavingsOverTime *savings;

@end


/**
 *  Represents an amount of money with its currency type.
 */
@interface GTLRSolar_Money : GTLRObject

/** The three-letter currency code defined in ISO 4217. */
@property(nonatomic, copy, nullable) NSString *currencyCode;

/**
 *  Number of nano (10^-9) units of the amount. The value must be between
 *  -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos`
 *  must be positive or zero. If `units` is zero, `nanos` can be positive, zero,
 *  or negative. If `units` is negative, `nanos` must be negative or zero. For
 *  example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nanos;

/**
 *  The whole units of the amount. For example if `currencyCode` is `"USD"`,
 *  then 1 unit is one US dollar.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *units;

@end


/**
 *  SolarPanel describes the position, orientation, and production of a single
 *  solar panel. See the panel_height_meters, panel_width_meters, and
 *  panel_capacity_watts fields in SolarPotential for information on the
 *  parameters of the panel.
 */
@interface GTLRSolar_Panel : GTLRObject

/** The centre of the panel. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLng *center;

/**
 *  The orientation of the panel.
 *
 *  Likely values:
 *    @arg @c kGTLRSolar_Panel_Orientation_Landscape A `LANDSCAPE` panel has its
 *        long edge perpendicular to the azimuth direction of the roof segment
 *        that it is placed on. (Value: "LANDSCAPE")
 *    @arg @c kGTLRSolar_Panel_Orientation_Portrait A `PORTRAIT` panel has its
 *        long edge parallel to the azimuth direction of the roof segment that
 *        it is placed on. (Value: "PORTRAIT")
 *    @arg @c kGTLRSolar_Panel_Orientation_SolarPanelOrientationUnspecified No
 *        panel orientation is known. (Value:
 *        "SOLAR_PANEL_ORIENTATION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *orientation;

/**
 *  Index in roof_segment_stats of the `RoofSegmentSizeAndSunshineStats` which
 *  corresponds to the roof segment that this panel is placed on.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *segmentIndex;

/**
 *  How much sunlight energy this layout captures over the course of a year, in
 *  DC kWh.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *yearlyEnergyDcKwh;

@end


/**
 *  SolarPanelConfig describes a particular placement of solar panels on the
 *  roof.
 */
@interface GTLRSolar_PanelConfig : GTLRObject

/**
 *  Total number of panels. Note that this is redundant to (the sum of) the
 *  corresponding fields in roof_segment_summaries.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelsCount;

/**
 *  Information about the production of each roof segment that is carrying at
 *  least one panel in this layout. `roof_segment_summaries[i]` describes the
 *  i-th roof segment, including its size, expected production and orientation.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSolar_RoofSegmentSummary *> *roofSegmentSummaries;

/**
 *  How much sunlight energy this layout captures over the course of a year, in
 *  DC kWh, assuming the panels described above.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *yearlyEnergyDcKwh;

@end


/**
 *  Information about the solar potential of a building. A number of fields in
 *  this are defined in terms of "panels". The fields panel_capacity_watts,
 *  panel_height_meters, and panel_width_meters describe the parameters of the
 *  model of panel used in these calculations.
 */
@interface GTLRSolar_Potential : GTLRObject

/**
 *  Size and sunlight quantiles for the entire building, including parts of the
 *  roof that were not assigned to some roof segment. Because the orientations
 *  of these parts are not well characterised, the roof area estimate is
 *  unreliable, but the ground area estimate is reliable. It may be that a more
 *  reliable whole building roof area can be obtained by scaling the roof area
 *  from whole_roof_stats by the ratio of the ground areas of `building_stats`
 *  and `whole_roof_stats`.
 */
@property(nonatomic, strong, nullable) GTLRSolar_SizeAndSunshineStats *buildingStats;

/**
 *  Equivalent amount of CO2 produced per MWh of grid electricity. This is a
 *  measure of the carbon intensity of grid electricity displaced by solar
 *  electricity.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *carbonOffsetFactorKgPerMwh;

/**
 *  A FinancialAnalysis gives the savings from going solar assuming a given
 *  monthly bill and a given electricity provider. They are in order of
 *  increasing order of monthly bill amount. This field will be empty for
 *  buildings in areas for which the Solar API does not have enough information
 *  to perform financial computations.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSolar_FinancialAnalysis *> *financialAnalyses;

/**
 *  Size, in square meters, of the maximum array.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxArrayAreaMeters2;

/**
 *  Size of the maximum array - that is, the maximum number of panels that can
 *  fit on the roof.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxArrayPanelsCount;

/**
 *  Maximum number of sunshine hours received per year, by any point on the
 *  roof. Sunshine hours are a measure of the total amount of insolation
 *  (energy) received per year. 1 sunshine hour = 1 kWh per kW (where kW refers
 *  to kW of capacity under Standard Testing Conditions).
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxSunshineHoursPerYear;

/**
 *  Capacity, in watts, of the panel used in the calculations.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelCapacityWatts;

/**
 *  Height, in meters in portrait orientation, of the panel used in the
 *  calculations.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelHeightMeters;

/**
 *  The expected lifetime, in years, of the solar panels. This is used in the
 *  financial calculations.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelLifetimeYears;

/**
 *  Width, in meters in portrait orientation, of the panel used in the
 *  calculations.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelWidthMeters;

/** Size and sunlight quantiles for each roof segment. */
@property(nonatomic, strong, nullable) NSArray<GTLRSolar_RoofSegmentSizeAndSunshineStats *> *roofSegmentStats;

/**
 *  Each SolarPanelConfig describes a different arrangement of solar panels on
 *  the roof. They are in order of increasing number of panels. The
 *  `SolarPanelConfig` with panels_count=N is based on the first N panels in the
 *  `solar_panels` list. This field is only populated if at least 4 panels can
 *  fit on a roof.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSolar_PanelConfig *> *solarPanelConfigs;

/**
 *  Each SolarPanel describes a single solar panel. They are listed in the order
 *  that the panel layout algorithm placed this. This is usually, though not
 *  always, in decreasing order of annual energy production.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSolar_Panel *> *solarPanels;

/**
 *  Total size and sunlight quantiles for the part of the roof that was assigned
 *  to some roof segment. Despite the name, this may not include the entire
 *  building. See building_stats.
 */
@property(nonatomic, strong, nullable) GTLRSolar_SizeAndSunshineStats *wholeRoofStats;

@end


/**
 *  Information about the size and sunniness quantiles of a roof segment.
 */
@interface GTLRSolar_RoofSegmentSizeAndSunshineStats : GTLRObject

/**
 *  Compass direction the roof segment is pointing in. 0 = North, 90 = East, 180
 *  = South. For a "flat" roof segment (`pitch_degrees` very near 0), azimuth is
 *  not well defined, so for consistency, we define it arbitrarily to be 0
 *  (North).
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *azimuthDegrees;

/** The bounding box of the roof segment. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLngBox *boundingBox;

/** A point near the center of the roof segment. */
@property(nonatomic, strong, nullable) GTLRSolar_LatLng *center;

/**
 *  Angle of the roof segment relative to the theoretical ground plane. 0 =
 *  parallel to the ground, 90 = perpendicular to the ground.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pitchDegrees;

/**
 *  The height of the roof segment plane, in meters above sea level, at the
 *  point designated by `center`. Together with the pitch, azimuth, and center
 *  location, this fully defines the roof segment plane.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *planeHeightAtCenterMeters;

/** Total size and sunlight quantiles for the roof segment. */
@property(nonatomic, strong, nullable) GTLRSolar_SizeAndSunshineStats *stats;

@end


/**
 *  Information about a roof segment on the building, with some number of panels
 *  placed on it.
 */
@interface GTLRSolar_RoofSegmentSummary : GTLRObject

/**
 *  Compass direction the roof segment is pointing in. 0 = North, 90 = East, 180
 *  = South. For a "flat" roof segment (`pitch_degrees` very near 0), azimuth is
 *  not well defined, so for consistency, we define it arbitrarily to be 0
 *  (North).
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *azimuthDegrees;

/**
 *  The total number of panels on this segment.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *panelsCount;

/**
 *  Angle of the roof segment relative to the theoretical ground plane. 0 =
 *  parallel to the ground, 90 = perpendicular to the ground.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pitchDegrees;

/**
 *  Index in roof_segment_stats of the corresponding
 *  `RoofSegmentSizeAndSunshineStats`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *segmentIndex;

/**
 *  How much sunlight energy this part of the layout captures over the course of
 *  a year, in DC kWh, assuming the panels described above.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *yearlyEnergyDcKwh;

@end


/**
 *  Financial information that's shared between different financing methods.
 */
@interface GTLRSolar_SavingsOverTime : GTLRObject

/**
 *  Indicates whether this scenario is financially viable. Will be false for
 *  scenarios with poor financial viability (e.g., money-losing).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *financiallyViable;

/**
 *  Using the assumed discount rate, what is the present value of the cumulative
 *  lifetime savings?
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *presentValueOfSavingsLifetime;

/**
 *  Using the assumed discount rate, what is the present value of the cumulative
 *  20-year savings?
 */
@property(nonatomic, strong, nullable) GTLRSolar_Money *presentValueOfSavingsYear20;

/** Savings in the entire panel lifetime. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *savingsLifetime;

/** Savings in the first year after panel installation. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *savingsYear1;

/** Savings in the first twenty years after panel installation. */
@property(nonatomic, strong, nullable) GTLRSolar_Money *savingsYear20;

@end


/**
 *  Size and sunniness quantiles of a roof, or part of a roof.
 */
@interface GTLRSolar_SizeAndSunshineStats : GTLRObject

/**
 *  The area of the roof or roof segment, in m^2. This is the roof area
 *  (accounting for tilt), not the ground footprint area.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *areaMeters2;

/**
 *  The ground footprint area covered by the roof or roof segment, in m^2.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *groundAreaMeters2;

/**
 *  Quantiles of the pointwise sunniness across the area. If there are N values
 *  here, this represents the (N-1)-iles. For example, if there are 5 values,
 *  then they would be the quartiles (min, 25%, 50%, 75%, max). Values are in
 *  annual kWh/kW like max_sunshine_hours_per_year.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *sunshineQuantiles;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
