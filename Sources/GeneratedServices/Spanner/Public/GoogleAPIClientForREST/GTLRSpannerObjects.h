// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Spanner API (spanner/v1)
// Description:
//   Cloud Spanner is a managed, mission-critical, globally consistent and
//   scalable relational database service.
// Documentation:
//   https://cloud.google.com/spanner/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRSpanner_AdaptMessageRequest_Attachments;
@class GTLRSpanner_AdaptMessageResponse_StateUpdates;
@class GTLRSpanner_AsymmetricAutoscalingOption;
@class GTLRSpanner_AutoscalingConfig;
@class GTLRSpanner_AutoscalingConfigOverrides;
@class GTLRSpanner_AutoscalingLimits;
@class GTLRSpanner_AutoscalingTargets;
@class GTLRSpanner_Backup;
@class GTLRSpanner_BackupInfo;
@class GTLRSpanner_BackupInstancePartition;
@class GTLRSpanner_BackupSchedule;
@class GTLRSpanner_BackupScheduleSpec;
@class GTLRSpanner_Binding;
@class GTLRSpanner_ChangeQuorumRequest;
@class GTLRSpanner_ChildLink;
@class GTLRSpanner_ColumnMetadata;
@class GTLRSpanner_CommitStats;
@class GTLRSpanner_ContextValue;
@class GTLRSpanner_CopyBackupEncryptionConfig;
@class GTLRSpanner_CreateBackupEncryptionConfig;
@class GTLRSpanner_CrontabSpec;
@class GTLRSpanner_Database;
@class GTLRSpanner_DatabaseMoveConfig;
@class GTLRSpanner_DatabaseRole;
@class GTLRSpanner_DataChangeRecord;
@class GTLRSpanner_DdlStatementActionInfo;
@class GTLRSpanner_Delete;
@class GTLRSpanner_DerivedMetric;
@class GTLRSpanner_DiagnosticMessage;
@class GTLRSpanner_DirectedReadOptions;
@class GTLRSpanner_DualRegionQuorum;
@class GTLRSpanner_EncryptionConfig;
@class GTLRSpanner_EncryptionInfo;
@class GTLRSpanner_ExcludeReplicas;
@class GTLRSpanner_ExecuteSqlRequest_Params;
@class GTLRSpanner_ExecuteSqlRequest_ParamTypes;
@class GTLRSpanner_Expr;
@class GTLRSpanner_Field;
@class GTLRSpanner_FreeInstanceMetadata;
@class GTLRSpanner_FullBackupSpec;
@class GTLRSpanner_GetPolicyOptions;
@class GTLRSpanner_HeartbeatRecord;
@class GTLRSpanner_IncludeReplicas;
@class GTLRSpanner_IncrementalBackupSpec;
@class GTLRSpanner_IndexAdvice;
@class GTLRSpanner_IndexedHotKey;
@class GTLRSpanner_IndexedHotKey_SparseHotKeys;
@class GTLRSpanner_IndexedKeyRangeInfos;
@class GTLRSpanner_IndexedKeyRangeInfos_KeyRangeInfos;
@class GTLRSpanner_Instance;
@class GTLRSpanner_Instance_Labels;
@class GTLRSpanner_InstanceConfig;
@class GTLRSpanner_InstanceConfig_Labels;
@class GTLRSpanner_InstanceEncryptionConfig;
@class GTLRSpanner_InstanceOperationProgress;
@class GTLRSpanner_InstancePartition;
@class GTLRSpanner_InstanceReplicaSelection;
@class GTLRSpanner_Key;
@class GTLRSpanner_KeyRange;
@class GTLRSpanner_KeyRangeInfo;
@class GTLRSpanner_KeyRangeInfos;
@class GTLRSpanner_KeySet;
@class GTLRSpanner_LocalizedString;
@class GTLRSpanner_LocalizedString_Args;
@class GTLRSpanner_Metric;
@class GTLRSpanner_Metric_IndexedHotKeys;
@class GTLRSpanner_Metric_IndexedKeyRangeInfos;
@class GTLRSpanner_MetricMatrix;
@class GTLRSpanner_MetricMatrixRow;
@class GTLRSpanner_Mod;
@class GTLRSpanner_ModValue;
@class GTLRSpanner_MoveInEvent;
@class GTLRSpanner_MoveOutEvent;
@class GTLRSpanner_MultiplexedSessionPrecommitToken;
@class GTLRSpanner_Mutation;
@class GTLRSpanner_MutationGroup;
@class GTLRSpanner_Operation;
@class GTLRSpanner_Operation_Metadata;
@class GTLRSpanner_Operation_Response;
@class GTLRSpanner_OperationProgress;
@class GTLRSpanner_Partition;
@class GTLRSpanner_PartitionedDml;
@class GTLRSpanner_PartitionEndRecord;
@class GTLRSpanner_PartitionEventRecord;
@class GTLRSpanner_PartitionOptions;
@class GTLRSpanner_PartitionQueryRequest_Params;
@class GTLRSpanner_PartitionQueryRequest_ParamTypes;
@class GTLRSpanner_PartitionStartRecord;
@class GTLRSpanner_PlanNode;
@class GTLRSpanner_PlanNode_ExecutionStats;
@class GTLRSpanner_PlanNode_Metadata;
@class GTLRSpanner_Policy;
@class GTLRSpanner_PrefixNode;
@class GTLRSpanner_QueryAdvisorResult;
@class GTLRSpanner_QueryOptions;
@class GTLRSpanner_QueryPlan;
@class GTLRSpanner_QuorumInfo;
@class GTLRSpanner_QuorumType;
@class GTLRSpanner_ReadOnly;
@class GTLRSpanner_ReadWrite;
@class GTLRSpanner_ReplicaComputeCapacity;
@class GTLRSpanner_ReplicaInfo;
@class GTLRSpanner_ReplicaSelection;
@class GTLRSpanner_RequestOptions;
@class GTLRSpanner_RestoreDatabaseEncryptionConfig;
@class GTLRSpanner_RestoreInfo;
@class GTLRSpanner_ResultSet;
@class GTLRSpanner_ResultSetMetadata;
@class GTLRSpanner_ResultSetStats;
@class GTLRSpanner_ResultSetStats_QueryStats;
@class GTLRSpanner_Scan;
@class GTLRSpanner_Scan_Details;
@class GTLRSpanner_ScanData;
@class GTLRSpanner_Session;
@class GTLRSpanner_Session_Labels;
@class GTLRSpanner_ShortRepresentation;
@class GTLRSpanner_ShortRepresentation_Subqueries;
@class GTLRSpanner_SingleRegionQuorum;
@class GTLRSpanner_SplitPoints;
@class GTLRSpanner_Statement;
@class GTLRSpanner_Statement_Params;
@class GTLRSpanner_Statement_ParamTypes;
@class GTLRSpanner_Status;
@class GTLRSpanner_Status_Details_Item;
@class GTLRSpanner_StructType;
@class GTLRSpanner_Transaction;
@class GTLRSpanner_TransactionOptions;
@class GTLRSpanner_TransactionSelector;
@class GTLRSpanner_Type;
@class GTLRSpanner_UpdateDatabaseRequest;
@class GTLRSpanner_VisualizationData;
@class GTLRSpanner_Write;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRSpanner_Backup.databaseDialect

/**
 *  Default value. This value will create a database with the
 *  GOOGLE_STANDARD_SQL dialect.
 *
 *  Value: "DATABASE_DIALECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_DatabaseDialect_DatabaseDialectUnspecified;
/**
 *  GoogleSQL supported SQL.
 *
 *  Value: "GOOGLE_STANDARD_SQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_DatabaseDialect_GoogleStandardSql;
/**
 *  PostgreSQL supported SQL.
 *
 *  Value: "POSTGRESQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_DatabaseDialect_Postgresql;

// ----------------------------------------------------------------------------
// GTLRSpanner_Backup.state

/**
 *  The pending backup is still being created. Operations on the backup may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_Creating;
/**
 *  The backup is complete and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ContextValue.severity

/**
 *  Severity level signaling an error "Error"
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Error;
/**
 *  Severity level signaling a non recoverable error "Fatal"
 *
 *  Value: "FATAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Fatal;
/**
 *  Lowest severity level "Info".
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Info;
/**
 *  Required default value.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_SeverityUnspecified;
/**
 *  Middle severity level "Warning".
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRSpanner_CopyBackupEncryptionConfig.encryptionType

/**
 *  Use customer managed encryption. If specified, either `kms_key_name` or
 *  `kms_key_names` must contain valid Cloud KMS keys.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_CustomerManagedEncryption;
/**
 *  Unspecified. Do not use.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Use Google default encryption.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_GoogleDefaultEncryption;
/**
 *  This is the default option for CopyBackup when encryption_config is not
 *  specified. For example, if the source backup is using
 *  `Customer_Managed_Encryption`, the backup will be using the same Cloud KMS
 *  key as the source backup.
 *
 *  Value: "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption;

// ----------------------------------------------------------------------------
// GTLRSpanner_CreateBackupEncryptionConfig.encryptionType

/**
 *  Use customer managed encryption. If specified, `kms_key_name` must contain a
 *  valid Cloud KMS key.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_CustomerManagedEncryption;
/**
 *  Unspecified. Do not use.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Use Google default encryption.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_GoogleDefaultEncryption;
/**
 *  Use the same encryption configuration as the database. This is the default
 *  option when encryption_config is empty. For example, if the database is
 *  using `Customer_Managed_Encryption`, the backup will be using the same Cloud
 *  KMS key as the database.
 *
 *  Value: "USE_DATABASE_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_UseDatabaseEncryption;

// ----------------------------------------------------------------------------
// GTLRSpanner_CreateDatabaseRequest.databaseDialect

/**
 *  Default value. This value will create a database with the
 *  GOOGLE_STANDARD_SQL dialect.
 *
 *  Value: "DATABASE_DIALECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_DatabaseDialectUnspecified;
/**
 *  GoogleSQL supported SQL.
 *
 *  Value: "GOOGLE_STANDARD_SQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_GoogleStandardSql;
/**
 *  PostgreSQL supported SQL.
 *
 *  Value: "POSTGRESQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_Postgresql;

// ----------------------------------------------------------------------------
// GTLRSpanner_CreateInstanceMetadata.expectedFulfillmentPeriod

/**
 *  Extended fulfillment period. It can take up to an hour for the operation to
 *  complete.
 *
 *  Value: "FULFILLMENT_PERIOD_EXTENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodExtended;
/**
 *  Normal fulfillment period. The operation is expected to complete within
 *  minutes.
 *
 *  Value: "FULFILLMENT_PERIOD_NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodNormal;
/**
 *  Not specified.
 *
 *  Value: "FULFILLMENT_PERIOD_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Database.databaseDialect

/**
 *  Default value. This value will create a database with the
 *  GOOGLE_STANDARD_SQL dialect.
 *
 *  Value: "DATABASE_DIALECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_DatabaseDialect_DatabaseDialectUnspecified;
/**
 *  GoogleSQL supported SQL.
 *
 *  Value: "GOOGLE_STANDARD_SQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_DatabaseDialect_GoogleStandardSql;
/**
 *  PostgreSQL supported SQL.
 *
 *  Value: "POSTGRESQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_DatabaseDialect_Postgresql;

// ----------------------------------------------------------------------------
// GTLRSpanner_Database.state

/**
 *  The database is still being created. Operations on the database may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_Creating;
/**
 *  The database is fully created and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_Ready;
/**
 *  The database is fully created and ready for use, but is still being
 *  optimized for performance and cannot handle full load. In this state, the
 *  database still references the backup it was restore from, preventing the
 *  backup from being deleted. When optimizations are complete, the full
 *  performance of the database will be restored, and the database will
 *  transition to `READY` state.
 *
 *  Value: "READY_OPTIMIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_ReadyOptimizing;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_DataChangeRecord.modType

/**
 *  Indicates existing data was deleted.
 *
 *  Value: "DELETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ModType_Delete;
/**
 *  Indicates data was inserted.
 *
 *  Value: "INSERT"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ModType_Insert;
/**
 *  Not specified.
 *
 *  Value: "MOD_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ModType_ModTypeUnspecified;
/**
 *  Indicates existing data was updated.
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ModType_Update;

// ----------------------------------------------------------------------------
// GTLRSpanner_DataChangeRecord.valueCaptureType

/**
 *  Records new values of all watched columns, including modified and unmodified
 *  columns.
 *
 *  Value: "NEW_ROW"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ValueCaptureType_NewRow;
/**
 *  Records the new values of all watched columns, including modified and
 *  unmodified columns. Also records the old values of the modified columns.
 *
 *  Value: "NEW_ROW_AND_OLD_VALUES"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ValueCaptureType_NewRowAndOldValues;
/**
 *  Records only new values of the modified watched columns.
 *
 *  Value: "NEW_VALUES"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ValueCaptureType_NewValues;
/**
 *  Records both old and new values of the modified watched columns.
 *
 *  Value: "OLD_AND_NEW_VALUES"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ValueCaptureType_OldAndNewValues;
/**
 *  Not specified.
 *
 *  Value: "VALUE_CAPTURE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DataChangeRecord_ValueCaptureType_ValueCaptureTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_DiagnosticMessage.severity

/**
 *  Severity level signaling an error "Error"
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Error;
/**
 *  Severity level signaling a non recoverable error "Fatal"
 *
 *  Value: "FATAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Fatal;
/**
 *  Lowest severity level "Info".
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Info;
/**
 *  Required default value.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_SeverityUnspecified;
/**
 *  Middle severity level "Warning".
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRSpanner_EncryptionInfo.encryptionType

/**
 *  The data is encrypted at rest with a key that is managed by the customer.
 *  The active version of the key. `kms_key_version` will be populated, and
 *  `encryption_status` may be populated.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_EncryptionInfo_EncryptionType_CustomerManagedEncryption;
/**
 *  The data is encrypted at rest with a key that is fully managed by Google. No
 *  key version or status will be populated. This is the default state.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_EncryptionInfo_EncryptionType_GoogleDefaultEncryption;
/**
 *  Encryption type was not specified, though data at rest remains encrypted.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_EncryptionInfo_EncryptionType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ExecuteSqlRequest.queryMode

/**
 *  The default mode. Only the statement results are returned.
 *
 *  Value: "NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal;
/**
 *  This mode returns only the query plan, without any results or execution
 *  statistics information.
 *
 *  Value: "PLAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan;
/**
 *  This mode returns the query plan, overall execution statistics, operator
 *  level execution statistics along with the results. This has a performance
 *  overhead compared to the other modes. It isn't recommended to use this mode
 *  for production traffic.
 *
 *  Value: "PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile;
/**
 *  This mode returns the query plan, overall (but not operator-level) execution
 *  statistics along with the results.
 *
 *  Value: "WITH_PLAN_AND_STATS"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_WithPlanAndStats;
/**
 *  This mode returns the overall (but not operator-level) execution statistics
 *  along with the results.
 *
 *  Value: "WITH_STATS"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_WithStats;

// ----------------------------------------------------------------------------
// GTLRSpanner_FreeInstanceMetadata.expireBehavior

/**
 *  Not specified.
 *
 *  Value: "EXPIRE_BEHAVIOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_ExpireBehaviorUnspecified;
/**
 *  When the free instance expires, upgrade the instance to a provisioned
 *  instance.
 *
 *  Value: "FREE_TO_PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_FreeToProvisioned;
/**
 *  When the free instance expires, disable the instance, and delete it after
 *  the grace period passes if it has not been upgraded.
 *
 *  Value: "REMOVE_AFTER_GRACE_PERIOD"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_RemoveAfterGracePeriod;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.defaultBackupScheduleType

/**
 *  A default backup schedule is created automatically when a new database is
 *  created in the instance. The default backup schedule creates a full backup
 *  every 24 hours. These full backups are retained for 7 days. You can edit or
 *  delete the default backup schedule once it's created.
 *
 *  Value: "AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_DefaultBackupScheduleType_Automatic;
/**
 *  Not specified.
 *
 *  Value: "DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_DefaultBackupScheduleType_DefaultBackupScheduleTypeUnspecified;
/**
 *  A default backup schedule isn't created automatically when a new database is
 *  created in the instance.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_DefaultBackupScheduleType_None;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.edition

/**
 *  Edition not specified.
 *
 *  Value: "EDITION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_Edition_EditionUnspecified;
/**
 *  Enterprise edition.
 *
 *  Value: "ENTERPRISE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_Edition_Enterprise;
/**
 *  Enterprise Plus edition.
 *
 *  Value: "ENTERPRISE_PLUS"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_Edition_EnterprisePlus;
/**
 *  Standard edition.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_Edition_Standard;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.instanceType

/**
 *  Free instances provide no guarantee for dedicated resources, [node_count,
 *  processing_units] should be 0. They come with stricter usage limits and
 *  limited support.
 *
 *  Value: "FREE_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_InstanceType_FreeInstance;
/**
 *  Not specified.
 *
 *  Value: "INSTANCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_InstanceType_InstanceTypeUnspecified;
/**
 *  Provisioned instances have dedicated resources, standard usage limits and
 *  support.
 *
 *  Value: "PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_InstanceType_Provisioned;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.state

/**
 *  The instance is still being created. Resources may not be available yet, and
 *  operations such as database creation may not work.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_Creating;
/**
 *  The instance is fully created and ready to do work such as creating
 *  databases.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.configType

/**
 *  Google-managed configuration.
 *
 *  Value: "GOOGLE_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_ConfigType_GoogleManaged;
/**
 *  Unspecified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_ConfigType_TypeUnspecified;
/**
 *  User-managed configuration.
 *
 *  Value: "USER_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_ConfigType_UserManaged;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.freeInstanceAvailability

/**
 *  Indicates that free instances are available to be created in this instance
 *  configuration.
 *
 *  Value: "AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Available;
/**
 *  Indicates that free instances are currently not available to be created in
 *  this instance configuration.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Disabled;
/**
 *  Not specified.
 *
 *  Value: "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_FreeInstanceAvailabilityUnspecified;
/**
 *  Indicates that additional free instances cannot be created in this instance
 *  configuration because the project has reached its limit of free instances.
 *
 *  Value: "QUOTA_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_QuotaExceeded;
/**
 *  Indicates that free instances are not supported in this instance
 *  configuration.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Unsupported;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.quorumType

/**
 *  An instance configuration tagged with the `DUAL_REGION` quorum type forms a
 *  write quorum with exactly two read-write regions in a multi-region
 *  configuration. This instance configuration requires failover in the event of
 *  regional failures.
 *
 *  Value: "DUAL_REGION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_QuorumType_DualRegion;
/**
 *  An instance configuration tagged with the `MULTI_REGION` quorum type forms a
 *  write quorum from replicas that are spread across more than one region in a
 *  multi-region configuration.
 *
 *  Value: "MULTI_REGION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_QuorumType_MultiRegion;
/**
 *  Quorum type not specified.
 *
 *  Value: "QUORUM_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_QuorumType_QuorumTypeUnspecified;
/**
 *  An instance configuration tagged with `REGION` quorum type forms a write
 *  quorum in a single region.
 *
 *  Value: "REGION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_QuorumType_Region;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.state

/**
 *  The instance configuration is still being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_State_Creating;
/**
 *  The instance configuration is fully created and ready to be used to create
 *  instances.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstancePartition.state

/**
 *  The instance partition is still being created. Resources may not be
 *  available yet, and operations such as creating placements using this
 *  instance partition may not work.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstancePartition_State_Creating;
/**
 *  The instance partition is fully created and ready to do work such as
 *  creating placements and using in databases.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstancePartition_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstancePartition_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Metric.aggregation

/**
 *  Required default value.
 *
 *  Value: "AGGREGATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Metric_Aggregation_AggregationUnspecified;
/**
 *  Use the maximum of all values.
 *
 *  Value: "MAX"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Metric_Aggregation_Max;
/**
 *  Use the sum of all values.
 *
 *  Value: "SUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Metric_Aggregation_Sum;

// ----------------------------------------------------------------------------
// GTLRSpanner_PlanNode.kind

/**
 *  Not specified.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_KindUnspecified;
/**
 *  Denotes a Relational operator node in the expression tree. Relational
 *  operators represent iterative processing of rows during query execution. For
 *  example, a `TableScan` operation that reads rows from a table.
 *
 *  Value: "RELATIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Relational;
/**
 *  Denotes a Scalar node in the expression tree. Scalar nodes represent
 *  non-iterable entities in the query plan. For example, constants or
 *  arithmetic operators appearing inside predicate expressions or references to
 *  column names.
 *
 *  Value: "SCALAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Scalar;

// ----------------------------------------------------------------------------
// GTLRSpanner_QuorumInfo.initiator

/**
 *  `ChangeQuorum` initiated by Google.
 *
 *  Value: "GOOGLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_QuorumInfo_Initiator_Google;
/**
 *  Unspecified.
 *
 *  Value: "INITIATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_QuorumInfo_Initiator_InitiatorUnspecified;
/**
 *  `ChangeQuorum` initiated by User.
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_QuorumInfo_Initiator_User;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReadRequest.lockHint

/**
 *  Acquire exclusive locks. Requesting exclusive locks is beneficial if you
 *  observe high write contention, which means you notice that multiple
 *  transactions are concurrently trying to read and write to the same data,
 *  resulting in a large number of aborts. This problem occurs when two
 *  transactions initially acquire shared locks and then both try to upgrade to
 *  exclusive locks at the same time. In this situation both transactions are
 *  waiting for the other to give up their lock, resulting in a deadlocked
 *  situation. Spanner is able to detect this occurring and force one of the
 *  transactions to abort. However, this is a slow and expensive operation and
 *  results in lower performance. In this case it makes sense to acquire
 *  exclusive locks at the start of the transaction because then when multiple
 *  transactions try to act on the same data, they automatically get serialized.
 *  Each transaction waits its turn to acquire the lock and avoids getting into
 *  deadlock situations. Because the exclusive lock hint is just a hint, it
 *  shouldn't be considered equivalent to a mutex. In other words, you shouldn't
 *  use Spanner exclusive locks as a mutual exclusion mechanism for the
 *  execution of code outside of Spanner. **Note:** Request exclusive locks
 *  judiciously because they block others from reading that data for the entire
 *  transaction, rather than just when the writes are being performed. Unless
 *  you observe high write contention, you should use the default of shared read
 *  locks so you don't prematurely block other clients from reading the data
 *  that you're writing to.
 *
 *  Value: "LOCK_HINT_EXCLUSIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadRequest_LockHint_LockHintExclusive;
/**
 *  Acquire shared locks. By default when you perform a read as part of a
 *  read-write transaction, Spanner acquires shared read locks, which allows
 *  other reads to still access the data until your transaction is ready to
 *  commit. When your transaction is committing and writes are being applied,
 *  the transaction attempts to upgrade to an exclusive lock for any data you
 *  are writing. For more information about locks, see [Lock
 *  modes](https://cloud.google.com/spanner/docs/introspection/lock-statistics#explain-lock-modes).
 *
 *  Value: "LOCK_HINT_SHARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadRequest_LockHint_LockHintShared;
/**
 *  Default value. `LOCK_HINT_UNSPECIFIED` is equivalent to `LOCK_HINT_SHARED`.
 *
 *  Value: "LOCK_HINT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadRequest_LockHint_LockHintUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReadRequest.orderBy

/**
 *  Read rows are returned in any order.
 *
 *  Value: "ORDER_BY_NO_ORDER"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadRequest_OrderBy_OrderByNoOrder;
/**
 *  Read rows are returned in primary key order. In the event that this option
 *  is used in conjunction with the `partition_token` field, the API returns an
 *  `INVALID_ARGUMENT` error.
 *
 *  Value: "ORDER_BY_PRIMARY_KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadRequest_OrderBy_OrderByPrimaryKey;
/**
 *  Default value. `ORDER_BY_UNSPECIFIED` is equivalent to
 *  `ORDER_BY_PRIMARY_KEY`.
 *
 *  Value: "ORDER_BY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadRequest_OrderBy_OrderByUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReadWrite.readLockMode

/**
 *  Optimistic lock mode. Locks for reads within the transaction are not
 *  acquired on read. Instead the locks are acquired on a commit to validate
 *  that read/queried data has not changed since the transaction started.
 *  Semantics described only applies to SERIALIZABLE isolation.
 *
 *  Value: "OPTIMISTIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadWrite_ReadLockMode_Optimistic;
/**
 *  Pessimistic lock mode. Read locks are acquired immediately on read.
 *  Semantics described only applies to SERIALIZABLE isolation.
 *
 *  Value: "PESSIMISTIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadWrite_ReadLockMode_Pessimistic;
/**
 *  Default value. * If isolation level is REPEATABLE_READ, then it is an error
 *  to specify `read_lock_mode`. Locking semantics default to `OPTIMISTIC`. No
 *  validation checks are done for reads, except to validate that the data that
 *  was served at the snapshot time is unchanged at commit time in the following
 *  cases: 1. reads done as part of queries that use `SELECT FOR UPDATE` 2.
 *  reads done as part of statements with a `LOCK_SCANNED_RANGES` hint 3. reads
 *  done as part of DML statements * At all other isolation levels, if
 *  `read_lock_mode` is the default value, then pessimistic read locks are used.
 *
 *  Value: "READ_LOCK_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadWrite_ReadLockMode_ReadLockModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReplicaInfo.type

/**
 *  Read-only replicas only support reads (not writes). Read-only replicas: *
 *  Maintain a full copy of your data. * Serve reads. * Do not participate in
 *  voting to commit writes. * Are not eligible to become a leader.
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_ReadOnly;
/**
 *  Read-write replicas support both reads and writes. These replicas: *
 *  Maintain a full copy of your data. * Serve reads. * Can vote whether to
 *  commit a write. * Participate in leadership election. * Are eligible to
 *  become a leader.
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_ReadWrite;
/**
 *  Not specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_TypeUnspecified;
/**
 *  Witness replicas don't support reads but do participate in voting to commit
 *  writes. Witness replicas: * Do not maintain a full copy of data. * Do not
 *  serve reads. * Vote whether to commit writes. * Participate in leader
 *  election but are not eligible to become leader.
 *
 *  Value: "WITNESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_Witness;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReplicaSelection.type

/**
 *  Read-only replicas only support reads (not writes).
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaSelection_Type_ReadOnly;
/**
 *  Read-write replicas support both reads and writes.
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaSelection_Type_ReadWrite;
/**
 *  Not specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaSelection_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_RequestOptions.priority

/**
 *  This specifies that the request is high priority.
 *
 *  Value: "PRIORITY_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityHigh;
/**
 *  This specifies that the request is low priority.
 *
 *  Value: "PRIORITY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityLow;
/**
 *  This specifies that the request is medium priority.
 *
 *  Value: "PRIORITY_MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityMedium;
/**
 *  `PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`.
 *
 *  Value: "PRIORITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreDatabaseEncryptionConfig.encryptionType

/**
 *  Use customer managed encryption. If specified, `kms_key_name` must must
 *  contain a valid Cloud KMS key.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_CustomerManagedEncryption;
/**
 *  Unspecified. Do not use.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Use Google default encryption.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_GoogleDefaultEncryption;
/**
 *  This is the default option when encryption_config is not specified.
 *
 *  Value: "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreDatabaseMetadata.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseMetadata_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseMetadata_SourceType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreInfo.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreInfo_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreInfo_SourceType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_TransactionOptions.isolationLevel

/**
 *  Default value. If the value is not specified, the `SERIALIZABLE` isolation
 *  level is used.
 *
 *  Value: "ISOLATION_LEVEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_TransactionOptions_IsolationLevel_IsolationLevelUnspecified;
/**
 *  All reads performed during the transaction observe a consistent snapshot of
 *  the database, and the transaction is only successfully committed in the
 *  absence of conflicts between its updates and any concurrent updates that
 *  have occurred since that snapshot. Consequently, in contrast to
 *  `SERIALIZABLE` transactions, only write-write conflicts are detected in
 *  snapshot transactions. This isolation level does not support Read-only and
 *  Partitioned DML transactions. When `REPEATABLE_READ` is specified on a
 *  read-write transaction, the locking semantics default to `OPTIMISTIC`.
 *
 *  Value: "REPEATABLE_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_TransactionOptions_IsolationLevel_RepeatableRead;
/**
 *  All transactions appear as if they executed in a serial order, even if some
 *  of the reads, writes, and other operations of distinct transactions actually
 *  occurred in parallel. Spanner assigns commit timestamps that reflect the
 *  order of committed transactions to implement this property. Spanner offers a
 *  stronger guarantee than serializability called external consistency. For
 *  more information, see [TrueTime and external
 *  consistency](https://cloud.google.com/spanner/docs/true-time-external-consistency#serializability).
 *
 *  Value: "SERIALIZABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_TransactionOptions_IsolationLevel_Serializable;

// ----------------------------------------------------------------------------
// GTLRSpanner_Type.code

/**
 *  Encoded as `list`, where the list elements are represented according to
 *  array_element_type.
 *
 *  Value: "ARRAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Array;
/**
 *  Encoded as JSON `true` or `false`.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Bool;
/**
 *  Encoded as a base64-encoded `string`, as described in RFC 4648, section 4.
 *
 *  Value: "BYTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Bytes;
/**
 *  Encoded as `string` in RFC 3339 date format.
 *
 *  Value: "DATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Date;
/**
 *  Encoded as `string`, in decimal format.
 *
 *  Value: "ENUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Enum;
/**
 *  Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or `"-Infinity"`.
 *
 *  Value: "FLOAT32"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Float32;
/**
 *  Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or `"-Infinity"`.
 *
 *  Value: "FLOAT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Float64;
/**
 *  Encoded as `string`, in decimal format.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Int64;
/**
 *  Encoded as `string`, in `ISO8601` duration format -
 *  `P[n]Y[n]M[n]DT[n]H[n]M[n[.fraction]]S` where `n` is an integer. For
 *  example, `P1Y2M3DT4H5M6.5S` represents time duration of 1 year, 2 months, 3
 *  days, 4 hours, 5 minutes, and 6.5 seconds.
 *
 *  Value: "INTERVAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Interval;
/**
 *  Encoded as a JSON-formatted `string` as described in RFC 7159. The following
 *  rules are applied when parsing JSON input: - Whitespace characters are not
 *  preserved. - If a JSON object has duplicate keys, only the first key is
 *  preserved. - Members of a JSON object are not guaranteed to have their order
 *  preserved. - JSON array elements will have their order preserved.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Json;
/**
 *  Encoded as `string`, in decimal format or scientific notation format.
 *  Decimal format: `[+-]Digits[.[Digits]]` or `+-.Digits` Scientific notation:
 *  `[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
 *  `+-.Digits[ExponentIndicator[+-]Digits]` (ExponentIndicator is `"e"` or
 *  `"E"`)
 *
 *  Value: "NUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Numeric;
/**
 *  Encoded as a base64-encoded `string`, as described in RFC 4648, section 4.
 *
 *  Value: "PROTO"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Proto;
/**
 *  Encoded as `string`.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_String;
/**
 *  Encoded as `list`, where list element `i` is represented according to
 *  [struct_type.fields[i]][google.spanner.v1.StructType.fields].
 *
 *  Value: "STRUCT"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Struct;
/**
 *  Encoded as `string` in RFC 3339 timestamp format. The time zone must be
 *  present, and must be `"Z"`. If the schema has the column option
 *  `allow_commit_timestamp=true`, the placeholder string
 *  `"spanner.commit_timestamp()"` can be used to instruct the system to insert
 *  the commit timestamp associated with the transaction commit.
 *
 *  Value: "TIMESTAMP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Timestamp;
/**
 *  Not specified.
 *
 *  Value: "TYPE_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_TypeCodeUnspecified;
/**
 *  Encoded as `string`, in lower-case hexa-decimal format, as described in RFC
 *  9562, section 4.
 *
 *  Value: "UUID"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Uuid;

// ----------------------------------------------------------------------------
// GTLRSpanner_Type.typeAnnotation

/**
 *  PostgreSQL compatible JSONB type. This annotation needs to be applied to
 *  Type instances having JSON type code to specify that values of this type
 *  should be treated as PostgreSQL JSONB values. Currently this annotation is
 *  always needed for JSON when a client interacts with PostgreSQL-enabled
 *  Spanner databases.
 *
 *  Value: "PG_JSONB"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_PgJsonb;
/**
 *  PostgreSQL compatible NUMERIC type. This annotation needs to be applied to
 *  Type instances having NUMERIC type code to specify that values of this type
 *  should be treated as PostgreSQL NUMERIC values. Currently this annotation is
 *  always needed for NUMERIC when a client interacts with PostgreSQL-enabled
 *  Spanner databases.
 *
 *  Value: "PG_NUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_PgNumeric;
/**
 *  PostgreSQL compatible OID type. This annotation can be used by a client
 *  interacting with PostgreSQL-enabled Spanner database to specify that a value
 *  should be treated using the semantics of the OID type.
 *
 *  Value: "PG_OID"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_PgOid;
/**
 *  Not specified.
 *
 *  Value: "TYPE_ANNOTATION_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_TypeAnnotationCodeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_UpdateInstanceMetadata.expectedFulfillmentPeriod

/**
 *  Extended fulfillment period. It can take up to an hour for the operation to
 *  complete.
 *
 *  Value: "FULFILLMENT_PERIOD_EXTENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_UpdateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodExtended;
/**
 *  Normal fulfillment period. The operation is expected to complete within
 *  minutes.
 *
 *  Value: "FULFILLMENT_PERIOD_NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_UpdateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodNormal;
/**
 *  Not specified.
 *
 *  Value: "FULFILLMENT_PERIOD_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_UpdateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_VisualizationData.keyUnit

/**
 *  Each entry corresponds to a chunk of keys
 *
 *  Value: "CHUNK"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_VisualizationData_KeyUnit_Chunk;
/**
 *  Each entry corresponds to one key
 *
 *  Value: "KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_VisualizationData_KeyUnit_Key;
/**
 *  Required default value
 *
 *  Value: "KEY_UNIT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_VisualizationData_KeyUnit_KeyUnitUnspecified;

/**
 *  A session in the Cloud Spanner Adapter API.
 */
@interface GTLRSpanner_AdapterSession : GTLRObject

/** Identifier. The name of the session. This is always system-assigned. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Message sent by the client to the adapter.
 */
@interface GTLRSpanner_AdaptMessageRequest : GTLRObject

/** Optional. Opaque request state passed by the client to the server. */
@property(nonatomic, strong, nullable) GTLRSpanner_AdaptMessageRequest_Attachments *attachments;

/**
 *  Optional. Uninterpreted bytes from the underlying wire protocol.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *payload;

/** Required. Identifier for the underlying wire protocol. */
@property(nonatomic, copy, nullable) NSString *protocol;

@end


/**
 *  Optional. Opaque request state passed by the client to the server.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_AdaptMessageRequest_Attachments : GTLRObject
@end


/**
 *  Message sent by the adapter to the client.
 */
@interface GTLRSpanner_AdaptMessageResponse : GTLRObject

/**
 *  Optional. Indicates whether this is the last AdaptMessageResponse in the
 *  stream. This field may be optionally set by the server. Clients should not
 *  rely on this field being set in all cases.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *last;

/**
 *  Optional. Uninterpreted bytes from the underlying wire protocol.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *payload;

/** Optional. Opaque state updates to be applied by the client. */
@property(nonatomic, strong, nullable) GTLRSpanner_AdaptMessageResponse_StateUpdates *stateUpdates;

@end


/**
 *  Optional. Opaque state updates to be applied by the client.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_AdaptMessageResponse_StateUpdates : GTLRObject
@end


/**
 *  The request for AddSplitPoints.
 */
@interface GTLRSpanner_AddSplitPointsRequest : GTLRObject

/**
 *  Optional. A user-supplied tag associated with the split points. For example,
 *  "initial_data_load", "special_event_1". Defaults to "CloudAddSplitPointsAPI"
 *  if not specified. The length of the tag must not exceed 50 characters, or
 *  else it is trimmed. Only valid UTF8 characters are allowed.
 */
@property(nonatomic, copy, nullable) NSString *initiator;

/** Required. The split points to add. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_SplitPoints *> *splitPoints;

@end


/**
 *  The response for AddSplitPoints.
 */
@interface GTLRSpanner_AddSplitPointsResponse : GTLRObject
@end


/**
 *  AsymmetricAutoscalingOption specifies the scaling of replicas identified by
 *  the given selection.
 */
@interface GTLRSpanner_AsymmetricAutoscalingOption : GTLRObject

/**
 *  Optional. Overrides applied to the top-level autoscaling configuration for
 *  the selected replicas.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_AutoscalingConfigOverrides *overrides;

/**
 *  Required. Selects the replicas to which this AsymmetricAutoscalingOption
 *  applies. Only read-only replicas are supported.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceReplicaSelection *replicaSelection;

@end


/**
 *  Autoscaling configuration for an instance.
 */
@interface GTLRSpanner_AutoscalingConfig : GTLRObject

/**
 *  Optional. Optional asymmetric autoscaling options. Replicas matching the
 *  replica selection criteria will be autoscaled independently from other
 *  replicas. The autoscaler will scale the replicas based on the utilization of
 *  replicas identified by the replica selection. Replica selections should not
 *  overlap with each other. Other replicas (those do not match any replica
 *  selection) will be autoscaled together and will have the same compute
 *  capacity allocated to them.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_AsymmetricAutoscalingOption *> *asymmetricAutoscalingOptions;

/** Required. Autoscaling limits for an instance. */
@property(nonatomic, strong, nullable) GTLRSpanner_AutoscalingLimits *autoscalingLimits;

/** Required. The autoscaling targets for an instance. */
@property(nonatomic, strong, nullable) GTLRSpanner_AutoscalingTargets *autoscalingTargets;

@end


/**
 *  Overrides the top-level autoscaling configuration for the replicas
 *  identified by `replica_selection`. All fields in this message are optional.
 *  Any unspecified fields will use the corresponding values from the top-level
 *  autoscaling configuration.
 */
@interface GTLRSpanner_AutoscalingConfigOverrides : GTLRObject

/**
 *  Optional. If specified, overrides the min/max limit in the top-level
 *  autoscaling configuration for the selected replicas.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_AutoscalingLimits *autoscalingLimits;

/**
 *  Optional. If specified, overrides the autoscaling target
 *  high_priority_cpu_utilization_percent in the top-level autoscaling
 *  configuration for the selected replicas.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoscalingTargetHighPriorityCpuUtilizationPercent;

@end


/**
 *  The autoscaling limits for the instance. Users can define the minimum and
 *  maximum compute capacity allocated to the instance, and the autoscaler will
 *  only scale within that range. Users can either use nodes or processing units
 *  to specify the limits, but should use the same unit to set both the
 *  min_limit and max_limit.
 */
@interface GTLRSpanner_AutoscalingLimits : GTLRObject

/**
 *  Maximum number of nodes allocated to the instance. If set, this number
 *  should be greater than or equal to min_nodes.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxNodes;

/**
 *  Maximum number of processing units allocated to the instance. If set, this
 *  number should be multiples of 1000 and be greater than or equal to
 *  min_processing_units.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxProcessingUnits;

/**
 *  Minimum number of nodes allocated to the instance. If set, this number
 *  should be greater than or equal to 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minNodes;

/**
 *  Minimum number of processing units allocated to the instance. If set, this
 *  number should be multiples of 1000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minProcessingUnits;

@end


/**
 *  The autoscaling targets for an instance.
 */
@interface GTLRSpanner_AutoscalingTargets : GTLRObject

/**
 *  Required. The target high priority cpu utilization percentage that the
 *  autoscaler should be trying to achieve for the instance. This number is on a
 *  scale from 0 (no utilization) to 100 (full utilization). The valid range is
 *  [10, 90] inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *highPriorityCpuUtilizationPercent;

/**
 *  Required. The target storage utilization percentage that the autoscaler
 *  should be trying to achieve for the instance. This number is on a scale from
 *  0 (no utilization) to 100 (full utilization). The valid range is [10, 99]
 *  inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *storageUtilizationPercent;

@end


/**
 *  A backup of a Cloud Spanner database.
 */
@interface GTLRSpanner_Backup : GTLRObject

/**
 *  Output only. List of backup schedule URIs that are associated with creating
 *  this backup. This is only applicable for scheduled backups, and is empty for
 *  on-demand backups. To optimize for storage, whenever possible, multiple
 *  schedules are collapsed together to create one backup. In such cases, this
 *  field captures the list of all backup schedule URIs that are associated with
 *  creating this backup. If collapsing is not done, then this field captures
 *  the single backup schedule URI associated with creating this backup.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backupSchedules;

/**
 *  Output only. The time the CreateBackup request is received. If the request
 *  does not specify `version_time`, the `version_time` of the backup will be
 *  equivalent to the `create_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required for the CreateBackup operation. Name of the database from which
 *  this backup was created. This needs to be in the same instance as the
 *  backup. Values are of the form `projects//instances//databases/`.
 */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  Output only. The database dialect information for the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Backup_DatabaseDialect_DatabaseDialectUnspecified
 *        Default value. This value will create a database with the
 *        GOOGLE_STANDARD_SQL dialect. (Value: "DATABASE_DIALECT_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Backup_DatabaseDialect_GoogleStandardSql GoogleSQL
 *        supported SQL. (Value: "GOOGLE_STANDARD_SQL")
 *    @arg @c kGTLRSpanner_Backup_DatabaseDialect_Postgresql PostgreSQL
 *        supported SQL. (Value: "POSTGRESQL")
 */
@property(nonatomic, copy, nullable) NSString *databaseDialect;

/** Output only. The encryption information for the backup. */
@property(nonatomic, strong, nullable) GTLRSpanner_EncryptionInfo *encryptionInfo;

/**
 *  Output only. The encryption information for the backup, whether it is
 *  protected by one or more KMS keys. The information includes all Cloud KMS
 *  key versions used to encrypt the backup. The `encryption_status` field
 *  inside of each `EncryptionInfo` is not populated. At least one of the key
 *  versions must be available for the backup to be restored. If a key version
 *  is revoked in the middle of a restore, the restore behavior is undefined.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_EncryptionInfo *> *encryptionInformation;

/**
 *  Output only. For a backup in an incremental backup chain, this is the
 *  storage space needed to keep the data that has changed since the previous
 *  backup. For all other backups, this is always the size of the backup. This
 *  value may change if backups on the same chain get deleted or expired. This
 *  field can be used to calculate the total storage space used by a set of
 *  backups. For example, the total space used by all backups of a database can
 *  be computed by summing up this field.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exclusiveSizeBytes;

/**
 *  Required for the CreateBackup operation. The expiration time of the backup,
 *  with microseconds granularity that must be at least 6 hours and at most 366
 *  days from the time the CreateBackup request is processed. Once the
 *  `expire_time` has passed, the backup is eligible to be automatically deleted
 *  by Cloud Spanner to free the resources used by the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Output only. The number of bytes that will be freed by deleting this backup.
 *  This value will be zero if, for example, this backup is part of an
 *  incremental backup chain and younger backups in the chain require that we
 *  keep its data. For backups not in an incremental backup chain, this is
 *  always the size of the backup. This value may change if backups on the same
 *  chain get created, deleted or expired.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *freeableSizeBytes;

/**
 *  Output only. Populated only for backups in an incremental backup chain.
 *  Backups share the same chain id if and only if they belong to the same
 *  incremental backup chain. Use this field to determine which backups are part
 *  of the same incremental backup chain. The ordering of backups in the chain
 *  can be determined by ordering the backup `version_time`.
 */
@property(nonatomic, copy, nullable) NSString *incrementalBackupChainId;

/**
 *  Output only. The instance partition storing the backup. This is the same as
 *  the list of the instance partitions that the database recorded at the
 *  backup's `version_time`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_BackupInstancePartition *> *instancePartitions;

/**
 *  Output only. The max allowed expiration time of the backup, with
 *  microseconds granularity. A backup's expiration time can be configured in
 *  multiple APIs: CreateBackup, UpdateBackup, CopyBackup. When updating or
 *  copying an existing backup, the expiration time specified must be less than
 *  `Backup.max_expire_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *maxExpireTime;

/**
 *  Output only for the CreateBackup operation. Required for the UpdateBackup
 *  operation. A globally unique identifier for the backup which cannot be
 *  changed. Values are of the form `projects//instances//backups/a-z*[a-z0-9]`
 *  The final segment of the name must be between 2 and 60 characters in length.
 *  The backup is stored in the location(s) specified in the instance
 *  configuration of the instance containing the backup, identified by the
 *  prefix of the backup name of the form `projects//instances/`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Data deleted at a time older than this is guaranteed not to be
 *  retained in order to support this backup. For a backup in an incremental
 *  backup chain, this is the version time of the oldest backup that exists or
 *  ever existed in the chain. For all other backups, this is the version time
 *  of the backup. This field can be used to understand what data is being
 *  retained by the backup system.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *oldestVersionTime;

/**
 *  Output only. The names of the destination backups being created by copying
 *  this source backup. The backup names are of the form
 *  `projects//instances//backups/`. Referencing backups may exist in different
 *  instances. The existence of any referencing backup prevents the backup from
 *  being deleted. When the copy operation is done (either successfully
 *  completed or cancelled or the destination backup is deleted), the reference
 *  to the backup is removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingBackups;

/**
 *  Output only. The names of the restored databases that reference the backup.
 *  The database names are of the form `projects//instances//databases/`.
 *  Referencing databases may exist in different instances. The existence of any
 *  referencing database prevents the backup from being deleted. When a restored
 *  database from the backup enters the `READY` state, the reference to the
 *  backup is removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingDatabases;

/**
 *  Output only. Size of the backup in bytes. For a backup in an incremental
 *  backup chain, this is the sum of the `exclusive_size_bytes` of itself and
 *  all older backups in the chain.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeBytes;

/**
 *  Output only. The current state of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Backup_State_Creating The pending backup is still
 *        being created. Operations on the backup may fail with
 *        `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Backup_State_Ready The backup is complete and ready
 *        for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Backup_State_StateUnspecified Not specified. (Value:
 *        "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The backup will contain an externally consistent copy of the database at the
 *  timestamp specified by `version_time`. If `version_time` is not specified,
 *  the system will set `version_time` to the `create_time` of the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *versionTime;

@end


/**
 *  Information about a backup.
 */
@interface GTLRSpanner_BackupInfo : GTLRObject

/** Name of the backup. */
@property(nonatomic, copy, nullable) NSString *backup;

/** The time the CreateBackup request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Name of the database the backup was created from. */
@property(nonatomic, copy, nullable) NSString *sourceDatabase;

/**
 *  The backup contains an externally consistent copy of `source_database` at
 *  the timestamp specified by `version_time`. If the CreateBackup request did
 *  not specify `version_time`, the `version_time` of the backup is equivalent
 *  to the `create_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *versionTime;

@end


/**
 *  Instance partition information for the backup.
 */
@interface GTLRSpanner_BackupInstancePartition : GTLRObject

/**
 *  A unique identifier for the instance partition. Values are of the form
 *  `projects//instances//instancePartitions/`
 */
@property(nonatomic, copy, nullable) NSString *instancePartition;

@end


/**
 *  BackupSchedule expresses the automated backup creation specification for a
 *  Spanner database.
 */
@interface GTLRSpanner_BackupSchedule : GTLRObject

/**
 *  Optional. The encryption configuration that is used to encrypt the backup.
 *  If this field is not specified, the backup uses the same encryption
 *  configuration as the database.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_CreateBackupEncryptionConfig *encryptionConfig;

/** The schedule creates only full backups. */
@property(nonatomic, strong, nullable) GTLRSpanner_FullBackupSpec *fullBackupSpec;

/** The schedule creates incremental backup chains. */
@property(nonatomic, strong, nullable) GTLRSpanner_IncrementalBackupSpec *incrementalBackupSpec;

/**
 *  Identifier. Output only for the CreateBackupSchedule operation. Required for
 *  the UpdateBackupSchedule operation. A globally unique identifier for the
 *  backup schedule which cannot be changed. Values are of the form
 *  `projects//instances//databases//backupSchedules/a-z*[a-z0-9]` The final
 *  segment of the name must be between 2 and 60 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. The retention duration of a backup that must be at least 6 hours
 *  and at most 366 days. The backup is eligible to be automatically deleted
 *  once the retention period has elapsed.
 */
@property(nonatomic, strong, nullable) GTLRDuration *retentionDuration;

/**
 *  Optional. The schedule specification based on which the backup creations are
 *  triggered.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupScheduleSpec *spec;

/**
 *  Output only. The timestamp at which the schedule was last updated. If the
 *  schedule has never been updated, this field contains the timestamp when the
 *  schedule was first created.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Defines specifications of the backup schedule.
 */
@interface GTLRSpanner_BackupScheduleSpec : GTLRObject

/** Cron style schedule specification. */
@property(nonatomic, strong, nullable) GTLRSpanner_CrontabSpec *cronSpec;

@end


/**
 *  The request for BatchCreateSessions.
 */
@interface GTLRSpanner_BatchCreateSessionsRequest : GTLRObject

/**
 *  Required. The number of sessions to be created in this batch call. The API
 *  can return fewer than the requested number of sessions. If a specific number
 *  of sessions are desired, the client can make additional calls to
 *  `BatchCreateSessions` (adjusting session_count as necessary).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sessionCount;

/** Parameters to apply to each created session. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *sessionTemplate;

@end


/**
 *  The response for BatchCreateSessions.
 */
@interface GTLRSpanner_BatchCreateSessionsResponse : GTLRObject

/** The freshly created sessions. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *session;

@end


/**
 *  The request for BatchWrite.
 */
@interface GTLRSpanner_BatchWriteRequest : GTLRObject

/**
 *  Optional. If you don't set the `exclude_txn_from_change_streams` option or
 *  if it's set to `false`, then any change streams monitoring columns modified
 *  by transactions will capture the updates made within that transaction.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *excludeTxnFromChangeStreams;

/** Required. The groups of mutations to be applied. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_MutationGroup *> *mutationGroups;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

@end


/**
 *  The result of applying a batch of mutations.
 */
@interface GTLRSpanner_BatchWriteResponse : GTLRObject

/**
 *  The commit timestamp of the transaction that applied this batch. Present if
 *  `status` is `OK`, absent otherwise.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

/**
 *  The mutation groups applied in this batch. The values index into the
 *  `mutation_groups` field in the corresponding `BatchWriteRequest`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *indexes;

/** An `OK` status indicates success. Any other status indicates a failure. */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *status;

@end


/**
 *  The request for BeginTransaction.
 */
@interface GTLRSpanner_BeginTransactionRequest : GTLRObject

/**
 *  Optional. Required for read-write transactions on a multiplexed session that
 *  commit mutations but don't perform any reads or queries. You must randomly
 *  select one of the mutations from the mutation set and send it as a part of
 *  this request.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Mutation *mutationKey;

/** Required. Options for the new transaction. */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *options;

/**
 *  Common options for this request. Priority is ignored for this request.
 *  Setting the priority in this `request_options` struct doesn't do anything.
 *  To set the priority for a transaction, set it on the reads and writes that
 *  are part of this transaction instead.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRSpanner_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `domain:{domain}`: The G Suite domain
 *  (primary) that represents all the users of that domain. For example,
 *  `google.com` or `example.com`. *
 *  `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workforce identity pool. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
 *  All workforce identities in a group. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All workforce identities with a specific attribute value. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/
 *  *`: All identities in a workforce identity pool. *
 *  `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workload identity pool. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
 *  A workload identity pool group. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All identities in a workload identity pool with a certain attribute. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/
 *  *`: All identities in a workload identity pool. *
 *  `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. *
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  Deleted single identity in a workforce identity pool. For example,
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM
 *  roles and permissions, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/roles-overview). For a list
 *  of the available pre-defined roles, see
 *  [here](https://cloud.google.com/iam/docs/understanding-roles).
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Metadata type for the long-running operation returned by ChangeQuorum.
 */
@interface GTLRSpanner_ChangeQuorumMetadata : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The request for ChangeQuorum. */
@property(nonatomic, strong, nullable) GTLRSpanner_ChangeQuorumRequest *request;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for ChangeQuorum.
 */
@interface GTLRSpanner_ChangeQuorumRequest : GTLRObject

/**
 *  Optional. The etag is the hash of the `QuorumInfo`. The `ChangeQuorum`
 *  operation is only performed if the etag matches that of the `QuorumInfo` in
 *  the current database resource. Otherwise the API returns an `ABORTED` error.
 *  The etag is used for optimistic concurrency control as a way to help prevent
 *  simultaneous change quorum requests that could create a race condition.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Required. Name of the database in which to apply `ChangeQuorum`. Values are
 *  of the form `projects//instances//databases/`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. The type of this quorum. */
@property(nonatomic, strong, nullable) GTLRSpanner_QuorumType *quorumType;

@end


/**
 *  Spanner Change Streams enable customers to capture and stream out changes to
 *  their Spanner databases in real-time. A change stream can be created with
 *  option partition_mode='IMMUTABLE_KEY_RANGE' or
 *  partition_mode='MUTABLE_KEY_RANGE'. This message is only used in Change
 *  Streams created with the option partition_mode='MUTABLE_KEY_RANGE'. Spanner
 *  automatically creates a special Table-Valued Function (TVF) along with each
 *  Change Streams. The function provides access to the change stream's records.
 *  The function is named READ_ (where is the name of the change stream), and it
 *  returns a table with only one column called ChangeRecord.
 */
@interface GTLRSpanner_ChangeStreamRecord : GTLRObject

/**
 *  Data change record describing a data change for a change stream partition.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_DataChangeRecord *dataChangeRecord;

/** Heartbeat record describing a heartbeat for a change stream partition. */
@property(nonatomic, strong, nullable) GTLRSpanner_HeartbeatRecord *heartbeatRecord;

/** Partition end record describing a terminated change stream partition. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionEndRecord *partitionEndRecord;

/**
 *  Partition event record describing key range changes for a change stream
 *  partition.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionEventRecord *partitionEventRecord;

/** Partition start record describing a new change stream partition. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionStartRecord *partitionStartRecord;

@end


/**
 *  Metadata associated with a parent-child relationship appearing in a
 *  PlanNode.
 */
@interface GTLRSpanner_ChildLink : GTLRObject

/**
 *  The node to which the link points.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *childIndex;

/**
 *  The type of the link. For example, in Hash Joins this could be used to
 *  distinguish between the build child and the probe child, or in the case of
 *  the child being an output variable, to represent the tag associated with the
 *  output variable.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Only present if the child node is SCALAR and corresponds to an output
 *  variable of the parent node. The field carries the name of the output
 *  variable. For example, a `TableScan` operator that reads rows from a table
 *  will have child links to the `SCALAR` nodes representing the output
 *  variables created for each column that is read by the operator. The
 *  corresponding `variable` fields will be set to the variable names assigned
 *  to the columns.
 */
@property(nonatomic, copy, nullable) NSString *variable;

@end


/**
 *  Metadata for a column.
 */
@interface GTLRSpanner_ColumnMetadata : GTLRObject

/**
 *  Indicates whether the column is a primary key column.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isPrimaryKey;

/** Name of the column. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Ordinal position of the column based on the original table definition in the
 *  schema starting with a value of 1.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ordinalPosition;

/** Type of the column. */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *type;

@end


/**
 *  The request for Commit.
 */
@interface GTLRSpanner_CommitRequest : GTLRObject

/**
 *  Optional. The amount of latency this request is configured to incur in order
 *  to improve throughput. If this field isn't set, Spanner assumes requests are
 *  relatively latency sensitive and automatically determines an appropriate
 *  delay time. You can specify a commit delay value between 0 and 500 ms.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxCommitDelay;

/**
 *  The mutations to be executed when this transaction commits. All mutations
 *  are applied atomically, in the order they appear in this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Mutation *> *mutations;

/**
 *  Optional. If the read-write transaction was executed on a multiplexed
 *  session, then you must include the precommit token with the highest sequence
 *  number received in this transaction attempt. Failing to do so results in a
 *  `FailedPrecondition` error.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_MultiplexedSessionPrecommitToken *precommitToken;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  If `true`, then statistics related to the transaction is included in the
 *  CommitResponse. Default value is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *returnCommitStats;

/**
 *  Execute mutations in a temporary transaction. Note that unlike commit of a
 *  previously-started transaction, commit with a temporary transaction is
 *  non-idempotent. That is, if the `CommitRequest` is sent to Cloud Spanner
 *  more than once (for instance, due to retries in the application, or in the
 *  transport library), it's possible that the mutations are executed more than
 *  once. If this is undesirable, use BeginTransaction and Commit instead.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUseTransaction;

/**
 *  Commit a previously-started transaction.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  The response for Commit.
 */
@interface GTLRSpanner_CommitResponse : GTLRObject

/**
 *  The statistics about this `Commit`. Not returned by default. For more
 *  information, see CommitRequest.return_commit_stats.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_CommitStats *commitStats;

/** The Cloud Spanner timestamp at which the transaction committed. */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

/**
 *  If specified, transaction has not committed yet. You must retry the commit
 *  with the new precommit token.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_MultiplexedSessionPrecommitToken *precommitToken;

/**
 *  If `TransactionOptions.isolation_level` is set to
 *  `IsolationLevel.REPEATABLE_READ`, then the snapshot timestamp is the
 *  timestamp at which all reads in the transaction ran. This timestamp is never
 *  returned.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *snapshotTimestamp;

@end


/**
 *  Additional statistics about a commit.
 */
@interface GTLRSpanner_CommitStats : GTLRObject

/**
 *  The total number of mutations for the transaction. Knowing the
 *  `mutation_count` value can help you maximize the number of mutations in a
 *  transaction and minimize the number of API round trips. You can also monitor
 *  this value to prevent transactions from exceeding the system
 *  [limit](https://cloud.google.com/spanner/quotas#limits_for_creating_reading_updating_and_deleting_data).
 *  If the number of mutations exceeds the limit, the server returns
 *  [INVALID_ARGUMENT](https://cloud.google.com/spanner/docs/reference/rest/v1/Code#ENUM_VALUES.INVALID_ARGUMENT).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mutationCount;

@end


/**
 *  A message representing context for a KeyRangeInfo, including a label, value,
 *  unit, and severity.
 */
@interface GTLRSpanner_ContextValue : GTLRObject

/** The label for the context value. e.g. "latency". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *label;

/**
 *  The severity of this context.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Error Severity level signaling
 *        an error "Error" (Value: "ERROR")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Fatal Severity level signaling
 *        a non recoverable error "Fatal" (Value: "FATAL")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Info Lowest severity level
 *        "Info". (Value: "INFO")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_SeverityUnspecified Required
 *        default value. (Value: "SEVERITY_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Warning Middle severity level
 *        "Warning". (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** The unit of the context value. */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  The value for the context.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  Encryption configuration for the copied backup.
 */
@interface GTLRSpanner_CopyBackupEncryptionConfig : GTLRObject

/**
 *  Required. The encryption type of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_CustomerManagedEncryption
 *        Use customer managed encryption. If specified, either `kms_key_name`
 *        or `kms_key_names` must contain valid Cloud KMS keys. (Value:
 *        "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_EncryptionTypeUnspecified
 *        Unspecified. Do not use. (Value: "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_GoogleDefaultEncryption
 *        Use Google default encryption. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption
 *        This is the default option for CopyBackup when encryption_config is
 *        not specified. For example, if the source backup is using
 *        `Customer_Managed_Encryption`, the backup will be using the same Cloud
 *        KMS key as the source backup. (Value:
 *        "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Optional. This field is maintained for backwards compatibility. For new
 *  callers, we recommend using `kms_key_names` to specify the KMS key. Only use
 *  `kms_key_name` if the location of the KMS key matches the database
 *  instance's configuration (location) exactly. For example, if the KMS
 *  location is in `us-central1` or `nam3`, then the database instance must also
 *  be in `us-central1` or `nam3`. The Cloud KMS key that is used to encrypt and
 *  decrypt the restored database. Set this field only when encryption_type is
 *  `CUSTOMER_MANAGED_ENCRYPTION`. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

/**
 *  Optional. Specifies the KMS configuration for the one or more keys used to
 *  protect the backup. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`. KMS keys specified can be in
 *  any order. The keys referenced by `kms_key_names` must fully cover all
 *  regions of the backup's instance configuration. Some examples: * For
 *  regional (single-region) instance configurations, specify a regional
 *  location KMS key. * For multi-region instance configurations of type
 *  `GOOGLE_MANAGED`, either specify a multi-region location KMS key or multiple
 *  regional location KMS keys that cover all regions in the instance
 *  configuration. * For an instance configuration of type `USER_MANAGED`,
 *  specify only regional location KMS keys to cover each region in the instance
 *  configuration. Multi-region location KMS keys aren't supported for
 *  `USER_MANAGED` type instance configurations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kmsKeyNames;

@end


/**
 *  Metadata type for the operation returned by CopyBackup.
 */
@interface GTLRSpanner_CopyBackupMetadata : GTLRObject

/**
 *  The time at which cancellation of CopyBackup operation was received.
 *  Operations.CancelOperation starts asynchronous cancellation on a
 *  long-running operation. The server makes a best effort to cancel the
 *  operation, but success is not guaranteed. Clients can use
 *  Operations.GetOperation or other methods to check whether the cancellation
 *  succeeded or whether the operation completed despite cancellation. On
 *  successful cancellation, the operation is not deleted; instead, it becomes
 *  an operation with an Operation.error value with a google.rpc.Status.code of
 *  1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/**
 *  The name of the backup being created through the copy operation. Values are
 *  of the form `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the CopyBackup operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

/**
 *  The name of the source backup that is being copied. Values are of the form
 *  `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

@end


/**
 *  The request for CopyBackup.
 */
@interface GTLRSpanner_CopyBackupRequest : GTLRObject

/**
 *  Required. The id of the backup copy. The `backup_id` appended to `parent`
 *  forms the full backup_uri of the form `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *backupId;

/**
 *  Optional. The encryption configuration used to encrypt the backup. If this
 *  field is not specified, the backup will use the same encryption
 *  configuration as the source backup by default, namely encryption_type =
 *  `USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_CopyBackupEncryptionConfig *encryptionConfig;

/**
 *  Required. The expiration time of the backup in microsecond granularity. The
 *  expiration time must be at least 6 hours and at most 366 days from the
 *  `create_time` of the source backup. Once the `expire_time` has passed, the
 *  backup is eligible to be automatically deleted by Cloud Spanner to free the
 *  resources used by the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Required. The source backup to be copied. The source backup needs to be in
 *  READY state for it to be copied. Once CopyBackup is in progress, the source
 *  backup cannot be deleted or cleaned up on expiration until CopyBackup is
 *  finished. Values are of the form: `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

@end


/**
 *  Encryption configuration for the backup to create.
 */
@interface GTLRSpanner_CreateBackupEncryptionConfig : GTLRObject

/**
 *  Required. The encryption type of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_CustomerManagedEncryption
 *        Use customer managed encryption. If specified, `kms_key_name` must
 *        contain a valid Cloud KMS key. (Value: "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_EncryptionTypeUnspecified
 *        Unspecified. Do not use. (Value: "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_GoogleDefaultEncryption
 *        Use Google default encryption. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_CreateBackupEncryptionConfig_EncryptionType_UseDatabaseEncryption
 *        Use the same encryption configuration as the database. This is the
 *        default option when encryption_config is empty. For example, if the
 *        database is using `Customer_Managed_Encryption`, the backup will be
 *        using the same Cloud KMS key as the database. (Value:
 *        "USE_DATABASE_ENCRYPTION")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Optional. This field is maintained for backwards compatibility. For new
 *  callers, we recommend using `kms_key_names` to specify the KMS key. Only use
 *  `kms_key_name` if the location of the KMS key matches the database
 *  instance's configuration (location) exactly. For example, if the KMS
 *  location is in `us-central1` or `nam3`, then the database instance must also
 *  be in `us-central1` or `nam3`. The Cloud KMS key that is used to encrypt and
 *  decrypt the restored database. Set this field only when encryption_type is
 *  `CUSTOMER_MANAGED_ENCRYPTION`. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

/**
 *  Optional. Specifies the KMS configuration for the one or more keys used to
 *  protect the backup. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`. The keys referenced by
 *  `kms_key_names` must fully cover all regions of the backup's instance
 *  configuration. Some examples: * For regional (single-region) instance
 *  configurations, specify a regional location KMS key. * For multi-region
 *  instance configurations of type `GOOGLE_MANAGED`, either specify a
 *  multi-region location KMS key or multiple regional location KMS keys that
 *  cover all regions in the instance configuration. * For an instance
 *  configuration of type `USER_MANAGED`, specify only regional location KMS
 *  keys to cover each region in the instance configuration. Multi-region
 *  location KMS keys aren't supported for `USER_MANAGED` type instance
 *  configurations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kmsKeyNames;

@end


/**
 *  Metadata type for the operation returned by CreateBackup.
 */
@interface GTLRSpanner_CreateBackupMetadata : GTLRObject

/**
 *  The time at which cancellation of this operation was received.
 *  Operations.CancelOperation starts asynchronous cancellation on a
 *  long-running operation. The server makes a best effort to cancel the
 *  operation, but success is not guaranteed. Clients can use
 *  Operations.GetOperation or other methods to check whether the cancellation
 *  succeeded or whether the operation completed despite cancellation. On
 *  successful cancellation, the operation is not deleted; instead, it becomes
 *  an operation with an Operation.error value with a google.rpc.Status.code of
 *  1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The name of the database the backup is created from. */
@property(nonatomic, copy, nullable) NSString *database;

/** The name of the backup being created. */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the CreateBackup operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

@end


/**
 *  Metadata type for the operation returned by CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseMetadata : GTLRObject

/** The database being created. */
@property(nonatomic, copy, nullable) NSString *database;

@end


/**
 *  The request for CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseRequest : GTLRObject

/**
 *  Required. A `CREATE DATABASE` statement, which specifies the ID of the new
 *  database. The database ID must conform to the regular expression
 *  `a-z*[a-z0-9]` and be between 2 and 30 characters in length. If the database
 *  ID is a reserved word or if it contains a hyphen, the database ID must be
 *  enclosed in backticks (`` ` ``).
 */
@property(nonatomic, copy, nullable) NSString *createStatement;

/**
 *  Optional. The dialect of the Cloud Spanner Database.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_DatabaseDialectUnspecified
 *        Default value. This value will create a database with the
 *        GOOGLE_STANDARD_SQL dialect. (Value: "DATABASE_DIALECT_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_GoogleStandardSql
 *        GoogleSQL supported SQL. (Value: "GOOGLE_STANDARD_SQL")
 *    @arg @c kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_Postgresql
 *        PostgreSQL supported SQL. (Value: "POSTGRESQL")
 */
@property(nonatomic, copy, nullable) NSString *databaseDialect;

/**
 *  Optional. The encryption configuration for the database. If this field is
 *  not specified, Cloud Spanner will encrypt/decrypt all data at rest using
 *  Google default encryption.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_EncryptionConfig *encryptionConfig;

/**
 *  Optional. A list of DDL statements to run inside the newly created database.
 *  Statements can create tables, indexes, etc. These statements execute
 *  atomically with the creation of the database: if there is an error in any
 *  statement, the database is not created.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *extraStatements;

/**
 *  Optional. Proto descriptors used by `CREATE/ALTER PROTO BUNDLE` statements
 *  in 'extra_statements'. Contains a protobuf-serialized
 *  [`google.protobuf.FileDescriptorSet`](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto)
 *  descriptor set. To generate it,
 *  [install](https://grpc.io/docs/protoc-installation/) and run `protoc` with
 *  --include_imports and --descriptor_set_out. For example, to generate for
 *  moon/shot/app.proto, run ``` $protoc --proto_path=/app_path
 *  --proto_path=/lib_path \\ --include_imports \\
 *  --descriptor_set_out=descriptors.data \\ moon/shot/app.proto ``` For more
 *  details, see protobuffer [self
 *  description](https://developers.google.com/protocol-buffers/docs/techniques#self-description).
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *protoDescriptors;

@end


/**
 *  Metadata type for the operation returned by CreateInstanceConfig.
 */
@interface GTLRSpanner_CreateInstanceConfigMetadata : GTLRObject

/** The time at which this operation was cancelled. */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The target instance configuration end state. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/** The progress of the CreateInstanceConfig operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceOperationProgress *progress;

@end


/**
 *  The request for CreateInstanceConfig.
 */
@interface GTLRSpanner_CreateInstanceConfigRequest : GTLRObject

/**
 *  Required. The `InstanceConfig` proto of the configuration to create.
 *  `instance_config.name` must be `/instanceConfigs/`.
 *  `instance_config.base_config` must be a Google-managed configuration name,
 *  e.g. /instanceConfigs/us-east1, /instanceConfigs/nam3.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/**
 *  Required. The ID of the instance configuration to create. Valid identifiers
 *  are of the form `custom-[-a-z0-9]*[a-z0-9]` and must be between 2 and 64
 *  characters in length. The `custom-` prefix is required to avoid name
 *  conflicts with Google-managed configurations.
 */
@property(nonatomic, copy, nullable) NSString *instanceConfigId;

/**
 *  An option to validate, but not actually execute, a request, and provide the
 *  same response.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateOnly;

@end


/**
 *  Metadata type for the operation returned by CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is guaranteed to succeed) and cannot be
 *  cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  The expected fulfillment period of this create operation.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_CreateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodExtended
 *        Extended fulfillment period. It can take up to an hour for the
 *        operation to complete. (Value: "FULFILLMENT_PERIOD_EXTENDED")
 *    @arg @c kGTLRSpanner_CreateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodNormal
 *        Normal fulfillment period. The operation is expected to complete
 *        within minutes. (Value: "FULFILLMENT_PERIOD_NORMAL")
 *    @arg @c kGTLRSpanner_CreateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodUnspecified
 *        Not specified. (Value: "FULFILLMENT_PERIOD_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *expectedFulfillmentPeriod;

/** The instance being created. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/** The time at which the CreateInstance request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Metadata type for the operation returned by CreateInstancePartition.
 */
@interface GTLRSpanner_CreateInstancePartitionMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is guaranteed to succeed) and cannot be
 *  cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The instance partition being created. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstancePartition *instancePartition;

/** The time at which the CreateInstancePartition request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for CreateInstancePartition.
 */
@interface GTLRSpanner_CreateInstancePartitionRequest : GTLRObject

/**
 *  Required. The instance partition to create. The instance_partition.name may
 *  be omitted, but if specified must be `/instancePartitions/`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstancePartition *instancePartition;

/**
 *  Required. The ID of the instance partition to create. Valid identifiers are
 *  of the form `a-z*[a-z0-9]` and must be between 2 and 64 characters in
 *  length.
 */
@property(nonatomic, copy, nullable) NSString *instancePartitionId;

@end


/**
 *  The request for CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceRequest : GTLRObject

/**
 *  Required. The instance to create. The name may be omitted, but if specified
 *  must be `/instances/`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  Required. The ID of the instance to create. Valid identifiers are of the
 *  form `a-z*[a-z0-9]` and must be between 2 and 64 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *instanceId;

@end


/**
 *  The request for CreateSession.
 */
@interface GTLRSpanner_CreateSessionRequest : GTLRObject

/** Required. The session to create. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *session;

@end


/**
 *  CrontabSpec can be used to specify the version time and frequency at which
 *  the backup is created.
 */
@interface GTLRSpanner_CrontabSpec : GTLRObject

/**
 *  Output only. Scheduled backups contain an externally consistent copy of the
 *  database at the version time specified in `schedule_spec.cron_spec`.
 *  However, Spanner might not initiate the creation of the scheduled backups at
 *  that version time. Spanner initiates the creation of scheduled backups
 *  within the time window bounded by the version_time specified in
 *  `schedule_spec.cron_spec` and version_time + `creation_window`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *creationWindow;

/**
 *  Required. Textual representation of the crontab. User can customize the
 *  backup frequency and the backup version time using the cron expression. The
 *  version time must be in UTC timezone. The backup will contain an externally
 *  consistent copy of the database at the version time. Full backups must be
 *  scheduled a minimum of 12 hours apart and incremental backups must be
 *  scheduled a minimum of 4 hours apart. Examples of valid cron specifications:
 *  * `0 2/12 * * *` : every 12 hours at (2, 14) hours past midnight in UTC. *
 *  `0 2,14 * * *` : every 12 hours at (2, 14) hours past midnight in UTC. * `0
 *  * /4 * * *` : (incremental backups only) every 4 hours at (0, 4, 8, 12, 16,
 *  20) hours past midnight in UTC. * `0 2 * * *` : once a day at 2 past
 *  midnight in UTC. * `0 2 * * 0` : once a week every Sunday at 2 past midnight
 *  in UTC. * `0 2 8 * *` : once a month on 8th day at 2 past midnight in UTC.
 */
@property(nonatomic, copy, nullable) NSString *text;

/**
 *  Output only. The time zone of the times in `CrontabSpec.text`. Currently,
 *  only UTC is supported.
 */
@property(nonatomic, copy, nullable) NSString *timeZone;

@end


/**
 *  A Cloud Spanner database.
 */
@interface GTLRSpanner_Database : GTLRObject

/**
 *  Output only. If exists, the time at which the database creation started.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The dialect of the Cloud Spanner Database.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Database_DatabaseDialect_DatabaseDialectUnspecified
 *        Default value. This value will create a database with the
 *        GOOGLE_STANDARD_SQL dialect. (Value: "DATABASE_DIALECT_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Database_DatabaseDialect_GoogleStandardSql GoogleSQL
 *        supported SQL. (Value: "GOOGLE_STANDARD_SQL")
 *    @arg @c kGTLRSpanner_Database_DatabaseDialect_Postgresql PostgreSQL
 *        supported SQL. (Value: "POSTGRESQL")
 */
@property(nonatomic, copy, nullable) NSString *databaseDialect;

/**
 *  Output only. The read-write region which contains the database's leader
 *  replicas. This is the same as the value of default_leader database option
 *  set using DatabaseAdmin.CreateDatabase or DatabaseAdmin.UpdateDatabaseDdl.
 *  If not explicitly set, this is empty.
 */
@property(nonatomic, copy, nullable) NSString *defaultLeader;

/**
 *  Output only. Earliest timestamp at which older versions of the data can be
 *  read. This value is continuously updated by Cloud Spanner and becomes stale
 *  the moment it is queried. If you are using this value to recover data, make
 *  sure to account for the time from the moment when the value is queried to
 *  the moment when you initiate the recovery.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *earliestVersionTime;

/**
 *  Optional. Whether drop protection is enabled for this database. Defaults to
 *  false, if not set. For more details, please see how to [prevent accidental
 *  database
 *  deletion](https://cloud.google.com/spanner/docs/prevent-database-deletion).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableDropProtection;

/**
 *  Output only. For databases that are using customer managed encryption, this
 *  field contains the encryption configuration for the database. For databases
 *  that are using Google default or other types of encryption, this field is
 *  empty.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_EncryptionConfig *encryptionConfig;

/**
 *  Output only. For databases that are using customer managed encryption, this
 *  field contains the encryption information for the database, such as all
 *  Cloud KMS key versions that are in use. The `encryption_status` field inside
 *  of each `EncryptionInfo` is not populated. For databases that are using
 *  Google default or other types of encryption, this field is empty. This field
 *  is propagated lazily from the backend. There might be a delay from when a
 *  key version is being used and when it appears in this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_EncryptionInfo *> *encryptionInfo;

/**
 *  Required. The name of the database. Values are of the form
 *  `projects//instances//databases/`, where `` is as specified in the `CREATE
 *  DATABASE` statement. This name can be passed to other API methods to
 *  identify the database.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Applicable only for databases that use dual-region instance
 *  configurations. Contains information about the quorum.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_QuorumInfo *quorumInfo;

/**
 *  Output only. If true, the database is being updated. If false, there are no
 *  ongoing update operations for the database.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  Output only. Applicable only for restored databases. Contains information
 *  about the restore source.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RestoreInfo *restoreInfo;

/**
 *  Output only. The current database state.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Database_State_Creating The database is still being
 *        created. Operations on the database may fail with
 *        `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Database_State_Ready The database is fully created
 *        and ready for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Database_State_ReadyOptimizing The database is fully
 *        created and ready for use, but is still being optimized for
 *        performance and cannot handle full load. In this state, the database
 *        still references the backup it was restore from, preventing the backup
 *        from being deleted. When optimizations are complete, the full
 *        performance of the database will be restored, and the database will
 *        transition to `READY` state. (Value: "READY_OPTIMIZING")
 *    @arg @c kGTLRSpanner_Database_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The period in which Cloud Spanner retains all versions of data
 *  for the database. This is the same as the value of version_retention_period
 *  database option set using UpdateDatabaseDdl. Defaults to 1 hour, if not set.
 */
@property(nonatomic, copy, nullable) NSString *versionRetentionPeriod;

@end


/**
 *  The configuration for each database in the target instance configuration.
 */
@interface GTLRSpanner_DatabaseMoveConfig : GTLRObject

/**
 *  Required. The unique identifier of the database resource in the Instance.
 *  For example, if the database uri is
 *  `projects/foo/instances/bar/databases/baz`, then the id to supply here is
 *  baz.
 */
@property(nonatomic, copy, nullable) NSString *databaseId;

/**
 *  Optional. Encryption configuration to be used for the database in the target
 *  configuration. The encryption configuration must be specified for every
 *  database which currently uses CMEK encryption. If a database currently uses
 *  Google-managed encryption and a target encryption configuration is not
 *  specified, then the database defaults to Google-managed encryption. If a
 *  database currently uses Google-managed encryption and a target CMEK
 *  encryption is specified, the request is rejected. If a database currently
 *  uses CMEK encryption, then a target encryption configuration must be
 *  specified. You can't move a CMEK database to a Google-managed encryption
 *  database using the MoveInstance API.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceEncryptionConfig *encryptionConfig;

@end


/**
 *  A Cloud Spanner database role.
 */
@interface GTLRSpanner_DatabaseRole : GTLRObject

/**
 *  Required. The name of the database role. Values are of the form
 *  `projects//instances//databases//databaseRoles/` where `` is as specified in
 *  the `CREATE ROLE` DDL statement.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A data change record contains a set of changes to a table with the same
 *  modification type (insert, update, or delete) committed at the same commit
 *  timestamp in one change stream partition for the same transaction. Multiple
 *  data change records can be returned for the same transaction across multiple
 *  change stream partitions.
 */
@interface GTLRSpanner_DataChangeRecord : GTLRObject

/**
 *  Provides metadata describing the columns associated with the mods listed
 *  below.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ColumnMetadata *> *columnMetadata;

/**
 *  Indicates the timestamp in which the change was committed.
 *  DataChangeRecord.commit_timestamps, PartitionStartRecord.start_timestamps,
 *  PartitionEventRecord.commit_timestamps, and
 *  PartitionEndRecord.end_timestamps can have the same value in the same
 *  partition.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

/**
 *  Indicates whether this is the last record for a transaction in the current
 *  partition. Clients can use this field to determine when all records for a
 *  transaction in the current partition have been received.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isLastRecordInTransactionInPartition;

/**
 *  Indicates whether the transaction is a system transaction. System
 *  transactions include those issued by time-to-live (TTL), column backfill,
 *  etc.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isSystemTransaction;

/** Describes the changes that were made. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Mod *> *mods;

/**
 *  Describes the type of change.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_DataChangeRecord_ModType_Delete Indicates existing
 *        data was deleted. (Value: "DELETE")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ModType_Insert Indicates data was
 *        inserted. (Value: "INSERT")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ModType_ModTypeUnspecified Not
 *        specified. (Value: "MOD_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ModType_Update Indicates existing
 *        data was updated. (Value: "UPDATE")
 */
@property(nonatomic, copy, nullable) NSString *modType;

/**
 *  Indicates the number of partitions that return data change records for this
 *  transaction. This value can be helpful in assembling all records associated
 *  with a particular transaction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numberOfPartitionsInTransaction;

/**
 *  Indicates the number of data change records that are part of this
 *  transaction across all change stream partitions. This value can be used to
 *  assemble all the records associated with a particular transaction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numberOfRecordsInTransaction;

/**
 *  Record sequence numbers are unique and monotonically increasing (but not
 *  necessarily contiguous) for a specific timestamp across record types in the
 *  same partition. To guarantee ordered processing, the reader should process
 *  records (of potentially different types) in record_sequence order for a
 *  specific timestamp in the same partition. The record sequence number
 *  ordering across partitions is only meaningful in the context of a specific
 *  transaction. Record sequence numbers are unique across partitions for a
 *  specific transaction. Sort the DataChangeRecords for the same
 *  server_transaction_id by record_sequence to reconstruct the ordering of the
 *  changes within the transaction.
 */
@property(nonatomic, copy, nullable) NSString *recordSequence;

/**
 *  Provides a globally unique string that represents the transaction in which
 *  the change was committed. Multiple transactions can have the same commit
 *  timestamp, but each transaction has a unique server_transaction_id.
 */
@property(nonatomic, copy, nullable) NSString *serverTransactionId;

/** Name of the table affected by the change. */
@property(nonatomic, copy, nullable) NSString *table;

/** Indicates the transaction tag associated with this transaction. */
@property(nonatomic, copy, nullable) NSString *transactionTag;

/**
 *  Describes the value capture type that was specified in the change stream
 *  configuration when this change was captured.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_DataChangeRecord_ValueCaptureType_NewRow Records new
 *        values of all watched columns, including modified and unmodified
 *        columns. (Value: "NEW_ROW")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ValueCaptureType_NewRowAndOldValues
 *        Records the new values of all watched columns, including modified and
 *        unmodified columns. Also records the old values of the modified
 *        columns. (Value: "NEW_ROW_AND_OLD_VALUES")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ValueCaptureType_NewValues Records
 *        only new values of the modified watched columns. (Value: "NEW_VALUES")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ValueCaptureType_OldAndNewValues
 *        Records both old and new values of the modified watched columns.
 *        (Value: "OLD_AND_NEW_VALUES")
 *    @arg @c kGTLRSpanner_DataChangeRecord_ValueCaptureType_ValueCaptureTypeUnspecified
 *        Not specified. (Value: "VALUE_CAPTURE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueCaptureType;

@end


/**
 *  Action information extracted from a DDL statement. This proto is used to
 *  display the brief info of the DDL statement for the operation
 *  UpdateDatabaseDdl.
 */
@interface GTLRSpanner_DdlStatementActionInfo : GTLRObject

/**
 *  The action for the DDL statement, for example, CREATE, ALTER, DROP, GRANT,
 *  etc. This field is a non-empty string.
 */
@property(nonatomic, copy, nullable) NSString *action;

/**
 *  The entity names being operated on the DDL statement. For example, 1. For
 *  statement "CREATE TABLE t1(...)", `entity_names` = ["t1"]. 2. For statement
 *  "GRANT ROLE r1, r2 ...", `entity_names` = ["r1", "r2"]. 3. For statement
 *  "ANALYZE", `entity_names` = [].
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *entityNames;

/**
 *  The entity type for the DDL statement, for example, TABLE, INDEX, VIEW, etc.
 *  This field can be empty string for some DDL statement, for example, for
 *  statement "ANALYZE", `entity_type` = "".
 */
@property(nonatomic, copy, nullable) NSString *entityType;

@end


/**
 *  Arguments to delete operations.
 */
@interface GTLRSpanner_Delete : GTLRObject

/**
 *  Required. The primary keys of the rows within table to delete. The primary
 *  keys must be specified in the order in which they appear in the `PRIMARY
 *  KEY()` clause of the table's equivalent DDL statement (the DDL statement
 *  used to create the table). Delete is idempotent. The transaction will
 *  succeed even if some or all rows do not exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Required. The table whose rows will be deleted. */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  A message representing a derived metric.
 */
@interface GTLRSpanner_DerivedMetric : GTLRObject

/** The name of the denominator metric. e.g. "rows". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *denominator;

/** The name of the numerator metric. e.g. "latency". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *numerator;

@end


/**
 *  A message representing the key visualizer diagnostic messages.
 */
@interface GTLRSpanner_DiagnosticMessage : GTLRObject

/** Information about this diagnostic information. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *info;

/** The metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *metric;

/**
 *  Whether this message is specific only for the current metric. By default
 *  Diagnostics are shown for all metrics, regardless which metric is the
 *  currently selected metric in the UI. However occasionally a metric will
 *  generate so many messages that the resulting visual clutter becomes
 *  overwhelming. In this case setting this to true, will show the diagnostic
 *  messages for that metric only if it is the currently selected metric.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *metricSpecific;

/**
 *  The severity of the diagnostic message.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Error Severity level
 *        signaling an error "Error" (Value: "ERROR")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Fatal Severity level
 *        signaling a non recoverable error "Fatal" (Value: "FATAL")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Info Lowest severity level
 *        "Info". (Value: "INFO")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_SeverityUnspecified
 *        Required default value. (Value: "SEVERITY_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Warning Middle severity
 *        level "Warning". (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** The short message. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *shortMessage;

@end


/**
 *  The `DirectedReadOptions` can be used to indicate which replicas or regions
 *  should be used for non-transactional reads or queries. `DirectedReadOptions`
 *  can only be specified for a read-only transaction, otherwise the API returns
 *  an `INVALID_ARGUMENT` error.
 */
@interface GTLRSpanner_DirectedReadOptions : GTLRObject

/**
 *  `Exclude_replicas` indicates that specified replicas should be excluded from
 *  serving requests. Spanner doesn't route requests to the replicas in this
 *  list.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExcludeReplicas *excludeReplicas;

/**
 *  `Include_replicas` indicates the order of replicas (as they appear in this
 *  list) to process the request. If `auto_failover_disabled` is set to `true`
 *  and all replicas are exhausted without finding a healthy replica, Spanner
 *  waits for a replica in the list to become available, requests might fail due
 *  to `DEADLINE_EXCEEDED` errors.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_IncludeReplicas *includeReplicas;

@end


/**
 *  Message type for a dual-region quorum. Currently this type has no options.
 */
@interface GTLRSpanner_DualRegionQuorum : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRSpanner_Empty : GTLRObject
@end


/**
 *  Encryption configuration for a Cloud Spanner database.
 */
@interface GTLRSpanner_EncryptionConfig : GTLRObject

/**
 *  The Cloud KMS key to be used for encrypting and decrypting the database.
 *  Values are of the form `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

/**
 *  Specifies the KMS configuration for one or more keys used to encrypt the
 *  database. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`. The keys referenced by
 *  `kms_key_names` must fully cover all regions of the database's instance
 *  configuration. Some examples: * For regional (single-region) instance
 *  configurations, specify a regional location KMS key. * For multi-region
 *  instance configurations of type `GOOGLE_MANAGED`, either specify a
 *  multi-region location KMS key or multiple regional location KMS keys that
 *  cover all regions in the instance configuration. * For an instance
 *  configuration of type `USER_MANAGED`, specify only regional location KMS
 *  keys to cover each region in the instance configuration. Multi-region
 *  location KMS keys aren't supported for `USER_MANAGED` type instance
 *  configurations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kmsKeyNames;

@end


/**
 *  Encryption information for a Cloud Spanner database or backup.
 */
@interface GTLRSpanner_EncryptionInfo : GTLRObject

/**
 *  Output only. If present, the status of a recent encrypt/decrypt call on
 *  underlying data for this database or backup. Regardless of status, data is
 *  always encrypted at rest.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *encryptionStatus;

/**
 *  Output only. The type of encryption.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_EncryptionInfo_EncryptionType_CustomerManagedEncryption
 *        The data is encrypted at rest with a key that is managed by the
 *        customer. The active version of the key. `kms_key_version` will be
 *        populated, and `encryption_status` may be populated. (Value:
 *        "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_EncryptionInfo_EncryptionType_GoogleDefaultEncryption
 *        The data is encrypted at rest with a key that is fully managed by
 *        Google. No key version or status will be populated. This is the
 *        default state. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_EncryptionInfo_EncryptionType_TypeUnspecified
 *        Encryption type was not specified, though data at rest remains
 *        encrypted. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Output only. A Cloud KMS key version that is being used to protect the
 *  database or backup.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyVersion;

@end


/**
 *  An ExcludeReplicas contains a repeated set of ReplicaSelection that should
 *  be excluded from serving requests.
 */
@interface GTLRSpanner_ExcludeReplicas : GTLRObject

/** The directed read replica selector. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaSelection *> *replicaSelections;

@end


/**
 *  The request for ExecuteBatchDml.
 */
@interface GTLRSpanner_ExecuteBatchDmlRequest : GTLRObject

/**
 *  Optional. If set to `true`, this request marks the end of the transaction.
 *  After these statements execute, you must commit or abort the transaction.
 *  Attempts to execute any other requests against this transaction (including
 *  reads and queries) are rejected. Setting this option might cause some error
 *  reporting to be deferred until commit time (for example, validation of
 *  unique constraints). Given this, successful execution of statements
 *  shouldn't be assumed until a subsequent `Commit` call completes
 *  successfully.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lastStatements;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  Required. A per-transaction sequence number used to identify this request.
 *  This field makes each request idempotent such that if the request is
 *  received multiple times, at most one succeeds. The sequence number must be
 *  monotonically increasing within the transaction. If a request arrives for
 *  the first time with an out-of-order sequence number, the transaction might
 *  be aborted. Replays of previously handled requests yield the same response
 *  as the first execution.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/**
 *  Required. The list of statements to execute in this batch. Statements are
 *  executed serially, such that the effects of statement `i` are visible to
 *  statement `i+1`. Each statement must be a DML statement. Execution stops at
 *  the first failed statement; the remaining statements are not executed.
 *  Callers must provide at least one statement.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Statement *> *statements;

/**
 *  Required. The transaction to use. Must be a read-write transaction. To
 *  protect against replays, single-use transactions are not supported. The
 *  caller must either supply an existing transaction ID or begin a new
 *  transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for ExecuteBatchDml. Contains a list of ResultSet messages, one
 *  for each DML statement that has successfully executed, in the same order as
 *  the statements in the request. If a statement fails, the status in the
 *  response body identifies the cause of the failure. To check for DML
 *  statements that failed, use the following approach: 1. Check the status in
 *  the response message. The google.rpc.Code enum value `OK` indicates that all
 *  statements were executed successfully. 2. If the status was not `OK`, check
 *  the number of result sets in the response. If the response contains `N`
 *  ResultSet messages, then statement `N+1` in the request failed. Example 1: *
 *  Request: 5 DML statements, all executed successfully. * Response: 5
 *  ResultSet messages, with the status `OK`. Example 2: * Request: 5 DML
 *  statements. The third statement has a syntax error. * Response: 2 ResultSet
 *  messages, and a syntax error (`INVALID_ARGUMENT`) status. The number of
 *  ResultSet messages indicates that the third statement failed, and the fourth
 *  and fifth statements were not executed.
 */
@interface GTLRSpanner_ExecuteBatchDmlResponse : GTLRObject

/**
 *  Optional. A precommit token is included if the read-write transaction is on
 *  a multiplexed session. Pass the precommit token with the highest sequence
 *  number from this transaction attempt should be passed to the Commit request
 *  for this transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_MultiplexedSessionPrecommitToken *precommitToken;

/**
 *  One ResultSet for each statement in the request that ran successfully, in
 *  the same order as the statements in the request. Each ResultSet does not
 *  contain any rows. The ResultSetStats in each ResultSet contain the number of
 *  rows modified by the statement. Only the first ResultSet in the response
 *  contains valid ResultSetMetadata.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ResultSet *> *resultSets;

/**
 *  If all DML statements are executed successfully, the status is `OK`.
 *  Otherwise, the error status of the first failed statement.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *status;

@end


/**
 *  The request for ExecuteSql and ExecuteStreamingSql.
 */
@interface GTLRSpanner_ExecuteSqlRequest : GTLRObject

/**
 *  If this is for a partitioned query and this field is set to `true`, the
 *  request is executed with Spanner Data Boost independent compute resources.
 *  If the field is set to `true` but the request doesn't set `partition_token`,
 *  the API returns an `INVALID_ARGUMENT` error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataBoostEnabled;

/** Directed read options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_DirectedReadOptions *directedReadOptions;

/**
 *  Optional. If set to `true`, this statement marks the end of the transaction.
 *  After this statement executes, you must commit or abort the transaction.
 *  Attempts to execute any other requests against this transaction (including
 *  reads and queries) are rejected. For DML statements, setting this option
 *  might cause some error reporting to be deferred until commit time (for
 *  example, validation of unique constraints). Given this, successful execution
 *  of a DML statement shouldn't be assumed until a subsequent `Commit` call
 *  completes successfully.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lastStatement;

/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names must conform to
 *  the naming requirements of identifiers as specified at
 *  https://cloud.google.com/spanner/docs/lexical#identifiers. Parameters can
 *  appear anywhere that a literal value is expected. The same parameter name
 *  can be used more than once, for example: `"WHERE id > \@msg_id AND id <
 *  \@msg_id + 100"` It's an error to execute a SQL statement with unbound
 *  parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_Params *params;

/**
 *  It isn't always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases, you can use
 *  `param_types` to specify the exact SQL type for some or all of the SQL
 *  statement parameters. See the definition of Type for more information about
 *  SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_ParamTypes *paramTypes;

/**
 *  If present, results are restricted to the specified partition previously
 *  created using `PartitionQuery`. There must be an exact match for the values
 *  of fields common to this message and the `PartitionQueryRequest` message
 *  used to create this `partition_token`.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  Used to control the amount of debugging information returned in
 *  ResultSetStats. If partition_token is set, query_mode can only be set to
 *  QueryMode.NORMAL.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal The default mode.
 *        Only the statement results are returned. (Value: "NORMAL")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan This mode returns
 *        only the query plan, without any results or execution statistics
 *        information. (Value: "PLAN")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile This mode returns
 *        the query plan, overall execution statistics, operator level execution
 *        statistics along with the results. This has a performance overhead
 *        compared to the other modes. It isn't recommended to use this mode for
 *        production traffic. (Value: "PROFILE")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_WithPlanAndStats This
 *        mode returns the query plan, overall (but not operator-level)
 *        execution statistics along with the results. (Value:
 *        "WITH_PLAN_AND_STATS")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_WithStats This mode
 *        returns the overall (but not operator-level) execution statistics
 *        along with the results. (Value: "WITH_STATS")
 */
@property(nonatomic, copy, nullable) NSString *queryMode;

/** Query optimizer configuration to use for the given query. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryOptions *queryOptions;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  If this request is resuming a previously interrupted SQL statement
 *  execution, `resume_token` should be copied from the last PartialResultSet
 *  yielded before the interruption. Doing this enables the new SQL statement
 *  execution to resume where the last one left off. The rest of the request
 *  parameters must exactly match the request that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  A per-transaction sequence number used to identify this request. This field
 *  makes each request idempotent such that if the request is received multiple
 *  times, at most one succeeds. The sequence number must be monotonically
 *  increasing within the transaction. If a request arrives for the first time
 *  with an out-of-order sequence number, the transaction can be aborted.
 *  Replays of previously handled requests yield the same response as the first
 *  execution. Required for DML statements. Ignored for queries.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/** Required. The SQL string. */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  The transaction to use. For queries, if none is provided, the default is a
 *  temporary read-only transaction with strong concurrency. Standard DML
 *  statements require a read-write transaction. To protect against replays,
 *  single-use transactions are not supported. The caller must either supply an
 *  existing transaction ID or begin a new transaction. Partitioned DML requires
 *  an existing Partitioned DML transaction ID.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names must conform to
 *  the naming requirements of identifiers as specified at
 *  https://cloud.google.com/spanner/docs/lexical#identifiers. Parameters can
 *  appear anywhere that a literal value is expected. The same parameter name
 *  can be used more than once, for example: `"WHERE id > \@msg_id AND id <
 *  \@msg_id + 100"` It's an error to execute a SQL statement with unbound
 *  parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_Params : GTLRObject
@end


/**
 *  It isn't always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases, you can use
 *  `param_types` to specify the exact SQL type for some or all of the SQL
 *  statement parameters. See the definition of Type for more information about
 *  SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_ParamTypes : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRSpanner_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Message representing a single field of a struct.
 */
@interface GTLRSpanner_Field : GTLRObject

/**
 *  The name of the field. For reads, this is the column name. For SQL queries,
 *  it is the column alias (e.g., `"Word"` in the query `"SELECT 'hello' AS
 *  Word"`), or the column name (e.g., `"ColName"` in the query `"SELECT ColName
 *  FROM Table"`). Some columns might have an empty name (e.g., `"SELECT
 *  UPPER(ColName)"`). Note that a query result can contain multiple fields with
 *  the same name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The type of the field. */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *type;

@end


/**
 *  Free instance specific metadata that is kept even after an instance has been
 *  upgraded for tracking purposes.
 */
@interface GTLRSpanner_FreeInstanceMetadata : GTLRObject

/**
 *  Specifies the expiration behavior of a free instance. The default of
 *  ExpireBehavior is `REMOVE_AFTER_GRACE_PERIOD`. This can be modified during
 *  or after creation, and before expiration.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_ExpireBehaviorUnspecified
 *        Not specified. (Value: "EXPIRE_BEHAVIOR_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_FreeToProvisioned
 *        When the free instance expires, upgrade the instance to a provisioned
 *        instance. (Value: "FREE_TO_PROVISIONED")
 *    @arg @c kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_RemoveAfterGracePeriod
 *        When the free instance expires, disable the instance, and delete it
 *        after the grace period passes if it has not been upgraded. (Value:
 *        "REMOVE_AFTER_GRACE_PERIOD")
 */
@property(nonatomic, copy, nullable) NSString *expireBehavior;

/**
 *  Output only. Timestamp after which the instance will either be upgraded or
 *  scheduled for deletion after a grace period. ExpireBehavior is used to
 *  choose between upgrading or scheduling the free instance for deletion. This
 *  timestamp is set during the creation of a free instance.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Output only. If present, the timestamp at which the free instance was
 *  upgraded to a provisioned instance.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *upgradeTime;

@end


/**
 *  The specification for full backups. A full backup stores the entire contents
 *  of the database at a given version time.
 */
@interface GTLRSpanner_FullBackupSpec : GTLRObject
@end


/**
 *  The response for GetDatabaseDdl.
 */
@interface GTLRSpanner_GetDatabaseDdlResponse : GTLRObject

/**
 *  Proto descriptors stored in the database. Contains a protobuf-serialized
 *  [google.protobuf.FileDescriptorSet](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto).
 *  For more details, see protobuffer [self
 *  description](https://developers.google.com/protocol-buffers/docs/techniques#self-description).
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *protoDescriptors;

/**
 *  A list of formatted DDL statements defining the schema of the database
 *  specified in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRSpanner_GetIamPolicyRequest : GTLRObject

/**
 *  OPTIONAL: A `GetPolicyOptions` object for specifying options to
 *  `GetIamPolicy`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_GetPolicyOptions *options;

@end


/**
 *  Encapsulates settings provided to GetIamPolicy.
 */
@interface GTLRSpanner_GetPolicyOptions : GTLRObject

/**
 *  Optional. The maximum policy version that will be used to format the policy.
 *  Valid values are 0, 1, and 3. Requests specifying an invalid value will be
 *  rejected. Requests for policies with any conditional role bindings must
 *  specify version 3. Policies with no conditional role bindings may specify
 *  any valid value or leave the field unset. The policy in the response might
 *  use the policy version that you specified, or it might use a lower policy
 *  version. For example, if you specify version 3, but the policy has no
 *  conditional role bindings, the response uses version 1. To learn which
 *  resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedPolicyVersion;

@end


/**
 *  A heartbeat record is returned as a progress indicator, when there are no
 *  data changes or any other partition record types in the change stream
 *  partition.
 */
@interface GTLRSpanner_HeartbeatRecord : GTLRObject

/**
 *  Indicates the timestamp at which the query has returned all the records in
 *  the change stream partition with timestamp <= heartbeat timestamp. The
 *  heartbeat timestamp will not be the same as the timestamps of other record
 *  types in the same partition.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

@end


/**
 *  An `IncludeReplicas` contains a repeated set of `ReplicaSelection` which
 *  indicates the order in which replicas should be considered.
 */
@interface GTLRSpanner_IncludeReplicas : GTLRObject

/**
 *  If `true`, Spanner doesn't route requests to a replica outside the
 *  <`include_replicas` list when all of the specified replicas are unavailable
 *  or unhealthy. Default value is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoFailoverDisabled;

/** The directed read replica selector. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaSelection *> *replicaSelections;

@end


/**
 *  The specification for incremental backup chains. An incremental backup
 *  stores the delta of changes between a previous backup and the database
 *  contents at a given version time. An incremental backup chain consists of a
 *  full backup and zero or more successive incremental backups. The first
 *  backup created for an incremental backup chain is always a full backup.
 */
@interface GTLRSpanner_IncrementalBackupSpec : GTLRObject
@end


/**
 *  Recommendation to add new indexes to run queries more efficiently.
 */
@interface GTLRSpanner_IndexAdvice : GTLRObject

/**
 *  Optional. DDL statements to add new indexes that will improve the query.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ddl;

/**
 *  Optional. Estimated latency improvement factor. For example if the query
 *  currently takes 500 ms to run and the estimated latency with new indexes is
 *  100 ms this field will be 5.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *improvementFactor;

@end


/**
 *  A message representing a (sparse) collection of hot keys for specific key
 *  buckets.
 */
@interface GTLRSpanner_IndexedHotKey : GTLRObject

/**
 *  A (sparse) mapping from key bucket index to the index of the specific hot
 *  row key for that key bucket. The index of the hot row key can be translated
 *  to the actual row key via the ScanData.VisualizationData.indexed_keys
 *  repeated field.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_IndexedHotKey_SparseHotKeys *sparseHotKeys;

@end


/**
 *  A (sparse) mapping from key bucket index to the index of the specific hot
 *  row key for that key bucket. The index of the hot row key can be translated
 *  to the actual row key via the ScanData.VisualizationData.indexed_keys
 *  repeated field.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_IndexedHotKey_SparseHotKeys : GTLRObject
@end


/**
 *  A message representing a (sparse) collection of KeyRangeInfos for specific
 *  key buckets.
 */
@interface GTLRSpanner_IndexedKeyRangeInfos : GTLRObject

/**
 *  A (sparse) mapping from key bucket index to the KeyRangeInfos for that key
 *  bucket.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_IndexedKeyRangeInfos_KeyRangeInfos *keyRangeInfos;

@end


/**
 *  A (sparse) mapping from key bucket index to the KeyRangeInfos for that key
 *  bucket.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_KeyRangeInfos. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_IndexedKeyRangeInfos_KeyRangeInfos : GTLRObject
@end


/**
 *  An isolated set of Cloud Spanner resources on which databases can be hosted.
 */
@interface GTLRSpanner_Instance : GTLRObject

/**
 *  Optional. The autoscaling configuration. Autoscaling is enabled if this
 *  field is set. When autoscaling is enabled, node_count and processing_units
 *  are treated as OUTPUT_ONLY fields and reflect the current compute capacity
 *  allocated to the instance.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_AutoscalingConfig *autoscalingConfig;

/**
 *  Required. The name of the instance's configuration. Values are of the form
 *  `projects//instanceConfigs/`. See also InstanceConfig and
 *  ListInstanceConfigs.
 */
@property(nonatomic, copy, nullable) NSString *config;

/** Output only. The time at which the instance was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. Controls the default backup schedule behavior for new databases
 *  within the instance. By default, a backup schedule is created automatically
 *  when a new database is created in a new instance. Note that the `AUTOMATIC`
 *  value isn't permitted for free instances, as backups and backup schedules
 *  aren't supported for free instances. In the `GetInstance` or `ListInstances`
 *  response, if the value of `default_backup_schedule_type` isn't set, or set
 *  to `NONE`, Spanner doesn't create a default backup schedule for new
 *  databases in the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_DefaultBackupScheduleType_Automatic A
 *        default backup schedule is created automatically when a new database
 *        is created in the instance. The default backup schedule creates a full
 *        backup every 24 hours. These full backups are retained for 7 days. You
 *        can edit or delete the default backup schedule once it's created.
 *        (Value: "AUTOMATIC")
 *    @arg @c kGTLRSpanner_Instance_DefaultBackupScheduleType_DefaultBackupScheduleTypeUnspecified
 *        Not specified. (Value: "DEFAULT_BACKUP_SCHEDULE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Instance_DefaultBackupScheduleType_None A default
 *        backup schedule isn't created automatically when a new database is
 *        created in the instance. (Value: "NONE")
 */
@property(nonatomic, copy, nullable) NSString *defaultBackupScheduleType;

/**
 *  Required. The descriptive name for this instance as it appears in UIs. Must
 *  be unique per project and between 4 and 30 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Optional. The `Edition` of the current instance.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_Edition_EditionUnspecified Edition not
 *        specified. (Value: "EDITION_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Instance_Edition_Enterprise Enterprise edition.
 *        (Value: "ENTERPRISE")
 *    @arg @c kGTLRSpanner_Instance_Edition_EnterprisePlus Enterprise Plus
 *        edition. (Value: "ENTERPRISE_PLUS")
 *    @arg @c kGTLRSpanner_Instance_Edition_Standard Standard edition. (Value:
 *        "STANDARD")
 */
@property(nonatomic, copy, nullable) NSString *edition;

/** Deprecated. This field is not populated. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *endpointUris;

/** Free instance metadata. Only populated for free instances. */
@property(nonatomic, strong, nullable) GTLRSpanner_FreeInstanceMetadata *freeInstanceMetadata;

/**
 *  The `InstanceType` of the current instance.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_InstanceType_FreeInstance Free instances
 *        provide no guarantee for dedicated resources, [node_count,
 *        processing_units] should be 0. They come with stricter usage limits
 *        and limited support. (Value: "FREE_INSTANCE")
 *    @arg @c kGTLRSpanner_Instance_InstanceType_InstanceTypeUnspecified Not
 *        specified. (Value: "INSTANCE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Instance_InstanceType_Provisioned Provisioned
 *        instances have dedicated resources, standard usage limits and support.
 *        (Value: "PROVISIONED")
 */
@property(nonatomic, copy, nullable) NSString *instanceType;

/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. And so you are advised to use an internal label representation, such
 *  as JSON, which doesn't rely upon specific characters being disallowed. For
 *  example, representing labels as the string: name + "_" + value would prove
 *  problematic if we were to allow "_" in a future release.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance_Labels *labels;

/**
 *  Required. A unique identifier for the instance, which cannot be changed
 *  after the instance is created. Values are of the form
 *  `projects//instances/a-z*[a-z0-9]`. The final segment of the name must be
 *  between 2 and 64 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The number of nodes allocated to this instance. At most, one of either
 *  `node_count` or `processing_units` should be present in the message. Users
 *  can set the `node_count` field to specify the target number of nodes
 *  allocated to the instance. If autoscaling is enabled, `node_count` is
 *  treated as an `OUTPUT_ONLY` field and reflects the current number of nodes
 *  allocated to the instance. This might be zero in API responses for instances
 *  that are not yet in the `READY` state. If the instance has varying node
 *  count across replicas (achieved by setting `asymmetric_autoscaling_options`
 *  in the autoscaling configuration), the `node_count` set here is the maximum
 *  node count across all replicas. For more information, see [Compute capacity,
 *  nodes, and processing
 *  units](https://cloud.google.com/spanner/docs/compute-capacity).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  The number of processing units allocated to this instance. At most, one of
 *  either `processing_units` or `node_count` should be present in the message.
 *  Users can set the `processing_units` field to specify the target number of
 *  processing units allocated to the instance. If autoscaling is enabled,
 *  `processing_units` is treated as an `OUTPUT_ONLY` field and reflects the
 *  current number of processing units allocated to the instance. This might be
 *  zero in API responses for instances that are not yet in the `READY` state.
 *  If the instance has varying processing units per replica (achieved by
 *  setting `asymmetric_autoscaling_options` in the autoscaling configuration),
 *  the `processing_units` set here is the maximum processing units across all
 *  replicas. For more information, see [Compute capacity, nodes and processing
 *  units](https://cloud.google.com/spanner/docs/compute-capacity).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *processingUnits;

/**
 *  Output only. Lists the compute capacity per ReplicaSelection. A replica
 *  selection identifies a set of replicas with common properties. Replicas
 *  identified by a ReplicaSelection are scaled with the same compute capacity.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaComputeCapacity *> *replicaComputeCapacity;

/**
 *  Output only. The current instance state. For CreateInstance, the state must
 *  be either omitted or set to `CREATING`. For UpdateInstance, the state must
 *  be either omitted or set to `READY`.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_State_Creating The instance is still being
 *        created. Resources may not be available yet, and operations such as
 *        database creation may not work. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Instance_State_Ready The instance is fully created
 *        and ready to do work such as creating databases. (Value: "READY")
 *    @arg @c kGTLRSpanner_Instance_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The time at which the instance was most recently updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. And so you are advised to use an internal label representation, such
 *  as JSON, which doesn't rely upon specific characters being disallowed. For
 *  example, representing labels as the string: name + "_" + value would prove
 *  problematic if we were to allow "_" in a future release.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Instance_Labels : GTLRObject
@end


/**
 *  A possible configuration for a Cloud Spanner instance. Configurations define
 *  the geographic placement of nodes and their replication.
 */
@interface GTLRSpanner_InstanceConfig : GTLRObject

/**
 *  Base configuration name, e.g. projects//instanceConfigs/nam3, based on which
 *  this configuration is created. Only set for user-managed configurations.
 *  `base_config` must refer to a configuration of type `GOOGLE_MANAGED` in the
 *  same project as this configuration.
 */
@property(nonatomic, copy, nullable) NSString *baseConfig;

/**
 *  Output only. Whether this instance configuration is a Google-managed or
 *  user-managed configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_ConfigType_GoogleManaged
 *        Google-managed configuration. (Value: "GOOGLE_MANAGED")
 *    @arg @c kGTLRSpanner_InstanceConfig_ConfigType_TypeUnspecified
 *        Unspecified. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_InstanceConfig_ConfigType_UserManaged User-managed
 *        configuration. (Value: "USER_MANAGED")
 */
@property(nonatomic, copy, nullable) NSString *configType;

/** The name of this instance configuration as it appears in UIs. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  etag is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a instance configuration from overwriting each
 *  other. It is strongly suggested that systems make use of the etag in the
 *  read-modify-write cycle to perform instance configuration updates in order
 *  to avoid race conditions: An etag is returned in the response which contains
 *  instance configurations, and systems are expected to put that etag in the
 *  request to update instance configuration to ensure that their change is
 *  applied to the same version of the instance configuration. If no etag is
 *  provided in the call to update the instance configuration, then the existing
 *  instance configuration is overwritten blindly.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. Describes whether free instances are available to be created in
 *  this instance configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Available
 *        Indicates that free instances are available to be created in this
 *        instance configuration. (Value: "AVAILABLE")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Disabled
 *        Indicates that free instances are currently not available to be
 *        created in this instance configuration. (Value: "DISABLED")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_FreeInstanceAvailabilityUnspecified
 *        Not specified. (Value: "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_QuotaExceeded
 *        Indicates that additional free instances cannot be created in this
 *        instance configuration because the project has reached its limit of
 *        free instances. (Value: "QUOTA_EXCEEDED")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Unsupported
 *        Indicates that free instances are not supported in this instance
 *        configuration. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *freeInstanceAvailability;

/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. Therefore, you are advised to use an internal label representation,
 *  such as JSON, which doesn't rely upon specific characters being disallowed.
 *  For example, representing labels as the string: name + "_" + value would
 *  prove problematic if we were to allow "_" in a future release.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig_Labels *labels;

/**
 *  Allowed values of the "default_leader" schema option for databases in
 *  instances that use this instance configuration.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *leaderOptions;

/**
 *  A unique identifier for the instance configuration. Values are of the form
 *  `projects//instanceConfigs/a-z*`. User instance configuration must start
 *  with `custom-`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The available optional replicas to choose from for user-managed
 *  configurations. Populated for Google-managed configurations.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaInfo *> *optionalReplicas;

/**
 *  Output only. The `QuorumType` of the instance configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_QuorumType_DualRegion An instance
 *        configuration tagged with the `DUAL_REGION` quorum type forms a write
 *        quorum with exactly two read-write regions in a multi-region
 *        configuration. This instance configuration requires failover in the
 *        event of regional failures. (Value: "DUAL_REGION")
 *    @arg @c kGTLRSpanner_InstanceConfig_QuorumType_MultiRegion An instance
 *        configuration tagged with the `MULTI_REGION` quorum type forms a write
 *        quorum from replicas that are spread across more than one region in a
 *        multi-region configuration. (Value: "MULTI_REGION")
 *    @arg @c kGTLRSpanner_InstanceConfig_QuorumType_QuorumTypeUnspecified
 *        Quorum type not specified. (Value: "QUORUM_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_InstanceConfig_QuorumType_Region An instance
 *        configuration tagged with `REGION` quorum type forms a write quorum in
 *        a single region. (Value: "REGION")
 */
@property(nonatomic, copy, nullable) NSString *quorumType;

/**
 *  Output only. If true, the instance configuration is being created or
 *  updated. If false, there are no ongoing operations for the instance
 *  configuration.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  The geographic placement of nodes in this instance configuration and their
 *  replication properties. To create user-managed configurations, input
 *  `replicas` must include all replicas in `replicas` of the `base_config` and
 *  include one or more replicas in the `optional_replicas` of the
 *  `base_config`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaInfo *> *replicas;

/**
 *  Output only. The current instance configuration state. Applicable only for
 *  `USER_MANAGED` configurations.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_State_Creating The instance
 *        configuration is still being created. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_InstanceConfig_State_Ready The instance configuration
 *        is fully created and ready to be used to create instances. (Value:
 *        "READY")
 *    @arg @c kGTLRSpanner_InstanceConfig_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The storage limit in bytes per processing unit.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *storageLimitPerProcessingUnit;

@end


/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. Therefore, you are advised to use an internal label representation,
 *  such as JSON, which doesn't rely upon specific characters being disallowed.
 *  For example, representing labels as the string: name + "_" + value would
 *  prove problematic if we were to allow "_" in a future release.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_InstanceConfig_Labels : GTLRObject
@end


/**
 *  Encryption configuration for a Cloud Spanner database.
 */
@interface GTLRSpanner_InstanceEncryptionConfig : GTLRObject

/**
 *  Optional. This field is maintained for backwards compatibility. For new
 *  callers, we recommend using `kms_key_names` to specify the KMS key. Only use
 *  `kms_key_name` if the location of the KMS key matches the database
 *  instance's configuration (location) exactly. For example, if the KMS
 *  location is in `us-central1` or `nam3`, then the database instance must also
 *  be in `us-central1` or `nam3`. The Cloud KMS key that is used to encrypt and
 *  decrypt the restored database. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

/**
 *  Optional. Specifies the KMS configuration for one or more keys used to
 *  encrypt the database. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`. The keys referenced by
 *  `kms_key_names` must fully cover all regions of the database's instance
 *  configuration. Some examples: * For regional (single-region) instance
 *  configurations, specify a regional location KMS key. * For multi-region
 *  instance configurations of type `GOOGLE_MANAGED`, either specify a
 *  multi-region location KMS key or multiple regional location KMS keys that
 *  cover all regions in the instance configuration. * For an instance
 *  configuration of type `USER_MANAGED`, specify only regional location KMS
 *  keys to cover each region in the instance configuration. Multi-region
 *  location KMS keys aren't supported for `USER_MANAGED` type instance
 *  configurations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kmsKeyNames;

@end


/**
 *  Encapsulates progress related information for a Cloud Spanner long running
 *  instance operations.
 */
@interface GTLRSpanner_InstanceOperationProgress : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Percent completion of the operation. Values are between 0 and 100 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *progressPercent;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  An isolated set of Cloud Spanner resources that databases can define
 *  placements on.
 */
@interface GTLRSpanner_InstancePartition : GTLRObject

/**
 *  Required. The name of the instance partition's configuration. Values are of
 *  the form `projects//instanceConfigs/`. See also InstanceConfig and
 *  ListInstanceConfigs.
 */
@property(nonatomic, copy, nullable) NSString *config;

/** Output only. The time at which the instance partition was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. The descriptive name for this instance partition as it appears in
 *  UIs. Must be unique per project and between 4 and 30 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a instance partition from overwriting each other. It
 *  is strongly suggested that systems make use of the etag in the
 *  read-modify-write cycle to perform instance partition updates in order to
 *  avoid race conditions: An etag is returned in the response which contains
 *  instance partitions, and systems are expected to put that etag in the
 *  request to update instance partitions to ensure that their change will be
 *  applied to the same version of the instance partition. If no etag is
 *  provided in the call to update instance partition, then the existing
 *  instance partition is overwritten blindly.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Required. A unique identifier for the instance partition. Values are of the
 *  form `projects//instances//instancePartitions/a-z*[a-z0-9]`. The final
 *  segment of the name must be between 2 and 64 characters in length. An
 *  instance partition's name cannot be changed after the instance partition is
 *  created.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The number of nodes allocated to this instance partition. Users can set the
 *  `node_count` field to specify the target number of nodes allocated to the
 *  instance partition. This may be zero in API responses for instance
 *  partitions that are not yet in state `READY`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  The number of processing units allocated to this instance partition. Users
 *  can set the `processing_units` field to specify the target number of
 *  processing units allocated to the instance partition. This might be zero in
 *  API responses for instance partitions that are not yet in the `READY` state.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *processingUnits;

/**
 *  Output only. Deprecated: This field is not populated. Output only. The names
 *  of the backups that reference this instance partition. Referencing backups
 *  should share the parent instance. The existence of any referencing backup
 *  prevents the instance partition from being deleted.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingBackups GTLR_DEPRECATED;

/**
 *  Output only. The names of the databases that reference this instance
 *  partition. Referencing databases should share the parent instance. The
 *  existence of any referencing database prevents the instance partition from
 *  being deleted.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingDatabases;

/**
 *  Output only. The current instance partition state.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstancePartition_State_Creating The instance
 *        partition is still being created. Resources may not be available yet,
 *        and operations such as creating placements using this instance
 *        partition may not work. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_InstancePartition_State_Ready The instance partition
 *        is fully created and ready to do work such as creating placements and
 *        using in databases. (Value: "READY")
 *    @arg @c kGTLRSpanner_InstancePartition_State_StateUnspecified Not
 *        specified. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The time at which the instance partition was most recently
 *  updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  ReplicaSelection identifies replicas with common properties.
 */
@interface GTLRSpanner_InstanceReplicaSelection : GTLRObject

/**
 *  Required. Name of the location of the replicas (for example, "us-central1").
 */
@property(nonatomic, copy, nullable) NSString *location;

@end


/**
 *  A split key.
 */
@interface GTLRSpanner_Key : GTLRObject

/**
 *  Required. The column values making up the split key.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *keyParts;

@end


/**
 *  KeyRange represents a range of rows in a table or index. A range has a start
 *  key and an end key. These keys can be open or closed, indicating if the
 *  range includes rows with that key. Keys are represented by lists, where the
 *  ith value in the list corresponds to the ith component of the table or index
 *  primary key. Individual values are encoded as described here. For example,
 *  consider the following table definition: CREATE TABLE UserEvents ( UserName
 *  STRING(MAX), EventDate STRING(10) ) PRIMARY KEY(UserName, EventDate); The
 *  following keys name rows in this table: "Bob", "2014-09-23" Since the
 *  `UserEvents` table's `PRIMARY KEY` clause names two columns, each
 *  `UserEvents` key has two elements; the first is the `UserName`, and the
 *  second is the `EventDate`. Key ranges with multiple components are
 *  interpreted lexicographically by component using the table or index key's
 *  declared sort order. For example, the following range returns all events for
 *  user `"Bob"` that occurred in the year 2015: "start_closed": ["Bob",
 *  "2015-01-01"] "end_closed": ["Bob", "2015-12-31"] Start and end keys can
 *  omit trailing key components. This affects the inclusion and exclusion of
 *  rows that exactly match the provided key components: if the key is closed,
 *  then rows that exactly match the provided components are included; if the
 *  key is open, then rows that exactly match are not included. For example, the
 *  following range includes all events for `"Bob"` that occurred during and
 *  after the year 2000: "start_closed": ["Bob", "2000-01-01"] "end_closed":
 *  ["Bob"] The next example retrieves all events for `"Bob"`: "start_closed":
 *  ["Bob"] "end_closed": ["Bob"] To retrieve events before the year 2000:
 *  "start_closed": ["Bob"] "end_open": ["Bob", "2000-01-01"] The following
 *  range includes all rows in the table: "start_closed": [] "end_closed": []
 *  This range returns all users whose `UserName` begins with any character from
 *  A to C: "start_closed": ["A"] "end_open": ["D"] This range returns all users
 *  whose `UserName` begins with B: "start_closed": ["B"] "end_open": ["C"] Key
 *  ranges honor column sort order. For example, suppose a table is defined as
 *  follows: CREATE TABLE DescendingSortedTable { Key INT64, ... ) PRIMARY
 *  KEY(Key DESC); The following range retrieves all rows with key values
 *  between 1 and 100 inclusive: "start_closed": ["100"] "end_closed": ["1"]
 *  Note that 100 is passed as the start, and 1 is passed as the end, because
 *  `Key` is a descending column in the schema.
 */
@interface GTLRSpanner_KeyRange : GTLRObject

/**
 *  If the end is closed, then the range includes all rows whose first
 *  `len(end_closed)` key columns exactly match `end_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endClosed;

/**
 *  If the end is open, then the range excludes rows whose first `len(end_open)`
 *  key columns exactly match `end_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endOpen;

/**
 *  If the start is closed, then the range includes all rows whose first
 *  `len(start_closed)` key columns exactly match `start_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startClosed;

/**
 *  If the start is open, then the range excludes rows whose first
 *  `len(start_open)` key columns exactly match `start_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startOpen;

@end


/**
 *  A message representing information for a key range (possibly one key).
 */
@interface GTLRSpanner_KeyRangeInfo : GTLRObject

/** The list of context values for this key range. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ContextValue *> *contextValues;

/**
 *  The index of the end key in indexed_keys.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endKeyIndex;

/** Information about this key range, for all metrics. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *info;

/**
 *  The number of keys this range covers.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *keysCount;

/** The name of the metric. e.g. "latency". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *metric;

/**
 *  The index of the start key in indexed_keys.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startKeyIndex;

/** The time offset. This is the time since the start of the time interval. */
@property(nonatomic, strong, nullable) GTLRDuration *timeOffset;

/**
 *  The unit of the metric. This is an unstructured field and will be mapped as
 *  is to the user.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *unit;

/**
 *  The value of the metric.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  A message representing a list of specific information for multiple key
 *  ranges.
 */
@interface GTLRSpanner_KeyRangeInfos : GTLRObject

/** The list individual KeyRangeInfos. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_KeyRangeInfo *> *infos;

/**
 *  The total size of the list of all KeyRangeInfos. This may be larger than the
 *  number of repeated messages above. If that is the case, this number may be
 *  used to determine how many are not being shown.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  `KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All
 *  the keys are expected to be in the same table or index. The keys need not be
 *  sorted in any particular way. If the same key is specified multiple times in
 *  the set (for example if two ranges, two keys, or a key and a range overlap),
 *  Cloud Spanner behaves as if the key were only specified once.
 */
@interface GTLRSpanner_KeySet : GTLRObject

/**
 *  For convenience `all` can be set to `true` to indicate that this `KeySet`
 *  matches all keys in the table or index. Note that any keys specified in
 *  `keys` or `ranges` are only yielded once.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *all;

/**
 *  A list of specific keys. Entries in `keys` should have exactly as many
 *  elements as there are columns in the primary or index key with which this
 *  `KeySet` is used. Individual key values are encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *keys;

/**
 *  A list of key ranges. See KeyRange for more information about key range
 *  specifications.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_KeyRange *> *ranges;

@end


/**
 *  The response for ListBackupOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListBackupOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListBackupOperations call to
 *  fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching backup long-running operations. Each operation's name
 *  will be prefixed by the backup's name. The operation's metadata field type
 *  `metadata.type_url` describes the type of the metadata. Operations returned
 *  include those that are pending or have completed/failed/canceled within the
 *  last 7 days. Operations returned are ordered by
 *  `operation.metadata.value.progress.start_time` in descending order starting
 *  from the most recently started operation.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListBackupSchedules.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backupSchedules" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRSpanner_ListBackupSchedulesResponse : GTLRCollectionObject

/**
 *  The list of backup schedules for a database.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_BackupSchedule *> *backupSchedules;

/**
 *  `next_page_token` can be sent in a subsequent ListBackupSchedules call to
 *  fetch more of the schedules.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListBackups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListBackupsResponse : GTLRCollectionObject

/**
 *  The list of matching backups. Backups returned are ordered by `create_time`
 *  in descending order, starting from the most recent `create_time`.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Backup *> *backups;

/**
 *  `next_page_token` can be sent in a subsequent ListBackups call to fetch more
 *  of the matching backups.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListDatabaseOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabaseOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListDatabaseOperations call to
 *  fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching database long-running operations. Each operation's name
 *  will be prefixed by the database's name. The operation's metadata field type
 *  `metadata.type_url` describes the type of the metadata.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListDatabaseRoles.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "databaseRoles" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabaseRolesResponse : GTLRCollectionObject

/**
 *  Database roles that matched the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_DatabaseRole *> *databaseRoles;

/**
 *  `next_page_token` can be sent in a subsequent ListDatabaseRoles call to
 *  fetch more of the matching roles.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListDatabases.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "databases" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabasesResponse : GTLRCollectionObject

/**
 *  Databases that matched the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Database *> *databases;

/**
 *  `next_page_token` can be sent in a subsequent ListDatabases call to fetch
 *  more of the matching databases.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstanceConfigOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstanceConfigOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListInstanceConfigOperations
 *  call to fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching instance configuration long-running operations. Each
 *  operation's name will be prefixed by the name of the instance configuration.
 *  The operation's metadata field type `metadata.type_url` describes the type
 *  of the metadata.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListInstanceConfigs.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instanceConfigs" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRSpanner_ListInstanceConfigsResponse : GTLRCollectionObject

/**
 *  The list of requested instance configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_InstanceConfig *> *instanceConfigs;

/**
 *  `next_page_token` can be sent in a subsequent ListInstanceConfigs call to
 *  fetch more of the matching instance configurations.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstancePartitionOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstancePartitionOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListInstancePartitionOperations call to fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching instance partition long-running operations. Each
 *  operation's name will be prefixed by the instance partition's name. The
 *  operation's metadata field type `metadata.type_url` describes the type of
 *  the metadata.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

/**
 *  The list of unreachable instance partitions. It includes the names of
 *  instance partitions whose operation metadata could not be retrieved within
 *  instance_partition_deadline.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachableInstancePartitions;

@end


/**
 *  The response for ListInstancePartitions.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instancePartitions" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRSpanner_ListInstancePartitionsResponse : GTLRCollectionObject

/**
 *  The list of requested instancePartitions.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_InstancePartition *> *instancePartitions;

/**
 *  `next_page_token` can be sent in a subsequent ListInstancePartitions call to
 *  fetch more of the matching instance partitions.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of unreachable instances or instance partitions. It includes the
 *  names of instances or instance partitions whose metadata could not be
 *  retrieved within instance_partition_deadline.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response for ListInstances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstancesResponse : GTLRCollectionObject

/**
 *  The list of requested instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Instance *> *instances;

/**
 *  `next_page_token` can be sent in a subsequent ListInstances call to fetch
 *  more of the matching instances.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of unreachable instances. It includes the names of instances whose
 *  metadata could not be retrieved within instance_deadline.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  Response method from the ListScans method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scans" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListScansResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Available scans based on the list query parameters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Scan *> *scans;

@end


/**
 *  The response for ListSessions.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "sessions" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListSessionsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListSessions call to fetch
 *  more of the matching sessions.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of requested sessions.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *sessions;

@end


/**
 *  A message representing a user-facing string whose value may need to be
 *  translated before being displayed.
 */
@interface GTLRSpanner_LocalizedString : GTLRObject

/**
 *  A map of arguments used when creating the localized message. Keys represent
 *  parameter names which may be used by the localized version when substituting
 *  dynamic values.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString_Args *args;

/**
 *  The canonical English version of this message. If no token is provided or
 *  the front-end has no message associated with the token, this text will be
 *  displayed as-is.
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  The token identifying the message, e.g. 'METRIC_READ_CPU'. This should be
 *  unique within the service.
 */
@property(nonatomic, copy, nullable) NSString *token;

@end


/**
 *  A map of arguments used when creating the localized message. Keys represent
 *  parameter names which may be used by the localized version when substituting
 *  dynamic values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_LocalizedString_Args : GTLRObject
@end


/**
 *  A message representing the actual monitoring data, values for each key
 *  bucket over time, of a metric.
 */
@interface GTLRSpanner_Metric : GTLRObject

/**
 *  The aggregation function used to aggregate each key bucket
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Metric_Aggregation_AggregationUnspecified Required
 *        default value. (Value: "AGGREGATION_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Metric_Aggregation_Max Use the maximum of all values.
 *        (Value: "MAX")
 *    @arg @c kGTLRSpanner_Metric_Aggregation_Sum Use the sum of all values.
 *        (Value: "SUM")
 */
@property(nonatomic, copy, nullable) NSString *aggregation;

/** The category of the metric, e.g. "Activity", "Alerts", "Reads", etc. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *category;

/**
 *  The references to numerator and denominator metrics for a derived metric.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_DerivedMetric *derived;

/** The displayed label of the metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *displayLabel;

/**
 *  Whether the metric has any non-zero data.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasNonzeroData;

/**
 *  The value that is considered hot for the metric. On a per metric basis
 *  hotness signals high utilization and something that might potentially be a
 *  cause for concern by the end user. hot_value is used to calibrate and scale
 *  visual color scales.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hotValue;

/**
 *  The (sparse) mapping from time index to an IndexedHotKey message,
 *  representing those time intervals for which there are hot keys.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Metric_IndexedHotKeys *indexedHotKeys;

/**
 *  The (sparse) mapping from time interval index to an IndexedKeyRangeInfos
 *  message, representing those time intervals for which there are informational
 *  messages concerning key ranges.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Metric_IndexedKeyRangeInfos *indexedKeyRangeInfos;

/** Information about the metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *info;

/** The data for the metric as a matrix. */
@property(nonatomic, strong, nullable) GTLRSpanner_MetricMatrix *matrix;

/** The unit of the metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *unit;

/**
 *  Whether the metric is visible to the end user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *visible;

@end


/**
 *  The (sparse) mapping from time index to an IndexedHotKey message,
 *  representing those time intervals for which there are hot keys.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_IndexedHotKey. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Metric_IndexedHotKeys : GTLRObject
@end


/**
 *  The (sparse) mapping from time interval index to an IndexedKeyRangeInfos
 *  message, representing those time intervals for which there are informational
 *  messages concerning key ranges.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_IndexedKeyRangeInfos. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Metric_IndexedKeyRangeInfos : GTLRObject
@end


/**
 *  A message representing a matrix of floats.
 */
@interface GTLRSpanner_MetricMatrix : GTLRObject

/** The rows of the matrix. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_MetricMatrixRow *> *rows;

@end


/**
 *  A message representing a row of a matrix of floats.
 */
@interface GTLRSpanner_MetricMatrixRow : GTLRObject

/**
 *  The columns of the row.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cols;

@end


/**
 *  A mod describes all data changes in a watched table row.
 */
@interface GTLRSpanner_Mod : GTLRObject

/** Returns the value of the primary key of the modified row. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ModValue *> *keys;

/**
 *  Returns the new values after the change for the modified columns. Always
 *  empty for DELETE.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ModValue *> *newValues NS_RETURNS_NOT_RETAINED;

/**
 *  Returns the old values before the change for the modified columns. Always
 *  empty for INSERT, or if old values are not being captured specified by
 *  value_capture_type.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ModValue *> *oldValues;

@end


/**
 *  Returns the value and associated metadata for a particular field of the Mod.
 */
@interface GTLRSpanner_ModValue : GTLRObject

/**
 *  Index within the repeated column_metadata field, to obtain the column
 *  metadata for the column that was modified.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *columnMetadataIndex;

/**
 *  The value of the column.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id value;

@end


/**
 *  Describes move-in of the key ranges into the change stream partition
 *  identified by partition_token. To maintain processing the changes for a
 *  particular key in timestamp order, the query processing the change stream
 *  partition identified by partition_token should not advance beyond the
 *  partition event record commit timestamp until the queries processing the
 *  source change stream partitions have processed all change stream records
 *  with timestamps <= the partition event record commit timestamp.
 */
@interface GTLRSpanner_MoveInEvent : GTLRObject

/**
 *  An unique partition identifier describing the source change stream partition
 *  that recorded changes for the key range that is moving into this partition.
 */
@property(nonatomic, copy, nullable) NSString *sourcePartitionToken;

@end


/**
 *  The request for MoveInstance.
 */
@interface GTLRSpanner_MoveInstanceRequest : GTLRObject

/**
 *  Required. The target instance configuration where to move the instance.
 *  Values are of the form `projects//instanceConfigs/`.
 */
@property(nonatomic, copy, nullable) NSString *targetConfig;

/**
 *  Optional. The configuration for each database in the target instance
 *  configuration.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_DatabaseMoveConfig *> *targetDatabaseMoveConfigs;

@end


/**
 *  Describes move-out of the key ranges out of the change stream partition
 *  identified by partition_token. To maintain processing the changes for a
 *  particular key in timestamp order, the query processing the MoveOutEvent in
 *  the partition identified by partition_token should inform the queries
 *  processing the destination partitions that they can unblock and proceed
 *  processing records past the commit_timestamp.
 */
@interface GTLRSpanner_MoveOutEvent : GTLRObject

/**
 *  An unique partition identifier describing the destination change stream
 *  partition that will record changes for the key range that is moving out of
 *  this partition.
 */
@property(nonatomic, copy, nullable) NSString *destinationPartitionToken;

@end


/**
 *  When a read-write transaction is executed on a multiplexed session, this
 *  precommit token is sent back to the client as a part of the Transaction
 *  message in the BeginTransaction response and also as a part of the ResultSet
 *  and PartialResultSet responses.
 */
@interface GTLRSpanner_MultiplexedSessionPrecommitToken : GTLRObject

/**
 *  Opaque precommit token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *precommitToken;

/**
 *  An incrementing seq number is generated on every precommit token that is
 *  returned. Clients should remember the precommit token with the highest
 *  sequence number from the current transaction attempt.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqNum;

@end


/**
 *  A modification to one or more Cloud Spanner rows. Mutations can be applied
 *  to a Cloud Spanner database by sending them in a Commit call.
 */
@interface GTLRSpanner_Mutation : GTLRObject

/**
 *  Delete rows from a table. Succeeds whether or not the named rows were
 *  present.
 *
 *  Remapped to 'deleteProperty' to avoid language reserved word 'delete'.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Delete *deleteProperty;

/**
 *  Insert new rows in a table. If any of the rows already exist, the write or
 *  transaction fails with error `ALREADY_EXISTS`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insert;

/**
 *  Like insert, except that if the row already exists, then its column values
 *  are overwritten with the ones provided. Any column values not explicitly
 *  written are preserved. When using insert_or_update, just as when using
 *  insert, all `NOT NULL` columns in the table must be given a value. This
 *  holds true even when the row already exists and will therefore actually be
 *  updated.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insertOrUpdate;

/**
 *  Like insert, except that if the row already exists, it is deleted, and the
 *  column values provided are inserted instead. Unlike insert_or_update, this
 *  means any values not explicitly written become `NULL`. In an interleaved
 *  table, if you create the child table with the `ON DELETE CASCADE`
 *  annotation, then replacing a parent row also deletes the child rows.
 *  Otherwise, you must delete the child rows before you replace the parent row.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *replace;

/**
 *  Update existing rows in a table. If any of the rows does not already exist,
 *  the transaction fails with error `NOT_FOUND`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *update;

@end


/**
 *  A group of mutations to be committed together. Related mutations should be
 *  placed in a group. For example, two mutations inserting rows with the same
 *  primary key prefix in both parent and child tables are related.
 */
@interface GTLRSpanner_MutationGroup : GTLRObject

/** Required. The mutations in this group. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Mutation *> *mutations;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRSpanner_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Response : GTLRObject
@end


/**
 *  Encapsulates progress related information for a Cloud Spanner long running
 *  operation.
 */
@interface GTLRSpanner_OperationProgress : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Percent completion of the operation. Values are between 0 and 100 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *progressPercent;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Metadata type for the long-running operation used to track the progress of
 *  optimizations performed on a newly restored database. This long-running
 *  operation is automatically created by the system after the successful
 *  completion of a database restore, and cannot be cancelled.
 */
@interface GTLRSpanner_OptimizeRestoredDatabaseMetadata : GTLRObject

/** Name of the restored database being optimized. */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the post-restore optimizations. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

@end


/**
 *  Partial results from a streaming read or SQL query. Streaming reads and SQL
 *  queries better tolerate large result sets, large rows, and large values, but
 *  are a little trickier to consume.
 */
@interface GTLRSpanner_PartialResultSet : GTLRObject

/**
 *  If true, then the final value in values is chunked, and must be combined
 *  with more values from subsequent `PartialResultSet`s to obtain a complete
 *  field value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *chunkedValue;

/**
 *  Optional. Indicates whether this is the last `PartialResultSet` in the
 *  stream. The server might optionally set this field. Clients shouldn't rely
 *  on this field being set in all cases.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *last;

/**
 *  Metadata about the result set, such as row type information. Only present in
 *  the first response.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Optional. A precommit token is included if the read-write transaction has
 *  multiplexed sessions enabled. Pass the precommit token with the highest
 *  sequence number from this transaction attempt to the Commit request for this
 *  transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_MultiplexedSessionPrecommitToken *precommitToken;

/**
 *  Streaming calls might be interrupted for a variety of reasons, such as TCP
 *  connection loss. If this occurs, the stream of results can be resumed by
 *  re-sending the original request and including `resume_token`. Note that
 *  executing any other transaction in the same session invalidates the token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  Query plan and execution statistics for the statement that produced this
 *  streaming result set. These can be requested by setting
 *  ExecuteSqlRequest.query_mode and are sent only once with the last response
 *  in the stream. This field is also present in the last response for DML
 *  statements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

/**
 *  A streamed result set consists of a stream of values, which might be split
 *  into many `PartialResultSet` messages to accommodate large rows and/or large
 *  values. Every N complete values defines a row, where N is equal to the
 *  number of entries in metadata.row_type.fields. Most values are encoded based
 *  on type as described here. It's possible that the last value in values is
 *  "chunked", meaning that the rest of the value is sent in subsequent
 *  `PartialResultSet`(s). This is denoted by the chunked_value field. Two or
 *  more chunked values can be merged to form a complete value as follows: *
 *  `bool/number/null`: can't be chunked * `string`: concatenate the strings *
 *  `list`: concatenate the lists. If the last element in a list is a `string`,
 *  `list`, or `object`, merge it with the first element in the next list by
 *  applying these rules recursively. * `object`: concatenate the (field name,
 *  field value) pairs. If a field name is duplicated, then apply these rules
 *  recursively to merge the field values. Some examples of merging: Strings are
 *  concatenated. "foo", "bar" => "foobar" Lists of non-strings are
 *  concatenated. [2, 3], [4] => [2, 3, 4] Lists are concatenated, but the last
 *  and first elements are merged because they are strings. ["a", "b"], ["c",
 *  "d"] => ["a", "bc", "d"] Lists are concatenated, but the last and first
 *  elements are merged because they are lists. Recursively, the last and first
 *  elements of the inner lists are merged because they are strings. ["a", ["b",
 *  "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"] Non-overlapping object fields
 *  are combined. {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"} Overlapping
 *  object fields are merged. {"a": "1"}, {"a": "2"} => {"a": "12"} Examples of
 *  merging objects containing lists of strings. {"a": ["1"]}, {"a": ["2"]} =>
 *  {"a": ["12"]} For a more complete example, suppose a streaming SQL query is
 *  yielding a result set whose rows contain a single string field. The
 *  following `PartialResultSet`s might be yielded: { "metadata": { ... }
 *  "values": ["Hello", "W"] "chunked_value": true "resume_token": "Af65..." } {
 *  "values": ["orl"] "chunked_value": true } { "values": ["d"] "resume_token":
 *  "Zx1B..." } This sequence of `PartialResultSet`s encodes two rows, one
 *  containing the field value `"Hello"`, and a second containing the field
 *  value `"World" = "W" + "orl" + "d"`. Not all `PartialResultSet`s contain a
 *  `resume_token`. Execution can only be resumed from a previously yielded
 *  `resume_token`. For the above sequence of `PartialResultSet`s, resuming the
 *  query with `"resume_token": "Af65..."` yields results from the
 *  `PartialResultSet` with value "orl".
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *values;

@end


/**
 *  Information returned for each partition returned in a PartitionResponse.
 */
@interface GTLRSpanner_Partition : GTLRObject

/**
 *  This token can be passed to `Read`, `StreamingRead`, `ExecuteSql`, or
 *  `ExecuteStreamingSql` requests to restrict the results to those identified
 *  by this partition token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

@end


/**
 *  Message type to initiate a Partitioned DML transaction.
 */
@interface GTLRSpanner_PartitionedDml : GTLRObject
@end


/**
 *  A partition end record serves as a notification that the client should stop
 *  reading the partition. No further records are expected to be retrieved on
 *  it.
 */
@interface GTLRSpanner_PartitionEndRecord : GTLRObject

/**
 *  End timestamp at which the change stream partition is terminated. All
 *  changes generated by this partition will have timestamps <= end_timestamp.
 *  DataChangeRecord.commit_timestamps, PartitionStartRecord.start_timestamps,
 *  PartitionEventRecord.commit_timestamps, and
 *  PartitionEndRecord.end_timestamps can have the same value in the same
 *  partition. PartitionEndRecord is the last record returned for a partition.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTimestamp;

/**
 *  Unique partition identifier describing the terminated change stream
 *  partition. partition_token is equal to the partition token of the change
 *  stream partition currently queried to return this PartitionEndRecord.
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  Record sequence numbers are unique and monotonically increasing (but not
 *  necessarily contiguous) for a specific timestamp across record types in the
 *  same partition. To guarantee ordered processing, the reader should process
 *  records (of potentially different types) in record_sequence order for a
 *  specific timestamp in the same partition.
 */
@property(nonatomic, copy, nullable) NSString *recordSequence;

@end


/**
 *  A partition event record describes key range changes for a change stream
 *  partition. The changes to a row defined by its primary key can be captured
 *  in one change stream partition for a specific time range, and then be
 *  captured in a different change stream partition for a different time range.
 *  This movement of key ranges across change stream partitions is a reflection
 *  of activities, such as Spanner's dynamic splitting and load balancing, etc.
 *  Processing this event is needed if users want to guarantee processing of the
 *  changes for any key in timestamp order. If time ordered processing of
 *  changes for a primary key is not needed, this event can be ignored. To
 *  guarantee time ordered processing for each primary key, if the event
 *  describes move-ins, the reader of this partition needs to wait until the
 *  readers of the source partitions have processed all records with timestamps
 *  <= this PartitionEventRecord.commit_timestamp, before advancing beyond this
 *  PartitionEventRecord. If the event describes move-outs, the reader can
 *  notify the readers of the destination partitions that they can continue
 *  processing.
 */
@interface GTLRSpanner_PartitionEventRecord : GTLRObject

/**
 *  Indicates the commit timestamp at which the key range change occurred.
 *  DataChangeRecord.commit_timestamps, PartitionStartRecord.start_timestamps,
 *  PartitionEventRecord.commit_timestamps, and
 *  PartitionEndRecord.end_timestamps can have the same value in the same
 *  partition.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

/**
 *  Set when one or more key ranges are moved into the change stream partition
 *  identified by partition_token. Example: Two key ranges are moved into
 *  partition (P1) from partition (P2) and partition (P3) in a single
 *  transaction at timestamp T. The PartitionEventRecord returned in P1 will
 *  reflect the move as: PartitionEventRecord { commit_timestamp: T
 *  partition_token: "P1" move_in_events { source_partition_token: "P2" }
 *  move_in_events { source_partition_token: "P3" } } The PartitionEventRecord
 *  returned in P2 will reflect the move as: PartitionEventRecord {
 *  commit_timestamp: T partition_token: "P2" move_out_events {
 *  destination_partition_token: "P1" } } The PartitionEventRecord returned in
 *  P3 will reflect the move as: PartitionEventRecord { commit_timestamp: T
 *  partition_token: "P3" move_out_events { destination_partition_token: "P1" }
 *  }
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_MoveInEvent *> *moveInEvents;

/**
 *  Set when one or more key ranges are moved out of the change stream partition
 *  identified by partition_token. Example: Two key ranges are moved out of
 *  partition (P1) to partition (P2) and partition (P3) in a single transaction
 *  at timestamp T. The PartitionEventRecord returned in P1 will reflect the
 *  move as: PartitionEventRecord { commit_timestamp: T partition_token: "P1"
 *  move_out_events { destination_partition_token: "P2" } move_out_events {
 *  destination_partition_token: "P3" } } The PartitionEventRecord returned in
 *  P2 will reflect the move as: PartitionEventRecord { commit_timestamp: T
 *  partition_token: "P2" move_in_events { source_partition_token: "P1" } } The
 *  PartitionEventRecord returned in P3 will reflect the move as:
 *  PartitionEventRecord { commit_timestamp: T partition_token: "P3"
 *  move_in_events { source_partition_token: "P1" } }
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_MoveOutEvent *> *moveOutEvents;

/**
 *  Unique partition identifier describing the partition this event occurred on.
 *  partition_token is equal to the partition token of the change stream
 *  partition currently queried to return this PartitionEventRecord.
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  Record sequence numbers are unique and monotonically increasing (but not
 *  necessarily contiguous) for a specific timestamp across record types in the
 *  same partition. To guarantee ordered processing, the reader should process
 *  records (of potentially different types) in record_sequence order for a
 *  specific timestamp in the same partition.
 */
@property(nonatomic, copy, nullable) NSString *recordSequence;

@end


/**
 *  Options for a `PartitionQueryRequest` and `PartitionReadRequest`.
 */
@interface GTLRSpanner_PartitionOptions : GTLRObject

/**
 *  **Note:** This hint is currently ignored by `PartitionQuery` and
 *  `PartitionRead` requests. The desired maximum number of partitions to
 *  return. For example, this might be set to the number of workers available.
 *  The default for this option is currently 10,000. The maximum value is
 *  currently 200,000. This is only a hint. The actual number of partitions
 *  returned can be smaller or larger than this maximum count request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPartitions;

/**
 *  **Note:** This hint is currently ignored by `PartitionQuery` and
 *  `PartitionRead` requests. The desired data size for each partition
 *  generated. The default for this option is currently 1 GiB. This is only a
 *  hint. The actual size of each partition can be smaller or larger than this
 *  size request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionSizeBytes;

@end


/**
 *  The request for PartitionQuery
 */
@interface GTLRSpanner_PartitionQueryRequest : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It's an
 *  error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_Params *params;

/**
 *  It isn't always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL query parameters. See the definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_ParamTypes *paramTypes;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/**
 *  Required. The query request to generate partitions for. The request fails if
 *  the query isn't root partitionable. For a query to be root partitionable, it
 *  needs to satisfy a few conditions. For example, if the query execution plan
 *  contains a distributed union operator, then it must be the first operator in
 *  the plan. For more information about other conditions, see [Read data in
 *  parallel](https://cloud.google.com/spanner/docs/reads#read_data_in_parallel).
 *  The query request must not contain DML commands, such as `INSERT`, `UPDATE`,
 *  or `DELETE`. Use `ExecuteStreamingSql` with a `PartitionedDml` transaction
 *  for large, partition-friendly DML operations.
 */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  Read-only snapshot transactions are supported, read and write and single-use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It's an
 *  error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_Params : GTLRObject
@end


/**
 *  It isn't always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL query parameters. See the definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_ParamTypes : GTLRObject
@end


/**
 *  The request for PartitionRead
 */
@interface GTLRSpanner_PartitionReadRequest : GTLRObject

/** The columns of table to be returned for each row matching this request. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is used instead of
 *  the table primary key when interpreting key_set and sorting result rows. See
 *  key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index is present. If
 *  index is present, then key_set instead names index keys in index. It isn't
 *  an error for the `key_set` to name rows that don't exist in the database.
 *  Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for PartitionQuery or PartitionRead
 */
@interface GTLRSpanner_PartitionResponse : GTLRObject

/** Partitions created by this request. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Partition *> *partitions;

/** Transaction created by this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

@end


/**
 *  A partition start record serves as a notification that the client should
 *  schedule the partitions to be queried. PartitionStartRecord returns
 *  information about one or more partitions.
 */
@interface GTLRSpanner_PartitionStartRecord : GTLRObject

/** Unique partition identifiers to be used in queries. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *partitionTokens;

/**
 *  Record sequence numbers are unique and monotonically increasing (but not
 *  necessarily contiguous) for a specific timestamp across record types in the
 *  same partition. To guarantee ordered processing, the reader should process
 *  records (of potentially different types) in record_sequence order for a
 *  specific timestamp in the same partition.
 */
@property(nonatomic, copy, nullable) NSString *recordSequence;

/**
 *  Start timestamp at which the partitions should be queried to return change
 *  stream records with timestamps >= start_timestamp.
 *  DataChangeRecord.commit_timestamps, PartitionStartRecord.start_timestamps,
 *  PartitionEventRecord.commit_timestamps, and
 *  PartitionEndRecord.end_timestamps can have the same value in the same
 *  partition.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTimestamp;

@end


/**
 *  Node information for nodes appearing in a QueryPlan.plan_nodes.
 */
@interface GTLRSpanner_PlanNode : GTLRObject

/** List of child node `index`es and their relationship to this parent. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ChildLink *> *childLinks;

/** The display name for the node. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_ExecutionStats *executionStats;

/**
 *  The `PlanNode`'s index in node list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Used to determine the type of node. May be needed for visualizing different
 *  kinds of nodes differently. For example, If the node is a SCALAR node, it
 *  will have a condensed representation which can be used to directly embed a
 *  description of the node in its parent.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_PlanNode_Kind_KindUnspecified Not specified. (Value:
 *        "KIND_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Relational Denotes a Relational
 *        operator node in the expression tree. Relational operators represent
 *        iterative processing of rows during query execution. For example, a
 *        `TableScan` operation that reads rows from a table. (Value:
 *        "RELATIONAL")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Scalar Denotes a Scalar node in the
 *        expression tree. Scalar nodes represent non-iterable entities in the
 *        query plan. For example, constants or arithmetic operators appearing
 *        inside predicate expressions or references to column names. (Value:
 *        "SCALAR")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Attributes relevant to the node contained in a group of key-value pairs. For
 *  example, a Parameter Reference node could have the following information in
 *  its metadata: { "parameter_reference": "param1", "parameter_type": "array" }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_Metadata *metadata;

/** Condensed representation for SCALAR nodes. */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation *shortRepresentation;

@end


/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_ExecutionStats : GTLRObject
@end


/**
 *  Attributes relevant to the node contained in a group of key-value pairs. For
 *  example, a Parameter Reference node could have the following information in
 *  its metadata: { "parameter_reference": "param1", "parameter_type": "array" }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_Metadata : GTLRObject
@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** ``` { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
 *  members: - user:mike\@example.com - group:admins\@example.com -
 *  domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 ``` For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRSpanner_Policy : GTLRObject

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  A message representing a key prefix node in the key prefix hierarchy. for
 *  eg. Bigtable keyspaces are lexicographically ordered mappings of keys to
 *  values. Keys often have a shared prefix structure where users use the keys
 *  to organize data. Eg ///employee In this case Keysight will possibly use one
 *  node for a company and reuse it for all employees that fall under the
 *  company. Doing so improves legibility in the UI.
 */
@interface GTLRSpanner_PrefixNode : GTLRObject

/**
 *  Whether this corresponds to a data_source name.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataSourceNode;

/**
 *  The depth in the prefix hierarchy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *depth;

/**
 *  The index of the end key bucket of the range that this node spans.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endIndex;

/**
 *  The index of the start key bucket of the range that this node spans.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startIndex;

/** The string represented by the prefix node. */
@property(nonatomic, copy, nullable) NSString *word;

@end


/**
 *  Output of query advisor analysis.
 */
@interface GTLRSpanner_QueryAdvisorResult : GTLRObject

/**
 *  Optional. Index Recommendation for a query. This is an optional field and
 *  the recommendation will only be available when the recommendation guarantees
 *  significant improvement in query performance.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_IndexAdvice *> *indexAdvice;

@end


/**
 *  Query optimizer configuration.
 */
@interface GTLRSpanner_QueryOptions : GTLRObject

/**
 *  An option to control the selection of optimizer statistics package. This
 *  parameter allows individual queries to use a different query optimizer
 *  statistics package. Specifying `latest` as a value instructs Cloud Spanner
 *  to use the latest generated statistics package. If not specified, Cloud
 *  Spanner uses the statistics package set at the database level options, or
 *  the latest package if the database option isn't set. The statistics package
 *  requested by the query has to be exempt from garbage collection. This can be
 *  achieved with the following DDL statement: ```sql ALTER STATISTICS SET
 *  OPTIONS (allow_gc=false) ``` The list of available statistics packages can
 *  be queried from `INFORMATION_SCHEMA.SPANNER_STATISTICS`. Executing a SQL
 *  statement with an invalid optimizer statistics package or with a statistics
 *  package that allows garbage collection fails with an `INVALID_ARGUMENT`
 *  error.
 */
@property(nonatomic, copy, nullable) NSString *optimizerStatisticsPackage;

/**
 *  An option to control the selection of optimizer version. This parameter
 *  allows individual queries to pick different query optimizer versions.
 *  Specifying `latest` as a value instructs Cloud Spanner to use the latest
 *  supported query optimizer version. If not specified, Cloud Spanner uses the
 *  optimizer version set at the database level options. Any other positive
 *  integer (from the list of supported optimizer versions) overrides the
 *  default optimizer version for query execution. The list of supported
 *  optimizer versions can be queried from
 *  `SPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS`. Executing a SQL statement with
 *  an invalid optimizer version fails with an `INVALID_ARGUMENT` error. See
 *  https://cloud.google.com/spanner/docs/query-optimizer/manage-query-optimizer
 *  for more information on managing the query optimizer. The
 *  `optimizer_version` statement hint has precedence over this setting.
 */
@property(nonatomic, copy, nullable) NSString *optimizerVersion;

@end


/**
 *  Contains an ordered list of nodes appearing in the query plan.
 */
@interface GTLRSpanner_QueryPlan : GTLRObject

/**
 *  The nodes in the query plan. Plan nodes are returned in pre-order starting
 *  with the plan root. Each PlanNode's `id` corresponds to its index in
 *  `plan_nodes`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_PlanNode *> *planNodes;

/**
 *  Optional. The advise/recommendations for a query. Currently this field will
 *  be serving index recommendations for a query.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryAdvisorResult *queryAdvice;

@end


/**
 *  Information about the dual-region quorum.
 */
@interface GTLRSpanner_QuorumInfo : GTLRObject

/**
 *  Output only. The etag is used for optimistic concurrency control as a way to
 *  help prevent simultaneous `ChangeQuorum` requests that might create a race
 *  condition.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. Whether this `ChangeQuorum` is Google or User initiated.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_QuorumInfo_Initiator_Google `ChangeQuorum` initiated
 *        by Google. (Value: "GOOGLE")
 *    @arg @c kGTLRSpanner_QuorumInfo_Initiator_InitiatorUnspecified
 *        Unspecified. (Value: "INITIATOR_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_QuorumInfo_Initiator_User `ChangeQuorum` initiated by
 *        User. (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *initiator;

/**
 *  Output only. The type of this quorum. See QuorumType for more information
 *  about quorum type specifications.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_QuorumType *quorumType;

/** Output only. The timestamp when the request was triggered. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Information about the database quorum type. This only applies to dual-region
 *  instance configs.
 */
@interface GTLRSpanner_QuorumType : GTLRObject

/** Dual-region quorum type. */
@property(nonatomic, strong, nullable) GTLRSpanner_DualRegionQuorum *dualRegion;

/** Single-region quorum type. */
@property(nonatomic, strong, nullable) GTLRSpanner_SingleRegionQuorum *singleRegion;

@end


/**
 *  Message type to initiate a read-only transaction.
 */
@interface GTLRSpanner_ReadOnly : GTLRObject

/**
 *  Executes all reads at a timestamp that is `exact_staleness` old. The
 *  timestamp is chosen soon after the read is started. Guarantees that all
 *  writes that have committed more than the specified number of seconds ago are
 *  visible. Because Cloud Spanner chooses the exact timestamp, this mode works
 *  even if the client's local clock is substantially skewed from Cloud Spanner
 *  commit timestamps. Useful for reading at nearby replicas without the
 *  distributed timestamp negotiation overhead of `max_staleness`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *exactStaleness;

/**
 *  Read data at a timestamp >= `NOW - max_staleness` seconds. Guarantees that
 *  all writes that have committed more than the specified number of seconds ago
 *  are visible. Because Cloud Spanner chooses the exact timestamp, this mode
 *  works even if the client's local clock is substantially skewed from Cloud
 *  Spanner commit timestamps. Useful for reading the freshest data available at
 *  a nearby replica, while bounding the possible staleness if the local replica
 *  has fallen behind. Note that this option can only be used in single-use
 *  transactions.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxStaleness;

/**
 *  Executes all reads at a timestamp >= `min_read_timestamp`. This is useful
 *  for requesting fresher data than some previous read, or data that is fresh
 *  enough to observe the effects of some previously committed transaction whose
 *  timestamp is known. Note that this option can only be used in single-use
 *  transactions. A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to
 *  nanoseconds. Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *minReadTimestamp;

/**
 *  Executes all reads at the given timestamp. Unlike other modes, reads at a
 *  specific timestamp are repeatable; the same read at the same timestamp
 *  always returns the same data. If the timestamp is in the future, the read is
 *  blocked until the specified timestamp, modulo the read's deadline. Useful
 *  for large scale consistent reads such as mapreduces, or for coordinating
 *  many reads against a consistent snapshot of the data. A timestamp in RFC3339
 *  UTC \\"Zulu\\" format, accurate to nanoseconds. Example:
 *  `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

/**
 *  If true, the Cloud Spanner-selected read timestamp is included in the
 *  Transaction message that describes the transaction.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *returnReadTimestamp;

/**
 *  Read at a timestamp where all previously committed transactions are visible.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strong;

@end


/**
 *  The request for Read and StreamingRead.
 */
@interface GTLRSpanner_ReadRequest : GTLRObject

/**
 *  Required. The columns of table to be returned for each row matching this
 *  request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If this is for a partitioned read and this field is set to `true`, the
 *  request is executed with Spanner Data Boost independent compute resources.
 *  If the field is set to `true` but the request doesn't set `partition_token`,
 *  the API returns an `INVALID_ARGUMENT` error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataBoostEnabled;

/** Directed read options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_DirectedReadOptions *directedReadOptions;

/**
 *  If non-empty, the name of an index on table. This index is used instead of
 *  the table primary key when interpreting key_set and sorting result rows. See
 *  key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index is present. If
 *  index is present, then key_set instead names index keys in index. If the
 *  partition_token field is empty, rows are yielded in table primary key order
 *  (if index is empty) or index key order (if index is non-empty). If the
 *  partition_token field isn't empty, rows are yielded in an unspecified order.
 *  It isn't an error for the `key_set` to name rows that don't exist in the
 *  database. Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/**
 *  If greater than zero, only the first `limit` rows are yielded. If `limit` is
 *  zero, the default is no limit. A limit can't be specified if
 *  `partition_token` is set.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *limit;

/**
 *  Optional. Lock Hint for the request, it can only be used with read-write
 *  transactions.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReadRequest_LockHint_LockHintExclusive Acquire
 *        exclusive locks. Requesting exclusive locks is beneficial if you
 *        observe high write contention, which means you notice that multiple
 *        transactions are concurrently trying to read and write to the same
 *        data, resulting in a large number of aborts. This problem occurs when
 *        two transactions initially acquire shared locks and then both try to
 *        upgrade to exclusive locks at the same time. In this situation both
 *        transactions are waiting for the other to give up their lock,
 *        resulting in a deadlocked situation. Spanner is able to detect this
 *        occurring and force one of the transactions to abort. However, this is
 *        a slow and expensive operation and results in lower performance. In
 *        this case it makes sense to acquire exclusive locks at the start of
 *        the transaction because then when multiple transactions try to act on
 *        the same data, they automatically get serialized. Each transaction
 *        waits its turn to acquire the lock and avoids getting into deadlock
 *        situations. Because the exclusive lock hint is just a hint, it
 *        shouldn't be considered equivalent to a mutex. In other words, you
 *        shouldn't use Spanner exclusive locks as a mutual exclusion mechanism
 *        for the execution of code outside of Spanner. **Note:** Request
 *        exclusive locks judiciously because they block others from reading
 *        that data for the entire transaction, rather than just when the writes
 *        are being performed. Unless you observe high write contention, you
 *        should use the default of shared read locks so you don't prematurely
 *        block other clients from reading the data that you're writing to.
 *        (Value: "LOCK_HINT_EXCLUSIVE")
 *    @arg @c kGTLRSpanner_ReadRequest_LockHint_LockHintShared Acquire shared
 *        locks. By default when you perform a read as part of a read-write
 *        transaction, Spanner acquires shared read locks, which allows other
 *        reads to still access the data until your transaction is ready to
 *        commit. When your transaction is committing and writes are being
 *        applied, the transaction attempts to upgrade to an exclusive lock for
 *        any data you are writing. For more information about locks, see [Lock
 *        modes](https://cloud.google.com/spanner/docs/introspection/lock-statistics#explain-lock-modes).
 *        (Value: "LOCK_HINT_SHARED")
 *    @arg @c kGTLRSpanner_ReadRequest_LockHint_LockHintUnspecified Default
 *        value. `LOCK_HINT_UNSPECIFIED` is equivalent to `LOCK_HINT_SHARED`.
 *        (Value: "LOCK_HINT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *lockHint;

/**
 *  Optional. Order for the returned rows. By default, Spanner returns result
 *  rows in primary key order except for PartitionRead requests. For
 *  applications that don't require rows to be returned in primary key
 *  (`ORDER_BY_PRIMARY_KEY`) order, setting `ORDER_BY_NO_ORDER` option allows
 *  Spanner to optimize row retrieval, resulting in lower latencies in certain
 *  cases (for example, bulk point lookups).
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReadRequest_OrderBy_OrderByNoOrder Read rows are
 *        returned in any order. (Value: "ORDER_BY_NO_ORDER")
 *    @arg @c kGTLRSpanner_ReadRequest_OrderBy_OrderByPrimaryKey Read rows are
 *        returned in primary key order. In the event that this option is used
 *        in conjunction with the `partition_token` field, the API returns an
 *        `INVALID_ARGUMENT` error. (Value: "ORDER_BY_PRIMARY_KEY")
 *    @arg @c kGTLRSpanner_ReadRequest_OrderBy_OrderByUnspecified Default value.
 *        `ORDER_BY_UNSPECIFIED` is equivalent to `ORDER_BY_PRIMARY_KEY`.
 *        (Value: "ORDER_BY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  If present, results are restricted to the specified partition previously
 *  created using `PartitionRead`. There must be an exact match for the values
 *  of fields common to this message and the PartitionReadRequest message used
 *  to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  If this request is resuming a previously interrupted read, `resume_token`
 *  should be copied from the last PartialResultSet yielded before the
 *  interruption. Doing this enables the new read to resume where the last read
 *  left off. The rest of the request parameters must exactly match the request
 *  that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The transaction to use. If none is provided, the default is a temporary
 *  read-only transaction with strong concurrency.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Message type to initiate a read-write transaction. Currently this
 *  transaction type has no options.
 */
@interface GTLRSpanner_ReadWrite : GTLRObject

/**
 *  Optional. Clients should pass the transaction ID of the previous transaction
 *  attempt that was aborted if this transaction is being executed on a
 *  multiplexed session.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *multiplexedSessionPreviousTransactionId;

/**
 *  Read lock mode for the transaction.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReadWrite_ReadLockMode_Optimistic Optimistic lock
 *        mode. Locks for reads within the transaction are not acquired on read.
 *        Instead the locks are acquired on a commit to validate that
 *        read/queried data has not changed since the transaction started.
 *        Semantics described only applies to SERIALIZABLE isolation. (Value:
 *        "OPTIMISTIC")
 *    @arg @c kGTLRSpanner_ReadWrite_ReadLockMode_Pessimistic Pessimistic lock
 *        mode. Read locks are acquired immediately on read. Semantics described
 *        only applies to SERIALIZABLE isolation. (Value: "PESSIMISTIC")
 *    @arg @c kGTLRSpanner_ReadWrite_ReadLockMode_ReadLockModeUnspecified
 *        Default value. * If isolation level is REPEATABLE_READ, then it is an
 *        error to specify `read_lock_mode`. Locking semantics default to
 *        `OPTIMISTIC`. No validation checks are done for reads, except to
 *        validate that the data that was served at the snapshot time is
 *        unchanged at commit time in the following cases: 1. reads done as part
 *        of queries that use `SELECT FOR UPDATE` 2. reads done as part of
 *        statements with a `LOCK_SCANNED_RANGES` hint 3. reads done as part of
 *        DML statements * At all other isolation levels, if `read_lock_mode` is
 *        the default value, then pessimistic read locks are used. (Value:
 *        "READ_LOCK_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *readLockMode;

@end


/**
 *  ReplicaComputeCapacity describes the amount of server resources that are
 *  allocated to each replica identified by the replica selection.
 */
@interface GTLRSpanner_ReplicaComputeCapacity : GTLRObject

/**
 *  The number of nodes allocated to each replica. This may be zero in API
 *  responses for instances that are not yet in state `READY`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  The number of processing units allocated to each replica. This may be zero
 *  in API responses for instances that are not yet in state `READY`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *processingUnits;

/**
 *  Required. Identifies replicas by specified properties. All replicas in the
 *  selection have the same amount of compute capacity.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceReplicaSelection *replicaSelection;

@end


/**
 *  GTLRSpanner_ReplicaInfo
 */
@interface GTLRSpanner_ReplicaInfo : GTLRObject

/**
 *  If true, this location is designated as the default leader location where
 *  leader replicas are placed. See the [region types
 *  documentation](https://cloud.google.com/spanner/docs/instances#region_types)
 *  for more details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultLeaderLocation;

/** The location of the serving resources, e.g., "us-central1". */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The type of replica.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_ReadOnly Read-only replicas only
 *        support reads (not writes). Read-only replicas: * Maintain a full copy
 *        of your data. * Serve reads. * Do not participate in voting to commit
 *        writes. * Are not eligible to become a leader. (Value: "READ_ONLY")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_ReadWrite Read-write replicas
 *        support both reads and writes. These replicas: * Maintain a full copy
 *        of your data. * Serve reads. * Can vote whether to commit a write. *
 *        Participate in leadership election. * Are eligible to become a leader.
 *        (Value: "READ_WRITE")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_TypeUnspecified Not specified.
 *        (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_Witness Witness replicas don't
 *        support reads but do participate in voting to commit writes. Witness
 *        replicas: * Do not maintain a full copy of data. * Do not serve reads.
 *        * Vote whether to commit writes. * Participate in leader election but
 *        are not eligible to become leader. (Value: "WITNESS")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The directed read replica selector. Callers must provide one or more of the
 *  following fields for replica selection: * `location` - The location must be
 *  one of the regions within the multi-region configuration of your database. *
 *  `type` - The type of the replica. Some examples of using replica_selectors
 *  are: * `location:us-east1` --> The "us-east1" replica(s) of any available
 *  type is used to process the request. * `type:READ_ONLY` --> The "READ_ONLY"
 *  type replica(s) in the nearest available location are used to process the
 *  request. * `location:us-east1 type:READ_ONLY` --> The "READ_ONLY" type
 *  replica(s) in location "us-east1" is used to process the request.
 */
@interface GTLRSpanner_ReplicaSelection : GTLRObject

/**
 *  The location or region of the serving requests, for example, "us-east1".
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The type of replica.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReplicaSelection_Type_ReadOnly Read-only replicas
 *        only support reads (not writes). (Value: "READ_ONLY")
 *    @arg @c kGTLRSpanner_ReplicaSelection_Type_ReadWrite Read-write replicas
 *        support both reads and writes. (Value: "READ_WRITE")
 *    @arg @c kGTLRSpanner_ReplicaSelection_Type_TypeUnspecified Not specified.
 *        (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Common request options for various APIs.
 */
@interface GTLRSpanner_RequestOptions : GTLRObject

/**
 *  Priority for the request.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityHigh This specifies
 *        that the request is high priority. (Value: "PRIORITY_HIGH")
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityLow This specifies
 *        that the request is low priority. (Value: "PRIORITY_LOW")
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityMedium This specifies
 *        that the request is medium priority. (Value: "PRIORITY_MEDIUM")
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityUnspecified
 *        `PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`. (Value:
 *        "PRIORITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *priority;

/**
 *  A per-request tag which can be applied to queries or reads, used for
 *  statistics collection. Both `request_tag` and `transaction_tag` can be
 *  specified for a read or query that belongs to a transaction. This field is
 *  ignored for requests where it's not applicable (for example,
 *  `CommitRequest`). Legal characters for `request_tag` values are all
 *  printable characters (ASCII 32 - 126) and the length of a request_tag is
 *  limited to 50 characters. Values that exceed this limit are truncated. Any
 *  leading underscore (_) characters are removed from the string.
 */
@property(nonatomic, copy, nullable) NSString *requestTag;

/**
 *  A tag used for statistics collection about this transaction. Both
 *  `request_tag` and `transaction_tag` can be specified for a read or query
 *  that belongs to a transaction. The value of transaction_tag should be the
 *  same for all requests belonging to the same transaction. If this request
 *  doesn't belong to any transaction, `transaction_tag` is ignored. Legal
 *  characters for `transaction_tag` values are all printable characters (ASCII
 *  32 - 126) and the length of a `transaction_tag` is limited to 50 characters.
 *  Values that exceed this limit are truncated. Any leading underscore (_)
 *  characters are removed from the string.
 */
@property(nonatomic, copy, nullable) NSString *transactionTag;

@end


/**
 *  Encryption configuration for the restored database.
 */
@interface GTLRSpanner_RestoreDatabaseEncryptionConfig : GTLRObject

/**
 *  Required. The encryption type of the restored database.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_CustomerManagedEncryption
 *        Use customer managed encryption. If specified, `kms_key_name` must
 *        must contain a valid Cloud KMS key. (Value:
 *        "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionTypeUnspecified
 *        Unspecified. Do not use. (Value: "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_GoogleDefaultEncryption
 *        Use Google default encryption. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption
 *        This is the default option when encryption_config is not specified.
 *        (Value: "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Optional. This field is maintained for backwards compatibility. For new
 *  callers, we recommend using `kms_key_names` to specify the KMS key. Only use
 *  `kms_key_name` if the location of the KMS key matches the database
 *  instance's configuration (location) exactly. For example, if the KMS
 *  location is in `us-central1` or `nam3`, then the database instance must also
 *  be in `us-central1` or `nam3`. The Cloud KMS key that is used to encrypt and
 *  decrypt the restored database. Set this field only when encryption_type is
 *  `CUSTOMER_MANAGED_ENCRYPTION`. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

/**
 *  Optional. Specifies the KMS configuration for one or more keys used to
 *  encrypt the database. Values have the form
 *  `projects//locations//keyRings//cryptoKeys/`. The keys referenced by
 *  `kms_key_names` must fully cover all regions of the database's instance
 *  configuration. Some examples: * For regional (single-region) instance
 *  configurations, specify a regional location KMS key. * For multi-region
 *  instance configurations of type `GOOGLE_MANAGED`, either specify a
 *  multi-region location KMS key or multiple regional location KMS keys that
 *  cover all regions in the instance configuration. * For an instance
 *  configuration of type `USER_MANAGED`, specify only regional location KMS
 *  keys to cover each region in the instance configuration. Multi-region
 *  location KMS keys aren't supported for `USER_MANAGED` type instance
 *  configurations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kmsKeyNames;

@end


/**
 *  Metadata type for the long-running operation returned by RestoreDatabase.
 */
@interface GTLRSpanner_RestoreDatabaseMetadata : GTLRObject

/** Information about the backup used to restore the database. */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupInfo *backupInfo;

/**
 *  The time at which cancellation of this operation was received.
 *  Operations.CancelOperation starts asynchronous cancellation on a
 *  long-running operation. The server makes a best effort to cancel the
 *  operation, but success is not guaranteed. Clients can use
 *  Operations.GetOperation or other methods to check whether the cancellation
 *  succeeded or whether the operation completed despite cancellation. On
 *  successful cancellation, the operation is not deleted; instead, it becomes
 *  an operation with an Operation.error value with a google.rpc.Status.code of
 *  1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** Name of the database being created and restored to. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If exists, the name of the long-running operation that will be used to track
 *  the post-restore optimization process to optimize the performance of the
 *  restored database, and remove the dependency on the restore source. The name
 *  is of the form `projects//instances//databases//operations/` where the is
 *  the name of database being created and restored to. The metadata type of the
 *  long-running operation is OptimizeRestoredDatabaseMetadata. This
 *  long-running operation will be automatically created by the system after the
 *  RestoreDatabase long-running operation completes successfully. This
 *  operation will not be created if the restore was not successful.
 */
@property(nonatomic, copy, nullable) NSString *optimizeDatabaseOperationName;

/** The progress of the RestoreDatabase operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreDatabaseMetadata_SourceType_Backup A backup
 *        was used as the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRSpanner_RestoreDatabaseMetadata_SourceType_TypeUnspecified No
 *        restore associated. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  The request for RestoreDatabase.
 */
@interface GTLRSpanner_RestoreDatabaseRequest : GTLRObject

/**
 *  Name of the backup from which to restore. Values are of the form
 *  `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  Required. The id of the database to create and restore to. This database
 *  must not already exist. The `database_id` appended to `parent` forms the
 *  full database name of the form `projects//instances//databases/`.
 */
@property(nonatomic, copy, nullable) NSString *databaseId;

/**
 *  Optional. An encryption configuration describing the encryption type and key
 *  resources in Cloud KMS used to encrypt/decrypt the database to restore to.
 *  If this field is not specified, the restored database will use the same
 *  encryption configuration as the backup by default, namely encryption_type =
 *  `USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RestoreDatabaseEncryptionConfig *encryptionConfig;

@end


/**
 *  Information about the database restore.
 */
@interface GTLRSpanner_RestoreInfo : GTLRObject

/**
 *  Information about the backup used to restore the database. The backup may no
 *  longer exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupInfo *backupInfo;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreInfo_SourceType_Backup A backup was used as
 *        the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRSpanner_RestoreInfo_SourceType_TypeUnspecified No restore
 *        associated. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  Results from Read or ExecuteSql.
 */
@interface GTLRSpanner_ResultSet : GTLRObject

/** Metadata about the result set, such as row type information. */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Optional. A precommit token is included if the read-write transaction is on
 *  a multiplexed session. Pass the precommit token with the highest sequence
 *  number from this transaction attempt to the Commit request for this
 *  transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_MultiplexedSessionPrecommitToken *precommitToken;

/**
 *  Each element in `rows` is a row whose format is defined by
 *  metadata.row_type. The ith element in each row matches the ith field in
 *  metadata.row_type. Elements are encoded based on type as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *rows;

/**
 *  Query plan and execution statistics for the SQL statement that produced this
 *  result set. These can be requested by setting ExecuteSqlRequest.query_mode.
 *  DML statements always produce stats containing the number of rows modified,
 *  unless executed using the ExecuteSqlRequest.QueryMode.PLAN
 *  ExecuteSqlRequest.query_mode. Other fields might or might not be populated,
 *  based on the ExecuteSqlRequest.query_mode.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

@end


/**
 *  Metadata about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetMetadata : GTLRObject

/**
 *  Indicates the field names and types for the rows in the result set. For
 *  example, a SQL query like `"SELECT UserId, UserName FROM Users"` could
 *  return a `row_type` value like: "fields": [ { "name": "UserId", "type": {
 *  "code": "INT64" } }, { "name": "UserName", "type": { "code": "STRING" } }, ]
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *rowType;

/**
 *  If the read or SQL query began a transaction as a side-effect, the
 *  information about the new transaction is yielded here.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

/**
 *  A SQL query can be parameterized. In PLAN mode, these parameters can be
 *  undeclared. This indicates the field names and types for those undeclared
 *  parameters in the SQL query. For example, a SQL query like `"SELECT * FROM
 *  Users where UserId = \@userId and UserName = \@userName "` could return a
 *  `undeclared_parameters` value like: "fields": [ { "name": "UserId", "type":
 *  { "code": "INT64" } }, { "name": "UserName", "type": { "code": "STRING" } },
 *  ]
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *undeclaredParameters;

@end


/**
 *  Additional statistics about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetStats : GTLRObject

/** QueryPlan for the query associated with this result. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryPlan *queryPlan;

/**
 *  Aggregated statistics from the execution of the query. Only present when the
 *  query is profiled. For example, a query could return the statistics as
 *  follows: { "rows_returned": "3", "elapsed_time": "1.22 secs", "cpu_time":
 *  "1.19 secs" }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats_QueryStats *queryStats;

/**
 *  Standard DML returns an exact count of rows that were modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountExact;

/**
 *  Partitioned DML doesn't offer exactly-once semantics, so it returns a lower
 *  bound of the rows modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountLowerBound;

@end


/**
 *  Aggregated statistics from the execution of the query. Only present when the
 *  query is profiled. For example, a query could return the statistics as
 *  follows: { "rows_returned": "3", "elapsed_time": "1.22 secs", "cpu_time":
 *  "1.19 secs" }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ResultSetStats_QueryStats : GTLRObject
@end


/**
 *  The request for Rollback.
 */
@interface GTLRSpanner_RollbackRequest : GTLRObject

/**
 *  Required. The transaction to roll back.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  Scan is a structure which describes Cloud Key Visualizer scan information.
 */
@interface GTLRSpanner_Scan : GTLRObject

/** Additional information provided by the implementer. */
@property(nonatomic, strong, nullable) GTLRSpanner_Scan_Details *details;

/** The upper bound for when the scan is defined. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  The unique name of the scan, specific to the Database service implementing
 *  this interface.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Cloud Key Visualizer scan data. Note, this field is not
 *  available to the ListScans method.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ScanData *scanData;

/**
 *  A range of time (inclusive) for when the scan is defined. The lower bound
 *  for when the scan is defined.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Additional information provided by the implementer.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Scan_Details : GTLRObject
@end


/**
 *  ScanData contains Cloud Key Visualizer scan data used by the caller to
 *  construct a visualization.
 */
@interface GTLRSpanner_ScanData : GTLRObject

/**
 *  Cloud Key Visualizer scan data. The range of time this information covers is
 *  captured via the above time range fields. Note, this field is not available
 *  to the ListScans method.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_VisualizationData *data;

/** The upper bound for when the contained data is defined. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  A range of time (inclusive) for when the contained data is defined. The
 *  lower bound for when the contained data is defined.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  A session in the Cloud Spanner API.
 */
@interface GTLRSpanner_Session : GTLRObject

/**
 *  Output only. The approximate timestamp when the session is last used. It's
 *  typically earlier than the actual last use time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *approximateLastUseTime;

/** Output only. The timestamp when the session is created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The database role which created this session. */
@property(nonatomic, copy, nullable) NSString *creatorRole;

/**
 *  The labels for the session. * Label keys must be between 1 and 63 characters
 *  long and must conform to the following regular expression:
 *  `[a-z]([-a-z0-9]*[a-z0-9])?`. * Label values must be between 0 and 63
 *  characters long and must conform to the regular expression
 *  `([a-z]([-a-z0-9]*[a-z0-9])?)?`. * No more than 64 labels can be associated
 *  with a given session. See https://goo.gl/xmQnxf for more information on and
 *  examples of labels.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Session_Labels *labels;

/**
 *  Optional. If `true`, specifies a multiplexed session. Use a multiplexed
 *  session for multiple, concurrent read-only operations. Don't use them for
 *  read-write transactions, partitioned reads, or partitioned queries. Use
 *  `sessions.create` to create multiplexed sessions. Don't use
 *  BatchCreateSessions to create a multiplexed session. You can't delete or
 *  list multiplexed sessions.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *multiplexed;

/** Output only. The name of the session. This is always system-assigned. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The labels for the session. * Label keys must be between 1 and 63 characters
 *  long and must conform to the following regular expression:
 *  `[a-z]([-a-z0-9]*[a-z0-9])?`. * Label values must be between 0 and 63
 *  characters long and must conform to the regular expression
 *  `([a-z]([-a-z0-9]*[a-z0-9])?)?`. * No more than 64 labels can be associated
 *  with a given session. See https://goo.gl/xmQnxf for more information on and
 *  examples of labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Session_Labels : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRSpanner_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Policy *policy;

@end


/**
 *  Condensed representation of a node and its subtree. Only present for
 *  `SCALAR` PlanNode(s).
 */
@interface GTLRSpanner_ShortRepresentation : GTLRObject

/**
 *  A string representation of the expression subtree rooted at this node.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases where
 *  the `description` string of this node references a `SCALAR` subquery
 *  contained in the expression subtree rooted at this node. The referenced
 *  `SCALAR` subquery may not necessarily be a direct child of this node.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation_Subqueries *subqueries;

@end


/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases where
 *  the `description` string of this node references a `SCALAR` subquery
 *  contained in the expression subtree rooted at this node. The referenced
 *  `SCALAR` subquery may not necessarily be a direct child of this node.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ShortRepresentation_Subqueries : GTLRObject
@end


/**
 *  Message type for a single-region quorum.
 */
@interface GTLRSpanner_SingleRegionQuorum : GTLRObject

/**
 *  Required. The location of the serving region, for example, "us-central1".
 *  The location must be one of the regions within the dual-region instance
 *  configuration of your database. The list of valid locations is available
 *  using the GetInstanceConfig API. This should only be used if you plan to
 *  change quorum to the single-region quorum type.
 */
@property(nonatomic, copy, nullable) NSString *servingLocation;

@end


/**
 *  The split points of a table or an index.
 */
@interface GTLRSpanner_SplitPoints : GTLRObject

/**
 *  Optional. The expiration timestamp of the split points. A timestamp in the
 *  past means immediate expiration. The maximum value can be 30 days in the
 *  future. Defaults to 10 days in the future if not specified.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  The index to split. If specified, the `table` field must refer to the
 *  index's base table.
 */
@property(nonatomic, copy, nullable) NSString *index;

/** Required. The list of split keys. In essence, the split boundaries. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Key *> *keys;

/** The table to split. */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  A single DML statement.
 */
@interface GTLRSpanner_Statement : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the DML string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It's an
 *  error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Statement_Params *params;

/**
 *  It isn't always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL statement parameters. See the definition of Type for more
 *  information about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Statement_ParamTypes *paramTypes;

/** Required. The DML string. */
@property(nonatomic, copy, nullable) NSString *sql;

@end


/**
 *  Parameter names and values that bind to placeholders in the DML string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It's an
 *  error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Statement_Params : GTLRObject
@end


/**
 *  It isn't always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL statement parameters. See the definition of Type for more
 *  information about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Statement_ParamTypes : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRSpanner_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRSpanner_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Status_Details_Item : GTLRObject
@end


/**
 *  `StructType` defines the fields of a STRUCT type.
 */
@interface GTLRSpanner_StructType : GTLRObject

/**
 *  The list of fields that make up this struct. Order is significant, because
 *  values of this struct type are represented as lists, where the order of
 *  field values matches the order of fields in the StructType. In turn, the
 *  order of fields matches the order of columns in a read request, or the order
 *  of fields in the `SELECT` clause of a query.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Field *> *fields;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsRequest : GTLRObject

/**
 *  REQUIRED: The set of permissions to check for 'resource'. Permissions with
 *  wildcards (such as '*', 'spanner.*', 'spanner.instances.*') are not allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  A transaction.
 */
@interface GTLRSpanner_Transaction : GTLRObject

/**
 *  `id` may be used to identify the transaction in subsequent Read, ExecuteSql,
 *  Commit, or Rollback calls. Single-use read-only transactions do not have
 *  IDs, because single-use transactions do not support multiple requests.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  A precommit token is included in the response of a BeginTransaction request
 *  if the read-write transaction is on a multiplexed session and a mutation_key
 *  was specified in the BeginTransaction. The precommit token with the highest
 *  sequence number from this transaction attempt should be passed to the Commit
 *  request for this transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_MultiplexedSessionPrecommitToken *precommitToken;

/**
 *  For snapshot read-only transactions, the read timestamp chosen for the
 *  transaction. Not returned by default: see
 *  TransactionOptions.ReadOnly.return_read_timestamp. A timestamp in RFC3339
 *  UTC \\"Zulu\\" format, accurate to nanoseconds. Example:
 *  `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

@end


/**
 *  Options to use for transactions.
 */
@interface GTLRSpanner_TransactionOptions : GTLRObject

/**
 *  When `exclude_txn_from_change_streams` is set to `true`, it prevents read or
 *  write transactions from being tracked in change streams. * If the DDL option
 *  `allow_txn_exclusion` is set to `true`, then the updates made within this
 *  transaction aren't recorded in the change stream. * If you don't set the DDL
 *  option `allow_txn_exclusion` or if it's set to `false`, then the updates
 *  made within this transaction are recorded in the change stream. When
 *  `exclude_txn_from_change_streams` is set to `false` or not set,
 *  modifications from this transaction are recorded in all change streams that
 *  are tracking columns modified by these transactions. The
 *  `exclude_txn_from_change_streams` option can only be specified for
 *  read-write or partitioned DML transactions, otherwise the API returns an
 *  `INVALID_ARGUMENT` error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *excludeTxnFromChangeStreams;

/**
 *  Isolation level for the transaction.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_TransactionOptions_IsolationLevel_IsolationLevelUnspecified
 *        Default value. If the value is not specified, the `SERIALIZABLE`
 *        isolation level is used. (Value: "ISOLATION_LEVEL_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_TransactionOptions_IsolationLevel_RepeatableRead All
 *        reads performed during the transaction observe a consistent snapshot
 *        of the database, and the transaction is only successfully committed in
 *        the absence of conflicts between its updates and any concurrent
 *        updates that have occurred since that snapshot. Consequently, in
 *        contrast to `SERIALIZABLE` transactions, only write-write conflicts
 *        are detected in snapshot transactions. This isolation level does not
 *        support Read-only and Partitioned DML transactions. When
 *        `REPEATABLE_READ` is specified on a read-write transaction, the
 *        locking semantics default to `OPTIMISTIC`. (Value: "REPEATABLE_READ")
 *    @arg @c kGTLRSpanner_TransactionOptions_IsolationLevel_Serializable All
 *        transactions appear as if they executed in a serial order, even if
 *        some of the reads, writes, and other operations of distinct
 *        transactions actually occurred in parallel. Spanner assigns commit
 *        timestamps that reflect the order of committed transactions to
 *        implement this property. Spanner offers a stronger guarantee than
 *        serializability called external consistency. For more information, see
 *        [TrueTime and external
 *        consistency](https://cloud.google.com/spanner/docs/true-time-external-consistency#serializability).
 *        (Value: "SERIALIZABLE")
 */
@property(nonatomic, copy, nullable) NSString *isolationLevel;

/**
 *  Partitioned DML transaction. Authorization to begin a Partitioned DML
 *  transaction requires `spanner.databases.beginPartitionedDmlTransaction`
 *  permission on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionedDml *partitionedDml;

/**
 *  Transaction does not write. Authorization to begin a read-only transaction
 *  requires `spanner.databases.beginReadOnlyTransaction` permission on the
 *  `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadOnly *readOnly;

/**
 *  Transaction may write. Authorization to begin a read-write transaction
 *  requires `spanner.databases.beginOrRollbackReadWriteTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadWrite *readWrite;

@end


/**
 *  This message is used to select the transaction in which a Read or ExecuteSql
 *  call runs. See TransactionOptions for more information about transactions.
 */
@interface GTLRSpanner_TransactionSelector : GTLRObject

/**
 *  Begin a new transaction and execute this read or SQL query in it. The
 *  transaction ID of the new transaction is returned in
 *  ResultSetMetadata.transaction, which is a Transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *begin;

/**
 *  Execute the read or SQL query in a previously-started transaction.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Execute the read or SQL query in a temporary transaction. This is the most
 *  efficient way to execute a transaction that consists of a single SQL query.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUse;

@end


/**
 *  `Type` indicates the type of a Cloud Spanner value, as might be stored in a
 *  table cell or returned from an SQL query.
 */
@interface GTLRSpanner_Type : GTLRObject

/**
 *  If code == ARRAY, then `array_element_type` is the type of the array
 *  elements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *arrayElementType;

/**
 *  Required. The TypeCode for this type.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Type_Code_Array Encoded as `list`, where the list
 *        elements are represented according to array_element_type. (Value:
 *        "ARRAY")
 *    @arg @c kGTLRSpanner_Type_Code_Bool Encoded as JSON `true` or `false`.
 *        (Value: "BOOL")
 *    @arg @c kGTLRSpanner_Type_Code_Bytes Encoded as a base64-encoded `string`,
 *        as described in RFC 4648, section 4. (Value: "BYTES")
 *    @arg @c kGTLRSpanner_Type_Code_Date Encoded as `string` in RFC 3339 date
 *        format. (Value: "DATE")
 *    @arg @c kGTLRSpanner_Type_Code_Enum Encoded as `string`, in decimal
 *        format. (Value: "ENUM")
 *    @arg @c kGTLRSpanner_Type_Code_Float32 Encoded as `number`, or the strings
 *        `"NaN"`, `"Infinity"`, or `"-Infinity"`. (Value: "FLOAT32")
 *    @arg @c kGTLRSpanner_Type_Code_Float64 Encoded as `number`, or the strings
 *        `"NaN"`, `"Infinity"`, or `"-Infinity"`. (Value: "FLOAT64")
 *    @arg @c kGTLRSpanner_Type_Code_Int64 Encoded as `string`, in decimal
 *        format. (Value: "INT64")
 *    @arg @c kGTLRSpanner_Type_Code_Interval Encoded as `string`, in `ISO8601`
 *        duration format - `P[n]Y[n]M[n]DT[n]H[n]M[n[.fraction]]S` where `n` is
 *        an integer. For example, `P1Y2M3DT4H5M6.5S` represents time duration
 *        of 1 year, 2 months, 3 days, 4 hours, 5 minutes, and 6.5 seconds.
 *        (Value: "INTERVAL")
 *    @arg @c kGTLRSpanner_Type_Code_Json Encoded as a JSON-formatted `string`
 *        as described in RFC 7159. The following rules are applied when parsing
 *        JSON input: - Whitespace characters are not preserved. - If a JSON
 *        object has duplicate keys, only the first key is preserved. - Members
 *        of a JSON object are not guaranteed to have their order preserved. -
 *        JSON array elements will have their order preserved. (Value: "JSON")
 *    @arg @c kGTLRSpanner_Type_Code_Numeric Encoded as `string`, in decimal
 *        format or scientific notation format. Decimal format:
 *        `[+-]Digits[.[Digits]]` or `+-.Digits` Scientific notation:
 *        `[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
 *        `+-.Digits[ExponentIndicator[+-]Digits]` (ExponentIndicator is `"e"`
 *        or `"E"`) (Value: "NUMERIC")
 *    @arg @c kGTLRSpanner_Type_Code_Proto Encoded as a base64-encoded `string`,
 *        as described in RFC 4648, section 4. (Value: "PROTO")
 *    @arg @c kGTLRSpanner_Type_Code_String Encoded as `string`. (Value:
 *        "STRING")
 *    @arg @c kGTLRSpanner_Type_Code_Struct Encoded as `list`, where list
 *        element `i` is represented according to
 *        [struct_type.fields[i]][google.spanner.v1.StructType.fields]. (Value:
 *        "STRUCT")
 *    @arg @c kGTLRSpanner_Type_Code_Timestamp Encoded as `string` in RFC 3339
 *        timestamp format. The time zone must be present, and must be `"Z"`. If
 *        the schema has the column option `allow_commit_timestamp=true`, the
 *        placeholder string `"spanner.commit_timestamp()"` can be used to
 *        instruct the system to insert the commit timestamp associated with the
 *        transaction commit. (Value: "TIMESTAMP")
 *    @arg @c kGTLRSpanner_Type_Code_TypeCodeUnspecified Not specified. (Value:
 *        "TYPE_CODE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Type_Code_Uuid Encoded as `string`, in lower-case
 *        hexa-decimal format, as described in RFC 9562, section 4. (Value:
 *        "UUID")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  If code == PROTO or code == ENUM, then `proto_type_fqn` is the fully
 *  qualified name of the proto type representing the proto/enum definition.
 */
@property(nonatomic, copy, nullable) NSString *protoTypeFqn;

/**
 *  If code == STRUCT, then `struct_type` provides type information for the
 *  struct's fields.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *structType;

/**
 *  The TypeAnnotationCode that disambiguates SQL type that Spanner will use to
 *  represent values of this type during query processing. This is necessary for
 *  some type codes because a single TypeCode can be mapped to different SQL
 *  types depending on the SQL dialect. type_annotation typically is not needed
 *  to process the content of a value (it doesn't affect serialization) and
 *  clients can ignore it on the read path.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_PgJsonb PostgreSQL compatible
 *        JSONB type. This annotation needs to be applied to Type instances
 *        having JSON type code to specify that values of this type should be
 *        treated as PostgreSQL JSONB values. Currently this annotation is
 *        always needed for JSON when a client interacts with PostgreSQL-enabled
 *        Spanner databases. (Value: "PG_JSONB")
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_PgNumeric PostgreSQL compatible
 *        NUMERIC type. This annotation needs to be applied to Type instances
 *        having NUMERIC type code to specify that values of this type should be
 *        treated as PostgreSQL NUMERIC values. Currently this annotation is
 *        always needed for NUMERIC when a client interacts with
 *        PostgreSQL-enabled Spanner databases. (Value: "PG_NUMERIC")
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_PgOid PostgreSQL compatible OID
 *        type. This annotation can be used by a client interacting with
 *        PostgreSQL-enabled Spanner database to specify that a value should be
 *        treated using the semantics of the OID type. (Value: "PG_OID")
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_TypeAnnotationCodeUnspecified Not
 *        specified. (Value: "TYPE_ANNOTATION_CODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *typeAnnotation;

@end


/**
 *  Metadata type for the operation returned by UpdateDatabaseDdl.
 */
@interface GTLRSpanner_UpdateDatabaseDdlMetadata : GTLRObject

/**
 *  The brief action info for the DDL statements. `actions[i]` is the brief info
 *  for `statements[i]`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_DdlStatementActionInfo *> *actions;

/**
 *  Reports the commit timestamps of all statements that have succeeded so far,
 *  where `commit_timestamps[i]` is the commit timestamp for the statement
 *  `statements[i]`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDateTime *> *commitTimestamps;

/** The database being modified. */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  The progress of the UpdateDatabaseDdl operations. All DDL statements will
 *  have continuously updating progress, and `progress[i]` is the operation
 *  progress for `statements[i]`. Also, `progress[i]` will have start time and
 *  end time populated with commit timestamp of operation, as well as a progress
 *  of 100% once the operation has completed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_OperationProgress *> *progress;

/**
 *  For an update this list contains all the statements. For an individual
 *  statement, this list contains only that statement.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

/**
 *  Output only. When true, indicates that the operation is throttled, for
 *  example, due to resource constraints. When resources become available the
 *  operation will resume and this field will be false again.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *throttled;

@end


/**
 *  Enqueues the given DDL statements to be applied, in order but not
 *  necessarily all at once, to the database schema at some point (or points) in
 *  the future. The server checks that the statements are executable
 *  (syntactically valid, name tables that exist, etc.) before enqueueing them,
 *  but they may still fail upon later execution (for example, if a statement
 *  from another batch of statements is applied first and it conflicts in some
 *  way, or if there is some data-related problem like a `NULL` value in a
 *  column to which `NOT NULL` would be added). If a statement fails, all
 *  subsequent statements in the batch are automatically cancelled. Each batch
 *  of statements is assigned a name which can be used with the Operations API
 *  to monitor progress. See the operation_id field for more details.
 */
@interface GTLRSpanner_UpdateDatabaseDdlRequest : GTLRObject

/**
 *  If empty, the new update request is assigned an automatically-generated
 *  operation ID. Otherwise, `operation_id` is used to construct the name of the
 *  resulting Operation. Specifying an explicit operation ID simplifies
 *  determining whether the statements were executed in the event that the
 *  UpdateDatabaseDdl call is replayed, or the return value is otherwise lost:
 *  the database and `operation_id` fields can be combined to form the `name` of
 *  the resulting longrunning.Operation: `/operations/`. `operation_id` should
 *  be unique within the database, and must be a valid identifier: `a-z*`. Note
 *  that automatically-generated operation IDs always begin with an underscore.
 *  If the named operation already exists, UpdateDatabaseDdl returns
 *  `ALREADY_EXISTS`.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/**
 *  Optional. Proto descriptors used by CREATE/ALTER PROTO BUNDLE statements.
 *  Contains a protobuf-serialized
 *  [google.protobuf.FileDescriptorSet](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto).
 *  To generate it, [install](https://grpc.io/docs/protoc-installation/) and run
 *  `protoc` with --include_imports and --descriptor_set_out. For example, to
 *  generate for moon/shot/app.proto, run ``` $protoc --proto_path=/app_path
 *  --proto_path=/lib_path \\ --include_imports \\
 *  --descriptor_set_out=descriptors.data \\ moon/shot/app.proto ``` For more
 *  details, see protobuffer [self
 *  description](https://developers.google.com/protocol-buffers/docs/techniques#self-description).
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *protoDescriptors;

/** Required. DDL statements to be applied to the database. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Metadata type for the operation returned by UpdateDatabase.
 */
@interface GTLRSpanner_UpdateDatabaseMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is best-effort).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The progress of the UpdateDatabase operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

/** The request for UpdateDatabase. */
@property(nonatomic, strong, nullable) GTLRSpanner_UpdateDatabaseRequest *request;

@end


/**
 *  The request for UpdateDatabase.
 */
@interface GTLRSpanner_UpdateDatabaseRequest : GTLRObject

/**
 *  Required. The database to update. The `name` field of the database is of the
 *  form `projects//instances//databases/`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Database *database;

/**
 *  Required. The list of fields to update. Currently, only
 *  `enable_drop_protection` field can be updated.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Metadata type for the operation returned by UpdateInstanceConfig.
 */
@interface GTLRSpanner_UpdateInstanceConfigMetadata : GTLRObject

/** The time at which this operation was cancelled. */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The desired instance configuration after updating. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/** The progress of the UpdateInstanceConfig operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceOperationProgress *progress;

@end


/**
 *  The request for UpdateInstanceConfig.
 */
@interface GTLRSpanner_UpdateInstanceConfigRequest : GTLRObject

/**
 *  Required. The user instance configuration to update, which must always
 *  include the instance configuration name. Otherwise, only fields mentioned in
 *  update_mask need be included. To prevent conflicts of concurrent updates,
 *  etag can be used.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/**
 *  Required. A mask specifying which fields in InstanceConfig should be
 *  updated. The field mask must always be specified; this prevents any future
 *  fields in InstanceConfig from being erased accidentally by clients that do
 *  not know about them. Only display_name and labels can be updated.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  An option to validate, but not actually execute, a request, and provide the
 *  same response.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateOnly;

@end


/**
 *  Metadata type for the operation returned by UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is guaranteed to succeed) and cannot be
 *  cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  The expected fulfillment period of this update operation.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_UpdateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodExtended
 *        Extended fulfillment period. It can take up to an hour for the
 *        operation to complete. (Value: "FULFILLMENT_PERIOD_EXTENDED")
 *    @arg @c kGTLRSpanner_UpdateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodNormal
 *        Normal fulfillment period. The operation is expected to complete
 *        within minutes. (Value: "FULFILLMENT_PERIOD_NORMAL")
 *    @arg @c kGTLRSpanner_UpdateInstanceMetadata_ExpectedFulfillmentPeriod_FulfillmentPeriodUnspecified
 *        Not specified. (Value: "FULFILLMENT_PERIOD_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *expectedFulfillmentPeriod;

/** The desired end state of the update. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/** The time at which UpdateInstance request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Metadata type for the operation returned by UpdateInstancePartition.
 */
@interface GTLRSpanner_UpdateInstancePartitionMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is guaranteed to succeed) and cannot be
 *  cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The desired end state of the update. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstancePartition *instancePartition;

/** The time at which UpdateInstancePartition request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for UpdateInstancePartition.
 */
@interface GTLRSpanner_UpdateInstancePartitionRequest : GTLRObject

/**
 *  Required. A mask specifying which fields in InstancePartition should be
 *  updated. The field mask must always be specified; this prevents any future
 *  fields in InstancePartition from being erased accidentally by clients that
 *  do not know about them.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *fieldMask;

/**
 *  Required. The instance partition to update, which must always include the
 *  instance partition name. Otherwise, only fields mentioned in field_mask need
 *  be included.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstancePartition *instancePartition;

@end


/**
 *  The request for UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceRequest : GTLRObject

/**
 *  Required. A mask specifying which fields in Instance should be updated. The
 *  field mask must always be specified; this prevents any future fields in
 *  Instance from being erased accidentally by clients that do not know about
 *  them.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *fieldMask;

/**
 *  Required. The instance to update, which must always include the instance
 *  name. Otherwise, only fields mentioned in field_mask need be included.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

@end


/**
 *  GTLRSpanner_VisualizationData
 */
@interface GTLRSpanner_VisualizationData : GTLRObject

/** The token signifying the end of a data_source. */
@property(nonatomic, copy, nullable) NSString *dataSourceEndToken;

/**
 *  The token delimiting a datasource name from the rest of a key in a
 *  data_source.
 */
@property(nonatomic, copy, nullable) NSString *dataSourceSeparatorToken;

/** The list of messages (info, alerts, ...) */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_DiagnosticMessage *> *diagnosticMessages;

/**
 *  We discretize the entire keyspace into buckets. Assuming each bucket has an
 *  inclusive keyrange and covers keys from k(i) ... k(n). In this case k(n)
 *  would be an end key for a given range. end_key_string is the collection of
 *  all such end keys
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *endKeyStrings;

/**
 *  Whether this scan contains PII.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasPii;

/**
 *  Keys of key ranges that contribute significantly to a given metric Can be
 *  thought of as heavy hitters.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *indexedKeys;

/** The token delimiting the key prefixes. */
@property(nonatomic, copy, nullable) NSString *keySeparator;

/**
 *  The unit for the key: e.g. 'key' or 'chunk'.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_VisualizationData_KeyUnit_Chunk Each entry
 *        corresponds to a chunk of keys (Value: "CHUNK")
 *    @arg @c kGTLRSpanner_VisualizationData_KeyUnit_Key Each entry corresponds
 *        to one key (Value: "KEY")
 *    @arg @c kGTLRSpanner_VisualizationData_KeyUnit_KeyUnitUnspecified Required
 *        default value (Value: "KEY_UNIT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *keyUnit;

/** The list of data objects for each metric. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Metric *> *metrics;

/**
 *  The list of extracted key prefix nodes used in the key prefix hierarchy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_PrefixNode *> *prefixNodes;

@end


/**
 *  Arguments to insert, update, insert_or_update, and replace operations.
 */
@interface GTLRSpanner_Write : GTLRObject

/**
 *  The names of the columns in table to be written. The list of columns must
 *  contain enough columns to allow Cloud Spanner to derive values for all
 *  primary key columns in the row(s) to be modified.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/** Required. The table whose rows will be written. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The values to be written. `values` can contain more than one list of values.
 *  If it does, then multiple rows are written, one for each entry in `values`.
 *  Each list in `values` must have exactly as many entries as there are entries
 *  in columns above. Sending multiple lists is equivalent to sending multiple
 *  `Mutation`s, each containing one `values` entry and repeating table and
 *  columns. Individual values in each list are encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *values;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
