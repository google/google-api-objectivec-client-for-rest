// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Spanner API (spanner/v1)
// Description:
//   Cloud Spanner is a managed, mission-critical, globally consistent and
//   scalable relational database service.
// Documentation:
//   https://cloud.google.com/spanner/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRSpanner_Backup;
@class GTLRSpanner_BackupInfo;
@class GTLRSpanner_Binding;
@class GTLRSpanner_ChildLink;
@class GTLRSpanner_CommitStats;
@class GTLRSpanner_ContextValue;
@class GTLRSpanner_CopyBackupEncryptionConfig;
@class GTLRSpanner_Database;
@class GTLRSpanner_DatabaseRole;
@class GTLRSpanner_Delete;
@class GTLRSpanner_DerivedMetric;
@class GTLRSpanner_DiagnosticMessage;
@class GTLRSpanner_EncryptionConfig;
@class GTLRSpanner_EncryptionInfo;
@class GTLRSpanner_ExecuteSqlRequest_Params;
@class GTLRSpanner_ExecuteSqlRequest_ParamTypes;
@class GTLRSpanner_Expr;
@class GTLRSpanner_Field;
@class GTLRSpanner_FreeInstanceMetadata;
@class GTLRSpanner_GetPolicyOptions;
@class GTLRSpanner_IndexedHotKey;
@class GTLRSpanner_IndexedHotKey_SparseHotKeys;
@class GTLRSpanner_IndexedKeyRangeInfos;
@class GTLRSpanner_IndexedKeyRangeInfos_KeyRangeInfos;
@class GTLRSpanner_Instance;
@class GTLRSpanner_Instance_Labels;
@class GTLRSpanner_InstanceConfig;
@class GTLRSpanner_InstanceConfig_Labels;
@class GTLRSpanner_InstanceOperationProgress;
@class GTLRSpanner_KeyRange;
@class GTLRSpanner_KeyRangeInfo;
@class GTLRSpanner_KeyRangeInfos;
@class GTLRSpanner_KeySet;
@class GTLRSpanner_LocalizedString;
@class GTLRSpanner_LocalizedString_Args;
@class GTLRSpanner_Metric;
@class GTLRSpanner_Metric_IndexedHotKeys;
@class GTLRSpanner_Metric_IndexedKeyRangeInfos;
@class GTLRSpanner_MetricMatrix;
@class GTLRSpanner_MetricMatrixRow;
@class GTLRSpanner_Mutation;
@class GTLRSpanner_Operation;
@class GTLRSpanner_Operation_Metadata;
@class GTLRSpanner_Operation_Response;
@class GTLRSpanner_OperationProgress;
@class GTLRSpanner_Partition;
@class GTLRSpanner_PartitionedDml;
@class GTLRSpanner_PartitionOptions;
@class GTLRSpanner_PartitionQueryRequest_Params;
@class GTLRSpanner_PartitionQueryRequest_ParamTypes;
@class GTLRSpanner_PlanNode;
@class GTLRSpanner_PlanNode_ExecutionStats;
@class GTLRSpanner_PlanNode_Metadata;
@class GTLRSpanner_Policy;
@class GTLRSpanner_PrefixNode;
@class GTLRSpanner_QueryOptions;
@class GTLRSpanner_QueryPlan;
@class GTLRSpanner_ReadOnly;
@class GTLRSpanner_ReadWrite;
@class GTLRSpanner_ReplicaInfo;
@class GTLRSpanner_RequestOptions;
@class GTLRSpanner_RestoreDatabaseEncryptionConfig;
@class GTLRSpanner_RestoreInfo;
@class GTLRSpanner_ResultSet;
@class GTLRSpanner_ResultSetMetadata;
@class GTLRSpanner_ResultSetStats;
@class GTLRSpanner_ResultSetStats_QueryStats;
@class GTLRSpanner_Scan;
@class GTLRSpanner_Scan_Details;
@class GTLRSpanner_ScanData;
@class GTLRSpanner_Session;
@class GTLRSpanner_Session_Labels;
@class GTLRSpanner_ShortRepresentation;
@class GTLRSpanner_ShortRepresentation_Subqueries;
@class GTLRSpanner_Statement;
@class GTLRSpanner_Statement_Params;
@class GTLRSpanner_Statement_ParamTypes;
@class GTLRSpanner_Status;
@class GTLRSpanner_Status_Details_Item;
@class GTLRSpanner_StructType;
@class GTLRSpanner_Transaction;
@class GTLRSpanner_TransactionOptions;
@class GTLRSpanner_TransactionSelector;
@class GTLRSpanner_Type;
@class GTLRSpanner_VisualizationData;
@class GTLRSpanner_Write;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRSpanner_Backup.databaseDialect

/**
 *  Default value. This value will create a database with the
 *  GOOGLE_STANDARD_SQL dialect.
 *
 *  Value: "DATABASE_DIALECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_DatabaseDialect_DatabaseDialectUnspecified;
/**
 *  Google standard SQL.
 *
 *  Value: "GOOGLE_STANDARD_SQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_DatabaseDialect_GoogleStandardSql;
/**
 *  PostgreSQL supported SQL.
 *
 *  Value: "POSTGRESQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_DatabaseDialect_Postgresql;

// ----------------------------------------------------------------------------
// GTLRSpanner_Backup.state

/**
 *  The pending backup is still being created. Operations on the backup may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_Creating;
/**
 *  The backup is complete and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ContextValue.severity

/**
 *  Severity level signaling an error "Error"
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Error;
/**
 *  Severity level signaling a non recoverable error "Fatal"
 *
 *  Value: "FATAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Fatal;
/**
 *  Lowest severity level "Info".
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Info;
/**
 *  Required default value.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_SeverityUnspecified;
/**
 *  Middle severity level "Warning".
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ContextValue_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRSpanner_CopyBackupEncryptionConfig.encryptionType

/**
 *  Use customer managed encryption. If specified, `kms_key_name` must contain a
 *  valid Cloud KMS key.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_CustomerManagedEncryption;
/**
 *  Unspecified. Do not use.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Use Google default encryption.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_GoogleDefaultEncryption;
/**
 *  This is the default option for CopyBackup when encryption_config is not
 *  specified. For example, if the source backup is using
 *  `Customer_Managed_Encryption`, the backup will be using the same Cloud KMS
 *  key as the source backup.
 *
 *  Value: "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption;

// ----------------------------------------------------------------------------
// GTLRSpanner_CreateDatabaseRequest.databaseDialect

/**
 *  Default value. This value will create a database with the
 *  GOOGLE_STANDARD_SQL dialect.
 *
 *  Value: "DATABASE_DIALECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_DatabaseDialectUnspecified;
/**
 *  Google standard SQL.
 *
 *  Value: "GOOGLE_STANDARD_SQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_GoogleStandardSql;
/**
 *  PostgreSQL supported SQL.
 *
 *  Value: "POSTGRESQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_Postgresql;

// ----------------------------------------------------------------------------
// GTLRSpanner_Database.databaseDialect

/**
 *  Default value. This value will create a database with the
 *  GOOGLE_STANDARD_SQL dialect.
 *
 *  Value: "DATABASE_DIALECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_DatabaseDialect_DatabaseDialectUnspecified;
/**
 *  Google standard SQL.
 *
 *  Value: "GOOGLE_STANDARD_SQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_DatabaseDialect_GoogleStandardSql;
/**
 *  PostgreSQL supported SQL.
 *
 *  Value: "POSTGRESQL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_DatabaseDialect_Postgresql;

// ----------------------------------------------------------------------------
// GTLRSpanner_Database.state

/**
 *  The database is still being created. Operations on the database may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_Creating;
/**
 *  The database is fully created and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_Ready;
/**
 *  The database is fully created and ready for use, but is still being
 *  optimized for performance and cannot handle full load. In this state, the
 *  database still references the backup it was restore from, preventing the
 *  backup from being deleted. When optimizations are complete, the full
 *  performance of the database will be restored, and the database will
 *  transition to `READY` state.
 *
 *  Value: "READY_OPTIMIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_ReadyOptimizing;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_DiagnosticMessage.severity

/**
 *  Severity level signaling an error "Error"
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Error;
/**
 *  Severity level signaling a non recoverable error "Fatal"
 *
 *  Value: "FATAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Fatal;
/**
 *  Lowest severity level "Info".
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Info;
/**
 *  Required default value.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_SeverityUnspecified;
/**
 *  Middle severity level "Warning".
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_DiagnosticMessage_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRSpanner_EncryptionInfo.encryptionType

/**
 *  The data is encrypted at rest with a key that is managed by the customer.
 *  The active version of the key. `kms_key_version` will be populated, and
 *  `encryption_status` may be populated.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_EncryptionInfo_EncryptionType_CustomerManagedEncryption;
/**
 *  The data is encrypted at rest with a key that is fully managed by Google. No
 *  key version or status will be populated. This is the default state.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_EncryptionInfo_EncryptionType_GoogleDefaultEncryption;
/**
 *  Encryption type was not specified, though data at rest remains encrypted.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_EncryptionInfo_EncryptionType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ExecuteSqlRequest.queryMode

/**
 *  The default mode. Only the statement results are returned.
 *
 *  Value: "NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal;
/**
 *  This mode returns only the query plan, without any results or execution
 *  statistics information.
 *
 *  Value: "PLAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan;
/**
 *  This mode returns both the query plan and the execution statistics along
 *  with the results.
 *
 *  Value: "PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile;

// ----------------------------------------------------------------------------
// GTLRSpanner_FreeInstanceMetadata.expireBehavior

/**
 *  Not specified.
 *
 *  Value: "EXPIRE_BEHAVIOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_ExpireBehaviorUnspecified;
/**
 *  When the free instance expires, upgrade the instance to a provisioned
 *  instance.
 *
 *  Value: "FREE_TO_PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_FreeToProvisioned;
/**
 *  When the free instance expires, disable the instance, and delete it after
 *  the grace period passes if it has not been upgraded.
 *
 *  Value: "REMOVE_AFTER_GRACE_PERIOD"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_RemoveAfterGracePeriod;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.instanceType

/**
 *  Free instances provide no guarantee for dedicated resources, [node_count,
 *  processing_units] should be 0. They come with stricter usage limits and
 *  limited support.
 *
 *  Value: "FREE_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_InstanceType_FreeInstance;
/**
 *  Not specified.
 *
 *  Value: "INSTANCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_InstanceType_InstanceTypeUnspecified;
/**
 *  Provisioned instances have dedicated resources, standard usage limits and
 *  support.
 *
 *  Value: "PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_InstanceType_Provisioned;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.state

/**
 *  The instance is still being created. Resources may not be available yet, and
 *  operations such as database creation may not work.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_Creating;
/**
 *  The instance is fully created and ready to do work such as creating
 *  databases.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.configType

/**
 *  Google managed configuration.
 *
 *  Value: "GOOGLE_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_ConfigType_GoogleManaged;
/**
 *  Unspecified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_ConfigType_TypeUnspecified;
/**
 *  User managed configuration.
 *
 *  Value: "USER_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_ConfigType_UserManaged;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.freeInstanceAvailability

/**
 *  Indicates that free instances are available to be created in this instance
 *  config.
 *
 *  Value: "AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Available;
/**
 *  Indicates that free instances are currently not available to be created in
 *  this instance config.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Disabled;
/**
 *  Not specified.
 *
 *  Value: "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_FreeInstanceAvailabilityUnspecified;
/**
 *  Indicates that additional free instances cannot be created in this instance
 *  config because the project has reached its limit of free instances.
 *
 *  Value: "QUOTA_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_QuotaExceeded;
/**
 *  Indicates that free instances are not supported in this instance config.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Unsupported;

// ----------------------------------------------------------------------------
// GTLRSpanner_InstanceConfig.state

/**
 *  The instance config is still being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_State_Creating;
/**
 *  The instance config is fully created and ready to be used to create
 *  instances.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_InstanceConfig_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Metric.aggregation

/**
 *  Required default value.
 *
 *  Value: "AGGREGATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Metric_Aggregation_AggregationUnspecified;
/**
 *  Use the maximum of all values.
 *
 *  Value: "MAX"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Metric_Aggregation_Max;
/**
 *  Use the sum of all values.
 *
 *  Value: "SUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Metric_Aggregation_Sum;

// ----------------------------------------------------------------------------
// GTLRSpanner_PlanNode.kind

/**
 *  Not specified.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_KindUnspecified;
/**
 *  Denotes a Relational operator node in the expression tree. Relational
 *  operators represent iterative processing of rows during query execution. For
 *  example, a `TableScan` operation that reads rows from a table.
 *
 *  Value: "RELATIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Relational;
/**
 *  Denotes a Scalar node in the expression tree. Scalar nodes represent
 *  non-iterable entities in the query plan. For example, constants or
 *  arithmetic operators appearing inside predicate expressions or references to
 *  column names.
 *
 *  Value: "SCALAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Scalar;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReadWrite.readLockMode

/**
 *  Optimistic lock mode. Locks for reads within the transaction are not
 *  acquired on read. Instead the locks are acquired on a commit to validate
 *  that read/queried data has not changed since the transaction started.
 *
 *  Value: "OPTIMISTIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadWrite_ReadLockMode_Optimistic;
/**
 *  Pessimistic lock mode. Read locks are acquired immediately on read.
 *
 *  Value: "PESSIMISTIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadWrite_ReadLockMode_Pessimistic;
/**
 *  Default value. If the value is not specified, the pessimistic read lock is
 *  used.
 *
 *  Value: "READ_LOCK_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReadWrite_ReadLockMode_ReadLockModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReplicaInfo.type

/**
 *  Read-only replicas only support reads (not writes). Read-only replicas: *
 *  Maintain a full copy of your data. * Serve reads. * Do not participate in
 *  voting to commit writes. * Are not eligible to become a leader.
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_ReadOnly;
/**
 *  Read-write replicas support both reads and writes. These replicas: *
 *  Maintain a full copy of your data. * Serve reads. * Can vote whether to
 *  commit a write. * Participate in leadership election. * Are eligible to
 *  become a leader.
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_ReadWrite;
/**
 *  Not specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_TypeUnspecified;
/**
 *  Witness replicas don't support reads but do participate in voting to commit
 *  writes. Witness replicas: * Do not maintain a full copy of data. * Do not
 *  serve reads. * Vote whether to commit writes. * Participate in leader
 *  election but are not eligible to become leader.
 *
 *  Value: "WITNESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_Witness;

// ----------------------------------------------------------------------------
// GTLRSpanner_RequestOptions.priority

/**
 *  This specifies that the request is high priority.
 *
 *  Value: "PRIORITY_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityHigh;
/**
 *  This specifies that the request is low priority.
 *
 *  Value: "PRIORITY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityLow;
/**
 *  This specifies that the request is medium priority.
 *
 *  Value: "PRIORITY_MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityMedium;
/**
 *  `PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`.
 *
 *  Value: "PRIORITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RequestOptions_Priority_PriorityUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreDatabaseEncryptionConfig.encryptionType

/**
 *  Use customer managed encryption. If specified, `kms_key_name` must must
 *  contain a valid Cloud KMS key.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_CustomerManagedEncryption;
/**
 *  Unspecified. Do not use.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Use Google default encryption.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_GoogleDefaultEncryption;
/**
 *  This is the default option when encryption_config is not specified.
 *
 *  Value: "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreDatabaseMetadata.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseMetadata_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseMetadata_SourceType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreInfo.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreInfo_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreInfo_SourceType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Type.code

/**
 *  Encoded as `list`, where the list elements are represented according to
 *  array_element_type.
 *
 *  Value: "ARRAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Array;
/**
 *  Encoded as JSON `true` or `false`.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Bool;
/**
 *  Encoded as a base64-encoded `string`, as described in RFC 4648, section 4.
 *
 *  Value: "BYTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Bytes;
/**
 *  Encoded as `string` in RFC 3339 date format.
 *
 *  Value: "DATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Date;
/**
 *  Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or `"-Infinity"`.
 *
 *  Value: "FLOAT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Float64;
/**
 *  Encoded as `string`, in decimal format.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Int64;
/**
 *  Encoded as a JSON-formatted `string` as described in RFC 7159. The following
 *  rules are applied when parsing JSON input: - Whitespace characters are not
 *  preserved. - If a JSON object has duplicate keys, only the first key is
 *  preserved. - Members of a JSON object are not guaranteed to have their order
 *  preserved. - JSON array elements will have their order preserved.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Json;
/**
 *  Encoded as `string`, in decimal format or scientific notation format.
 *  Decimal format: `[+-]Digits[.[Digits]]` or `+-.Digits` Scientific notation:
 *  `[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
 *  `+-.Digits[ExponentIndicator[+-]Digits]` (ExponentIndicator is `"e"` or
 *  `"E"`)
 *
 *  Value: "NUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Numeric;
/**
 *  Encoded as `string`.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_String;
/**
 *  Encoded as `list`, where list element `i` is represented according to
 *  [struct_type.fields[i]][google.spanner.v1.StructType.fields].
 *
 *  Value: "STRUCT"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Struct;
/**
 *  Encoded as `string` in RFC 3339 timestamp format. The time zone must be
 *  present, and must be `"Z"`. If the schema has the column option
 *  `allow_commit_timestamp=true`, the placeholder string
 *  `"spanner.commit_timestamp()"` can be used to instruct the system to insert
 *  the commit timestamp associated with the transaction commit.
 *
 *  Value: "TIMESTAMP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Timestamp;
/**
 *  Not specified.
 *
 *  Value: "TYPE_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_TypeCodeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Type.typeAnnotation

/**
 *  PostgreSQL compatible JSONB type. This annotation needs to be applied to
 *  Type instances having JSON type code to specify that values of this type
 *  should be treated as PostgreSQL JSONB values. Currently this annotation is
 *  always needed for JSON when a client interacts with PostgreSQL-enabled
 *  Spanner databases.
 *
 *  Value: "PG_JSONB"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_PgJsonb;
/**
 *  PostgreSQL compatible NUMERIC type. This annotation needs to be applied to
 *  Type instances having NUMERIC type code to specify that values of this type
 *  should be treated as PostgreSQL NUMERIC values. Currently this annotation is
 *  always needed for NUMERIC when a client interacts with PostgreSQL-enabled
 *  Spanner databases.
 *
 *  Value: "PG_NUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_PgNumeric;
/**
 *  Not specified.
 *
 *  Value: "TYPE_ANNOTATION_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_TypeAnnotation_TypeAnnotationCodeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_VisualizationData.keyUnit

/**
 *  Each entry corresponds to a chunk of keys
 *
 *  Value: "CHUNK"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_VisualizationData_KeyUnit_Chunk;
/**
 *  Each entry corresponds to one key
 *
 *  Value: "KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_VisualizationData_KeyUnit_Key;
/**
 *  Required default value
 *
 *  Value: "KEY_UNIT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_VisualizationData_KeyUnit_KeyUnitUnspecified;

/**
 *  A backup of a Cloud Spanner database.
 */
@interface GTLRSpanner_Backup : GTLRObject

/**
 *  Output only. The time the CreateBackup request is received. If the request
 *  does not specify `version_time`, the `version_time` of the backup will be
 *  equivalent to the `create_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required for the CreateBackup operation. Name of the database from which
 *  this backup was created. This needs to be in the same instance as the
 *  backup. Values are of the form `projects//instances//databases/`.
 */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  Output only. The database dialect information for the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Backup_DatabaseDialect_DatabaseDialectUnspecified
 *        Default value. This value will create a database with the
 *        GOOGLE_STANDARD_SQL dialect. (Value: "DATABASE_DIALECT_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Backup_DatabaseDialect_GoogleStandardSql Google
 *        standard SQL. (Value: "GOOGLE_STANDARD_SQL")
 *    @arg @c kGTLRSpanner_Backup_DatabaseDialect_Postgresql PostgreSQL
 *        supported SQL. (Value: "POSTGRESQL")
 */
@property(nonatomic, copy, nullable) NSString *databaseDialect;

/** Output only. Output only. The encryption information for the backup. . */
@property(nonatomic, strong, nullable) GTLRSpanner_EncryptionInfo *encryptionInfo;

/**
 *  Required for the CreateBackup operation. The expiration time of the backup,
 *  with microseconds granularity that must be at least 6 hours and at most 366
 *  days from the time the CreateBackup request is processed. Once the
 *  `expire_time` has passed, the backup is eligible to be automatically deleted
 *  by Cloud Spanner to free the resources used by the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Output only. The max allowed expiration time of the backup, with
 *  microseconds granularity. A backup's expiration time can be configured in
 *  multiple APIs: CreateBackup, UpdateBackup, CopyBackup. When updating or
 *  copying an existing backup, the expiration time specified must be less than
 *  `Backup.max_expire_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *maxExpireTime;

/**
 *  Output only for the CreateBackup operation. Required for the UpdateBackup
 *  operation. A globally unique identifier for the backup which cannot be
 *  changed. Values are of the form `projects//instances//backups/a-z*[a-z0-9]`
 *  The final segment of the name must be between 2 and 60 characters in length.
 *  The backup is stored in the location(s) specified in the instance
 *  configuration of the instance containing the backup, identified by the
 *  prefix of the backup name of the form `projects//instances/`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The names of the destination backups being created by copying
 *  this source backup. The backup names are of the form
 *  `projects//instances//backups/`. Referencing backups may exist in different
 *  instances. The existence of any referencing backup prevents the backup from
 *  being deleted. When the copy operation is done (either successfully
 *  completed or cancelled or the destination backup is deleted), the reference
 *  to the backup is removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingBackups;

/**
 *  Output only. The names of the restored databases that reference the backup.
 *  The database names are of the form `projects//instances//databases/`.
 *  Referencing databases may exist in different instances. The existence of any
 *  referencing database prevents the backup from being deleted. When a restored
 *  database from the backup enters the `READY` state, the reference to the
 *  backup is removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingDatabases;

/**
 *  Output only. Size of the backup in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeBytes;

/**
 *  Output only. The current state of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Backup_State_Creating The pending backup is still
 *        being created. Operations on the backup may fail with
 *        `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Backup_State_Ready The backup is complete and ready
 *        for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Backup_State_StateUnspecified Not specified. (Value:
 *        "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The backup will contain an externally consistent copy of the database at the
 *  timestamp specified by `version_time`. If `version_time` is not specified,
 *  the system will set `version_time` to the `create_time` of the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *versionTime;

@end


/**
 *  Information about a backup.
 */
@interface GTLRSpanner_BackupInfo : GTLRObject

/** Name of the backup. */
@property(nonatomic, copy, nullable) NSString *backup;

/** The time the CreateBackup request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Name of the database the backup was created from. */
@property(nonatomic, copy, nullable) NSString *sourceDatabase;

/**
 *  The backup contains an externally consistent copy of `source_database` at
 *  the timestamp specified by `version_time`. If the CreateBackup request did
 *  not specify `version_time`, the `version_time` of the backup is equivalent
 *  to the `create_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *versionTime;

@end


/**
 *  The request for BatchCreateSessions.
 */
@interface GTLRSpanner_BatchCreateSessionsRequest : GTLRObject

/**
 *  Required. The number of sessions to be created in this batch call. The API
 *  may return fewer than the requested number of sessions. If a specific number
 *  of sessions are desired, the client can make additional calls to
 *  BatchCreateSessions (adjusting session_count as necessary).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sessionCount;

/** Parameters to be applied to each created session. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *sessionTemplate;

@end


/**
 *  The response for BatchCreateSessions.
 */
@interface GTLRSpanner_BatchCreateSessionsResponse : GTLRObject

/** The freshly created sessions. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *session;

@end


/**
 *  The request for BeginTransaction.
 */
@interface GTLRSpanner_BeginTransactionRequest : GTLRObject

/** Required. Options for the new transaction. */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *options;

/**
 *  Common options for this request. Priority is ignored for this request.
 *  Setting the priority in this request_options struct will not do anything. To
 *  set the priority for a transaction, set it on the reads and writes that are
 *  part of this transaction instead.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRSpanner_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
 *  An email address (plus unique identifier) representing a user that has been
 *  recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Metadata associated with a parent-child relationship appearing in a
 *  PlanNode.
 */
@interface GTLRSpanner_ChildLink : GTLRObject

/**
 *  The node to which the link points.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *childIndex;

/**
 *  The type of the link. For example, in Hash Joins this could be used to
 *  distinguish between the build child and the probe child, or in the case of
 *  the child being an output variable, to represent the tag associated with the
 *  output variable.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Only present if the child node is SCALAR and corresponds to an output
 *  variable of the parent node. The field carries the name of the output
 *  variable. For example, a `TableScan` operator that reads rows from a table
 *  will have child links to the `SCALAR` nodes representing the output
 *  variables created for each column that is read by the operator. The
 *  corresponding `variable` fields will be set to the variable names assigned
 *  to the columns.
 */
@property(nonatomic, copy, nullable) NSString *variable;

@end


/**
 *  The request for Commit.
 */
@interface GTLRSpanner_CommitRequest : GTLRObject

/**
 *  The mutations to be executed when this transaction commits. All mutations
 *  are applied atomically, in the order they appear in this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Mutation *> *mutations;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  If `true`, then statistics related to the transaction will be included in
 *  the CommitResponse. Default value is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *returnCommitStats;

/**
 *  Execute mutations in a temporary transaction. Note that unlike commit of a
 *  previously-started transaction, commit with a temporary transaction is
 *  non-idempotent. That is, if the `CommitRequest` is sent to Cloud Spanner
 *  more than once (for instance, due to retries in the application, or in the
 *  transport library), it is possible that the mutations are executed more than
 *  once. If this is undesirable, use BeginTransaction and Commit instead.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUseTransaction;

/**
 *  Commit a previously-started transaction.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  The response for Commit.
 */
@interface GTLRSpanner_CommitResponse : GTLRObject

/**
 *  The statistics about this Commit. Not returned by default. For more
 *  information, see CommitRequest.return_commit_stats.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_CommitStats *commitStats;

/** The Cloud Spanner timestamp at which the transaction committed. */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

@end


/**
 *  Additional statistics about a commit.
 */
@interface GTLRSpanner_CommitStats : GTLRObject

/**
 *  The total number of mutations for the transaction. Knowing the
 *  `mutation_count` value can help you maximize the number of mutations in a
 *  transaction and minimize the number of API round trips. You can also monitor
 *  this value to prevent transactions from exceeding the system
 *  [limit](https://cloud.google.com/spanner/quotas#limits_for_creating_reading_updating_and_deleting_data).
 *  If the number of mutations exceeds the limit, the server returns
 *  [INVALID_ARGUMENT](https://cloud.google.com/spanner/docs/reference/rest/v1/Code#ENUM_VALUES.INVALID_ARGUMENT).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mutationCount;

@end


/**
 *  A message representing context for a KeyRangeInfo, including a label, value,
 *  unit, and severity.
 */
@interface GTLRSpanner_ContextValue : GTLRObject

/** The label for the context value. e.g. "latency". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *label;

/**
 *  The severity of this context.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Error Severity level signaling
 *        an error "Error" (Value: "ERROR")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Fatal Severity level signaling
 *        a non recoverable error "Fatal" (Value: "FATAL")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Info Lowest severity level
 *        "Info". (Value: "INFO")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_SeverityUnspecified Required
 *        default value. (Value: "SEVERITY_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_ContextValue_Severity_Warning Middle severity level
 *        "Warning". (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** The unit of the context value. */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  The value for the context.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  Encryption configuration for the copied backup.
 */
@interface GTLRSpanner_CopyBackupEncryptionConfig : GTLRObject

/**
 *  Required. The encryption type of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_CustomerManagedEncryption
 *        Use customer managed encryption. If specified, `kms_key_name` must
 *        contain a valid Cloud KMS key. (Value: "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_EncryptionTypeUnspecified
 *        Unspecified. Do not use. (Value: "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_GoogleDefaultEncryption
 *        Use Google default encryption. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_CopyBackupEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption
 *        This is the default option for CopyBackup when encryption_config is
 *        not specified. For example, if the source backup is using
 *        `Customer_Managed_Encryption`, the backup will be using the same Cloud
 *        KMS key as the source backup. (Value:
 *        "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Optional. The Cloud KMS key that will be used to protect the backup. This
 *  field should be set only when encryption_type is
 *  `CUSTOMER_MANAGED_ENCRYPTION`. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

@end


/**
 *  Metadata type for the operation returned by CopyBackup.
 */
@interface GTLRSpanner_CopyBackupMetadata : GTLRObject

/**
 *  The time at which cancellation of CopyBackup operation was received.
 *  Operations.CancelOperation starts asynchronous cancellation on a
 *  long-running operation. The server makes a best effort to cancel the
 *  operation, but success is not guaranteed. Clients can use
 *  Operations.GetOperation or other methods to check whether the cancellation
 *  succeeded or whether the operation completed despite cancellation. On
 *  successful cancellation, the operation is not deleted; instead, it becomes
 *  an operation with an Operation.error value with a google.rpc.Status.code of
 *  1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/**
 *  The name of the backup being created through the copy operation. Values are
 *  of the form `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the CopyBackup operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

/**
 *  The name of the source backup that is being copied. Values are of the form
 *  `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

@end


/**
 *  The request for CopyBackup.
 */
@interface GTLRSpanner_CopyBackupRequest : GTLRObject

/**
 *  Required. The id of the backup copy. The `backup_id` appended to `parent`
 *  forms the full backup_uri of the form `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *backupId;

/**
 *  Optional. The encryption configuration used to encrypt the backup. If this
 *  field is not specified, the backup will use the same encryption
 *  configuration as the source backup by default, namely encryption_type =
 *  `USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_CopyBackupEncryptionConfig *encryptionConfig;

/**
 *  Required. The expiration time of the backup in microsecond granularity. The
 *  expiration time must be at least 6 hours and at most 366 days from the
 *  `create_time` of the source backup. Once the `expire_time` has passed, the
 *  backup is eligible to be automatically deleted by Cloud Spanner to free the
 *  resources used by the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Required. The source backup to be copied. The source backup needs to be in
 *  READY state for it to be copied. Once CopyBackup is in progress, the source
 *  backup cannot be deleted or cleaned up on expiration until CopyBackup is
 *  finished. Values are of the form: `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

@end


/**
 *  Metadata type for the operation returned by CreateBackup.
 */
@interface GTLRSpanner_CreateBackupMetadata : GTLRObject

/**
 *  The time at which cancellation of this operation was received.
 *  Operations.CancelOperation starts asynchronous cancellation on a
 *  long-running operation. The server makes a best effort to cancel the
 *  operation, but success is not guaranteed. Clients can use
 *  Operations.GetOperation or other methods to check whether the cancellation
 *  succeeded or whether the operation completed despite cancellation. On
 *  successful cancellation, the operation is not deleted; instead, it becomes
 *  an operation with an Operation.error value with a google.rpc.Status.code of
 *  1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The name of the database the backup is created from. */
@property(nonatomic, copy, nullable) NSString *database;

/** The name of the backup being created. */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the CreateBackup operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

@end


/**
 *  Metadata type for the operation returned by CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseMetadata : GTLRObject

/** The database being created. */
@property(nonatomic, copy, nullable) NSString *database;

@end


/**
 *  The request for CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseRequest : GTLRObject

/**
 *  Required. A `CREATE DATABASE` statement, which specifies the ID of the new
 *  database. The database ID must conform to the regular expression
 *  `a-z*[a-z0-9]` and be between 2 and 30 characters in length. If the database
 *  ID is a reserved word or if it contains a hyphen, the database ID must be
 *  enclosed in backticks (`` ` ``).
 */
@property(nonatomic, copy, nullable) NSString *createStatement;

/**
 *  Optional. The dialect of the Cloud Spanner Database.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_DatabaseDialectUnspecified
 *        Default value. This value will create a database with the
 *        GOOGLE_STANDARD_SQL dialect. (Value: "DATABASE_DIALECT_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_GoogleStandardSql
 *        Google standard SQL. (Value: "GOOGLE_STANDARD_SQL")
 *    @arg @c kGTLRSpanner_CreateDatabaseRequest_DatabaseDialect_Postgresql
 *        PostgreSQL supported SQL. (Value: "POSTGRESQL")
 */
@property(nonatomic, copy, nullable) NSString *databaseDialect;

/**
 *  Optional. The encryption configuration for the database. If this field is
 *  not specified, Cloud Spanner will encrypt/decrypt all data at rest using
 *  Google default encryption.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_EncryptionConfig *encryptionConfig;

/**
 *  Optional. A list of DDL statements to run inside the newly created database.
 *  Statements can create tables, indexes, etc. These statements execute
 *  atomically with the creation of the database: if there is an error in any
 *  statement, the database is not created.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *extraStatements;

@end


/**
 *  Metadata type for the operation returned by CreateInstanceConfig.
 */
@interface GTLRSpanner_CreateInstanceConfigMetadata : GTLRObject

/** The time at which this operation was cancelled. */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The target instance config end state. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/** The progress of the CreateInstanceConfig operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceOperationProgress *progress;

@end


/**
 *  The request for CreateInstanceConfigRequest.
 */
@interface GTLRSpanner_CreateInstanceConfigRequest : GTLRObject

/**
 *  Required. The InstanceConfig proto of the configuration to create.
 *  instance_config.name must be `/instanceConfigs/`.
 *  instance_config.base_config must be a Google managed configuration name,
 *  e.g. /instanceConfigs/us-east1, /instanceConfigs/nam3.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/**
 *  Required. The ID of the instance config to create. Valid identifiers are of
 *  the form `custom-[-a-z0-9]*[a-z0-9]` and must be between 2 and 64 characters
 *  in length. The `custom-` prefix is required to avoid name conflicts with
 *  Google managed configurations.
 */
@property(nonatomic, copy, nullable) NSString *instanceConfigId;

/**
 *  An option to validate, but not actually execute, a request, and provide the
 *  same response.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateOnly;

@end


/**
 *  Metadata type for the operation returned by CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is guaranteed to succeed) and cannot be
 *  cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The instance being created. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/** The time at which the CreateInstance request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceRequest : GTLRObject

/**
 *  Required. The instance to create. The name may be omitted, but if specified
 *  must be `/instances/`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  Required. The ID of the instance to create. Valid identifiers are of the
 *  form `a-z*[a-z0-9]` and must be between 2 and 64 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *instanceId;

@end


/**
 *  The request for CreateSession.
 */
@interface GTLRSpanner_CreateSessionRequest : GTLRObject

/** Required. The session to create. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *session;

@end


/**
 *  A Cloud Spanner database.
 */
@interface GTLRSpanner_Database : GTLRObject

/**
 *  Output only. If exists, the time at which the database creation started.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The dialect of the Cloud Spanner Database.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Database_DatabaseDialect_DatabaseDialectUnspecified
 *        Default value. This value will create a database with the
 *        GOOGLE_STANDARD_SQL dialect. (Value: "DATABASE_DIALECT_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Database_DatabaseDialect_GoogleStandardSql Google
 *        standard SQL. (Value: "GOOGLE_STANDARD_SQL")
 *    @arg @c kGTLRSpanner_Database_DatabaseDialect_Postgresql PostgreSQL
 *        supported SQL. (Value: "POSTGRESQL")
 */
@property(nonatomic, copy, nullable) NSString *databaseDialect;

/**
 *  Output only. The read-write region which contains the database's leader
 *  replicas. This is the same as the value of default_leader database option
 *  set using DatabaseAdmin.CreateDatabase or DatabaseAdmin.UpdateDatabaseDdl.
 *  If not explicitly set, this is empty.
 */
@property(nonatomic, copy, nullable) NSString *defaultLeader;

/**
 *  Output only. Earliest timestamp at which older versions of the data can be
 *  read. This value is continuously updated by Cloud Spanner and becomes stale
 *  the moment it is queried. If you are using this value to recover data, make
 *  sure to account for the time from the moment when the value is queried to
 *  the moment when you initiate the recovery.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *earliestVersionTime;

/**
 *  Output only. For databases that are using customer managed encryption, this
 *  field contains the encryption configuration for the database. For databases
 *  that are using Google default or other types of encryption, this field is
 *  empty.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_EncryptionConfig *encryptionConfig;

/**
 *  Output only. For databases that are using customer managed encryption, this
 *  field contains the encryption information for the database, such as all
 *  Cloud KMS key versions that are in use. The `encryption_status' field inside
 *  of each `EncryptionInfo` is not populated. For databases that are using
 *  Google default or other types of encryption, this field is empty. This field
 *  is propagated lazily from the backend. There might be a delay from when a
 *  key version is being used and when it appears in this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_EncryptionInfo *> *encryptionInfo;

/**
 *  Required. The name of the database. Values are of the form
 *  `projects//instances//databases/`, where `` is as specified in the `CREATE
 *  DATABASE` statement. This name can be passed to other API methods to
 *  identify the database.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Applicable only for restored databases. Contains information
 *  about the restore source.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RestoreInfo *restoreInfo;

/**
 *  Output only. The current database state.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Database_State_Creating The database is still being
 *        created. Operations on the database may fail with
 *        `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Database_State_Ready The database is fully created
 *        and ready for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Database_State_ReadyOptimizing The database is fully
 *        created and ready for use, but is still being optimized for
 *        performance and cannot handle full load. In this state, the database
 *        still references the backup it was restore from, preventing the backup
 *        from being deleted. When optimizations are complete, the full
 *        performance of the database will be restored, and the database will
 *        transition to `READY` state. (Value: "READY_OPTIMIZING")
 *    @arg @c kGTLRSpanner_Database_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The period in which Cloud Spanner retains all versions of data
 *  for the database. This is the same as the value of version_retention_period
 *  database option set using UpdateDatabaseDdl. Defaults to 1 hour, if not set.
 */
@property(nonatomic, copy, nullable) NSString *versionRetentionPeriod;

@end


/**
 *  A Cloud Spanner database role.
 */
@interface GTLRSpanner_DatabaseRole : GTLRObject

/**
 *  Required. The name of the database role. Values are of the form
 *  `projects//instances//databases//databaseRoles/` where `` is as specified in
 *  the `CREATE ROLE` DDL statement.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Arguments to delete operations.
 */
@interface GTLRSpanner_Delete : GTLRObject

/**
 *  Required. The primary keys of the rows within table to delete. The primary
 *  keys must be specified in the order in which they appear in the `PRIMARY
 *  KEY()` clause of the table's equivalent DDL statement (the DDL statement
 *  used to create the table). Delete is idempotent. The transaction will
 *  succeed even if some or all rows do not exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Required. The table whose rows will be deleted. */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  A message representing a derived metric.
 */
@interface GTLRSpanner_DerivedMetric : GTLRObject

/** The name of the denominator metric. e.g. "rows". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *denominator;

/** The name of the numerator metric. e.g. "latency". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *numerator;

@end


/**
 *  A message representing the key visualizer diagnostic messages.
 */
@interface GTLRSpanner_DiagnosticMessage : GTLRObject

/** Information about this diagnostic information. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *info;

/** The metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *metric;

/**
 *  Whether this message is specific only for the current metric. By default
 *  Diagnostics are shown for all metrics, regardless which metric is the
 *  currently selected metric in the UI. However occasionally a metric will
 *  generate so many messages that the resulting visual clutter becomes
 *  overwhelming. In this case setting this to true, will show the diagnostic
 *  messages for that metric only if it is the currently selected metric.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *metricSpecific;

/**
 *  The severity of the diagnostic message.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Error Severity level
 *        signaling an error "Error" (Value: "ERROR")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Fatal Severity level
 *        signaling a non recoverable error "Fatal" (Value: "FATAL")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Info Lowest severity level
 *        "Info". (Value: "INFO")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_SeverityUnspecified
 *        Required default value. (Value: "SEVERITY_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_DiagnosticMessage_Severity_Warning Middle severity
 *        level "Warning". (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** The short message. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *shortMessage;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRSpanner_Empty : GTLRObject
@end


/**
 *  Encryption configuration for a Cloud Spanner database.
 */
@interface GTLRSpanner_EncryptionConfig : GTLRObject

/**
 *  The Cloud KMS key to be used for encrypting and decrypting the database.
 *  Values are of the form `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

@end


/**
 *  Encryption information for a Cloud Spanner database or backup.
 */
@interface GTLRSpanner_EncryptionInfo : GTLRObject

/**
 *  Output only. If present, the status of a recent encrypt/decrypt call on
 *  underlying data for this database or backup. Regardless of status, data is
 *  always encrypted at rest.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *encryptionStatus;

/**
 *  Output only. The type of encryption.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_EncryptionInfo_EncryptionType_CustomerManagedEncryption
 *        The data is encrypted at rest with a key that is managed by the
 *        customer. The active version of the key. `kms_key_version` will be
 *        populated, and `encryption_status` may be populated. (Value:
 *        "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_EncryptionInfo_EncryptionType_GoogleDefaultEncryption
 *        The data is encrypted at rest with a key that is fully managed by
 *        Google. No key version or status will be populated. This is the
 *        default state. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_EncryptionInfo_EncryptionType_TypeUnspecified
 *        Encryption type was not specified, though data at rest remains
 *        encrypted. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Output only. A Cloud KMS key version that is being used to protect the
 *  database or backup.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyVersion;

@end


/**
 *  The request for ExecuteBatchDml.
 */
@interface GTLRSpanner_ExecuteBatchDmlRequest : GTLRObject

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  Required. A per-transaction sequence number used to identify this request.
 *  This field makes each request idempotent such that if the request is
 *  received multiple times, at most one will succeed. The sequence number must
 *  be monotonically increasing within the transaction. If a request arrives for
 *  the first time with an out-of-order sequence number, the transaction may be
 *  aborted. Replays of previously handled requests will yield the same response
 *  as the first execution.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/**
 *  Required. The list of statements to execute in this batch. Statements are
 *  executed serially, such that the effects of statement `i` are visible to
 *  statement `i+1`. Each statement must be a DML statement. Execution stops at
 *  the first failed statement; the remaining statements are not executed.
 *  Callers must provide at least one statement.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Statement *> *statements;

/**
 *  Required. The transaction to use. Must be a read-write transaction. To
 *  protect against replays, single-use transactions are not supported. The
 *  caller must either supply an existing transaction ID or begin a new
 *  transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for ExecuteBatchDml. Contains a list of ResultSet messages, one
 *  for each DML statement that has successfully executed, in the same order as
 *  the statements in the request. If a statement fails, the status in the
 *  response body identifies the cause of the failure. To check for DML
 *  statements that failed, use the following approach: 1. Check the status in
 *  the response message. The google.rpc.Code enum value `OK` indicates that all
 *  statements were executed successfully. 2. If the status was not `OK`, check
 *  the number of result sets in the response. If the response contains `N`
 *  ResultSet messages, then statement `N+1` in the request failed. Example 1: *
 *  Request: 5 DML statements, all executed successfully. * Response: 5
 *  ResultSet messages, with the status `OK`. Example 2: * Request: 5 DML
 *  statements. The third statement has a syntax error. * Response: 2 ResultSet
 *  messages, and a syntax error (`INVALID_ARGUMENT`) status. The number of
 *  ResultSet messages indicates that the third statement failed, and the fourth
 *  and fifth statements were not executed.
 */
@interface GTLRSpanner_ExecuteBatchDmlResponse : GTLRObject

/**
 *  One ResultSet for each statement in the request that ran successfully, in
 *  the same order as the statements in the request. Each ResultSet does not
 *  contain any rows. The ResultSetStats in each ResultSet contain the number of
 *  rows modified by the statement. Only the first ResultSet in the response
 *  contains valid ResultSetMetadata.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ResultSet *> *resultSets;

/**
 *  If all DML statements are executed successfully, the status is `OK`.
 *  Otherwise, the error status of the first failed statement.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *status;

@end


/**
 *  The request for ExecuteSql and ExecuteStreamingSql.
 */
@interface GTLRSpanner_ExecuteSqlRequest : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names must conform to
 *  the naming requirements of identifiers as specified at
 *  https://cloud.google.com/spanner/docs/lexical#identifiers. Parameters can
 *  appear anywhere that a literal value is expected. The same parameter name
 *  can be used more than once, for example: `"WHERE id > \@msg_id AND id <
 *  \@msg_id + 100"` It is an error to execute a SQL statement with unbound
 *  parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL statement parameters. See the definition of Type for more
 *  information about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_ParamTypes *paramTypes;

/**
 *  If present, results will be restricted to the specified partition previously
 *  created using PartitionQuery(). There must be an exact match for the values
 *  of fields common to this message and the PartitionQueryRequest message used
 *  to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  Used to control the amount of debugging information returned in
 *  ResultSetStats. If partition_token is set, query_mode can only be set to
 *  QueryMode.NORMAL.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal The default mode.
 *        Only the statement results are returned. (Value: "NORMAL")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan This mode returns
 *        only the query plan, without any results or execution statistics
 *        information. (Value: "PLAN")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile This mode returns
 *        both the query plan and the execution statistics along with the
 *        results. (Value: "PROFILE")
 */
@property(nonatomic, copy, nullable) NSString *queryMode;

/** Query optimizer configuration to use for the given query. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryOptions *queryOptions;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  If this request is resuming a previously interrupted SQL statement
 *  execution, `resume_token` should be copied from the last PartialResultSet
 *  yielded before the interruption. Doing this enables the new SQL statement
 *  execution to resume where the last one left off. The rest of the request
 *  parameters must exactly match the request that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  A per-transaction sequence number used to identify this request. This field
 *  makes each request idempotent such that if the request is received multiple
 *  times, at most one will succeed. The sequence number must be monotonically
 *  increasing within the transaction. If a request arrives for the first time
 *  with an out-of-order sequence number, the transaction may be aborted.
 *  Replays of previously handled requests will yield the same response as the
 *  first execution. Required for DML statements. Ignored for queries.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/** Required. The SQL string. */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  The transaction to use. For queries, if none is provided, the default is a
 *  temporary read-only transaction with strong concurrency. Standard DML
 *  statements require a read-write transaction. To protect against replays,
 *  single-use transactions are not supported. The caller must either supply an
 *  existing transaction ID or begin a new transaction. Partitioned DML requires
 *  an existing Partitioned DML transaction ID.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names must conform to
 *  the naming requirements of identifiers as specified at
 *  https://cloud.google.com/spanner/docs/lexical#identifiers. Parameters can
 *  appear anywhere that a literal value is expected. The same parameter name
 *  can be used more than once, for example: `"WHERE id > \@msg_id AND id <
 *  \@msg_id + 100"` It is an error to execute a SQL statement with unbound
 *  parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL statement parameters. See the definition of Type for more
 *  information about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_ParamTypes : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRSpanner_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Message representing a single field of a struct.
 */
@interface GTLRSpanner_Field : GTLRObject

/**
 *  The name of the field. For reads, this is the column name. For SQL queries,
 *  it is the column alias (e.g., `"Word"` in the query `"SELECT 'hello' AS
 *  Word"`), or the column name (e.g., `"ColName"` in the query `"SELECT ColName
 *  FROM Table"`). Some columns might have an empty name (e.g., `"SELECT
 *  UPPER(ColName)"`). Note that a query result can contain multiple fields with
 *  the same name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The type of the field. */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *type;

@end


/**
 *  Free instance specific metadata that is kept even after an instance has been
 *  upgraded for tracking purposes.
 */
@interface GTLRSpanner_FreeInstanceMetadata : GTLRObject

/**
 *  Specifies the expiration behavior of a free instance. The default of
 *  ExpireBehavior is `REMOVE_AFTER_GRACE_PERIOD`. This can be modified during
 *  or after creation, and before expiration.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_ExpireBehaviorUnspecified
 *        Not specified. (Value: "EXPIRE_BEHAVIOR_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_FreeToProvisioned
 *        When the free instance expires, upgrade the instance to a provisioned
 *        instance. (Value: "FREE_TO_PROVISIONED")
 *    @arg @c kGTLRSpanner_FreeInstanceMetadata_ExpireBehavior_RemoveAfterGracePeriod
 *        When the free instance expires, disable the instance, and delete it
 *        after the grace period passes if it has not been upgraded. (Value:
 *        "REMOVE_AFTER_GRACE_PERIOD")
 */
@property(nonatomic, copy, nullable) NSString *expireBehavior;

/**
 *  Output only. Timestamp after which the instance will either be upgraded or
 *  scheduled for deletion after a grace period. ExpireBehavior is used to
 *  choose between upgrading or scheduling the free instance for deletion. This
 *  timestamp is set during the creation of a free instance.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Output only. If present, the timestamp at which the free instance was
 *  upgraded to a provisioned instance.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *upgradeTime;

@end


/**
 *  The response for GetDatabaseDdl.
 */
@interface GTLRSpanner_GetDatabaseDdlResponse : GTLRObject

/**
 *  A list of formatted DDL statements defining the schema of the database
 *  specified in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRSpanner_GetIamPolicyRequest : GTLRObject

/**
 *  OPTIONAL: A `GetPolicyOptions` object for specifying options to
 *  `GetIamPolicy`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_GetPolicyOptions *options;

@end


/**
 *  Encapsulates settings provided to GetIamPolicy.
 */
@interface GTLRSpanner_GetPolicyOptions : GTLRObject

/**
 *  Optional. The maximum policy version that will be used to format the policy.
 *  Valid values are 0, 1, and 3. Requests specifying an invalid value will be
 *  rejected. Requests for policies with any conditional role bindings must
 *  specify version 3. Policies with no conditional role bindings may specify
 *  any valid value or leave the field unset. The policy in the response might
 *  use the policy version that you specified, or it might use a lower policy
 *  version. For example, if you specify version 3, but the policy has no
 *  conditional role bindings, the response uses version 1. To learn which
 *  resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedPolicyVersion;

@end


/**
 *  A message representing a (sparse) collection of hot keys for specific key
 *  buckets.
 */
@interface GTLRSpanner_IndexedHotKey : GTLRObject

/**
 *  A (sparse) mapping from key bucket index to the index of the specific hot
 *  row key for that key bucket. The index of the hot row key can be translated
 *  to the actual row key via the ScanData.VisualizationData.indexed_keys
 *  repeated field.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_IndexedHotKey_SparseHotKeys *sparseHotKeys;

@end


/**
 *  A (sparse) mapping from key bucket index to the index of the specific hot
 *  row key for that key bucket. The index of the hot row key can be translated
 *  to the actual row key via the ScanData.VisualizationData.indexed_keys
 *  repeated field.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_IndexedHotKey_SparseHotKeys : GTLRObject
@end


/**
 *  A message representing a (sparse) collection of KeyRangeInfos for specific
 *  key buckets.
 */
@interface GTLRSpanner_IndexedKeyRangeInfos : GTLRObject

/**
 *  A (sparse) mapping from key bucket index to the KeyRangeInfos for that key
 *  bucket.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_IndexedKeyRangeInfos_KeyRangeInfos *keyRangeInfos;

@end


/**
 *  A (sparse) mapping from key bucket index to the KeyRangeInfos for that key
 *  bucket.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_KeyRangeInfos. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_IndexedKeyRangeInfos_KeyRangeInfos : GTLRObject
@end


/**
 *  An isolated set of Cloud Spanner resources on which databases can be hosted.
 */
@interface GTLRSpanner_Instance : GTLRObject

/**
 *  Required. The name of the instance's configuration. Values are of the form
 *  `projects//instanceConfigs/`. See also InstanceConfig and
 *  ListInstanceConfigs.
 */
@property(nonatomic, copy, nullable) NSString *config;

/** Output only. The time at which the instance was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. The descriptive name for this instance as it appears in UIs. Must
 *  be unique per project and between 4 and 30 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Deprecated. This field is not populated. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *endpointUris;

/** Free instance metadata. Only populated for free instances. */
@property(nonatomic, strong, nullable) GTLRSpanner_FreeInstanceMetadata *freeInstanceMetadata;

/**
 *  The `InstanceType` of the current instance.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_InstanceType_FreeInstance Free instances
 *        provide no guarantee for dedicated resources, [node_count,
 *        processing_units] should be 0. They come with stricter usage limits
 *        and limited support. (Value: "FREE_INSTANCE")
 *    @arg @c kGTLRSpanner_Instance_InstanceType_InstanceTypeUnspecified Not
 *        specified. (Value: "INSTANCE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Instance_InstanceType_Provisioned Provisioned
 *        instances have dedicated resources, standard usage limits and support.
 *        (Value: "PROVISIONED")
 */
@property(nonatomic, copy, nullable) NSString *instanceType;

/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. And so you are advised to use an internal label representation, such
 *  as JSON, which doesn't rely upon specific characters being disallowed. For
 *  example, representing labels as the string: name + "_" + value would prove
 *  problematic if we were to allow "_" in a future release.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance_Labels *labels;

/**
 *  Required. A unique identifier for the instance, which cannot be changed
 *  after the instance is created. Values are of the form
 *  `projects//instances/a-z*[a-z0-9]`. The final segment of the name must be
 *  between 2 and 64 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The number of nodes allocated to this instance. At most one of either
 *  node_count or processing_units should be present in the message. This may be
 *  zero in API responses for instances that are not yet in state `READY`. See
 *  [the documentation](https://cloud.google.com/spanner/docs/compute-capacity)
 *  for more information about nodes and processing units.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  The number of processing units allocated to this instance. At most one of
 *  processing_units or node_count should be present in the message. This may be
 *  zero in API responses for instances that are not yet in state `READY`. See
 *  [the documentation](https://cloud.google.com/spanner/docs/compute-capacity)
 *  for more information about nodes and processing units.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *processingUnits;

/**
 *  Output only. The current instance state. For CreateInstance, the state must
 *  be either omitted or set to `CREATING`. For UpdateInstance, the state must
 *  be either omitted or set to `READY`.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_State_Creating The instance is still being
 *        created. Resources may not be available yet, and operations such as
 *        database creation may not work. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Instance_State_Ready The instance is fully created
 *        and ready to do work such as creating databases. (Value: "READY")
 *    @arg @c kGTLRSpanner_Instance_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The time at which the instance was most recently updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. And so you are advised to use an internal label representation, such
 *  as JSON, which doesn't rely upon specific characters being disallowed. For
 *  example, representing labels as the string: name + "_" + value would prove
 *  problematic if we were to allow "_" in a future release.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Instance_Labels : GTLRObject
@end


/**
 *  A possible configuration for a Cloud Spanner instance. Configurations define
 *  the geographic placement of nodes and their replication.
 */
@interface GTLRSpanner_InstanceConfig : GTLRObject

/**
 *  Base configuration name, e.g. projects//instanceConfigs/nam3, based on which
 *  this configuration is created. Only set for user managed configurations.
 *  `base_config` must refer to a configuration of type GOOGLE_MANAGED in the
 *  same project as this configuration.
 */
@property(nonatomic, copy, nullable) NSString *baseConfig;

/**
 *  Output only. Whether this instance config is a Google or User Managed
 *  Configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_ConfigType_GoogleManaged Google
 *        managed configuration. (Value: "GOOGLE_MANAGED")
 *    @arg @c kGTLRSpanner_InstanceConfig_ConfigType_TypeUnspecified
 *        Unspecified. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_InstanceConfig_ConfigType_UserManaged User managed
 *        configuration. (Value: "USER_MANAGED")
 */
@property(nonatomic, copy, nullable) NSString *configType;

/** The name of this instance configuration as it appears in UIs. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  etag is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a instance config from overwriting each other. It is
 *  strongly suggested that systems make use of the etag in the
 *  read-modify-write cycle to perform instance config updates in order to avoid
 *  race conditions: An etag is returned in the response which contains instance
 *  configs, and systems are expected to put that etag in the request to update
 *  instance config to ensure that their change will be applied to the same
 *  version of the instance config. If no etag is provided in the call to update
 *  instance config, then the existing instance config is overwritten blindly.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. Describes whether free instances are available to be created in
 *  this instance config.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Available
 *        Indicates that free instances are available to be created in this
 *        instance config. (Value: "AVAILABLE")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Disabled
 *        Indicates that free instances are currently not available to be
 *        created in this instance config. (Value: "DISABLED")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_FreeInstanceAvailabilityUnspecified
 *        Not specified. (Value: "FREE_INSTANCE_AVAILABILITY_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_QuotaExceeded
 *        Indicates that additional free instances cannot be created in this
 *        instance config because the project has reached its limit of free
 *        instances. (Value: "QUOTA_EXCEEDED")
 *    @arg @c kGTLRSpanner_InstanceConfig_FreeInstanceAvailability_Unsupported
 *        Indicates that free instances are not supported in this instance
 *        config. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *freeInstanceAvailability;

/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. Therefore, you are advised to use an internal label representation,
 *  such as JSON, which doesn't rely upon specific characters being disallowed.
 *  For example, representing labels as the string: name + "_" + value would
 *  prove problematic if we were to allow "_" in a future release.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig_Labels *labels;

/**
 *  Allowed values of the "default_leader" schema option for databases in
 *  instances that use this instance configuration.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *leaderOptions;

/**
 *  A unique identifier for the instance configuration. Values are of the form
 *  `projects//instanceConfigs/a-z*`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The available optional replicas to choose from for user managed
 *  configurations. Populated for Google managed configurations.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaInfo *> *optionalReplicas;

/**
 *  Output only. If true, the instance config is being created or updated. If
 *  false, there are no ongoing operations for the instance config.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  The geographic placement of nodes in this instance configuration and their
 *  replication properties.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaInfo *> *replicas;

/**
 *  Output only. The current instance config state.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_InstanceConfig_State_Creating The instance config is
 *        still being created. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_InstanceConfig_State_Ready The instance config is
 *        fully created and ready to be used to create instances. (Value:
 *        "READY")
 *    @arg @c kGTLRSpanner_InstanceConfig_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.). * Label keys must be between 1 and 63
 *  characters long and must conform to the following regular expression:
 *  `a-z{0,62}`. * Label values must be between 0 and 63 characters long and
 *  must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64
 *  labels can be associated with a given resource. See https://goo.gl/xmQnxf
 *  for more information on and examples of labels. If you plan to use labels in
 *  your own code, please note that additional characters may be allowed in the
 *  future. Therefore, you are advised to use an internal label representation,
 *  such as JSON, which doesn't rely upon specific characters being disallowed.
 *  For example, representing labels as the string: name + "_" + value would
 *  prove problematic if we were to allow "_" in a future release.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_InstanceConfig_Labels : GTLRObject
@end


/**
 *  Encapsulates progress related information for a Cloud Spanner long running
 *  instance operations.
 */
@interface GTLRSpanner_InstanceOperationProgress : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Percent completion of the operation. Values are between 0 and 100 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *progressPercent;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  KeyRange represents a range of rows in a table or index. A range has a start
 *  key and an end key. These keys can be open or closed, indicating if the
 *  range includes rows with that key. Keys are represented by lists, where the
 *  ith value in the list corresponds to the ith component of the table or index
 *  primary key. Individual values are encoded as described here. For example,
 *  consider the following table definition: CREATE TABLE UserEvents ( UserName
 *  STRING(MAX), EventDate STRING(10) ) PRIMARY KEY(UserName, EventDate); The
 *  following keys name rows in this table: "Bob", "2014-09-23" Since the
 *  `UserEvents` table's `PRIMARY KEY` clause names two columns, each
 *  `UserEvents` key has two elements; the first is the `UserName`, and the
 *  second is the `EventDate`. Key ranges with multiple components are
 *  interpreted lexicographically by component using the table or index key's
 *  declared sort order. For example, the following range returns all events for
 *  user `"Bob"` that occurred in the year 2015: "start_closed": ["Bob",
 *  "2015-01-01"] "end_closed": ["Bob", "2015-12-31"] Start and end keys can
 *  omit trailing key components. This affects the inclusion and exclusion of
 *  rows that exactly match the provided key components: if the key is closed,
 *  then rows that exactly match the provided components are included; if the
 *  key is open, then rows that exactly match are not included. For example, the
 *  following range includes all events for `"Bob"` that occurred during and
 *  after the year 2000: "start_closed": ["Bob", "2000-01-01"] "end_closed":
 *  ["Bob"] The next example retrieves all events for `"Bob"`: "start_closed":
 *  ["Bob"] "end_closed": ["Bob"] To retrieve events before the year 2000:
 *  "start_closed": ["Bob"] "end_open": ["Bob", "2000-01-01"] The following
 *  range includes all rows in the table: "start_closed": [] "end_closed": []
 *  This range returns all users whose `UserName` begins with any character from
 *  A to C: "start_closed": ["A"] "end_open": ["D"] This range returns all users
 *  whose `UserName` begins with B: "start_closed": ["B"] "end_open": ["C"] Key
 *  ranges honor column sort order. For example, suppose a table is defined as
 *  follows: CREATE TABLE DescendingSortedTable { Key INT64, ... ) PRIMARY
 *  KEY(Key DESC); The following range retrieves all rows with key values
 *  between 1 and 100 inclusive: "start_closed": ["100"] "end_closed": ["1"]
 *  Note that 100 is passed as the start, and 1 is passed as the end, because
 *  `Key` is a descending column in the schema.
 */
@interface GTLRSpanner_KeyRange : GTLRObject

/**
 *  If the end is closed, then the range includes all rows whose first
 *  `len(end_closed)` key columns exactly match `end_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endClosed;

/**
 *  If the end is open, then the range excludes rows whose first `len(end_open)`
 *  key columns exactly match `end_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endOpen;

/**
 *  If the start is closed, then the range includes all rows whose first
 *  `len(start_closed)` key columns exactly match `start_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startClosed;

/**
 *  If the start is open, then the range excludes rows whose first
 *  `len(start_open)` key columns exactly match `start_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startOpen;

@end


/**
 *  A message representing information for a key range (possibly one key).
 */
@interface GTLRSpanner_KeyRangeInfo : GTLRObject

/** The list of context values for this key range. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ContextValue *> *contextValues;

/**
 *  The index of the end key in indexed_keys.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endKeyIndex;

/** Information about this key range, for all metrics. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *info;

/**
 *  The number of keys this range covers.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *keysCount;

/** The name of the metric. e.g. "latency". */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *metric;

/**
 *  The index of the start key in indexed_keys.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startKeyIndex;

/** The time offset. This is the time since the start of the time interval. */
@property(nonatomic, strong, nullable) GTLRDuration *timeOffset;

/**
 *  The unit of the metric. This is an unstructured field and will be mapped as
 *  is to the user.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *unit;

/**
 *  The value of the metric.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  A message representing a list of specific information for multiple key
 *  ranges.
 */
@interface GTLRSpanner_KeyRangeInfos : GTLRObject

/** The list individual KeyRangeInfos. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_KeyRangeInfo *> *infos;

/**
 *  The total size of the list of all KeyRangeInfos. This may be larger than the
 *  number of repeated messages above. If that is the case, this number may be
 *  used to determine how many are not being shown.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  `KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All
 *  the keys are expected to be in the same table or index. The keys need not be
 *  sorted in any particular way. If the same key is specified multiple times in
 *  the set (for example if two ranges, two keys, or a key and a range overlap),
 *  Cloud Spanner behaves as if the key were only specified once.
 */
@interface GTLRSpanner_KeySet : GTLRObject

/**
 *  For convenience `all` can be set to `true` to indicate that this `KeySet`
 *  matches all keys in the table or index. Note that any keys specified in
 *  `keys` or `ranges` are only yielded once.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *all;

/**
 *  A list of specific keys. Entries in `keys` should have exactly as many
 *  elements as there are columns in the primary or index key with which this
 *  `KeySet` is used. Individual key values are encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *keys;

/**
 *  A list of key ranges. See KeyRange for more information about key range
 *  specifications.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_KeyRange *> *ranges;

@end


/**
 *  The response for ListBackupOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListBackupOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListBackupOperations call to
 *  fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching backup long-running operations. Each operation's name
 *  will be prefixed by the backup's name. The operation's metadata field type
 *  `metadata.type_url` describes the type of the metadata. Operations returned
 *  include those that are pending or have completed/failed/canceled within the
 *  last 7 days. Operations returned are ordered by
 *  `operation.metadata.value.progress.start_time` in descending order starting
 *  from the most recently started operation.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListBackups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListBackupsResponse : GTLRCollectionObject

/**
 *  The list of matching backups. Backups returned are ordered by `create_time`
 *  in descending order, starting from the most recent `create_time`.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Backup *> *backups;

/**
 *  `next_page_token` can be sent in a subsequent ListBackups call to fetch more
 *  of the matching backups.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListDatabaseOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabaseOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListDatabaseOperations call to
 *  fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching database long-running operations. Each operation's name
 *  will be prefixed by the database's name. The operation's metadata field type
 *  `metadata.type_url` describes the type of the metadata.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListDatabaseRoles.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "databaseRoles" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabaseRolesResponse : GTLRCollectionObject

/**
 *  Database roles that matched the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_DatabaseRole *> *databaseRoles;

/**
 *  `next_page_token` can be sent in a subsequent ListDatabaseRoles call to
 *  fetch more of the matching roles.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListDatabases.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "databases" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabasesResponse : GTLRCollectionObject

/**
 *  Databases that matched the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Database *> *databases;

/**
 *  `next_page_token` can be sent in a subsequent ListDatabases call to fetch
 *  more of the matching databases.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstanceConfigOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstanceConfigOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListInstanceConfigOperations
 *  call to fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching instance config long-running operations. Each
 *  operation's name will be prefixed by the instance config's name. The
 *  operation's metadata field type `metadata.type_url` describes the type of
 *  the metadata.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListInstanceConfigs.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instanceConfigs" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRSpanner_ListInstanceConfigsResponse : GTLRCollectionObject

/**
 *  The list of requested instance configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_InstanceConfig *> *instanceConfigs;

/**
 *  `next_page_token` can be sent in a subsequent ListInstanceConfigs call to
 *  fetch more of the matching instance configurations.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstancesResponse : GTLRCollectionObject

/**
 *  The list of requested instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Instance *> *instances;

/**
 *  `next_page_token` can be sent in a subsequent ListInstances call to fetch
 *  more of the matching instances.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of unreachable instances. It includes the names of instances whose
 *  metadata could not be retrieved within instance_deadline.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  Response method from the ListScans method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scans" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListScansResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Available scans based on the list query parameters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Scan *> *scans;

@end


/**
 *  The response for ListSessions.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "sessions" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListSessionsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent ListSessions call to fetch
 *  more of the matching sessions.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of requested sessions.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *sessions;

@end


/**
 *  A message representing a user-facing string whose value may need to be
 *  translated before being displayed.
 */
@interface GTLRSpanner_LocalizedString : GTLRObject

/**
 *  A map of arguments used when creating the localized message. Keys represent
 *  parameter names which may be used by the localized version when substituting
 *  dynamic values.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString_Args *args;

/**
 *  The canonical English version of this message. If no token is provided or
 *  the front-end has no message associated with the token, this text will be
 *  displayed as-is.
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  The token identifying the message, e.g. 'METRIC_READ_CPU'. This should be
 *  unique within the service.
 */
@property(nonatomic, copy, nullable) NSString *token;

@end


/**
 *  A map of arguments used when creating the localized message. Keys represent
 *  parameter names which may be used by the localized version when substituting
 *  dynamic values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_LocalizedString_Args : GTLRObject
@end


/**
 *  A message representing the actual monitoring data, values for each key
 *  bucket over time, of a metric.
 */
@interface GTLRSpanner_Metric : GTLRObject

/**
 *  The aggregation function used to aggregate each key bucket
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Metric_Aggregation_AggregationUnspecified Required
 *        default value. (Value: "AGGREGATION_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_Metric_Aggregation_Max Use the maximum of all values.
 *        (Value: "MAX")
 *    @arg @c kGTLRSpanner_Metric_Aggregation_Sum Use the sum of all values.
 *        (Value: "SUM")
 */
@property(nonatomic, copy, nullable) NSString *aggregation;

/** The category of the metric, e.g. "Activity", "Alerts", "Reads", etc. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *category;

/**
 *  The references to numerator and denominator metrics for a derived metric.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_DerivedMetric *derived;

/** The displayed label of the metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *displayLabel;

/**
 *  Whether the metric has any non-zero data.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasNonzeroData;

/**
 *  The value that is considered hot for the metric. On a per metric basis
 *  hotness signals high utilization and something that might potentially be a
 *  cause for concern by the end user. hot_value is used to calibrate and scale
 *  visual color scales.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hotValue;

/**
 *  The (sparse) mapping from time index to an IndexedHotKey message,
 *  representing those time intervals for which there are hot keys.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Metric_IndexedHotKeys *indexedHotKeys;

/**
 *  The (sparse) mapping from time interval index to an IndexedKeyRangeInfos
 *  message, representing those time intervals for which there are informational
 *  messages concerning key ranges.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Metric_IndexedKeyRangeInfos *indexedKeyRangeInfos;

/** Information about the metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *info;

/** The data for the metric as a matrix. */
@property(nonatomic, strong, nullable) GTLRSpanner_MetricMatrix *matrix;

/** The unit of the metric. */
@property(nonatomic, strong, nullable) GTLRSpanner_LocalizedString *unit;

/**
 *  Whether the metric is visible to the end user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *visible;

@end


/**
 *  The (sparse) mapping from time index to an IndexedHotKey message,
 *  representing those time intervals for which there are hot keys.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_IndexedHotKey. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Metric_IndexedHotKeys : GTLRObject
@end


/**
 *  The (sparse) mapping from time interval index to an IndexedKeyRangeInfos
 *  message, representing those time intervals for which there are informational
 *  messages concerning key ranges.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_IndexedKeyRangeInfos. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Metric_IndexedKeyRangeInfos : GTLRObject
@end


/**
 *  A message representing a matrix of floats.
 */
@interface GTLRSpanner_MetricMatrix : GTLRObject

/** The rows of the matrix. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_MetricMatrixRow *> *rows;

@end


/**
 *  A message representing a row of a matrix of floats.
 */
@interface GTLRSpanner_MetricMatrixRow : GTLRObject

/**
 *  The columns of the row.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cols;

@end


/**
 *  A modification to one or more Cloud Spanner rows. Mutations can be applied
 *  to a Cloud Spanner database by sending them in a Commit call.
 */
@interface GTLRSpanner_Mutation : GTLRObject

/**
 *  Delete rows from a table. Succeeds whether or not the named rows were
 *  present.
 *
 *  Remapped to 'deleteProperty' to avoid language reserved word 'delete'.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Delete *deleteProperty;

/**
 *  Insert new rows in a table. If any of the rows already exist, the write or
 *  transaction fails with error `ALREADY_EXISTS`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insert;

/**
 *  Like insert, except that if the row already exists, then its column values
 *  are overwritten with the ones provided. Any column values not explicitly
 *  written are preserved. When using insert_or_update, just as when using
 *  insert, all `NOT NULL` columns in the table must be given a value. This
 *  holds true even when the row already exists and will therefore actually be
 *  updated.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insertOrUpdate;

/**
 *  Like insert, except that if the row already exists, it is deleted, and the
 *  column values provided are inserted instead. Unlike insert_or_update, this
 *  means any values not explicitly written become `NULL`. In an interleaved
 *  table, if you create the child table with the `ON DELETE CASCADE`
 *  annotation, then replacing a parent row also deletes the child rows.
 *  Otherwise, you must delete the child rows before you replace the parent row.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *replace;

/**
 *  Update existing rows in a table. If any of the rows does not already exist,
 *  the transaction fails with error `NOT_FOUND`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *update;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRSpanner_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Response : GTLRObject
@end


/**
 *  Encapsulates progress related information for a Cloud Spanner long running
 *  operation.
 */
@interface GTLRSpanner_OperationProgress : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Percent completion of the operation. Values are between 0 and 100 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *progressPercent;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Metadata type for the long-running operation used to track the progress of
 *  optimizations performed on a newly restored database. This long-running
 *  operation is automatically created by the system after the successful
 *  completion of a database restore, and cannot be cancelled.
 */
@interface GTLRSpanner_OptimizeRestoredDatabaseMetadata : GTLRObject

/** Name of the restored database being optimized. */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the post-restore optimizations. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

@end


/**
 *  Partial results from a streaming read or SQL query. Streaming reads and SQL
 *  queries better tolerate large result sets, large rows, and large values, but
 *  are a little trickier to consume.
 */
@interface GTLRSpanner_PartialResultSet : GTLRObject

/**
 *  If true, then the final value in values is chunked, and must be combined
 *  with more values from subsequent `PartialResultSet`s to obtain a complete
 *  field value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *chunkedValue;

/**
 *  Metadata about the result set, such as row type information. Only present in
 *  the first response.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Streaming calls might be interrupted for a variety of reasons, such as TCP
 *  connection loss. If this occurs, the stream of results can be resumed by
 *  re-sending the original request and including `resume_token`. Note that
 *  executing any other transaction in the same session invalidates the token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  Query plan and execution statistics for the statement that produced this
 *  streaming result set. These can be requested by setting
 *  ExecuteSqlRequest.query_mode and are sent only once with the last response
 *  in the stream. This field will also be present in the last response for DML
 *  statements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

/**
 *  A streamed result set consists of a stream of values, which might be split
 *  into many `PartialResultSet` messages to accommodate large rows and/or large
 *  values. Every N complete values defines a row, where N is equal to the
 *  number of entries in metadata.row_type.fields. Most values are encoded based
 *  on type as described here. It is possible that the last value in values is
 *  "chunked", meaning that the rest of the value is sent in subsequent
 *  `PartialResultSet`(s). This is denoted by the chunked_value field. Two or
 *  more chunked values can be merged to form a complete value as follows: *
 *  `bool/number/null`: cannot be chunked * `string`: concatenate the strings *
 *  `list`: concatenate the lists. If the last element in a list is a `string`,
 *  `list`, or `object`, merge it with the first element in the next list by
 *  applying these rules recursively. * `object`: concatenate the (field name,
 *  field value) pairs. If a field name is duplicated, then apply these rules
 *  recursively to merge the field values. Some examples of merging: # Strings
 *  are concatenated. "foo", "bar" => "foobar" # Lists of non-strings are
 *  concatenated. [2, 3], [4] => [2, 3, 4] # Lists are concatenated, but the
 *  last and first elements are merged # because they are strings. ["a", "b"],
 *  ["c", "d"] => ["a", "bc", "d"] # Lists are concatenated, but the last and
 *  first elements are merged # because they are lists. Recursively, the last
 *  and first elements # of the inner lists are merged because they are strings.
 *  ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"] # Non-overlapping
 *  object fields are combined. {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"} #
 *  Overlapping object fields are merged. {"a": "1"}, {"a": "2"} => {"a": "12"}
 *  # Examples of merging objects containing lists of strings. {"a": ["1"]},
 *  {"a": ["2"]} => {"a": ["12"]} For a more complete example, suppose a
 *  streaming SQL query is yielding a result set whose rows contain a single
 *  string field. The following `PartialResultSet`s might be yielded: {
 *  "metadata": { ... } "values": ["Hello", "W"] "chunked_value": true
 *  "resume_token": "Af65..." } { "values": ["orl"] "chunked_value": true } {
 *  "values": ["d"] "resume_token": "Zx1B..." } This sequence of
 *  `PartialResultSet`s encodes two rows, one containing the field value
 *  `"Hello"`, and a second containing the field value `"World" = "W" + "orl" +
 *  "d"`. Not all `PartialResultSet`s contain a `resume_token`. Execution can
 *  only be resumed from a previously yielded `resume_token`. For the above
 *  sequence of `PartialResultSet`s, resuming the query with `"resume_token":
 *  "Af65..."` will yield results from the `PartialResultSet` with value
 *  `["orl"]`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *values;

@end


/**
 *  Information returned for each partition returned in a PartitionResponse.
 */
@interface GTLRSpanner_Partition : GTLRObject

/**
 *  This token can be passed to Read, StreamingRead, ExecuteSql, or
 *  ExecuteStreamingSql requests to restrict the results to those identified by
 *  this partition token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

@end


/**
 *  Message type to initiate a Partitioned DML transaction.
 */
@interface GTLRSpanner_PartitionedDml : GTLRObject
@end


/**
 *  Options for a PartitionQueryRequest and PartitionReadRequest.
 */
@interface GTLRSpanner_PartitionOptions : GTLRObject

/**
 *  **Note:** This hint is currently ignored by PartitionQuery and PartitionRead
 *  requests. The desired maximum number of partitions to return. For example,
 *  this may be set to the number of workers available. The default for this
 *  option is currently 10,000. The maximum value is currently 200,000. This is
 *  only a hint. The actual number of partitions returned may be smaller or
 *  larger than this maximum count request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPartitions;

/**
 *  **Note:** This hint is currently ignored by PartitionQuery and PartitionRead
 *  requests. The desired data size for each partition generated. The default
 *  for this option is currently 1 GiB. This is only a hint. The actual size of
 *  each partition may be smaller or larger than this size request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionSizeBytes;

@end


/**
 *  The request for PartitionQuery
 */
@interface GTLRSpanner_PartitionQueryRequest : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It is an
 *  error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL query parameters. See the definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_ParamTypes *paramTypes;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/**
 *  Required. The query request to generate partitions for. The request will
 *  fail if the query is not root partitionable. The query plan of a root
 *  partitionable query has a single distributed union operator. A distributed
 *  union operator conceptually divides one or more tables into multiple splits,
 *  remotely evaluates a subquery independently on each split, and then unions
 *  all results. This must not contain DML commands, such as INSERT, UPDATE, or
 *  DELETE. Use ExecuteStreamingSql with a PartitionedDml transaction for large,
 *  partition-friendly DML operations.
 */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Parameter names and values that bind to placeholders in the SQL string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It is an
 *  error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL query parameters. See the definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_ParamTypes : GTLRObject
@end


/**
 *  The request for PartitionRead
 */
@interface GTLRSpanner_PartitionReadRequest : GTLRObject

/** The columns of table to be returned for each row matching this request. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is used instead of
 *  the table primary key when interpreting key_set and sorting result rows. See
 *  key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index is present. If
 *  index is present, then key_set instead names index keys in index. It is not
 *  an error for the `key_set` to name rows that do not exist in the database.
 *  Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for PartitionQuery or PartitionRead
 */
@interface GTLRSpanner_PartitionResponse : GTLRObject

/** Partitions created by this request. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Partition *> *partitions;

/** Transaction created by this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

@end


/**
 *  Node information for nodes appearing in a QueryPlan.plan_nodes.
 */
@interface GTLRSpanner_PlanNode : GTLRObject

/** List of child node `index`es and their relationship to this parent. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ChildLink *> *childLinks;

/** The display name for the node. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_ExecutionStats *executionStats;

/**
 *  The `PlanNode`'s index in node list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Used to determine the type of node. May be needed for visualizing different
 *  kinds of nodes differently. For example, If the node is a SCALAR node, it
 *  will have a condensed representation which can be used to directly embed a
 *  description of the node in its parent.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_PlanNode_Kind_KindUnspecified Not specified. (Value:
 *        "KIND_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Relational Denotes a Relational
 *        operator node in the expression tree. Relational operators represent
 *        iterative processing of rows during query execution. For example, a
 *        `TableScan` operation that reads rows from a table. (Value:
 *        "RELATIONAL")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Scalar Denotes a Scalar node in the
 *        expression tree. Scalar nodes represent non-iterable entities in the
 *        query plan. For example, constants or arithmetic operators appearing
 *        inside predicate expressions or references to column names. (Value:
 *        "SCALAR")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Attributes relevant to the node contained in a group of key-value pairs. For
 *  example, a Parameter Reference node could have the following information in
 *  its metadata: { "parameter_reference": "param1", "parameter_type": "array" }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_Metadata *metadata;

/** Condensed representation for SCALAR nodes. */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation *shortRepresentation;

@end


/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_ExecutionStats : GTLRObject
@end


/**
 *  Attributes relevant to the node contained in a group of key-value pairs. For
 *  example, a Parameter Reference node could have the following information in
 *  its metadata: { "parameter_reference": "param1", "parameter_type": "array" }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_Metadata : GTLRObject
@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRSpanner_Policy : GTLRObject

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  A message representing a key prefix node in the key prefix hierarchy. for
 *  eg. Bigtable keyspaces are lexicographically ordered mappings of keys to
 *  values. Keys often have a shared prefix structure where users use the keys
 *  to organize data. Eg ///employee In this case Keysight will possibly use one
 *  node for a company and reuse it for all employees that fall under the
 *  company. Doing so improves legibility in the UI.
 */
@interface GTLRSpanner_PrefixNode : GTLRObject

/**
 *  Whether this corresponds to a data_source name.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataSourceNode;

/**
 *  The depth in the prefix hierarchy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *depth;

/**
 *  The index of the end key bucket of the range that this node spans.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endIndex;

/**
 *  The index of the start key bucket of the range that this node spans.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startIndex;

/** The string represented by the prefix node. */
@property(nonatomic, copy, nullable) NSString *word;

@end


/**
 *  Query optimizer configuration.
 */
@interface GTLRSpanner_QueryOptions : GTLRObject

/**
 *  An option to control the selection of optimizer statistics package. This
 *  parameter allows individual queries to use a different query optimizer
 *  statistics package. Specifying `latest` as a value instructs Cloud Spanner
 *  to use the latest generated statistics package. If not specified, Cloud
 *  Spanner uses the statistics package set at the database level options, or
 *  the latest package if the database option is not set. The statistics package
 *  requested by the query has to be exempt from garbage collection. This can be
 *  achieved with the following DDL statement: ``` ALTER STATISTICS SET OPTIONS
 *  (allow_gc=false) ``` The list of available statistics packages can be
 *  queried from `INFORMATION_SCHEMA.SPANNER_STATISTICS`. Executing a SQL
 *  statement with an invalid optimizer statistics package or with a statistics
 *  package that allows garbage collection fails with an `INVALID_ARGUMENT`
 *  error.
 */
@property(nonatomic, copy, nullable) NSString *optimizerStatisticsPackage;

/**
 *  An option to control the selection of optimizer version. This parameter
 *  allows individual queries to pick different query optimizer versions.
 *  Specifying `latest` as a value instructs Cloud Spanner to use the latest
 *  supported query optimizer version. If not specified, Cloud Spanner uses the
 *  optimizer version set at the database level options. Any other positive
 *  integer (from the list of supported optimizer versions) overrides the
 *  default optimizer version for query execution. The list of supported
 *  optimizer versions can be queried from
 *  SPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS. Executing a SQL statement with an
 *  invalid optimizer version fails with an `INVALID_ARGUMENT` error. See
 *  https://cloud.google.com/spanner/docs/query-optimizer/manage-query-optimizer
 *  for more information on managing the query optimizer. The
 *  `optimizer_version` statement hint has precedence over this setting.
 */
@property(nonatomic, copy, nullable) NSString *optimizerVersion;

@end


/**
 *  Contains an ordered list of nodes appearing in the query plan.
 */
@interface GTLRSpanner_QueryPlan : GTLRObject

/**
 *  The nodes in the query plan. Plan nodes are returned in pre-order starting
 *  with the plan root. Each PlanNode's `id` corresponds to its index in
 *  `plan_nodes`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_PlanNode *> *planNodes;

@end


/**
 *  Message type to initiate a read-only transaction.
 */
@interface GTLRSpanner_ReadOnly : GTLRObject

/**
 *  Executes all reads at a timestamp that is `exact_staleness` old. The
 *  timestamp is chosen soon after the read is started. Guarantees that all
 *  writes that have committed more than the specified number of seconds ago are
 *  visible. Because Cloud Spanner chooses the exact timestamp, this mode works
 *  even if the client's local clock is substantially skewed from Cloud Spanner
 *  commit timestamps. Useful for reading at nearby replicas without the
 *  distributed timestamp negotiation overhead of `max_staleness`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *exactStaleness;

/**
 *  Read data at a timestamp >= `NOW - max_staleness` seconds. Guarantees that
 *  all writes that have committed more than the specified number of seconds ago
 *  are visible. Because Cloud Spanner chooses the exact timestamp, this mode
 *  works even if the client's local clock is substantially skewed from Cloud
 *  Spanner commit timestamps. Useful for reading the freshest data available at
 *  a nearby replica, while bounding the possible staleness if the local replica
 *  has fallen behind. Note that this option can only be used in single-use
 *  transactions.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxStaleness;

/**
 *  Executes all reads at a timestamp >= `min_read_timestamp`. This is useful
 *  for requesting fresher data than some previous read, or data that is fresh
 *  enough to observe the effects of some previously committed transaction whose
 *  timestamp is known. Note that this option can only be used in single-use
 *  transactions. A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to
 *  nanoseconds. Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *minReadTimestamp;

/**
 *  Executes all reads at the given timestamp. Unlike other modes, reads at a
 *  specific timestamp are repeatable; the same read at the same timestamp
 *  always returns the same data. If the timestamp is in the future, the read
 *  will block until the specified timestamp, modulo the read's deadline. Useful
 *  for large scale consistent reads such as mapreduces, or for coordinating
 *  many reads against a consistent snapshot of the data. A timestamp in RFC3339
 *  UTC \\"Zulu\\" format, accurate to nanoseconds. Example:
 *  `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

/**
 *  If true, the Cloud Spanner-selected read timestamp is included in the
 *  Transaction message that describes the transaction.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *returnReadTimestamp;

/**
 *  Read at a timestamp where all previously committed transactions are visible.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strong;

@end


/**
 *  The request for Read and StreamingRead.
 */
@interface GTLRSpanner_ReadRequest : GTLRObject

/**
 *  Required. The columns of table to be returned for each row matching this
 *  request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is used instead of
 *  the table primary key when interpreting key_set and sorting result rows. See
 *  key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index is present. If
 *  index is present, then key_set instead names index keys in index. If the
 *  partition_token field is empty, rows are yielded in table primary key order
 *  (if index is empty) or index key order (if index is non-empty). If the
 *  partition_token field is not empty, rows will be yielded in an unspecified
 *  order. It is not an error for the `key_set` to name rows that do not exist
 *  in the database. Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/**
 *  If greater than zero, only the first `limit` rows are yielded. If `limit` is
 *  zero, the default is no limit. A limit cannot be specified if
 *  `partition_token` is set.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *limit;

/**
 *  If present, results will be restricted to the specified partition previously
 *  created using PartitionRead(). There must be an exact match for the values
 *  of fields common to this message and the PartitionReadRequest message used
 *  to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/** Common options for this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_RequestOptions *requestOptions;

/**
 *  If this request is resuming a previously interrupted read, `resume_token`
 *  should be copied from the last PartialResultSet yielded before the
 *  interruption. Doing this enables the new read to resume where the last read
 *  left off. The rest of the request parameters must exactly match the request
 *  that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The transaction to use. If none is provided, the default is a temporary
 *  read-only transaction with strong concurrency.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Message type to initiate a read-write transaction. Currently this
 *  transaction type has no options.
 */
@interface GTLRSpanner_ReadWrite : GTLRObject

/**
 *  Read lock mode for the transaction.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReadWrite_ReadLockMode_Optimistic Optimistic lock
 *        mode. Locks for reads within the transaction are not acquired on read.
 *        Instead the locks are acquired on a commit to validate that
 *        read/queried data has not changed since the transaction started.
 *        (Value: "OPTIMISTIC")
 *    @arg @c kGTLRSpanner_ReadWrite_ReadLockMode_Pessimistic Pessimistic lock
 *        mode. Read locks are acquired immediately on read. (Value:
 *        "PESSIMISTIC")
 *    @arg @c kGTLRSpanner_ReadWrite_ReadLockMode_ReadLockModeUnspecified
 *        Default value. If the value is not specified, the pessimistic read
 *        lock is used. (Value: "READ_LOCK_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *readLockMode;

@end


/**
 *  GTLRSpanner_ReplicaInfo
 */
@interface GTLRSpanner_ReplicaInfo : GTLRObject

/**
 *  If true, this location is designated as the default leader location where
 *  leader replicas are placed. See the [region types
 *  documentation](https://cloud.google.com/spanner/docs/instances#region_types)
 *  for more details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultLeaderLocation;

/** The location of the serving resources, e.g. "us-central1". */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The type of replica.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_ReadOnly Read-only replicas only
 *        support reads (not writes). Read-only replicas: * Maintain a full copy
 *        of your data. * Serve reads. * Do not participate in voting to commit
 *        writes. * Are not eligible to become a leader. (Value: "READ_ONLY")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_ReadWrite Read-write replicas
 *        support both reads and writes. These replicas: * Maintain a full copy
 *        of your data. * Serve reads. * Can vote whether to commit a write. *
 *        Participate in leadership election. * Are eligible to become a leader.
 *        (Value: "READ_WRITE")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_TypeUnspecified Not specified.
 *        (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_Witness Witness replicas don't
 *        support reads but do participate in voting to commit writes. Witness
 *        replicas: * Do not maintain a full copy of data. * Do not serve reads.
 *        * Vote whether to commit writes. * Participate in leader election but
 *        are not eligible to become leader. (Value: "WITNESS")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Common request options for various APIs.
 */
@interface GTLRSpanner_RequestOptions : GTLRObject

/**
 *  Priority for the request.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityHigh This specifies
 *        that the request is high priority. (Value: "PRIORITY_HIGH")
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityLow This specifies
 *        that the request is low priority. (Value: "PRIORITY_LOW")
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityMedium This specifies
 *        that the request is medium priority. (Value: "PRIORITY_MEDIUM")
 *    @arg @c kGTLRSpanner_RequestOptions_Priority_PriorityUnspecified
 *        `PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`. (Value:
 *        "PRIORITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *priority;

/**
 *  A per-request tag which can be applied to queries or reads, used for
 *  statistics collection. Both request_tag and transaction_tag can be specified
 *  for a read or query that belongs to a transaction. This field is ignored for
 *  requests where it's not applicable (e.g. CommitRequest). Legal characters
 *  for `request_tag` values are all printable characters (ASCII 32 - 126) and
 *  the length of a request_tag is limited to 50 characters. Values that exceed
 *  this limit are truncated. Any leading underscore (_) characters will be
 *  removed from the string.
 */
@property(nonatomic, copy, nullable) NSString *requestTag;

/**
 *  A tag used for statistics collection about this transaction. Both
 *  request_tag and transaction_tag can be specified for a read or query that
 *  belongs to a transaction. The value of transaction_tag should be the same
 *  for all requests belonging to the same transaction. If this request doesn't
 *  belong to any transaction, transaction_tag will be ignored. Legal characters
 *  for `transaction_tag` values are all printable characters (ASCII 32 - 126)
 *  and the length of a transaction_tag is limited to 50 characters. Values that
 *  exceed this limit are truncated. Any leading underscore (_) characters will
 *  be removed from the string.
 */
@property(nonatomic, copy, nullable) NSString *transactionTag;

@end


/**
 *  Encryption configuration for the restored database.
 */
@interface GTLRSpanner_RestoreDatabaseEncryptionConfig : GTLRObject

/**
 *  Required. The encryption type of the restored database.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_CustomerManagedEncryption
 *        Use customer managed encryption. If specified, `kms_key_name` must
 *        must contain a valid Cloud KMS key. (Value:
 *        "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionTypeUnspecified
 *        Unspecified. Do not use. (Value: "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_GoogleDefaultEncryption
 *        Use Google default encryption. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 *    @arg @c kGTLRSpanner_RestoreDatabaseEncryptionConfig_EncryptionType_UseConfigDefaultOrBackupEncryption
 *        This is the default option when encryption_config is not specified.
 *        (Value: "USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Optional. The Cloud KMS key that will be used to encrypt/decrypt the
 *  restored database. This field should be set only when encryption_type is
 *  `CUSTOMER_MANAGED_ENCRYPTION`. Values are of the form
 *  `projects//locations//keyRings//cryptoKeys/`.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

@end


/**
 *  Metadata type for the long-running operation returned by RestoreDatabase.
 */
@interface GTLRSpanner_RestoreDatabaseMetadata : GTLRObject

/** Information about the backup used to restore the database. */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupInfo *backupInfo;

/**
 *  The time at which cancellation of this operation was received.
 *  Operations.CancelOperation starts asynchronous cancellation on a
 *  long-running operation. The server makes a best effort to cancel the
 *  operation, but success is not guaranteed. Clients can use
 *  Operations.GetOperation or other methods to check whether the cancellation
 *  succeeded or whether the operation completed despite cancellation. On
 *  successful cancellation, the operation is not deleted; instead, it becomes
 *  an operation with an Operation.error value with a google.rpc.Status.code of
 *  1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** Name of the database being created and restored to. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If exists, the name of the long-running operation that will be used to track
 *  the post-restore optimization process to optimize the performance of the
 *  restored database, and remove the dependency on the restore source. The name
 *  is of the form `projects//instances//databases//operations/` where the is
 *  the name of database being created and restored to. The metadata type of the
 *  long-running operation is OptimizeRestoredDatabaseMetadata. This
 *  long-running operation will be automatically created by the system after the
 *  RestoreDatabase long-running operation completes successfully. This
 *  operation will not be created if the restore was not successful.
 */
@property(nonatomic, copy, nullable) NSString *optimizeDatabaseOperationName;

/** The progress of the RestoreDatabase operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreDatabaseMetadata_SourceType_Backup A backup
 *        was used as the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRSpanner_RestoreDatabaseMetadata_SourceType_TypeUnspecified No
 *        restore associated. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  The request for RestoreDatabase.
 */
@interface GTLRSpanner_RestoreDatabaseRequest : GTLRObject

/**
 *  Name of the backup from which to restore. Values are of the form
 *  `projects//instances//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  Required. The id of the database to create and restore to. This database
 *  must not already exist. The `database_id` appended to `parent` forms the
 *  full database name of the form `projects//instances//databases/`.
 */
@property(nonatomic, copy, nullable) NSString *databaseId;

/**
 *  Optional. An encryption configuration describing the encryption type and key
 *  resources in Cloud KMS used to encrypt/decrypt the database to restore to.
 *  If this field is not specified, the restored database will use the same
 *  encryption configuration as the backup by default, namely encryption_type =
 *  `USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RestoreDatabaseEncryptionConfig *encryptionConfig;

@end


/**
 *  Information about the database restore.
 */
@interface GTLRSpanner_RestoreInfo : GTLRObject

/**
 *  Information about the backup used to restore the database. The backup may no
 *  longer exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupInfo *backupInfo;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreInfo_SourceType_Backup A backup was used as
 *        the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRSpanner_RestoreInfo_SourceType_TypeUnspecified No restore
 *        associated. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  Results from Read or ExecuteSql.
 */
@interface GTLRSpanner_ResultSet : GTLRObject

/** Metadata about the result set, such as row type information. */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Each element in `rows` is a row whose format is defined by
 *  metadata.row_type. The ith element in each row matches the ith field in
 *  metadata.row_type. Elements are encoded based on type as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *rows;

/**
 *  Query plan and execution statistics for the SQL statement that produced this
 *  result set. These can be requested by setting ExecuteSqlRequest.query_mode.
 *  DML statements always produce stats containing the number of rows modified,
 *  unless executed using the ExecuteSqlRequest.QueryMode.PLAN
 *  ExecuteSqlRequest.query_mode. Other fields may or may not be populated,
 *  based on the ExecuteSqlRequest.query_mode.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

@end


/**
 *  Metadata about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetMetadata : GTLRObject

/**
 *  Indicates the field names and types for the rows in the result set. For
 *  example, a SQL query like `"SELECT UserId, UserName FROM Users"` could
 *  return a `row_type` value like: "fields": [ { "name": "UserId", "type": {
 *  "code": "INT64" } }, { "name": "UserName", "type": { "code": "STRING" } }, ]
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *rowType;

/**
 *  If the read or SQL query began a transaction as a side-effect, the
 *  information about the new transaction is yielded here.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

/**
 *  A SQL query can be parameterized. In PLAN mode, these parameters can be
 *  undeclared. This indicates the field names and types for those undeclared
 *  parameters in the SQL query. For example, a SQL query like `"SELECT * FROM
 *  Users where UserId = \@userId and UserName = \@userName "` could return a
 *  `undeclared_parameters` value like: "fields": [ { "name": "UserId", "type":
 *  { "code": "INT64" } }, { "name": "UserName", "type": { "code": "STRING" } },
 *  ]
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *undeclaredParameters;

@end


/**
 *  Additional statistics about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetStats : GTLRObject

/** QueryPlan for the query associated with this result. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryPlan *queryPlan;

/**
 *  Aggregated statistics from the execution of the query. Only present when the
 *  query is profiled. For example, a query could return the statistics as
 *  follows: { "rows_returned": "3", "elapsed_time": "1.22 secs", "cpu_time":
 *  "1.19 secs" }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats_QueryStats *queryStats;

/**
 *  Standard DML returns an exact count of rows that were modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountExact;

/**
 *  Partitioned DML does not offer exactly-once semantics, so it returns a lower
 *  bound of the rows modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountLowerBound;

@end


/**
 *  Aggregated statistics from the execution of the query. Only present when the
 *  query is profiled. For example, a query could return the statistics as
 *  follows: { "rows_returned": "3", "elapsed_time": "1.22 secs", "cpu_time":
 *  "1.19 secs" }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ResultSetStats_QueryStats : GTLRObject
@end


/**
 *  The request for Rollback.
 */
@interface GTLRSpanner_RollbackRequest : GTLRObject

/**
 *  Required. The transaction to roll back.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  Scan is a structure which describes Cloud Key Visualizer scan information.
 */
@interface GTLRSpanner_Scan : GTLRObject

/** Additional information provided by the implementer. */
@property(nonatomic, strong, nullable) GTLRSpanner_Scan_Details *details;

/** The upper bound for when the scan is defined. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  The unique name of the scan, specific to the Database service implementing
 *  this interface.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Cloud Key Visualizer scan data. Note, this field is not
 *  available to the ListScans method.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ScanData *scanData;

/**
 *  A range of time (inclusive) for when the scan is defined. The lower bound
 *  for when the scan is defined.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Additional information provided by the implementer.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Scan_Details : GTLRObject
@end


/**
 *  ScanData contains Cloud Key Visualizer scan data used by the caller to
 *  construct a visualization.
 */
@interface GTLRSpanner_ScanData : GTLRObject

/**
 *  Cloud Key Visualizer scan data. The range of time this information covers is
 *  captured via the above time range fields. Note, this field is not available
 *  to the ListScans method.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_VisualizationData *data;

/** The upper bound for when the contained data is defined. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  A range of time (inclusive) for when the contained data is defined. The
 *  lower bound for when the contained data is defined.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  A session in the Cloud Spanner API.
 */
@interface GTLRSpanner_Session : GTLRObject

/**
 *  Output only. The approximate timestamp when the session is last used. It is
 *  typically earlier than the actual last use time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *approximateLastUseTime;

/** Output only. The timestamp when the session is created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The database role which created this session. */
@property(nonatomic, copy, nullable) NSString *creatorRole;

/**
 *  The labels for the session. * Label keys must be between 1 and 63 characters
 *  long and must conform to the following regular expression:
 *  `[a-z]([-a-z0-9]*[a-z0-9])?`. * Label values must be between 0 and 63
 *  characters long and must conform to the regular expression
 *  `([a-z]([-a-z0-9]*[a-z0-9])?)?`. * No more than 64 labels can be associated
 *  with a given session. See https://goo.gl/xmQnxf for more information on and
 *  examples of labels.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Session_Labels *labels;

/** Output only. The name of the session. This is always system-assigned. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The labels for the session. * Label keys must be between 1 and 63 characters
 *  long and must conform to the following regular expression:
 *  `[a-z]([-a-z0-9]*[a-z0-9])?`. * Label values must be between 0 and 63
 *  characters long and must conform to the regular expression
 *  `([a-z]([-a-z0-9]*[a-z0-9])?)?`. * No more than 64 labels can be associated
 *  with a given session. See https://goo.gl/xmQnxf for more information on and
 *  examples of labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Session_Labels : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRSpanner_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Policy *policy;

@end


/**
 *  Condensed representation of a node and its subtree. Only present for
 *  `SCALAR` PlanNode(s).
 */
@interface GTLRSpanner_ShortRepresentation : GTLRObject

/**
 *  A string representation of the expression subtree rooted at this node.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases where
 *  the `description` string of this node references a `SCALAR` subquery
 *  contained in the expression subtree rooted at this node. The referenced
 *  `SCALAR` subquery may not necessarily be a direct child of this node.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation_Subqueries *subqueries;

@end


/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases where
 *  the `description` string of this node references a `SCALAR` subquery
 *  contained in the expression subtree rooted at this node. The referenced
 *  `SCALAR` subquery may not necessarily be a direct child of this node.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ShortRepresentation_Subqueries : GTLRObject
@end


/**
 *  A single DML statement.
 */
@interface GTLRSpanner_Statement : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the DML string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It is an
 *  error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Statement_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL statement parameters. See the definition of Type for more
 *  information about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Statement_ParamTypes *paramTypes;

/** Required. The DML string. */
@property(nonatomic, copy, nullable) NSString *sql;

@end


/**
 *  Parameter names and values that bind to placeholders in the DML string. A
 *  parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores. Parameters can appear anywhere that a
 *  literal value is expected. The same parameter name can be used more than
 *  once, for example: `"WHERE id > \@msg_id AND id < \@msg_id + 100"` It is an
 *  error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Statement_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type from
 *  a JSON value. For example, values of type `BYTES` and values of type
 *  `STRING` both appear in params as JSON strings. In these cases,
 *  `param_types` can be used to specify the exact SQL type for some or all of
 *  the SQL statement parameters. See the definition of Type for more
 *  information about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Statement_ParamTypes : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRSpanner_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRSpanner_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Status_Details_Item : GTLRObject
@end


/**
 *  `StructType` defines the fields of a STRUCT type.
 */
@interface GTLRSpanner_StructType : GTLRObject

/**
 *  The list of fields that make up this struct. Order is significant, because
 *  values of this struct type are represented as lists, where the order of
 *  field values matches the order of fields in the StructType. In turn, the
 *  order of fields matches the order of columns in a read request, or the order
 *  of fields in the `SELECT` clause of a query.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Field *> *fields;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsRequest : GTLRObject

/**
 *  REQUIRED: The set of permissions to check for 'resource'. Permissions with
 *  wildcards (such as '*', 'spanner.*', 'spanner.instances.*') are not allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  A transaction.
 */
@interface GTLRSpanner_Transaction : GTLRObject

/**
 *  `id` may be used to identify the transaction in subsequent Read, ExecuteSql,
 *  Commit, or Rollback calls. Single-use read-only transactions do not have
 *  IDs, because single-use transactions do not support multiple requests.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  For snapshot read-only transactions, the read timestamp chosen for the
 *  transaction. Not returned by default: see
 *  TransactionOptions.ReadOnly.return_read_timestamp. A timestamp in RFC3339
 *  UTC \\"Zulu\\" format, accurate to nanoseconds. Example:
 *  `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

@end


/**
 *  Transactions: Each session can have at most one active transaction at a time
 *  (note that standalone reads and queries use a transaction internally and do
 *  count towards the one transaction limit). After the active transaction is
 *  completed, the session can immediately be re-used for the next transaction.
 *  It is not necessary to create a new session for each transaction.
 *  Transaction modes: Cloud Spanner supports three transaction modes: 1.
 *  Locking read-write. This type of transaction is the only way to write data
 *  into Cloud Spanner. These transactions rely on pessimistic locking and, if
 *  necessary, two-phase commit. Locking read-write transactions may abort,
 *  requiring the application to retry. 2. Snapshot read-only. Snapshot
 *  read-only transactions provide guaranteed consistency across several reads,
 *  but do not allow writes. Snapshot read-only transactions can be configured
 *  to read at timestamps in the past, or configured to perform a strong read
 *  (where Spanner will select a timestamp such that the read is guaranteed to
 *  see the effects of all transactions that have committed before the start of
 *  the read). Snapshot read-only transactions do not need to be committed.
 *  Queries on change streams must be performed with the snapshot read-only
 *  transaction mode, specifying a strong read. Please see
 *  TransactionOptions.ReadOnly.strong for more details. 3. Partitioned DML.
 *  This type of transaction is used to execute a single Partitioned DML
 *  statement. Partitioned DML partitions the key space and runs the DML
 *  statement over each partition in parallel using separate, internal
 *  transactions that commit independently. Partitioned DML transactions do not
 *  need to be committed. For transactions that only read, snapshot read-only
 *  transactions provide simpler semantics and are almost always faster. In
 *  particular, read-only transactions do not take locks, so they do not
 *  conflict with read-write transactions. As a consequence of not taking locks,
 *  they also do not abort, so retry loops are not needed. Transactions may only
 *  read-write data in a single database. They may, however, read-write data in
 *  different tables within that database. Locking read-write transactions:
 *  Locking transactions may be used to atomically read-modify-write data
 *  anywhere in a database. This type of transaction is externally consistent.
 *  Clients should attempt to minimize the amount of time a transaction is
 *  active. Faster transactions commit with higher probability and cause less
 *  contention. Cloud Spanner attempts to keep read locks active as long as the
 *  transaction continues to do reads, and the transaction has not been
 *  terminated by Commit or Rollback. Long periods of inactivity at the client
 *  may cause Cloud Spanner to release a transaction's locks and abort it.
 *  Conceptually, a read-write transaction consists of zero or more reads or SQL
 *  statements followed by Commit. At any time before Commit, the client can
 *  send a Rollback request to abort the transaction. Semantics: Cloud Spanner
 *  can commit the transaction if all read locks it acquired are still valid at
 *  commit time, and it is able to acquire write locks for all writes. Cloud
 *  Spanner can abort the transaction for any reason. If a commit attempt
 *  returns `ABORTED`, Cloud Spanner guarantees that the transaction has not
 *  modified any user data in Cloud Spanner. Unless the transaction commits,
 *  Cloud Spanner makes no guarantees about how long the transaction's locks
 *  were held for. It is an error to use Cloud Spanner locks for any sort of
 *  mutual exclusion other than between Cloud Spanner transactions themselves.
 *  Retrying aborted transactions: When a transaction aborts, the application
 *  can choose to retry the whole transaction again. To maximize the chances of
 *  successfully committing the retry, the client should execute the retry in
 *  the same session as the original attempt. The original session's lock
 *  priority increases with each consecutive abort, meaning that each attempt
 *  has a slightly better chance of success than the previous. Under some
 *  circumstances (for example, many transactions attempting to modify the same
 *  row(s)), a transaction can abort many times in a short period before
 *  successfully committing. Thus, it is not a good idea to cap the number of
 *  retries a transaction can attempt; instead, it is better to limit the total
 *  amount of time spent retrying. Idle transactions: A transaction is
 *  considered idle if it has no outstanding reads or SQL queries and has not
 *  started a read or SQL query within the last 10 seconds. Idle transactions
 *  can be aborted by Cloud Spanner so that they don't hold on to locks
 *  indefinitely. If an idle transaction is aborted, the commit will fail with
 *  error `ABORTED`. If this behavior is undesirable, periodically executing a
 *  simple SQL query in the transaction (for example, `SELECT 1`) prevents the
 *  transaction from becoming idle. Snapshot read-only transactions: Snapshot
 *  read-only transactions provides a simpler method than locking read-write
 *  transactions for doing several consistent reads. However, this type of
 *  transaction does not support writes. Snapshot transactions do not take
 *  locks. Instead, they work by choosing a Cloud Spanner timestamp, then
 *  executing all reads at that timestamp. Since they do not acquire locks, they
 *  do not block concurrent read-write transactions. Unlike locking read-write
 *  transactions, snapshot read-only transactions never abort. They can fail if
 *  the chosen read timestamp is garbage collected; however, the default garbage
 *  collection policy is generous enough that most applications do not need to
 *  worry about this in practice. Snapshot read-only transactions do not need to
 *  call Commit or Rollback (and in fact are not permitted to do so). To execute
 *  a snapshot transaction, the client specifies a timestamp bound, which tells
 *  Cloud Spanner how to choose a read timestamp. The types of timestamp bound
 *  are: - Strong (the default). - Bounded staleness. - Exact staleness. If the
 *  Cloud Spanner database to be read is geographically distributed, stale
 *  read-only transactions can execute more quickly than strong or read-write
 *  transactions, because they are able to execute far from the leader replica.
 *  Each type of timestamp bound is discussed in detail below. Strong: Strong
 *  reads are guaranteed to see the effects of all transactions that have
 *  committed before the start of the read. Furthermore, all rows yielded by a
 *  single read are consistent with each other -- if any part of the read
 *  observes a transaction, all parts of the read see the transaction. Strong
 *  reads are not repeatable: two consecutive strong read-only transactions
 *  might return inconsistent results if there are concurrent writes. If
 *  consistency across reads is required, the reads should be executed within a
 *  transaction or at an exact read timestamp. Queries on change streams (see
 *  below for more details) must also specify the strong read timestamp bound.
 *  See TransactionOptions.ReadOnly.strong. Exact staleness: These timestamp
 *  bounds execute reads at a user-specified timestamp. Reads at a timestamp are
 *  guaranteed to see a consistent prefix of the global transaction history:
 *  they observe modifications done by all transactions with a commit timestamp
 *  less than or equal to the read timestamp, and observe none of the
 *  modifications done by transactions with a larger commit timestamp. They will
 *  block until all conflicting transactions that may be assigned commit
 *  timestamps <= the read timestamp have finished. The timestamp can either be
 *  expressed as an absolute Cloud Spanner commit timestamp or a staleness
 *  relative to the current time. These modes do not require a "negotiation
 *  phase" to pick a timestamp. As a result, they execute slightly faster than
 *  the equivalent boundedly stale concurrency modes. On the other hand,
 *  boundedly stale reads usually return fresher results. See
 *  TransactionOptions.ReadOnly.read_timestamp and
 *  TransactionOptions.ReadOnly.exact_staleness. Bounded staleness: Bounded
 *  staleness modes allow Cloud Spanner to pick the read timestamp, subject to a
 *  user-provided staleness bound. Cloud Spanner chooses the newest timestamp
 *  within the staleness bound that allows execution of the reads at the closest
 *  available replica without blocking. All rows yielded are consistent with
 *  each other -- if any part of the read observes a transaction, all parts of
 *  the read see the transaction. Boundedly stale reads are not repeatable: two
 *  stale reads, even if they use the same staleness bound, can execute at
 *  different timestamps and thus return inconsistent results. Boundedly stale
 *  reads execute in two phases: the first phase negotiates a timestamp among
 *  all replicas needed to serve the read. In the second phase, reads are
 *  executed at the negotiated timestamp. As a result of the two phase
 *  execution, bounded staleness reads are usually a little slower than
 *  comparable exact staleness reads. However, they are typically able to return
 *  fresher results, and are more likely to execute at the closest replica.
 *  Because the timestamp negotiation requires up-front knowledge of which rows
 *  will be read, it can only be used with single-use read-only transactions.
 *  See TransactionOptions.ReadOnly.max_staleness and
 *  TransactionOptions.ReadOnly.min_read_timestamp. Old read timestamps and
 *  garbage collection: Cloud Spanner continuously garbage collects deleted and
 *  overwritten data in the background to reclaim storage space. This process is
 *  known as "version GC". By default, version GC reclaims versions after they
 *  are one hour old. Because of this, Cloud Spanner cannot perform reads at
 *  read timestamps more than one hour in the past. This restriction also
 *  applies to in-progress reads and/or SQL queries whose timestamp become too
 *  old while executing. Reads and SQL queries with too-old read timestamps fail
 *  with the error `FAILED_PRECONDITION`. You can configure and extend the
 *  `VERSION_RETENTION_PERIOD` of a database up to a period as long as one week,
 *  which allows Cloud Spanner to perform reads up to one week in the past.
 *  Querying change Streams: A Change Stream is a schema object that can be
 *  configured to watch data changes on the entire database, a set of tables, or
 *  a set of columns in a database. When a change stream is created, Spanner
 *  automatically defines a corresponding SQL Table-Valued Function (TVF) that
 *  can be used to query the change records in the associated change stream
 *  using the ExecuteStreamingSql API. The name of the TVF for a change stream
 *  is generated from the name of the change stream: READ_. All queries on
 *  change stream TVFs must be executed using the ExecuteStreamingSql API with a
 *  single-use read-only transaction with a strong read-only timestamp_bound.
 *  The change stream TVF allows users to specify the start_timestamp and
 *  end_timestamp for the time range of interest. All change records within the
 *  retention period is accessible using the strong read-only timestamp_bound.
 *  All other TransactionOptions are invalid for change stream queries. In
 *  addition, if TransactionOptions.read_only.return_read_timestamp is set to
 *  true, a special value of 2^63 - 2 will be returned in the Transaction
 *  message that describes the transaction, instead of a valid read timestamp.
 *  This special value should be discarded and not used for any subsequent
 *  queries. Please see https://cloud.google.com/spanner/docs/change-streams for
 *  more details on how to query the change stream TVFs. Partitioned DML
 *  transactions: Partitioned DML transactions are used to execute DML
 *  statements with a different execution strategy that provides different, and
 *  often better, scalability properties for large, table-wide operations than
 *  DML in a ReadWrite transaction. Smaller scoped statements, such as an OLTP
 *  workload, should prefer using ReadWrite transactions. Partitioned DML
 *  partitions the keyspace and runs the DML statement on each partition in
 *  separate, internal transactions. These transactions commit automatically
 *  when complete, and run independently from one another. To reduce lock
 *  contention, this execution strategy only acquires read locks on rows that
 *  match the WHERE clause of the statement. Additionally, the smaller
 *  per-partition transactions hold locks for less time. That said, Partitioned
 *  DML is not a drop-in replacement for standard DML used in ReadWrite
 *  transactions. - The DML statement must be fully-partitionable. Specifically,
 *  the statement must be expressible as the union of many statements which each
 *  access only a single row of the table. - The statement is not applied
 *  atomically to all rows of the table. Rather, the statement is applied
 *  atomically to partitions of the table, in independent transactions.
 *  Secondary index rows are updated atomically with the base table rows. -
 *  Partitioned DML does not guarantee exactly-once execution semantics against
 *  a partition. The statement will be applied at least once to each partition.
 *  It is strongly recommended that the DML statement should be idempotent to
 *  avoid unexpected results. For instance, it is potentially dangerous to run a
 *  statement such as `UPDATE table SET column = column + 1` as it could be run
 *  multiple times against some rows. - The partitions are committed
 *  automatically - there is no support for Commit or Rollback. If the call
 *  returns an error, or if the client issuing the ExecuteSql call dies, it is
 *  possible that some rows had the statement executed on them successfully. It
 *  is also possible that statement was never executed against other rows. -
 *  Partitioned DML transactions may only contain the execution of a single DML
 *  statement via ExecuteSql or ExecuteStreamingSql. - If any error is
 *  encountered during the execution of the partitioned DML operation (for
 *  instance, a UNIQUE INDEX violation, division by zero, or a value that cannot
 *  be stored due to schema constraints), then the operation is stopped at that
 *  point and an error is returned. It is possible that at this point, some
 *  partitions have been committed (or even committed multiple times), and other
 *  partitions have not been run at all. Given the above, Partitioned DML is
 *  good fit for large, database-wide, operations that are idempotent, such as
 *  deleting old rows from a very large table.
 */
@interface GTLRSpanner_TransactionOptions : GTLRObject

/**
 *  Partitioned DML transaction. Authorization to begin a Partitioned DML
 *  transaction requires `spanner.databases.beginPartitionedDmlTransaction`
 *  permission on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionedDml *partitionedDml;

/**
 *  Transaction will not write. Authorization to begin a read-only transaction
 *  requires `spanner.databases.beginReadOnlyTransaction` permission on the
 *  `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadOnly *readOnly;

/**
 *  Transaction may write. Authorization to begin a read-write transaction
 *  requires `spanner.databases.beginOrRollbackReadWriteTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadWrite *readWrite;

@end


/**
 *  This message is used to select the transaction in which a Read or ExecuteSql
 *  call runs. See TransactionOptions for more information about transactions.
 */
@interface GTLRSpanner_TransactionSelector : GTLRObject

/**
 *  Begin a new transaction and execute this read or SQL query in it. The
 *  transaction ID of the new transaction is returned in
 *  ResultSetMetadata.transaction, which is a Transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *begin;

/**
 *  Execute the read or SQL query in a previously-started transaction.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Execute the read or SQL query in a temporary transaction. This is the most
 *  efficient way to execute a transaction that consists of a single SQL query.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUse;

@end


/**
 *  `Type` indicates the type of a Cloud Spanner value, as might be stored in a
 *  table cell or returned from an SQL query.
 */
@interface GTLRSpanner_Type : GTLRObject

/**
 *  If code == ARRAY, then `array_element_type` is the type of the array
 *  elements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *arrayElementType;

/**
 *  Required. The TypeCode for this type.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Type_Code_Array Encoded as `list`, where the list
 *        elements are represented according to array_element_type. (Value:
 *        "ARRAY")
 *    @arg @c kGTLRSpanner_Type_Code_Bool Encoded as JSON `true` or `false`.
 *        (Value: "BOOL")
 *    @arg @c kGTLRSpanner_Type_Code_Bytes Encoded as a base64-encoded `string`,
 *        as described in RFC 4648, section 4. (Value: "BYTES")
 *    @arg @c kGTLRSpanner_Type_Code_Date Encoded as `string` in RFC 3339 date
 *        format. (Value: "DATE")
 *    @arg @c kGTLRSpanner_Type_Code_Float64 Encoded as `number`, or the strings
 *        `"NaN"`, `"Infinity"`, or `"-Infinity"`. (Value: "FLOAT64")
 *    @arg @c kGTLRSpanner_Type_Code_Int64 Encoded as `string`, in decimal
 *        format. (Value: "INT64")
 *    @arg @c kGTLRSpanner_Type_Code_Json Encoded as a JSON-formatted `string`
 *        as described in RFC 7159. The following rules are applied when parsing
 *        JSON input: - Whitespace characters are not preserved. - If a JSON
 *        object has duplicate keys, only the first key is preserved. - Members
 *        of a JSON object are not guaranteed to have their order preserved. -
 *        JSON array elements will have their order preserved. (Value: "JSON")
 *    @arg @c kGTLRSpanner_Type_Code_Numeric Encoded as `string`, in decimal
 *        format or scientific notation format. Decimal format:
 *        `[+-]Digits[.[Digits]]` or `+-.Digits` Scientific notation:
 *        `[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
 *        `+-.Digits[ExponentIndicator[+-]Digits]` (ExponentIndicator is `"e"`
 *        or `"E"`) (Value: "NUMERIC")
 *    @arg @c kGTLRSpanner_Type_Code_String Encoded as `string`. (Value:
 *        "STRING")
 *    @arg @c kGTLRSpanner_Type_Code_Struct Encoded as `list`, where list
 *        element `i` is represented according to
 *        [struct_type.fields[i]][google.spanner.v1.StructType.fields]. (Value:
 *        "STRUCT")
 *    @arg @c kGTLRSpanner_Type_Code_Timestamp Encoded as `string` in RFC 3339
 *        timestamp format. The time zone must be present, and must be `"Z"`. If
 *        the schema has the column option `allow_commit_timestamp=true`, the
 *        placeholder string `"spanner.commit_timestamp()"` can be used to
 *        instruct the system to insert the commit timestamp associated with the
 *        transaction commit. (Value: "TIMESTAMP")
 *    @arg @c kGTLRSpanner_Type_Code_TypeCodeUnspecified Not specified. (Value:
 *        "TYPE_CODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  If code == STRUCT, then `struct_type` provides type information for the
 *  struct's fields.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *structType;

/**
 *  The TypeAnnotationCode that disambiguates SQL type that Spanner will use to
 *  represent values of this type during query processing. This is necessary for
 *  some type codes because a single TypeCode can be mapped to different SQL
 *  types depending on the SQL dialect. type_annotation typically is not needed
 *  to process the content of a value (it doesn't affect serialization) and
 *  clients can ignore it on the read path.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_PgJsonb PostgreSQL compatible
 *        JSONB type. This annotation needs to be applied to Type instances
 *        having JSON type code to specify that values of this type should be
 *        treated as PostgreSQL JSONB values. Currently this annotation is
 *        always needed for JSON when a client interacts with PostgreSQL-enabled
 *        Spanner databases. (Value: "PG_JSONB")
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_PgNumeric PostgreSQL compatible
 *        NUMERIC type. This annotation needs to be applied to Type instances
 *        having NUMERIC type code to specify that values of this type should be
 *        treated as PostgreSQL NUMERIC values. Currently this annotation is
 *        always needed for NUMERIC when a client interacts with
 *        PostgreSQL-enabled Spanner databases. (Value: "PG_NUMERIC")
 *    @arg @c kGTLRSpanner_Type_TypeAnnotation_TypeAnnotationCodeUnspecified Not
 *        specified. (Value: "TYPE_ANNOTATION_CODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *typeAnnotation;

@end


/**
 *  Metadata type for the operation returned by UpdateDatabaseDdl.
 */
@interface GTLRSpanner_UpdateDatabaseDdlMetadata : GTLRObject

/**
 *  Reports the commit timestamps of all statements that have succeeded so far,
 *  where `commit_timestamps[i]` is the commit timestamp for the statement
 *  `statements[i]`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDateTime *> *commitTimestamps;

/** The database being modified. */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  The progress of the UpdateDatabaseDdl operations. Currently, only index
 *  creation statements will have a continuously updating progress. For
 *  non-index creation statements, `progress[i]` will have start time and end
 *  time populated with commit timestamp of operation, as well as a progress of
 *  100% once the operation has completed. `progress[i]` is the operation
 *  progress for `statements[i]`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_OperationProgress *> *progress;

/**
 *  For an update this list contains all the statements. For an individual
 *  statement, this list contains only that statement.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

/**
 *  Output only. When true, indicates that the operation is throttled e.g due to
 *  resource constraints. When resources become available the operation will
 *  resume and this field will be false again.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *throttled;

@end


/**
 *  Enqueues the given DDL statements to be applied, in order but not
 *  necessarily all at once, to the database schema at some point (or points) in
 *  the future. The server checks that the statements are executable
 *  (syntactically valid, name tables that exist, etc.) before enqueueing them,
 *  but they may still fail upon later execution (e.g., if a statement from
 *  another batch of statements is applied first and it conflicts in some way,
 *  or if there is some data-related problem like a `NULL` value in a column to
 *  which `NOT NULL` would be added). If a statement fails, all subsequent
 *  statements in the batch are automatically cancelled. Each batch of
 *  statements is assigned a name which can be used with the Operations API to
 *  monitor progress. See the operation_id field for more details.
 */
@interface GTLRSpanner_UpdateDatabaseDdlRequest : GTLRObject

/**
 *  If empty, the new update request is assigned an automatically-generated
 *  operation ID. Otherwise, `operation_id` is used to construct the name of the
 *  resulting Operation. Specifying an explicit operation ID simplifies
 *  determining whether the statements were executed in the event that the
 *  UpdateDatabaseDdl call is replayed, or the return value is otherwise lost:
 *  the database and `operation_id` fields can be combined to form the name of
 *  the resulting longrunning.Operation: `/operations/`. `operation_id` should
 *  be unique within the database, and must be a valid identifier: `a-z*`. Note
 *  that automatically-generated operation IDs always begin with an underscore.
 *  If the named operation already exists, UpdateDatabaseDdl returns
 *  `ALREADY_EXISTS`.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Required. DDL statements to be applied to the database. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Metadata type for the operation returned by UpdateInstanceConfig.
 */
@interface GTLRSpanner_UpdateInstanceConfigMetadata : GTLRObject

/** The time at which this operation was cancelled. */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The desired instance config after updating. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/** The progress of the UpdateInstanceConfig operation. */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceOperationProgress *progress;

@end


/**
 *  The request for UpdateInstanceConfigRequest.
 */
@interface GTLRSpanner_UpdateInstanceConfigRequest : GTLRObject

/**
 *  Required. The user instance config to update, which must always include the
 *  instance config name. Otherwise, only fields mentioned in update_mask need
 *  be included. To prevent conflicts of concurrent updates, etag can be used.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_InstanceConfig *instanceConfig;

/**
 *  Required. A mask specifying which fields in InstanceConfig should be
 *  updated. The field mask must always be specified; this prevents any future
 *  fields in InstanceConfig from being erased accidentally by clients that do
 *  not know about them. Only display_name and labels can be updated.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  An option to validate, but not actually execute, a request, and provide the
 *  same response.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateOnly;

@end


/**
 *  Metadata type for the operation returned by UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is in
 *  the process of undoing itself (which is guaranteed to succeed) and cannot be
 *  cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The desired end state of the update. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/** The time at which UpdateInstance request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceRequest : GTLRObject

/**
 *  Required. A mask specifying which fields in Instance should be updated. The
 *  field mask must always be specified; this prevents any future fields in
 *  Instance from being erased accidentally by clients that do not know about
 *  them.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *fieldMask;

/**
 *  Required. The instance to update, which must always include the instance
 *  name. Otherwise, only fields mentioned in field_mask need be included.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

@end


/**
 *  GTLRSpanner_VisualizationData
 */
@interface GTLRSpanner_VisualizationData : GTLRObject

/** The token signifying the end of a data_source. */
@property(nonatomic, copy, nullable) NSString *dataSourceEndToken;

/**
 *  The token delimiting a datasource name from the rest of a key in a
 *  data_source.
 */
@property(nonatomic, copy, nullable) NSString *dataSourceSeparatorToken;

/** The list of messages (info, alerts, ...) */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_DiagnosticMessage *> *diagnosticMessages;

/**
 *  We discretize the entire keyspace into buckets. Assuming each bucket has an
 *  inclusive keyrange and covers keys from k(i) ... k(n). In this case k(n)
 *  would be an end key for a given range. end_key_string is the collection of
 *  all such end keys
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *endKeyStrings;

/**
 *  Whether this scan contains PII.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasPii;

/**
 *  Keys of key ranges that contribute significantly to a given metric Can be
 *  thought of as heavy hitters.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *indexedKeys;

/** The token delimiting the key prefixes. */
@property(nonatomic, copy, nullable) NSString *keySeparator;

/**
 *  The unit for the key: e.g. 'key' or 'chunk'.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_VisualizationData_KeyUnit_Chunk Each entry
 *        corresponds to a chunk of keys (Value: "CHUNK")
 *    @arg @c kGTLRSpanner_VisualizationData_KeyUnit_Key Each entry corresponds
 *        to one key (Value: "KEY")
 *    @arg @c kGTLRSpanner_VisualizationData_KeyUnit_KeyUnitUnspecified Required
 *        default value (Value: "KEY_UNIT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *keyUnit;

/** The list of data objects for each metric. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Metric *> *metrics;

/**
 *  The list of extracted key prefix nodes used in the key prefix hierarchy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_PrefixNode *> *prefixNodes;

@end


/**
 *  Arguments to insert, update, insert_or_update, and replace operations.
 */
@interface GTLRSpanner_Write : GTLRObject

/**
 *  The names of the columns in table to be written. The list of columns must
 *  contain enough columns to allow Cloud Spanner to derive values for all
 *  primary key columns in the row(s) to be modified.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/** Required. The table whose rows will be written. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The values to be written. `values` can contain more than one list of values.
 *  If it does, then multiple rows are written, one for each entry in `values`.
 *  Each list in `values` must have exactly as many entries as there are entries
 *  in columns above. Sending multiple lists is equivalent to sending multiple
 *  `Mutation`s, each containing one `values` entry and repeating table and
 *  columns. Individual values in each list are encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *values;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
