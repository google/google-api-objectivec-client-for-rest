// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Anthos On-Prem API (gkeonprem/v1)
// Documentation:
//   https://cloud.google.com/anthos/clusters/docs/on-prem/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRGKEOnPrem_Authorization;
@class GTLRGKEOnPrem_BareMetalAdminApiServerArgument;
@class GTLRGKEOnPrem_BareMetalAdminCluster;
@class GTLRGKEOnPrem_BareMetalAdminCluster_Annotations;
@class GTLRGKEOnPrem_BareMetalAdminClusterOperationsConfig;
@class GTLRGKEOnPrem_BareMetalAdminControlPlaneConfig;
@class GTLRGKEOnPrem_BareMetalAdminControlPlaneNodePoolConfig;
@class GTLRGKEOnPrem_BareMetalAdminDrainedMachine;
@class GTLRGKEOnPrem_BareMetalAdminDrainingMachine;
@class GTLRGKEOnPrem_BareMetalAdminIslandModeCidrConfig;
@class GTLRGKEOnPrem_BareMetalAdminLoadBalancerConfig;
@class GTLRGKEOnPrem_BareMetalAdminMachineDrainStatus;
@class GTLRGKEOnPrem_BareMetalAdminMaintenanceConfig;
@class GTLRGKEOnPrem_BareMetalAdminMaintenanceStatus;
@class GTLRGKEOnPrem_BareMetalAdminManualLbConfig;
@class GTLRGKEOnPrem_BareMetalAdminNetworkConfig;
@class GTLRGKEOnPrem_BareMetalAdminNodeAccessConfig;
@class GTLRGKEOnPrem_BareMetalAdminOsEnvironmentConfig;
@class GTLRGKEOnPrem_BareMetalAdminPortConfig;
@class GTLRGKEOnPrem_BareMetalAdminProxyConfig;
@class GTLRGKEOnPrem_BareMetalAdminSecurityConfig;
@class GTLRGKEOnPrem_BareMetalAdminStorageConfig;
@class GTLRGKEOnPrem_BareMetalAdminVipConfig;
@class GTLRGKEOnPrem_BareMetalAdminWorkloadNodeConfig;
@class GTLRGKEOnPrem_BareMetalApiServerArgument;
@class GTLRGKEOnPrem_BareMetalBgpLbConfig;
@class GTLRGKEOnPrem_BareMetalBgpPeerConfig;
@class GTLRGKEOnPrem_BareMetalCluster;
@class GTLRGKEOnPrem_BareMetalCluster_Annotations;
@class GTLRGKEOnPrem_BareMetalClusterOperationsConfig;
@class GTLRGKEOnPrem_BareMetalClusterUpgradePolicy;
@class GTLRGKEOnPrem_BareMetalControlPlaneConfig;
@class GTLRGKEOnPrem_BareMetalControlPlaneNodePoolConfig;
@class GTLRGKEOnPrem_BareMetalDrainedMachine;
@class GTLRGKEOnPrem_BareMetalDrainingMachine;
@class GTLRGKEOnPrem_BareMetalIslandModeCidrConfig;
@class GTLRGKEOnPrem_BareMetalKubeletConfig;
@class GTLRGKEOnPrem_BareMetalLoadBalancerAddressPool;
@class GTLRGKEOnPrem_BareMetalLoadBalancerConfig;
@class GTLRGKEOnPrem_BareMetalLoadBalancerNodePoolConfig;
@class GTLRGKEOnPrem_BareMetalLvpConfig;
@class GTLRGKEOnPrem_BareMetalLvpShareConfig;
@class GTLRGKEOnPrem_BareMetalMachineDrainStatus;
@class GTLRGKEOnPrem_BareMetalMaintenanceConfig;
@class GTLRGKEOnPrem_BareMetalMaintenanceStatus;
@class GTLRGKEOnPrem_BareMetalManualLbConfig;
@class GTLRGKEOnPrem_BareMetalMetalLbConfig;
@class GTLRGKEOnPrem_BareMetalMultipleNetworkInterfacesConfig;
@class GTLRGKEOnPrem_BareMetalNetworkConfig;
@class GTLRGKEOnPrem_BareMetalNodeAccessConfig;
@class GTLRGKEOnPrem_BareMetalNodeConfig;
@class GTLRGKEOnPrem_BareMetalNodeConfig_Labels;
@class GTLRGKEOnPrem_BareMetalNodePool;
@class GTLRGKEOnPrem_BareMetalNodePool_Annotations;
@class GTLRGKEOnPrem_BareMetalNodePoolConfig;
@class GTLRGKEOnPrem_BareMetalNodePoolConfig_Labels;
@class GTLRGKEOnPrem_BareMetalNodePoolUpgradePolicy;
@class GTLRGKEOnPrem_BareMetalOsEnvironmentConfig;
@class GTLRGKEOnPrem_BareMetalParallelUpgradeConfig;
@class GTLRGKEOnPrem_BareMetalPortConfig;
@class GTLRGKEOnPrem_BareMetalProxyConfig;
@class GTLRGKEOnPrem_BareMetalSecurityConfig;
@class GTLRGKEOnPrem_BareMetalSrIovConfig;
@class GTLRGKEOnPrem_BareMetalStorageConfig;
@class GTLRGKEOnPrem_BareMetalVersionInfo;
@class GTLRGKEOnPrem_BareMetalVipConfig;
@class GTLRGKEOnPrem_BareMetalWorkloadNodeConfig;
@class GTLRGKEOnPrem_BinaryAuthorization;
@class GTLRGKEOnPrem_Binding;
@class GTLRGKEOnPrem_ClusterUser;
@class GTLRGKEOnPrem_Expr;
@class GTLRGKEOnPrem_Fleet;
@class GTLRGKEOnPrem_Location;
@class GTLRGKEOnPrem_Location_Labels;
@class GTLRGKEOnPrem_Location_Metadata;
@class GTLRGKEOnPrem_Metric;
@class GTLRGKEOnPrem_NodeTaint;
@class GTLRGKEOnPrem_Operation;
@class GTLRGKEOnPrem_Operation_Metadata;
@class GTLRGKEOnPrem_Operation_Response;
@class GTLRGKEOnPrem_OperationProgress;
@class GTLRGKEOnPrem_OperationStage;
@class GTLRGKEOnPrem_Policy;
@class GTLRGKEOnPrem_ResourceCondition;
@class GTLRGKEOnPrem_ResourceStatus;
@class GTLRGKEOnPrem_Status;
@class GTLRGKEOnPrem_Status_Details_Item;
@class GTLRGKEOnPrem_UpgradeDependency;
@class GTLRGKEOnPrem_ValidationCheck;
@class GTLRGKEOnPrem_ValidationCheckResult;
@class GTLRGKEOnPrem_ValidationCheckStatus;
@class GTLRGKEOnPrem_VmwareAAGConfig;
@class GTLRGKEOnPrem_VmwareAddressPool;
@class GTLRGKEOnPrem_VmwareAdminAddonNodeConfig;
@class GTLRGKEOnPrem_VmwareAdminAuthorizationConfig;
@class GTLRGKEOnPrem_VmwareAdminCluster;
@class GTLRGKEOnPrem_VmwareAdminCluster_Annotations;
@class GTLRGKEOnPrem_VmwareAdminControlPlaneNodeConfig;
@class GTLRGKEOnPrem_VmwareAdminF5BigIpConfig;
@class GTLRGKEOnPrem_VmwareAdminHAControlPlaneConfig;
@class GTLRGKEOnPrem_VmwareAdminLoadBalancerConfig;
@class GTLRGKEOnPrem_VmwareAdminManualLbConfig;
@class GTLRGKEOnPrem_VmwareAdminMetalLbConfig;
@class GTLRGKEOnPrem_VmwareAdminNetworkConfig;
@class GTLRGKEOnPrem_VmwareAdminPreparedSecretsConfig;
@class GTLRGKEOnPrem_VmwareAdminSeesawConfig;
@class GTLRGKEOnPrem_VmwareAdminVCenterConfig;
@class GTLRGKEOnPrem_VmwareAdminVipConfig;
@class GTLRGKEOnPrem_VmwareAutoRepairConfig;
@class GTLRGKEOnPrem_VmwareAutoResizeConfig;
@class GTLRGKEOnPrem_VmwareBundleConfig;
@class GTLRGKEOnPrem_VmwareCluster;
@class GTLRGKEOnPrem_VmwareCluster_Annotations;
@class GTLRGKEOnPrem_VmwareClusterUpgradePolicy;
@class GTLRGKEOnPrem_VmwareControlPlaneNodeConfig;
@class GTLRGKEOnPrem_VmwareControlPlaneV2Config;
@class GTLRGKEOnPrem_VmwareControlPlaneVsphereConfig;
@class GTLRGKEOnPrem_VmwareDataplaneV2Config;
@class GTLRGKEOnPrem_VmwareDhcpIpConfig;
@class GTLRGKEOnPrem_VmwareF5BigIpConfig;
@class GTLRGKEOnPrem_VmwareHostConfig;
@class GTLRGKEOnPrem_VmwareHostIp;
@class GTLRGKEOnPrem_VmwareIpBlock;
@class GTLRGKEOnPrem_VmwareLoadBalancerConfig;
@class GTLRGKEOnPrem_VmwareManualLbConfig;
@class GTLRGKEOnPrem_VmwareMetalLbConfig;
@class GTLRGKEOnPrem_VmwareNetworkConfig;
@class GTLRGKEOnPrem_VmwareNodeConfig;
@class GTLRGKEOnPrem_VmwareNodeConfig_Labels;
@class GTLRGKEOnPrem_VmwareNodePool;
@class GTLRGKEOnPrem_VmwareNodePool_Annotations;
@class GTLRGKEOnPrem_VmwareNodePoolAutoscalingConfig;
@class GTLRGKEOnPrem_VmwarePlatformConfig;
@class GTLRGKEOnPrem_VmwareSeesawConfig;
@class GTLRGKEOnPrem_VmwareStaticIpConfig;
@class GTLRGKEOnPrem_VmwareStorageConfig;
@class GTLRGKEOnPrem_VmwareVCenterConfig;
@class GTLRGKEOnPrem_VmwareVersionInfo;
@class GTLRGKEOnPrem_VmwareVipConfig;
@class GTLRGKEOnPrem_VmwareVsphereConfig;
@class GTLRGKEOnPrem_VmwareVsphereTag;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BareMetalAdminCluster.state

/**
 *  The DEGRADED state indicates the cluster requires user action to restore
 *  full functionality.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_Degraded;
/**
 *  The ERROR state indicates the cluster is in a broken unrecoverable state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_Error;
/**
 *  The PROVISIONING state indicates the cluster is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_Provisioning;
/**
 *  The RECONCILING state indicates that the cluster is being updated. It
 *  remains available, but potentially with degraded performance.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_Reconciling;
/**
 *  The RUNNING state indicates the cluster has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_StateUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalAdminCluster_State_Stopping;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BareMetalCluster.state

/**
 *  The DEGRADED state indicates the cluster requires user action to restore
 *  full functionality.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_Degraded;
/**
 *  The ERROR state indicates the cluster is in a broken unrecoverable state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_Error;
/**
 *  The PROVISIONING state indicates the cluster is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_Provisioning;
/**
 *  The RECONCILING state indicates that the cluster is being updated. It
 *  remains available, but potentially with degraded performance.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_Reconciling;
/**
 *  The RUNNING state indicates the cluster has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_StateUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalCluster_State_Stopping;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BareMetalClusterUpgradePolicy.policy

/**
 *  Upgrade all worker node pools in parallel.
 *
 *  Value: "CONCURRENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalClusterUpgradePolicy_Policy_Concurrent;
/**
 *  No upgrade policy selected.
 *
 *  Value: "NODE_POOL_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalClusterUpgradePolicy_Policy_NodePoolPolicyUnspecified;
/**
 *  Upgrade worker node pools sequentially.
 *
 *  Value: "SERIAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalClusterUpgradePolicy_Policy_Serial;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BareMetalNodePool.state

/**
 *  The DEGRADED state indicates the bare metal node pool requires user action
 *  to restore full functionality.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_Degraded;
/**
 *  The ERROR state indicates the bare metal node pool is in a broken
 *  unrecoverable state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_Error;
/**
 *  The PROVISIONING state indicates the bare metal node pool is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_Provisioning;
/**
 *  The RECONCILING state indicates that the bare metal node pool is being
 *  updated. It remains available, but potentially with degraded performance.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_Reconciling;
/**
 *  The RUNNING state indicates the bare metal node pool has been created and is
 *  fully usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_StateUnspecified;
/**
 *  The STOPPING state indicates the bare metal node pool is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePool_State_Stopping;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BareMetalNodePoolConfig.operatingSystem

/**
 *  Linux operating system.
 *
 *  Value: "LINUX"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePoolConfig_OperatingSystem_Linux;
/**
 *  No operating system runtime selected.
 *
 *  Value: "OPERATING_SYSTEM_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalNodePoolConfig_OperatingSystem_OperatingSystemUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BareMetalWorkloadNodeConfig.containerRuntime

/**
 *  Containerd runtime.
 *
 *  Value: "CONTAINERD"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalWorkloadNodeConfig_ContainerRuntime_Containerd;
/**
 *  No container runtime selected.
 *
 *  Value: "CONTAINER_RUNTIME_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BareMetalWorkloadNodeConfig_ContainerRuntime_ContainerRuntimeUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_BinaryAuthorization.evaluationMode

/**
 *  Disable BinaryAuthorization
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BinaryAuthorization_EvaluationMode_Disabled;
/**
 *  Default value
 *
 *  Value: "EVALUATION_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BinaryAuthorization_EvaluationMode_EvaluationModeUnspecified;
/**
 *  Enforce Kubernetes admission requests with BinaryAuthorization using the
 *  project's singleton policy.
 *
 *  Value: "PROJECT_SINGLETON_POLICY_ENFORCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_BinaryAuthorization_EvaluationMode_ProjectSingletonPolicyEnforce;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_Metric.metric

/**
 *  Not set.
 *
 *  Value: "METRIC_ID_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_MetricIdUnspecified;
/**
 *  The number of nodes draining.
 *
 *  Value: "NODES_DRAINING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesDraining;
/**
 *  The number of nodes to fail actuation.
 *
 *  Value: "NODES_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesFailed;
/**
 *  The number of nodes healthy.
 *
 *  Value: "NODES_HEALTHY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesHealthy;
/**
 *  The number of nodes in maintenance mode.
 *
 *  Value: "NODES_IN_MAINTENANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesInMaintenance;
/**
 *  The number of nodes to be upgraded.
 *
 *  Value: "NODES_PENDING_UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesPendingUpgrade;
/**
 *  The number of nodes reconciling.
 *
 *  Value: "NODES_RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesReconciling;
/**
 *  The total number of nodes being actuated.
 *
 *  Value: "NODES_TOTAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesTotal;
/**
 *  The number of nodes upgraded.
 *
 *  Value: "NODES_UPGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesUpgraded;
/**
 *  The number of nodes actively upgrading.
 *
 *  Value: "NODES_UPGRADING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_NodesUpgrading;
/**
 *  The number of completed preflight checks.
 *
 *  Value: "PREFLIGHTS_COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_PreflightsCompleted;
/**
 *  The number of preflight checks failed.
 *
 *  Value: "PREFLIGHTS_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_PreflightsFailed;
/**
 *  The number of preflight checks running.
 *
 *  Value: "PREFLIGHTS_RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_PreflightsRunning;
/**
 *  The total number of preflight checks.
 *
 *  Value: "PREFLIGHTS_TOTAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_Metric_Metric_PreflightsTotal;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_NodeTaint.effect

/**
 *  Not set.
 *
 *  Value: "EFFECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_NodeTaint_Effect_EffectUnspecified;
/**
 *  Evict any already-running pods that do not tolerate the taint. Currently
 *  enforced by NodeController.
 *
 *  Value: "NO_EXECUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_NodeTaint_Effect_NoExecute;
/**
 *  Do not allow new pods to schedule onto the node unless they tolerate the
 *  taint, but allow all pods submitted to Kubelet without going through the
 *  scheduler to start, and allow all already-running pods to continue running.
 *  Enforced by the scheduler.
 *
 *  Value: "NO_SCHEDULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_NodeTaint_Effect_NoSchedule;
/**
 *  Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods
 *  onto the node, rather than prohibiting new pods from scheduling onto the
 *  node entirely. Enforced by the scheduler.
 *
 *  Value: "PREFER_NO_SCHEDULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_NodeTaint_Effect_PreferNoSchedule;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_OperationMetadata.type

/**
 *  The resource is being created.
 *
 *  Value: "CREATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationMetadata_Type_Create;
/**
 *  The resource is being deleted.
 *
 *  Value: "DELETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationMetadata_Type_Delete;
/**
 *  Not set.
 *
 *  Value: "OPERATION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationMetadata_Type_OperationTypeUnspecified;
/**
 *  The platform is being upgraded.
 *
 *  Value: "PLATFORM_UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationMetadata_Type_PlatformUpgrade;
/**
 *  The resource is being updated.
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationMetadata_Type_Update;
/**
 *  The resource is being upgraded.
 *
 *  Value: "UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationMetadata_Type_Upgrade;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_OperationStage.stage

/**
 *  Resource is being configured.
 *
 *  Value: "CONFIGURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_Stage_Configure;
/**
 *  Resource is being deployed.
 *
 *  Value: "DEPLOY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_Stage_Deploy;
/**
 *  Waiting for the resource to become healthy.
 *
 *  Value: "HEALTH_CHECK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_Stage_HealthCheck;
/**
 *  Preflight checks are running.
 *
 *  Value: "PREFLIGHT_CHECK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_Stage_PreflightCheck;
/**
 *  Not set.
 *
 *  Value: "STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_Stage_StageUnspecified;
/**
 *  Resource is being updated.
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_Stage_Update;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_OperationStage.state

/**
 *  The stage has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_State_Failed;
/**
 *  The stage is pending.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_State_Pending;
/**
 *  The stage is running
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_State_StateUnspecified;
/**
 *  The stage has completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_OperationStage_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_ResourceCondition.state

/**
 *  Resource is not in the condition.
 *
 *  Value: "STATE_FALSE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ResourceCondition_State_StateFalse;
/**
 *  Resource is in the condition.
 *
 *  Value: "STATE_TRUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ResourceCondition_State_StateTrue;
/**
 *  Kubernetes controller can't decide if the resource is in the condition or
 *  not.
 *
 *  Value: "STATE_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ResourceCondition_State_StateUnknown;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ResourceCondition_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_ValidationCheck.option

/**
 *  Default value. Standard preflight validation check will be used.
 *
 *  Value: "OPTIONS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheck_Option_OptionsUnspecified;
/**
 *  Skip all preflight check validations.
 *
 *  Value: "SKIP_VALIDATION_ALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheck_Option_SkipValidationAll;
/**
 *  Prevent failed preflight checks from failing.
 *
 *  Value: "SKIP_VALIDATION_CHECK_BLOCKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheck_Option_SkipValidationCheckBlocking;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_ValidationCheck.scenario

/**
 *  The validation check occurred during a create flow.
 *
 *  Value: "CREATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheck_Scenario_Create;
/**
 *  Default value. This value is unused.
 *
 *  Value: "SCENARIO_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheck_Scenario_ScenarioUnspecified;
/**
 *  The validation check occurred during an update flow.
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheck_Scenario_Update;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_ValidationCheckResult.state

/**
 *  The check failed.
 *
 *  Value: "STATE_FAILURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheckResult_State_StateFailure;
/**
 *  The check itself failed to complete.
 *
 *  Value: "STATE_FATAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheckResult_State_StateFatal;
/**
 *  The check was skipped.
 *
 *  Value: "STATE_SKIPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheckResult_State_StateSkipped;
/**
 *  The default value. The check result is unknown.
 *
 *  Value: "STATE_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheckResult_State_StateUnknown;
/**
 *  The check encountered a warning.
 *
 *  Value: "STATE_WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_ValidationCheckResult_State_StateWarning;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_VmwareAdminCluster.state

/**
 *  The DEGRADED state indicates the cluster requires user action to restore
 *  full functionality.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_Degraded;
/**
 *  The ERROR state indicates the cluster is in a broken unrecoverable state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_Error;
/**
 *  The PROVISIONING state indicates the cluster is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_Provisioning;
/**
 *  The RECONCILING state indicates that the cluster is being updated. It
 *  remains available, but potentially with degraded performance.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_Reconciling;
/**
 *  The RUNNING state indicates the cluster has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_StateUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareAdminCluster_State_Stopping;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_VmwareCluster.state

/**
 *  The DEGRADED state indicates the cluster requires user action to restore
 *  full functionality.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_Degraded;
/**
 *  The ERROR state indicates the cluster is in a broken unrecoverable state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_Error;
/**
 *  The PROVISIONING state indicates the cluster is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_Provisioning;
/**
 *  The RECONCILING state indicates that the cluster is being updated. It
 *  remains available, but potentially with degraded performance.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_Reconciling;
/**
 *  The RUNNING state indicates the cluster has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_StateUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareCluster_State_Stopping;

// ----------------------------------------------------------------------------
// GTLRGKEOnPrem_VmwareNodePool.state

/**
 *  The DEGRADED state indicates the node pool requires user action to restore
 *  full functionality.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_Degraded;
/**
 *  The ERROR state indicates the node pool is in a broken unrecoverable state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_Error;
/**
 *  The PROVISIONING state indicates the node pool is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_Provisioning;
/**
 *  The RECONCILING state indicates that the node pool is being updated. It
 *  remains available, but potentially with degraded performance.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_Reconciling;
/**
 *  The RUNNING state indicates the node pool has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_Running;
/**
 *  Not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_StateUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEOnPrem_VmwareNodePool_State_Stopping;

/**
 *  Authorization defines the On-Prem cluster authorization configuration to
 *  bootstrap onto the admin cluster.
 */
@interface GTLRGKEOnPrem_Authorization : GTLRObject

/**
 *  For VMware and bare metal user clusters, users will be granted the
 *  cluster-admin role on the cluster, which provides full administrative access
 *  to the cluster. For bare metal admin clusters, users will be granted the
 *  cluster-view role, which limits users to read-only access.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_ClusterUser *> *adminUsers;

@end


/**
 *  BareMetalAdminApiServerArgument represents an arg name->value pair. Only a
 *  subset of customized flags are supported. Please refer to the API server
 *  documentation below to know the exact format:
 *  https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
 */
@interface GTLRGKEOnPrem_BareMetalAdminApiServerArgument : GTLRObject

/**
 *  Required. The argument name as it appears on the API Server command line
 *  please make sure to remove the leading dashes.
 */
@property(nonatomic, copy, nullable) NSString *argument;

/**
 *  Required. The value of the arg as it will be passed to the API Server
 *  command line.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Resource that represents a bare metal admin cluster. LINT.IfChange
 */
@interface GTLRGKEOnPrem_BareMetalAdminCluster : GTLRObject

/**
 *  Annotations on the bare metal admin cluster. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminCluster_Annotations *annotations;

/**
 *  The Anthos clusters on bare metal version for the bare metal admin cluster.
 */
@property(nonatomic, copy, nullable) NSString *bareMetalVersion;

/** Binary Authorization related configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BinaryAuthorization *binaryAuthorization;

/** Cluster operations configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminClusterOperationsConfig *clusterOperations;

/** Control plane configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminControlPlaneConfig *controlPlane;

/**
 *  Output only. The time at which this bare metal admin cluster was created.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The time at which this bare metal admin cluster was deleted. If
 *  the resource is not deleted, this must be empty
 */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/**
 *  A human readable description of this bare metal admin cluster.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The IP address name of bare metal admin cluster's API server.
 */
@property(nonatomic, copy, nullable) NSString *endpoint;

/**
 *  This checksum is computed by the server based on the value of other fields,
 *  and may be sent on update and delete requests to ensure the client has an
 *  up-to-date value before proceeding. Allows clients to perform consistent
 *  read-modify-writes through optimistic concurrency control.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Output only. Fleet configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Fleet *fleet;

/** Load balancer configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminLoadBalancerConfig *loadBalancer;

/**
 *  Output only. The object name of the bare metal cluster custom resource. This
 *  field is used to support conflicting names when enrolling existing clusters
 *  to the API. When used as a part of cluster enrollment, this field will
 *  differ from the ID in the resource name. For new clusters, this field will
 *  match the user provided cluster name and be visible in the last component of
 *  the resource name. It is not modifiable. All users should use this name to
 *  access their cluster using gkectl or kubectl and should expect to see the
 *  local name when viewing admin cluster controller logs.
 */
@property(nonatomic, copy, nullable) NSString *localName;

/** Maintenance configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminMaintenanceConfig *maintenanceConfig;

/** Output only. MaintenanceStatus representing state of maintenance. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminMaintenanceStatus *maintenanceStatus;

/** Immutable. The bare metal admin cluster resource name. */
@property(nonatomic, copy, nullable) NSString *name;

/** Network configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminNetworkConfig *networkConfig;

/** Node access related configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminNodeAccessConfig *nodeAccessConfig;

/** Workload node configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminWorkloadNodeConfig *nodeConfig;

/** OS environment related configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminOsEnvironmentConfig *osEnvironmentConfig;

/** Proxy configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminProxyConfig *proxy;

/**
 *  Output only. If set, there are currently changes in flight to the bare metal
 *  Admin Cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/** Security related configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminSecurityConfig *securityConfig;

/**
 *  Output only. The current state of the bare metal admin cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_Degraded The DEGRADED
 *        state indicates the cluster requires user action to restore full
 *        functionality. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_Error The ERROR state
 *        indicates the cluster is in a broken unrecoverable state. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_Provisioning The
 *        PROVISIONING state indicates the cluster is being created. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_Reconciling The
 *        RECONCILING state indicates that the cluster is being updated. It
 *        remains available, but potentially with degraded performance. (Value:
 *        "RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_Running The RUNNING
 *        state indicates the cluster has been created and is fully usable.
 *        (Value: "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_StateUnspecified Not
 *        set. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalAdminCluster_State_Stopping The STOPPING
 *        state indicates the cluster is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. ResourceStatus representing detailed cluster status. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** Storage configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminStorageConfig *storage;

/** Output only. The unique identifier of the bare metal admin cluster. */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The time at which this bare metal admin cluster was last
 *  updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Output only. ValidationCheck representing the result of the preflight check.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ValidationCheck *validationCheck;

@end


/**
 *  Annotations on the bare metal admin cluster. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_BareMetalAdminCluster_Annotations : GTLRObject
@end


/**
 *  BareMetalAdminClusterOperationsConfig specifies the admin cluster's
 *  observability infrastructure.
 */
@interface GTLRGKEOnPrem_BareMetalAdminClusterOperationsConfig : GTLRObject

/**
 *  Whether collection of application logs/metrics should be enabled (in
 *  addition to system logs/metrics).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableApplicationLogs;

@end


/**
 *  BareMetalAdminControlPlaneConfig specifies the control plane configuration.
 */
@interface GTLRGKEOnPrem_BareMetalAdminControlPlaneConfig : GTLRObject

/**
 *  Customizes the default API server args. Only a subset of customized flags
 *  are supported. Please refer to the API server documentation below to know
 *  the exact format:
 *  https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalAdminApiServerArgument *> *apiServerArgs;

/**
 *  Required. Configures the node pool running the control plane. If specified
 *  the corresponding NodePool will be created for the cluster's control plane.
 *  The NodePool will have the same name and namespace as the cluster.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminControlPlaneNodePoolConfig *controlPlaneNodePoolConfig;

@end


/**
 *  BareMetalAdminControlPlaneNodePoolConfig specifies the control plane node
 *  pool configuration. We have a control plane specific node pool config so
 *  that we can flexible about supporting control plane specific fields in the
 *  future.
 */
@interface GTLRGKEOnPrem_BareMetalAdminControlPlaneNodePoolConfig : GTLRObject

/**
 *  Required. The generic configuration for a node pool running the control
 *  plane.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePoolConfig *nodePoolConfig;

@end


/**
 *  BareMetalAdminDrainedMachine represents the machines that are drained.
 */
@interface GTLRGKEOnPrem_BareMetalAdminDrainedMachine : GTLRObject

/** Drained machine IP address. */
@property(nonatomic, copy, nullable) NSString *nodeIp;

@end


/**
 *  BareMetalAdminDrainingMachine represents the machines that are currently
 *  draining.
 */
@interface GTLRGKEOnPrem_BareMetalAdminDrainingMachine : GTLRObject

/** Draining machine IP address. */
@property(nonatomic, copy, nullable) NSString *nodeIp;

/**
 *  The count of pods yet to drain.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podCount;

@end


/**
 *  BareMetalAdminIslandModeCidrConfig specifies the cluster CIDR configuration
 *  while running in island mode.
 */
@interface GTLRGKEOnPrem_BareMetalAdminIslandModeCidrConfig : GTLRObject

/**
 *  Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
 *  these ranges. This field cannot be changed after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *podAddressCidrBlocks;

/**
 *  Required. All services in the cluster are assigned an RFC1918 IPv4 address
 *  from these ranges. This field cannot be changed after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *serviceAddressCidrBlocks;

@end


/**
 *  BareMetalAdminLoadBalancerConfig specifies the load balancer configuration.
 */
@interface GTLRGKEOnPrem_BareMetalAdminLoadBalancerConfig : GTLRObject

/** Manually configured load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminManualLbConfig *manualLbConfig;

/** Configures the ports that the load balancer will listen on. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminPortConfig *portConfig;

/** The VIPs used by the load balancer. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminVipConfig *vipConfig;

@end


/**
 *  BareMetalAdminMachineDrainStatus represents the status of bare metal node
 *  machines that are undergoing drain operations.
 */
@interface GTLRGKEOnPrem_BareMetalAdminMachineDrainStatus : GTLRObject

/** The list of drained machines. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalAdminDrainedMachine *> *drainedMachines;

/** The list of draning machines. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalAdminDrainingMachine *> *drainingMachines;

@end


/**
 *  BareMetalAdminMaintenanceConfig specifies configurations to put bare metal
 *  Admin cluster CRs nodes in and out of maintenance.
 */
@interface GTLRGKEOnPrem_BareMetalAdminMaintenanceConfig : GTLRObject

/**
 *  Required. All IPv4 address from these ranges will be placed into maintenance
 *  mode. Nodes in maintenance mode will be cordoned and drained. When both of
 *  these are true, the "baremetal.cluster.gke.io/maintenance" annotation will
 *  be set on the node resource.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *maintenanceAddressCidrBlocks;

@end


/**
 *  BareMetalAdminMaintenanceStatus represents the maintenance status for bare
 *  metal Admin cluster CR's nodes.
 */
@interface GTLRGKEOnPrem_BareMetalAdminMaintenanceStatus : GTLRObject

/**
 *  Represents the status of draining and drained machine nodes. This is used to
 *  show the progress of cluster upgrade.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminMachineDrainStatus *machineDrainStatus;

@end


/**
 *  BareMetalAdminManualLbConfig represents configuration parameters for a
 *  manual load balancer.
 */
@interface GTLRGKEOnPrem_BareMetalAdminManualLbConfig : GTLRObject

/**
 *  Whether manual load balancing is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  BareMetalAdminNetworkConfig specifies the cluster network configuration.
 */
@interface GTLRGKEOnPrem_BareMetalAdminNetworkConfig : GTLRObject

/** Configuration for Island mode CIDR. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalAdminIslandModeCidrConfig *islandModeCidr;

@end


/**
 *  Specifies the node access related settings for the bare metal admin cluster.
 */
@interface GTLRGKEOnPrem_BareMetalAdminNodeAccessConfig : GTLRObject

/**
 *  Required. LoginUser is the user name used to access node machines. It
 *  defaults to "root" if not set.
 */
@property(nonatomic, copy, nullable) NSString *loginUser;

@end


/**
 *  Specifies operating system operation settings for cluster provisioning.
 */
@interface GTLRGKEOnPrem_BareMetalAdminOsEnvironmentConfig : GTLRObject

/**
 *  Whether the package repo should be added when initializing bare metal
 *  machines.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packageRepoExcluded;

@end


/**
 *  BareMetalAdminPortConfig is the specification of load balancer ports.
 */
@interface GTLRGKEOnPrem_BareMetalAdminPortConfig : GTLRObject

/**
 *  The port that control plane hosted load balancers will listen on.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controlPlaneLoadBalancerPort;

@end


/**
 *  BareMetalAdminProxyConfig specifies the cluster proxy configuration.
 */
@interface GTLRGKEOnPrem_BareMetalAdminProxyConfig : GTLRObject

/**
 *  A list of IPs, hostnames, and domains that should skip the proxy. Examples:
 *  ["127.0.0.1", "example.com", ".corp", "localhost"].
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *noProxy;

/**
 *  Required. Specifies the address of your proxy server. Examples:
 *  `http://domain` WARNING: Do not provide credentials in the format
 *  `http://(username:password\@)domain` these will be rejected by the server.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Specifies the security related settings for the bare metal admin cluster.
 */
@interface GTLRGKEOnPrem_BareMetalAdminSecurityConfig : GTLRObject

/** Configures user access to the admin cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Authorization *authorization;

@end


/**
 *  BareMetalAdminStorageConfig specifies the cluster storage configuration.
 */
@interface GTLRGKEOnPrem_BareMetalAdminStorageConfig : GTLRObject

/**
 *  Required. Specifies the config for local PersistentVolumes backed by mounted
 *  node disks. These disks need to be formatted and mounted by the user, which
 *  can be done before or after cluster creation.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLvpConfig *lvpNodeMountsConfig;

/**
 *  Required. Specifies the config for local PersistentVolumes backed by
 *  subdirectories in a shared filesystem. These subdirectores are automatically
 *  created during cluster creation.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLvpShareConfig *lvpShareConfig;

@end


/**
 *  BareMetalAdminVipConfig for bare metal load balancer configurations.
 */
@interface GTLRGKEOnPrem_BareMetalAdminVipConfig : GTLRObject

/**
 *  The VIP which you previously set aside for the Kubernetes API of this bare
 *  metal admin cluster.
 */
@property(nonatomic, copy, nullable) NSString *controlPlaneVip;

@end


/**
 *  BareMetalAdminWorkloadNodeConfig specifies the workload node configurations.
 */
@interface GTLRGKEOnPrem_BareMetalAdminWorkloadNodeConfig : GTLRObject

/**
 *  The maximum number of pods a node can run. The size of the CIDR range
 *  assigned to the node will be derived from this parameter. By default 110
 *  Pods are created per Node. Upper bound is 250 for both HA and non-HA admin
 *  cluster. Lower bound is 64 for non-HA admin cluster and 32 for HA admin
 *  cluster.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPodsPerNode;

@end


/**
 *  Represents an arg name->value pair. Only a subset of customized flags are
 *  supported. For the exact format, refer to the [API server
 *  documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
 */
@interface GTLRGKEOnPrem_BareMetalApiServerArgument : GTLRObject

/**
 *  Required. The argument name as it appears on the API Server command line,
 *  make sure to remove the leading dashes.
 */
@property(nonatomic, copy, nullable) NSString *argument;

/**
 *  Required. The value of the arg as it will be passed to the API Server
 *  command line.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  BareMetalBgpLbConfig represents configuration parameters for a Border
 *  Gateway Protocol (BGP) load balancer.
 */
@interface GTLRGKEOnPrem_BareMetalBgpLbConfig : GTLRObject

/**
 *  Required. AddressPools is a list of non-overlapping IP pools used by load
 *  balancer typed services. All addresses must be routable to load balancer
 *  nodes. IngressVIP must be included in the pools.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalLoadBalancerAddressPool *> *addressPools;

/**
 *  Required. BGP autonomous system number (ASN) of the cluster. This field can
 *  be updated after cluster creation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *asn;

/**
 *  Required. The list of BGP peers that the cluster will connect to. At least
 *  one peer must be configured for each control plane node. Control plane nodes
 *  will connect to these peers to advertise the control plane VIP. The Services
 *  load balancer also uses these peers by default. This field can be updated
 *  after cluster creation.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalBgpPeerConfig *> *bgpPeerConfigs;

/**
 *  Specifies the node pool running data plane load balancing. L2 connectivity
 *  is required among nodes in this pool. If missing, the control plane node
 *  pool is used for data plane load balancing.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLoadBalancerNodePoolConfig *loadBalancerNodePoolConfig;

@end


/**
 *  BareMetalBgpPeerConfig represents configuration parameters for a Border
 *  Gateway Protocol (BGP) peer.
 */
@interface GTLRGKEOnPrem_BareMetalBgpPeerConfig : GTLRObject

/**
 *  Required. BGP autonomous system number (ASN) for the network that contains
 *  the external peer device.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *asn;

/**
 *  The IP address of the control plane node that connects to the external peer.
 *  If you don't specify any control plane nodes, all control plane nodes can
 *  connect to the external peer. If you specify one or more IP addresses, only
 *  the nodes specified participate in peering sessions.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *controlPlaneNodes;

/** Required. The IP address of the external peer device. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

@end


/**
 *  Resource that represents a bare metal user cluster. LINT.IfChange
 */
@interface GTLRGKEOnPrem_BareMetalCluster : GTLRObject

/**
 *  Required. The admin cluster this bare metal user cluster belongs to. This is
 *  the full resource name of the admin cluster's fleet membership.
 */
@property(nonatomic, copy, nullable) NSString *adminClusterMembership;

/**
 *  Output only. The resource name of the bare metal admin cluster managing this
 *  user cluster.
 */
@property(nonatomic, copy, nullable) NSString *adminClusterName;

/**
 *  Annotations on the bare metal user cluster. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalCluster_Annotations *annotations;

/**
 *  Required. The Anthos clusters on bare metal version for your user cluster.
 */
@property(nonatomic, copy, nullable) NSString *bareMetalVersion;

/** Binary Authorization related configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BinaryAuthorization *binaryAuthorization;

/** Cluster operations configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalClusterOperationsConfig *clusterOperations;

/** Required. Control plane configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalControlPlaneConfig *controlPlane;

/** Output only. The time when the bare metal user cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The time when the bare metal user cluster was deleted. If the
 *  resource is not deleted, this must be empty
 */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/**
 *  A human readable description of this bare metal user cluster.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The IP address of the bare metal user cluster's API server.
 */
@property(nonatomic, copy, nullable) NSString *endpoint;

/**
 *  Output only. This checksum is computed by the server based on the value of
 *  other fields, and may be sent on update and delete requests to ensure the
 *  client has an up-to-date value before proceeding. Allows clients to perform
 *  consistent read-modify-writes through optimistic concurrency control.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Output only. Fleet configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Fleet *fleet;

/** Required. Load balancer configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLoadBalancerConfig *loadBalancer;

/**
 *  Output only. The object name of the bare metal user cluster custom resource
 *  on the associated admin cluster. This field is used to support conflicting
 *  names when enrolling existing clusters to the API. When used as a part of
 *  cluster enrollment, this field will differ from the name in the resource
 *  name. For new clusters, this field will match the user provided cluster name
 *  and be visible in the last component of the resource name. It is not
 *  modifiable. When the local name and cluster name differ, the local name is
 *  used in the admin cluster controller logs. You use the cluster name when
 *  accessing the cluster using bmctl and kubectl.
 */
@property(nonatomic, copy, nullable) NSString *localName;

/** Maintenance configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalMaintenanceConfig *maintenanceConfig;

/** Output only. Status of on-going maintenance tasks. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalMaintenanceStatus *maintenanceStatus;

/** Immutable. The bare metal user cluster resource name. */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. Network configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNetworkConfig *networkConfig;

/** Node access related configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodeAccessConfig *nodeAccessConfig;

/** Workload node configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalWorkloadNodeConfig *nodeConfig;

/** OS environment related configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalOsEnvironmentConfig *osEnvironmentConfig;

/** Proxy configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalProxyConfig *proxy;

/**
 *  Output only. If set, there are currently changes in flight to the bare metal
 *  user cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/** Security related setting configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalSecurityConfig *securityConfig;

/**
 *  Output only. The current state of the bare metal user cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_Degraded The DEGRADED state
 *        indicates the cluster requires user action to restore full
 *        functionality. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_Error The ERROR state
 *        indicates the cluster is in a broken unrecoverable state. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_Provisioning The
 *        PROVISIONING state indicates the cluster is being created. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_Reconciling The RECONCILING
 *        state indicates that the cluster is being updated. It remains
 *        available, but potentially with degraded performance. (Value:
 *        "RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_Running The RUNNING state
 *        indicates the cluster has been created and is fully usable. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalCluster_State_Stopping The STOPPING state
 *        indicates the cluster is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. Detailed cluster status. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** Required. Storage configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalStorageConfig *storage;

/** Output only. The unique identifier of the bare metal user cluster. */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The time when the bare metal user cluster was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** The cluster upgrade policy. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalClusterUpgradePolicy *upgradePolicy;

/** Output only. The result of the preflight check. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ValidationCheck *validationCheck;

@end


/**
 *  Annotations on the bare metal user cluster. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_BareMetalCluster_Annotations : GTLRObject
@end


/**
 *  Specifies the bare metal user cluster's observability infrastructure.
 */
@interface GTLRGKEOnPrem_BareMetalClusterOperationsConfig : GTLRObject

/**
 *  Whether collection of application logs/metrics should be enabled (in
 *  addition to system logs/metrics).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableApplicationLogs;

@end


/**
 *  BareMetalClusterUpgradePolicy defines the cluster upgrade policy.
 */
@interface GTLRGKEOnPrem_BareMetalClusterUpgradePolicy : GTLRObject

/**
 *  Specifies which upgrade policy to use.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BareMetalClusterUpgradePolicy_Policy_Concurrent
 *        Upgrade all worker node pools in parallel. (Value: "CONCURRENT")
 *    @arg @c kGTLRGKEOnPrem_BareMetalClusterUpgradePolicy_Policy_NodePoolPolicyUnspecified
 *        No upgrade policy selected. (Value: "NODE_POOL_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalClusterUpgradePolicy_Policy_Serial Upgrade
 *        worker node pools sequentially. (Value: "SERIAL")
 */
@property(nonatomic, copy, nullable) NSString *policy;

@end


/**
 *  Specifies the control plane configuration.
 */
@interface GTLRGKEOnPrem_BareMetalControlPlaneConfig : GTLRObject

/**
 *  Customizes the default API server args. Only a subset of customized flags
 *  are supported. For the exact format, refer to the [API server
 *  documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalApiServerArgument *> *apiServerArgs;

/** Required. Configures the node pool running the control plane. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalControlPlaneNodePoolConfig *controlPlaneNodePoolConfig;

@end


/**
 *  Specifies the control plane node pool configuration.
 */
@interface GTLRGKEOnPrem_BareMetalControlPlaneNodePoolConfig : GTLRObject

/**
 *  Required. The generic configuration for a node pool running the control
 *  plane.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePoolConfig *nodePoolConfig;

@end


/**
 *  Represents a machine that is currently drained.
 */
@interface GTLRGKEOnPrem_BareMetalDrainedMachine : GTLRObject

/** Drained machine IP address. */
@property(nonatomic, copy, nullable) NSString *nodeIp;

@end


/**
 *  Represents a machine that is currently draining.
 */
@interface GTLRGKEOnPrem_BareMetalDrainingMachine : GTLRObject

/** Draining machine IP address. */
@property(nonatomic, copy, nullable) NSString *nodeIp;

/**
 *  The count of pods yet to drain.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podCount;

@end


/**
 *  Specifies the cluster CIDR configuration while running in island mode.
 */
@interface GTLRGKEOnPrem_BareMetalIslandModeCidrConfig : GTLRObject

/**
 *  Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
 *  these ranges. This field cannot be changed after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *podAddressCidrBlocks;

/**
 *  Required. All services in the cluster are assigned an RFC1918 IPv4 address
 *  from these ranges. This field is mutable after creation starting with
 *  version 1.15.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *serviceAddressCidrBlocks;

@end


/**
 *  KubeletConfig defines the modifiable kubelet configurations for bare metal
 *  machines. Note: this list includes fields supported in GKE (see
 *  https://cloud.google.com/kubernetes-engine/docs/how-to/node-system-config#kubelet-options).
 */
@interface GTLRGKEOnPrem_BareMetalKubeletConfig : GTLRObject

/**
 *  The maximum size of bursty pulls, temporarily allows pulls to burst to this
 *  number, while still not exceeding registry_pull_qps. The value must not be a
 *  negative number. Updating this field may impact scalability by changing the
 *  amount of traffic produced by image pulls. Defaults to 10.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *registryBurst;

/**
 *  The limit of registry pulls per second. Setting this value to 0 means no
 *  limit. Updating this field may impact scalability by changing the amount of
 *  traffic produced by image pulls. Defaults to 5.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *registryPullQps;

/**
 *  Prevents the Kubelet from pulling multiple images at a time. We recommend
 *  *not* changing the default value on nodes that run docker daemon with
 *  version < 1.9 or an Another Union File System (Aufs) storage backend. Issue
 *  https://github.com/kubernetes/kubernetes/issues/10959 has more details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *serializeImagePullsDisabled;

@end


/**
 *  Represents an IP pool used by the load balancer.
 */
@interface GTLRGKEOnPrem_BareMetalLoadBalancerAddressPool : GTLRObject

/**
 *  Required. The addresses that are part of this pool. Each address must be
 *  either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *addresses;

/**
 *  If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer
 *  devices mistakenly dropping IPv4 traffic for those special IP addresses.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *avoidBuggyIps;

/**
 *  If true, prevent IP addresses from being automatically assigned.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *manualAssign;

/** Required. The name of the address pool. */
@property(nonatomic, copy, nullable) NSString *pool;

@end


/**
 *  Specifies the load balancer configuration.
 */
@interface GTLRGKEOnPrem_BareMetalLoadBalancerConfig : GTLRObject

/**
 *  Configuration for BGP typed load balancers. When set
 *  network_config.advanced_networking is automatically set to true.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalBgpLbConfig *bgpLbConfig;

/** Manually configured load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalManualLbConfig *manualLbConfig;

/** Configuration for MetalLB load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalMetalLbConfig *metalLbConfig;

/** Configures the ports that the load balancer will listen on. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalPortConfig *portConfig;

/** The VIPs used by the load balancer. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalVipConfig *vipConfig;

@end


/**
 *  Specifies the load balancer's node pool configuration.
 */
@interface GTLRGKEOnPrem_BareMetalLoadBalancerNodePoolConfig : GTLRObject

/** The generic configuration for a node pool running a load balancer. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePoolConfig *nodePoolConfig;

@end


/**
 *  Specifies the configs for local persistent volumes (PVs).
 */
@interface GTLRGKEOnPrem_BareMetalLvpConfig : GTLRObject

/** Required. The host machine path. */
@property(nonatomic, copy, nullable) NSString *path;

/** Required. The StorageClass name that PVs will be created with. */
@property(nonatomic, copy, nullable) NSString *storageClass;

@end


/**
 *  Specifies the configs for local persistent volumes under a shared file
 *  system.
 */
@interface GTLRGKEOnPrem_BareMetalLvpShareConfig : GTLRObject

/** Required. Defines the machine path and storage class for the LVP Share. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLvpConfig *lvpConfig;

/**
 *  The number of subdirectories to create under path.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sharedPathPvCount;

@end


/**
 *  Represents the status of node machines that are undergoing drain operations.
 */
@interface GTLRGKEOnPrem_BareMetalMachineDrainStatus : GTLRObject

/** The list of drained machines. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalDrainedMachine *> *drainedMachines;

/** The list of draning machines. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalDrainingMachine *> *drainingMachines;

@end


/**
 *  Specifies configurations to put bare metal nodes in and out of maintenance.
 */
@interface GTLRGKEOnPrem_BareMetalMaintenanceConfig : GTLRObject

/**
 *  Required. All IPv4 address from these ranges will be placed into maintenance
 *  mode. Nodes in maintenance mode will be cordoned and drained. When both of
 *  these are true, the "baremetal.cluster.gke.io/maintenance" annotation will
 *  be set on the node resource.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *maintenanceAddressCidrBlocks;

@end


/**
 *  Represents the maintenance status of the bare metal user cluster.
 */
@interface GTLRGKEOnPrem_BareMetalMaintenanceStatus : GTLRObject

/** The maintenance status of node machines. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalMachineDrainStatus *machineDrainStatus;

@end


/**
 *  Represents configuration parameters for a manual load balancer.
 */
@interface GTLRGKEOnPrem_BareMetalManualLbConfig : GTLRObject

/**
 *  Whether manual load balancing is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Represents configuration parameters for a MetalLB load balancer.
 */
@interface GTLRGKEOnPrem_BareMetalMetalLbConfig : GTLRObject

/**
 *  Required. AddressPools is a list of non-overlapping IP pools used by load
 *  balancer typed services. All addresses must be routable to load balancer
 *  nodes. IngressVIP must be included in the pools.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalLoadBalancerAddressPool *> *addressPools;

/**
 *  Specifies the node pool running the load balancer. L2 connectivity is
 *  required among nodes in this pool. If missing, the control plane node pool
 *  is used as the load balancer pool.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLoadBalancerNodePoolConfig *loadBalancerNodePoolConfig;

@end


/**
 *  Specifies the multiple networking interfaces cluster configuration.
 */
@interface GTLRGKEOnPrem_BareMetalMultipleNetworkInterfacesConfig : GTLRObject

/**
 *  Whether to enable multiple network interfaces for your pods. When set
 *  network_config.advanced_networking is automatically set to true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Specifies the cluster network configuration.
 */
@interface GTLRGKEOnPrem_BareMetalNetworkConfig : GTLRObject

/**
 *  Enables the use of advanced Anthos networking features, such as Bundled Load
 *  Balancing with BGP or the egress NAT gateway. Setting configuration for
 *  advanced networking features will automatically set this flag.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *advancedNetworking;

/**
 *  Configuration for island mode CIDR. In an island-mode network, nodes have
 *  unique IP addresses, but pods don't have unique addresses across clusters.
 *  This doesn't cause problems because pods in one cluster never directly
 *  communicate with pods in another cluster. Instead, there are gateways that
 *  mediate between a pod in one cluster and a pod in another cluster.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalIslandModeCidrConfig *islandModeCidr;

/** Configuration for multiple network interfaces. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalMultipleNetworkInterfacesConfig *multipleNetworkInterfacesConfig;

/** Configuration for SR-IOV. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalSrIovConfig *srIovConfig;

@end


/**
 *  Specifies the node access related settings for the bare metal user cluster.
 */
@interface GTLRGKEOnPrem_BareMetalNodeAccessConfig : GTLRObject

/**
 *  LoginUser is the user name used to access node machines. It defaults to
 *  "root" if not set.
 */
@property(nonatomic, copy, nullable) NSString *loginUser;

@end


/**
 *  BareMetalNodeConfig lists machine addresses to access Nodes.
 */
@interface GTLRGKEOnPrem_BareMetalNodeConfig : GTLRObject

/**
 *  The labels assigned to this node. An object containing a list of key/value
 *  pairs. The labels here, unioned with the labels set on
 *  BareMetalNodePoolConfig are the set of labels that will be applied to the
 *  node. If there are any conflicts, the BareMetalNodeConfig labels take
 *  precedence. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodeConfig_Labels *labels;

/**
 *  The default IPv4 address for SSH access and Kubernetes node. Example:
 *  192.168.0.1
 */
@property(nonatomic, copy, nullable) NSString *nodeIp;

@end


/**
 *  The labels assigned to this node. An object containing a list of key/value
 *  pairs. The labels here, unioned with the labels set on
 *  BareMetalNodePoolConfig are the set of labels that will be applied to the
 *  node. If there are any conflicts, the BareMetalNodeConfig labels take
 *  precedence. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_BareMetalNodeConfig_Labels : GTLRObject
@end


/**
 *  Resource that represents a bare metal node pool.
 */
@interface GTLRGKEOnPrem_BareMetalNodePool : GTLRObject

/**
 *  Annotations on the bare metal node pool. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePool_Annotations *annotations;

/** Output only. The time at which this bare metal node pool was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The time at which this bare metal node pool was deleted. If the
 *  resource is not deleted, this must be empty
 */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** The display name for the bare metal node pool. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  This checksum is computed by the server based on the value of other fields,
 *  and may be sent on update and delete requests to ensure the client has an
 *  up-to-date value before proceeding. Allows clients to perform consistent
 *  read-modify-writes through optimistic concurrency control.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Immutable. The bare metal node pool resource name. */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. Node pool configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePoolConfig *nodePoolConfig;

/**
 *  Output only. If set, there are currently changes in flight to the bare metal
 *  node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  Output only. The current state of the bare metal node pool.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_Degraded The DEGRADED state
 *        indicates the bare metal node pool requires user action to restore
 *        full functionality. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_Error The ERROR state
 *        indicates the bare metal node pool is in a broken unrecoverable state.
 *        (Value: "ERROR")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_Provisioning The
 *        PROVISIONING state indicates the bare metal node pool is being
 *        created. (Value: "PROVISIONING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_Reconciling The RECONCILING
 *        state indicates that the bare metal node pool is being updated. It
 *        remains available, but potentially with degraded performance. (Value:
 *        "RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_Running The RUNNING state
 *        indicates the bare metal node pool has been created and is fully
 *        usable. (Value: "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePool_State_Stopping The STOPPING state
 *        indicates the bare metal node pool is being deleted. (Value:
 *        "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. ResourceStatus representing the detailed node pool status. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** Output only. The unique identifier of the bare metal node pool. */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The time at which this bare metal node pool was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** The worker node pool upgrade policy. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePoolUpgradePolicy *upgradePolicy;

@end


/**
 *  Annotations on the bare metal node pool. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_BareMetalNodePool_Annotations : GTLRObject
@end


/**
 *  BareMetalNodePoolConfig describes the configuration of all nodes within a
 *  given bare metal node pool.
 */
@interface GTLRGKEOnPrem_BareMetalNodePoolConfig : GTLRObject

/** The modifiable kubelet configurations for the bare metal machines. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalKubeletConfig *kubeletConfig;

/**
 *  The labels assigned to nodes of this node pool. An object containing a list
 *  of key/value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count":
 *  "3" }.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalNodePoolConfig_Labels *labels;

/** Required. The list of machine addresses in the bare metal node pool. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalNodeConfig *> *nodeConfigs;

/**
 *  Specifies the nodes operating system (default: LINUX).
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePoolConfig_OperatingSystem_Linux Linux
 *        operating system. (Value: "LINUX")
 *    @arg @c kGTLRGKEOnPrem_BareMetalNodePoolConfig_OperatingSystem_OperatingSystemUnspecified
 *        No operating system runtime selected. (Value:
 *        "OPERATING_SYSTEM_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *operatingSystem;

/** The initial taints assigned to nodes of this node pool. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_NodeTaint *> *taints;

@end


/**
 *  The labels assigned to nodes of this node pool. An object containing a list
 *  of key/value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count":
 *  "3" }.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_BareMetalNodePoolConfig_Labels : GTLRObject
@end


/**
 *  BareMetalNodePoolUpgradePolicy defines the node pool upgrade policy.
 */
@interface GTLRGKEOnPrem_BareMetalNodePoolUpgradePolicy : GTLRObject

/** The parallel upgrade settings for worker node pools. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalParallelUpgradeConfig *parallelUpgradeConfig;

@end


/**
 *  Specifies operating system settings for cluster provisioning.
 */
@interface GTLRGKEOnPrem_BareMetalOsEnvironmentConfig : GTLRObject

/**
 *  Whether the package repo should not be included when initializing bare metal
 *  machines.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packageRepoExcluded;

@end


/**
 *  BareMetalParallelUpgradeConfig defines the parallel upgrade settings for
 *  worker node pools.
 */
@interface GTLRGKEOnPrem_BareMetalParallelUpgradeConfig : GTLRObject

/**
 *  The maximum number of nodes that can be upgraded at once.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *concurrentNodes;

/**
 *  The minimum number of nodes that should be healthy and available during an
 *  upgrade. If set to the default value of 0, it is possible that none of the
 *  nodes will be available during an upgrade.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimumAvailableNodes;

@end


/**
 *  Specifies load balancer ports for the bare metal user cluster.
 */
@interface GTLRGKEOnPrem_BareMetalPortConfig : GTLRObject

/**
 *  The port that control plane hosted load balancers will listen on.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controlPlaneLoadBalancerPort;

@end


/**
 *  Specifies the cluster proxy configuration.
 */
@interface GTLRGKEOnPrem_BareMetalProxyConfig : GTLRObject

/**
 *  A list of IPs, hostnames, and domains that should skip the proxy. Examples:
 *  ["127.0.0.1", "example.com", ".corp", "localhost"].
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *noProxy;

/**
 *  Required. Specifies the address of your proxy server. Examples:
 *  `http://domain` Do not provide credentials in the format
 *  `http://(username:password\@)domain` these will be rejected by the server.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Specifies the security related settings for the bare metal user cluster.
 */
@interface GTLRGKEOnPrem_BareMetalSecurityConfig : GTLRObject

/** Configures user access to the user cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Authorization *authorization;

@end


/**
 *  Specifies the SR-IOV networking operator config.
 */
@interface GTLRGKEOnPrem_BareMetalSrIovConfig : GTLRObject

/**
 *  Whether to install the SR-IOV operator.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  BareMetalStorageConfig specifies the cluster storage configuration.
 */
@interface GTLRGKEOnPrem_BareMetalStorageConfig : GTLRObject

/**
 *  Required. Specifies the config for local PersistentVolumes backed by mounted
 *  node disks. These disks need to be formatted and mounted by the user, which
 *  can be done before or after cluster creation.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLvpConfig *lvpNodeMountsConfig;

/**
 *  Required. Specifies the config for local PersistentVolumes backed by
 *  subdirectories in a shared filesystem. These subdirectores are automatically
 *  created during cluster creation.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_BareMetalLvpShareConfig *lvpShareConfig;

@end


/**
 *  Contains information about a specific Anthos on bare metal version.
 */
@interface GTLRGKEOnPrem_BareMetalVersionInfo : GTLRObject

/** The list of upgrade dependencies for this version. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_UpgradeDependency *> *dependencies;

/**
 *  If set, the cluster dependencies (e.g. the admin cluster, other user
 *  clusters managed by the same admin cluster, version skew policy, etc) must
 *  be upgraded before this version can be installed or upgraded to.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasDependencies;

/** Version number e.g. 1.13.1. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Specifies the VIP config for the bare metal load balancer.
 */
@interface GTLRGKEOnPrem_BareMetalVipConfig : GTLRObject

/**
 *  The VIP which you previously set aside for the Kubernetes API of this bare
 *  metal user cluster.
 */
@property(nonatomic, copy, nullable) NSString *controlPlaneVip;

/**
 *  The VIP which you previously set aside for ingress traffic into this bare
 *  metal user cluster.
 */
@property(nonatomic, copy, nullable) NSString *ingressVip;

@end


/**
 *  Specifies the workload node configurations.
 */
@interface GTLRGKEOnPrem_BareMetalWorkloadNodeConfig : GTLRObject

/**
 *  Specifies which container runtime will be used.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BareMetalWorkloadNodeConfig_ContainerRuntime_Containerd
 *        Containerd runtime. (Value: "CONTAINERD")
 *    @arg @c kGTLRGKEOnPrem_BareMetalWorkloadNodeConfig_ContainerRuntime_ContainerRuntimeUnspecified
 *        No container runtime selected. (Value:
 *        "CONTAINER_RUNTIME_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *containerRuntime;

/**
 *  The maximum number of pods a node can run. The size of the CIDR range
 *  assigned to the node will be derived from this parameter.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPodsPerNode;

@end


/**
 *  Configuration for Binary Authorization.
 */
@interface GTLRGKEOnPrem_BinaryAuthorization : GTLRObject

/**
 *  Mode of operation for binauthz policy evaluation. If unspecified, defaults
 *  to DISABLED.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_BinaryAuthorization_EvaluationMode_Disabled Disable
 *        BinaryAuthorization (Value: "DISABLED")
 *    @arg @c kGTLRGKEOnPrem_BinaryAuthorization_EvaluationMode_EvaluationModeUnspecified
 *        Default value (Value: "EVALUATION_MODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_BinaryAuthorization_EvaluationMode_ProjectSingletonPolicyEnforce
 *        Enforce Kubernetes admission requests with BinaryAuthorization using
 *        the project's singleton policy. (Value:
 *        "PROJECT_SINGLETON_POLICY_ENFORCE")
 */
@property(nonatomic, copy, nullable) NSString *evaluationMode;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRGKEOnPrem_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `domain:{domain}`: The G Suite domain
 *  (primary) that represents all the users of that domain. For example,
 *  `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a user that has been
 *  recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRGKEOnPrem_CancelOperationRequest : GTLRObject
@end


/**
 *  ClusterUser configures user principals for an RBAC policy.
 */
@interface GTLRGKEOnPrem_ClusterUser : GTLRObject

/** Required. The name of the user, e.g. `my-gcp-id\@gmail.com`. */
@property(nonatomic, copy, nullable) NSString *username;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRGKEOnPrem_Empty : GTLRObject
@end


/**
 *  Message for enrolling an existing bare metal admin cluster to the GKE
 *  on-prem API.
 */
@interface GTLRGKEOnPrem_EnrollBareMetalAdminClusterRequest : GTLRObject

/**
 *  User provided OnePlatform identifier that is used as part of the resource
 *  name. This must be unique among all GKE on-prem clusters within a project
 *  and location and will return a 409 if the cluster already exists.
 *  (https://tools.ietf.org/html/rfc1123) format.
 */
@property(nonatomic, copy, nullable) NSString *bareMetalAdminClusterId;

/**
 *  Required. This is the full resource name of this admin cluster's fleet
 *  membership.
 */
@property(nonatomic, copy, nullable) NSString *membership;

@end


/**
 *  Message for enrolling an existing bare metal cluster to the Anthos On-Prem
 *  API.
 */
@interface GTLRGKEOnPrem_EnrollBareMetalClusterRequest : GTLRObject

/**
 *  Required. The admin cluster this bare metal user cluster belongs to. This is
 *  the full resource name of the admin cluster's fleet membership. In the
 *  future, references to other resource types might be allowed if admin
 *  clusters are modeled as their own resources.
 */
@property(nonatomic, copy, nullable) NSString *adminClusterMembership;

/**
 *  User provided OnePlatform identifier that is used as part of the resource
 *  name. This must be unique among all bare metal clusters within a project and
 *  location and will return a 409 if the cluster already exists.
 *  (https://tools.ietf.org/html/rfc1123) format.
 */
@property(nonatomic, copy, nullable) NSString *bareMetalClusterId;

/**
 *  Optional. The object name of the bare metal cluster custom resource on the
 *  associated admin cluster. This field is used to support conflicting resource
 *  names when enrolling existing clusters to the API. When not provided, this
 *  field will resolve to the bare_metal_cluster_id. Otherwise, it must match
 *  the object name of the bare metal cluster custom resource. It is not
 *  modifiable outside / beyond the enrollment operation.
 */
@property(nonatomic, copy, nullable) NSString *localName;

@end


/**
 *  Message for enrolling an existing bare metal node pool to the GKE on-prem
 *  API.
 */
@interface GTLRGKEOnPrem_EnrollBareMetalNodePoolRequest : GTLRObject

/**
 *  User provided OnePlatform identifier that is used as part of the resource
 *  name. (https://tools.ietf.org/html/rfc1123) format.
 */
@property(nonatomic, copy, nullable) NSString *bareMetalNodePoolId;

/**
 *  If set, only validate the request, but do not actually enroll the node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateOnly;

@end


/**
 *  Message for enrolling an existing VMware admin cluster to the GKE on-prem
 *  API.
 */
@interface GTLRGKEOnPrem_EnrollVmwareAdminClusterRequest : GTLRObject

/**
 *  Required. This is the full resource name of this admin cluster's fleet
 *  membership.
 */
@property(nonatomic, copy, nullable) NSString *membership;

/**
 *  User provided OnePlatform identifier that is used as part of the resource
 *  name. This must be unique among all GKE on-prem clusters within a project
 *  and location and will return a 409 if the cluster already exists.
 *  (https://tools.ietf.org/html/rfc1123) format.
 */
@property(nonatomic, copy, nullable) NSString *vmwareAdminClusterId;

@end


/**
 *  Message for enrolling an existing VMware cluster to the Anthos On-Prem API.
 */
@interface GTLRGKEOnPrem_EnrollVmwareClusterRequest : GTLRObject

/**
 *  Required. The admin cluster this VMware user cluster belongs to. This is the
 *  full resource name of the admin cluster's fleet membership. In the future,
 *  references to other resource types might be allowed if admin clusters are
 *  modeled as their own resources.
 */
@property(nonatomic, copy, nullable) NSString *adminClusterMembership;

/**
 *  Optional. The object name of the VMware OnPremUserCluster custom resource on
 *  the associated admin cluster. This field is used to support conflicting
 *  resource names when enrolling existing clusters to the API. When not
 *  provided, this field will resolve to the vmware_cluster_id. Otherwise, it
 *  must match the object name of the VMware OnPremUserCluster custom resource.
 *  It is not modifiable outside / beyond the enrollment operation.
 */
@property(nonatomic, copy, nullable) NSString *localName;

/**
 *  Validate the request without actually doing any updates.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateOnly;

/**
 *  User provided OnePlatform identifier that is used as part of the resource
 *  name. This must be unique among all GKE on-prem clusters within a project
 *  and location and will return a 409 if the cluster already exists.
 *  (https://tools.ietf.org/html/rfc1123) format.
 */
@property(nonatomic, copy, nullable) NSString *vmwareClusterId;

@end


/**
 *  Message for enrolling a VMware node pool.
 */
@interface GTLRGKEOnPrem_EnrollVmwareNodePoolRequest : GTLRObject

/** The target node pool id to be enrolled. */
@property(nonatomic, copy, nullable) NSString *vmwareNodePoolId;

@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRGKEOnPrem_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Fleet related configuration. Fleets are a Google Cloud concept for logically
 *  organizing clusters, letting you use and manage multi-cluster capabilities
 *  and apply consistent policies across your systems. See [Anthos
 *  Fleets](`https://cloud.google.com/anthos/multicluster-management/fleets`)
 *  for more details on Anthos multi-cluster capabilities using Fleets. ##
 */
@interface GTLRGKEOnPrem_Fleet : GTLRObject

/**
 *  Output only. The name of the managed fleet Membership resource associated to
 *  this cluster. Membership names are formatted as
 *  `projects//locations//memberships/`.
 */
@property(nonatomic, copy, nullable) NSString *membership;

@end


/**
 *  Response message for listing bare metal admin clusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "bareMetalAdminClusters" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRGKEOnPrem_ListBareMetalAdminClustersResponse : GTLRCollectionObject

/**
 *  The list of bare metal admin cluster.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalAdminCluster *> *bareMetalAdminClusters;

/**
 *  A token identifying a page of results the server should return. If the token
 *  is not empty this means that more results are available and should be
 *  retrieved by repeating the request with the provided page token.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for listing bare metal Clusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "bareMetalClusters" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRGKEOnPrem_ListBareMetalClustersResponse : GTLRCollectionObject

/**
 *  The list of bare metal Clusters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalCluster *> *bareMetalClusters;

/**
 *  A token identifying a page of results the server should return. If the token
 *  is not empty this means that more results are available and should be
 *  retrieved by repeating the request with the provided page token.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for listing bare metal node pools.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "bareMetalNodePools" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRGKEOnPrem_ListBareMetalNodePoolsResponse : GTLRCollectionObject

/**
 *  The node pools from the specified parent resource.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalNodePool *> *bareMetalNodePools;

/**
 *  A token, which can be sent as `page_token` to retrieve the next page. If
 *  this field is omitted, there are no subsequent pages.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEOnPrem_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEOnPrem_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_Operation *> *operations;

@end


/**
 *  Response message for listing VMware admin clusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "vmwareAdminClusters" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRGKEOnPrem_ListVmwareAdminClustersResponse : GTLRCollectionObject

/**
 *  A token identifying a page of results the server should return. If the token
 *  is not empty this means that more results are available and should be
 *  retrieved by repeating the request with the provided page token.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

/**
 *  The list of VMware admin cluster.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareAdminCluster *> *vmwareAdminClusters;

@end


/**
 *  Response message for listing VMware Clusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "vmwareClusters" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRGKEOnPrem_ListVmwareClustersResponse : GTLRCollectionObject

/**
 *  A token identifying a page of results the server should return. If the token
 *  is not empty this means that more results are available and should be
 *  retrieved by repeating the request with the provided page token.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

/**
 *  The list of VMware Cluster.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareCluster *> *vmwareClusters;

@end


/**
 *  Response message for listing VMware node pools.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "vmwareNodePools" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRGKEOnPrem_ListVmwareNodePoolsResponse : GTLRCollectionObject

/**
 *  A token, which can be sent as `page_token` to retrieve the next page. If
 *  this field is omitted, there are no subsequent pages.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

/**
 *  The node pools from the specified parent resource.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareNodePool *> *vmwareNodePools;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRGKEOnPrem_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEOnPrem_Location_Metadata : GTLRObject
@end


/**
 *  Progress metric is (string, int|float|string) pair.
 */
@interface GTLRGKEOnPrem_Metric : GTLRObject

/**
 *  For metrics with floating point value.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  For metrics with integer value.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *intValue;

/**
 *  Required. The metric name.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_MetricIdUnspecified Not set. (Value:
 *        "METRIC_ID_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesDraining The number of nodes
 *        draining. (Value: "NODES_DRAINING")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesFailed The number of nodes to
 *        fail actuation. (Value: "NODES_FAILED")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesHealthy The number of nodes
 *        healthy. (Value: "NODES_HEALTHY")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesInMaintenance The number of
 *        nodes in maintenance mode. (Value: "NODES_IN_MAINTENANCE")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesPendingUpgrade The number of
 *        nodes to be upgraded. (Value: "NODES_PENDING_UPGRADE")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesReconciling The number of nodes
 *        reconciling. (Value: "NODES_RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesTotal The total number of nodes
 *        being actuated. (Value: "NODES_TOTAL")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesUpgraded The number of nodes
 *        upgraded. (Value: "NODES_UPGRADED")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_NodesUpgrading The number of nodes
 *        actively upgrading. (Value: "NODES_UPGRADING")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_PreflightsCompleted The number of
 *        completed preflight checks. (Value: "PREFLIGHTS_COMPLETED")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_PreflightsFailed The number of
 *        preflight checks failed. (Value: "PREFLIGHTS_FAILED")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_PreflightsRunning The number of
 *        preflight checks running. (Value: "PREFLIGHTS_RUNNING")
 *    @arg @c kGTLRGKEOnPrem_Metric_Metric_PreflightsTotal The total number of
 *        preflight checks. (Value: "PREFLIGHTS_TOTAL")
 */
@property(nonatomic, copy, nullable) NSString *metric;

/** For metrics with custom values (ratios, visual progress, etc.). */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  NodeTaint applied to every Kubernetes node in a node pool. Kubernetes taints
 *  can be used together with tolerations to control how workloads are scheduled
 *  to your nodes. Node taints are permanent.
 */
@interface GTLRGKEOnPrem_NodeTaint : GTLRObject

/**
 *  The taint effect.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_NodeTaint_Effect_EffectUnspecified Not set. (Value:
 *        "EFFECT_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_NodeTaint_Effect_NoExecute Evict any
 *        already-running pods that do not tolerate the taint. Currently
 *        enforced by NodeController. (Value: "NO_EXECUTE")
 *    @arg @c kGTLRGKEOnPrem_NodeTaint_Effect_NoSchedule Do not allow new pods
 *        to schedule onto the node unless they tolerate the taint, but allow
 *        all pods submitted to Kubelet without going through the scheduler to
 *        start, and allow all already-running pods to continue running.
 *        Enforced by the scheduler. (Value: "NO_SCHEDULE")
 *    @arg @c kGTLRGKEOnPrem_NodeTaint_Effect_PreferNoSchedule Like
 *        TaintEffectNoSchedule, but the scheduler tries not to schedule new
 *        pods onto the node, rather than prohibiting new pods from scheduling
 *        onto the node entirely. Enforced by the scheduler. (Value:
 *        "PREFER_NO_SCHEDULE")
 */
@property(nonatomic, copy, nullable) NSString *effect;

/** Key associated with the effect. */
@property(nonatomic, copy, nullable) NSString *key;

/** Value associated with the effect. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRGKEOnPrem_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEOnPrem_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEOnPrem_Operation_Response : GTLRObject
@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRGKEOnPrem_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  Output only. Denotes if the local managing cluster's control plane is
 *  currently disconnected. This is expected to occur temporarily during
 *  self-managed cluster upgrades.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controlPlaneDisconnected;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Output only. Detailed progress information for the operation. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_OperationProgress *progress;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have successfully been cancelled have
 *  [Operation.error] value with a [google.rpc.Status.code] of 1, corresponding
 *  to `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/**
 *  Output only. Type of operation being executed.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_OperationMetadata_Type_Create The resource is being
 *        created. (Value: "CREATE")
 *    @arg @c kGTLRGKEOnPrem_OperationMetadata_Type_Delete The resource is being
 *        deleted. (Value: "DELETE")
 *    @arg @c kGTLRGKEOnPrem_OperationMetadata_Type_OperationTypeUnspecified Not
 *        set. (Value: "OPERATION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_OperationMetadata_Type_PlatformUpgrade The platform
 *        is being upgraded. (Value: "PLATFORM_UPGRADE")
 *    @arg @c kGTLRGKEOnPrem_OperationMetadata_Type_Update The resource is being
 *        updated. (Value: "UPDATE")
 *    @arg @c kGTLRGKEOnPrem_OperationMetadata_Type_Upgrade The resource is
 *        being upgraded. (Value: "UPGRADE")
 */
@property(nonatomic, copy, nullable) NSString *type;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  Information about operation progress. LINT.IfChange
 */
@interface GTLRGKEOnPrem_OperationProgress : GTLRObject

/** The stages of the operation. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_OperationStage *> *stages;

@end


/**
 *  Information about a particular stage of an operation.
 */
@interface GTLRGKEOnPrem_OperationStage : GTLRObject

/** Time the stage ended. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Progress metric bundle. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_Metric *> *metrics;

/**
 *  The high-level stage of the operation.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_OperationStage_Stage_Configure Resource is being
 *        configured. (Value: "CONFIGURE")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_Stage_Deploy Resource is being
 *        deployed. (Value: "DEPLOY")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_Stage_HealthCheck Waiting for the
 *        resource to become healthy. (Value: "HEALTH_CHECK")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_Stage_PreflightCheck Preflight
 *        checks are running. (Value: "PREFLIGHT_CHECK")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_Stage_StageUnspecified Not set.
 *        (Value: "STAGE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_Stage_Update Resource is being
 *        updated. (Value: "UPDATE")
 */
@property(nonatomic, copy, nullable) NSString *stage;

/** Time the stage started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Output only. State of the stage.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_OperationStage_State_Failed The stage has failed.
 *        (Value: "FAILED")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_State_Pending The stage is pending.
 *        (Value: "PENDING")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_State_Running The stage is running
 *        (Value: "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_OperationStage_State_Succeeded The stage has
 *        completed successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** ``` { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
 *  members: - user:mike\@example.com - group:admins\@example.com -
 *  domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 ``` For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRGKEOnPrem_Policy : GTLRObject

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Response message for querying bare metal admin cluster version config.
 */
@interface GTLRGKEOnPrem_QueryBareMetalAdminVersionConfigResponse : GTLRObject

/** List of available versions to install or to upgrade to. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalVersionInfo *> *versions;

@end


/**
 *  Response message for querying bare metal admin cluster version config.
 */
@interface GTLRGKEOnPrem_QueryBareMetalVersionConfigResponse : GTLRObject

/** List of available versions to install or to upgrade to. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_BareMetalVersionInfo *> *versions;

@end


/**
 *  Response message for querying VMware user cluster version config.
 */
@interface GTLRGKEOnPrem_QueryVmwareVersionConfigResponse : GTLRObject

/** List of available versions to install or to upgrade to. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareVersionInfo *> *versions;

@end


/**
 *  ResourceCondition provides a standard mechanism for higher-level status
 *  reporting from controller.
 */
@interface GTLRGKEOnPrem_ResourceCondition : GTLRObject

/** Last time the condition transit from one status to another. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastTransitionTime;

/** Human-readable message indicating details about last transition. */
@property(nonatomic, copy, nullable) NSString *message;

/** Machine-readable message indicating details about last transition. */
@property(nonatomic, copy, nullable) NSString *reason;

/**
 *  state of the condition.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_ResourceCondition_State_StateFalse Resource is not
 *        in the condition. (Value: "STATE_FALSE")
 *    @arg @c kGTLRGKEOnPrem_ResourceCondition_State_StateTrue Resource is in
 *        the condition. (Value: "STATE_TRUE")
 *    @arg @c kGTLRGKEOnPrem_ResourceCondition_State_StateUnknown Kubernetes
 *        controller can't decide if the resource is in the condition or not.
 *        (Value: "STATE_UNKNOWN")
 *    @arg @c kGTLRGKEOnPrem_ResourceCondition_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Type of the condition. (e.g., ClusterRunning, NodePoolRunning or
 *  ServerSidePreflightReady)
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  ResourceStatus describes why a cluster or node pool has a certain status.
 *  (e.g., ERROR or DEGRADED).
 */
@interface GTLRGKEOnPrem_ResourceStatus : GTLRObject

/**
 *  ResourceCondition provide a standard mechanism for higher-level status
 *  reporting from controller.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_ResourceCondition *> *conditions;

/**
 *  Human-friendly representation of the error message from controller. The
 *  error message can be temporary as the controller controller creates a
 *  cluster or node pool. If the error message persists for a longer period of
 *  time, it can be used to surface error message to indicate real problems
 *  requiring user intervention.
 */
@property(nonatomic, copy, nullable) NSString *errorMessage;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRGKEOnPrem_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Policy *policy;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRGKEOnPrem_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRGKEOnPrem_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEOnPrem_Status_Details_Item : GTLRObject
@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRGKEOnPrem_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRGKEOnPrem_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  UpgradeDependency represents a dependency when upgrading a resource.
 */
@interface GTLRGKEOnPrem_UpgradeDependency : GTLRObject

/** Current version of the dependency e.g. 1.15.0. */
@property(nonatomic, copy, nullable) NSString *currentVersion;

/** Membership names are formatted as `projects//locations//memberships/`. */
@property(nonatomic, copy, nullable) NSString *membership;

/** Resource name of the dependency. */
@property(nonatomic, copy, nullable) NSString *resourceName;

/**
 *  Target version of the dependency e.g. 1.16.1. This is the version the
 *  dependency needs to be upgraded to before a resource can be upgraded.
 */
@property(nonatomic, copy, nullable) NSString *targetVersion;

@end


/**
 *  ValidationCheck represents the result of preflight check.
 */
@interface GTLRGKEOnPrem_ValidationCheck : GTLRObject

/**
 *  Options used for the validation check
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_ValidationCheck_Option_OptionsUnspecified Default
 *        value. Standard preflight validation check will be used. (Value:
 *        "OPTIONS_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheck_Option_SkipValidationAll Skip all
 *        preflight check validations. (Value: "SKIP_VALIDATION_ALL")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheck_Option_SkipValidationCheckBlocking
 *        Prevent failed preflight checks from failing. (Value:
 *        "SKIP_VALIDATION_CHECK_BLOCKING")
 */
@property(nonatomic, copy, nullable) NSString *option;

/**
 *  Output only. The scenario when the preflight checks were run.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_ValidationCheck_Scenario_Create The validation
 *        check occurred during a create flow. (Value: "CREATE")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheck_Scenario_ScenarioUnspecified
 *        Default value. This value is unused. (Value: "SCENARIO_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheck_Scenario_Update The validation
 *        check occurred during an update flow. (Value: "UPDATE")
 */
@property(nonatomic, copy, nullable) NSString *scenario;

/** Output only. The detailed validation check status. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ValidationCheckStatus *status;

@end


/**
 *  ValidationCheckResult defines the details about the validation check.
 */
@interface GTLRGKEOnPrem_ValidationCheckResult : GTLRObject

/** The category of the validation. */
@property(nonatomic, copy, nullable) NSString *category;

/**
 *  The description of the validation check.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Detailed failure information, which might be unformatted. */
@property(nonatomic, copy, nullable) NSString *details;

/** A human-readable message of the check failure. */
@property(nonatomic, copy, nullable) NSString *reason;

/**
 *  The validation check state.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_ValidationCheckResult_State_StateFailure The check
 *        failed. (Value: "STATE_FAILURE")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheckResult_State_StateFatal The check
 *        itself failed to complete. (Value: "STATE_FATAL")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheckResult_State_StateSkipped The check
 *        was skipped. (Value: "STATE_SKIPPED")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheckResult_State_StateUnknown The
 *        default value. The check result is unknown. (Value: "STATE_UNKNOWN")
 *    @arg @c kGTLRGKEOnPrem_ValidationCheckResult_State_StateWarning The check
 *        encountered a warning. (Value: "STATE_WARNING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  ValidationCheckStatus defines the detailed validation check status.
 */
@interface GTLRGKEOnPrem_ValidationCheckStatus : GTLRObject

/**
 *  Individual checks which failed as part of the Preflight check execution.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_ValidationCheckResult *> *result;

@end


/**
 *  Specifies anti affinity group config for the VMware user cluster.
 */
@interface GTLRGKEOnPrem_VmwareAAGConfig : GTLRObject

/**
 *  Spread nodes across at least three physical hosts (requires at least three
 *  hosts). Enabled by default.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aagConfigDisabled;

@end


/**
 *  Represents an IP pool used by the load balancer.
 */
@interface GTLRGKEOnPrem_VmwareAddressPool : GTLRObject

/**
 *  Required. The addresses that are part of this pool. Each address must be
 *  either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *addresses;

/**
 *  If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer
 *  devices mistakenly dropping IPv4 traffic for those special IP addresses.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *avoidBuggyIps;

/**
 *  If true, prevent IP addresses from being automatically assigned.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *manualAssign;

/** Required. The name of the address pool. */
@property(nonatomic, copy, nullable) NSString *pool;

@end


/**
 *  VmwareAdminAddonNodeConfig contains add-on node configurations for VMware
 *  admin cluster.
 */
@interface GTLRGKEOnPrem_VmwareAdminAddonNodeConfig : GTLRObject

/** VmwareAutoResizeConfig config specifies auto resize config. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAutoResizeConfig *autoResizeConfig;

@end


/**
 *  VmwareAdminAuthorizationConfig represents configuration for admin cluster
 *  authorization.
 */
@interface GTLRGKEOnPrem_VmwareAdminAuthorizationConfig : GTLRObject

/**
 *  For VMware admin clusters, users will be granted the cluster-viewer role on
 *  the cluster.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_ClusterUser *> *viewerUsers;

@end


/**
 *  Resource that represents a VMware admin cluster.
 */
@interface GTLRGKEOnPrem_VmwareAdminCluster : GTLRObject

/** The VMware admin cluster addon node configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminAddonNodeConfig *addonNode;

/**
 *  Annotations on the VMware admin cluster. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminCluster_Annotations *annotations;

/** The VMware admin cluster anti affinity group configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAAGConfig *antiAffinityGroups;

/** The VMware admin cluster authorization configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminAuthorizationConfig *authorization;

/** The VMware admin cluster auto repair configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAutoRepairConfig *autoRepairConfig;

/** The bootstrap cluster this VMware admin cluster belongs to. */
@property(nonatomic, copy, nullable) NSString *bootstrapClusterMembership;

/** The VMware admin cluster control plane node configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminControlPlaneNodeConfig *controlPlaneNode;

/** Output only. The time at which VMware admin cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A human readable description of this VMware admin cluster.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Output only. The DNS name of VMware admin cluster's API server. */
@property(nonatomic, copy, nullable) NSString *endpoint;

/**
 *  This checksum is computed by the server based on the value of other fields,
 *  and may be sent on update and delete requests to ensure the client has an
 *  up-to-date value before proceeding. Allows clients to perform consistent
 *  read-modify-writes through optimistic concurrency control.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Output only. Fleet configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Fleet *fleet;

/** The OS image type for the VMware admin cluster. */
@property(nonatomic, copy, nullable) NSString *imageType;

/** The VMware admin cluster load balancer configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminLoadBalancerConfig *loadBalancer;

/**
 *  Output only. The object name of the VMware OnPremAdminCluster custom
 *  resource. This field is used to support conflicting names when enrolling
 *  existing clusters to the API. When used as a part of cluster enrollment,
 *  this field will differ from the ID in the resource name. For new clusters,
 *  this field will match the user provided cluster name and be visible in the
 *  last component of the resource name. It is not modifiable. All users should
 *  use this name to access their cluster using gkectl or kubectl and should
 *  expect to see the local name when viewing admin cluster controller logs.
 */
@property(nonatomic, copy, nullable) NSString *localName;

/** Immutable. The VMware admin cluster resource name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The VMware admin cluster network configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminNetworkConfig *networkConfig;

/** The Anthos clusters on the VMware version for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *onPremVersion;

/** The VMware platform configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwarePlatformConfig *platformConfig;

/**
 *  Output only. The VMware admin cluster prepared secrets configuration. It
 *  should always be enabled by the Central API, instead of letting users set
 *  it.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminPreparedSecretsConfig *preparedSecrets;

/**
 *  Output only. If set, there are currently changes in flight to the VMware
 *  admin cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  Output only. The current state of VMware admin cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_Degraded The DEGRADED
 *        state indicates the cluster requires user action to restore full
 *        functionality. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_Error The ERROR state
 *        indicates the cluster is in a broken unrecoverable state. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_Provisioning The
 *        PROVISIONING state indicates the cluster is being created. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_Reconciling The
 *        RECONCILING state indicates that the cluster is being updated. It
 *        remains available, but potentially with degraded performance. (Value:
 *        "RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_Running The RUNNING state
 *        indicates the cluster has been created and is fully usable. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_VmwareAdminCluster_State_Stopping The STOPPING
 *        state indicates the cluster is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. ResourceStatus representing detailed cluster state. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** Output only. The unique identifier of the VMware admin cluster. */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time at which VMware admin cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** The VMware admin cluster VCenter configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminVCenterConfig *vcenter;

@end


/**
 *  Annotations on the VMware admin cluster. This field has the same
 *  restrictions as Kubernetes annotations. The total size of all keys and
 *  values combined is limited to 256k. Key can have 2 segments: prefix
 *  (optional) and name (required), separated by a slash (/). Prefix must be a
 *  DNS subdomain. Name must be 63 characters or less, begin and end with
 *  alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics
 *  between.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_VmwareAdminCluster_Annotations : GTLRObject
@end


/**
 *  VmwareAdminControlPlaneNodeConfig contains control plane node configuration
 *  for VMware admin cluster.
 */
@interface GTLRGKEOnPrem_VmwareAdminControlPlaneNodeConfig : GTLRObject

/**
 *  The number of vCPUs for the control-plane node of the admin cluster.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cpus;

/**
 *  The number of mebibytes of memory for the control-plane node of the admin
 *  cluster.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memory;

/**
 *  The number of control plane nodes for this VMware admin cluster. (default: 1
 *  replica).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicas;

@end


/**
 *  VmwareAdminF5BigIpConfig represents configuration parameters for an F5
 *  BIG-IP load balancer.
 */
@interface GTLRGKEOnPrem_VmwareAdminF5BigIpConfig : GTLRObject

/** The load balancer's IP address. */
@property(nonatomic, copy, nullable) NSString *address;

/**
 *  The preexisting partition to be used by the load balancer. This partition is
 *  usually created for the admin cluster for example: 'my-f5-admin-partition'.
 */
@property(nonatomic, copy, nullable) NSString *partition;

/** The pool name. Only necessary, if using SNAT. */
@property(nonatomic, copy, nullable) NSString *snatPool;

@end


/**
 *  Specifies HA admin control plane config.
 */
@interface GTLRGKEOnPrem_VmwareAdminHAControlPlaneConfig : GTLRObject

/** Static IP addresses for the admin control plane nodes. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareIpBlock *controlPlaneIpBlock;

@end


/**
 *  VmwareAdminLoadBalancerConfig contains load balancer configuration for
 *  VMware admin cluster.
 */
@interface GTLRGKEOnPrem_VmwareAdminLoadBalancerConfig : GTLRObject

/** Configuration for F5 Big IP typed load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminF5BigIpConfig *f5Config;

/** Manually configured load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminManualLbConfig *manualLbConfig;

/** MetalLB load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminMetalLbConfig *metalLbConfig;

/** Output only. Configuration for Seesaw typed load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminSeesawConfig *seesawConfig;

/** The VIPs used by the load balancer. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminVipConfig *vipConfig;

@end


/**
 *  GTLRGKEOnPrem_VmwareAdminManualLbConfig
 */
@interface GTLRGKEOnPrem_VmwareAdminManualLbConfig : GTLRObject

/**
 *  NodePort for add-ons server in the admin cluster.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *addonsNodePort;

/**
 *  NodePort for control plane service. The Kubernetes API server in the admin
 *  cluster is implemented as a Service of type NodePort (ex. 30968).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controlPlaneNodePort;

/**
 *  NodePort for ingress service's http. The ingress service in the admin
 *  cluster is implemented as a Service of type NodePort (ex. 32527).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ingressHttpNodePort;

/**
 *  NodePort for ingress service's https. The ingress service in the admin
 *  cluster is implemented as a Service of type NodePort (ex. 30139).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ingressHttpsNodePort;

/**
 *  NodePort for konnectivity server service running as a sidecar in each
 *  kube-apiserver pod (ex. 30564).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *konnectivityServerNodePort;

@end


/**
 *  VmwareAdminMetalLbConfig represents configuration parameters for a MetalLB
 *  load balancer. For admin clusters, currently no configurations is needed.
 */
@interface GTLRGKEOnPrem_VmwareAdminMetalLbConfig : GTLRObject
@end


/**
 *  VmwareAdminNetworkConfig contains network configuration for VMware admin
 *  cluster.
 */
@interface GTLRGKEOnPrem_VmwareAdminNetworkConfig : GTLRObject

/** Configuration settings for a DHCP IP configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareDhcpIpConfig *dhcpIpConfig;

/** Configuration for HA admin cluster control plane. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAdminHAControlPlaneConfig *haControlPlaneConfig;

/**
 *  Represents common network settings irrespective of the host's IP address.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareHostConfig *hostConfig;

/**
 *  Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
 *  these ranges. Only a single range is supported. This field cannot be changed
 *  after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *podAddressCidrBlocks;

/**
 *  Required. All services in the cluster are assigned an RFC1918 IPv4 address
 *  from these ranges. Only a single range is supported. This field cannot be
 *  changed after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *serviceAddressCidrBlocks;

/** Configuration settings for a static IP configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareStaticIpConfig *staticIpConfig;

/** vcenter_network specifies vCenter network name. */
@property(nonatomic, copy, nullable) NSString *vcenterNetwork;

@end


/**
 *  VmwareAdminPreparedSecretsConfig represents configuration for admin cluster
 *  prepared secrets.
 */
@interface GTLRGKEOnPrem_VmwareAdminPreparedSecretsConfig : GTLRObject

/**
 *  Whether prepared secrets is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  VmwareSeesawConfig represents configuration parameters for an already
 *  existing Seesaw load balancer. IMPORTANT: Please note that the Anthos
 *  On-Prem API will not generate or update Seesaw configurations it can only
 *  bind a pre-existing configuration to a new user cluster. IMPORTANT: When
 *  attempting to create a user cluster with a pre-existing Seesaw load balancer
 *  you will need to follow some preparation steps before calling the
 *  'CreateVmwareCluster' API method. First you will need to create the user
 *  cluster's namespace via kubectl. The namespace will need to use the
 *  following naming convention : -gke-onprem-mgmt or -gke-onprem-mgmt depending
 *  on whether you used the 'VmwareCluster.local_name' to disambiguate
 *  collisions; for more context see the documentation of
 *  'VmwareCluster.local_name'. Once the namespace is created you will need to
 *  create a secret resource via kubectl. This secret will contain copies of
 *  your Seesaw credentials. The Secret must be called 'user-cluster-creds' and
 *  contain Seesaw's SSH and Cert credentials. The credentials must be keyed
 *  with the following names: 'seesaw-ssh-private-key', 'seesaw-ssh-public-key',
 *  'seesaw-ssh-ca-key', 'seesaw-ssh-ca-cert'.
 */
@interface GTLRGKEOnPrem_VmwareAdminSeesawConfig : GTLRObject

/**
 *  Enable two load balancer VMs to achieve a highly-available Seesaw load
 *  balancer.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableHa;

/**
 *  In general the following format should be used for the Seesaw group name:
 *  seesaw-for-[cluster_name].
 */
@property(nonatomic, copy, nullable) NSString *group;

/** The IP Blocks to be used by the Seesaw load balancer */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareIpBlock *> *ipBlocks;

/** MasterIP is the IP announced by the master of Seesaw group. */
@property(nonatomic, copy, nullable) NSString *masterIp;

/** Name to be used by Stackdriver. */
@property(nonatomic, copy, nullable) NSString *stackdriverName;

/** Names of the VMs created for this Seesaw group. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *vms;

@end


/**
 *  VmwareAdminVCenterConfig contains VCenter configuration for VMware admin
 *  cluster.
 */
@interface GTLRGKEOnPrem_VmwareAdminVCenterConfig : GTLRObject

/** The vCenter IP address. */
@property(nonatomic, copy, nullable) NSString *address;

/** Contains the vCenter CA certificate public key for SSL verification. */
@property(nonatomic, copy, nullable) NSString *caCertData;

/** The name of the vCenter cluster for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *cluster;

/** The name of the vCenter datacenter for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *datacenter;

/** The name of the virtual machine disk (VMDK) for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *dataDisk;

/** The name of the vCenter datastore for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *datastore;

/** The name of the vCenter folder for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *folder;

/** The name of the vCenter resource pool for the admin cluster. */
@property(nonatomic, copy, nullable) NSString *resourcePool;

/** The name of the vCenter storage policy for the user cluster. */
@property(nonatomic, copy, nullable) NSString *storagePolicyName;

@end


/**
 *  VmwareAdminVipConfig for VMware load balancer configurations.
 */
@interface GTLRGKEOnPrem_VmwareAdminVipConfig : GTLRObject

/** The VIP to configure the load balancer for add-ons. */
@property(nonatomic, copy, nullable) NSString *addonsVip;

/**
 *  The VIP which you previously set aside for the Kubernetes API of the admin
 *  cluster.
 */
@property(nonatomic, copy, nullable) NSString *controlPlaneVip;

@end


/**
 *  Specifies config to enable/disable auto repair. The
 *  cluster-health-controller is deployed only if Enabled is true.
 */
@interface GTLRGKEOnPrem_VmwareAutoRepairConfig : GTLRObject

/**
 *  Whether auto repair is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Represents auto resizing configurations for the VMware user cluster.
 */
@interface GTLRGKEOnPrem_VmwareAutoResizeConfig : GTLRObject

/**
 *  Whether to enable controle plane node auto resizing.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  VmwareBundleConfig represents configuration for the bundle.
 */
@interface GTLRGKEOnPrem_VmwareBundleConfig : GTLRObject

/** Output only. Resource status for the bundle. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** The version of the bundle. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Resource that represents a VMware user cluster. ##
 */
@interface GTLRGKEOnPrem_VmwareCluster : GTLRObject

/**
 *  Required. The admin cluster this VMware user cluster belongs to. This is the
 *  full resource name of the admin cluster's fleet membership. In the future,
 *  references to other resource types might be allowed if admin clusters are
 *  modeled as their own resources.
 */
@property(nonatomic, copy, nullable) NSString *adminClusterMembership;

/**
 *  Output only. The resource name of the VMware admin cluster hosting this user
 *  cluster.
 */
@property(nonatomic, copy, nullable) NSString *adminClusterName;

/**
 *  Annotations on the VMware user cluster. This field has the same restrictions
 *  as Kubernetes annotations. The total size of all keys and values combined is
 *  limited to 256k. Key can have 2 segments: prefix (optional) and name
 *  (required), separated by a slash (/). Prefix must be a DNS subdomain. Name
 *  must be 63 characters or less, begin and end with alphanumerics, with dashes
 *  (-), underscores (_), dots (.), and alphanumerics between.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareCluster_Annotations *annotations;

/**
 *  AAGConfig specifies whether to spread VMware user cluster nodes across at
 *  least three physical hosts in the datacenter.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAAGConfig *antiAffinityGroups;

/** RBAC policy that will be applied and managed by the Anthos On-Prem API. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Authorization *authorization;

/** Configuration for auto repairing. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAutoRepairConfig *autoRepairConfig;

/**
 *  VMware user cluster control plane nodes must have either 1 or 3 replicas.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareControlPlaneNodeConfig *controlPlaneNode;

/** Output only. The time at which VMware user cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** VmwareDataplaneV2Config specifies configuration for Dataplane V2. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareDataplaneV2Config *dataplaneV2;

/** Output only. The time at which VMware user cluster was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/**
 *  A human readable description of this VMware user cluster.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Disable bundled ingress.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableBundledIngress;

/**
 *  Enable control plane V2. Default to false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableControlPlaneV2;

/** Output only. The DNS name of VMware user cluster's API server. */
@property(nonatomic, copy, nullable) NSString *endpoint;

/**
 *  This checksum is computed by the server based on the value of other fields,
 *  and may be sent on update and delete requests to ensure the client has an
 *  up-to-date value before proceeding. Allows clients to perform consistent
 *  read-modify-writes through optimistic concurrency control.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Output only. Fleet configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_Fleet *fleet;

/** Load balancer configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareLoadBalancerConfig *loadBalancer;

/**
 *  Output only. The object name of the VMware OnPremUserCluster custom resource
 *  on the associated admin cluster. This field is used to support conflicting
 *  names when enrolling existing clusters to the API. When used as a part of
 *  cluster enrollment, this field will differ from the ID in the resource name.
 *  For new clusters, this field will match the user provided cluster name and
 *  be visible in the last component of the resource name. It is not modifiable.
 *  All users should use this name to access their cluster using gkectl or
 *  kubectl and should expect to see the local name when viewing admin cluster
 *  controller logs.
 */
@property(nonatomic, copy, nullable) NSString *localName;

/** Immutable. The VMware user cluster resource name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The VMware user cluster network configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareNetworkConfig *networkConfig;

/**
 *  Required. The Anthos clusters on the VMware version for your user cluster.
 */
@property(nonatomic, copy, nullable) NSString *onPremVersion;

/**
 *  Output only. If set, there are currently changes in flight to the VMware
 *  user cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  Output only. The current state of VMware user cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_Degraded The DEGRADED state
 *        indicates the cluster requires user action to restore full
 *        functionality. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_Error The ERROR state indicates
 *        the cluster is in a broken unrecoverable state. (Value: "ERROR")
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_Provisioning The PROVISIONING
 *        state indicates the cluster is being created. (Value: "PROVISIONING")
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_Reconciling The RECONCILING
 *        state indicates that the cluster is being updated. It remains
 *        available, but potentially with degraded performance. (Value:
 *        "RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_Running The RUNNING state
 *        indicates the cluster has been created and is fully usable. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_VmwareCluster_State_Stopping The STOPPING state
 *        indicates the cluster is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. ResourceStatus representing detailed cluster state. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** Storage configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareStorageConfig *storage;

/** Output only. The unique identifier of the VMware user cluster. */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time at which VMware user cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Specifies upgrade policy for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareClusterUpgradePolicy *upgradePolicy;

/**
 *  Output only. ValidationCheck represents the result of the preflight check
 *  job.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ValidationCheck *validationCheck;

/**
 *  VmwareVCenterConfig specifies vCenter config for the user cluster. If
 *  unspecified, it is inherited from the admin cluster.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareVCenterConfig *vcenter;

/**
 *  Enable VM tracking.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vmTrackingEnabled;

@end


/**
 *  Annotations on the VMware user cluster. This field has the same restrictions
 *  as Kubernetes annotations. The total size of all keys and values combined is
 *  limited to 256k. Key can have 2 segments: prefix (optional) and name
 *  (required), separated by a slash (/). Prefix must be a DNS subdomain. Name
 *  must be 63 characters or less, begin and end with alphanumerics, with dashes
 *  (-), underscores (_), dots (.), and alphanumerics between.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_VmwareCluster_Annotations : GTLRObject
@end


/**
 *  VmwareClusterUpgradePolicy defines the cluster upgrade policy.
 */
@interface GTLRGKEOnPrem_VmwareClusterUpgradePolicy : GTLRObject

/**
 *  Controls whether the upgrade applies to the control plane only.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controlPlaneOnly;

@end


/**
 *  Specifies control plane node config for the VMware user cluster.
 */
@interface GTLRGKEOnPrem_VmwareControlPlaneNodeConfig : GTLRObject

/** AutoResizeConfig provides auto resizing configurations. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareAutoResizeConfig *autoResizeConfig;

/**
 *  The number of CPUs for each admin cluster node that serve as control planes
 *  for this VMware user cluster. (default: 4 CPUs)
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cpus;

/**
 *  The megabytes of memory for each admin cluster node that serves as a control
 *  plane for this VMware user cluster (default: 8192 MB memory).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memory;

/**
 *  The number of control plane nodes for this VMware user cluster. (default: 1
 *  replica).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicas;

/** Vsphere-specific config. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareControlPlaneVsphereConfig *vsphereConfig;

@end


/**
 *  Specifies control plane V2 config.
 */
@interface GTLRGKEOnPrem_VmwareControlPlaneV2Config : GTLRObject

/** Static IP addresses for the control plane nodes. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareIpBlock *controlPlaneIpBlock;

@end


/**
 *  Specifies control plane node config.
 */
@interface GTLRGKEOnPrem_VmwareControlPlaneVsphereConfig : GTLRObject

/** The Vsphere datastore used by the control plane Node. */
@property(nonatomic, copy, nullable) NSString *datastore;

/** The Vsphere storage policy used by the control plane Node. */
@property(nonatomic, copy, nullable) NSString *storagePolicyName;

@end


/**
 *  Contains configurations for Dataplane V2, which is optimized dataplane for
 *  Kubernetes networking. For more information, see:
 *  https://cloud.google.com/kubernetes-engine/docs/concepts/dataplane-v2
 */
@interface GTLRGKEOnPrem_VmwareDataplaneV2Config : GTLRObject

/**
 *  Enable advanced networking which requires dataplane_v2_enabled to be set
 *  true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *advancedNetworking;

/**
 *  Enables Dataplane V2.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataplaneV2Enabled;

/**
 *  Enable Dataplane V2 for clusters with Windows nodes.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *windowsDataplaneV2Enabled;

@end


/**
 *  Represents the network configuration required for the VMware user clusters
 *  with DHCP IP configurations.
 */
@interface GTLRGKEOnPrem_VmwareDhcpIpConfig : GTLRObject

/**
 *  enabled is a flag to mark if DHCP IP allocation is used for VMware user
 *  clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Represents configuration parameters for an F5 BIG-IP load balancer.
 */
@interface GTLRGKEOnPrem_VmwareF5BigIpConfig : GTLRObject

/** The load balancer's IP address. */
@property(nonatomic, copy, nullable) NSString *address;

/**
 *  The preexisting partition to be used by the load balancer. This partition is
 *  usually created for the admin cluster for example: 'my-f5-admin-partition'.
 */
@property(nonatomic, copy, nullable) NSString *partition;

/** The pool name. Only necessary, if using SNAT. */
@property(nonatomic, copy, nullable) NSString *snatPool;

@end


/**
 *  Represents the common parameters for all the hosts irrespective of their IP
 *  address.
 */
@interface GTLRGKEOnPrem_VmwareHostConfig : GTLRObject

/** DNS search domains. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dnsSearchDomains;

/** DNS servers. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dnsServers;

/** NTP servers. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ntpServers;

@end


/**
 *  Represents VMware user cluster node's network configuration.
 */
@interface GTLRGKEOnPrem_VmwareHostIp : GTLRObject

/** Hostname of the machine. VM's name will be used if this field is empty. */
@property(nonatomic, copy, nullable) NSString *hostname;

/** IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24). */
@property(nonatomic, copy, nullable) NSString *ip;

@end


/**
 *  Represents a collection of IP addresses to assign to nodes.
 */
@interface GTLRGKEOnPrem_VmwareIpBlock : GTLRObject

/** The network gateway used by the VMware user cluster. */
@property(nonatomic, copy, nullable) NSString *gateway;

/** The node's network configurations used by the VMware user cluster. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareHostIp *> *ips;

/** The netmask used by the VMware user cluster. */
@property(nonatomic, copy, nullable) NSString *netmask;

@end


/**
 *  Specifies the locad balancer config for the VMware user cluster.
 */
@interface GTLRGKEOnPrem_VmwareLoadBalancerConfig : GTLRObject

/** Configuration for F5 Big IP typed load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareF5BigIpConfig *f5Config;

/** Manually configured load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareManualLbConfig *manualLbConfig;

/** Configuration for MetalLB typed load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareMetalLbConfig *metalLbConfig;

/** Output only. Configuration for Seesaw typed load balancers. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareSeesawConfig *seesawConfig;

/** The VIPs used by the load balancer. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareVipConfig *vipConfig;

@end


/**
 *  Represents configuration parameters for an already existing manual load
 *  balancer. Given the nature of manual load balancers it is expected that said
 *  load balancer will be fully managed by users. IMPORTANT: Please note that
 *  the Anthos On-Prem API will not generate or update ManualLB configurations
 *  it can only bind a pre-existing configuration to a new VMware user cluster.
 */
@interface GTLRGKEOnPrem_VmwareManualLbConfig : GTLRObject

/**
 *  NodePort for control plane service. The Kubernetes API server in the admin
 *  cluster is implemented as a Service of type NodePort (ex. 30968).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controlPlaneNodePort;

/**
 *  NodePort for ingress service's http. The ingress service in the admin
 *  cluster is implemented as a Service of type NodePort (ex. 32527).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ingressHttpNodePort;

/**
 *  NodePort for ingress service's https. The ingress service in the admin
 *  cluster is implemented as a Service of type NodePort (ex. 30139).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ingressHttpsNodePort;

/**
 *  NodePort for konnectivity server service running as a sidecar in each
 *  kube-apiserver pod (ex. 30564).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *konnectivityServerNodePort;

@end


/**
 *  Represents configuration parameters for the MetalLB load balancer.
 */
@interface GTLRGKEOnPrem_VmwareMetalLbConfig : GTLRObject

/**
 *  Required. AddressPools is a list of non-overlapping IP pools used by load
 *  balancer typed services. All addresses must be routable to load balancer
 *  nodes. IngressVIP must be included in the pools.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareAddressPool *> *addressPools;

@end


/**
 *  Specifies network config for the VMware user cluster.
 */
@interface GTLRGKEOnPrem_VmwareNetworkConfig : GTLRObject

/** Configuration for control plane V2 mode. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareControlPlaneV2Config *controlPlaneV2Config;

/** Configuration settings for a DHCP IP configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareDhcpIpConfig *dhcpIpConfig;

/**
 *  Represents common network settings irrespective of the host's IP address.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareHostConfig *hostConfig;

/**
 *  Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
 *  these ranges. Only a single range is supported. This field cannot be changed
 *  after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *podAddressCidrBlocks;

/**
 *  Required. All services in the cluster are assigned an RFC1918 IPv4 address
 *  from these ranges. Only a single range is supported. This field cannot be
 *  changed after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *serviceAddressCidrBlocks;

/** Configuration settings for a static IP configuration. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareStaticIpConfig *staticIpConfig;

/**
 *  Output only. vcenter_network specifies vCenter network name. Inherited from
 *  the admin cluster.
 */
@property(nonatomic, copy, nullable) NSString *vcenterNetwork;

@end


/**
 *  Parameters that describe the configuration of all nodes within a given node
 *  pool.
 */
@interface GTLRGKEOnPrem_VmwareNodeConfig : GTLRObject

/**
 *  VMware disk size to be used during creation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bootDiskSizeGb;

/**
 *  The number of CPUs for each node in the node pool.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cpus;

/**
 *  Allow node pool traffic to be load balanced. Only works for clusters with
 *  MetalLB load balancers.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableLoadBalancer;

/** The OS image name in vCenter, only valid when using Windows. */
@property(nonatomic, copy, nullable) NSString *image;

/**
 *  Required. The OS image to be used for each node in a node pool. Currently
 *  `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
 */
@property(nonatomic, copy, nullable) NSString *imageType;

/**
 *  The map of Kubernetes labels (key/value pairs) to be applied to each node.
 *  These will added in addition to any default label(s) that Kubernetes may
 *  apply to the node. In case of conflict in label keys, the applied set may
 *  differ depending on the Kubernetes version -- it's best to assume the
 *  behavior is undefined and conflicts should be avoided. For more information,
 *  including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareNodeConfig_Labels *labels;

/**
 *  The megabytes of memory for each node in the node pool.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryMb;

/**
 *  The number of nodes in the node pool.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicas;

/** The initial taints assigned to nodes of this node pool. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_NodeTaint *> *taints;

/** Specifies the vSphere config for node pool. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareVsphereConfig *vsphereConfig;

@end


/**
 *  The map of Kubernetes labels (key/value pairs) to be applied to each node.
 *  These will added in addition to any default label(s) that Kubernetes may
 *  apply to the node. In case of conflict in label keys, the applied set may
 *  differ depending on the Kubernetes version -- it's best to assume the
 *  behavior is undefined and conflicts should be avoided. For more information,
 *  including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_VmwareNodeConfig_Labels : GTLRObject
@end


/**
 *  Resource VmwareNodePool represents a VMware node pool. ##
 */
@interface GTLRGKEOnPrem_VmwareNodePool : GTLRObject

/**
 *  Annotations on the node pool. This field has the same restrictions as
 *  Kubernetes annotations. The total size of all keys and values combined is
 *  limited to 256k. Key can have 2 segments: prefix (optional) and name
 *  (required), separated by a slash (/). Prefix must be a DNS subdomain. Name
 *  must be 63 characters or less, begin and end with alphanumerics, with dashes
 *  (-), underscores (_), dots (.), and alphanumerics between.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareNodePool_Annotations *annotations;

/** Required. The node configuration of the node pool. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareNodeConfig *config;

/** Output only. The time at which this node pool was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The time at which this node pool was deleted. If the resource
 *  is not deleted, this must be empty
 */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** The display name for the node pool. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  This checksum is computed by the server based on the value of other fields,
 *  and may be sent on update and delete requests to ensure the client has an
 *  up-to-date value before proceeding. Allows clients to perform consistent
 *  read-modify-writes through optimistic concurrency control.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Immutable. The resource name of this node pool. */
@property(nonatomic, copy, nullable) NSString *name;

/** Node pool autoscaling config for the node pool. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_VmwareNodePoolAutoscalingConfig *nodePoolAutoscaling;

/** Anthos version for the node pool. Defaults to the user cluster version. */
@property(nonatomic, copy, nullable) NSString *onPremVersion;

/**
 *  Output only. If set, there are currently changes in flight to the node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/**
 *  Output only. The current state of the node pool.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_Degraded The DEGRADED state
 *        indicates the node pool requires user action to restore full
 *        functionality. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_Error The ERROR state
 *        indicates the node pool is in a broken unrecoverable state. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_Provisioning The PROVISIONING
 *        state indicates the node pool is being created. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_Reconciling The RECONCILING
 *        state indicates that the node pool is being updated. It remains
 *        available, but potentially with degraded performance. (Value:
 *        "RECONCILING")
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_Running The RUNNING state
 *        indicates the node pool has been created and is fully usable. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_StateUnspecified Not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEOnPrem_VmwareNodePool_State_Stopping The STOPPING state
 *        indicates the cluster is being deleted (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. ResourceStatus representing the detailed VMware node pool
 *  state.
 */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

/** Output only. The unique identifier of the node pool. */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time at which this node pool was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Annotations on the node pool. This field has the same restrictions as
 *  Kubernetes annotations. The total size of all keys and values combined is
 *  limited to 256k. Key can have 2 segments: prefix (optional) and name
 *  (required), separated by a slash (/). Prefix must be a DNS subdomain. Name
 *  must be 63 characters or less, begin and end with alphanumerics, with dashes
 *  (-), underscores (_), dots (.), and alphanumerics between.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEOnPrem_VmwareNodePool_Annotations : GTLRObject
@end


/**
 *  NodePoolAutoscaling config for the NodePool to allow for the kubernetes to
 *  scale NodePool.
 */
@interface GTLRGKEOnPrem_VmwareNodePoolAutoscalingConfig : GTLRObject

/**
 *  Maximum number of replicas in the NodePool.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxReplicas;

/**
 *  Minimum number of replicas in the NodePool.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minReplicas;

@end


/**
 *  VmwarePlatformConfig represents configuration for the VMware platform.
 */
@interface GTLRGKEOnPrem_VmwarePlatformConfig : GTLRObject

/** Output only. The list of bundles installed in the admin cluster. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareBundleConfig *> *bundles;

/** Output only. The platform version e.g. 1.13.2. */
@property(nonatomic, copy, nullable) NSString *platformVersion;

/**
 *  Input only. The required platform version e.g. 1.13.1. If the current
 *  platform version is lower than the target version, the platform version will
 *  be updated to the target version. If the target version is not installed in
 *  the platform (bundle versions), download the target version bundle.
 */
@property(nonatomic, copy, nullable) NSString *requiredPlatformVersion;

/** Output only. Resource status for the platform. */
@property(nonatomic, strong, nullable) GTLRGKEOnPrem_ResourceStatus *status;

@end


/**
 *  VmwareSeesawConfig represents configuration parameters for an already
 *  existing Seesaw load balancer. IMPORTANT: Please note that the Anthos
 *  On-Prem API will not generate or update Seesaw configurations it can only
 *  bind a pre-existing configuration to a new user cluster. IMPORTANT: When
 *  attempting to create a user cluster with a pre-existing Seesaw load balancer
 *  you will need to follow some preparation steps before calling the
 *  'CreateVmwareCluster' API method. First you will need to create the user
 *  cluster's namespace via kubectl. The namespace will need to use the
 *  following naming convention : -gke-onprem-mgmt or -gke-onprem-mgmt depending
 *  on whether you used the 'VmwareCluster.local_name' to disambiguate
 *  collisions; for more context see the documentation of
 *  'VmwareCluster.local_name'. Once the namespace is created you will need to
 *  create a secret resource via kubectl. This secret will contain copies of
 *  your Seesaw credentials. The Secret must be called 'user-cluster-creds' and
 *  contain Seesaw's SSH and Cert credentials. The credentials must be keyed
 *  with the following names: 'seesaw-ssh-private-key', 'seesaw-ssh-public-key',
 *  'seesaw-ssh-ca-key', 'seesaw-ssh-ca-cert'.
 */
@interface GTLRGKEOnPrem_VmwareSeesawConfig : GTLRObject

/**
 *  Enable two load balancer VMs to achieve a highly-available Seesaw load
 *  balancer.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableHa;

/**
 *  Required. In general the following format should be used for the Seesaw
 *  group name: seesaw-for-[cluster_name].
 */
@property(nonatomic, copy, nullable) NSString *group;

/** Required. The IP Blocks to be used by the Seesaw load balancer */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareIpBlock *> *ipBlocks;

/** Required. MasterIP is the IP announced by the master of Seesaw group. */
@property(nonatomic, copy, nullable) NSString *masterIp;

/** Name to be used by Stackdriver. */
@property(nonatomic, copy, nullable) NSString *stackdriverName;

/** Names of the VMs created for this Seesaw group. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *vms;

@end


/**
 *  Represents the network configuration required for the VMware user clusters
 *  with Static IP configurations.
 */
@interface GTLRGKEOnPrem_VmwareStaticIpConfig : GTLRObject

/** Represents the configuration values for static IP allocation to nodes. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareIpBlock *> *ipBlocks;

@end


/**
 *  Specifies vSphere CSI components deployment config in the VMware user
 *  cluster.
 */
@interface GTLRGKEOnPrem_VmwareStorageConfig : GTLRObject

/**
 *  Whether or not to deploy vSphere CSI components in the VMware user cluster.
 *  Enabled by default.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vsphereCsiDisabled;

@end


/**
 *  Represents configuration for the VMware VCenter for the user cluster.
 */
@interface GTLRGKEOnPrem_VmwareVCenterConfig : GTLRObject

/** Output only. The vCenter IP address. */
@property(nonatomic, copy, nullable) NSString *address;

/** Contains the vCenter CA certificate public key for SSL verification. */
@property(nonatomic, copy, nullable) NSString *caCertData;

/** The name of the vCenter cluster for the user cluster. */
@property(nonatomic, copy, nullable) NSString *cluster;

/** The name of the vCenter datacenter for the user cluster. */
@property(nonatomic, copy, nullable) NSString *datacenter;

/** The name of the vCenter datastore for the user cluster. */
@property(nonatomic, copy, nullable) NSString *datastore;

/** The name of the vCenter folder for the user cluster. */
@property(nonatomic, copy, nullable) NSString *folder;

/** The name of the vCenter resource pool for the user cluster. */
@property(nonatomic, copy, nullable) NSString *resourcePool;

/** The name of the vCenter storage policy for the user cluster. */
@property(nonatomic, copy, nullable) NSString *storagePolicyName;

@end


/**
 *  Contains information about a specific Anthos on VMware version.
 */
@interface GTLRGKEOnPrem_VmwareVersionInfo : GTLRObject

/** The list of upgrade dependencies for this version. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_UpgradeDependency *> *dependencies;

/**
 *  If set, the cluster dependencies (e.g. the admin cluster, other user
 *  clusters managed by the same admin cluster) must be upgraded before this
 *  version can be installed or upgraded to.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasDependencies;

/**
 *  If set, the version is installed in the admin cluster. Otherwise, the
 *  version bundle must be downloaded and installed before a user cluster can be
 *  created at or upgraded to this version.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isInstalled;

/** Version number e.g. 1.13.1-gke.1000. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Specifies the VIP config for the VMware user cluster load balancer.
 */
@interface GTLRGKEOnPrem_VmwareVipConfig : GTLRObject

/**
 *  The VIP which you previously set aside for the Kubernetes API of this
 *  cluster.
 */
@property(nonatomic, copy, nullable) NSString *controlPlaneVip;

/**
 *  The VIP which you previously set aside for ingress traffic into this
 *  cluster.
 */
@property(nonatomic, copy, nullable) NSString *ingressVip;

@end


/**
 *  VmwareVsphereConfig represents configuration for the VMware VCenter for node
 *  pool.
 */
@interface GTLRGKEOnPrem_VmwareVsphereConfig : GTLRObject

/** The name of the vCenter datastore. Inherited from the user cluster. */
@property(nonatomic, copy, nullable) NSString *datastore;

/** Vsphere host groups to apply to all VMs in the node pool */
@property(nonatomic, strong, nullable) NSArray<NSString *> *hostGroups;

/** Tags to apply to VMs. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEOnPrem_VmwareVsphereTag *> *tags;

@end


/**
 *  VmwareVsphereTag describes a vSphere tag to be placed on VMs in the node
 *  pool. For more information, see
 *  https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vcenterhost.doc/GUID-E8E854DD-AA97-4E0C-8419-CE84F93C4058.html
 */
@interface GTLRGKEOnPrem_VmwareVsphereTag : GTLRObject

/** The Vsphere tag category. */
@property(nonatomic, copy, nullable) NSString *category;

/** The Vsphere tag name. */
@property(nonatomic, copy, nullable) NSString *tag;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
