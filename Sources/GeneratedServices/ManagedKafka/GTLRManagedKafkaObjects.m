// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Managed Service for Apache Kafka API (managedkafka/v1)
// Description:
//   Manage Apache Kafka clusters and resources.
// Documentation:
//   https://cloud.google.com/managed-service-for-apache-kafka/docs

#import <GoogleAPIClientForREST/GTLRManagedKafkaObjects.h>

// ----------------------------------------------------------------------------
// Constants

// GTLRManagedKafka_CheckCompatibilityRequest.schemaType
NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Avro = @"AVRO";
NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Json = @"JSON";
NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Protobuf = @"PROTOBUF";
NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_SchemaTypeUnspecified = @"SCHEMA_TYPE_UNSPECIFIED";

// GTLRManagedKafka_Cluster.state
NSString * const kGTLRManagedKafka_Cluster_State_Active        = @"ACTIVE";
NSString * const kGTLRManagedKafka_Cluster_State_Creating      = @"CREATING";
NSString * const kGTLRManagedKafka_Cluster_State_Deleting      = @"DELETING";
NSString * const kGTLRManagedKafka_Cluster_State_StateUnspecified = @"STATE_UNSPECIFIED";

// GTLRManagedKafka_ConnectCluster.state
NSString * const kGTLRManagedKafka_ConnectCluster_State_Active = @"ACTIVE";
NSString * const kGTLRManagedKafka_ConnectCluster_State_Creating = @"CREATING";
NSString * const kGTLRManagedKafka_ConnectCluster_State_Deleting = @"DELETING";
NSString * const kGTLRManagedKafka_ConnectCluster_State_StateUnspecified = @"STATE_UNSPECIFIED";

// GTLRManagedKafka_Connector.state
NSString * const kGTLRManagedKafka_Connector_State_Failed      = @"FAILED";
NSString * const kGTLRManagedKafka_Connector_State_Paused      = @"PAUSED";
NSString * const kGTLRManagedKafka_Connector_State_Restarting  = @"RESTARTING";
NSString * const kGTLRManagedKafka_Connector_State_Running     = @"RUNNING";
NSString * const kGTLRManagedKafka_Connector_State_StateUnspecified = @"STATE_UNSPECIFIED";
NSString * const kGTLRManagedKafka_Connector_State_Stopped     = @"STOPPED";
NSString * const kGTLRManagedKafka_Connector_State_Unassigned  = @"UNASSIGNED";

// GTLRManagedKafka_CreateVersionRequest.schemaType
NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_Avro = @"AVRO";
NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_Json = @"JSON";
NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_Protobuf = @"PROTOBUF";
NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_SchemaTypeUnspecified = @"SCHEMA_TYPE_UNSPECIFIED";

// GTLRManagedKafka_LookupVersionRequest.schemaType
NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_Avro = @"AVRO";
NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_Json = @"JSON";
NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_Protobuf = @"PROTOBUF";
NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_SchemaTypeUnspecified = @"SCHEMA_TYPE_UNSPECIFIED";

// GTLRManagedKafka_RebalanceConfig.mode
NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_AutoRebalanceOnScaleUp = @"AUTO_REBALANCE_ON_SCALE_UP";
NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_ModeUnspecified = @"MODE_UNSPECIFIED";
NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_NoRebalance = @"NO_REBALANCE";

// GTLRManagedKafka_Schema.schemaType
NSString * const kGTLRManagedKafka_Schema_SchemaType_Avro      = @"AVRO";
NSString * const kGTLRManagedKafka_Schema_SchemaType_Json      = @"JSON";
NSString * const kGTLRManagedKafka_Schema_SchemaType_Protobuf  = @"PROTOBUF";
NSString * const kGTLRManagedKafka_Schema_SchemaType_SchemaTypeUnspecified = @"SCHEMA_TYPE_UNSPECIFIED";

// GTLRManagedKafka_SchemaConfig.compatibility
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_Backward = @"BACKWARD";
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_BackwardTransitive = @"BACKWARD_TRANSITIVE";
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_Forward = @"FORWARD";
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_ForwardTransitive = @"FORWARD_TRANSITIVE";
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_Full = @"FULL";
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_FullTransitive = @"FULL_TRANSITIVE";
NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_None = @"NONE";

// GTLRManagedKafka_SchemaMode.mode
NSString * const kGTLRManagedKafka_SchemaMode_Mode_Import    = @"IMPORT";
NSString * const kGTLRManagedKafka_SchemaMode_Mode_None      = @"NONE";
NSString * const kGTLRManagedKafka_SchemaMode_Mode_Readonly  = @"READONLY";
NSString * const kGTLRManagedKafka_SchemaMode_Mode_Readwrite = @"READWRITE";

// GTLRManagedKafka_SchemaVersion.schemaType
NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_Avro = @"AVRO";
NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_Json = @"JSON";
NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_Protobuf = @"PROTOBUF";
NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_SchemaTypeUnspecified = @"SCHEMA_TYPE_UNSPECIFIED";

// GTLRManagedKafka_UpdateSchemaConfigRequest.compatibility
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Backward = @"BACKWARD";
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_BackwardTransitive = @"BACKWARD_TRANSITIVE";
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Forward = @"FORWARD";
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_ForwardTransitive = @"FORWARD_TRANSITIVE";
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Full = @"FULL";
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_FullTransitive = @"FULL_TRANSITIVE";
NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_None = @"NONE";

// GTLRManagedKafka_UpdateSchemaModeRequest.mode
NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Import = @"IMPORT";
NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_None = @"NONE";
NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Readonly = @"READONLY";
NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Readwrite = @"READWRITE";

// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_AccessConfig
//

@implementation GTLRManagedKafka_AccessConfig
@dynamic networkConfigs;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"networkConfigs" : [GTLRManagedKafka_NetworkConfig class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Acl
//

@implementation GTLRManagedKafka_Acl
@dynamic aclEntries, ETag, name, patternType, resourceName, resourceType;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"ETag" : @"etag" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"aclEntries" : [GTLRManagedKafka_AclEntry class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_AclEntry
//

@implementation GTLRManagedKafka_AclEntry
@dynamic host, operation, permissionType, principal;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_AddAclEntryResponse
//

@implementation GTLRManagedKafka_AddAclEntryResponse
@dynamic acl, aclCreated;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CancelOperationRequest
//

@implementation GTLRManagedKafka_CancelOperationRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CapacityConfig
//

@implementation GTLRManagedKafka_CapacityConfig
@dynamic memoryBytes, vcpuCount;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CertificateAuthorityServiceConfig
//

@implementation GTLRManagedKafka_CertificateAuthorityServiceConfig
@dynamic caPool;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CheckCompatibilityRequest
//

@implementation GTLRManagedKafka_CheckCompatibilityRequest
@dynamic references, schema, schemaType, verbose;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"references" : [GTLRManagedKafka_SchemaReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CheckCompatibilityResponse
//

@implementation GTLRManagedKafka_CheckCompatibilityResponse
@dynamic isCompatible, messages;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"isCompatible" : @"is_compatible" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"messages" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Cluster
//

@implementation GTLRManagedKafka_Cluster
@dynamic capacityConfig, createTime, gcpConfig, labels, name, rebalanceConfig,
         satisfiesPzi, satisfiesPzs, state, tlsConfig, updateOptions,
         updateTime;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Cluster_Labels
//

@implementation GTLRManagedKafka_Cluster_Labels

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConnectAccessConfig
//

@implementation GTLRManagedKafka_ConnectAccessConfig
@dynamic networkConfigs;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"networkConfigs" : [GTLRManagedKafka_ConnectNetworkConfig class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConnectCluster
//

@implementation GTLRManagedKafka_ConnectCluster
@dynamic capacityConfig, config, createTime, gcpConfig, kafkaCluster, labels,
         name, satisfiesPzi, satisfiesPzs, state, updateTime;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConnectCluster_Config
//

@implementation GTLRManagedKafka_ConnectCluster_Config

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConnectCluster_Labels
//

@implementation GTLRManagedKafka_ConnectCluster_Labels

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConnectGcpConfig
//

@implementation GTLRManagedKafka_ConnectGcpConfig
@dynamic accessConfig, secretPaths;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"secretPaths" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConnectNetworkConfig
//

@implementation GTLRManagedKafka_ConnectNetworkConfig
@dynamic additionalSubnets, dnsDomainNames, primarySubnet;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"additionalSubnets" : [NSString class],
    @"dnsDomainNames" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Connector
//

@implementation GTLRManagedKafka_Connector
@dynamic configs, name, state, taskRestartPolicy;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Connector_Configs
//

@implementation GTLRManagedKafka_Connector_Configs

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConsumerGroup
//

@implementation GTLRManagedKafka_ConsumerGroup
@dynamic name, topics;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConsumerGroup_Topics
//

@implementation GTLRManagedKafka_ConsumerGroup_Topics

+ (Class)classForAdditionalProperties {
  return [GTLRManagedKafka_ConsumerTopicMetadata class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConsumerPartitionMetadata
//

@implementation GTLRManagedKafka_ConsumerPartitionMetadata
@dynamic metadata, offset;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConsumerTopicMetadata
//

@implementation GTLRManagedKafka_ConsumerTopicMetadata
@dynamic partitions;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ConsumerTopicMetadata_Partitions
//

@implementation GTLRManagedKafka_ConsumerTopicMetadata_Partitions

+ (Class)classForAdditionalProperties {
  return [GTLRManagedKafka_ConsumerPartitionMetadata class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Context
//

@implementation GTLRManagedKafka_Context
@dynamic name, subjects;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"subjects" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CreateSchemaRegistryRequest
//

@implementation GTLRManagedKafka_CreateSchemaRegistryRequest
@dynamic schemaRegistry, schemaRegistryId;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CreateVersionRequest
//

@implementation GTLRManagedKafka_CreateVersionRequest
@dynamic identifier, normalize, references, schema, schemaType, version;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"references" : [GTLRManagedKafka_SchemaReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_CreateVersionResponse
//

@implementation GTLRManagedKafka_CreateVersionResponse
@dynamic identifier;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Empty
//

@implementation GTLRManagedKafka_Empty
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_GcpConfig
//

@implementation GTLRManagedKafka_GcpConfig
@dynamic accessConfig, kmsKey;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_HttpBody
//

@implementation GTLRManagedKafka_HttpBody
@dynamic contentType, data, extensions;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"extensions" : [GTLRManagedKafka_HttpBody_Extensions_Item class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_HttpBody_Extensions_Item
//

@implementation GTLRManagedKafka_HttpBody_Extensions_Item

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListAclsResponse
//

@implementation GTLRManagedKafka_ListAclsResponse
@dynamic acls, nextPageToken;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"acls" : [GTLRManagedKafka_Acl class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"acls";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListClustersResponse
//

@implementation GTLRManagedKafka_ListClustersResponse
@dynamic clusters, nextPageToken, unreachable;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"clusters" : [GTLRManagedKafka_Cluster class],
    @"unreachable" : [NSString class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"clusters";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListConnectClustersResponse
//

@implementation GTLRManagedKafka_ListConnectClustersResponse
@dynamic connectClusters, nextPageToken, unreachable;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"connectClusters" : [GTLRManagedKafka_ConnectCluster class],
    @"unreachable" : [NSString class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"connectClusters";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListConnectorsResponse
//

@implementation GTLRManagedKafka_ListConnectorsResponse
@dynamic connectors, nextPageToken;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"connectors" : [GTLRManagedKafka_Connector class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"connectors";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListConsumerGroupsResponse
//

@implementation GTLRManagedKafka_ListConsumerGroupsResponse
@dynamic consumerGroups, nextPageToken;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"consumerGroups" : [GTLRManagedKafka_ConsumerGroup class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"consumerGroups";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListLocationsResponse
//

@implementation GTLRManagedKafka_ListLocationsResponse
@dynamic locations, nextPageToken;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"locations" : [GTLRManagedKafka_Location class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"locations";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListOperationsResponse
//

@implementation GTLRManagedKafka_ListOperationsResponse
@dynamic nextPageToken, operations;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"operations" : [GTLRManagedKafka_Operation class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"operations";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListSchemaRegistriesResponse
//

@implementation GTLRManagedKafka_ListSchemaRegistriesResponse
@dynamic schemaRegistries;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"schemaRegistries" : [GTLRManagedKafka_SchemaRegistry class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ListTopicsResponse
//

@implementation GTLRManagedKafka_ListTopicsResponse
@dynamic nextPageToken, topics;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"topics" : [GTLRManagedKafka_Topic class]
  };
  return map;
}

+ (NSString *)collectionItemsKey {
  return @"topics";
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Location
//

@implementation GTLRManagedKafka_Location
@dynamic displayName, labels, locationId, metadata, name;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Location_Labels
//

@implementation GTLRManagedKafka_Location_Labels

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Location_Metadata
//

@implementation GTLRManagedKafka_Location_Metadata

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_LookupVersionRequest
//

@implementation GTLRManagedKafka_LookupVersionRequest
@dynamic deleted, normalize, references, schema, schemaType;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"references" : [GTLRManagedKafka_SchemaReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_NetworkConfig
//

@implementation GTLRManagedKafka_NetworkConfig
@dynamic subnet;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Operation
//

@implementation GTLRManagedKafka_Operation
@dynamic done, error, metadata, name, response;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Operation_Metadata
//

@implementation GTLRManagedKafka_Operation_Metadata

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Operation_Response
//

@implementation GTLRManagedKafka_Operation_Response

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_OperationMetadata
//

@implementation GTLRManagedKafka_OperationMetadata
@dynamic apiVersion, createTime, endTime, requestedCancellation, statusMessage,
         target, verb;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_PauseConnectorRequest
//

@implementation GTLRManagedKafka_PauseConnectorRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_PauseConnectorResponse
//

@implementation GTLRManagedKafka_PauseConnectorResponse
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_RebalanceConfig
//

@implementation GTLRManagedKafka_RebalanceConfig
@dynamic mode;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_RemoveAclEntryResponse
//

@implementation GTLRManagedKafka_RemoveAclEntryResponse
@dynamic acl, aclDeleted;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_RestartConnectorRequest
//

@implementation GTLRManagedKafka_RestartConnectorRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_RestartConnectorResponse
//

@implementation GTLRManagedKafka_RestartConnectorResponse
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ResumeConnectorRequest
//

@implementation GTLRManagedKafka_ResumeConnectorRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_ResumeConnectorResponse
//

@implementation GTLRManagedKafka_ResumeConnectorResponse
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Schema
//

@implementation GTLRManagedKafka_Schema
@dynamic references, schema, schemaType;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"references" : [GTLRManagedKafka_SchemaReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_SchemaConfig
//

@implementation GTLRManagedKafka_SchemaConfig
@dynamic alias, compatibility, normalize;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_SchemaMode
//

@implementation GTLRManagedKafka_SchemaMode
@dynamic mode;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_SchemaReference
//

@implementation GTLRManagedKafka_SchemaReference
@dynamic name, subject, version;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_SchemaRegistry
//

@implementation GTLRManagedKafka_SchemaRegistry
@dynamic contexts, name;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"contexts" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_SchemaVersion
//

@implementation GTLRManagedKafka_SchemaVersion
@dynamic identifier, references, schema, schemaType, subject, version;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"references" : [GTLRManagedKafka_SchemaReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Status
//

@implementation GTLRManagedKafka_Status
@dynamic code, details, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"details" : [GTLRManagedKafka_Status_Details_Item class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Status_Details_Item
//

@implementation GTLRManagedKafka_Status_Details_Item

+ (Class)classForAdditionalProperties {
  return [NSObject class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_StopConnectorRequest
//

@implementation GTLRManagedKafka_StopConnectorRequest
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_StopConnectorResponse
//

@implementation GTLRManagedKafka_StopConnectorResponse
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_TaskRetryPolicy
//

@implementation GTLRManagedKafka_TaskRetryPolicy
@dynamic maximumBackoff, minimumBackoff;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_TlsConfig
//

@implementation GTLRManagedKafka_TlsConfig
@dynamic sslPrincipalMappingRules, trustConfig;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Topic
//

@implementation GTLRManagedKafka_Topic
@dynamic configs, name, partitionCount, replicationFactor;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_Topic_Configs
//

@implementation GTLRManagedKafka_Topic_Configs

+ (Class)classForAdditionalProperties {
  return [NSString class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_TrustConfig
//

@implementation GTLRManagedKafka_TrustConfig
@dynamic casConfigs;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"casConfigs" : [GTLRManagedKafka_CertificateAuthorityServiceConfig class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_UpdateOptions
//

@implementation GTLRManagedKafka_UpdateOptions
@dynamic allowBrokerDownscaleOnClusterUpscale;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_UpdateSchemaConfigRequest
//

@implementation GTLRManagedKafka_UpdateSchemaConfigRequest
@dynamic compatibility, normalize;
@end


// ----------------------------------------------------------------------------
//
//   GTLRManagedKafka_UpdateSchemaModeRequest
//

@implementation GTLRManagedKafka_UpdateSchemaModeRequest
@dynamic mode;
@end
