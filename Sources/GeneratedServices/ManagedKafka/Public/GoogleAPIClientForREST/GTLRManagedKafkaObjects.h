// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Managed Service for Apache Kafka API (managedkafka/v1)
// Description:
//   Manage Apache Kafka clusters and resources.
// Documentation:
//   https://cloud.google.com/managed-service-for-apache-kafka/docs

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRManagedKafka_AccessConfig;
@class GTLRManagedKafka_Acl;
@class GTLRManagedKafka_AclEntry;
@class GTLRManagedKafka_CapacityConfig;
@class GTLRManagedKafka_Cluster;
@class GTLRManagedKafka_Cluster_Labels;
@class GTLRManagedKafka_ConnectAccessConfig;
@class GTLRManagedKafka_ConnectCluster;
@class GTLRManagedKafka_ConnectCluster_Config;
@class GTLRManagedKafka_ConnectCluster_Labels;
@class GTLRManagedKafka_ConnectGcpConfig;
@class GTLRManagedKafka_ConnectNetworkConfig;
@class GTLRManagedKafka_Connector;
@class GTLRManagedKafka_Connector_Configs;
@class GTLRManagedKafka_ConsumerGroup;
@class GTLRManagedKafka_ConsumerGroup_Topics;
@class GTLRManagedKafka_ConsumerPartitionMetadata;
@class GTLRManagedKafka_ConsumerTopicMetadata;
@class GTLRManagedKafka_ConsumerTopicMetadata_Partitions;
@class GTLRManagedKafka_GcpConfig;
@class GTLRManagedKafka_HttpBody_Extensions_Item;
@class GTLRManagedKafka_Location;
@class GTLRManagedKafka_Location_Labels;
@class GTLRManagedKafka_Location_Metadata;
@class GTLRManagedKafka_NetworkConfig;
@class GTLRManagedKafka_Operation;
@class GTLRManagedKafka_Operation_Metadata;
@class GTLRManagedKafka_Operation_Response;
@class GTLRManagedKafka_RebalanceConfig;
@class GTLRManagedKafka_SchemaReference;
@class GTLRManagedKafka_SchemaRegistry;
@class GTLRManagedKafka_Status;
@class GTLRManagedKafka_Status_Details_Item;
@class GTLRManagedKafka_TaskRetryPolicy;
@class GTLRManagedKafka_Topic;
@class GTLRManagedKafka_Topic_Configs;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRManagedKafka_CheckCompatibilityRequest.schemaType

/**
 *  Avro schema type.
 *
 *  Value: "AVRO"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Avro;
/**
 *  JSON schema type.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Json;
/**
 *  Protobuf schema type.
 *
 *  Value: "PROTOBUF"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Protobuf;
/**
 *  No schema type. The default will be AVRO.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_SchemaTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_Cluster.state

/**
 *  The cluster is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_Active;
/**
 *  The cluster is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_Creating;
/**
 *  The cluster is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_Deleting;
/**
 *  A state was not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_ConnectCluster.state

/**
 *  The cluster is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_Active;
/**
 *  The cluster is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_Creating;
/**
 *  The cluster is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_Deleting;
/**
 *  A state was not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_Connector.state

/**
 *  The connector has failed. See logs for why.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Failed;
/**
 *  The connector has been paused.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Paused;
/**
 *  The connector is restarting.
 *
 *  Value: "RESTARTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Restarting;
/**
 *  The connector is running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Running;
/**
 *  A state was not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_StateUnspecified;
/**
 *  The connector has been stopped.
 *
 *  Value: "STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Stopped;
/**
 *  The connector is not assigned to any tasks, usually transient.
 *
 *  Value: "UNASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Unassigned;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_CreateVersionRequest.schemaType

/**
 *  Avro schema type.
 *
 *  Value: "AVRO"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_Avro;
/**
 *  JSON schema type.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_Json;
/**
 *  Protobuf schema type.
 *
 *  Value: "PROTOBUF"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_Protobuf;
/**
 *  No schema type. The default will be AVRO.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_CreateVersionRequest_SchemaType_SchemaTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_LookupVersionRequest.schemaType

/**
 *  Avro schema type.
 *
 *  Value: "AVRO"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_Avro;
/**
 *  JSON schema type.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_Json;
/**
 *  Protobuf schema type.
 *
 *  Value: "PROTOBUF"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_Protobuf;
/**
 *  No schema type. The default will be AVRO.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_LookupVersionRequest_SchemaType_SchemaTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_RebalanceConfig.mode

/**
 *  Automatically rebalance topic partitions among brokers when the cluster is
 *  scaled up.
 *
 *  Value: "AUTO_REBALANCE_ON_SCALE_UP"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_AutoRebalanceOnScaleUp;
/**
 *  A mode was not specified. Do not use.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_ModeUnspecified;
/**
 *  Do not rebalance automatically.
 *
 *  Value: "NO_REBALANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_NoRebalance;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_Schema.schemaType

/**
 *  Avro schema type.
 *
 *  Value: "AVRO"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Schema_SchemaType_Avro;
/**
 *  JSON schema type.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Schema_SchemaType_Json;
/**
 *  Protobuf schema type.
 *
 *  Value: "PROTOBUF"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Schema_SchemaType_Protobuf;
/**
 *  No schema type. The default will be AVRO.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Schema_SchemaType_SchemaTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_SchemaConfig.compatibility

/**
 *  Backwards compatible with the most recent version.
 *
 *  Value: "BACKWARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_Backward;
/**
 *  Backwards compatible with all previous versions.
 *
 *  Value: "BACKWARD_TRANSITIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_BackwardTransitive;
/**
 *  Forwards compatible with the most recent version.
 *
 *  Value: "FORWARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_Forward;
/**
 *  Forwards compatible with all previous versions.
 *
 *  Value: "FORWARD_TRANSITIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_ForwardTransitive;
/**
 *  Backwards and forwards compatible with the most recent version.
 *
 *  Value: "FULL"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_Full;
/**
 *  Backwards and forwards compatible with all previous versions.
 *
 *  Value: "FULL_TRANSITIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_FullTransitive;
/**
 *  No compatibility check.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaConfig_Compatibility_None;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_SchemaMode.mode

/**
 *  IMPORT mode.
 *
 *  Value: "IMPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaMode_Mode_Import;
/**
 *  No mode.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaMode_Mode_None;
/**
 *  READONLY mode.
 *
 *  Value: "READONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaMode_Mode_Readonly;
/**
 *  READWRITE mode.
 *
 *  Value: "READWRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaMode_Mode_Readwrite;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_SchemaVersion.schemaType

/**
 *  Avro schema type.
 *
 *  Value: "AVRO"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_Avro;
/**
 *  JSON schema type.
 *
 *  Value: "JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_Json;
/**
 *  Protobuf schema type.
 *
 *  Value: "PROTOBUF"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_Protobuf;
/**
 *  No schema type. The default will be AVRO.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_SchemaVersion_SchemaType_SchemaTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_UpdateSchemaConfigRequest.compatibility

/**
 *  Backwards compatible with the most recent version.
 *
 *  Value: "BACKWARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Backward;
/**
 *  Backwards compatible with all previous versions.
 *
 *  Value: "BACKWARD_TRANSITIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_BackwardTransitive;
/**
 *  Forwards compatible with the most recent version.
 *
 *  Value: "FORWARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Forward;
/**
 *  Forwards compatible with all previous versions.
 *
 *  Value: "FORWARD_TRANSITIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_ForwardTransitive;
/**
 *  Backwards and forwards compatible with the most recent version.
 *
 *  Value: "FULL"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Full;
/**
 *  Backwards and forwards compatible with all previous versions.
 *
 *  Value: "FULL_TRANSITIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_FullTransitive;
/**
 *  No compatibility check.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_None;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_UpdateSchemaModeRequest.mode

/**
 *  IMPORT mode.
 *
 *  Value: "IMPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Import;
/**
 *  No mode.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_None;
/**
 *  READONLY mode.
 *
 *  Value: "READONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Readonly;
/**
 *  READWRITE mode.
 *
 *  Value: "READWRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Readwrite;

/**
 *  The configuration of access to the Kafka cluster.
 */
@interface GTLRManagedKafka_AccessConfig : GTLRObject

/**
 *  Required. Virtual Private Cloud (VPC) networks that must be granted direct
 *  access to the Kafka cluster. Minimum of 1 network is required. Maximum 10
 *  networks can be specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_NetworkConfig *> *networkConfigs;

@end


/**
 *  Represents the set of ACLs for a given Kafka Resource Pattern, which
 *  consists of resource_type, resource_name and pattern_type.
 */
@interface GTLRManagedKafka_Acl : GTLRObject

/**
 *  Required. The ACL entries that apply to the resource pattern. The maximum
 *  number of allowed entries 100.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_AclEntry *> *aclEntries;

/**
 *  Optional. `etag` is used for concurrency control. An `etag` is returned in
 *  the response to `GetAcl` and `CreateAcl`. Callers are required to put that
 *  etag in the request to `UpdateAcl` to ensure that their change will be
 *  applied to the same version of the acl that exists in the Kafka Cluster. A
 *  terminal 'T' character in the etag indicates that the AclEntries were
 *  truncated; more entries for the Acl exist on the Kafka Cluster, but can't be
 *  returned in the Acl due to repeated field limits.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Identifier. The name for the acl. Represents a single Resource Pattern.
 *  Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
 *  structure of `acl_id` defines the Resource Pattern (resource_type,
 *  resource_name, pattern_type) of the acl. `acl_id` is structured like one of
 *  the following: For acls on the cluster: `cluster` For acls on a single
 *  resource within the cluster: `topic/{resource_name}`
 *  `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls
 *  on all resources that match a prefix: `topicPrefixed/{resource_name}`
 *  `consumerGroupPrefixed/{resource_name}`
 *  `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
 *  given type (i.e. the wildcard literal "*"): `allTopics` (represents `topic/
 *  *`) `allConsumerGroups` (represents `consumerGroup/ *`)
 *  `allTransactionalIds` (represents `transactionalId/ *`)
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The ACL pattern type derived from the name. One of: LITERAL,
 *  PREFIXED.
 */
@property(nonatomic, copy, nullable) NSString *patternType;

/**
 *  Output only. The ACL resource name derived from the name. For cluster
 *  resource_type, this is always "kafka-cluster". Can be the wildcard literal
 *  "*".
 */
@property(nonatomic, copy, nullable) NSString *resourceName;

/**
 *  Output only. The ACL resource type derived from the name. One of: CLUSTER,
 *  TOPIC, GROUP, TRANSACTIONAL_ID.
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  Represents the access granted for a given Resource Pattern in an ACL.
 */
@interface GTLRManagedKafka_AclEntry : GTLRObject

/**
 *  Required. The host. Must be set to "*" for Managed Service for Apache Kafka.
 */
@property(nonatomic, copy, nullable) NSString *host;

/**
 *  Required. The operation type. Allowed values are (case insensitive): ALL,
 *  READ, WRITE, CREATE, DELETE, ALTER, DESCRIBE, CLUSTER_ACTION,
 *  DESCRIBE_CONFIGS, ALTER_CONFIGS, and IDEMPOTENT_WRITE. See
 *  https://kafka.apache.org/documentation/#operations_resources_and_protocols
 *  for valid combinations of resource_type and operation for different Kafka
 *  API requests.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/**
 *  Required. The permission type. Accepted values are (case insensitive):
 *  ALLOW, DENY.
 */
@property(nonatomic, copy, nullable) NSString *permissionType;

/**
 *  Required. The principal. Specified as Google Cloud account, with the Kafka
 *  StandardAuthorizer prefix "User:". For example:
 *  "User:test-kafka-client\@test-project.iam.gserviceaccount.com". Can be the
 *  wildcard "User:*" to refer to all users.
 */
@property(nonatomic, copy, nullable) NSString *principal;

@end


/**
 *  Response for AddAclEntry.
 */
@interface GTLRManagedKafka_AddAclEntryResponse : GTLRObject

/** The updated acl. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Acl *acl;

/**
 *  Whether the acl was created as a result of adding the acl entry.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aclCreated;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRManagedKafka_CancelOperationRequest : GTLRObject
@end


/**
 *  A capacity configuration of a Kafka cluster.
 */
@interface GTLRManagedKafka_CapacityConfig : GTLRObject

/**
 *  Required. The memory to provision for the cluster in bytes. The CPU:memory
 *  ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryBytes;

/**
 *  Required. The number of vCPUs to provision for the cluster. Minimum: 3.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vcpuCount;

@end


/**
 *  Request for CheckCompatibility.
 */
@interface GTLRManagedKafka_CheckCompatibilityRequest : GTLRObject

/** Optional. The schema references used by the schema. */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_SchemaReference *> *references;

/** Required. The schema payload */
@property(nonatomic, copy, nullable) NSString *schema;

/**
 *  Optional. The schema type of the schema.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Avro Avro
 *        schema type. (Value: "AVRO")
 *    @arg @c kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Json JSON
 *        schema type. (Value: "JSON")
 *    @arg @c kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_Protobuf
 *        Protobuf schema type. (Value: "PROTOBUF")
 *    @arg @c kGTLRManagedKafka_CheckCompatibilityRequest_SchemaType_SchemaTypeUnspecified
 *        No schema type. The default will be AVRO. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

/**
 *  Optional. If true, the response will contain the compatibility check result
 *  with reasons for failed checks. The default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *verbose;

@end


/**
 *  Response for CheckCompatibility.
 */
@interface GTLRManagedKafka_CheckCompatibilityResponse : GTLRObject

/**
 *  The compatibility check result. If true, the schema is compatible with the
 *  resource.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isCompatible;

/** Failure reasons if verbose = true. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *messages;

@end


/**
 *  An Apache Kafka cluster deployed in a location.
 */
@interface GTLRManagedKafka_Cluster : GTLRObject

/** Required. Capacity configuration for the Kafka cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_CapacityConfig *capacityConfig;

/** Output only. The time when the cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. Configuration properties for a Kafka cluster deployed to Google
 *  Cloud Platform.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_GcpConfig *gcpConfig;

/** Optional. Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Cluster_Labels *labels;

/**
 *  Identifier. The name of the cluster. Structured like:
 *  projects/{project_number}/locations/{location}/clusters/{cluster_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Optional. Rebalance configuration for the Kafka cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_RebalanceConfig *rebalanceConfig;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzi;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzs;

/**
 *  Output only. The current state of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_Cluster_State_Active The cluster is active.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRManagedKafka_Cluster_State_Creating The cluster is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRManagedKafka_Cluster_State_Deleting The cluster is being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRManagedKafka_Cluster_State_StateUnspecified A state was not
 *        specified. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The time when the cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Cluster_Labels : GTLRObject
@end


/**
 *  The configuration of access to the Kafka Connect cluster.
 */
@interface GTLRManagedKafka_ConnectAccessConfig : GTLRObject

/**
 *  Required. Virtual Private Cloud (VPC) networks that must be granted direct
 *  access to the Kafka Connect cluster. Minimum of 1 network is required.
 *  Maximum 10 networks can be specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_ConnectNetworkConfig *> *networkConfigs;

@end


/**
 *  An Apache Kafka Connect cluster deployed in a location.
 */
@interface GTLRManagedKafka_ConnectCluster : GTLRObject

/** Required. Capacity configuration for the Kafka Connect cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_CapacityConfig *capacityConfig;

/**
 *  Optional. Configurations for the worker that are overridden from the
 *  defaults. The key of the map is a Kafka Connect worker property name, for
 *  example: `exactly.once.source.support`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectCluster_Config *config;

/** Output only. The time when the cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. Configuration properties for a Kafka Connect cluster deployed to
 *  Google Cloud Platform.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectGcpConfig *gcpConfig;

/**
 *  Required. Immutable. The name of the Kafka cluster this Kafka Connect
 *  cluster is attached to. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}
 */
@property(nonatomic, copy, nullable) NSString *kafkaCluster;

/** Optional. Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectCluster_Labels *labels;

/**
 *  Identifier. The name of the Kafka Connect cluster. Structured like:
 *  projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current state of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_Active The cluster is
 *        active. (Value: "ACTIVE")
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_Creating The cluster is
 *        being created. (Value: "CREATING")
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_Deleting The cluster is
 *        being deleted. (Value: "DELETING")
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_StateUnspecified A state
 *        was not specified. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The time when the cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Configurations for the worker that are overridden from the
 *  defaults. The key of the map is a Kafka Connect worker property name, for
 *  example: `exactly.once.source.support`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_ConnectCluster_Config : GTLRObject
@end


/**
 *  Optional. Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_ConnectCluster_Labels : GTLRObject
@end


/**
 *  Configuration properties for a Kafka Connect cluster deployed to Google
 *  Cloud Platform.
 */
@interface GTLRManagedKafka_ConnectGcpConfig : GTLRObject

/** Required. Access configuration for the Kafka Connect cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectAccessConfig *accessConfig;

/**
 *  Optional. Secrets to load into workers. Exact SecretVersions from Secret
 *  Manager must be provided -- aliases are not supported. Up to 32 secrets may
 *  be loaded into one cluster. Format: projects//secrets//versions/
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *secretPaths;

@end


/**
 *  The configuration of a Virtual Private Cloud (VPC) network that can access
 *  the Kafka Connect cluster.
 */
@interface GTLRManagedKafka_ConnectNetworkConfig : GTLRObject

/**
 *  Optional. Additional subnets may be specified. They may be in another
 *  region, but must be in the same VPC network. The Connect workers can
 *  communicate with network endpoints in either the primary or additional
 *  subnets.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *additionalSubnets;

/**
 *  Optional. Additional DNS domain names from the subnet's network to be made
 *  visible to the Connect Cluster. When using MirrorMaker2, it's necessary to
 *  add the bootstrap address's dns domain name of the target cluster to make it
 *  visible to the connector. For example:
 *  my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dnsDomainNames;

/**
 *  Required. VPC subnet to make available to the Kafka Connect cluster.
 *  Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}
 *  It is used to create a Private Service Connect (PSC) interface for the Kafka
 *  Connect workers. It must be located in the same region as the Kafka Connect
 *  cluster. The CIDR range of the subnet must be within the IPv4 address ranges
 *  for private networks, as specified in RFC 1918. The primary subnet CIDR
 *  range must have a minimum size of /22 (1024 addresses).
 */
@property(nonatomic, copy, nullable) NSString *primarySubnet;

@end


/**
 *  A Kafka Connect connector in a given ConnectCluster.
 */
@interface GTLRManagedKafka_Connector : GTLRObject

/**
 *  Optional. Connector config as keys/values. The keys of the map are connector
 *  property names, for example: `connector.class`, `tasks.max`,
 *  `key.converter`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Connector_Configs *configs;

/**
 *  Identifier. The name of the connector. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current state of the connector.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_Connector_State_Failed The connector has failed.
 *        See logs for why. (Value: "FAILED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Paused The connector has been
 *        paused. (Value: "PAUSED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Restarting The connector is
 *        restarting. (Value: "RESTARTING")
 *    @arg @c kGTLRManagedKafka_Connector_State_Running The connector is
 *        running. (Value: "RUNNING")
 *    @arg @c kGTLRManagedKafka_Connector_State_StateUnspecified A state was not
 *        specified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Stopped The connector has been
 *        stopped. (Value: "STOPPED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Unassigned The connector is not
 *        assigned to any tasks, usually transient. (Value: "UNASSIGNED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Optional. Restarts the individual tasks of a Connector. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_TaskRetryPolicy *taskRestartPolicy;

@end


/**
 *  Optional. Connector config as keys/values. The keys of the map are connector
 *  property names, for example: `connector.class`, `tasks.max`,
 *  `key.converter`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Connector_Configs : GTLRObject
@end


/**
 *  A Kafka consumer group in a given cluster.
 */
@interface GTLRManagedKafka_ConsumerGroup : GTLRObject

/**
 *  Identifier. The name of the consumer group. The `consumer_group` segment is
 *  used when connecting directly to the cluster. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Metadata for this consumer group for all topics it has metadata
 *  for. The key of the map is a topic name, structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConsumerGroup_Topics *topics;

@end


/**
 *  Optional. Metadata for this consumer group for all topics it has metadata
 *  for. The key of the map is a topic name, structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 *
 *  @note This class is documented as having more properties of
 *        GTLRManagedKafka_ConsumerTopicMetadata. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_ConsumerGroup_Topics : GTLRObject
@end


/**
 *  Metadata for a consumer group corresponding to a specific partition.
 */
@interface GTLRManagedKafka_ConsumerPartitionMetadata : GTLRObject

/**
 *  Optional. The associated metadata for this partition, or empty if it does
 *  not exist.
 */
@property(nonatomic, copy, nullable) NSString *metadata;

/**
 *  Required. The current offset for this partition, or 0 if no offset has been
 *  committed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

@end


/**
 *  Metadata for a consumer group corresponding to a specific topic.
 */
@interface GTLRManagedKafka_ConsumerTopicMetadata : GTLRObject

/**
 *  Optional. Metadata for this consumer group and topic for all partition
 *  indexes it has metadata for.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConsumerTopicMetadata_Partitions *partitions;

@end


/**
 *  Optional. Metadata for this consumer group and topic for all partition
 *  indexes it has metadata for.
 *
 *  @note This class is documented as having more properties of
 *        GTLRManagedKafka_ConsumerPartitionMetadata. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRManagedKafka_ConsumerTopicMetadata_Partitions : GTLRObject
@end


/**
 *  Context represents an independent schema grouping in a schema registry
 *  instance.
 */
@interface GTLRManagedKafka_Context : GTLRObject

/**
 *  Identifier. The name of the context. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 *  The context name {context} can contain the following: * Up to 255
 *  characters. * Allowed characters: letters (uppercase or lowercase), numbers,
 *  and the following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Optional. The subjects of the context. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *subjects;

@end


/**
 *  Request to create a schema registry instance.
 */
@interface GTLRManagedKafka_CreateSchemaRegistryRequest : GTLRObject

/**
 *  Required. The schema registry instance to create. The name field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_SchemaRegistry *schemaRegistry;

/**
 *  Required. The schema registry instance ID to use for this schema registry.
 *  The ID must contain only letters (a-z, A-Z), numbers (0-9), and underscores
 *  (-). The maximum length is 63 characters. The ID must not start with a
 *  number.
 */
@property(nonatomic, copy, nullable) NSString *schemaRegistryId;

@end


/**
 *  Request for CreateVersion.
 */
@interface GTLRManagedKafka_CreateVersionRequest : GTLRObject

/**
 *  Optional. The schema ID of the schema. If not specified, the schema ID will
 *  be generated by the server. If the schema ID is specified, it must not be
 *  used by an existing schema that is different from the schema to be created.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *identifier;

/**
 *  Optional. If true, the schema will be normalized before being stored. The
 *  default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *normalize;

/** Optional. The schema references used by the schema. */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_SchemaReference *> *references;

/** Required. The schema payload */
@property(nonatomic, copy, nullable) NSString *schema;

/**
 *  Optional. The type of the schema. It is optional. If not specified, the
 *  schema type will be AVRO.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_CreateVersionRequest_SchemaType_Avro Avro schema
 *        type. (Value: "AVRO")
 *    @arg @c kGTLRManagedKafka_CreateVersionRequest_SchemaType_Json JSON schema
 *        type. (Value: "JSON")
 *    @arg @c kGTLRManagedKafka_CreateVersionRequest_SchemaType_Protobuf
 *        Protobuf schema type. (Value: "PROTOBUF")
 *    @arg @c kGTLRManagedKafka_CreateVersionRequest_SchemaType_SchemaTypeUnspecified
 *        No schema type. The default will be AVRO. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

/**
 *  Optional. The version to create. It is optional. If not specified, the
 *  version will be created with the max version ID of the subject increased by
 *  1. If the version ID is specified, it will be used as the new version ID and
 *  must not be used by an existing version of the subject.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Response for CreateVersion.
 */
@interface GTLRManagedKafka_CreateVersionResponse : GTLRObject

/**
 *  The unique identifier of the schema created.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *identifier;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRManagedKafka_Empty : GTLRObject
@end


/**
 *  Configuration properties for a Kafka cluster deployed to Google Cloud
 *  Platform.
 */
@interface GTLRManagedKafka_GcpConfig : GTLRObject

/** Required. Access configuration for the Kafka cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_AccessConfig *accessConfig;

/**
 *  Optional. Immutable. The Cloud KMS Key name to use for encryption. The key
 *  must be located in the same region as the cluster and cannot be changed.
 *  Structured like:
 *  projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
 */
@property(nonatomic, copy, nullable) NSString *kmsKey;

@end


/**
 *  Message that represents an arbitrary HTTP body. It should only be used for
 *  payload formats that can't be represented as JSON, such as raw binary or an
 *  HTML page. This message can be used both in streaming and non-streaming API
 *  methods in the request as well as the response. It can be used as a
 *  top-level request field, which is convenient if one wants to extract
 *  parameters from either the URL or HTTP template into the request fields and
 *  also want access to the raw HTTP body. Example: message GetResourceRequest {
 *  // A unique request id. string request_id = 1; // The raw HTTP body is bound
 *  to this field. google.api.HttpBody http_body = 2; } service ResourceService
 *  { rpc GetResource(GetResourceRequest) returns (google.api.HttpBody); rpc
 *  UpdateResource(google.api.HttpBody) returns (google.protobuf.Empty); }
 *  Example with streaming methods: service CaldavService { rpc
 *  GetCalendar(stream google.api.HttpBody) returns (stream
 *  google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
 *  (stream google.api.HttpBody); } Use of this type only changes how the
 *  request and response bodies are handled, all other features will continue to
 *  work unchanged.
 */
@interface GTLRManagedKafka_HttpBody : GTLRObject

/**
 *  The HTTP Content-Type header value specifying the content type of the body.
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The HTTP request/response body as raw binary.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  Application specific response metadata. Must be set in the first response
 *  for streaming APIs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_HttpBody_Extensions_Item *> *extensions;

@end


/**
 *  GTLRManagedKafka_HttpBody_Extensions_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_HttpBody_Extensions_Item : GTLRObject
@end


/**
 *  Response for ListAcls.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "acls" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListAclsResponse : GTLRCollectionObject

/**
 *  The list of acls in the requested parent. The order of the acls is
 *  unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Acl *> *acls;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response for ListClusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "clusters" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListClustersResponse : GTLRCollectionObject

/**
 *  The list of Clusters in the requested parent.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Cluster *> *clusters;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListConnectClusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "connectClusters" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRManagedKafka_ListConnectClustersResponse : GTLRCollectionObject

/**
 *  The list of Connect clusters in the requested parent.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_ConnectCluster *> *connectClusters;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListConnectors.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "connectors" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListConnectorsResponse : GTLRCollectionObject

/**
 *  The list of connectors in the requested parent.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Connector *> *connectors;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response for ListConsumerGroups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "consumerGroups" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRManagedKafka_ListConsumerGroupsResponse : GTLRCollectionObject

/**
 *  The list of consumer group in the requested parent. The order of the
 *  consumer groups is unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_ConsumerGroup *> *consumerGroups;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Operation *> *operations;

@end


/**
 *  Request for ListSchemaRegistries.
 */
@interface GTLRManagedKafka_ListSchemaRegistriesResponse : GTLRObject

/** The schema registry instances. */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_SchemaRegistry *> *schemaRegistries;

@end


/**
 *  Response for ListTopics.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "topics" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListTopicsResponse : GTLRCollectionObject

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of topics in the requested parent. The order of the topics is
 *  unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Topic *> *topics;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRManagedKafka_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Location_Metadata : GTLRObject
@end


/**
 *  Request for LookupVersion.
 */
@interface GTLRManagedKafka_LookupVersionRequest : GTLRObject

/**
 *  Optional. If true, soft-deleted versions will be included in lookup, no
 *  matter if the subject is active or soft-deleted. If false, soft-deleted
 *  versions will be excluded. The default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deleted;

/**
 *  Optional. If true, the schema will be normalized before being looked up. The
 *  default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *normalize;

/** Optional. The schema references used by the schema. */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_SchemaReference *> *references;

/** Required. The schema payload */
@property(nonatomic, copy, nullable) NSString *schema;

/**
 *  Optional. The schema type of the schema.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_LookupVersionRequest_SchemaType_Avro Avro schema
 *        type. (Value: "AVRO")
 *    @arg @c kGTLRManagedKafka_LookupVersionRequest_SchemaType_Json JSON schema
 *        type. (Value: "JSON")
 *    @arg @c kGTLRManagedKafka_LookupVersionRequest_SchemaType_Protobuf
 *        Protobuf schema type. (Value: "PROTOBUF")
 *    @arg @c kGTLRManagedKafka_LookupVersionRequest_SchemaType_SchemaTypeUnspecified
 *        No schema type. The default will be AVRO. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

@end


/**
 *  The configuration of a Virtual Private Cloud (VPC) network that can access
 *  the Kafka cluster.
 */
@interface GTLRManagedKafka_NetworkConfig : GTLRObject

/**
 *  Required. Name of the VPC subnet in which to create Private Service Connect
 *  (PSC) endpoints for the Kafka brokers and bootstrap address. Structured
 *  like: projects/{project}/regions/{region}/subnetworks/{subnet_id} The subnet
 *  must be located in the same region as the Kafka cluster. The project may
 *  differ. Multiple subnets from the same parent network must not be specified.
 */
@property(nonatomic, copy, nullable) NSString *subnet;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRManagedKafka_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Operation_Response : GTLRObject
@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRManagedKafka_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have been cancelled successfully have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  Request for PauseConnector.
 */
@interface GTLRManagedKafka_PauseConnectorRequest : GTLRObject
@end


/**
 *  Response for PauseConnector.
 */
@interface GTLRManagedKafka_PauseConnectorResponse : GTLRObject
@end


/**
 *  Defines rebalancing behavior of a Kafka cluster.
 */
@interface GTLRManagedKafka_RebalanceConfig : GTLRObject

/**
 *  Optional. The rebalance behavior for the cluster. When not specified,
 *  defaults to `NO_REBALANCE`.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_RebalanceConfig_Mode_AutoRebalanceOnScaleUp
 *        Automatically rebalance topic partitions among brokers when the
 *        cluster is scaled up. (Value: "AUTO_REBALANCE_ON_SCALE_UP")
 *    @arg @c kGTLRManagedKafka_RebalanceConfig_Mode_ModeUnspecified A mode was
 *        not specified. Do not use. (Value: "MODE_UNSPECIFIED")
 *    @arg @c kGTLRManagedKafka_RebalanceConfig_Mode_NoRebalance Do not
 *        rebalance automatically. (Value: "NO_REBALANCE")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  Response for RemoveAclEntry.
 */
@interface GTLRManagedKafka_RemoveAclEntryResponse : GTLRObject

/**
 *  The updated acl. Returned if the removed acl entry was not the last entry in
 *  the acl.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Acl *acl;

/**
 *  Returned with value true if the removed acl entry was the last entry in the
 *  acl, resulting in acl deletion.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aclDeleted;

@end


/**
 *  Request for RestartConnector.
 */
@interface GTLRManagedKafka_RestartConnectorRequest : GTLRObject
@end


/**
 *  Response for RestartConnector.
 */
@interface GTLRManagedKafka_RestartConnectorResponse : GTLRObject
@end


/**
 *  Request for ResumeConnector.
 */
@interface GTLRManagedKafka_ResumeConnectorRequest : GTLRObject
@end


/**
 *  Response for ResumeConnector.
 */
@interface GTLRManagedKafka_ResumeConnectorResponse : GTLRObject
@end


/**
 *  Schema for a Kafka message.
 */
@interface GTLRManagedKafka_Schema : GTLRObject

/** Optional. The schema references used by the schema. */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_SchemaReference *> *references;

/** The schema payload. */
@property(nonatomic, copy, nullable) NSString *schema;

/**
 *  Optional. The schema type of the schema.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_Schema_SchemaType_Avro Avro schema type. (Value:
 *        "AVRO")
 *    @arg @c kGTLRManagedKafka_Schema_SchemaType_Json JSON schema type. (Value:
 *        "JSON")
 *    @arg @c kGTLRManagedKafka_Schema_SchemaType_Protobuf Protobuf schema type.
 *        (Value: "PROTOBUF")
 *    @arg @c kGTLRManagedKafka_Schema_SchemaType_SchemaTypeUnspecified No
 *        schema type. The default will be AVRO. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

@end


/**
 *  SchemaConfig represents configuration for a schema registry or a specific
 *  subject.
 */
@interface GTLRManagedKafka_SchemaConfig : GTLRObject

/**
 *  Optional. The subject to which this subject is an alias of. Only applicable
 *  for subject config.
 */
@property(nonatomic, copy, nullable) NSString *alias;

/**
 *  Required. The compatibility type of the schema. The default value is
 *  BACKWARD. If unset in a SchemaSubject-level SchemaConfig, defaults to the
 *  global value. If unset in a SchemaRegistry-level SchemaConfig, reverts to
 *  the default value.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_Backward Backwards
 *        compatible with the most recent version. (Value: "BACKWARD")
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_BackwardTransitive
 *        Backwards compatible with all previous versions. (Value:
 *        "BACKWARD_TRANSITIVE")
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_Forward Forwards
 *        compatible with the most recent version. (Value: "FORWARD")
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_ForwardTransitive
 *        Forwards compatible with all previous versions. (Value:
 *        "FORWARD_TRANSITIVE")
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_Full Backwards and
 *        forwards compatible with the most recent version. (Value: "FULL")
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_FullTransitive
 *        Backwards and forwards compatible with all previous versions. (Value:
 *        "FULL_TRANSITIVE")
 *    @arg @c kGTLRManagedKafka_SchemaConfig_Compatibility_None No compatibility
 *        check. (Value: "NONE")
 */
@property(nonatomic, copy, nullable) NSString *compatibility;

/**
 *  Optional. If true, the schema will be normalized before being stored or
 *  looked up. The default is false. If unset in a SchemaSubject-level
 *  SchemaConfig, the global value will be used. If unset in a
 *  SchemaRegistry-level SchemaConfig, reverts to the default value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *normalize;

@end


/**
 *  SchemaMode represents the mode of a schema registry or a specific subject.
 *  Four modes are supported: * NONE: This is the default mode for a subject and
 *  essentially means that the subject does not have any mode set. This means
 *  the subject will follow the schema registry's mode. * READONLY: The schema
 *  registry is in read-only mode. * READWRITE: The schema registry is in
 *  read-write mode, which allows limited write operations on the schema. *
 *  IMPORT: The schema registry is in import mode, which allows more editing
 *  operations on the schema for data importing purposes.
 */
@interface GTLRManagedKafka_SchemaMode : GTLRObject

/**
 *  Required. The mode type of a schema registry (READWRITE by default) or of a
 *  subject (NONE by default, which means use the global schema registry
 *  setting).
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_SchemaMode_Mode_Import IMPORT mode. (Value:
 *        "IMPORT")
 *    @arg @c kGTLRManagedKafka_SchemaMode_Mode_None No mode. (Value: "NONE")
 *    @arg @c kGTLRManagedKafka_SchemaMode_Mode_Readonly READONLY mode. (Value:
 *        "READONLY")
 *    @arg @c kGTLRManagedKafka_SchemaMode_Mode_Readwrite READWRITE mode.
 *        (Value: "READWRITE")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  SchemaReference is a reference to a schema.
 */
@interface GTLRManagedKafka_SchemaReference : GTLRObject

/** Required. The name of the reference. */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. The subject of the reference. */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Required. The version of the reference.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  SchemaRegistry is a schema registry instance.
 */
@interface GTLRManagedKafka_SchemaRegistry : GTLRObject

/** Output only. The contexts of the schema registry instance. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *contexts;

/**
 *  Identifier. The name of the schema registry instance. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *  The instance name {schema_registry} can contain the following: * Up to 255
 *  characters. * Letters (uppercase or lowercase), numbers, and underscores.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Version of a schema.
 */
@interface GTLRManagedKafka_SchemaVersion : GTLRObject

/**
 *  Required. The schema ID.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *identifier;

/** Optional. The schema references used by the schema. */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_SchemaReference *> *references;

/** Required. The schema payload. */
@property(nonatomic, copy, nullable) NSString *schema;

/**
 *  Optional. The schema type of the schema.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_SchemaVersion_SchemaType_Avro Avro schema type.
 *        (Value: "AVRO")
 *    @arg @c kGTLRManagedKafka_SchemaVersion_SchemaType_Json JSON schema type.
 *        (Value: "JSON")
 *    @arg @c kGTLRManagedKafka_SchemaVersion_SchemaType_Protobuf Protobuf
 *        schema type. (Value: "PROTOBUF")
 *    @arg @c kGTLRManagedKafka_SchemaVersion_SchemaType_SchemaTypeUnspecified
 *        No schema type. The default will be AVRO. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

/** Required. The subject of the version. */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Required. The version ID
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRManagedKafka_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRManagedKafka_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Status_Details_Item : GTLRObject
@end


/**
 *  Request for StopConnector.
 */
@interface GTLRManagedKafka_StopConnectorRequest : GTLRObject
@end


/**
 *  Response for StopConnector.
 */
@interface GTLRManagedKafka_StopConnectorResponse : GTLRObject
@end


/**
 *  Task Retry Policy is implemented on a best-effort basis. Retry delay will be
 *  exponential based on provided minimum and maximum backoffs.
 *  https://en.wikipedia.org/wiki/Exponential_backoff. Note that the delay
 *  between consecutive task restarts may not always precisely match the
 *  configured settings. This can happen when the ConnectCluster is in
 *  rebalancing state or if the ConnectCluster is unresponsive etc. The default
 *  values for minimum and maximum backoffs are 60 seconds and 30 minutes
 *  respectively.
 */
@interface GTLRManagedKafka_TaskRetryPolicy : GTLRObject

/**
 *  Optional. The maximum amount of time to wait before retrying a failed task.
 *  This sets an upper bound for the backoff delay.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maximumBackoff;

/**
 *  Optional. The minimum amount of time to wait before retrying a failed task.
 *  This sets a lower bound for the backoff delay.
 */
@property(nonatomic, strong, nullable) GTLRDuration *minimumBackoff;

@end


/**
 *  A Kafka topic in a given cluster.
 */
@interface GTLRManagedKafka_Topic : GTLRObject

/**
 *  Optional. Configurations for the topic that are overridden from the cluster
 *  defaults. The key of the map is a Kafka topic property name, for example:
 *  `cleanup.policy`, `compression.type`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Topic_Configs *configs;

/**
 *  Identifier. The name of the topic. The `topic` segment is used when
 *  connecting directly to the cluster. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The number of partitions this topic has. The partition count can
 *  only be increased, not decreased. Please note that if partitions are
 *  increased for a topic that has a key, the partitioning logic or the ordering
 *  of the messages will be affected.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionCount;

/**
 *  Required. Immutable. The number of replicas of each partition. A replication
 *  factor of 3 is recommended for high availability.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicationFactor;

@end


/**
 *  Optional. Configurations for the topic that are overridden from the cluster
 *  defaults. The key of the map is a Kafka topic property name, for example:
 *  `cleanup.policy`, `compression.type`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Topic_Configs : GTLRObject
@end


/**
 *  Request for updating schema config. On a SchemaSubject-level SchemaConfig,
 *  an unset field will be removed from the SchemaConfig.
 */
@interface GTLRManagedKafka_UpdateSchemaConfigRequest : GTLRObject

/**
 *  Required. The compatibility type of the schemas. Cannot be unset for a
 *  SchemaRegistry-level SchemaConfig. If unset on a SchemaSubject-level
 *  SchemaConfig, removes the compatibility field for the SchemaConfig.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Backward
 *        Backwards compatible with the most recent version. (Value: "BACKWARD")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_BackwardTransitive
 *        Backwards compatible with all previous versions. (Value:
 *        "BACKWARD_TRANSITIVE")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Forward
 *        Forwards compatible with the most recent version. (Value: "FORWARD")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_ForwardTransitive
 *        Forwards compatible with all previous versions. (Value:
 *        "FORWARD_TRANSITIVE")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_Full
 *        Backwards and forwards compatible with the most recent version.
 *        (Value: "FULL")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_FullTransitive
 *        Backwards and forwards compatible with all previous versions. (Value:
 *        "FULL_TRANSITIVE")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaConfigRequest_Compatibility_None No
 *        compatibility check. (Value: "NONE")
 */
@property(nonatomic, copy, nullable) NSString *compatibility;

/**
 *  Optional. If true, the schema will be normalized before being stored or
 *  looked up. The default is false. Cannot be unset for a SchemaRegistry-level
 *  SchemaConfig. If unset on a SchemaSubject-level SchemaConfig, removes the
 *  normalize field for the SchemaConfig.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *normalize;

@end


/**
 *  Request for updating schema registry or subject mode.
 */
@interface GTLRManagedKafka_UpdateSchemaModeRequest : GTLRObject

/**
 *  Required. The mode type.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Import IMPORT mode.
 *        (Value: "IMPORT")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_None No mode.
 *        (Value: "NONE")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Readonly READONLY
 *        mode. (Value: "READONLY")
 *    @arg @c kGTLRManagedKafka_UpdateSchemaModeRequest_Mode_Readwrite READWRITE
 *        mode. (Value: "READWRITE")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
