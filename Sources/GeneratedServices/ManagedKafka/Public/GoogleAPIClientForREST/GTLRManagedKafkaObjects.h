// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Managed Service for Apache Kafka API (managedkafka/v1)
// Description:
//   Manage Apache Kafka clusters and resources.
// Documentation:
//   https://cloud.google.com/managed-service-for-apache-kafka/docs

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRManagedKafka_AccessConfig;
@class GTLRManagedKafka_CapacityConfig;
@class GTLRManagedKafka_Cluster;
@class GTLRManagedKafka_Cluster_Labels;
@class GTLRManagedKafka_ConnectAccessConfig;
@class GTLRManagedKafka_ConnectCluster;
@class GTLRManagedKafka_ConnectCluster_Config;
@class GTLRManagedKafka_ConnectCluster_Labels;
@class GTLRManagedKafka_ConnectGcpConfig;
@class GTLRManagedKafka_ConnectNetworkConfig;
@class GTLRManagedKafka_Connector;
@class GTLRManagedKafka_Connector_Configs;
@class GTLRManagedKafka_ConsumerGroup;
@class GTLRManagedKafka_ConsumerGroup_Topics;
@class GTLRManagedKafka_ConsumerPartitionMetadata;
@class GTLRManagedKafka_ConsumerTopicMetadata;
@class GTLRManagedKafka_ConsumerTopicMetadata_Partitions;
@class GTLRManagedKafka_GcpConfig;
@class GTLRManagedKafka_Location;
@class GTLRManagedKafka_Location_Labels;
@class GTLRManagedKafka_Location_Metadata;
@class GTLRManagedKafka_NetworkConfig;
@class GTLRManagedKafka_Operation;
@class GTLRManagedKafka_Operation_Metadata;
@class GTLRManagedKafka_Operation_Response;
@class GTLRManagedKafka_RebalanceConfig;
@class GTLRManagedKafka_Status;
@class GTLRManagedKafka_Status_Details_Item;
@class GTLRManagedKafka_TaskRetryPolicy;
@class GTLRManagedKafka_Topic;
@class GTLRManagedKafka_Topic_Configs;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRManagedKafka_Cluster.state

/**
 *  The cluster is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_Active;
/**
 *  The cluster is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_Creating;
/**
 *  The cluster is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_Deleting;
/**
 *  A state was not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Cluster_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_ConnectCluster.state

/**
 *  The cluster is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_Active;
/**
 *  The cluster is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_Creating;
/**
 *  The cluster is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_Deleting;
/**
 *  A state was not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_ConnectCluster_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_Connector.state

/**
 *  The connector has failed. See logs for why.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Failed;
/**
 *  The connector has been paused.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Paused;
/**
 *  The connector is restarting.
 *
 *  Value: "RESTARTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Restarting;
/**
 *  The connector is running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Running;
/**
 *  A state was not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_StateUnspecified;
/**
 *  The connector has been stopped.
 *
 *  Value: "STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Stopped;
/**
 *  The connector is not assigned to any tasks, usually transient.
 *
 *  Value: "UNASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_Connector_State_Unassigned;

// ----------------------------------------------------------------------------
// GTLRManagedKafka_RebalanceConfig.mode

/**
 *  Automatically rebalance topic partitions among brokers when the cluster is
 *  scaled up.
 *
 *  Value: "AUTO_REBALANCE_ON_SCALE_UP"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_AutoRebalanceOnScaleUp;
/**
 *  A mode was not specified. Do not use.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_ModeUnspecified;
/**
 *  Do not rebalance automatically.
 *
 *  Value: "NO_REBALANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafka_RebalanceConfig_Mode_NoRebalance;

/**
 *  The configuration of access to the Kafka cluster.
 */
@interface GTLRManagedKafka_AccessConfig : GTLRObject

/**
 *  Required. Virtual Private Cloud (VPC) networks that must be granted direct
 *  access to the Kafka cluster. Minimum of 1 network is required. Maximum 10
 *  networks can be specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_NetworkConfig *> *networkConfigs;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRManagedKafka_CancelOperationRequest : GTLRObject
@end


/**
 *  A capacity configuration of a Kafka cluster.
 */
@interface GTLRManagedKafka_CapacityConfig : GTLRObject

/**
 *  Required. The memory to provision for the cluster in bytes. The CPU:memory
 *  ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryBytes;

/**
 *  Required. The number of vCPUs to provision for the cluster. Minimum: 3.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vcpuCount;

@end


/**
 *  An Apache Kafka cluster deployed in a location.
 */
@interface GTLRManagedKafka_Cluster : GTLRObject

/** Required. Capacity configuration for the Kafka cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_CapacityConfig *capacityConfig;

/** Output only. The time when the cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. Configuration properties for a Kafka cluster deployed to Google
 *  Cloud Platform.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_GcpConfig *gcpConfig;

/** Optional. Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Cluster_Labels *labels;

/**
 *  Identifier. The name of the cluster. Structured like:
 *  projects/{project_number}/locations/{location}/clusters/{cluster_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Optional. Rebalance configuration for the Kafka cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_RebalanceConfig *rebalanceConfig;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzi;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzs;

/**
 *  Output only. The current state of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_Cluster_State_Active The cluster is active.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRManagedKafka_Cluster_State_Creating The cluster is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRManagedKafka_Cluster_State_Deleting The cluster is being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRManagedKafka_Cluster_State_StateUnspecified A state was not
 *        specified. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The time when the cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Cluster_Labels : GTLRObject
@end


/**
 *  The configuration of access to the Kafka Connect cluster.
 */
@interface GTLRManagedKafka_ConnectAccessConfig : GTLRObject

/**
 *  Required. Virtual Private Cloud (VPC) networks that must be granted direct
 *  access to the Kafka Connect cluster. Minimum of 1 network is required.
 *  Maximum 10 networks can be specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_ConnectNetworkConfig *> *networkConfigs;

@end


/**
 *  An Apache Kafka Connect cluster deployed in a location.
 */
@interface GTLRManagedKafka_ConnectCluster : GTLRObject

/** Required. Capacity configuration for the Kafka Connect cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_CapacityConfig *capacityConfig;

/**
 *  Optional. Configurations for the worker that are overridden from the
 *  defaults. The key of the map is a Kafka Connect worker property name, for
 *  example: `exactly.once.source.support`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectCluster_Config *config;

/** Output only. The time when the cluster was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. Configuration properties for a Kafka Connect cluster deployed to
 *  Google Cloud Platform.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectGcpConfig *gcpConfig;

/**
 *  Required. Immutable. The name of the Kafka cluster this Kafka Connect
 *  cluster is attached to. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}
 */
@property(nonatomic, copy, nullable) NSString *kafkaCluster;

/** Optional. Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectCluster_Labels *labels;

/**
 *  Identifier. The name of the Kafka Connect cluster. Structured like:
 *  projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current state of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_Active The cluster is
 *        active. (Value: "ACTIVE")
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_Creating The cluster is
 *        being created. (Value: "CREATING")
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_Deleting The cluster is
 *        being deleted. (Value: "DELETING")
 *    @arg @c kGTLRManagedKafka_ConnectCluster_State_StateUnspecified A state
 *        was not specified. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The time when the cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Configurations for the worker that are overridden from the
 *  defaults. The key of the map is a Kafka Connect worker property name, for
 *  example: `exactly.once.source.support`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_ConnectCluster_Config : GTLRObject
@end


/**
 *  Optional. Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_ConnectCluster_Labels : GTLRObject
@end


/**
 *  Configuration properties for a Kafka Connect cluster deployed to Google
 *  Cloud Platform.
 */
@interface GTLRManagedKafka_ConnectGcpConfig : GTLRObject

/** Required. Access configuration for the Kafka Connect cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConnectAccessConfig *accessConfig;

/**
 *  Optional. Secrets to load into workers. Exact SecretVersions from Secret
 *  Manager must be provided -- aliases are not supported. Up to 32 secrets may
 *  be loaded into one cluster. Format: projects//secrets//versions/
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *secretPaths;

@end


/**
 *  The configuration of a Virtual Private Cloud (VPC) network that can access
 *  the Kafka Connect cluster.
 */
@interface GTLRManagedKafka_ConnectNetworkConfig : GTLRObject

/**
 *  Optional. Additional subnets may be specified. They may be in another
 *  region, but must be in the same VPC network. The Connect workers can
 *  communicate with network endpoints in either the primary or additional
 *  subnets.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *additionalSubnets;

/**
 *  Optional. Additional DNS domain names from the subnet's network to be made
 *  visible to the Connect Cluster. When using MirrorMaker2, it's necessary to
 *  add the bootstrap address's dns domain name of the target cluster to make it
 *  visible to the connector. For example:
 *  my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dnsDomainNames;

/**
 *  Required. VPC subnet to make available to the Kafka Connect cluster.
 *  Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}
 *  It is used to create a Private Service Connect (PSC) interface for the Kafka
 *  Connect workers. It must be located in the same region as the Kafka Connect
 *  cluster. The CIDR range of the subnet must be within the IPv4 address ranges
 *  for private networks, as specified in RFC 1918. The primary subnet CIDR
 *  range must have a minimum size of /22 (1024 addresses).
 */
@property(nonatomic, copy, nullable) NSString *primarySubnet;

@end


/**
 *  A Kafka Connect connector in a given ConnectCluster.
 */
@interface GTLRManagedKafka_Connector : GTLRObject

/**
 *  Optional. Connector config as keys/values. The keys of the map are connector
 *  property names, for example: `connector.class`, `tasks.max`,
 *  `key.converter`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Connector_Configs *configs;

/**
 *  Identifier. The name of the connector. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current state of the connector.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_Connector_State_Failed The connector has failed.
 *        See logs for why. (Value: "FAILED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Paused The connector has been
 *        paused. (Value: "PAUSED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Restarting The connector is
 *        restarting. (Value: "RESTARTING")
 *    @arg @c kGTLRManagedKafka_Connector_State_Running The connector is
 *        running. (Value: "RUNNING")
 *    @arg @c kGTLRManagedKafka_Connector_State_StateUnspecified A state was not
 *        specified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Stopped The connector has been
 *        stopped. (Value: "STOPPED")
 *    @arg @c kGTLRManagedKafka_Connector_State_Unassigned The connector is not
 *        assigned to any tasks, usually transient. (Value: "UNASSIGNED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Optional. Restarts the individual tasks of a Connector. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_TaskRetryPolicy *taskRestartPolicy;

@end


/**
 *  Optional. Connector config as keys/values. The keys of the map are connector
 *  property names, for example: `connector.class`, `tasks.max`,
 *  `key.converter`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Connector_Configs : GTLRObject
@end


/**
 *  A Kafka consumer group in a given cluster.
 */
@interface GTLRManagedKafka_ConsumerGroup : GTLRObject

/**
 *  Identifier. The name of the consumer group. The `consumer_group` segment is
 *  used when connecting directly to the cluster. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Metadata for this consumer group for all topics it has metadata
 *  for. The key of the map is a topic name, structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConsumerGroup_Topics *topics;

@end


/**
 *  Optional. Metadata for this consumer group for all topics it has metadata
 *  for. The key of the map is a topic name, structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 *
 *  @note This class is documented as having more properties of
 *        GTLRManagedKafka_ConsumerTopicMetadata. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_ConsumerGroup_Topics : GTLRObject
@end


/**
 *  Metadata for a consumer group corresponding to a specific partition.
 */
@interface GTLRManagedKafka_ConsumerPartitionMetadata : GTLRObject

/**
 *  Optional. The associated metadata for this partition, or empty if it does
 *  not exist.
 */
@property(nonatomic, copy, nullable) NSString *metadata;

/**
 *  Required. The current offset for this partition, or 0 if no offset has been
 *  committed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

@end


/**
 *  Metadata for a consumer group corresponding to a specific topic.
 */
@interface GTLRManagedKafka_ConsumerTopicMetadata : GTLRObject

/**
 *  Optional. Metadata for this consumer group and topic for all partition
 *  indexes it has metadata for.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_ConsumerTopicMetadata_Partitions *partitions;

@end


/**
 *  Optional. Metadata for this consumer group and topic for all partition
 *  indexes it has metadata for.
 *
 *  @note This class is documented as having more properties of
 *        GTLRManagedKafka_ConsumerPartitionMetadata. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRManagedKafka_ConsumerTopicMetadata_Partitions : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRManagedKafka_Empty : GTLRObject
@end


/**
 *  Configuration properties for a Kafka cluster deployed to Google Cloud
 *  Platform.
 */
@interface GTLRManagedKafka_GcpConfig : GTLRObject

/** Required. Access configuration for the Kafka cluster. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_AccessConfig *accessConfig;

/**
 *  Optional. Immutable. The Cloud KMS Key name to use for encryption. The key
 *  must be located in the same region as the cluster and cannot be changed.
 *  Structured like:
 *  projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
 */
@property(nonatomic, copy, nullable) NSString *kmsKey;

@end


/**
 *  Response for ListClusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "clusters" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListClustersResponse : GTLRCollectionObject

/**
 *  The list of Clusters in the requested parent.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Cluster *> *clusters;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListConnectClusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "connectClusters" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRManagedKafka_ListConnectClustersResponse : GTLRCollectionObject

/**
 *  The list of Connect clusters in the requested parent.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_ConnectCluster *> *connectClusters;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListConnectors.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "connectors" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListConnectorsResponse : GTLRCollectionObject

/**
 *  The list of connectors in the requested parent.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Connector *> *connectors;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response for ListConsumerGroups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "consumerGroups" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRManagedKafka_ListConsumerGroupsResponse : GTLRCollectionObject

/**
 *  The list of consumer group in the requested parent. The order of the
 *  consumer groups is unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_ConsumerGroup *> *consumerGroups;

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Operation *> *operations;

@end


/**
 *  Response for ListTopics.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "topics" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRManagedKafka_ListTopicsResponse : GTLRCollectionObject

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of topics in the requested parent. The order of the topics is
 *  unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Topic *> *topics;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRManagedKafka_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Location_Metadata : GTLRObject
@end


/**
 *  The configuration of a Virtual Private Cloud (VPC) network that can access
 *  the Kafka cluster.
 */
@interface GTLRManagedKafka_NetworkConfig : GTLRObject

/**
 *  Required. Name of the VPC subnet in which to create Private Service Connect
 *  (PSC) endpoints for the Kafka brokers and bootstrap address. Structured
 *  like: projects/{project}/regions/{region}/subnetworks/{subnet_id} The subnet
 *  must be located in the same region as the Kafka cluster. The project may
 *  differ. Multiple subnets from the same parent network must not be specified.
 */
@property(nonatomic, copy, nullable) NSString *subnet;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRManagedKafka_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Operation_Response : GTLRObject
@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRManagedKafka_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have been cancelled successfully have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  Request for PauseConnector.
 */
@interface GTLRManagedKafka_PauseConnectorRequest : GTLRObject
@end


/**
 *  Response for PauseConnector.
 */
@interface GTLRManagedKafka_PauseConnectorResponse : GTLRObject
@end


/**
 *  Defines rebalancing behavior of a Kafka cluster.
 */
@interface GTLRManagedKafka_RebalanceConfig : GTLRObject

/**
 *  Optional. The rebalance behavior for the cluster. When not specified,
 *  defaults to `NO_REBALANCE`.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafka_RebalanceConfig_Mode_AutoRebalanceOnScaleUp
 *        Automatically rebalance topic partitions among brokers when the
 *        cluster is scaled up. (Value: "AUTO_REBALANCE_ON_SCALE_UP")
 *    @arg @c kGTLRManagedKafka_RebalanceConfig_Mode_ModeUnspecified A mode was
 *        not specified. Do not use. (Value: "MODE_UNSPECIFIED")
 *    @arg @c kGTLRManagedKafka_RebalanceConfig_Mode_NoRebalance Do not
 *        rebalance automatically. (Value: "NO_REBALANCE")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  Request for RestartConnector.
 */
@interface GTLRManagedKafka_RestartConnectorRequest : GTLRObject
@end


/**
 *  Response for RestartConnector.
 */
@interface GTLRManagedKafka_RestartConnectorResponse : GTLRObject
@end


/**
 *  Request for ResumeConnector.
 */
@interface GTLRManagedKafka_ResumeConnectorRequest : GTLRObject
@end


/**
 *  Response for ResumeConnector.
 */
@interface GTLRManagedKafka_ResumeConnectorResponse : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRManagedKafka_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRManagedKafka_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRManagedKafka_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRManagedKafka_Status_Details_Item : GTLRObject
@end


/**
 *  Request for StopConnector.
 */
@interface GTLRManagedKafka_StopConnectorRequest : GTLRObject
@end


/**
 *  Response for StopConnector.
 */
@interface GTLRManagedKafka_StopConnectorResponse : GTLRObject
@end


/**
 *  Task Retry Policy is implemented on a best-effort basis. Retry delay will be
 *  exponential based on provided minimum and maximum backoffs.
 *  https://en.wikipedia.org/wiki/Exponential_backoff. Note that the delay
 *  between consecutive task restarts may not always precisely match the
 *  configured settings. This can happen when the ConnectCluster is in
 *  rebalancing state or if the ConnectCluster is unresponsive etc.
 */
@interface GTLRManagedKafka_TaskRetryPolicy : GTLRObject

/**
 *  Optional. The maximum amount of time to wait before retrying a failed task.
 *  This sets an upper bound for the backoff delay.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maximumBackoff;

/**
 *  Optional. The minimum amount of time to wait before retrying a failed task.
 *  This sets a lower bound for the backoff delay.
 */
@property(nonatomic, strong, nullable) GTLRDuration *minimumBackoff;

@end


/**
 *  A Kafka topic in a given cluster.
 */
@interface GTLRManagedKafka_Topic : GTLRObject

/**
 *  Optional. Configurations for the topic that are overridden from the cluster
 *  defaults. The key of the map is a Kafka topic property name, for example:
 *  `cleanup.policy`, `compression.type`.
 */
@property(nonatomic, strong, nullable) GTLRManagedKafka_Topic_Configs *configs;

/**
 *  Identifier. The name of the topic. The `topic` segment is used when
 *  connecting directly to the cluster. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The number of partitions this topic has. The partition count can
 *  only be increased, not decreased. Please note that if partitions are
 *  increased for a topic that has a key, the partitioning logic or the ordering
 *  of the messages will be affected.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionCount;

/**
 *  Required. Immutable. The number of replicas of each partition. A replication
 *  factor of 3 is recommended for high availability.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicationFactor;

@end


/**
 *  Optional. Configurations for the topic that are overridden from the cluster
 *  defaults. The key of the map is a Kafka topic property name, for example:
 *  `cleanup.policy`, `compression.type`.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRManagedKafka_Topic_Configs : GTLRObject
@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
