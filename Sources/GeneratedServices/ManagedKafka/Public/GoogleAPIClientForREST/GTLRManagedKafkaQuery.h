// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Managed Service for Apache Kafka API (managedkafka/v1)
// Description:
//   Manage Apache Kafka clusters and resources.
// Documentation:
//   https://cloud.google.com/managed-service-for-apache-kafka/docs

#import <GoogleAPIClientForREST/GTLRQuery.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

#import "GTLRManagedKafkaObjects.h"

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the query classes' properties below.

// ----------------------------------------------------------------------------
// view

/**
 *  If SchemaRegistryView is not specified, this is the default value. Returns
 *  only the name of the schema registry. The contexts associated with it are
 *  not included.
 *
 *  Value: "SCHEMA_REGISTRY_VIEW_BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafkaViewSchemaRegistryViewBasic;
/**
 *  Returns the name of the schema registry and all the contexts associated with
 *  it.
 *
 *  Value: "SCHEMA_REGISTRY_VIEW_FULL"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafkaViewSchemaRegistryViewFull;
/**
 *  The unset value. The API will default to SCHEMA_REGISTRY_VIEW_BASIC.
 *
 *  Value: "SCHEMA_REGISTRY_VIEW_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRManagedKafkaViewSchemaRegistryViewUnspecified;

// ----------------------------------------------------------------------------
// Query Classes
//

/**
 *  Parent class for other Managed Kafka query classes.
 */
@interface GTLRManagedKafkaQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Incremental update: Adds an acl entry to an acl. Creates the acl if it does
 *  not exist yet.
 *
 *  Method: managedkafka.projects.locations.clusters.acls.addAclEntry
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsAddAclEntry : GTLRManagedKafkaQuery

/**
 *  Required. The name of the acl to add the acl entry to. Structured like:
 *  `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *  The structure of `acl_id` defines the Resource Pattern (resource_type,
 *  resource_name, pattern_type) of the acl. See `Acl.name` for details.
 */
@property(nonatomic, copy, nullable) NSString *acl;

/**
 *  Fetches a @c GTLRManagedKafka_AddAclEntryResponse.
 *
 *  Incremental update: Adds an acl entry to an acl. Creates the acl if it does
 *  not exist yet.
 *
 *  @param object The @c GTLRManagedKafka_AclEntry to include in the query.
 *  @param acl Required. The name of the acl to add the acl entry to. Structured
 *    like:
 *    `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *    The structure of `acl_id` defines the Resource Pattern (resource_type,
 *    resource_name, pattern_type) of the acl. See `Acl.name` for details.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsAddAclEntry
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_AclEntry *)object
                            acl:(NSString *)acl;

@end

/**
 *  Creates a new acl in the given project, location, and cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.acls.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsCreate : GTLRManagedKafkaQuery

/**
 *  Required. The ID to use for the acl, which will become the final component
 *  of the acl's name. The structure of `acl_id` defines the Resource Pattern
 *  (resource_type, resource_name, pattern_type) of the acl. `acl_id` is
 *  structured like one of the following: For acls on the cluster: `cluster` For
 *  acls on a single resource within the cluster: `topic/{resource_name}`
 *  `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls
 *  on all resources that match a prefix: `topicPrefixed/{resource_name}`
 *  `consumerGroupPrefixed/{resource_name}`
 *  `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
 *  given type (i.e. the wildcard literal "*"): `allTopics` (represents `topic/
 *  *`) `allConsumerGroups` (represents `consumerGroup/ *`)
 *  `allTransactionalIds` (represents `transactionalId/ *`)
 */
@property(nonatomic, copy, nullable) NSString *aclId;

/**
 *  Required. The parent cluster in which to create the acl. Structured like
 *  `projects/{project}/locations/{location}/clusters/{cluster}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_Acl.
 *
 *  Creates a new acl in the given project, location, and cluster.
 *
 *  @param object The @c GTLRManagedKafka_Acl to include in the query.
 *  @param parent Required. The parent cluster in which to create the acl.
 *    Structured like
 *    `projects/{project}/locations/{location}/clusters/{cluster}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Acl *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes an acl.
 *
 *  Method: managedkafka.projects.locations.clusters.acls.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the acl to delete. Structured like:
 *  `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *  The structure of `acl_id` defines the Resource Pattern (resource_type,
 *  resource_name, pattern_type) of the acl. See `Acl.name` for details.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Deletes an acl.
 *
 *  @param name Required. The name of the acl to delete. Structured like:
 *    `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *    The structure of `acl_id` defines the Resource Pattern (resource_type,
 *    resource_name, pattern_type) of the acl. See `Acl.name` for details.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Returns the properties of a single acl.
 *
 *  Method: managedkafka.projects.locations.clusters.acls.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the acl to return. Structured like:
 *  `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *  The structure of `acl_id` defines the Resource Pattern (resource_type,
 *  resource_name, pattern_type) of the acl. See `Acl.name` for details.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Acl.
 *
 *  Returns the properties of a single acl.
 *
 *  @param name Required. The name of the acl to return. Structured like:
 *    `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *    The structure of `acl_id` defines the Resource Pattern (resource_type,
 *    resource_name, pattern_type) of the acl. See `Acl.name` for details.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the acls in a given cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.acls.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsList : GTLRManagedKafkaQuery

/**
 *  Optional. The maximum number of acls to return. The service may return fewer
 *  than this value. If unset or zero, all acls for the parent is returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. A page token, received from a previous `ListAcls` call. Provide
 *  this to retrieve the subsequent page. When paginating, all other parameters
 *  provided to `ListAcls` must match the call that provided the page token.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The parent cluster whose acls are to be listed. Structured like
 *  `projects/{project}/locations/{location}/clusters/{cluster}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_ListAclsResponse.
 *
 *  Lists the acls in a given cluster.
 *
 *  @param parent Required. The parent cluster whose acls are to be listed.
 *    Structured like
 *    `projects/{project}/locations/{location}/clusters/{cluster}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates the properties of a single acl.
 *
 *  Method: managedkafka.projects.locations.clusters.acls.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsPatch : GTLRManagedKafkaQuery

/**
 *  Identifier. The name for the acl. Represents a single Resource Pattern.
 *  Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
 *  structure of `acl_id` defines the Resource Pattern (resource_type,
 *  resource_name, pattern_type) of the acl. `acl_id` is structured like one of
 *  the following: For acls on the cluster: `cluster` For acls on a single
 *  resource within the cluster: `topic/{resource_name}`
 *  `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls
 *  on all resources that match a prefix: `topicPrefixed/{resource_name}`
 *  `consumerGroupPrefixed/{resource_name}`
 *  `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
 *  given type (i.e. the wildcard literal "*"): `allTopics` (represents `topic/
 *  *`) `allConsumerGroups` (represents `consumerGroup/ *`)
 *  `allTransactionalIds` (represents `transactionalId/ *`)
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Field mask is used to specify the fields to be overwritten in the
 *  Acl resource by the update. The fields specified in the update_mask are
 *  relative to the resource, not the full request. A field will be overwritten
 *  if it is in the mask.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRManagedKafka_Acl.
 *
 *  Updates the properties of a single acl.
 *
 *  @param object The @c GTLRManagedKafka_Acl to include in the query.
 *  @param name Identifier. The name for the acl. Represents a single Resource
 *    Pattern. Structured like:
 *    projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}
 *    The structure of `acl_id` defines the Resource Pattern (resource_type,
 *    resource_name, pattern_type) of the acl. `acl_id` is structured like one
 *    of the following: For acls on the cluster: `cluster` For acls on a single
 *    resource within the cluster: `topic/{resource_name}`
 *    `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls
 *    on all resources that match a prefix: `topicPrefixed/{resource_name}`
 *    `consumerGroupPrefixed/{resource_name}`
 *    `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
 *    given type (i.e. the wildcard literal "*"): `allTopics` (represents
 *    `topic/ *`) `allConsumerGroups` (represents `consumerGroup/ *`)
 *    `allTransactionalIds` (represents `transactionalId/ *`)
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsPatch
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Acl *)object
                           name:(NSString *)name;

@end

/**
 *  Incremental update: Removes an acl entry from an acl. Deletes the acl if its
 *  acl entries become empty (i.e. if the removed entry was the last one in the
 *  acl).
 *
 *  Method: managedkafka.projects.locations.clusters.acls.removeAclEntry
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsRemoveAclEntry : GTLRManagedKafkaQuery

/**
 *  Required. The name of the acl to remove the acl entry from. Structured like:
 *  `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *  The structure of `acl_id` defines the Resource Pattern (resource_type,
 *  resource_name, pattern_type) of the acl. See `Acl.name` for details.
 */
@property(nonatomic, copy, nullable) NSString *acl;

/**
 *  Fetches a @c GTLRManagedKafka_RemoveAclEntryResponse.
 *
 *  Incremental update: Removes an acl entry from an acl. Deletes the acl if its
 *  acl entries become empty (i.e. if the removed entry was the last one in the
 *  acl).
 *
 *  @param object The @c GTLRManagedKafka_AclEntry to include in the query.
 *  @param acl Required. The name of the acl to remove the acl entry from.
 *    Structured like:
 *    `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
 *    The structure of `acl_id` defines the Resource Pattern (resource_type,
 *    resource_name, pattern_type) of the acl. See `Acl.name` for details.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersAclsRemoveAclEntry
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_AclEntry *)object
                            acl:(NSString *)acl;

@end

/**
 *  Deletes a single consumer group.
 *
 *  Method: managedkafka.projects.locations.clusters.consumerGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the consumer group to delete.
 *  `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Deletes a single consumer group.
 *
 *  @param name Required. The name of the consumer group to delete.
 *    `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Returns the properties of a single consumer group.
 *
 *  Method: managedkafka.projects.locations.clusters.consumerGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the consumer group whose configuration to return.
 *  `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_ConsumerGroup.
 *
 *  Returns the properties of a single consumer group.
 *
 *  @param name Required. The name of the consumer group whose configuration to
 *    return.
 *    `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the consumer groups in a given cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.consumerGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsList : GTLRManagedKafkaQuery

/**
 *  Optional. The maximum number of consumer groups to return. The service may
 *  return fewer than this value. If unset or zero, all consumer groups for the
 *  parent is returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. A page token, received from a previous `ListConsumerGroups` call.
 *  Provide this to retrieve the subsequent page. When paginating, all other
 *  parameters provided to `ListConsumerGroups` must match the call that
 *  provided the page token.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The parent cluster whose consumer groups are to be listed.
 *  Structured like
 *  `projects/{project}/locations/{location}/clusters/{cluster}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_ListConsumerGroupsResponse.
 *
 *  Lists the consumer groups in a given cluster.
 *
 *  @param parent Required. The parent cluster whose consumer groups are to be
 *    listed. Structured like
 *    `projects/{project}/locations/{location}/clusters/{cluster}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates the properties of a single consumer group.
 *
 *  Method: managedkafka.projects.locations.clusters.consumerGroups.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsPatch : GTLRManagedKafkaQuery

/**
 *  Identifier. The name of the consumer group. The `consumer_group` segment is
 *  used when connecting directly to the cluster. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Field mask is used to specify the fields to be overwritten in the
 *  ConsumerGroup resource by the update. The fields specified in the
 *  update_mask are relative to the resource, not the full request. A field will
 *  be overwritten if it is in the mask. The mask is required and a value of *
 *  will update all fields.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRManagedKafka_ConsumerGroup.
 *
 *  Updates the properties of a single consumer group.
 *
 *  @param object The @c GTLRManagedKafka_ConsumerGroup to include in the query.
 *  @param name Identifier. The name of the consumer group. The `consumer_group`
 *    segment is used when connecting directly to the cluster. Structured like:
 *    projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersConsumerGroupsPatch
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_ConsumerGroup *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new cluster in a given project and location.
 *
 *  Method: managedkafka.projects.locations.clusters.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersCreate : GTLRManagedKafkaQuery

/**
 *  Required. The ID to use for the cluster, which will become the final
 *  component of the cluster's name. The ID must be 1-63 characters long, and
 *  match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC
 *  1035. This value is structured like: `my-cluster-id`.
 */
@property(nonatomic, copy, nullable) NSString *clusterId;

/**
 *  Required. The parent region in which to create the cluster. Structured like
 *  `projects/{project}/locations/{location}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. An optional request ID to identify requests. Specify a unique
 *  request ID to avoid duplication of requests. If a request times out or
 *  fails, retrying with the same ID allows the server to recognize the previous
 *  attempt. For at least 60 minutes, the server ignores duplicate requests
 *  bearing the same ID. For example, consider a situation where you make an
 *  initial request and the request times out. If you make the request again
 *  with the same request ID within 60 minutes of the last request, the server
 *  checks if an original operation with the same request ID was received. If
 *  so, the server ignores the second request. The request ID must be a valid
 *  UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Creates a new cluster in a given project and location.
 *
 *  @param object The @c GTLRManagedKafka_Cluster to include in the query.
 *  @param parent Required. The parent region in which to create the cluster.
 *    Structured like `projects/{project}/locations/{location}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Cluster *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes a single cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersDelete : GTLRManagedKafkaQuery

/** Required. The name of the cluster to delete. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. An optional request ID to identify requests. Specify a unique
 *  request ID to avoid duplication of requests. If a request times out or
 *  fails, retrying with the same ID allows the server to recognize the previous
 *  attempt. For at least 60 minutes, the server ignores duplicate requests
 *  bearing the same ID. For example, consider a situation where you make an
 *  initial request and the request times out. If you make the request again
 *  with the same request ID within 60 minutes of the last request, the server
 *  checks if an original operation with the same request ID was received. If
 *  so, the server ignores the second request. The request ID must be a valid
 *  UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Deletes a single cluster.
 *
 *  @param name Required. The name of the cluster to delete.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Returns the properties of a single cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersGet : GTLRManagedKafkaQuery

/** Required. The name of the cluster whose configuration to return. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Cluster.
 *
 *  Returns the properties of a single cluster.
 *
 *  @param name Required. The name of the cluster whose configuration to return.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the clusters in a given project and location.
 *
 *  Method: managedkafka.projects.locations.clusters.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersList : GTLRManagedKafkaQuery

/** Optional. Filter expression for the result. */
@property(nonatomic, copy, nullable) NSString *filter;

/** Optional. Order by fields for the result. */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Optional. The maximum number of clusters to return. The service may return
 *  fewer than this value. If unspecified, server will pick an appropriate
 *  default.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. A page token, received from a previous `ListClusters` call.
 *  Provide this to retrieve the subsequent page. When paginating, all other
 *  parameters provided to `ListClusters` must match the call that provided the
 *  page token.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The parent location whose clusters are to be listed. Structured
 *  like `projects/{project}/locations/{location}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_ListClustersResponse.
 *
 *  Lists the clusters in a given project and location.
 *
 *  @param parent Required. The parent location whose clusters are to be listed.
 *    Structured like `projects/{project}/locations/{location}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates the properties of a single cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersPatch : GTLRManagedKafkaQuery

/**
 *  Identifier. The name of the cluster. Structured like:
 *  projects/{project_number}/locations/{location}/clusters/{cluster_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. An optional request ID to identify requests. Specify a unique
 *  request ID to avoid duplication of requests. If a request times out or
 *  fails, retrying with the same ID allows the server to recognize the previous
 *  attempt. For at least 60 minutes, the server ignores duplicate requests
 *  bearing the same ID. For example, consider a situation where you make an
 *  initial request and the request times out. If you make the request again
 *  with the same request ID within 60 minutes of the last request, the server
 *  checks if an original operation with the same request ID was received. If
 *  so, the server ignores the second request. The request ID must be a valid
 *  UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Required. Field mask is used to specify the fields to be overwritten in the
 *  cluster resource by the update. The fields specified in the update_mask are
 *  relative to the resource, not the full request. A field will be overwritten
 *  if it is in the mask. The mask is required and a value of * will update all
 *  fields.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Updates the properties of a single cluster.
 *
 *  @param object The @c GTLRManagedKafka_Cluster to include in the query.
 *  @param name Identifier. The name of the cluster. Structured like:
 *    projects/{project_number}/locations/{location}/clusters/{cluster_id}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersPatch
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Cluster *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new topic in a given project and location.
 *
 *  Method: managedkafka.projects.locations.clusters.topics.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsCreate : GTLRManagedKafkaQuery

/**
 *  Required. The parent cluster in which to create the topic. Structured like
 *  `projects/{project}/locations/{location}/clusters/{cluster}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Required. The ID to use for the topic, which will become the final component
 *  of the topic's name. This value is structured like: `my-topic-name`.
 */
@property(nonatomic, copy, nullable) NSString *topicId;

/**
 *  Fetches a @c GTLRManagedKafka_Topic.
 *
 *  Creates a new topic in a given project and location.
 *
 *  @param object The @c GTLRManagedKafka_Topic to include in the query.
 *  @param parent Required. The parent cluster in which to create the topic.
 *    Structured like
 *    `projects/{project}/locations/{location}/clusters/{cluster}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Topic *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes a single topic.
 *
 *  Method: managedkafka.projects.locations.clusters.topics.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the topic to delete.
 *  `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Deletes a single topic.
 *
 *  @param name Required. The name of the topic to delete.
 *    `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Returns the properties of a single topic.
 *
 *  Method: managedkafka.projects.locations.clusters.topics.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the topic whose configuration to return. Structured
 *  like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Topic.
 *
 *  Returns the properties of a single topic.
 *
 *  @param name Required. The name of the topic whose configuration to return.
 *    Structured like:
 *    projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the topics in a given cluster.
 *
 *  Method: managedkafka.projects.locations.clusters.topics.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsList : GTLRManagedKafkaQuery

/**
 *  Optional. The maximum number of topics to return. The service may return
 *  fewer than this value. If unset or zero, all topics for the parent is
 *  returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. A page token, received from a previous `ListTopics` call. Provide
 *  this to retrieve the subsequent page. When paginating, all other parameters
 *  provided to `ListTopics` must match the call that provided the page token.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The parent cluster whose topics are to be listed. Structured like
 *  `projects/{project}/locations/{location}/clusters/{cluster}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_ListTopicsResponse.
 *
 *  Lists the topics in a given cluster.
 *
 *  @param parent Required. The parent cluster whose topics are to be listed.
 *    Structured like
 *    `projects/{project}/locations/{location}/clusters/{cluster}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates the properties of a single topic.
 *
 *  Method: managedkafka.projects.locations.clusters.topics.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsPatch : GTLRManagedKafkaQuery

/**
 *  Identifier. The name of the topic. The `topic` segment is used when
 *  connecting directly to the cluster. Structured like:
 *  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Field mask is used to specify the fields to be overwritten in the
 *  Topic resource by the update. The fields specified in the update_mask are
 *  relative to the resource, not the full request. A field will be overwritten
 *  if it is in the mask. The mask is required and a value of * will update all
 *  fields.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRManagedKafka_Topic.
 *
 *  Updates the properties of a single topic.
 *
 *  @param object The @c GTLRManagedKafka_Topic to include in the query.
 *  @param name Identifier. The name of the topic. The `topic` segment is used
 *    when connecting directly to the cluster. Structured like:
 *    projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsClustersTopicsPatch
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Topic *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new connector in a given Connect cluster.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsCreate : GTLRManagedKafkaQuery

/**
 *  Required. The ID to use for the connector, which will become the final
 *  component of the connector's name. The ID must be 1-63 characters long, and
 *  match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC
 *  1035. This value is structured like: `my-connector-id`.
 */
@property(nonatomic, copy, nullable) NSString *connectorId;

/**
 *  Required. The parent Connect cluster in which to create the connector.
 *  Structured like
 *  `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_Connector.
 *
 *  Creates a new connector in a given Connect cluster.
 *
 *  @param object The @c GTLRManagedKafka_Connector to include in the query.
 *  @param parent Required. The parent Connect cluster in which to create the
 *    connector. Structured like
 *    `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Connector *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes a connector.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the connector to delete. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Deletes a connector.
 *
 *  @param name Required. The name of the connector to delete. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Returns the properties of a single connector.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the connector whose configuration to return.
 *  Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Connector.
 *
 *  Returns the properties of a single connector.
 *
 *  @param name Required. The name of the connector whose configuration to
 *    return. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the connectors in a given Connect cluster.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsList : GTLRManagedKafkaQuery

/**
 *  Optional. The maximum number of connectors to return. The service may return
 *  fewer than this value. If unspecified, server will pick an appropriate
 *  default.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. A page token, received from a previous `ListConnectors` call.
 *  Provide this to retrieve the subsequent page. When paginating, all other
 *  parameters provided to `ListConnectors` must match the call that provided
 *  the page token.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The parent Connect cluster whose connectors are to be listed.
 *  Structured like
 *  `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_ListConnectorsResponse.
 *
 *  Lists the connectors in a given Connect cluster.
 *
 *  @param parent Required. The parent Connect cluster whose connectors are to
 *    be listed. Structured like
 *    `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates the properties of a connector.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsPatch : GTLRManagedKafkaQuery

/**
 *  Identifier. The name of the connector. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Field mask is used to specify the fields to be overwritten in the
 *  cluster resource by the update. The fields specified in the update_mask are
 *  relative to the resource, not the full request. A field will be overwritten
 *  if it is in the mask. The mask is required and a value of * will update all
 *  fields.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRManagedKafka_Connector.
 *
 *  Updates the properties of a connector.
 *
 *  @param object The @c GTLRManagedKafka_Connector to include in the query.
 *  @param name Identifier. The name of the connector. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsPatch
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_Connector *)object
                           name:(NSString *)name;

@end

/**
 *  Pauses the connector and its tasks.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.pause
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsPause : GTLRManagedKafkaQuery

/**
 *  Required. The name of the connector to pause. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_PauseConnectorResponse.
 *
 *  Pauses the connector and its tasks.
 *
 *  @param object The @c GTLRManagedKafka_PauseConnectorRequest to include in
 *    the query.
 *  @param name Required. The name of the connector to pause. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsPause
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_PauseConnectorRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Restarts the connector.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.restart
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsRestart : GTLRManagedKafkaQuery

/**
 *  Required. The name of the connector to restart. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_RestartConnectorResponse.
 *
 *  Restarts the connector.
 *
 *  @param object The @c GTLRManagedKafka_RestartConnectorRequest to include in
 *    the query.
 *  @param name Required. The name of the connector to restart. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsRestart
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_RestartConnectorRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Resumes the connector and its tasks.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.resume
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsResume : GTLRManagedKafkaQuery

/**
 *  Required. The name of the connector to pause. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_ResumeConnectorResponse.
 *
 *  Resumes the connector and its tasks.
 *
 *  @param object The @c GTLRManagedKafka_ResumeConnectorRequest to include in
 *    the query.
 *  @param name Required. The name of the connector to pause. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsResume
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_ResumeConnectorRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Stops the connector.
 *
 *  Method: managedkafka.projects.locations.connectClusters.connectors.stop
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsStop : GTLRManagedKafkaQuery

/**
 *  Required. The name of the connector to stop. Structured like:
 *  projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_StopConnectorResponse.
 *
 *  Stops the connector.
 *
 *  @param object The @c GTLRManagedKafka_StopConnectorRequest to include in the
 *    query.
 *  @param name Required. The name of the connector to stop. Structured like:
 *    projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersConnectorsStop
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_StopConnectorRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new Kafka Connect cluster in a given project and location.
 *
 *  Method: managedkafka.projects.locations.connectClusters.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersCreate : GTLRManagedKafkaQuery

/**
 *  Required. The ID to use for the Connect cluster, which will become the final
 *  component of the cluster's name. The ID must be 1-63 characters long, and
 *  match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC
 *  1035. This value is structured like: `my-cluster-id`.
 */
@property(nonatomic, copy, nullable) NSString *connectClusterId;

/**
 *  Required. The parent project/location in which to create the Kafka Connect
 *  cluster. Structured like `projects/{project}/locations/{location}/`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. An optional request ID to identify requests. Specify a unique
 *  request ID to avoid duplication of requests. If a request times out or
 *  fails, retrying with the same ID allows the server to recognize the previous
 *  attempt. For at least 60 minutes, the server ignores duplicate requests
 *  bearing the same ID. For example, consider a situation where you make an
 *  initial request and the request times out. If you make the request again
 *  with the same request ID within 60 minutes of the last request, the server
 *  checks if an original operation with the same request ID was received. If
 *  so, the server ignores the second request. The request ID must be a valid
 *  UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Creates a new Kafka Connect cluster in a given project and location.
 *
 *  @param object The @c GTLRManagedKafka_ConnectCluster to include in the
 *    query.
 *  @param parent Required. The parent project/location in which to create the
 *    Kafka Connect cluster. Structured like
 *    `projects/{project}/locations/{location}/`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_ConnectCluster *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes a single Connect cluster.
 *
 *  Method: managedkafka.projects.locations.connectClusters.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the Kafka Connect cluster to delete. Structured like
 *  `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. An optional request ID to identify requests. Specify a unique
 *  request ID to avoid duplication of requests. If a request times out or
 *  fails, retrying with the same ID allows the server to recognize the previous
 *  attempt. For at least 60 minutes, the server ignores duplicate requests
 *  bearing the same ID. For example, consider a situation where you make an
 *  initial request and the request times out. If you make the request again
 *  with the same request ID within 60 minutes of the last request, the server
 *  checks if an original operation with the same request ID was received. If
 *  so, the server ignores the second request. The request ID must be a valid
 *  UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Deletes a single Connect cluster.
 *
 *  @param name Required. The name of the Kafka Connect cluster to delete.
 *    Structured like
 *    `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Returns the properties of a single Kafka Connect cluster.
 *
 *  Method: managedkafka.projects.locations.connectClusters.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the Kafka Connect cluster whose configuration to
 *  return. Structured like
 *  `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_ConnectCluster.
 *
 *  Returns the properties of a single Kafka Connect cluster.
 *
 *  @param name Required. The name of the Kafka Connect cluster whose
 *    configuration to return. Structured like
 *    `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the Kafka Connect clusters in a given project and location.
 *
 *  Method: managedkafka.projects.locations.connectClusters.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersList : GTLRManagedKafkaQuery

/** Optional. Filter expression for the result. */
@property(nonatomic, copy, nullable) NSString *filter;

/** Optional. Order by fields for the result. */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Optional. The maximum number of Connect clusters to return. The service may
 *  return fewer than this value. If unspecified, server will pick an
 *  appropriate default.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. A page token, received from a previous `ListConnectClusters` call.
 *  Provide this to retrieve the subsequent page. When paginating, all other
 *  parameters provided to `ListConnectClusters` must match the call that
 *  provided the page token.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The parent project/location whose Connect clusters are to be
 *  listed. Structured like `projects/{project}/locations/{location}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_ListConnectClustersResponse.
 *
 *  Lists the Kafka Connect clusters in a given project and location.
 *
 *  @param parent Required. The parent project/location whose Connect clusters
 *    are to be listed. Structured like
 *    `projects/{project}/locations/{location}`.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates the properties of a single Kafka Connect cluster.
 *
 *  Method: managedkafka.projects.locations.connectClusters.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersPatch : GTLRManagedKafkaQuery

/**
 *  Identifier. The name of the Kafka Connect cluster. Structured like:
 *  projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. An optional request ID to identify requests. Specify a unique
 *  request ID to avoid duplication of requests. If a request times out or
 *  fails, retrying with the same ID allows the server to recognize the previous
 *  attempt. For at least 60 minutes, the server ignores duplicate requests
 *  bearing the same ID. For example, consider a situation where you make an
 *  initial request and the request times out. If you make the request again
 *  with the same request ID within 60 minutes of the last request, the server
 *  checks if an original operation with the same request ID was received. If
 *  so, the server ignores the second request. The request ID must be a valid
 *  UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Required. Field mask is used to specify the fields to be overwritten in the
 *  cluster resource by the update. The fields specified in the update_mask are
 *  relative to the resource, not the full request. A field will be overwritten
 *  if it is in the mask. The mask is required and a value of * will update all
 *  fields.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Updates the properties of a single Kafka Connect cluster.
 *
 *  @param object The @c GTLRManagedKafka_ConnectCluster to include in the
 *    query.
 *  @param name Identifier. The name of the Kafka Connect cluster. Structured
 *    like:
 *    projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsConnectClustersPatch
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_ConnectCluster *)object
                           name:(NSString *)name;

@end

/**
 *  Gets information about a location.
 *
 *  Method: managedkafka.projects.locations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsGet : GTLRManagedKafkaQuery

/** Resource name for the location. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Location.
 *
 *  Gets information about a location.
 *
 *  @param name Resource name for the location.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists information about the supported locations for this service.
 *
 *  Method: managedkafka.projects.locations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsList : GTLRManagedKafkaQuery

/**
 *  Optional. Do not use this field. It is unsupported and is ignored unless
 *  explicitly documented otherwise. This is primarily for internal usage.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *extraLocationTypes;

/**
 *  A filter to narrow down results to a preferred subset. The filtering
 *  language accepts strings like `"displayName=tokyo"`, and is documented in
 *  more detail in [AIP-160](https://google.aip.dev/160).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The resource that owns the locations collection, if applicable. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The maximum number of results to return. If not set, the service selects a
 *  default.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  A page token received from the `next_page_token` field in the response. Send
 *  that page token to receive the subsequent page.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRManagedKafka_ListLocationsResponse.
 *
 *  Lists information about the supported locations for this service.
 *
 *  @param name The resource that owns the locations collection, if applicable.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Starts asynchronous cancellation on a long-running operation. The server
 *  makes a best effort to cancel the operation, but success is not guaranteed.
 *  If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or
 *  other methods to check whether the cancellation succeeded or whether the
 *  operation completed despite cancellation. On successful cancellation, the
 *  operation is not deleted; instead, it becomes an operation with an
 *  Operation.error value with a google.rpc.Status.code of `1`, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Method: managedkafka.projects.locations.operations.cancel
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsOperationsCancel : GTLRManagedKafkaQuery

/** The name of the operation resource to be cancelled. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Starts asynchronous cancellation on a long-running operation. The server
 *  makes a best effort to cancel the operation, but success is not guaranteed.
 *  If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or
 *  other methods to check whether the cancellation succeeded or whether the
 *  operation completed despite cancellation. On successful cancellation, the
 *  operation is not deleted; instead, it becomes an operation with an
 *  Operation.error value with a google.rpc.Status.code of `1`, corresponding to
 *  `Code.CANCELLED`.
 *
 *  @param object The @c GTLRManagedKafka_CancelOperationRequest to include in
 *    the query.
 *  @param name The name of the operation resource to be cancelled.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsOperationsCancel
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_CancelOperationRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes a long-running operation. This method indicates that the client is
 *  no longer interested in the operation result. It does not cancel the
 *  operation. If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`.
 *
 *  Method: managedkafka.projects.locations.operations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsOperationsDelete : GTLRManagedKafkaQuery

/** The name of the operation resource to be deleted. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Deletes a long-running operation. This method indicates that the client is
 *  no longer interested in the operation result. It does not cancel the
 *  operation. If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`.
 *
 *  @param name The name of the operation resource to be deleted.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsOperationsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets the latest state of a long-running operation. Clients can use this
 *  method to poll the operation result at intervals as recommended by the API
 *  service.
 *
 *  Method: managedkafka.projects.locations.operations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsOperationsGet : GTLRManagedKafkaQuery

/** The name of the operation resource. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Operation.
 *
 *  Gets the latest state of a long-running operation. Clients can use this
 *  method to poll the operation result at intervals as recommended by the API
 *  service.
 *
 *  @param name The name of the operation resource.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsOperationsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists operations that match the specified filter in the request. If the
 *  server doesn't support this method, it returns `UNIMPLEMENTED`.
 *
 *  Method: managedkafka.projects.locations.operations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsOperationsList : GTLRManagedKafkaQuery

/** The standard list filter. */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the operation's parent resource. */
@property(nonatomic, copy, nullable) NSString *name;

/** The standard list page size. */
@property(nonatomic, assign) NSInteger pageSize;

/** The standard list page token. */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  When set to `true`, operations that are reachable are returned as normal,
 *  and those that are unreachable are returned in the
 *  [ListOperationsResponse.unreachable] field. This can only be `true` when
 *  reading across collections e.g. when `parent` is set to
 *  `"projects/example/locations/-"`. This field is not by default supported and
 *  will result in an `UNIMPLEMENTED` error if set unless explicitly documented
 *  otherwise in service or product specific documentation.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRManagedKafka_ListOperationsResponse.
 *
 *  Lists operations that match the specified filter in the request. If the
 *  server doesn't support this method, it returns `UNIMPLEMENTED`.
 *
 *  @param name The name of the operation's parent resource.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Check compatibility of a schema with all versions or a specific version of a
 *  subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.compatibility.checkCompatibility
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibility : GTLRManagedKafkaQuery

/**
 *  Required. The name of the resource to check compatibility for. The format is
 *  either of following: *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/
 *  * /versions: Check compatibility with one or more versions of the specified
 *  subject. *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}:
 *  Check compatibility with a specific version of the subject.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_CheckCompatibilityResponse.
 *
 *  Check compatibility of a schema with all versions or a specific version of a
 *  subject.
 *
 *  @param object The @c GTLRManagedKafka_CheckCompatibilityRequest to include
 *    in the query.
 *  @param name Required. The name of the resource to check compatibility for.
 *    The format is either of following: *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/
 *    * /versions: Check compatibility with one or more versions of the
 *    specified subject. *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}:
 *    Check compatibility with a specific version of the subject.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibility
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_CheckCompatibilityRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Delete schema config for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.config.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesConfigDelete : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of subject to delete the config for. The format
 *  is *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaConfig.
 *
 *  Delete schema config for a subject.
 *
 *  @param name Required. The resource name of subject to delete the config for.
 *    The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesConfigDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get schema config at global level or for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.config.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesConfigGet : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the config will fall back to the config at the global
 *  level if no subject level config is found.
 */
@property(nonatomic, assign) BOOL defaultToGlobal;

/**
 *  Required. The resource name to get the config for. It can be either of
 *  following: *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *  Get config at global level. *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *  Get config for a specific subject.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaConfig.
 *
 *  Get schema config at global level or for a subject.
 *
 *  @param name Required. The resource name to get the config for. It can be
 *    either of following: *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *    Get config at global level. *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *    Get config for a specific subject.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesConfigGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Update config at global level or for a subject. Creates a
 *  SchemaSubject-level SchemaConfig if it does not exist.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.config.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesConfigUpdate : GTLRManagedKafkaQuery

/**
 *  Required. The resource name to update the config for. It can be either of
 *  following: *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *  Update config at global level. *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *  Update config for a specific subject.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaConfig.
 *
 *  Update config at global level or for a subject. Creates a
 *  SchemaSubject-level SchemaConfig if it does not exist.
 *
 *  @param object The @c GTLRManagedKafka_UpdateSchemaConfigRequest to include
 *    in the query.
 *  @param name Required. The resource name to update the config for. It can be
 *    either of following: *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *    Update config at global level. *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *    Update config for a specific subject.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesConfigUpdate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_UpdateSchemaConfigRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Check compatibility of a schema with all versions or a specific version of a
 *  subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.compatibility.checkCompatibility
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibility : GTLRManagedKafkaQuery

/**
 *  Required. The name of the resource to check compatibility for. The format is
 *  either of following: *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/
 *  * /versions: Check compatibility with one or more versions of the specified
 *  subject. *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}:
 *  Check compatibility with a specific version of the subject.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_CheckCompatibilityResponse.
 *
 *  Check compatibility of a schema with all versions or a specific version of a
 *  subject.
 *
 *  @param object The @c GTLRManagedKafka_CheckCompatibilityRequest to include
 *    in the query.
 *  @param name Required. The name of the resource to check compatibility for.
 *    The format is either of following: *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/
 *    * /versions: Check compatibility with one or more versions of the
 *    specified subject. *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}:
 *    Check compatibility with a specific version of the subject.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibility
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_CheckCompatibilityRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Delete schema config for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.config.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsConfigDelete : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of subject to delete the config for. The format
 *  is *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaConfig.
 *
 *  Delete schema config for a subject.
 *
 *  @param name Required. The resource name of subject to delete the config for.
 *    The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsConfigDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get schema config at global level or for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.config.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsConfigGet : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the config will fall back to the config at the global
 *  level if no subject level config is found.
 */
@property(nonatomic, assign) BOOL defaultToGlobal;

/**
 *  Required. The resource name to get the config for. It can be either of
 *  following: *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *  Get config at global level. *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *  Get config for a specific subject.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaConfig.
 *
 *  Get schema config at global level or for a subject.
 *
 *  @param name Required. The resource name to get the config for. It can be
 *    either of following: *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *    Get config at global level. *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *    Get config for a specific subject.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsConfigGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Update config at global level or for a subject. Creates a
 *  SchemaSubject-level SchemaConfig if it does not exist.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.config.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsConfigUpdate : GTLRManagedKafkaQuery

/**
 *  Required. The resource name to update the config for. It can be either of
 *  following: *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *  Update config at global level. *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *  Update config for a specific subject.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaConfig.
 *
 *  Update config at global level or for a subject. Creates a
 *  SchemaSubject-level SchemaConfig if it does not exist.
 *
 *  @param object The @c GTLRManagedKafka_UpdateSchemaConfigRequest to include
 *    in the query.
 *  @param name Required. The resource name to update the config for. It can be
 *    either of following: *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config:
 *    Update config at global level. *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}:
 *    Update config for a specific subject.
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsConfigUpdate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_UpdateSchemaConfigRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Get the context.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the context to return. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Context.
 *
 *  Get the context.
 *
 *  @param name Required. The name of the context to return. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List contexts for a schema registry.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsList : GTLRManagedKafkaQuery

/**
 *  Required. The parent of the contexts. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List contexts for a schema registry.
 *
 *  @param parent Required. The parent of the contexts. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Delete schema mode for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.mode.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsModeDelete : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of subject to delete the mode for. The format is
 *  *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
 *  *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaMode.
 *
 *  Delete schema mode for a subject.
 *
 *  @param name Required. The resource name of subject to delete the mode for.
 *    The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
 *    *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsModeDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get mode at global level or for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.mode.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsModeGet : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of the mode. The format is *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *  mode for a schema registry, or *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *  mode for a specific subject in a specific context
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaMode.
 *
 *  Get mode at global level or for a subject.
 *
 *  @param name Required. The resource name of the mode. The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *    mode for a schema registry, or *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *    mode for a specific subject in a specific context
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsModeGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Update mode at global level or for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.mode.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsModeUpdate : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of the mode. The format is *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *  mode for a schema registry, or *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *  mode for a specific subject in a specific context
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaMode.
 *
 *  Update mode at global level or for a subject.
 *
 *  @param object The @c GTLRManagedKafka_UpdateSchemaModeRequest to include in
 *    the query.
 *  @param name Required. The resource name of the mode. The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *    mode for a schema registry, or *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *    mode for a specific subject in a specific context
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsModeUpdate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_UpdateSchemaModeRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Get the schema for the given schema id.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.schemas.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the schema to return. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Used to limit the search for the schema ID to a specific subject,
 *  otherwise the schema ID will be searched for in all subjects in the given
 *  specified context.
 */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_Schema.
 *
 *  Get the schema for the given schema id.
 *
 *  @param name Required. The name of the schema to return. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get the schema string for the given schema id. The response will be the
 *  schema string.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.schemas.getSchema
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasGetSchema : GTLRManagedKafkaQuery

/**
 *  Required. The name of the schema to return. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Used to limit the search for the schema ID to a specific subject,
 *  otherwise the schema ID will be searched for in all subjects in the given
 *  specified context.
 */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get the schema string for the given schema id. The response will be the
 *  schema string.
 *
 *  @param name Required. The name of the schema to return. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasGetSchema
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List subjects which reference a particular schema id. The response will be
 *  an array of subject names.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.schemas.subjects.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted subjects. The
 *  default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The schema resource whose associated subjects are to be listed.
 *  Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/** Optional. The subject to filter the subjects by. */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List subjects which reference a particular schema id. The response will be
 *  an array of subject names.
 *
 *  @param parent Required. The schema resource whose associated subjects are to
 *    be listed. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  List the supported schema types. The response will be an array of schema
 *  types.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.schemas.types.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasTypesList : GTLRManagedKafkaQuery

/**
 *  Required. The parent schema registry whose schema types are to be listed.
 *  Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List the supported schema types. The response will be an array of schema
 *  types.
 *
 *  @param parent Required. The parent schema registry whose schema types are to
 *    be listed. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasTypesList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  List the schema versions for the given schema id. The response will be an
 *  array of subject-version pairs as: [{"subject":"subject1", "version":1},
 *  {"subject":"subject2", "version":2}].
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.schemas.versions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasVersionsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted versions of the
 *  schema, even if the subject is soft-deleted. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The schema whose schema versions are to be listed. Structured
 *  like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/** Optional. The subject to filter the subjects by. */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List the schema versions for the given schema id. The response will be an
 *  array of subject-version pairs as: [{"subject":"subject1", "version":1},
 *  {"subject":"subject2", "version":2}].
 *
 *  @param parent Required. The schema whose schema versions are to be listed.
 *    Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSchemasVersionsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Delete a subject. The response will be an array of versions of the deleted
 *  subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the subject to delete. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. If true, the subject and all associated metadata including the
 *  schema ID will be deleted permanently. Otherwise, only the subject is
 *  soft-deleted. The default is false. Soft-deleted subjects can still be
 *  searched in ListSubjects API call with deleted=true query parameter. A
 *  soft-delete of a subject must be performed before a hard-delete.
 */
@property(nonatomic, assign) BOOL permanent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Delete a subject. The response will be an array of versions of the deleted
 *  subject.
 *
 *  @param name Required. The name of the subject to delete. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List subjects in the schema registry. The response will be an array of
 *  subject names.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted subjects. The
 *  default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The parent schema registry/context whose subjects are to be
 *  listed. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. The context to filter the subjects by, in the format of
 *  `:.{context}:`. If unset, all subjects in the registry are returned. Set to
 *  empty string or add as '?subjectPrefix=' at the end of this request to list
 *  subjects in the default context.
 */
@property(nonatomic, copy, nullable) NSString *subjectPrefix;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List subjects in the schema registry. The response will be an array of
 *  subject names.
 *
 *  @param parent Required. The parent schema registry/context whose subjects
 *    are to be listed. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Lookup a schema under the specified subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.lookupVersion
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersion : GTLRManagedKafkaQuery

/**
 *  Required. The subject to lookup the schema in. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaVersion.
 *
 *  Lookup a schema under the specified subject.
 *
 *  @param object The @c GTLRManagedKafka_LookupVersionRequest to include in the
 *    query.
 *  @param parent Required. The subject to lookup the schema in. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersion
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_LookupVersionRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Register a new version under a given subject with the given schema.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreate : GTLRManagedKafkaQuery

/**
 *  Required. The subject to create the version for. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_CreateVersionResponse.
 *
 *  Register a new version under a given subject with the given schema.
 *
 *  @param object The @c GTLRManagedKafka_CreateVersionRequest to include in the
 *    query.
 *  @param parent Required. The subject to create the version for. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_CreateVersionRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Delete a version of a subject. The response will be the deleted version id.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the subject version to delete. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. If true, both the version and the referenced schema ID will be
 *  permanently deleted. The default is false. If false, the version will be
 *  deleted but the schema ID will be retained. Soft-deleted versions can still
 *  be searched in ListVersions API call with deleted=true query parameter. A
 *  soft-delete of a version must be performed before a hard-delete.
 */
@property(nonatomic, assign) BOOL permanent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Delete a version of a subject. The response will be the deleted version id.
 *
 *  @param name Required. The name of the subject version to delete. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get a versioned schema (schema with subject/version) of a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGet : GTLRManagedKafkaQuery

/**
 *  Optional. If true, no matter if the subject/version is soft-deleted or not,
 *  it returns the version details. If false, it returns NOT_FOUND error if the
 *  subject/version is soft-deleted. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The name of the subject to return versions. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaVersion.
 *
 *  Get a versioned schema (schema with subject/version) of a subject.
 *
 *  @param name Required. The name of the subject to return versions. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get the schema string only for a version of a subject. The response will be
 *  the schema string.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.getSchema
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchema : GTLRManagedKafkaQuery

/**
 *  Optional. If true, no matter if the subject/version is soft-deleted or not,
 *  it returns the version details. If false, it returns NOT_FOUND error if the
 *  subject/version is soft-deleted. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The name of the subject to return versions. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get the schema string only for a version of a subject. The response will be
 *  the schema string.
 *
 *  @param name Required. The name of the subject to return versions. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchema
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get all versions of a subject. The response will be an array of versions of
 *  the subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted versions of an
 *  active or soft-deleted subject. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The subject whose versions are to be listed. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get all versions of a subject. The response will be an array of versions of
 *  the subject.
 *
 *  @param parent Required. The subject whose versions are to be listed.
 *    Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Get a list of IDs of schemas that reference the schema with the given
 *  subject and version.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.referencedby.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyList : GTLRManagedKafkaQuery

/**
 *  Required. The version to list referenced by. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get a list of IDs of schemas that reference the schema with the given
 *  subject and version.
 *
 *  @param parent Required. The version to list referenced by. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Create a schema registry instance.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesCreate : GTLRManagedKafkaQuery

/**
 *  Required. The parent whose schema registry instance is to be created.
 *  Structured like: `projects/{project}/locations/{location}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaRegistry.
 *
 *  Create a schema registry instance.
 *
 *  @param object The @c GTLRManagedKafka_CreateSchemaRegistryRequest to include
 *    in the query.
 *  @param parent Required. The parent whose schema registry instance is to be
 *    created. Structured like: `projects/{project}/locations/{location}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_CreateSchemaRegistryRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Delete a schema registry instance.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the schema registry instance to delete. Structured
 *  like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_Empty.
 *
 *  Delete a schema registry instance.
 *
 *  @param name Required. The name of the schema registry instance to delete.
 *    Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get the schema registry instance.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the schema registry instance to return. Structured
 *  like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaRegistry.
 *
 *  Get the schema registry instance.
 *
 *  @param name Required. The name of the schema registry instance to return.
 *    Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List schema registries.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesList : GTLRManagedKafkaQuery

/**
 *  Required. The parent whose schema registry instances are to be listed.
 *  Structured like: `projects/{project}/locations/{location}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. Specifies the view to return for the schema registry instances. If
 *  not specified, the default view is SCHEMA_REGISTRY_VIEW_BASIC.
 *
 *  Likely values:
 *    @arg @c kGTLRManagedKafkaViewSchemaRegistryViewUnspecified The unset
 *        value. The API will default to SCHEMA_REGISTRY_VIEW_BASIC. (Value:
 *        "SCHEMA_REGISTRY_VIEW_UNSPECIFIED")
 *    @arg @c kGTLRManagedKafkaViewSchemaRegistryViewBasic If SchemaRegistryView
 *        is not specified, this is the default value. Returns only the name of
 *        the schema registry. The contexts associated with it are not included.
 *        (Value: "SCHEMA_REGISTRY_VIEW_BASIC")
 *    @arg @c kGTLRManagedKafkaViewSchemaRegistryViewFull Returns the name of
 *        the schema registry and all the contexts associated with it. (Value:
 *        "SCHEMA_REGISTRY_VIEW_FULL")
 */
@property(nonatomic, copy, nullable) NSString *view;

/**
 *  Fetches a @c GTLRManagedKafka_ListSchemaRegistriesResponse.
 *
 *  List schema registries.
 *
 *  @param parent Required. The parent whose schema registry instances are to be
 *    listed. Structured like: `projects/{project}/locations/{location}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Delete schema mode for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.mode.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesModeDelete : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of subject to delete the mode for. The format is
 *  *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
 *  *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaMode.
 *
 *  Delete schema mode for a subject.
 *
 *  @param name Required. The resource name of subject to delete the mode for.
 *    The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
 *    *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesModeDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get mode at global level or for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.mode.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesModeGet : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of the mode. The format is *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *  mode for a schema registry, or *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *  mode for a specific subject in a specific context
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaMode.
 *
 *  Get mode at global level or for a subject.
 *
 *  @param name Required. The resource name of the mode. The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *    mode for a schema registry, or *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *    mode for a specific subject in a specific context
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesModeGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Update mode at global level or for a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.mode.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesModeUpdate : GTLRManagedKafkaQuery

/**
 *  Required. The resource name of the mode. The format is *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *  mode for a schema registry, or *
 *  projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *  mode for a specific subject in a specific context
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaMode.
 *
 *  Update mode at global level or for a subject.
 *
 *  @param object The @c GTLRManagedKafka_UpdateSchemaModeRequest to include in
 *    the query.
 *  @param name Required. The resource name of the mode. The format is *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}:
 *    mode for a schema registry, or *
 *    projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}:
 *    mode for a specific subject in a specific context
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesModeUpdate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_UpdateSchemaModeRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Get the schema for the given schema id.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.schemas.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasGet : GTLRManagedKafkaQuery

/**
 *  Required. The name of the schema to return. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Used to limit the search for the schema ID to a specific subject,
 *  otherwise the schema ID will be searched for in all subjects in the given
 *  specified context.
 */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_Schema.
 *
 *  Get the schema for the given schema id.
 *
 *  @param name Required. The name of the schema to return. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get the schema string for the given schema id. The response will be the
 *  schema string.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.schemas.getSchema
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasGetSchema : GTLRManagedKafkaQuery

/**
 *  Required. The name of the schema to return. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Used to limit the search for the schema ID to a specific subject,
 *  otherwise the schema ID will be searched for in all subjects in the given
 *  specified context.
 */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get the schema string for the given schema id. The response will be the
 *  schema string.
 *
 *  @param name Required. The name of the schema to return. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasGetSchema
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List subjects which reference a particular schema id. The response will be
 *  an array of subject names.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.schemas.subjects.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasSubjectsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted subjects. The
 *  default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The schema resource whose associated subjects are to be listed.
 *  Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/** Optional. The subject to filter the subjects by. */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List subjects which reference a particular schema id. The response will be
 *  an array of subject names.
 *
 *  @param parent Required. The schema resource whose associated subjects are to
 *    be listed. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasSubjectsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  List the supported schema types. The response will be an array of schema
 *  types.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.schemas.types.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasTypesList : GTLRManagedKafkaQuery

/**
 *  Required. The parent schema registry whose schema types are to be listed.
 *  Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List the supported schema types. The response will be an array of schema
 *  types.
 *
 *  @param parent Required. The parent schema registry whose schema types are to
 *    be listed. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasTypesList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  List the schema versions for the given schema id. The response will be an
 *  array of subject-version pairs as: [{"subject":"subject1", "version":1},
 *  {"subject":"subject2", "version":2}].
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.schemas.versions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasVersionsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted versions of the
 *  schema, even if the subject is soft-deleted. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The schema whose schema versions are to be listed. Structured
 *  like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/** Optional. The subject to filter the subjects by. */
@property(nonatomic, copy, nullable) NSString *subject;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List the schema versions for the given schema id. The response will be an
 *  array of subject-version pairs as: [{"subject":"subject1", "version":1},
 *  {"subject":"subject2", "version":2}].
 *
 *  @param parent Required. The schema whose schema versions are to be listed.
 *    Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSchemasVersionsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Delete a subject. The response will be an array of versions of the deleted
 *  subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the subject to delete. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. If true, the subject and all associated metadata including the
 *  schema ID will be deleted permanently. Otherwise, only the subject is
 *  soft-deleted. The default is false. Soft-deleted subjects can still be
 *  searched in ListSubjects API call with deleted=true query parameter. A
 *  soft-delete of a subject must be performed before a hard-delete.
 */
@property(nonatomic, assign) BOOL permanent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Delete a subject. The response will be an array of versions of the deleted
 *  subject.
 *
 *  @param name Required. The name of the subject to delete. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List subjects in the schema registry. The response will be an array of
 *  subject names.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted subjects. The
 *  default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The parent schema registry/context whose subjects are to be
 *  listed. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. The context to filter the subjects by, in the format of
 *  `:.{context}:`. If unset, all subjects in the registry are returned. Set to
 *  empty string or add as '?subjectPrefix=' at the end of this request to list
 *  subjects in the default context.
 */
@property(nonatomic, copy, nullable) NSString *subjectPrefix;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  List subjects in the schema registry. The response will be an array of
 *  subject names.
 *
 *  @param parent Required. The parent schema registry/context whose subjects
 *    are to be listed. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Lookup a schema under the specified subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.lookupVersion
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsLookupVersion : GTLRManagedKafkaQuery

/**
 *  Required. The subject to lookup the schema in. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaVersion.
 *
 *  Lookup a schema under the specified subject.
 *
 *  @param object The @c GTLRManagedKafka_LookupVersionRequest to include in the
 *    query.
 *  @param parent Required. The subject to lookup the schema in. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsLookupVersion
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_LookupVersionRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Register a new version under a given subject with the given schema.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.versions.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsCreate : GTLRManagedKafkaQuery

/**
 *  Required. The subject to create the version for. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_CreateVersionResponse.
 *
 *  Register a new version under a given subject with the given schema.
 *
 *  @param object The @c GTLRManagedKafka_CreateVersionRequest to include in the
 *    query.
 *  @param parent Required. The subject to create the version for. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsCreate
 */
+ (instancetype)queryWithObject:(GTLRManagedKafka_CreateVersionRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Delete a version of a subject. The response will be the deleted version id.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.versions.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsDelete : GTLRManagedKafkaQuery

/**
 *  Required. The name of the subject version to delete. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. If true, both the version and the referenced schema ID will be
 *  permanently deleted. The default is false. If false, the version will be
 *  deleted but the schema ID will be retained. Soft-deleted versions can still
 *  be searched in ListVersions API call with deleted=true query parameter. A
 *  soft-delete of a version must be performed before a hard-delete.
 */
@property(nonatomic, assign) BOOL permanent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Delete a version of a subject. The response will be the deleted version id.
 *
 *  @param name Required. The name of the subject version to delete. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get a versioned schema (schema with subject/version) of a subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.versions.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsGet : GTLRManagedKafkaQuery

/**
 *  Optional. If true, no matter if the subject/version is soft-deleted or not,
 *  it returns the version details. If false, it returns NOT_FOUND error if the
 *  subject/version is soft-deleted. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The name of the subject to return versions. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_SchemaVersion.
 *
 *  Get a versioned schema (schema with subject/version) of a subject.
 *
 *  @param name Required. The name of the subject to return versions. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get the schema string only for a version of a subject. The response will be
 *  the schema string.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.versions.getSchema
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchema : GTLRManagedKafkaQuery

/**
 *  Optional. If true, no matter if the subject/version is soft-deleted or not,
 *  it returns the version details. If false, it returns NOT_FOUND error if the
 *  subject/version is soft-deleted. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The name of the subject to return versions. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get the schema string only for a version of a subject. The response will be
 *  the schema string.
 *
 *  @param name Required. The name of the subject to return versions. Structured
 *    like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchema
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get all versions of a subject. The response will be an array of versions of
 *  the subject.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.versions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsList : GTLRManagedKafkaQuery

/**
 *  Optional. If true, the response will include soft-deleted versions of an
 *  active or soft-deleted subject. The default is false.
 */
@property(nonatomic, assign) BOOL deleted;

/**
 *  Required. The subject whose versions are to be listed. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get all versions of a subject. The response will be an array of versions of
 *  the subject.
 *
 *  @param parent Required. The subject whose versions are to be listed.
 *    Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Get a list of IDs of schemas that reference the schema with the given
 *  subject and version.
 *
 *  Method: managedkafka.projects.locations.schemaRegistries.subjects.versions.referencedby.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeManagedKafkaCloudPlatform
 */
@interface GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyList : GTLRManagedKafkaQuery

/**
 *  Required. The version to list referenced by. Structured like:
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *  or
 *  `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRManagedKafka_HttpBody.
 *
 *  Get a list of IDs of schemas that reference the schema with the given
 *  subject and version.
 *
 *  @param parent Required. The version to list referenced by. Structured like:
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *    or
 *    `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 *
 *  @return GTLRManagedKafkaQuery_ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyList
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
