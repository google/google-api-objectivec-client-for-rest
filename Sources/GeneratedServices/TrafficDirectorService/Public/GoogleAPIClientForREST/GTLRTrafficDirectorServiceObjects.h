// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Traffic Director API (trafficdirector/v3)
// Documentation:
//   https://cloud.google.com/traffic-director

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRTrafficDirectorService_Address;
@class GTLRTrafficDirectorService_BuildVersion;
@class GTLRTrafficDirectorService_BuildVersion_Metadata;
@class GTLRTrafficDirectorService_ClientConfig;
@class GTLRTrafficDirectorService_ClustersConfigDump;
@class GTLRTrafficDirectorService_ContextParams;
@class GTLRTrafficDirectorService_ContextParams_Params;
@class GTLRTrafficDirectorService_DoubleMatcher;
@class GTLRTrafficDirectorService_DoubleRange;
@class GTLRTrafficDirectorService_DynamicCluster;
@class GTLRTrafficDirectorService_DynamicCluster_Cluster;
@class GTLRTrafficDirectorService_DynamicEndpointConfig;
@class GTLRTrafficDirectorService_DynamicEndpointConfig_EndpointConfig;
@class GTLRTrafficDirectorService_DynamicListener;
@class GTLRTrafficDirectorService_DynamicListenerState;
@class GTLRTrafficDirectorService_DynamicListenerState_Listener;
@class GTLRTrafficDirectorService_DynamicRouteConfig;
@class GTLRTrafficDirectorService_DynamicRouteConfig_RouteConfig;
@class GTLRTrafficDirectorService_DynamicScopedRouteConfigs;
@class GTLRTrafficDirectorService_DynamicScopedRouteConfigs_ScopedRouteConfigs_Item;
@class GTLRTrafficDirectorService_EndpointsConfigDump;
@class GTLRTrafficDirectorService_EnvoyInternalAddress;
@class GTLRTrafficDirectorService_Extension;
@class GTLRTrafficDirectorService_GenericXdsConfig;
@class GTLRTrafficDirectorService_GenericXdsConfig_XdsConfig;
@class GTLRTrafficDirectorService_GoogleRE2;
@class GTLRTrafficDirectorService_InlineScopedRouteConfigs;
@class GTLRTrafficDirectorService_InlineScopedRouteConfigs_ScopedRouteConfigs_Item;
@class GTLRTrafficDirectorService_ListenersConfigDump;
@class GTLRTrafficDirectorService_ListMatcher;
@class GTLRTrafficDirectorService_Locality;
@class GTLRTrafficDirectorService_Node;
@class GTLRTrafficDirectorService_Node_DynamicParameters;
@class GTLRTrafficDirectorService_Node_Metadata;
@class GTLRTrafficDirectorService_NodeMatcher;
@class GTLRTrafficDirectorService_NullMatch;
@class GTLRTrafficDirectorService_OrMatcher;
@class GTLRTrafficDirectorService_PathSegment;
@class GTLRTrafficDirectorService_PerXdsConfig;
@class GTLRTrafficDirectorService_Pipe;
@class GTLRTrafficDirectorService_RegexMatcher;
@class GTLRTrafficDirectorService_RoutesConfigDump;
@class GTLRTrafficDirectorService_ScopedRoutesConfigDump;
@class GTLRTrafficDirectorService_SemanticVersion;
@class GTLRTrafficDirectorService_SocketAddress;
@class GTLRTrafficDirectorService_StaticCluster;
@class GTLRTrafficDirectorService_StaticCluster_Cluster;
@class GTLRTrafficDirectorService_StaticEndpointConfig;
@class GTLRTrafficDirectorService_StaticEndpointConfig_EndpointConfig;
@class GTLRTrafficDirectorService_StaticListener;
@class GTLRTrafficDirectorService_StaticListener_Listener;
@class GTLRTrafficDirectorService_StaticRouteConfig;
@class GTLRTrafficDirectorService_StaticRouteConfig_RouteConfig;
@class GTLRTrafficDirectorService_StringMatcher;
@class GTLRTrafficDirectorService_StructMatcher;
@class GTLRTrafficDirectorService_TypedExtensionConfig;
@class GTLRTrafficDirectorService_TypedExtensionConfig_TypedConfig;
@class GTLRTrafficDirectorService_UpdateFailureState;
@class GTLRTrafficDirectorService_UpdateFailureState_FailedConfiguration;
@class GTLRTrafficDirectorService_ValueMatcher;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_DynamicCluster.clientStatus

/**
 *  Client received this resource and replied with ACK.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Acked;
/**
 *  This resource has been requested by the client but has either not been
 *  delivered by the server or was previously delivered by the server and then
 *  subsequently removed from resources provided by the server. For more
 *  information, please refer to the :ref:`"Knowing When a Requested Resource
 *  Does Not Exist" ` section.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_DoesNotExist;
/**
 *  Client received this resource and replied with NACK.
 *
 *  Value: "NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Nacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_ReceivedError;
/**
 *  Client requested this resource but hasn't received any update from
 *  management server. The client will not fail requests, but will queue them
 *  until update arrives or the client times out waiting for the resource.
 *
 *  Value: "REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Requested;
/**
 *  Client timed out waiting for the resource from the control plane.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Timeout;
/**
 *  Resource status is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_DynamicEndpointConfig.clientStatus

/**
 *  Client received this resource and replied with ACK.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Acked;
/**
 *  This resource has been requested by the client but has either not been
 *  delivered by the server or was previously delivered by the server and then
 *  subsequently removed from resources provided by the server. For more
 *  information, please refer to the :ref:`"Knowing When a Requested Resource
 *  Does Not Exist" ` section.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_DoesNotExist;
/**
 *  Client received this resource and replied with NACK.
 *
 *  Value: "NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Nacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_ReceivedError;
/**
 *  Client requested this resource but hasn't received any update from
 *  management server. The client will not fail requests, but will queue them
 *  until update arrives or the client times out waiting for the resource.
 *
 *  Value: "REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Requested;
/**
 *  Client timed out waiting for the resource from the control plane.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Timeout;
/**
 *  Resource status is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_DynamicListener.clientStatus

/**
 *  Client received this resource and replied with ACK.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Acked;
/**
 *  This resource has been requested by the client but has either not been
 *  delivered by the server or was previously delivered by the server and then
 *  subsequently removed from resources provided by the server. For more
 *  information, please refer to the :ref:`"Knowing When a Requested Resource
 *  Does Not Exist" ` section.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_DoesNotExist;
/**
 *  Client received this resource and replied with NACK.
 *
 *  Value: "NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Nacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_ReceivedError;
/**
 *  Client requested this resource but hasn't received any update from
 *  management server. The client will not fail requests, but will queue them
 *  until update arrives or the client times out waiting for the resource.
 *
 *  Value: "REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Requested;
/**
 *  Client timed out waiting for the resource from the control plane.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Timeout;
/**
 *  Resource status is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_DynamicRouteConfig.clientStatus

/**
 *  Client received this resource and replied with ACK.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Acked;
/**
 *  This resource has been requested by the client but has either not been
 *  delivered by the server or was previously delivered by the server and then
 *  subsequently removed from resources provided by the server. For more
 *  information, please refer to the :ref:`"Knowing When a Requested Resource
 *  Does Not Exist" ` section.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_DoesNotExist;
/**
 *  Client received this resource and replied with NACK.
 *
 *  Value: "NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Nacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_ReceivedError;
/**
 *  Client requested this resource but hasn't received any update from
 *  management server. The client will not fail requests, but will queue them
 *  until update arrives or the client times out waiting for the resource.
 *
 *  Value: "REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Requested;
/**
 *  Client timed out waiting for the resource from the control plane.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Timeout;
/**
 *  Resource status is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_DynamicScopedRouteConfigs.clientStatus

/**
 *  Client received this resource and replied with ACK.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Acked;
/**
 *  This resource has been requested by the client but has either not been
 *  delivered by the server or was previously delivered by the server and then
 *  subsequently removed from resources provided by the server. For more
 *  information, please refer to the :ref:`"Knowing When a Requested Resource
 *  Does Not Exist" ` section.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_DoesNotExist;
/**
 *  Client received this resource and replied with NACK.
 *
 *  Value: "NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Nacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_ReceivedError;
/**
 *  Client requested this resource but hasn't received any update from
 *  management server. The client will not fail requests, but will queue them
 *  until update arrives or the client times out waiting for the resource.
 *
 *  Value: "REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Requested;
/**
 *  Client timed out waiting for the resource from the control plane.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Timeout;
/**
 *  Resource status is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_GenericXdsConfig.clientStatus

/**
 *  Client received this resource and replied with ACK.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Acked;
/**
 *  This resource has been requested by the client but has either not been
 *  delivered by the server or was previously delivered by the server and then
 *  subsequently removed from resources provided by the server. For more
 *  information, please refer to the :ref:`"Knowing When a Requested Resource
 *  Does Not Exist" ` section.
 *
 *  Value: "DOES_NOT_EXIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_DoesNotExist;
/**
 *  Client received this resource and replied with NACK.
 *
 *  Value: "NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Nacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_ReceivedError;
/**
 *  Client requested this resource but hasn't received any update from
 *  management server. The client will not fail requests, but will queue them
 *  until update arrives or the client times out waiting for the resource.
 *
 *  Value: "REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Requested;
/**
 *  Client timed out waiting for the resource from the control plane.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Timeout;
/**
 *  Resource status is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_GenericXdsConfig.configStatus

/**
 *  Management server has sent the config to client but received NACK. The
 *  attached config dump will be the latest config (the rejected one), since it
 *  is the persisted version in the management server.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Error;
/**
 *  Config is not sent.
 *
 *  Value: "NOT_SENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_NotSent;
/**
 *  Management server has sent the config to client but hasn’t received
 *  ACK/NACK.
 *
 *  Value: "STALE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Stale;
/**
 *  Management server has sent the config to client and received ACK.
 *
 *  Value: "SYNCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Synced;
/**
 *  Status info is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_PerXdsConfig.clientStatus

/**
 *  Client received the config and replied with ACK.
 *
 *  Value: "CLIENT_ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientAcked;
/**
 *  Client received the config and replied with NACK. Notably, the attached
 *  config dump is not the NACKed version, but the most recent accepted one. If
 *  no config is accepted yet, the attached config dump will be empty.
 *
 *  Value: "CLIENT_NACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientNacked;
/**
 *  Client received an error from the control plane. The attached config dump is
 *  the most recent accepted one. If no config is accepted yet, the attached
 *  config dump will be empty.
 *
 *  Value: "CLIENT_RECEIVED_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientReceivedError;
/**
 *  Client requested the config but hasn't received any config from management
 *  server yet.
 *
 *  Value: "CLIENT_REQUESTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientRequested;
/**
 *  Config status is not available/unknown.
 *
 *  Value: "CLIENT_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientUnknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_PerXdsConfig.status

/**
 *  Management server has sent the config to client but received NACK. The
 *  attached config dump will be the latest config (the rejected one), since it
 *  is the persisted version in the management server.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_Status_Error;
/**
 *  Config is not sent.
 *
 *  Value: "NOT_SENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_Status_NotSent;
/**
 *  Management server has sent the config to client but hasn’t received
 *  ACK/NACK.
 *
 *  Value: "STALE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_Status_Stale;
/**
 *  Management server has sent the config to client and received ACK.
 *
 *  Value: "SYNCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_Status_Synced;
/**
 *  Status info is not available/unknown.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_PerXdsConfig_Status_Unknown;

// ----------------------------------------------------------------------------
// GTLRTrafficDirectorService_SocketAddress.protocol

/** Value: "TCP" */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_SocketAddress_Protocol_Tcp;
/** Value: "UDP" */
FOUNDATION_EXTERN NSString * const kGTLRTrafficDirectorService_SocketAddress_Protocol_Udp;

/**
 *  Addresses specify either a logical or physical address and port, which are
 *  used to tell Envoy where to bind/listen, connect to upstream and find
 *  management servers.
 */
@interface GTLRTrafficDirectorService_Address : GTLRObject

/** Specifies a user-space address handled by :ref:`internal listeners `. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_EnvoyInternalAddress *envoyInternalAddress;

@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_Pipe *pipe;
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_SocketAddress *socketAddress;

@end


/**
 *  BuildVersion combines SemVer version of extension with free-form build
 *  information (i.e. 'alpha', 'private-build') as a set of strings.
 */
@interface GTLRTrafficDirectorService_BuildVersion : GTLRObject

/**
 *  Free-form build information. Envoy defines several well known keys in the
 *  source/common/version/version.h file
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_BuildVersion_Metadata *metadata;

/** SemVer version of extension. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_SemanticVersion *version;

@end


/**
 *  Free-form build information. Envoy defines several well known keys in the
 *  source/common/version/version.h file
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_BuildVersion_Metadata : GTLRObject
@end


/**
 *  All xds configs for a particular client.
 */
@interface GTLRTrafficDirectorService_ClientConfig : GTLRObject

/**
 *  For xDS clients, the scope in which the data is used. For example, gRPC
 *  indicates the data plane target or that the data is associated with gRPC
 *  server(s).
 */
@property(nonatomic, copy, nullable) NSString *clientScope;

/**
 *  Represents generic xDS config and the exact config structure depends on the
 *  type URL (like Cluster if it is CDS)
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_GenericXdsConfig *> *genericXdsConfigs;

/** Node for a particular client. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_Node *node;

/**
 *  This field is deprecated in favor of generic_xds_configs which is much
 *  simpler and uniform in structure.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_PerXdsConfig *> *xdsConfig GTLR_DEPRECATED;

@end


/**
 *  Request for client status of clients identified by a list of NodeMatchers.
 */
@interface GTLRTrafficDirectorService_ClientStatusRequest : GTLRObject

/**
 *  If true, the server will not include the resource contents in the response
 *  (i.e., the generic_xds_configs.xds_config field will not be populated).
 *  [#not-implemented-hide:]
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *excludeResourceContents;

/** The node making the csds request. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_Node *node;

/**
 *  Management server can use these match criteria to identify clients. The
 *  match follows OR semantics.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_NodeMatcher *> *nodeMatchers;

@end


/**
 *  GTLRTrafficDirectorService_ClientStatusResponse
 */
@interface GTLRTrafficDirectorService_ClientStatusResponse : GTLRObject

/** Client configs for the clients specified in the ClientStatusRequest. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_ClientConfig *> *config;

@end


/**
 *  Envoy's cluster manager fills this message with all currently known
 *  clusters. Cluster configuration information can be used to recreate an Envoy
 *  configuration by populating all clusters as static clusters or by returning
 *  them in a CDS response.
 */
@interface GTLRTrafficDirectorService_ClustersConfigDump : GTLRObject

/**
 *  The dynamically loaded active clusters. These are clusters that are
 *  available to service data plane traffic.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicCluster *> *dynamicActiveClusters;

/**
 *  The dynamically loaded warming clusters. These are clusters that are
 *  currently undergoing warming in preparation to service data plane traffic.
 *  Note that if attempting to recreate an Envoy configuration from a
 *  configuration dump, the warming clusters should generally be discarded.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicCluster *> *dynamicWarmingClusters;

/** The statically loaded cluster configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_StaticCluster *> *staticClusters;

/**
 *  This is the :ref:`version_info ` in the last processed CDS discovery
 *  response. If there are only static bootstrap clusters, this field will be
 *  "".
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  Additional parameters that can be used to select resource variants. These
 *  include any global context parameters, per-resource type client feature
 *  capabilities and per-resource type functional attributes. All per-resource
 *  type attributes will be `xds.resource.` prefixed and some of these are
 *  documented below: `xds.resource.listening_address`: The value is "IP:port"
 *  (e.g. "10.1.1.3:8080") which is the listening address of a Listener. Used in
 *  a Listener resource query.
 */
@interface GTLRTrafficDirectorService_ContextParams : GTLRObject

@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ContextParams_Params *params;

@end


/**
 *  GTLRTrafficDirectorService_ContextParams_Params
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRTrafficDirectorService_ContextParams_Params : GTLRObject
@end


/**
 *  Specifies the way to match a double value.
 */
@interface GTLRTrafficDirectorService_DoubleMatcher : GTLRObject

/**
 *  If specified, the input double value must be equal to the value specified
 *  here.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exact;

/**
 *  If specified, the input double value must be in the range specified here.
 *  Note: The range is using half-open interval semantics [start, end).
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DoubleRange *range;

@end


/**
 *  Specifies the double start and end of the range using half-open interval
 *  semantics [start, end).
 */
@interface GTLRTrafficDirectorService_DoubleRange : GTLRObject

/**
 *  end of the range (exclusive)
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *end;

/**
 *  start of the range (inclusive)
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *start;

@end


/**
 *  Describes a dynamically loaded cluster via the CDS API. [#next-free-field:
 *  6]
 */
@interface GTLRTrafficDirectorService_DynamicCluster : GTLRObject

/**
 *  The client status of this resource. [#not-implemented-hide:]
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Acked
 *        Client received this resource and replied with ACK. (Value: "ACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_DoesNotExist
 *        This resource has been requested by the client but has either not been
 *        delivered by the server or was previously delivered by the server and
 *        then subsequently removed from resources provided by the server. For
 *        more information, please refer to the :ref:`"Knowing When a Requested
 *        Resource Does Not Exist" ` section. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Nacked
 *        Client received this resource and replied with NACK. (Value: "NACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_ReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value: "RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Requested
 *        Client requested this resource but hasn't received any update from
 *        management server. The client will not fail requests, but will queue
 *        them until update arrives or the client times out waiting for the
 *        resource. (Value: "REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Timeout
 *        Client timed out waiting for the resource from the control plane.
 *        (Value: "TIMEOUT")
 *    @arg @c kGTLRTrafficDirectorService_DynamicCluster_ClientStatus_Unknown
 *        Resource status is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus;

/** The cluster config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicCluster_Cluster *cluster;

/**
 *  Set if the last update failed, cleared after the next successful update. The
 *  ``error_state`` field contains the rejected version of this particular
 *  resource along with the reason and timestamp. For successfully updated or
 *  acknowledged resource, this field should be empty. [#not-implemented-hide:]
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState *errorState;

/** The timestamp when the Cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/**
 *  This is the per-resource version information. This version is currently
 *  taken from the :ref:`version_info ` field at the time that the cluster was
 *  loaded. In the future, discrete per-cluster versions may be supported by the
 *  API.
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  The cluster config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_DynamicCluster_Cluster : GTLRObject
@end


/**
 *  [#next-free-field: 6]
 */
@interface GTLRTrafficDirectorService_DynamicEndpointConfig : GTLRObject

/**
 *  The client status of this resource. [#not-implemented-hide:]
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Acked
 *        Client received this resource and replied with ACK. (Value: "ACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_DoesNotExist
 *        This resource has been requested by the client but has either not been
 *        delivered by the server or was previously delivered by the server and
 *        then subsequently removed from resources provided by the server. For
 *        more information, please refer to the :ref:`"Knowing When a Requested
 *        Resource Does Not Exist" ` section. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Nacked
 *        Client received this resource and replied with NACK. (Value: "NACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_ReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value: "RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Requested
 *        Client requested this resource but hasn't received any update from
 *        management server. The client will not fail requests, but will queue
 *        them until update arrives or the client times out waiting for the
 *        resource. (Value: "REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Timeout
 *        Client timed out waiting for the resource from the control plane.
 *        (Value: "TIMEOUT")
 *    @arg @c kGTLRTrafficDirectorService_DynamicEndpointConfig_ClientStatus_Unknown
 *        Resource status is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus;

/** The endpoint config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicEndpointConfig_EndpointConfig *endpointConfig;

/**
 *  Set if the last update failed, cleared after the next successful update. The
 *  ``error_state`` field contains the rejected version of this particular
 *  resource along with the reason and timestamp. For successfully updated or
 *  acknowledged resource, this field should be empty. [#not-implemented-hide:]
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState *errorState;

/**
 *  [#not-implemented-hide:] The timestamp when the Endpoint was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/**
 *  [#not-implemented-hide:] This is the per-resource version information. This
 *  version is currently taken from the :ref:`version_info ` field at the time
 *  that the endpoint configuration was loaded.
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  The endpoint config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_DynamicEndpointConfig_EndpointConfig : GTLRObject
@end


/**
 *  Describes a dynamically loaded listener via the LDS API. [#next-free-field:
 *  7]
 */
@interface GTLRTrafficDirectorService_DynamicListener : GTLRObject

/**
 *  The listener state for any active listener by this name. These are listeners
 *  that are available to service data plane traffic.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicListenerState *activeState;

/**
 *  The client status of this resource. [#not-implemented-hide:]
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Acked
 *        Client received this resource and replied with ACK. (Value: "ACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_DoesNotExist
 *        This resource has been requested by the client but has either not been
 *        delivered by the server or was previously delivered by the server and
 *        then subsequently removed from resources provided by the server. For
 *        more information, please refer to the :ref:`"Knowing When a Requested
 *        Resource Does Not Exist" ` section. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Nacked
 *        Client received this resource and replied with NACK. (Value: "NACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_ReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value: "RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Requested
 *        Client requested this resource but hasn't received any update from
 *        management server. The client will not fail requests, but will queue
 *        them until update arrives or the client times out waiting for the
 *        resource. (Value: "REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Timeout
 *        Client timed out waiting for the resource from the control plane.
 *        (Value: "TIMEOUT")
 *    @arg @c kGTLRTrafficDirectorService_DynamicListener_ClientStatus_Unknown
 *        Resource status is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus;

/**
 *  The listener state for any draining listener by this name. These are
 *  listeners that are currently undergoing draining in preparation to stop
 *  servicing data plane traffic. Note that if attempting to recreate an Envoy
 *  configuration from a configuration dump, the draining listeners should
 *  generally be discarded.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicListenerState *drainingState;

/**
 *  Set if the last update failed, cleared after the next successful update. The
 *  ``error_state`` field contains the rejected version of this particular
 *  resource along with the reason and timestamp. For successfully updated or
 *  acknowledged resource, this field should be empty.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState *errorState;

/**
 *  The name or unique id of this listener, pulled from the DynamicListenerState
 *  config.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The listener state for any warming listener by this name. These are
 *  listeners that are currently undergoing warming in preparation to service
 *  data plane traffic. Note that if attempting to recreate an Envoy
 *  configuration from a configuration dump, the warming listeners should
 *  generally be discarded.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicListenerState *warmingState;

@end


/**
 *  GTLRTrafficDirectorService_DynamicListenerState
 */
@interface GTLRTrafficDirectorService_DynamicListenerState : GTLRObject

/** The timestamp when the Listener was last successfully updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** The listener config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicListenerState_Listener *listener;

/**
 *  This is the per-resource version information. This version is currently
 *  taken from the :ref:`version_info ` field at the time that the listener was
 *  loaded. In the future, discrete per-listener versions may be supported by
 *  the API.
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  The listener config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_DynamicListenerState_Listener : GTLRObject
@end


/**
 *  [#next-free-field: 6]
 */
@interface GTLRTrafficDirectorService_DynamicRouteConfig : GTLRObject

/**
 *  The client status of this resource. [#not-implemented-hide:]
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Acked
 *        Client received this resource and replied with ACK. (Value: "ACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_DoesNotExist
 *        This resource has been requested by the client but has either not been
 *        delivered by the server or was previously delivered by the server and
 *        then subsequently removed from resources provided by the server. For
 *        more information, please refer to the :ref:`"Knowing When a Requested
 *        Resource Does Not Exist" ` section. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Nacked
 *        Client received this resource and replied with NACK. (Value: "NACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_ReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value: "RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Requested
 *        Client requested this resource but hasn't received any update from
 *        management server. The client will not fail requests, but will queue
 *        them until update arrives or the client times out waiting for the
 *        resource. (Value: "REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Timeout
 *        Client timed out waiting for the resource from the control plane.
 *        (Value: "TIMEOUT")
 *    @arg @c kGTLRTrafficDirectorService_DynamicRouteConfig_ClientStatus_Unknown
 *        Resource status is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus;

/**
 *  Set if the last update failed, cleared after the next successful update. The
 *  ``error_state`` field contains the rejected version of this particular
 *  resource along with the reason and timestamp. For successfully updated or
 *  acknowledged resource, this field should be empty. [#not-implemented-hide:]
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState *errorState;

/** The timestamp when the Route was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** The route config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DynamicRouteConfig_RouteConfig *routeConfig;

/**
 *  This is the per-resource version information. This version is currently
 *  taken from the :ref:`version_info ` field at the time that the route
 *  configuration was loaded.
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  The route config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_DynamicRouteConfig_RouteConfig : GTLRObject
@end


/**
 *  [#next-free-field: 7]
 */
@interface GTLRTrafficDirectorService_DynamicScopedRouteConfigs : GTLRObject

/**
 *  The client status of this resource. [#not-implemented-hide:]
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Acked
 *        Client received this resource and replied with ACK. (Value: "ACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_DoesNotExist
 *        This resource has been requested by the client but has either not been
 *        delivered by the server or was previously delivered by the server and
 *        then subsequently removed from resources provided by the server. For
 *        more information, please refer to the :ref:`"Knowing When a Requested
 *        Resource Does Not Exist" ` section. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Nacked
 *        Client received this resource and replied with NACK. (Value: "NACKED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_ReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value: "RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Requested
 *        Client requested this resource but hasn't received any update from
 *        management server. The client will not fail requests, but will queue
 *        them until update arrives or the client times out waiting for the
 *        resource. (Value: "REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Timeout
 *        Client timed out waiting for the resource from the control plane.
 *        (Value: "TIMEOUT")
 *    @arg @c kGTLRTrafficDirectorService_DynamicScopedRouteConfigs_ClientStatus_Unknown
 *        Resource status is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus;

/**
 *  Set if the last update failed, cleared after the next successful update. The
 *  ``error_state`` field contains the rejected version of this particular
 *  resource along with the reason and timestamp. For successfully updated or
 *  acknowledged resource, this field should be empty. [#not-implemented-hide:]
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState *errorState;

/** The timestamp when the scoped route config set was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** The name assigned to the scoped route configurations. */
@property(nonatomic, copy, nullable) NSString *name;

/** The scoped route configurations. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicScopedRouteConfigs_ScopedRouteConfigs_Item *> *scopedRouteConfigs;

/**
 *  This is the per-resource version information. This version is currently
 *  taken from the :ref:`version_info ` field at the time that the scoped routes
 *  configuration was loaded.
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  GTLRTrafficDirectorService_DynamicScopedRouteConfigs_ScopedRouteConfigs_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_DynamicScopedRouteConfigs_ScopedRouteConfigs_Item : GTLRObject
@end


/**
 *  Envoy's admin fill this message with all currently known endpoints. Endpoint
 *  configuration information can be used to recreate an Envoy configuration by
 *  populating all endpoints as static endpoints or by returning them in an EDS
 *  response.
 */
@interface GTLRTrafficDirectorService_EndpointsConfigDump : GTLRObject

/** The dynamically loaded endpoint configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicEndpointConfig *> *dynamicEndpointConfigs;

/** The statically loaded endpoint configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_StaticEndpointConfig *> *staticEndpointConfigs;

@end


/**
 *  The address represents an envoy internal listener. [#comment:
 */
@interface GTLRTrafficDirectorService_EnvoyInternalAddress : GTLRObject

/**
 *  Specifies an endpoint identifier to distinguish between multiple endpoints
 *  for the same internal listener in a single upstream pool. Only used in the
 *  upstream addresses for tracking changes to individual endpoints. This, for
 *  example, may be set to the final destination IP for the target internal
 *  listener.
 */
@property(nonatomic, copy, nullable) NSString *endpointId;

/** Specifies the :ref:`name ` of the internal listener. */
@property(nonatomic, copy, nullable) NSString *serverListenerName;

@end


/**
 *  Version and identification for an Envoy extension. [#next-free-field: 7]
 */
@interface GTLRTrafficDirectorService_Extension : GTLRObject

/**
 *  Category of the extension. Extension category names use reverse DNS
 *  notation. For instance "envoy.filters.listener" for Envoy's built-in
 *  listener filters or "com.acme.filters.http" for HTTP filters from acme.com
 *  vendor. [#comment:
 */
@property(nonatomic, copy, nullable) NSString *category;

/**
 *  Indicates that the extension is present but was disabled via dynamic
 *  configuration.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

/**
 *  This is the name of the Envoy filter as specified in the Envoy
 *  configuration, e.g. envoy.filters.http.router, com.acme.widget.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  [#not-implemented-hide:] Type descriptor of extension configuration proto.
 *  [#comment:
 */
@property(nonatomic, copy, nullable) NSString *typeDescriptor GTLR_DEPRECATED;

/** Type URLs of extension configuration protos. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *typeUrls;

/**
 *  The version is a property of the extension and maintained independently of
 *  other extensions and the Envoy API. This field is not set when extension did
 *  not provide version information.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_BuildVersion *version;

@end


/**
 *  GenericXdsConfig is used to specify the config status and the dump of any
 *  xDS resource identified by their type URL. It is the generalized version of
 *  the now deprecated ListenersConfigDump, ClustersConfigDump etc
 *  [#next-free-field: 10]
 */
@interface GTLRTrafficDirectorService_GenericXdsConfig : GTLRObject

/**
 *  Per xDS resource status from the view of a xDS client
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Acked
 *        Client received this resource and replied with ACK. (Value: "ACKED")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_DoesNotExist
 *        This resource has been requested by the client but has either not been
 *        delivered by the server or was previously delivered by the server and
 *        then subsequently removed from resources provided by the server. For
 *        more information, please refer to the :ref:`"Knowing When a Requested
 *        Resource Does Not Exist" ` section. (Value: "DOES_NOT_EXIST")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Nacked
 *        Client received this resource and replied with NACK. (Value: "NACKED")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_ReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value: "RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Requested
 *        Client requested this resource but hasn't received any update from
 *        management server. The client will not fail requests, but will queue
 *        them until update arrives or the client times out waiting for the
 *        resource. (Value: "REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Timeout
 *        Client timed out waiting for the resource from the control plane.
 *        (Value: "TIMEOUT")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ClientStatus_Unknown
 *        Resource status is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus;

/**
 *  Per xDS resource config status. It is generated by management servers. It
 *  will not be present if the CSDS server is an xDS client.
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Error
 *        Management server has sent the config to client but received NACK. The
 *        attached config dump will be the latest config (the rejected one),
 *        since it is the persisted version in the management server. (Value:
 *        "ERROR")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_NotSent
 *        Config is not sent. (Value: "NOT_SENT")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Stale
 *        Management server has sent the config to client but hasn’t received
 *        ACK/NACK. (Value: "STALE")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Synced
 *        Management server has sent the config to client and received ACK.
 *        (Value: "SYNCED")
 *    @arg @c kGTLRTrafficDirectorService_GenericXdsConfig_ConfigStatus_Unknown
 *        Status info is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *configStatus;

/**
 *  Set if the last update failed, cleared after the next successful update. The
 *  *error_state* field contains the rejected version of this particular
 *  resource along with the reason and timestamp. For successfully updated or
 *  acknowledged resource, this field should be empty. [#not-implemented-hide:]
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState *errorState;

/**
 *  Is static resource is true if it is specified in the config supplied through
 *  the file at the startup.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isStaticResource;

/** Timestamp when the xDS resource was last updated */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** Name of the xDS resource */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Type_url represents the fully qualified name of xDS resource type like
 *  envoy.v3.Cluster, envoy.v3.ClusterLoadAssignment etc.
 */
@property(nonatomic, copy, nullable) NSString *typeUrl;

/**
 *  This is the :ref:`version_info ` in the last processed xDS discovery
 *  response. If there are only static bootstrap listeners, this field will be
 *  ""
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

/** The xDS resource config. Actual content depends on the type */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_GenericXdsConfig_XdsConfig *xdsConfig;

@end


/**
 *  The xDS resource config. Actual content depends on the type
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_GenericXdsConfig_XdsConfig : GTLRObject
@end


/**
 *  Google's `RE2 `_ regex engine. The regex string must adhere to the
 *  documented `syntax `_. The engine is designed to complete execution in
 *  linear time as well as limit the amount of memory used. Envoy supports
 *  program size checking via runtime. The runtime keys
 *  ``re2.max_program_size.error_level`` and ``re2.max_program_size.warn_level``
 *  can be set to integers as the maximum program size or complexity that a
 *  compiled regex can have before an exception is thrown or a warning is
 *  logged, respectively. ``re2.max_program_size.error_level`` defaults to 100,
 *  and ``re2.max_program_size.warn_level`` has no default if unset (will not
 *  check/log a warning). Envoy emits two stats for tracking the program size of
 *  regexes: the histogram ``re2.program_size``, which records the program size,
 *  and the counter ``re2.exceeded_warn_level``, which is incremented each time
 *  the program size exceeds the warn level threshold.
 */
@interface GTLRTrafficDirectorService_GoogleRE2 : GTLRObject

/**
 *  This field controls the RE2 "program size" which is a rough estimate of how
 *  complex a compiled regex is to evaluate. A regex that has a program size
 *  greater than the configured value will fail to compile. In this case, the
 *  configured max program size can be increased or the regex can be simplified.
 *  If not specified, the default is 100. This field is deprecated; regexp
 *  validation should be performed on the management server instead of being
 *  done by each individual client. .. note:: Although this field is deprecated,
 *  the program size will still be checked against the global
 *  ``re2.max_program_size.error_level`` runtime value.
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxProgramSize GTLR_DEPRECATED;

@end


/**
 *  GTLRTrafficDirectorService_InlineScopedRouteConfigs
 */
@interface GTLRTrafficDirectorService_InlineScopedRouteConfigs : GTLRObject

/** The timestamp when the scoped route config set was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** The name assigned to the scoped route configurations. */
@property(nonatomic, copy, nullable) NSString *name;

/** The scoped route configurations. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_InlineScopedRouteConfigs_ScopedRouteConfigs_Item *> *scopedRouteConfigs;

@end


/**
 *  GTLRTrafficDirectorService_InlineScopedRouteConfigs_ScopedRouteConfigs_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_InlineScopedRouteConfigs_ScopedRouteConfigs_Item : GTLRObject
@end


/**
 *  Envoy's listener manager fills this message with all currently known
 *  listeners. Listener configuration information can be used to recreate an
 *  Envoy configuration by populating all listeners as static listeners or by
 *  returning them in a LDS response.
 */
@interface GTLRTrafficDirectorService_ListenersConfigDump : GTLRObject

/** State for any warming, active, or draining listeners. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicListener *> *dynamicListeners;

/** The statically loaded listener configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_StaticListener *> *staticListeners;

/**
 *  This is the :ref:`version_info ` in the last processed LDS discovery
 *  response. If there are only static bootstrap listeners, this field will be
 *  "".
 */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  Specifies the way to match a list value.
 */
@interface GTLRTrafficDirectorService_ListMatcher : GTLRObject

/**
 *  If specified, at least one of the values in the list must match the value
 *  specified.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ValueMatcher *oneOf;

@end


/**
 *  Identifies location of where either Envoy runs or where upstream hosts run.
 */
@interface GTLRTrafficDirectorService_Locality : GTLRObject

/** Region this :ref:`zone ` belongs to. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  When used for locality of upstream hosts, this field further splits zone
 *  into smaller chunks of sub-zones so they can be load balanced independently.
 */
@property(nonatomic, copy, nullable) NSString *subZone;

/**
 *  Defines the local service zone where Envoy is running. Though optional, it
 *  should be set if discovery service routing is used and the discovery service
 *  exposes :ref:`zone data `, either in this message or via
 *  :option:`--service-zone`. The meaning of zone is context dependent, e.g.
 *  `Availability Zone (AZ) `_ on AWS, `Zone `_ on GCP, etc.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  Identifies a specific Envoy instance. The node identifier is presented to
 *  the management server, which may use this identifier to distinguish per
 *  Envoy configuration for serving. [#next-free-field: 13]
 */
@interface GTLRTrafficDirectorService_Node : GTLRObject

/**
 *  Client feature support list. These are well known features described in the
 *  Envoy API repository for a given major version of an API. Client features
 *  use reverse DNS naming scheme, for example ``com.acme.feature``. See
 *  :ref:`the list of features ` that xDS client may support.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *clientFeatures;

/**
 *  Defines the local service cluster name where Envoy is running. Though
 *  optional, it should be set if any of the following features are used:
 *  :ref:`statsd `, :ref:`health check cluster verification `, :ref:`runtime
 *  override directory `, :ref:`user agent addition `, :ref:`HTTP global rate
 *  limiting `, :ref:`CDS `, and :ref:`HTTP tracing `, either in this message or
 *  via :option:`--service-cluster`.
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/**
 *  Map from xDS resource type URL to dynamic context parameters. These may vary
 *  at runtime (unlike other fields in this message). For example, the xDS
 *  client may have a shard identifier that changes during the lifetime of the
 *  xDS client. In Envoy, this would be achieved by updating the dynamic context
 *  on the Server::Instance's LocalInfo context provider. The shard ID dynamic
 *  parameter then appears in this field during future discovery requests.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_Node_DynamicParameters *dynamicParameters;

/** List of extensions and their versions supported by the node. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_Extension *> *extensions;

/**
 *  An opaque node identifier for the Envoy node. This also provides the local
 *  service node name. It should be set if any of the following features are
 *  used: :ref:`statsd `, :ref:`CDS `, and :ref:`HTTP tracing `, either in this
 *  message or via :option:`--service-node`.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Known listening ports on the node as a generic hint to the management server
 *  for filtering :ref:`listeners ` to be returned. For example, if there is a
 *  listener bound to port 80, the list can optionally contain the SocketAddress
 *  ``(0.0.0.0,80)``. The field is optional and just a hint.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_Address *> *listeningAddresses GTLR_DEPRECATED;

/** Locality specifying where the Envoy instance is running. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_Locality *locality;

/**
 *  Opaque metadata extending the node identifier. Envoy will pass this directly
 *  to the management server.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_Node_Metadata *metadata;

/** Structured version of the entity requesting config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_BuildVersion *userAgentBuildVersion;

/**
 *  Free-form string that identifies the entity requesting config. E.g. "envoy"
 *  or "grpc"
 */
@property(nonatomic, copy, nullable) NSString *userAgentName;

/**
 *  Free-form string that identifies the version of the entity requesting
 *  config. E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
 */
@property(nonatomic, copy, nullable) NSString *userAgentVersion;

@end


/**
 *  Map from xDS resource type URL to dynamic context parameters. These may vary
 *  at runtime (unlike other fields in this message). For example, the xDS
 *  client may have a shard identifier that changes during the lifetime of the
 *  xDS client. In Envoy, this would be achieved by updating the dynamic context
 *  on the Server::Instance's LocalInfo context provider. The shard ID dynamic
 *  parameter then appears in this field during future discovery requests.
 *
 *  @note This class is documented as having more properties of
 *        GTLRTrafficDirectorService_ContextParams. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRTrafficDirectorService_Node_DynamicParameters : GTLRObject
@end


/**
 *  Opaque metadata extending the node identifier. Envoy will pass this directly
 *  to the management server.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_Node_Metadata : GTLRObject
@end


/**
 *  Specifies the way to match a Node. The match follows AND semantics.
 */
@interface GTLRTrafficDirectorService_NodeMatcher : GTLRObject

/** Specifies match criteria on the node id. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_StringMatcher *nodeId;

/** Specifies match criteria on the node metadata. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_StructMatcher *> *nodeMetadatas;

@end


/**
 *  NullMatch is an empty message to specify a null value.
 */
@interface GTLRTrafficDirectorService_NullMatch : GTLRObject
@end


/**
 *  Specifies a list of alternatives for the match.
 */
@interface GTLRTrafficDirectorService_OrMatcher : GTLRObject

@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_ValueMatcher *> *valueMatchers;

@end


/**
 *  Specifies the segment in a path to retrieve value from Struct.
 */
@interface GTLRTrafficDirectorService_PathSegment : GTLRObject

/** If specified, use the key to retrieve the value in a Struct. */
@property(nonatomic, copy, nullable) NSString *key;

@end


/**
 *  Detailed config (per xDS) with status. [#next-free-field: 8]
 */
@interface GTLRTrafficDirectorService_PerXdsConfig : GTLRObject

/**
 *  Client config status is populated by xDS clients. Will not be present if the
 *  CSDS server is an xDS server. No matter what the client config status is,
 *  xDS clients should always dump the most recent accepted xDS config. ..
 *  attention:: This field is deprecated. Use :ref:`ClientResourceStatus ` for
 *  per-resource config status instead.
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientAcked
 *        Client received the config and replied with ACK. (Value:
 *        "CLIENT_ACKED")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientNacked
 *        Client received the config and replied with NACK. Notably, the
 *        attached config dump is not the NACKed version, but the most recent
 *        accepted one. If no config is accepted yet, the attached config dump
 *        will be empty. (Value: "CLIENT_NACKED")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientReceivedError
 *        Client received an error from the control plane. The attached config
 *        dump is the most recent accepted one. If no config is accepted yet,
 *        the attached config dump will be empty. (Value:
 *        "CLIENT_RECEIVED_ERROR")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientRequested
 *        Client requested the config but hasn't received any config from
 *        management server yet. (Value: "CLIENT_REQUESTED")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_ClientStatus_ClientUnknown
 *        Config status is not available/unknown. (Value: "CLIENT_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *clientStatus GTLR_DEPRECATED;

@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ClustersConfigDump *clusterConfig;
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_EndpointsConfigDump *endpointConfig;
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ListenersConfigDump *listenerConfig;
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_RoutesConfigDump *routeConfig;
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ScopedRoutesConfigDump *scopedRouteConfig;

/**
 *  Config status generated by management servers. Will not be present if the
 *  CSDS server is an xDS client.
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_Status_Error Management
 *        server has sent the config to client but received NACK. The attached
 *        config dump will be the latest config (the rejected one), since it is
 *        the persisted version in the management server. (Value: "ERROR")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_Status_NotSent Config is
 *        not sent. (Value: "NOT_SENT")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_Status_Stale Management
 *        server has sent the config to client but hasn’t received ACK/NACK.
 *        (Value: "STALE")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_Status_Synced Management
 *        server has sent the config to client and received ACK. (Value:
 *        "SYNCED")
 *    @arg @c kGTLRTrafficDirectorService_PerXdsConfig_Status_Unknown Status
 *        info is not available/unknown. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  GTLRTrafficDirectorService_Pipe
 */
@interface GTLRTrafficDirectorService_Pipe : GTLRObject

/**
 *  The mode for the Pipe. Not applicable for abstract sockets.
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mode;

/**
 *  Unix Domain Socket path. On Linux, paths starting with '\@' will use the
 *  abstract namespace. The starting '\@' is replaced by a null byte by Envoy.
 *  Paths starting with '\@' will result in an error in environments other than
 *  Linux.
 */
@property(nonatomic, copy, nullable) NSString *path;

@end


/**
 *  A regex matcher designed for safety when used with untrusted input.
 */
@interface GTLRTrafficDirectorService_RegexMatcher : GTLRObject

/** Google's RE2 regex engine. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_GoogleRE2 *googleRe2 GTLR_DEPRECATED;

/**
 *  The regex match string. The string must be supported by the configured
 *  engine. The regex is matched against the full string, not as a partial
 *  match.
 */
@property(nonatomic, copy, nullable) NSString *regex;

@end


/**
 *  Envoy's RDS implementation fills this message with all currently loaded
 *  routes, as described by their RouteConfiguration objects. Static routes that
 *  are either defined in the bootstrap configuration or defined inline while
 *  configuring listeners are separated from those configured dynamically via
 *  RDS. Route configuration information can be used to recreate an Envoy
 *  configuration by populating all routes as static routes or by returning them
 *  in RDS responses.
 */
@interface GTLRTrafficDirectorService_RoutesConfigDump : GTLRObject

/** The dynamically loaded route configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicRouteConfig *> *dynamicRouteConfigs;

/** The statically loaded route configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_StaticRouteConfig *> *staticRouteConfigs;

@end


/**
 *  Envoy's scoped RDS implementation fills this message with all currently
 *  loaded route configuration scopes (defined via ScopedRouteConfigurationsSet
 *  protos). This message lists both the scopes defined inline with the higher
 *  order object (i.e., the HttpConnectionManager) and the dynamically obtained
 *  scopes via the SRDS API.
 */
@interface GTLRTrafficDirectorService_ScopedRoutesConfigDump : GTLRObject

/** The dynamically loaded scoped route configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_DynamicScopedRouteConfigs *> *dynamicScopedRouteConfigs;

/** The statically loaded scoped route configs. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_InlineScopedRouteConfigs *> *inlineScopedRouteConfigs;

@end


/**
 *  Envoy uses SemVer (https://semver.org/). Major/minor versions indicate
 *  expected behaviors and APIs, the patch version field is used only for
 *  security fixes and can be generally ignored.
 */
@interface GTLRTrafficDirectorService_SemanticVersion : GTLRObject

/**
 *  majorNumber
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *majorNumber;

/**
 *  minorNumber
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minorNumber;

/**
 *  patch
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *patch;

@end


/**
 *  [#next-free-field: 7]
 */
@interface GTLRTrafficDirectorService_SocketAddress : GTLRObject

/**
 *  The address for this socket. :ref:`Listeners ` will bind to the address. An
 *  empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any
 *  address. [#comment:TODO(zuercher) reinstate when implemented: It is possible
 *  to distinguish a Listener address via the prefix/suffix matching in
 *  :ref:`FilterChainMatch `.] When used within an upstream :ref:`BindConfig `,
 *  the address controls the source address of outbound connections. For
 *  :ref:`clusters `, the cluster type determines whether the address must be an
 *  IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
 *  (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be
 *  customized via :ref:`resolver_name `.
 */
@property(nonatomic, copy, nullable) NSString *address;

/**
 *  When binding to an IPv6 address above, this enables `IPv4 compatibility `_.
 *  Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4
 *  addresses mapped into IPv6 space as ``::FFFF:``.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ipv4Compat;

/**
 *  This is only valid if :ref:`resolver_name ` is specified below and the named
 *  resolver is capable of named port resolution.
 */
@property(nonatomic, copy, nullable) NSString *namedPort;

/**
 *  portValue
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *portValue;

/**
 *  protocol
 *
 *  Likely values:
 *    @arg @c kGTLRTrafficDirectorService_SocketAddress_Protocol_Tcp Value "TCP"
 *    @arg @c kGTLRTrafficDirectorService_SocketAddress_Protocol_Udp Value "UDP"
 */
@property(nonatomic, copy, nullable) NSString *protocol;

/**
 *  The name of the custom resolver. This must have been registered with Envoy.
 *  If this is empty, a context dependent default applies. If the address is a
 *  concrete IP address, no resolution will occur. If address is a hostname this
 *  should be set for resolution other than DNS. Specifying a custom resolver
 *  with ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
 */
@property(nonatomic, copy, nullable) NSString *resolverName;

@end


/**
 *  Describes a statically loaded cluster.
 */
@interface GTLRTrafficDirectorService_StaticCluster : GTLRObject

/** The cluster config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_StaticCluster_Cluster *cluster;

/** The timestamp when the Cluster was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

@end


/**
 *  The cluster config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_StaticCluster_Cluster : GTLRObject
@end


/**
 *  GTLRTrafficDirectorService_StaticEndpointConfig
 */
@interface GTLRTrafficDirectorService_StaticEndpointConfig : GTLRObject

/** The endpoint config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_StaticEndpointConfig_EndpointConfig *endpointConfig;

/**
 *  [#not-implemented-hide:] The timestamp when the Endpoint was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

@end


/**
 *  The endpoint config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_StaticEndpointConfig_EndpointConfig : GTLRObject
@end


/**
 *  Describes a statically loaded listener.
 */
@interface GTLRTrafficDirectorService_StaticListener : GTLRObject

/** The timestamp when the Listener was last successfully updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** The listener config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_StaticListener_Listener *listener;

@end


/**
 *  The listener config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_StaticListener_Listener : GTLRObject
@end


/**
 *  GTLRTrafficDirectorService_StaticRouteConfig
 */
@interface GTLRTrafficDirectorService_StaticRouteConfig : GTLRObject

/** The timestamp when the Route was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdated;

/** The route config. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_StaticRouteConfig_RouteConfig *routeConfig;

@end


/**
 *  The route config.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_StaticRouteConfig_RouteConfig : GTLRObject
@end


/**
 *  Specifies the way to match a string. [#next-free-field: 9]
 */
@interface GTLRTrafficDirectorService_StringMatcher : GTLRObject

/**
 *  The input string must have the substring specified here. Note: empty
 *  contains match is not allowed, please use regex instead. Examples: * ``abc``
 *  matches the value ``xyz.abc.def``
 */
@property(nonatomic, copy, nullable) NSString *contains;

/**
 *  Use an extension as the matcher type. [#extension-category:
 *  envoy.string_matcher]
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_TypedExtensionConfig *custom;

/**
 *  The input string must match exactly the string specified here. Examples: *
 *  ``abc`` only matches the value ``abc``.
 */
@property(nonatomic, copy, nullable) NSString *exact;

/**
 *  If true, indicates the exact/prefix/suffix/contains matching should be case
 *  insensitive. This has no effect for the safe_regex match. For example, the
 *  matcher ``data`` will match both input string ``Data`` and ``data`` if set
 *  to true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ignoreCase;

/**
 *  The input string must have the prefix specified here. Note: empty prefix is
 *  not allowed, please use regex instead. Examples: * ``abc`` matches the value
 *  ``abc.xyz``
 */
@property(nonatomic, copy, nullable) NSString *prefix;

/** The input string must match the regular expression specified here. */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_RegexMatcher *safeRegex;

/**
 *  The input string must have the suffix specified here. Note: empty prefix is
 *  not allowed, please use regex instead. Examples: * ``abc`` matches the value
 *  ``xyz.abc``
 */
@property(nonatomic, copy, nullable) NSString *suffix;

@end


/**
 *  StructMatcher provides a general interface to check if a given value is
 *  matched in google.protobuf.Struct. It uses ``path`` to retrieve the value
 *  from the struct and then check if it's matched to the specified value. For
 *  example, for the following Struct: .. code-block:: yaml fields: a:
 *  struct_value: fields: b: struct_value: fields: c: string_value: pro t:
 *  list_value: values: - string_value: m - string_value: n The following
 *  MetadataMatcher is matched as the path [a, b, c] will retrieve a string
 *  value "pro" from the Metadata which is matched to the specified prefix
 *  match. .. code-block:: yaml path: - key: a - key: b - key: c value:
 *  string_match: prefix: pr The following StructMatcher is matched as the code
 *  will match one of the string values in the list at the path [a, t]. ..
 *  code-block:: yaml path: - key: a - key: t value: list_match: one_of:
 *  string_match: exact: m An example use of StructMatcher is to match metadata
 *  in envoy.v*.core.Node.
 */
@interface GTLRTrafficDirectorService_StructMatcher : GTLRObject

/** The path to retrieve the Value from the Struct. */
@property(nonatomic, strong, nullable) NSArray<GTLRTrafficDirectorService_PathSegment *> *path;

/**
 *  The StructMatcher is matched if the value retrieved by path is matched to
 *  this value.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ValueMatcher *value;

@end


/**
 *  Message type for extension configuration.
 */
@interface GTLRTrafficDirectorService_TypedExtensionConfig : GTLRObject

/**
 *  The name of an extension. This is not used to select the extension, instead
 *  it serves the role of an opaque identifier.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The typed config for the extension. The type URL will be used to identify
 *  the extension. In the case that the type URL is *xds.type.v3.TypedStruct*
 *  (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type URL
 *  of *TypedStruct* will be utilized. See the :ref:`extension configuration
 *  overview ` for further details.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_TypedExtensionConfig_TypedConfig *typedConfig;

@end


/**
 *  The typed config for the extension. The type URL will be used to identify
 *  the extension. In the case that the type URL is *xds.type.v3.TypedStruct*
 *  (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type URL
 *  of *TypedStruct* will be utilized. See the :ref:`extension configuration
 *  overview ` for further details.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_TypedExtensionConfig_TypedConfig : GTLRObject
@end


/**
 *  GTLRTrafficDirectorService_UpdateFailureState
 */
@interface GTLRTrafficDirectorService_UpdateFailureState : GTLRObject

/** Details about the last failed update attempt. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  What the component configuration would have been if the update had
 *  succeeded. This field may not be populated by xDS clients due to storage
 *  overhead.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_UpdateFailureState_FailedConfiguration *failedConfiguration;

/** Time of the latest failed update attempt. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdateAttempt;

/** This is the version of the rejected resource. [#not-implemented-hide:] */
@property(nonatomic, copy, nullable) NSString *versionInfo;

@end


/**
 *  What the component configuration would have been if the update had
 *  succeeded. This field may not be populated by xDS clients due to storage
 *  overhead.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTrafficDirectorService_UpdateFailureState_FailedConfiguration : GTLRObject
@end


/**
 *  Specifies the way to match a ProtobufWkt::Value. Primitive values and
 *  ListValue are supported. StructValue is not supported and is always not
 *  matched. [#next-free-field: 8]
 */
@interface GTLRTrafficDirectorService_ValueMatcher : GTLRObject

/**
 *  If specified, a match occurs if and only if the target value is a bool value
 *  and is equal to this field.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolMatch;

/**
 *  If specified, a match occurs if and only if the target value is a double
 *  value and is matched to this field.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_DoubleMatcher *doubleMatch;

/**
 *  If specified, a match occurs if and only if the target value is a list value
 *  and is matched to this field.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_ListMatcher *listMatch;

/**
 *  If specified, a match occurs if and only if the target value is a NullValue.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_NullMatch *nullMatch;

/**
 *  If specified, a match occurs if and only if any of the alternatives in the
 *  match accept the value.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_OrMatcher *orMatch;

/**
 *  If specified, value match will be performed based on whether the path is
 *  referring to a valid primitive value in the metadata. If the path is
 *  referring to a non-primitive value, the result is always not matched.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *presentMatch;

/**
 *  If specified, a match occurs if and only if the target value is a string
 *  value and is matched to this field.
 */
@property(nonatomic, strong, nullable) GTLRTrafficDirectorService_StringMatcher *stringMatch;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
