// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   OS Config API (osconfig/v1)
// Description:
//   OS management tools that can be used for patch management, patch
//   compliance, and configuration management on VM instances.
// Documentation:
//   https://cloud.google.com/compute/docs/osconfig/rest

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLROSConfig_AptSettings;
@class GTLROSConfig_CVSSv3;
@class GTLROSConfig_Date;
@class GTLROSConfig_ExecStep;
@class GTLROSConfig_ExecStepConfig;
@class GTLROSConfig_FixedOrPercent;
@class GTLROSConfig_GcsObject;
@class GTLROSConfig_GooSettings;
@class GTLROSConfig_Inventory;
@class GTLROSConfig_Inventory_Items;
@class GTLROSConfig_InventoryItem;
@class GTLROSConfig_InventoryOsInfo;
@class GTLROSConfig_InventorySoftwarePackage;
@class GTLROSConfig_InventoryVersionedPackage;
@class GTLROSConfig_InventoryWindowsApplication;
@class GTLROSConfig_InventoryWindowsQuickFixEngineeringPackage;
@class GTLROSConfig_InventoryWindowsUpdatePackage;
@class GTLROSConfig_InventoryWindowsUpdatePackageWindowsUpdateCategory;
@class GTLROSConfig_InventoryZypperPatch;
@class GTLROSConfig_MonthlySchedule;
@class GTLROSConfig_OneTimeSchedule;
@class GTLROSConfig_Operation_Metadata;
@class GTLROSConfig_Operation_Response;
@class GTLROSConfig_OSPolicy;
@class GTLROSConfig_OSPolicyAssignment;
@class GTLROSConfig_OSPolicyAssignmentInstanceFilter;
@class GTLROSConfig_OSPolicyAssignmentInstanceFilterInventory;
@class GTLROSConfig_OSPolicyAssignmentLabelSet;
@class GTLROSConfig_OSPolicyAssignmentLabelSet_Labels;
@class GTLROSConfig_OSPolicyAssignmentReport;
@class GTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance;
@class GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance;
@class GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput;
@class GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep;
@class GTLROSConfig_OSPolicyAssignmentRollout;
@class GTLROSConfig_OSPolicyInventoryFilter;
@class GTLROSConfig_OSPolicyResource;
@class GTLROSConfig_OSPolicyResourceExecResource;
@class GTLROSConfig_OSPolicyResourceExecResourceExec;
@class GTLROSConfig_OSPolicyResourceFile;
@class GTLROSConfig_OSPolicyResourceFileGcs;
@class GTLROSConfig_OSPolicyResourceFileRemote;
@class GTLROSConfig_OSPolicyResourceFileResource;
@class GTLROSConfig_OSPolicyResourceGroup;
@class GTLROSConfig_OSPolicyResourcePackageResource;
@class GTLROSConfig_OSPolicyResourcePackageResourceAPT;
@class GTLROSConfig_OSPolicyResourcePackageResourceDeb;
@class GTLROSConfig_OSPolicyResourcePackageResourceGooGet;
@class GTLROSConfig_OSPolicyResourcePackageResourceMSI;
@class GTLROSConfig_OSPolicyResourcePackageResourceRPM;
@class GTLROSConfig_OSPolicyResourcePackageResourceYUM;
@class GTLROSConfig_OSPolicyResourcePackageResourceZypper;
@class GTLROSConfig_OSPolicyResourceRepositoryResource;
@class GTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository;
@class GTLROSConfig_OSPolicyResourceRepositoryResourceGooRepository;
@class GTLROSConfig_OSPolicyResourceRepositoryResourceYumRepository;
@class GTLROSConfig_OSPolicyResourceRepositoryResourceZypperRepository;
@class GTLROSConfig_PatchConfig;
@class GTLROSConfig_PatchDeployment;
@class GTLROSConfig_PatchInstanceFilter;
@class GTLROSConfig_PatchInstanceFilterGroupLabel;
@class GTLROSConfig_PatchInstanceFilterGroupLabel_Labels;
@class GTLROSConfig_PatchJob;
@class GTLROSConfig_PatchJobInstanceDetails;
@class GTLROSConfig_PatchJobInstanceDetailsSummary;
@class GTLROSConfig_PatchRollout;
@class GTLROSConfig_RecurringSchedule;
@class GTLROSConfig_Status;
@class GTLROSConfig_Status_Details_Item;
@class GTLROSConfig_TimeOfDay;
@class GTLROSConfig_TimeZone;
@class GTLROSConfig_VulnerabilityReport;
@class GTLROSConfig_VulnerabilityReportVulnerability;
@class GTLROSConfig_VulnerabilityReportVulnerabilityDetails;
@class GTLROSConfig_VulnerabilityReportVulnerabilityDetailsReference;
@class GTLROSConfig_VulnerabilityReportVulnerabilityItem;
@class GTLROSConfig_WeekDayOfMonth;
@class GTLROSConfig_WeeklySchedule;
@class GTLROSConfig_WindowsUpdateSettings;
@class GTLROSConfig_YumSettings;
@class GTLROSConfig_ZypperSettings;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLROSConfig_AptSettings.type

/**
 *  Runs `apt-get dist-upgrade`.
 *
 *  Value: "DIST"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_AptSettings_Type_Dist;
/**
 *  By default, upgrade will be performed.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_AptSettings_Type_TypeUnspecified;
/**
 *  Runs `apt-get upgrade`.
 *
 *  Value: "UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_AptSettings_Type_Upgrade;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.attackComplexity

/**
 *  A successful attack depends on conditions beyond the attacker's control.
 *  That is, a successful attack cannot be accomplished at will, but requires
 *  the attacker to invest in some measurable amount of effort in preparation or
 *  execution against the vulnerable component before a successful attack can be
 *  expected.
 *
 *  Value: "ATTACK_COMPLEXITY_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackComplexity_AttackComplexityHigh;
/**
 *  Specialized access conditions or extenuating circumstances do not exist. An
 *  attacker can expect repeatable success when attacking the vulnerable
 *  component.
 *
 *  Value: "ATTACK_COMPLEXITY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackComplexity_AttackComplexityLow;
/**
 *  Invalid value.
 *
 *  Value: "ATTACK_COMPLEXITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackComplexity_AttackComplexityUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.attackVector

/**
 *  The vulnerable component is bound to the network stack, but the attack is
 *  limited at the protocol level to a logically adjacent topology.
 *
 *  Value: "ATTACK_VECTOR_ADJACENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackVector_AttackVectorAdjacent;
/**
 *  The vulnerable component is not bound to the network stack and the
 *  attacker's path is via read/write/execute capabilities.
 *
 *  Value: "ATTACK_VECTOR_LOCAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackVector_AttackVectorLocal;
/**
 *  The vulnerable component is bound to the network stack and the set of
 *  possible attackers extends beyond the other options listed below, up to and
 *  including the entire Internet.
 *
 *  Value: "ATTACK_VECTOR_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackVector_AttackVectorNetwork;
/**
 *  The attack requires the attacker to physically touch or manipulate the
 *  vulnerable component.
 *
 *  Value: "ATTACK_VECTOR_PHYSICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackVector_AttackVectorPhysical;
/**
 *  Invalid value.
 *
 *  Value: "ATTACK_VECTOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AttackVector_AttackVectorUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.availabilityImpact

/**
 *  High impact.
 *
 *  Value: "IMPACT_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactHigh;
/**
 *  Low impact.
 *
 *  Value: "IMPACT_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactLow;
/**
 *  No impact.
 *
 *  Value: "IMPACT_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactNone;
/**
 *  Invalid value.
 *
 *  Value: "IMPACT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.confidentialityImpact

/**
 *  High impact.
 *
 *  Value: "IMPACT_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactHigh;
/**
 *  Low impact.
 *
 *  Value: "IMPACT_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactLow;
/**
 *  No impact.
 *
 *  Value: "IMPACT_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactNone;
/**
 *  Invalid value.
 *
 *  Value: "IMPACT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.integrityImpact

/**
 *  High impact.
 *
 *  Value: "IMPACT_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactHigh;
/**
 *  Low impact.
 *
 *  Value: "IMPACT_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactLow;
/**
 *  No impact.
 *
 *  Value: "IMPACT_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactNone;
/**
 *  Invalid value.
 *
 *  Value: "IMPACT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.privilegesRequired

/**
 *  The attacker requires privileges that provide significant (e.g.,
 *  administrative) control over the vulnerable component allowing access to
 *  component-wide settings and files.
 *
 *  Value: "PRIVILEGES_REQUIRED_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredHigh;
/**
 *  The attacker requires privileges that provide basic user capabilities that
 *  could normally affect only settings and files owned by a user.
 *  Alternatively, an attacker with Low privileges has the ability to access
 *  only non-sensitive resources.
 *
 *  Value: "PRIVILEGES_REQUIRED_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredLow;
/**
 *  The attacker is unauthorized prior to attack, and therefore does not require
 *  any access to settings or files of the vulnerable system to carry out an
 *  attack.
 *
 *  Value: "PRIVILEGES_REQUIRED_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredNone;
/**
 *  Invalid value.
 *
 *  Value: "PRIVILEGES_REQUIRED_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.scope

/**
 *  An exploited vulnerability can affect resources beyond the security scope
 *  managed by the security authority of the vulnerable component.
 *
 *  Value: "SCOPE_CHANGED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_Scope_ScopeChanged;
/**
 *  An exploited vulnerability can only affect resources managed by the same
 *  security authority.
 *
 *  Value: "SCOPE_UNCHANGED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_Scope_ScopeUnchanged;
/**
 *  Invalid value.
 *
 *  Value: "SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_Scope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_CVSSv3.userInteraction

/**
 *  The vulnerable system can be exploited without interaction from any user.
 *
 *  Value: "USER_INTERACTION_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_UserInteraction_UserInteractionNone;
/**
 *  Successful exploitation of this vulnerability requires a user to take some
 *  action before the vulnerability can be exploited.
 *
 *  Value: "USER_INTERACTION_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_UserInteraction_UserInteractionRequired;
/**
 *  Invalid value.
 *
 *  Value: "USER_INTERACTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_CVSSv3_UserInteraction_UserInteractionUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_ExecStepConfig.interpreter

/**
 *  If the interpreter is not specified, the value defaults to `NONE`.
 *
 *  Value: "INTERPRETER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_ExecStepConfig_Interpreter_InterpreterUnspecified;
/**
 *  Indicates that the file is run as follows on each operating system: + For
 *  Linux VMs, the file is ran as an executable and the interpreter might be
 *  parsed from the [shebang line](https://wikipedia.org/wiki/Shebang_(Unix)) of
 *  the file. + For Windows VM, this value is not supported.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_ExecStepConfig_Interpreter_None;
/**
 *  Indicates that the file is run with PowerShell.
 *
 *  Value: "POWERSHELL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_ExecStepConfig_Interpreter_Powershell;
/**
 *  Indicates that the file is run with `/bin/sh` on Linux and `cmd` on Windows.
 *
 *  Value: "SHELL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_ExecStepConfig_Interpreter_Shell;

// ----------------------------------------------------------------------------
// GTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata.apiMethod

/**
 *  Invalid value
 *
 *  Value: "API_METHOD_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_ApiMethodUnspecified;
/**
 *  Create OS policy assignment API method
 *
 *  Value: "CREATE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_Create;
/**
 *  Delete OS policy assignment API method
 *
 *  Value: "DELETE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_Delete;
/**
 *  Update OS policy assignment API method
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_Update;

// ----------------------------------------------------------------------------
// GTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata.rolloutState

/**
 *  The rollout is cancelled.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_Cancelled;
/**
 *  The rollout is being cancelled.
 *
 *  Value: "CANCELLING"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_Cancelling;
/**
 *  The rollout is in progress.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_InProgress;
/**
 *  Invalid value
 *
 *  Value: "ROLLOUT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_RolloutStateUnspecified;
/**
 *  The rollout has completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_Succeeded;

// ----------------------------------------------------------------------------
// GTLROSConfig_InventoryItem.originType

/**
 *  This inventory item was discovered as the result of the agent reporting
 *  inventory via the reporting API.
 *
 *  Value: "INVENTORY_REPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_InventoryItem_OriginType_InventoryReport;
/**
 *  Invalid. An origin type must be specified.
 *
 *  Value: "ORIGIN_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_InventoryItem_OriginType_OriginTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_InventoryItem.type

/**
 *  This represents an update that is available for a package.
 *
 *  Value: "AVAILABLE_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_InventoryItem_Type_AvailablePackage;
/**
 *  This represents a package that is installed on the VM.
 *
 *  Value: "INSTALLED_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_InventoryItem_Type_InstalledPackage;
/**
 *  Invalid. An type must be specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_InventoryItem_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicy.mode

/**
 *  This mode checks if the configuration resources in the policy are in their
 *  desired state, and if not, enforces the desired state.
 *
 *  Value: "ENFORCEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicy_Mode_Enforcement;
/**
 *  Invalid mode
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicy_Mode_ModeUnspecified;
/**
 *  This mode checks if the configuration resources in the policy are in their
 *  desired state. No actions are performed if they are not in the desired
 *  state. This mode is used for reporting purposes.
 *
 *  Value: "VALIDATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicy_Mode_Validation;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyAssignment.rolloutState

/**
 *  The rollout is cancelled.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignment_RolloutState_Cancelled;
/**
 *  The rollout is being cancelled.
 *
 *  Value: "CANCELLING"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignment_RolloutState_Cancelling;
/**
 *  The rollout is in progress.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignment_RolloutState_InProgress;
/**
 *  Invalid value
 *
 *  Value: "ROLLOUT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignment_RolloutState_RolloutStateUnspecified;
/**
 *  The rollout has completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignment_RolloutState_Succeeded;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyAssignmentOperationMetadata.apiMethod

/**
 *  Invalid value
 *
 *  Value: "API_METHOD_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_ApiMethodUnspecified;
/**
 *  Create OS policy assignment API method
 *
 *  Value: "CREATE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_Create;
/**
 *  Delete OS policy assignment API method
 *
 *  Value: "DELETE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_Delete;
/**
 *  Update OS policy assignment API method
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_Update;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyAssignmentOperationMetadata.rolloutState

/**
 *  The rollout is cancelled.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_Cancelled;
/**
 *  The rollout is being cancelled.
 *
 *  Value: "CANCELLING"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_Cancelling;
/**
 *  The rollout is in progress.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_InProgress;
/**
 *  Invalid value
 *
 *  Value: "ROLLOUT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_RolloutStateUnspecified;
/**
 *  The rollout has completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_Succeeded;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance.complianceState

/**
 *  Policy is compliant. The policy is compliant if all the underlying resources
 *  are also compliant.
 *
 *  Value: "COMPLIANT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance_ComplianceState_Compliant;
/**
 *  Policy is non-compliant. The policy is non-compliant if one or more
 *  underlying resources are non-compliant.
 *
 *  Value: "NON_COMPLIANT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance_ComplianceState_NonCompliant;
/**
 *  The policy is in an unknown compliance state. Refer to the field
 *  `compliance_state_reason` to learn the exact reason for the policy to be in
 *  this compliance state.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance_ComplianceState_Unknown;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance.complianceState

/**
 *  Resource is compliant.
 *
 *  Value: "COMPLIANT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance_ComplianceState_Compliant;
/**
 *  Resource is non-compliant.
 *
 *  Value: "NON_COMPLIANT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance_ComplianceState_NonCompliant;
/**
 *  The resource is in an unknown compliance state. To get more details about
 *  why the policy is in this state, review the output of the
 *  `compliance_state_reason` field.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance_ComplianceState_Unknown;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep.type

/**
 *  Checks the current status of the desired state for a resource.
 *
 *  Value: "DESIRED_STATE_CHECK"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_DesiredStateCheck;
/**
 *  Re-checks the status of the desired state. This check is done for a resource
 *  after the enforcement of all OS policies. This step is used to determine the
 *  final desired state status for the resource. It accounts for any resources
 *  that might have drifted from their desired state due to side effects from
 *  executing other resources.
 *
 *  Value: "DESIRED_STATE_CHECK_POST_ENFORCEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_DesiredStateCheckPostEnforcement;
/**
 *  Enforces the desired state for a resource that is not in desired state.
 *
 *  Value: "DESIRED_STATE_ENFORCEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_DesiredStateEnforcement;
/**
 *  Default value. This value is unused.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_TypeUnspecified;
/**
 *  Checks for resource conflicts such as schema errors.
 *
 *  Value: "VALIDATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_Validation;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyResourceExecResourceExec.interpreter

/**
 *  Invalid value, the request will return validation error.
 *
 *  Value: "INTERPRETER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_InterpreterUnspecified;
/**
 *  If an interpreter is not specified, the source is executed directly. This
 *  execution, without an interpreter, only succeeds for executables and scripts
 *  that have shebang lines.
 *
 *  Value: "NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_None;
/**
 *  Indicates that the script runs with PowerShell.
 *
 *  Value: "POWERSHELL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_Powershell;
/**
 *  Indicates that the script runs with `/bin/sh` on Linux and `cmd.exe` on
 *  Windows.
 *
 *  Value: "SHELL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_Shell;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyResourceFileResource.state

/**
 *  Ensure file at path is absent.
 *
 *  Value: "ABSENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceFileResource_State_Absent;
/**
 *  Ensure the contents of the file at path matches. If the file does not exist
 *  it will be created.
 *
 *  Value: "CONTENTS_MATCH"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceFileResource_State_ContentsMatch;
/**
 *  Unspecified is invalid.
 *
 *  Value: "DESIRED_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceFileResource_State_DesiredStateUnspecified;
/**
 *  Ensure file at path is present.
 *
 *  Value: "PRESENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceFileResource_State_Present;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyResourcePackageResource.desiredState

/**
 *  Unspecified is invalid.
 *
 *  Value: "DESIRED_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourcePackageResource_DesiredState_DesiredStateUnspecified;
/**
 *  Ensure that the package is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourcePackageResource_DesiredState_Installed;
/**
 *  The agent ensures that the package is not installed and uninstalls it if
 *  detected.
 *
 *  Value: "REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourcePackageResource_DesiredState_Removed;

// ----------------------------------------------------------------------------
// GTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository.archiveType

/**
 *  Unspecified is invalid.
 *
 *  Value: "ARCHIVE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository_ArchiveType_ArchiveTypeUnspecified;
/**
 *  Deb indicates that the archive contains binary files.
 *
 *  Value: "DEB"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository_ArchiveType_Deb;
/**
 *  Deb-src indicates that the archive contains source files.
 *
 *  Value: "DEB_SRC"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository_ArchiveType_DebSrc;

// ----------------------------------------------------------------------------
// GTLROSConfig_PatchConfig.rebootConfig

/**
 *  Always reboot the machine after the update completes.
 *
 *  Value: "ALWAYS"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchConfig_RebootConfig_Always;
/**
 *  The agent decides if a reboot is necessary by checking signals such as
 *  registry keys on Windows or `/var/run/reboot-required` on APT based systems.
 *  On RPM based systems, a set of core system package install times are
 *  compared with system boot time.
 *
 *  Value: "DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchConfig_RebootConfig_Default;
/**
 *  Never reboot the machine after the update completes.
 *
 *  Value: "NEVER"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchConfig_RebootConfig_Never;
/**
 *  The default behavior is DEFAULT.
 *
 *  Value: "REBOOT_CONFIG_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchConfig_RebootConfig_RebootConfigUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_PatchDeployment.state

/**
 *  Active value means that patch deployment generates Patch Jobs.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchDeployment_State_Active;
/**
 *  Paused value means that patch deployment does not generate Patch jobs.
 *  Requires user action to move in and out from this state.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchDeployment_State_Paused;
/**
 *  The default value. This value is used if the state is omitted.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchDeployment_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLROSConfig_PatchJob.state

/**
 *  The patch job was canceled.
 *
 *  Value: "CANCELED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_Canceled;
/**
 *  Patch job completed but there were errors.
 *
 *  Value: "COMPLETED_WITH_ERRORS"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_CompletedWithErrors;
/**
 *  The patch job is looking up instances to run the patch on.
 *
 *  Value: "INSTANCE_LOOKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_InstanceLookup;
/**
 *  Instances are being patched.
 *
 *  Value: "PATCHING"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_Patching;
/**
 *  The patch job was successfully initiated.
 *
 *  Value: "STARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_Started;
/**
 *  State must be specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_StateUnspecified;
/**
 *  Patch job completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_Succeeded;
/**
 *  The patch job timed out.
 *
 *  Value: "TIMED_OUT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJob_State_TimedOut;

// ----------------------------------------------------------------------------
// GTLROSConfig_PatchJobInstanceDetails.state

/**
 *  The instance acked the notification and will start shortly.
 *
 *  Value: "ACKED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Acked;
/**
 *  The instance is applying patches.
 *
 *  Value: "APPLYING_PATCHES"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_ApplyingPatches;
/**
 *  The instance is downloading patches.
 *
 *  Value: "DOWNLOADING_PATCHES"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_DownloadingPatches;
/**
 *  The instance has failed to apply the patch.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Failed;
/**
 *  Instance is inactive and cannot be patched.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Inactive;
/**
 *  The service could not detect the presence of the agent. Check to ensure that
 *  the agent is installed, running, and able to communicate with the service.
 *
 *  Value: "NO_AGENT_DETECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_NoAgentDetected;
/**
 *  The instance is notified that it should be patched.
 *
 *  Value: "NOTIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Notified;
/**
 *  Unspecified.
 *
 *  Value: "PATCH_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_PatchStateUnspecified;
/**
 *  The instance is not yet notified.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Pending;
/**
 *  The instance is rebooting.
 *
 *  Value: "REBOOTING"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Rebooting;
/**
 *  The instance is running the post-patch step.
 *
 *  Value: "RUNNING_POST_PATCH_STEP"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_RunningPostPatchStep;
/**
 *  The instance is running the pre-patch step.
 *
 *  Value: "RUNNING_PRE_PATCH_STEP"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_RunningPrePatchStep;
/**
 *  The instance has started the patching process.
 *
 *  Value: "STARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Started;
/**
 *  The instance has completed applying patches.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_Succeeded;
/**
 *  The instance has completed applying patches but a reboot is required.
 *
 *  Value: "SUCCEEDED_REBOOT_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_SucceededRebootRequired;
/**
 *  The instance exceeded the time out while applying the patch.
 *
 *  Value: "TIMED_OUT"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchJobInstanceDetails_State_TimedOut;

// ----------------------------------------------------------------------------
// GTLROSConfig_PatchRollout.mode

/**
 *  Patches are applied to VMs in all zones at the same time.
 *
 *  Value: "CONCURRENT_ZONES"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchRollout_Mode_ConcurrentZones;
/**
 *  Mode must be specified.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchRollout_Mode_ModeUnspecified;
/**
 *  Patches are applied one zone at a time. The patch job begins in the region
 *  with the lowest number of targeted VMs. Within the region, patching begins
 *  in the zone with the lowest number of targeted VMs. If multiple regions (or
 *  zones within a region) have the same number of targeted VMs, a tie-breaker
 *  is achieved by sorting the regions or zones in alphabetical order.
 *
 *  Value: "ZONE_BY_ZONE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_PatchRollout_Mode_ZoneByZone;

// ----------------------------------------------------------------------------
// GTLROSConfig_RecurringSchedule.frequency

/**
 *  Indicates that the frequency of recurrence should be expressed in terms of
 *  days.
 *
 *  Value: "DAILY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_RecurringSchedule_Frequency_Daily;
/**
 *  Invalid. A frequency must be specified.
 *
 *  Value: "FREQUENCY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_RecurringSchedule_Frequency_FrequencyUnspecified;
/**
 *  Indicates that the frequency of recurrence should be expressed in terms of
 *  months.
 *
 *  Value: "MONTHLY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_RecurringSchedule_Frequency_Monthly;
/**
 *  Indicates that the frequency of recurrence should be expressed in terms of
 *  weeks.
 *
 *  Value: "WEEKLY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_RecurringSchedule_Frequency_Weekly;

// ----------------------------------------------------------------------------
// GTLROSConfig_WeekDayOfMonth.dayOfWeek

/**
 *  The day of the week is unspecified.
 *
 *  Value: "DAY_OF_WEEK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_DayOfWeekUnspecified;
/**
 *  Friday
 *
 *  Value: "FRIDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Friday;
/**
 *  Monday
 *
 *  Value: "MONDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Monday;
/**
 *  Saturday
 *
 *  Value: "SATURDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Saturday;
/**
 *  Sunday
 *
 *  Value: "SUNDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Sunday;
/**
 *  Thursday
 *
 *  Value: "THURSDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Thursday;
/**
 *  Tuesday
 *
 *  Value: "TUESDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Tuesday;
/**
 *  Wednesday
 *
 *  Value: "WEDNESDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Wednesday;

// ----------------------------------------------------------------------------
// GTLROSConfig_WeeklySchedule.dayOfWeek

/**
 *  The day of the week is unspecified.
 *
 *  Value: "DAY_OF_WEEK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_DayOfWeekUnspecified;
/**
 *  Friday
 *
 *  Value: "FRIDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Friday;
/**
 *  Monday
 *
 *  Value: "MONDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Monday;
/**
 *  Saturday
 *
 *  Value: "SATURDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Saturday;
/**
 *  Sunday
 *
 *  Value: "SUNDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Sunday;
/**
 *  Thursday
 *
 *  Value: "THURSDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Thursday;
/**
 *  Tuesday
 *
 *  Value: "TUESDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Tuesday;
/**
 *  Wednesday
 *
 *  Value: "WEDNESDAY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WeeklySchedule_DayOfWeek_Wednesday;

// ----------------------------------------------------------------------------
// GTLROSConfig_WindowsUpdateSettings.classifications

/**
 *  Invalid. If classifications are included, they must be specified.
 *
 *  Value: "CLASSIFICATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_ClassificationUnspecified;
/**
 *  "A widely released fix for a specific problem that addresses a critical,
 *  non-security-related bug." [1]
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_Critical;
/**
 *  "A widely released and frequent software update that contains additions to a
 *  product's definition database. Definition databases are often used to detect
 *  objects that have specific attributes, such as malicious code, phishing
 *  websites, or junk mail." [1]
 *
 *  Value: "DEFINITION"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_Definition;
/**
 *  "Software that controls the input and output of a device." [1]
 *
 *  Value: "DRIVER"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_Driver;
/**
 *  "New product functionality that is first distributed outside the context of
 *  a product release and that is typically included in the next full product
 *  release." [1]
 *
 *  Value: "FEATURE_PACK"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_FeaturePack;
/**
 *  "A widely released fix for a product-specific, security-related
 *  vulnerability. Security vulnerabilities are rated by their severity. The
 *  severity rating is indicated in the Microsoft security bulletin as critical,
 *  important, moderate, or low." [1]
 *
 *  Value: "SECURITY"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_Security;
/**
 *  "A tested, cumulative set of all hotfixes, security updates, critical
 *  updates, and updates. Additionally, service packs may contain additional
 *  fixes for problems that are found internally since the release of the
 *  product. Service packs my also contain a limited number of
 *  customer-requested design changes or features." [1]
 *
 *  Value: "SERVICE_PACK"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_ServicePack;
/**
 *  "A utility or feature that helps complete a task or set of tasks." [1]
 *
 *  Value: "TOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_Tool;
/**
 *  "A widely released fix for a specific problem. An update addresses a
 *  noncritical, non-security-related bug." [1]
 *
 *  Value: "UPDATE"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_Update;
/**
 *  "A tested, cumulative set of hotfixes, security updates, critical updates,
 *  and updates that are packaged together for easy deployment. A rollup
 *  generally targets a specific area, such as security, or a component of a
 *  product, such as Internet Information Services (IIS)." [1]
 *
 *  Value: "UPDATE_ROLLUP"
 */
FOUNDATION_EXTERN NSString * const kGTLROSConfig_WindowsUpdateSettings_Classifications_UpdateRollup;

/**
 *  Apt patching is completed by executing `apt-get update && apt-get upgrade`.
 *  Additional options can be set to control how this is executed.
 */
@interface GTLROSConfig_AptSettings : GTLRObject

/**
 *  List of packages to exclude from update. These packages will be excluded
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludes;

/**
 *  An exclusive list of packages to be updated. These are the only packages
 *  that will be updated. If these packages are not installed, they will be
 *  ignored. This field cannot be specified with any other patch configuration
 *  fields.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exclusivePackages;

/**
 *  By changing the type to DIST, the patching is performed using `apt-get
 *  dist-upgrade` instead.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_AptSettings_Type_Dist Runs `apt-get dist-upgrade`.
 *        (Value: "DIST")
 *    @arg @c kGTLROSConfig_AptSettings_Type_TypeUnspecified By default, upgrade
 *        will be performed. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_AptSettings_Type_Upgrade Runs `apt-get upgrade`.
 *        (Value: "UPGRADE")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLROSConfig_CancelOperationRequest : GTLRObject
@end


/**
 *  Message for canceling a patch job.
 */
@interface GTLROSConfig_CancelPatchJobRequest : GTLRObject
@end


/**
 *  Common Vulnerability Scoring System version 3. For details, see
 *  https://www.first.org/cvss/specification-document
 */
@interface GTLROSConfig_CVSSv3 : GTLRObject

/**
 *  This metric describes the conditions beyond the attacker's control that must
 *  exist in order to exploit the vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_AttackComplexity_AttackComplexityHigh A
 *        successful attack depends on conditions beyond the attacker's control.
 *        That is, a successful attack cannot be accomplished at will, but
 *        requires the attacker to invest in some measurable amount of effort in
 *        preparation or execution against the vulnerable component before a
 *        successful attack can be expected. (Value: "ATTACK_COMPLEXITY_HIGH")
 *    @arg @c kGTLROSConfig_CVSSv3_AttackComplexity_AttackComplexityLow
 *        Specialized access conditions or extenuating circumstances do not
 *        exist. An attacker can expect repeatable success when attacking the
 *        vulnerable component. (Value: "ATTACK_COMPLEXITY_LOW")
 *    @arg @c kGTLROSConfig_CVSSv3_AttackComplexity_AttackComplexityUnspecified
 *        Invalid value. (Value: "ATTACK_COMPLEXITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *attackComplexity;

/**
 *  This metric reflects the context by which vulnerability exploitation is
 *  possible.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_AttackVector_AttackVectorAdjacent The
 *        vulnerable component is bound to the network stack, but the attack is
 *        limited at the protocol level to a logically adjacent topology.
 *        (Value: "ATTACK_VECTOR_ADJACENT")
 *    @arg @c kGTLROSConfig_CVSSv3_AttackVector_AttackVectorLocal The vulnerable
 *        component is not bound to the network stack and the attacker's path is
 *        via read/write/execute capabilities. (Value: "ATTACK_VECTOR_LOCAL")
 *    @arg @c kGTLROSConfig_CVSSv3_AttackVector_AttackVectorNetwork The
 *        vulnerable component is bound to the network stack and the set of
 *        possible attackers extends beyond the other options listed below, up
 *        to and including the entire Internet. (Value: "ATTACK_VECTOR_NETWORK")
 *    @arg @c kGTLROSConfig_CVSSv3_AttackVector_AttackVectorPhysical The attack
 *        requires the attacker to physically touch or manipulate the vulnerable
 *        component. (Value: "ATTACK_VECTOR_PHYSICAL")
 *    @arg @c kGTLROSConfig_CVSSv3_AttackVector_AttackVectorUnspecified Invalid
 *        value. (Value: "ATTACK_VECTOR_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *attackVector;

/**
 *  This metric measures the impact to the availability of the impacted
 *  component resulting from a successfully exploited vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactHigh High impact.
 *        (Value: "IMPACT_HIGH")
 *    @arg @c kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactLow Low impact.
 *        (Value: "IMPACT_LOW")
 *    @arg @c kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactNone No impact.
 *        (Value: "IMPACT_NONE")
 *    @arg @c kGTLROSConfig_CVSSv3_AvailabilityImpact_ImpactUnspecified Invalid
 *        value. (Value: "IMPACT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *availabilityImpact;

/**
 *  The base score is a function of the base metric scores.
 *  https://www.first.org/cvss/specification-document#Base-Metrics
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *baseScore;

/**
 *  This metric measures the impact to the confidentiality of the information
 *  resources managed by a software component due to a successfully exploited
 *  vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactHigh High impact.
 *        (Value: "IMPACT_HIGH")
 *    @arg @c kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactLow Low impact.
 *        (Value: "IMPACT_LOW")
 *    @arg @c kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactNone No impact.
 *        (Value: "IMPACT_NONE")
 *    @arg @c kGTLROSConfig_CVSSv3_ConfidentialityImpact_ImpactUnspecified
 *        Invalid value. (Value: "IMPACT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *confidentialityImpact;

/**
 *  The Exploitability sub-score equation is derived from the Base
 *  Exploitability metrics.
 *  https://www.first.org/cvss/specification-document#2-1-Exploitability-Metrics
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exploitabilityScore;

/**
 *  The Impact sub-score equation is derived from the Base Impact metrics.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *impactScore;

/**
 *  This metric measures the impact to integrity of a successfully exploited
 *  vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactHigh High impact.
 *        (Value: "IMPACT_HIGH")
 *    @arg @c kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactLow Low impact. (Value:
 *        "IMPACT_LOW")
 *    @arg @c kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactNone No impact. (Value:
 *        "IMPACT_NONE")
 *    @arg @c kGTLROSConfig_CVSSv3_IntegrityImpact_ImpactUnspecified Invalid
 *        value. (Value: "IMPACT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *integrityImpact;

/**
 *  This metric describes the level of privileges an attacker must possess
 *  before successfully exploiting the vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredHigh The
 *        attacker requires privileges that provide significant (e.g.,
 *        administrative) control over the vulnerable component allowing access
 *        to component-wide settings and files. (Value:
 *        "PRIVILEGES_REQUIRED_HIGH")
 *    @arg @c kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredLow The
 *        attacker requires privileges that provide basic user capabilities that
 *        could normally affect only settings and files owned by a user.
 *        Alternatively, an attacker with Low privileges has the ability to
 *        access only non-sensitive resources. (Value:
 *        "PRIVILEGES_REQUIRED_LOW")
 *    @arg @c kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredNone The
 *        attacker is unauthorized prior to attack, and therefore does not
 *        require any access to settings or files of the vulnerable system to
 *        carry out an attack. (Value: "PRIVILEGES_REQUIRED_NONE")
 *    @arg @c kGTLROSConfig_CVSSv3_PrivilegesRequired_PrivilegesRequiredUnspecified
 *        Invalid value. (Value: "PRIVILEGES_REQUIRED_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *privilegesRequired;

/**
 *  The Scope metric captures whether a vulnerability in one vulnerable
 *  component impacts resources in components beyond its security scope.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_Scope_ScopeChanged An exploited vulnerability
 *        can affect resources beyond the security scope managed by the security
 *        authority of the vulnerable component. (Value: "SCOPE_CHANGED")
 *    @arg @c kGTLROSConfig_CVSSv3_Scope_ScopeUnchanged An exploited
 *        vulnerability can only affect resources managed by the same security
 *        authority. (Value: "SCOPE_UNCHANGED")
 *    @arg @c kGTLROSConfig_CVSSv3_Scope_ScopeUnspecified Invalid value. (Value:
 *        "SCOPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *scope;

/**
 *  This metric captures the requirement for a human user, other than the
 *  attacker, to participate in the successful compromise of the vulnerable
 *  component.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_CVSSv3_UserInteraction_UserInteractionNone The
 *        vulnerable system can be exploited without interaction from any user.
 *        (Value: "USER_INTERACTION_NONE")
 *    @arg @c kGTLROSConfig_CVSSv3_UserInteraction_UserInteractionRequired
 *        Successful exploitation of this vulnerability requires a user to take
 *        some action before the vulnerability can be exploited. (Value:
 *        "USER_INTERACTION_REQUIRED")
 *    @arg @c kGTLROSConfig_CVSSv3_UserInteraction_UserInteractionUnspecified
 *        Invalid value. (Value: "USER_INTERACTION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *userInteraction;

@end


/**
 *  Represents a whole or partial calendar date, such as a birthday. The time of
 *  day and time zone are either specified elsewhere or are insignificant. The
 *  date is relative to the Gregorian Calendar. This can represent one of the
 *  following: * A full date, with non-zero year, month, and day values. * A
 *  month and day, with a zero year (for example, an anniversary). * A year on
 *  its own, with a zero month and a zero day. * A year and month, with a zero
 *  day (for example, a credit card expiration date). Related types: *
 *  google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
 */
@interface GTLROSConfig_Date : GTLRObject

/**
 *  Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
 *  to specify a year by itself or a year and month where the day isn't
 *  significant.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *day;

/**
 *  Month of a year. Must be from 1 to 12, or 0 to specify a year without a
 *  month and day.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *month;

/**
 *  Year of the date. Must be from 1 to 9999, or 0 to specify a date without a
 *  year.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *year;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLROSConfig_Empty : GTLRObject
@end


/**
 *  A step that runs an executable for a PatchJob.
 */
@interface GTLROSConfig_ExecStep : GTLRObject

/** The ExecStepConfig for all Linux VMs targeted by the PatchJob. */
@property(nonatomic, strong, nullable) GTLROSConfig_ExecStepConfig *linuxExecStepConfig;

/** The ExecStepConfig for all Windows VMs targeted by the PatchJob. */
@property(nonatomic, strong, nullable) GTLROSConfig_ExecStepConfig *windowsExecStepConfig;

@end


/**
 *  Common configurations for an ExecStep.
 */
@interface GTLROSConfig_ExecStepConfig : GTLRObject

/**
 *  Defaults to [0]. A list of possible return values that the execution can
 *  return to indicate a success.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *allowedSuccessCodes;

/** A Cloud Storage object containing the executable. */
@property(nonatomic, strong, nullable) GTLROSConfig_GcsObject *gcsObject;

/**
 *  The script interpreter to use to run the script. If no interpreter is
 *  specified the script will be executed directly, which will likely only
 *  succeed for scripts with [shebang lines]
 *  (https://en.wikipedia.org/wiki/Shebang_\\(Unix\\)).
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_ExecStepConfig_Interpreter_InterpreterUnspecified If
 *        the interpreter is not specified, the value defaults to `NONE`.
 *        (Value: "INTERPRETER_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_ExecStepConfig_Interpreter_None Indicates that the
 *        file is run as follows on each operating system: + For Linux VMs, the
 *        file is ran as an executable and the interpreter might be parsed from
 *        the [shebang line](https://wikipedia.org/wiki/Shebang_(Unix)) of the
 *        file. + For Windows VM, this value is not supported. (Value: "NONE")
 *    @arg @c kGTLROSConfig_ExecStepConfig_Interpreter_Powershell Indicates that
 *        the file is run with PowerShell. (Value: "POWERSHELL")
 *    @arg @c kGTLROSConfig_ExecStepConfig_Interpreter_Shell Indicates that the
 *        file is run with `/bin/sh` on Linux and `cmd` on Windows. (Value:
 *        "SHELL")
 */
@property(nonatomic, copy, nullable) NSString *interpreter;

/** An absolute path to the executable on the VM. */
@property(nonatomic, copy, nullable) NSString *localPath;

@end


/**
 *  A request message to initiate patching across Compute Engine instances.
 */
@interface GTLROSConfig_ExecutePatchJobRequest : GTLRObject

/**
 *  Description of the patch job. Length of the description is limited to 1024
 *  characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Display name for this patch job. This does not have to be unique. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  If this patch is a dry-run only, instances are contacted but will do
 *  nothing.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dryRun;

/**
 *  Duration of the patch job. After the duration ends, the patch job times out.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  Required. Instances to patch, either explicitly or filtered by some criteria
 *  such as zone or labels.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchInstanceFilter *instanceFilter;

/**
 *  Patch configuration being applied. If omitted, instances are patched using
 *  the default configurations.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchConfig *patchConfig;

/** Rollout strategy of the patch job. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchRollout *rollout;

@end


/**
 *  Message encapsulating a value that can be either absolute ("fixed") or
 *  relative ("percent") to a value.
 */
@interface GTLROSConfig_FixedOrPercent : GTLRObject

/**
 *  Specifies a fixed value.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fixed;

/**
 *  Specifies the relative value defined as a percentage, which will be
 *  multiplied by a reference value.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percent;

@end


/**
 *  Cloud Storage object representation.
 */
@interface GTLROSConfig_GcsObject : GTLRObject

/** Required. Bucket of the Cloud Storage object. */
@property(nonatomic, copy, nullable) NSString *bucket;

/**
 *  Required. Generation number of the Cloud Storage object. This is used to
 *  ensure that the ExecStep specified by this PatchJob does not change.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *generationNumber;

/** Required. Name of the Cloud Storage object. */
@property(nonatomic, copy, nullable) NSString *object;

@end


/**
 *  OS policy assignment operation metadata provided by OS policy assignment API
 *  methods that return long running operations.
 */
@interface GTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata : GTLRObject

/**
 *  The OS policy assignment API method.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_ApiMethodUnspecified
 *        Invalid value (Value: "API_METHOD_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_Create
 *        Create OS policy assignment API method (Value: "CREATE")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_Delete
 *        Delete OS policy assignment API method (Value: "DELETE")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_ApiMethod_Update
 *        Update OS policy assignment API method (Value: "UPDATE")
 */
@property(nonatomic, copy, nullable) NSString *apiMethod;

/**
 *  Reference to the `OSPolicyAssignment` API resource. Format:
 *  `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id\@revision_id}`
 */
@property(nonatomic, copy, nullable) NSString *osPolicyAssignment;

/** Rollout start time */
@property(nonatomic, strong, nullable) GTLRDateTime *rolloutStartTime;

/**
 *  State of the rollout
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_Cancelled
 *        The rollout is cancelled. (Value: "CANCELLED")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_Cancelling
 *        The rollout is being cancelled. (Value: "CANCELLING")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_InProgress
 *        The rollout is in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_RolloutStateUnspecified
 *        Invalid value (Value: "ROLLOUT_STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_GoogleCloudOsconfigV1OSPolicyAssignmentOperationMetadata_RolloutState_Succeeded
 *        The rollout has completed successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *rolloutState;

/** Rollout update time */
@property(nonatomic, strong, nullable) GTLRDateTime *rolloutUpdateTime;

@end


/**
 *  Googet patching is performed by running `googet update`.
 */
@interface GTLROSConfig_GooSettings : GTLRObject
@end


/**
 *  This API resource represents the available inventory data for a Compute
 *  Engine virtual machine (VM) instance at a given point in time. You can use
 *  this API resource to determine the inventory data of your VM. For more
 *  information, see [Information provided by OS inventory
 *  management](https://cloud.google.com/compute/docs/instances/os-inventory-management#data-collected).
 */
@interface GTLROSConfig_Inventory : GTLRObject

/**
 *  Inventory items related to the VM keyed by an opaque unique identifier for
 *  each inventory item. The identifier is unique to each distinct and
 *  addressable inventory item and will change, when there is a new package
 *  version.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_Inventory_Items *items;

/**
 *  Output only. The `Inventory` API resource name. Format:
 *  `projects/{project_number}/locations/{location}/instances/{instance_id}/inventory`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Base level operating system information for the VM. */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryOsInfo *osInfo;

/** Output only. Timestamp of the last reported inventory for the VM. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Inventory items related to the VM keyed by an opaque unique identifier for
 *  each inventory item. The identifier is unique to each distinct and
 *  addressable inventory item and will change, when there is a new package
 *  version.
 *
 *  @note This class is documented as having more properties of
 *        GTLROSConfig_InventoryItem. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLROSConfig_Inventory_Items : GTLRObject
@end


/**
 *  A single piece of inventory on a VM.
 */
@interface GTLROSConfig_InventoryItem : GTLRObject

/** Software package available to be installed on the VM instance. */
@property(nonatomic, strong, nullable) GTLROSConfig_InventorySoftwarePackage *availablePackage;

/** When this inventory item was first detected. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Identifier for this item, unique across items for this VM.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Software package present on the VM instance. */
@property(nonatomic, strong, nullable) GTLROSConfig_InventorySoftwarePackage *installedPackage;

/**
 *  The origin of this inventory item.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_InventoryItem_OriginType_InventoryReport This
 *        inventory item was discovered as the result of the agent reporting
 *        inventory via the reporting API. (Value: "INVENTORY_REPORT")
 *    @arg @c kGTLROSConfig_InventoryItem_OriginType_OriginTypeUnspecified
 *        Invalid. An origin type must be specified. (Value:
 *        "ORIGIN_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *originType;

/**
 *  The specific type of inventory, correlating to its specific details.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_InventoryItem_Type_AvailablePackage This represents
 *        an update that is available for a package. (Value:
 *        "AVAILABLE_PACKAGE")
 *    @arg @c kGTLROSConfig_InventoryItem_Type_InstalledPackage This represents
 *        a package that is installed on the VM. (Value: "INSTALLED_PACKAGE")
 *    @arg @c kGTLROSConfig_InventoryItem_Type_TypeUnspecified Invalid. An type
 *        must be specified. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

/** When this inventory item was last modified. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Operating system information for the VM.
 */
@interface GTLROSConfig_InventoryOsInfo : GTLRObject

/** The system architecture of the operating system. */
@property(nonatomic, copy, nullable) NSString *architecture;

/** The VM hostname. */
@property(nonatomic, copy, nullable) NSString *hostname;

/** The kernel release of the operating system. */
@property(nonatomic, copy, nullable) NSString *kernelRelease;

/** The kernel version of the operating system. */
@property(nonatomic, copy, nullable) NSString *kernelVersion;

/**
 *  The operating system long name. For example 'Debian GNU/Linux 9' or
 *  'Microsoft Window Server 2019 Datacenter'.
 */
@property(nonatomic, copy, nullable) NSString *longName;

/** The current version of the OS Config agent running on the VM. */
@property(nonatomic, copy, nullable) NSString *osconfigAgentVersion;

/** The operating system short name. For example, 'windows' or 'debian'. */
@property(nonatomic, copy, nullable) NSString *shortName;

/** The version of the operating system. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Software package information of the operating system.
 */
@interface GTLROSConfig_InventorySoftwarePackage : GTLRObject

/**
 *  Details of an APT package. For details about the apt package manager, see
 *  https://wiki.debian.org/Apt.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryVersionedPackage *aptPackage;

/** Details of a COS package. */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryVersionedPackage *cosPackage;

/**
 *  Details of a Googet package. For details about the googet package manager,
 *  see https://github.com/google/googet.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryVersionedPackage *googetPackage;

/**
 *  Details of a Windows Quick Fix engineering package. See
 *  https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
 *  for info in Windows Quick Fix Engineering.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryWindowsQuickFixEngineeringPackage *qfePackage;

/** Details of Windows Application. */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryWindowsApplication *windowsApplication;

/**
 *  Details of a Windows Update package. See
 *  https://docs.microsoft.com/en-us/windows/win32/api/_wua/ for information
 *  about Windows Update.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryWindowsUpdatePackage *wuaPackage;

/**
 *  Yum package info. For details about the yum package manager, see
 *  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryVersionedPackage *yumPackage;

/**
 *  Details of a Zypper package. For details about the Zypper package manager,
 *  see https://en.opensuse.org/SDB:Zypper_manual.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryVersionedPackage *zypperPackage;

/**
 *  Details of a Zypper patch. For details about the Zypper package manager, see
 *  https://en.opensuse.org/SDB:Zypper_manual.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_InventoryZypperPatch *zypperPatch;

@end


/**
 *  Information related to the a standard versioned package. This includes
 *  package info for APT, Yum, Zypper, and Googet package managers.
 */
@interface GTLROSConfig_InventoryVersionedPackage : GTLRObject

/** The system architecture this package is intended for. */
@property(nonatomic, copy, nullable) NSString *architecture;

/** The name of the package. */
@property(nonatomic, copy, nullable) NSString *packageName;

/** The version of the package. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Contains information about a Windows application that is retrieved from the
 *  Windows Registry. For more information about these fields, see:
 *  https://docs.microsoft.com/en-us/windows/win32/msi/uninstall-registry-key
 */
@interface GTLROSConfig_InventoryWindowsApplication : GTLRObject

/** The name of the application or product. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** The version of the product or application in string format. */
@property(nonatomic, copy, nullable) NSString *displayVersion;

/** The internet address for technical support. */
@property(nonatomic, copy, nullable) NSString *helpLink;

/**
 *  The last time this product received service. The value of this property is
 *  replaced each time a patch is applied or removed from the product or the
 *  command-line option is used to repair the product.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_Date *installDate;

/** The name of the manufacturer for the product or application. */
@property(nonatomic, copy, nullable) NSString *publisher;

@end


/**
 *  Information related to a Quick Fix Engineering package. Fields are taken
 *  from Windows QuickFixEngineering Interface and match the source names:
 *  https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
 */
@interface GTLROSConfig_InventoryWindowsQuickFixEngineeringPackage : GTLRObject

/** A short textual description of the QFE update. */
@property(nonatomic, copy, nullable) NSString *caption;

/**
 *  A textual description of the QFE update.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Unique identifier associated with a particular QFE update. */
@property(nonatomic, copy, nullable) NSString *hotFixId;

/** Date that the QFE update was installed. Mapped from installed_on field. */
@property(nonatomic, strong, nullable) GTLRDateTime *installTime;

@end


/**
 *  Details related to a Windows Update package. Field data and names are taken
 *  from Windows Update API IUpdate Interface:
 *  https://docs.microsoft.com/en-us/windows/win32/api/_wua/ Descriptive fields
 *  like title, and description are localized based on the locale of the VM
 *  being updated.
 */
@interface GTLROSConfig_InventoryWindowsUpdatePackage : GTLRObject

/** The categories that are associated with this update package. */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_InventoryWindowsUpdatePackageWindowsUpdateCategory *> *categories;

/**
 *  The localized description of the update package.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A collection of Microsoft Knowledge Base article IDs that are associated
 *  with the update package.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kbArticleIds;

/** The last published date of the update, in (UTC) date and time. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastDeploymentChangeTime;

/**
 *  A collection of URLs that provide more information about the update package.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *moreInfoUrls;

/**
 *  The revision number of this update package.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *revisionNumber;

/**
 *  A hyperlink to the language-specific support information for the update.
 */
@property(nonatomic, copy, nullable) NSString *supportUrl;

/** The localized title of the update package. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  Gets the identifier of an update package. Stays the same across revisions.
 */
@property(nonatomic, copy, nullable) NSString *updateId;

@end


/**
 *  Categories specified by the Windows Update.
 */
@interface GTLROSConfig_InventoryWindowsUpdatePackageWindowsUpdateCategory : GTLRObject

/**
 *  The identifier of the windows update category.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** The name of the windows update category. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Details related to a Zypper Patch.
 */
@interface GTLROSConfig_InventoryZypperPatch : GTLRObject

/** The category of the patch. */
@property(nonatomic, copy, nullable) NSString *category;

/** The name of the patch. */
@property(nonatomic, copy, nullable) NSString *patchName;

/** The severity specified for this patch */
@property(nonatomic, copy, nullable) NSString *severity;

/** Any summary information provided about this patch. */
@property(nonatomic, copy, nullable) NSString *summary;

@end


/**
 *  A response message for listing inventory data for all VMs in a specified
 *  location.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "inventories" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLROSConfig_ListInventoriesResponse : GTLRCollectionObject

/**
 *  List of inventory objects.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_Inventory *> *inventories;

/** The pagination token to retrieve the next page of inventory objects. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  A response message for listing OS Policy assignment reports including the
 *  page of results and page token.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "osPolicyAssignmentReports" property. If returned as the result of
 *        a query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLROSConfig_ListOSPolicyAssignmentReportsResponse : GTLRCollectionObject

/**
 *  The pagination token to retrieve the next page of OS policy assignment
 *  report objects.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  List of OS policy assignment reports.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentReport *> *osPolicyAssignmentReports;

@end


/**
 *  A response message for listing all revisions for a OS policy assignment.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "osPolicyAssignments" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLROSConfig_ListOSPolicyAssignmentRevisionsResponse : GTLRCollectionObject

/**
 *  The pagination token to retrieve the next page of OS policy assignment
 *  revisions.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The OS policy assignment revisions
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignment *> *osPolicyAssignments;

@end


/**
 *  A response message for listing all assignments under given parent.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "osPolicyAssignments" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLROSConfig_ListOSPolicyAssignmentsResponse : GTLRCollectionObject

/**
 *  The pagination token to retrieve the next page of OS policy assignments.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of assignments
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignment *> *osPolicyAssignments;

@end


/**
 *  A response message for listing patch deployments.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "patchDeployments" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLROSConfig_ListPatchDeploymentsResponse : GTLRCollectionObject

/**
 *  A pagination token that can be used to get the next page of patch
 *  deployments.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of patch deployments.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_PatchDeployment *> *patchDeployments;

@end


/**
 *  A response message for listing the instances details for a patch job.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "patchJobInstanceDetails" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLROSConfig_ListPatchJobInstanceDetailsResponse : GTLRCollectionObject

/** A pagination token that can be used to get the next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of instance status.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_PatchJobInstanceDetails *> *patchJobInstanceDetails;

@end


/**
 *  A response message for listing patch jobs.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "patchJobs" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLROSConfig_ListPatchJobsResponse : GTLRCollectionObject

/** A pagination token that can be used to get the next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of patch jobs.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_PatchJob *> *patchJobs;

@end


/**
 *  A response message for listing vulnerability reports for all VM instances in
 *  the specified location.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "vulnerabilityReports" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLROSConfig_ListVulnerabilityReportsResponse : GTLRCollectionObject

/**
 *  The pagination token to retrieve the next page of vulnerabilityReports
 *  object.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  List of vulnerabilityReport objects.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_VulnerabilityReport *> *vulnerabilityReports;

@end


/**
 *  Represents a monthly schedule. An example of a valid monthly schedule is "on
 *  the third Tuesday of the month" or "on the 15th of the month".
 */
@interface GTLROSConfig_MonthlySchedule : GTLRObject

/**
 *  Required. One day of the month. 1-31 indicates the 1st to the 31st day. -1
 *  indicates the last day of the month. Months without the target day will be
 *  skipped. For example, a schedule to run "every month on the 31st" will not
 *  run in February, April, June, etc.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *monthDay;

/** Required. Week day in a month. */
@property(nonatomic, strong, nullable) GTLROSConfig_WeekDayOfMonth *weekDayOfMonth;

@end


/**
 *  Sets the time for a one time patch deployment. Timestamp is in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@interface GTLROSConfig_OneTimeSchedule : GTLRObject

/** Required. The desired patch job execution time. */
@property(nonatomic, strong, nullable) GTLRDateTime *executeTime;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLROSConfig_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLROSConfig_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROSConfig_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROSConfig_Operation_Response : GTLRObject
@end


/**
 *  An OS policy defines the desired state configuration for a VM.
 */
@interface GTLROSConfig_OSPolicy : GTLRObject

/**
 *  This flag determines the OS policy compliance status when none of the
 *  resource groups within the policy are applicable for a VM. Set this value to
 *  `true` if the policy needs to be reported as compliant even if the policy
 *  has nothing to validate or enforce.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowNoResourceGroupMatch;

/**
 *  Policy description. Length of the description is limited to 1024 characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. The id of the OS policy with the following restrictions: * Must
 *  contain only lowercase letters, numbers, and hyphens. * Must start with a
 *  letter. * Must be between 1-63 characters. * Must end with a number or a
 *  letter. * Must be unique within the assignment.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Required. Policy mode
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicy_Mode_Enforcement This mode checks if the
 *        configuration resources in the policy are in their desired state, and
 *        if not, enforces the desired state. (Value: "ENFORCEMENT")
 *    @arg @c kGTLROSConfig_OSPolicy_Mode_ModeUnspecified Invalid mode (Value:
 *        "MODE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicy_Mode_Validation This mode checks if the
 *        configuration resources in the policy are in their desired state. No
 *        actions are performed if they are not in the desired state. This mode
 *        is used for reporting purposes. (Value: "VALIDATION")
 */
@property(nonatomic, copy, nullable) NSString *mode;

/**
 *  Required. List of resource groups for the policy. For a particular VM,
 *  resource groups are evaluated in the order specified and the first resource
 *  group that is applicable is selected and the rest are ignored. If none of
 *  the resource groups are applicable for a VM, the VM is considered to be
 *  non-compliant w.r.t this policy. This behavior can be toggled by the flag
 *  `allow_no_resource_group_match`
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyResourceGroup *> *resourceGroups;

@end


/**
 *  OS policy assignment is an API resource that is used to apply a set of OS
 *  policies to a dynamically targeted group of Compute Engine VM instances. An
 *  OS policy is used to define the desired state configuration for a Compute
 *  Engine VM instance through a set of configuration resources that provide
 *  capabilities such as installing or removing software packages, or executing
 *  a script. For more information about the OS policy resource definitions and
 *  examples, see [OS policy and OS policy
 *  assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
 */
@interface GTLROSConfig_OSPolicyAssignment : GTLRObject

/**
 *  Output only. Indicates that this revision has been successfully rolled out
 *  in this zone and new VMs will be assigned OS policies from this revision.
 *  For a given OS policy assignment, there is only one revision with a value of
 *  `true` for this field.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *baseline;

/**
 *  Output only. Indicates that this revision deletes the OS policy assignment.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deleted;

/**
 *  OS policy assignment description. Length of the description is limited to
 *  1024 characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The etag for this OS policy assignment. If this is provided on update, it
 *  must match the server's etag.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Required. Filter to select VMs. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyAssignmentInstanceFilter *instanceFilter;

/**
 *  Resource name. Format:
 *  `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id}`
 *  This field is ignored when you create an OS policy assignment.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. List of OS policies to be applied to the VMs. */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicy *> *osPolicies;

/**
 *  Output only. Indicates that reconciliation is in progress for the revision.
 *  This value is `true` when the `rollout_state` is one of: * IN_PROGRESS *
 *  CANCELLING
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reconciling;

/** Output only. The timestamp that the revision was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *revisionCreateTime;

/**
 *  Output only. The assignment revision ID A new revision is committed whenever
 *  a rollout is triggered for a OS policy assignment
 */
@property(nonatomic, copy, nullable) NSString *revisionId;

/**
 *  Required. Rollout to deploy the OS policy assignment. A rollout is triggered
 *  in the following situations: 1) OSPolicyAssignment is created. 2)
 *  OSPolicyAssignment is updated and the update contains changes to one of the
 *  following fields: - instance_filter - os_policies 3) OSPolicyAssignment is
 *  deleted.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyAssignmentRollout *rollout;

/**
 *  Output only. OS policy assignment rollout state
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyAssignment_RolloutState_Cancelled The
 *        rollout is cancelled. (Value: "CANCELLED")
 *    @arg @c kGTLROSConfig_OSPolicyAssignment_RolloutState_Cancelling The
 *        rollout is being cancelled. (Value: "CANCELLING")
 *    @arg @c kGTLROSConfig_OSPolicyAssignment_RolloutState_InProgress The
 *        rollout is in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLROSConfig_OSPolicyAssignment_RolloutState_RolloutStateUnspecified
 *        Invalid value (Value: "ROLLOUT_STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyAssignment_RolloutState_Succeeded The
 *        rollout has completed successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *rolloutState;

/**
 *  Output only. Server generated unique id for the OS policy assignment
 *  resource.
 */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  Filters to select target VMs for an assignment. If more than one filter
 *  criteria is specified below, a VM will be selected if and only if it
 *  satisfies all of them.
 */
@interface GTLROSConfig_OSPolicyAssignmentInstanceFilter : GTLRObject

/**
 *  Target all VMs in the project. If true, no other criteria is permitted.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *all;

/**
 *  List of label sets used for VM exclusion. If the list has more than one
 *  label set, the VM is excluded if any of the label sets are applicable for
 *  the VM.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentLabelSet *> *exclusionLabels;

/**
 *  List of label sets used for VM inclusion. If the list has more than one
 *  `LabelSet`, the VM is included if any of the label sets are applicable for
 *  the VM.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentLabelSet *> *inclusionLabels;

/**
 *  List of inventories to select VMs. A VM is selected if its inventory data
 *  matches at least one of the following inventories.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentInstanceFilterInventory *> *inventories;

@end


/**
 *  VM inventory details.
 */
@interface GTLROSConfig_OSPolicyAssignmentInstanceFilterInventory : GTLRObject

/** Required. The OS short name */
@property(nonatomic, copy, nullable) NSString *osShortName;

/**
 *  The OS version Prefix matches are supported if asterisk(*) is provided as
 *  the last character. For example, to match all versions with a major version
 *  of `7`, specify the following value for this field `7.*` An empty string
 *  matches all OS versions.
 */
@property(nonatomic, copy, nullable) NSString *osVersion;

@end


/**
 *  Message representing label set. * A label is a key value pair set for a VM.
 *  * A LabelSet is a set of labels. * Labels within a LabelSet are ANDed. In
 *  other words, a LabelSet is applicable for a VM only if it matches all the
 *  labels in the LabelSet. * Example: A LabelSet with 2 labels: `env=prod` and
 *  `type=webserver` will only be applicable for those VMs with both labels
 *  present.
 */
@interface GTLROSConfig_OSPolicyAssignmentLabelSet : GTLRObject

/**
 *  Labels are identified by key/value pairs in this map. A VM should contain
 *  all the key/value pairs specified in this map to be selected.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyAssignmentLabelSet_Labels *labels;

@end


/**
 *  Labels are identified by key/value pairs in this map. A VM should contain
 *  all the key/value pairs specified in this map to be selected.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROSConfig_OSPolicyAssignmentLabelSet_Labels : GTLRObject
@end


/**
 *  OS policy assignment operation metadata provided by OS policy assignment API
 *  methods that return long running operations.
 */
@interface GTLROSConfig_OSPolicyAssignmentOperationMetadata : GTLRObject

/**
 *  The OS policy assignment API method.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_ApiMethodUnspecified
 *        Invalid value (Value: "API_METHOD_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_Create
 *        Create OS policy assignment API method (Value: "CREATE")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_Delete
 *        Delete OS policy assignment API method (Value: "DELETE")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_ApiMethod_Update
 *        Update OS policy assignment API method (Value: "UPDATE")
 */
@property(nonatomic, copy, nullable) NSString *apiMethod;

/**
 *  Reference to the `OSPolicyAssignment` API resource. Format:
 *  `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id\@revision_id}`
 */
@property(nonatomic, copy, nullable) NSString *osPolicyAssignment;

/** Rollout start time */
@property(nonatomic, strong, nullable) GTLRDateTime *rolloutStartTime;

/**
 *  State of the rollout
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_Cancelled
 *        The rollout is cancelled. (Value: "CANCELLED")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_Cancelling
 *        The rollout is being cancelled. (Value: "CANCELLING")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_InProgress
 *        The rollout is in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_RolloutStateUnspecified
 *        Invalid value (Value: "ROLLOUT_STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentOperationMetadata_RolloutState_Succeeded
 *        The rollout has completed successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *rolloutState;

/** Rollout update time */
@property(nonatomic, strong, nullable) GTLRDateTime *rolloutUpdateTime;

@end


/**
 *  A report of the OS policy assignment status for a given instance.
 */
@interface GTLROSConfig_OSPolicyAssignmentReport : GTLRObject

/** The Compute Engine VM instance name. */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  Unique identifier of the last attempted run to apply the OS policies
 *  associated with this assignment on the VM. This ID is logged by the OS
 *  Config agent while applying the OS policies associated with this assignment
 *  on the VM. NOTE: If the service is unable to successfully connect to the
 *  agent for this run, then this id will not be available in the agent logs.
 */
@property(nonatomic, copy, nullable) NSString *lastRunId;

/**
 *  The `OSPolicyAssignmentReport` API resource name. Format:
 *  `projects/{project_number}/locations/{location}/instances/{instance_id}/osPolicyAssignments/{os_policy_assignment_id}/report`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Reference to the `OSPolicyAssignment` API resource that the `OSPolicy`
 *  belongs to. Format:
 *  `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id\@revision_id}`
 */
@property(nonatomic, copy, nullable) NSString *osPolicyAssignment;

/** Compliance data for each `OSPolicy` that is applied to the VM. */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance *> *osPolicyCompliances;

/** Timestamp for when the report was last generated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Compliance data for an OS policy
 */
@interface GTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance : GTLRObject

/**
 *  The compliance state of the OS policy.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance_ComplianceState_Compliant
 *        Policy is compliant. The policy is compliant if all the underlying
 *        resources are also compliant. (Value: "COMPLIANT")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance_ComplianceState_NonCompliant
 *        Policy is non-compliant. The policy is non-compliant if one or more
 *        underlying resources are non-compliant. (Value: "NON_COMPLIANT")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyCompliance_ComplianceState_Unknown
 *        The policy is in an unknown compliance state. Refer to the field
 *        `compliance_state_reason` to learn the exact reason for the policy to
 *        be in this compliance state. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *complianceState;

/**
 *  The reason for the OS policy to be in an unknown compliance state. This
 *  field is always populated when `compliance_state` is `UNKNOWN`. If
 *  populated, the field can contain one of the following values: *
 *  `vm-not-running`: The VM was not running. *
 *  `os-policies-not-supported-by-agent`: The version of the OS Config agent
 *  running on the VM does not support running OS policies. *
 *  `no-agent-detected`: The OS Config agent is not detected for the VM. *
 *  `resource-execution-errors`: The OS Config agent encountered errors while
 *  executing one or more resources in the policy. See
 *  `os_policy_resource_compliances` for details. * `task-timeout`: The task
 *  sent to the agent to apply the policy timed out. * `unexpected-agent-state`:
 *  The OS Config agent did not report the final status of the task that
 *  attempted to apply the policy. Instead, the agent unexpectedly started
 *  working on a different task. This mostly happens when the agent or VM
 *  unexpectedly restarts while applying OS policies. *
 *  `internal-service-errors`: Internal service errors were encountered while
 *  attempting to apply the policy.
 */
@property(nonatomic, copy, nullable) NSString *complianceStateReason;

/** The OS policy id */
@property(nonatomic, copy, nullable) NSString *osPolicyId;

/**
 *  Compliance data for each resource within the policy that is applied to the
 *  VM.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance *> *osPolicyResourceCompliances;

@end


/**
 *  Compliance data for an OS policy resource.
 */
@interface GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance : GTLRObject

/**
 *  The compliance state of the resource.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance_ComplianceState_Compliant
 *        Resource is compliant. (Value: "COMPLIANT")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance_ComplianceState_NonCompliant
 *        Resource is non-compliant. (Value: "NON_COMPLIANT")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceCompliance_ComplianceState_Unknown
 *        The resource is in an unknown compliance state. To get more details
 *        about why the policy is in this state, review the output of the
 *        `compliance_state_reason` field. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *complianceState;

/**
 *  A reason for the resource to be in the given compliance state. This field is
 *  always populated when `compliance_state` is `UNKNOWN`. The following values
 *  are supported when `compliance_state == UNKNOWN` * `execution-errors`:
 *  Errors were encountered by the agent while executing the resource and the
 *  compliance state couldn't be determined. * `execution-skipped-by-agent`:
 *  Resource execution was skipped by the agent because errors were encountered
 *  while executing prior resources in the OS policy. *
 *  `os-policy-execution-attempt-failed`: The execution of the OS policy
 *  containing this resource failed and the compliance state couldn't be
 *  determined.
 */
@property(nonatomic, copy, nullable) NSString *complianceStateReason;

/**
 *  Ordered list of configuration completed by the agent for the OS policy
 *  resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep *> *configSteps;

/** ExecResource specific output. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput *execResourceOutput;

/** The ID of the OS policy resource. */
@property(nonatomic, copy, nullable) NSString *osPolicyResourceId;

@end


/**
 *  ExecResource specific output.
 */
@interface GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput : GTLRObject

/**
 *  Output from enforcement phase output file (if run). Output size is limited
 *  to 100K bytes.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *enforcementOutput;

@end


/**
 *  Step performed by the OS Config agent for configuring an `OSPolicy` resource
 *  to its desired state.
 */
@interface GTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep : GTLRObject

/**
 *  An error message recorded during the execution of this step. Only populated
 *  if errors were encountered during this step execution.
 */
@property(nonatomic, copy, nullable) NSString *errorMessage;

/**
 *  Configuration step type.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_DesiredStateCheck
 *        Checks the current status of the desired state for a resource. (Value:
 *        "DESIRED_STATE_CHECK")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_DesiredStateCheckPostEnforcement
 *        Re-checks the status of the desired state. This check is done for a
 *        resource after the enforcement of all OS policies. This step is used
 *        to determine the final desired state status for the resource. It
 *        accounts for any resources that might have drifted from their desired
 *        state due to side effects from executing other resources. (Value:
 *        "DESIRED_STATE_CHECK_POST_ENFORCEMENT")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_DesiredStateEnforcement
 *        Enforces the desired state for a resource that is not in desired
 *        state. (Value: "DESIRED_STATE_ENFORCEMENT")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_TypeUnspecified
 *        Default value. This value is unused. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep_Type_Validation
 *        Checks for resource conflicts such as schema errors. (Value:
 *        "VALIDATION")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Message to configure the rollout at the zonal level for the OS policy
 *  assignment.
 */
@interface GTLROSConfig_OSPolicyAssignmentRollout : GTLRObject

/**
 *  Required. The maximum number (or percentage) of VMs per zone to disrupt at
 *  any given moment.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_FixedOrPercent *disruptionBudget;

/**
 *  Required. This determines the minimum duration of time to wait after the
 *  configuration changes are applied through the current rollout. A VM
 *  continues to count towards the `disruption_budget` at least until this
 *  duration of time has passed after configuration changes are applied.
 */
@property(nonatomic, strong, nullable) GTLRDuration *minWaitDuration;

@end


/**
 *  Filtering criteria to select VMs based on inventory details.
 */
@interface GTLROSConfig_OSPolicyInventoryFilter : GTLRObject

/** Required. The OS short name */
@property(nonatomic, copy, nullable) NSString *osShortName;

/**
 *  The OS version Prefix matches are supported if asterisk(*) is provided as
 *  the last character. For example, to match all versions with a major version
 *  of `7`, specify the following value for this field `7.*` An empty string
 *  matches all OS versions.
 */
@property(nonatomic, copy, nullable) NSString *osVersion;

@end


/**
 *  An OS policy resource is used to define the desired state configuration and
 *  provides a specific functionality like installing/removing packages,
 *  executing a script etc. The system ensures that resources are always in
 *  their desired state by taking necessary actions if they have drifted from
 *  their desired state.
 */
@interface GTLROSConfig_OSPolicyResource : GTLRObject

/** Exec resource */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceExecResource *exec;

/** File resource */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFileResource *file;

/**
 *  Required. The id of the resource with the following restrictions: * Must
 *  contain only lowercase letters, numbers, and hyphens. * Must start with a
 *  letter. * Must be between 1-63 characters. * Must end with a number or a
 *  letter. * Must be unique within the OS policy.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Package resource */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResource *pkg;

/** Package repository resource */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceRepositoryResource *repository;

@end


/**
 *  A resource that allows executing scripts on the VM. The `ExecResource` has 2
 *  stages: `validate` and `enforce` and both stages accept a script as an
 *  argument to execute. When the `ExecResource` is applied by the agent, it
 *  first executes the script in the `validate` stage. The `validate` stage can
 *  signal that the `ExecResource` is already in the desired state by returning
 *  an exit code of `100`. If the `ExecResource` is not in the desired state, it
 *  should return an exit code of `101`. Any other exit code returned by this
 *  stage is considered an error. If the `ExecResource` is not in the desired
 *  state based on the exit code from the `validate` stage, the agent proceeds
 *  to execute the script from the `enforce` stage. If the `ExecResource` is
 *  already in the desired state, the `enforce` stage will not be run. Similar
 *  to `validate` stage, the `enforce` stage should return an exit code of `100`
 *  to indicate that the resource in now in its desired state. Any other exit
 *  code is considered an error. NOTE: An exit code of `100` was chosen over `0`
 *  (and `101` vs `1`) to have an explicit indicator of `in desired state`, `not
 *  in desired state` and errors. Because, for example, Powershell will always
 *  return an exit code of `0` unless an `exit` statement is provided in the
 *  script. So, for reasons of consistency and being explicit, exit codes `100`
 *  and `101` were chosen.
 */
@interface GTLROSConfig_OSPolicyResourceExecResource : GTLRObject

/**
 *  What to run to bring this resource into the desired state. An exit code of
 *  100 indicates "success", any other exit code indicates a failure running
 *  enforce.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceExecResourceExec *enforce;

/**
 *  Required. What to run to validate this resource is in the desired state. An
 *  exit code of 100 indicates "in desired state", and exit code of 101
 *  indicates "not in desired state". Any other exit code indicates a failure
 *  running validate.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceExecResourceExec *validate;

@end


/**
 *  A file or script to execute.
 */
@interface GTLROSConfig_OSPolicyResourceExecResourceExec : GTLRObject

/** Optional arguments to pass to the source during execution. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

/** A remote or local file. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFile *file;

/**
 *  Required. The script interpreter to use.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_InterpreterUnspecified
 *        Invalid value, the request will return validation error. (Value:
 *        "INTERPRETER_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_None If
 *        an interpreter is not specified, the source is executed directly. This
 *        execution, without an interpreter, only succeeds for executables and
 *        scripts that have shebang lines. (Value: "NONE")
 *    @arg @c kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_Powershell
 *        Indicates that the script runs with PowerShell. (Value: "POWERSHELL")
 *    @arg @c kGTLROSConfig_OSPolicyResourceExecResourceExec_Interpreter_Shell
 *        Indicates that the script runs with `/bin/sh` on Linux and `cmd.exe`
 *        on Windows. (Value: "SHELL")
 */
@property(nonatomic, copy, nullable) NSString *interpreter;

/**
 *  Only recorded for enforce Exec. Path to an output file (that is created by
 *  this Exec) whose content will be recorded in OSPolicyResourceCompliance
 *  after a successful run. Absence or failure to read this file will result in
 *  this ExecResource being non-compliant. Output file size is limited to 100K
 *  bytes.
 */
@property(nonatomic, copy, nullable) NSString *outputFilePath;

/** An inline script. The size of the script is limited to 1024 characters. */
@property(nonatomic, copy, nullable) NSString *script;

@end


/**
 *  A remote or local file.
 */
@interface GTLROSConfig_OSPolicyResourceFile : GTLRObject

/**
 *  Defaults to false. When false, files are subject to validations based on the
 *  file type: Remote: A checksum must be specified. Cloud Storage: An object
 *  generation number must be specified.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowInsecure;

/** A Cloud Storage object. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFileGcs *gcs;

/** A local path within the VM to use. */
@property(nonatomic, copy, nullable) NSString *localPath;

/** A generic remote file. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFileRemote *remote;

@end


/**
 *  Specifies a file available as a Cloud Storage Object.
 */
@interface GTLROSConfig_OSPolicyResourceFileGcs : GTLRObject

/** Required. Bucket of the Cloud Storage object. */
@property(nonatomic, copy, nullable) NSString *bucket;

/**
 *  Generation number of the Cloud Storage object.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *generation;

/** Required. Name of the Cloud Storage object. */
@property(nonatomic, copy, nullable) NSString *object;

@end


/**
 *  Specifies a file available via some URI.
 */
@interface GTLROSConfig_OSPolicyResourceFileRemote : GTLRObject

/** SHA256 checksum of the remote file. */
@property(nonatomic, copy, nullable) NSString *sha256Checksum;

/**
 *  Required. URI from which to fetch the object. It should contain both the
 *  protocol and path following the format `{protocol}://{location}`.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A resource that manages the state of a file.
 */
@interface GTLROSConfig_OSPolicyResourceFileResource : GTLRObject

/**
 *  A a file with this content. The size of the content is limited to 1024
 *  characters.
 */
@property(nonatomic, copy, nullable) NSString *content;

/** A remote or local source. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFile *file;

/** Required. The absolute path of the file within the VM. */
@property(nonatomic, copy, nullable) NSString *path;

/**
 *  Consists of three octal digits which represent, in order, the permissions of
 *  the owner, group, and other users for the file (similarly to the numeric
 *  mode used in the linux chmod utility). Each digit represents a three bit
 *  number with the 4 bit corresponding to the read permissions, the 2 bit
 *  corresponds to the write bit, and the one bit corresponds to the execute
 *  permission. Default behavior is 755. Below are some examples of permissions
 *  and their associated values: read, write, and execute: 7 read and execute: 5
 *  read and write: 6 read only: 4
 */
@property(nonatomic, copy, nullable) NSString *permissions;

/**
 *  Required. Desired state of the file.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyResourceFileResource_State_Absent Ensure
 *        file at path is absent. (Value: "ABSENT")
 *    @arg @c kGTLROSConfig_OSPolicyResourceFileResource_State_ContentsMatch
 *        Ensure the contents of the file at path matches. If the file does not
 *        exist it will be created. (Value: "CONTENTS_MATCH")
 *    @arg @c kGTLROSConfig_OSPolicyResourceFileResource_State_DesiredStateUnspecified
 *        Unspecified is invalid. (Value: "DESIRED_STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyResourceFileResource_State_Present Ensure
 *        file at path is present. (Value: "PRESENT")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Resource groups provide a mechanism to group OS policy resources. Resource
 *  groups enable OS policy authors to create a single OS policy to be applied
 *  to VMs running different operating Systems. When the OS policy is applied to
 *  a target VM, the appropriate resource group within the OS policy is selected
 *  based on the `OSFilter` specified within the resource group.
 */
@interface GTLROSConfig_OSPolicyResourceGroup : GTLRObject

/**
 *  List of inventory filters for the resource group. The resources in this
 *  resource group are applied to the target VM if it satisfies at least one of
 *  the following inventory filters. For example, to apply this resource group
 *  to VMs running either `RHEL` or `CentOS` operating systems, specify 2 items
 *  for the list with following values:
 *  inventory_filters[0].os_short_name='rhel' and
 *  inventory_filters[1].os_short_name='centos' If the list is empty, this
 *  resource group will be applied to the target VM unconditionally.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyInventoryFilter *> *inventoryFilters;

/**
 *  Required. List of resources configured for this resource group. The
 *  resources are executed in the exact order specified here.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_OSPolicyResource *> *resources;

@end


/**
 *  A resource that manages a system package.
 */
@interface GTLROSConfig_OSPolicyResourcePackageResource : GTLRObject

/** A package managed by Apt. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceAPT *apt;

/** A deb package file. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceDeb *deb;

/**
 *  Required. The desired state the agent should maintain for this package.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyResourcePackageResource_DesiredState_DesiredStateUnspecified
 *        Unspecified is invalid. (Value: "DESIRED_STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyResourcePackageResource_DesiredState_Installed
 *        Ensure that the package is installed. (Value: "INSTALLED")
 *    @arg @c kGTLROSConfig_OSPolicyResourcePackageResource_DesiredState_Removed
 *        The agent ensures that the package is not installed and uninstalls it
 *        if detected. (Value: "REMOVED")
 */
@property(nonatomic, copy, nullable) NSString *desiredState;

/** A package managed by GooGet. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceGooGet *googet;

/** An MSI package. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceMSI *msi;

/** An rpm package file. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceRPM *rpm;

/** A package managed by YUM. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceYUM *yum;

/** A package managed by Zypper. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourcePackageResourceZypper *zypper;

@end


/**
 *  A package managed by APT. - install: `apt-get update && apt-get -y install
 *  [name]` - remove: `apt-get -y remove [name]`
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceAPT : GTLRObject

/** Required. Package name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A deb package file. dpkg packages only support INSTALLED state.
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceDeb : GTLRObject

/**
 *  Whether dependencies should also be installed. - install when false: `dpkg
 *  -i package` - install when true: `apt-get update && apt-get -y install
 *  package.deb`
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pullDeps;

/** Required. A deb package. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFile *source;

@end


/**
 *  A package managed by GooGet. - install: `googet -noconfirm install package`
 *  - remove: `googet -noconfirm remove package`
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceGooGet : GTLRObject

/** Required. Package name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  An MSI package. MSI packages only support INSTALLED state.
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceMSI : GTLRObject

/**
 *  Additional properties to use during installation. This should be in the
 *  format of Property=Setting. Appended to the defaults of `ACTION=INSTALL
 *  REBOOT=ReallySuppress`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *properties;

/** Required. The MSI package. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFile *source;

@end


/**
 *  An RPM package file. RPM packages only support INSTALLED state.
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceRPM : GTLRObject

/**
 *  Whether dependencies should also be installed. - install when false: `rpm
 *  --upgrade --replacepkgs package.rpm` - install when true: `yum -y install
 *  package.rpm` or `zypper -y install package.rpm`
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pullDeps;

/** Required. An rpm package. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceFile *source;

@end


/**
 *  A package managed by YUM. - install: `yum -y install package` - remove: `yum
 *  -y remove package`
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceYUM : GTLRObject

/** Required. Package name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A package managed by Zypper. - install: `zypper -y install package` -
 *  remove: `zypper -y rm package`
 */
@interface GTLROSConfig_OSPolicyResourcePackageResourceZypper : GTLRObject

/** Required. Package name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A resource that manages a package repository.
 */
@interface GTLROSConfig_OSPolicyResourceRepositoryResource : GTLRObject

/** An Apt Repository. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository *apt;

/** A Goo Repository. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceRepositoryResourceGooRepository *goo;

/** A Yum Repository. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceRepositoryResourceYumRepository *yum;

/** A Zypper Repository. */
@property(nonatomic, strong, nullable) GTLROSConfig_OSPolicyResourceRepositoryResourceZypperRepository *zypper;

@end


/**
 *  Represents a single apt package repository. These will be added to a repo
 *  file that will be managed at `/etc/apt/sources.list.d/google_osconfig.list`.
 */
@interface GTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository : GTLRObject

/**
 *  Required. Type of archive files in this repository.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository_ArchiveType_ArchiveTypeUnspecified
 *        Unspecified is invalid. (Value: "ARCHIVE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository_ArchiveType_Deb
 *        Deb indicates that the archive contains binary files. (Value: "DEB")
 *    @arg @c kGTLROSConfig_OSPolicyResourceRepositoryResourceAptRepository_ArchiveType_DebSrc
 *        Deb-src indicates that the archive contains source files. (Value:
 *        "DEB_SRC")
 */
@property(nonatomic, copy, nullable) NSString *archiveType;

/**
 *  Required. List of components for this repository. Must contain at least one
 *  item.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *components;

/** Required. Distribution of this repository. */
@property(nonatomic, copy, nullable) NSString *distribution;

/**
 *  URI of the key file for this repository. The agent maintains a keyring at
 *  `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
 */
@property(nonatomic, copy, nullable) NSString *gpgKey;

/** Required. URI for this repository. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Represents a Goo package repository. These are added to a repo file that is
 *  managed at `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
 */
@interface GTLROSConfig_OSPolicyResourceRepositoryResourceGooRepository : GTLRObject

/** Required. The name of the repository. */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. The url of the repository. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Represents a single yum package repository. These are added to a repo file
 *  that is managed at `/etc/yum.repos.d/google_osconfig.repo`.
 */
@interface GTLROSConfig_OSPolicyResourceRepositoryResourceYumRepository : GTLRObject

/** Required. The location of the repository directory. */
@property(nonatomic, copy, nullable) NSString *baseUrl;

/** The display name of the repository. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** URIs of GPG keys. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *gpgKeys;

/**
 *  Required. A one word, unique name for this repository. This is the `repo id`
 *  in the yum config file and also the `display_name` if `display_name` is
 *  omitted. This id is also used as the unique identifier when checking for
 *  resource conflicts.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

@end


/**
 *  Represents a single zypper package repository. These are added to a repo
 *  file that is managed at `/etc/zypp/repos.d/google_osconfig.repo`.
 */
@interface GTLROSConfig_OSPolicyResourceRepositoryResourceZypperRepository : GTLRObject

/** Required. The location of the repository directory. */
@property(nonatomic, copy, nullable) NSString *baseUrl;

/** The display name of the repository. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** URIs of GPG keys. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *gpgKeys;

/**
 *  Required. A one word, unique name for this repository. This is the `repo id`
 *  in the zypper config file and also the `display_name` if `display_name` is
 *  omitted. This id is also used as the unique identifier when checking for
 *  GuestPolicy conflicts.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

@end


/**
 *  Patch configuration specifications. Contains details on how to apply the
 *  patch(es) to a VM instance.
 */
@interface GTLROSConfig_PatchConfig : GTLRObject

/**
 *  Apt update settings. Use this setting to override the default `apt` patch
 *  rules.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_AptSettings *apt;

/**
 *  Goo update settings. Use this setting to override the default `goo` patch
 *  rules.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_GooSettings *goo;

/**
 *  Allows the patch job to run on Managed instance groups (MIGs).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *migInstancesAllowed;

/** The `ExecStep` to run after the patch update. */
@property(nonatomic, strong, nullable) GTLROSConfig_ExecStep *postStep;

/** The `ExecStep` to run before the patch update. */
@property(nonatomic, strong, nullable) GTLROSConfig_ExecStep *preStep;

/**
 *  Post-patch reboot settings.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_PatchConfig_RebootConfig_Always Always reboot the
 *        machine after the update completes. (Value: "ALWAYS")
 *    @arg @c kGTLROSConfig_PatchConfig_RebootConfig_Default The agent decides
 *        if a reboot is necessary by checking signals such as registry keys on
 *        Windows or `/var/run/reboot-required` on APT based systems. On RPM
 *        based systems, a set of core system package install times are compared
 *        with system boot time. (Value: "DEFAULT")
 *    @arg @c kGTLROSConfig_PatchConfig_RebootConfig_Never Never reboot the
 *        machine after the update completes. (Value: "NEVER")
 *    @arg @c kGTLROSConfig_PatchConfig_RebootConfig_RebootConfigUnspecified The
 *        default behavior is DEFAULT. (Value: "REBOOT_CONFIG_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *rebootConfig;

/**
 *  Windows update settings. Use this override the default windows patch rules.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_WindowsUpdateSettings *windowsUpdate;

/**
 *  Yum update settings. Use this setting to override the default `yum` patch
 *  rules.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_YumSettings *yum;

/**
 *  Zypper update settings. Use this setting to override the default `zypper`
 *  patch rules.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_ZypperSettings *zypper;

@end


/**
 *  Patch deployments are configurations that individual patch jobs use to
 *  complete a patch. These configurations include instance filter, package
 *  repository settings, and a schedule. For more information about creating and
 *  managing patch deployments, see [Scheduling patch
 *  jobs](https://cloud.google.com/compute/docs/os-patch-management/schedule-patch-jobs).
 */
@interface GTLROSConfig_PatchDeployment : GTLRObject

/**
 *  Output only. Time the patch deployment was created. Timestamp is in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. Description of the patch deployment. Length of the description is
 *  limited to 1024 characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. Duration of the patch. After the duration ends, the patch times
 *  out.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/** Required. VM instances to patch. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchInstanceFilter *instanceFilter;

/**
 *  Output only. The last time a patch job was started by this deployment.
 *  Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastExecuteTime;

/**
 *  Unique name for the patch deployment resource in a project. The patch
 *  deployment name is in the form:
 *  `projects/{project_id}/patchDeployments/{patch_deployment_id}`. This field
 *  is ignored when you create a new patch deployment.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. Schedule a one-time execution. */
@property(nonatomic, strong, nullable) GTLROSConfig_OneTimeSchedule *oneTimeSchedule;

/** Optional. Patch configuration that is applied. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchConfig *patchConfig;

/** Required. Schedule recurring executions. */
@property(nonatomic, strong, nullable) GTLROSConfig_RecurringSchedule *recurringSchedule;

/** Optional. Rollout strategy of the patch job. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchRollout *rollout;

/**
 *  Output only. Current state of the patch deployment.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_PatchDeployment_State_Active Active value means that
 *        patch deployment generates Patch Jobs. (Value: "ACTIVE")
 *    @arg @c kGTLROSConfig_PatchDeployment_State_Paused Paused value means that
 *        patch deployment does not generate Patch jobs. Requires user action to
 *        move in and out from this state. (Value: "PAUSED")
 *    @arg @c kGTLROSConfig_PatchDeployment_State_StateUnspecified The default
 *        value. This value is used if the state is omitted. (Value:
 *        "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. Time the patch deployment was last updated. Timestamp is in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  A filter to target VM instances for patching. The targeted VMs must meet all
 *  criteria specified. So if both labels and zones are specified, the patch job
 *  targets only VMs with those labels and in those zones.
 */
@interface GTLROSConfig_PatchInstanceFilter : GTLRObject

/**
 *  Target all VM instances in the project. If true, no other criteria is
 *  permitted.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *all;

/**
 *  Targets VM instances matching ANY of these GroupLabels. This allows
 *  targeting of disparate groups of VM instances.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_PatchInstanceFilterGroupLabel *> *groupLabels;

/**
 *  Targets VMs whose name starts with one of these prefixes. Similar to labels,
 *  this is another way to group VMs when targeting configs, for example
 *  prefix="prod-".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instanceNamePrefixes;

/**
 *  Targets any of the VM instances specified. Instances are specified by their
 *  URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`,
 *  `projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`, or
 *  `https://www.googleapis.com/compute/v1/projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instances;

/**
 *  Targets VM instances in ANY of these zones. Leave empty to target VM
 *  instances in any zone.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *zones;

@end


/**
 *  Targets a group of VM instances by using their [assigned
 *  labels](https://cloud.google.com/compute/docs/labeling-resources). Labels
 *  are key-value pairs. A `GroupLabel` is a combination of labels that is used
 *  to target VMs for a patch job. For example, a patch job can target VMs that
 *  have the following `GroupLabel`: `{"env":"test", "app":"web"}`. This means
 *  that the patch job is applied to VMs that have both the labels `env=test`
 *  and `app=web`.
 */
@interface GTLROSConfig_PatchInstanceFilterGroupLabel : GTLRObject

/**
 *  Compute Engine instance labels that must be present for a VM instance to be
 *  targeted by this filter.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchInstanceFilterGroupLabel_Labels *labels;

@end


/**
 *  Compute Engine instance labels that must be present for a VM instance to be
 *  targeted by this filter.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROSConfig_PatchInstanceFilterGroupLabel_Labels : GTLRObject
@end


/**
 *  A high level representation of a patch job that is either in progress or has
 *  completed. Instance details are not included in the job. To paginate through
 *  instance details, use ListPatchJobInstanceDetails. For more information
 *  about patch jobs, see [Creating patch
 *  jobs](https://cloud.google.com/compute/docs/os-patch-management/create-patch-job).
 */
@interface GTLROSConfig_PatchJob : GTLRObject

/** Time this patch job was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Description of the patch job. Length of the description is limited to 1024
 *  characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Display name for this patch job. This is not a unique identifier. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  If this patch job is a dry run, the agent reports that it has finished
 *  without running any updates on the VM instance.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dryRun;

/**
 *  Duration of the patch job. After the duration ends, the patch job times out.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  If this patch job failed, this message provides information about the
 *  failure.
 */
@property(nonatomic, copy, nullable) NSString *errorMessage;

/** Summary of instance details. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchJobInstanceDetailsSummary *instanceDetailsSummary;

/** Instances to patch. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchInstanceFilter *instanceFilter;

/**
 *  Unique identifier for this patch job in the form `projects/ * /patchJobs/ *`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Patch configuration being applied. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchConfig *patchConfig;

/** Output only. Name of the patch deployment that created this patch job. */
@property(nonatomic, copy, nullable) NSString *patchDeployment;

/**
 *  Reflects the overall progress of the patch job in the range of 0.0 being no
 *  progress to 100.0 being complete.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percentComplete;

/** Rollout strategy being applied. */
@property(nonatomic, strong, nullable) GTLROSConfig_PatchRollout *rollout;

/**
 *  The current state of the PatchJob.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_PatchJob_State_Canceled The patch job was canceled.
 *        (Value: "CANCELED")
 *    @arg @c kGTLROSConfig_PatchJob_State_CompletedWithErrors Patch job
 *        completed but there were errors. (Value: "COMPLETED_WITH_ERRORS")
 *    @arg @c kGTLROSConfig_PatchJob_State_InstanceLookup The patch job is
 *        looking up instances to run the patch on. (Value: "INSTANCE_LOOKUP")
 *    @arg @c kGTLROSConfig_PatchJob_State_Patching Instances are being patched.
 *        (Value: "PATCHING")
 *    @arg @c kGTLROSConfig_PatchJob_State_Started The patch job was
 *        successfully initiated. (Value: "STARTED")
 *    @arg @c kGTLROSConfig_PatchJob_State_StateUnspecified State must be
 *        specified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_PatchJob_State_Succeeded Patch job completed
 *        successfully. (Value: "SUCCEEDED")
 *    @arg @c kGTLROSConfig_PatchJob_State_TimedOut The patch job timed out.
 *        (Value: "TIMED_OUT")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Last time this patch job was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Patch details for a VM instance. For more information about reviewing VM
 *  instance details, see [Listing all VM instance details for a specific patch
 *  job](https://cloud.google.com/compute/docs/os-patch-management/manage-patch-jobs#list-instance-details).
 */
@interface GTLROSConfig_PatchJobInstanceDetails : GTLRObject

/**
 *  The number of times the agent that the agent attempts to apply the patch.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *attemptCount;

/** If the patch fails, this field provides the reason. */
@property(nonatomic, copy, nullable) NSString *failureReason;

/**
 *  The unique identifier for the instance. This identifier is defined by the
 *  server.
 */
@property(nonatomic, copy, nullable) NSString *instanceSystemId;

/** The instance name in the form `projects/ * /zones/ * /instances/ *` */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Current state of instance patch.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Acked The instance
 *        acked the notification and will start shortly. (Value: "ACKED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_ApplyingPatches The
 *        instance is applying patches. (Value: "APPLYING_PATCHES")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_DownloadingPatches The
 *        instance is downloading patches. (Value: "DOWNLOADING_PATCHES")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Failed The instance
 *        has failed to apply the patch. (Value: "FAILED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Inactive Instance is
 *        inactive and cannot be patched. (Value: "INACTIVE")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_NoAgentDetected The
 *        service could not detect the presence of the agent. Check to ensure
 *        that the agent is installed, running, and able to communicate with the
 *        service. (Value: "NO_AGENT_DETECTED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Notified The instance
 *        is notified that it should be patched. (Value: "NOTIFIED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_PatchStateUnspecified
 *        Unspecified. (Value: "PATCH_STATE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Pending The instance
 *        is not yet notified. (Value: "PENDING")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Rebooting The instance
 *        is rebooting. (Value: "REBOOTING")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_RunningPostPatchStep
 *        The instance is running the post-patch step. (Value:
 *        "RUNNING_POST_PATCH_STEP")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_RunningPrePatchStep
 *        The instance is running the pre-patch step. (Value:
 *        "RUNNING_PRE_PATCH_STEP")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Started The instance
 *        has started the patching process. (Value: "STARTED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_Succeeded The instance
 *        has completed applying patches. (Value: "SUCCEEDED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_SucceededRebootRequired
 *        The instance has completed applying patches but a reboot is required.
 *        (Value: "SUCCEEDED_REBOOT_REQUIRED")
 *    @arg @c kGTLROSConfig_PatchJobInstanceDetails_State_TimedOut The instance
 *        exceeded the time out while applying the patch. (Value: "TIMED_OUT")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  A summary of the current patch state across all instances that this patch
 *  job affects. Contains counts of instances in different states. These states
 *  map to `InstancePatchState`. List patch job instance details to see the
 *  specific states of each instance.
 */
@interface GTLROSConfig_PatchJobInstanceDetailsSummary : GTLRObject

/**
 *  Number of instances that have acked and will start shortly.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ackedInstanceCount;

/**
 *  Number of instances that are applying patches.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applyingPatchesInstanceCount;

/**
 *  Number of instances that are downloading patches.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *downloadingPatchesInstanceCount;

/**
 *  Number of instances that failed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *failedInstanceCount;

/**
 *  Number of instances that are inactive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inactiveInstanceCount;

/**
 *  Number of instances that do not appear to be running the agent. Check to
 *  ensure that the agent is installed, running, and able to communicate with
 *  the service.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *noAgentDetectedInstanceCount;

/**
 *  Number of instances notified about patch job.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *notifiedInstanceCount;

/**
 *  Number of instances pending patch job.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pendingInstanceCount;

/**
 *  Number of instances that are running the post-patch step.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *postPatchStepInstanceCount;

/**
 *  Number of instances that are running the pre-patch step.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *prePatchStepInstanceCount;

/**
 *  Number of instances rebooting.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rebootingInstanceCount;

/**
 *  Number of instances that have started.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startedInstanceCount;

/**
 *  Number of instances that have completed successfully.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *succeededInstanceCount;

/**
 *  Number of instances that require reboot.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *succeededRebootRequiredInstanceCount;

/**
 *  Number of instances that exceeded the time out while applying the patch.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *timedOutInstanceCount;

@end


/**
 *  Patch rollout configuration specifications. Contains details on the
 *  concurrency control when applying patch(es) to all targeted VMs.
 */
@interface GTLROSConfig_PatchRollout : GTLRObject

/**
 *  The maximum number (or percentage) of VMs per zone to disrupt at any given
 *  moment. The number of VMs calculated from multiplying the percentage by the
 *  total number of VMs in a zone is rounded up. During patching, a VM is
 *  considered disrupted from the time the agent is notified to begin until
 *  patching has completed. This disruption time includes the time to complete
 *  reboot and any post-patch steps. A VM contributes to the disruption budget
 *  if its patching operation fails either when applying the patches, running
 *  pre or post patch steps, or if it fails to respond with a success
 *  notification before timing out. VMs that are not running or do not have an
 *  active agent do not count toward this disruption budget. For zone-by-zone
 *  rollouts, if the disruption budget in a zone is exceeded, the patch job
 *  stops, because continuing to the next zone requires completion of the patch
 *  process in the previous zone. For example, if the disruption budget has a
 *  fixed value of `10`, and 8 VMs fail to patch in the current zone, the patch
 *  job continues to patch 2 VMs at a time until the zone is completed. When
 *  that zone is completed successfully, patching begins with 10 VMs at a time
 *  in the next zone. If 10 VMs in the next zone fail to patch, the patch job
 *  stops.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_FixedOrPercent *disruptionBudget;

/**
 *  Mode of the patch rollout.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_PatchRollout_Mode_ConcurrentZones Patches are
 *        applied to VMs in all zones at the same time. (Value:
 *        "CONCURRENT_ZONES")
 *    @arg @c kGTLROSConfig_PatchRollout_Mode_ModeUnspecified Mode must be
 *        specified. (Value: "MODE_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_PatchRollout_Mode_ZoneByZone Patches are applied one
 *        zone at a time. The patch job begins in the region with the lowest
 *        number of targeted VMs. Within the region, patching begins in the zone
 *        with the lowest number of targeted VMs. If multiple regions (or zones
 *        within a region) have the same number of targeted VMs, a tie-breaker
 *        is achieved by sorting the regions or zones in alphabetical order.
 *        (Value: "ZONE_BY_ZONE")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  A request message for pausing a patch deployment.
 */
@interface GTLROSConfig_PausePatchDeploymentRequest : GTLRObject
@end


/**
 *  Sets the time for recurring patch deployments.
 */
@interface GTLROSConfig_RecurringSchedule : GTLRObject

/**
 *  Optional. The end time at which a recurring patch deployment schedule is no
 *  longer active.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Required. The frequency unit of this recurring schedule.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_RecurringSchedule_Frequency_Daily Indicates that the
 *        frequency of recurrence should be expressed in terms of days. (Value:
 *        "DAILY")
 *    @arg @c kGTLROSConfig_RecurringSchedule_Frequency_FrequencyUnspecified
 *        Invalid. A frequency must be specified. (Value:
 *        "FREQUENCY_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_RecurringSchedule_Frequency_Monthly Indicates that
 *        the frequency of recurrence should be expressed in terms of months.
 *        (Value: "MONTHLY")
 *    @arg @c kGTLROSConfig_RecurringSchedule_Frequency_Weekly Indicates that
 *        the frequency of recurrence should be expressed in terms of weeks.
 *        (Value: "WEEKLY")
 */
@property(nonatomic, copy, nullable) NSString *frequency;

/** Output only. The time the last patch job ran successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastExecuteTime;

/** Required. Schedule with monthly executions. */
@property(nonatomic, strong, nullable) GTLROSConfig_MonthlySchedule *monthly;

/** Output only. The time the next patch job is scheduled to run. */
@property(nonatomic, strong, nullable) GTLRDateTime *nextExecuteTime;

/**
 *  Optional. The time that the recurring schedule becomes effective. Defaults
 *  to `create_time` of the patch deployment.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** Required. Time of the day to run a recurring deployment. */
@property(nonatomic, strong, nullable) GTLROSConfig_TimeOfDay *timeOfDay;

/**
 *  Required. Defines the time zone that `time_of_day` is relative to. The rules
 *  for daylight saving time are determined by the chosen time zone.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_TimeZone *timeZone;

/** Required. Schedule with weekly executions. */
@property(nonatomic, strong, nullable) GTLROSConfig_WeeklySchedule *weekly;

@end


/**
 *  A request message for resuming a patch deployment.
 */
@interface GTLROSConfig_ResumePatchDeploymentRequest : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLROSConfig_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLROSConfig_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROSConfig_Status_Details_Item : GTLRObject
@end


/**
 *  Represents a time of day. The date and time zone are either not significant
 *  or are specified elsewhere. An API may choose to allow leap seconds. Related
 *  types are google.type.Date and `google.protobuf.Timestamp`.
 */
@interface GTLROSConfig_TimeOfDay : GTLRObject

/**
 *  Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to
 *  allow the value "24:00:00" for scenarios like business closing time.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hours;

/**
 *  Minutes of hour of day. Must be from 0 to 59.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minutes;

/**
 *  Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nanos;

/**
 *  Seconds of minutes of the time. Must normally be from 0 to 59. An API may
 *  allow the value 60 if it allows leap-seconds.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seconds;

@end


/**
 *  Represents a time zone from the [IANA Time Zone
 *  Database](https://www.iana.org/time-zones).
 */
@interface GTLROSConfig_TimeZone : GTLRObject

/**
 *  IANA Time Zone Database time zone, e.g. "America/New_York".
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Optional. IANA Time Zone Database version number, e.g. "2019a". */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  This API resource represents the vulnerability report for a specified
 *  Compute Engine virtual machine (VM) instance at a given point in time. For
 *  more information, see [Vulnerability
 *  reports](https://cloud.google.com/compute/docs/instances/os-inventory-management#vulnerability-reports).
 */
@interface GTLROSConfig_VulnerabilityReport : GTLRObject

/**
 *  Output only. The `vulnerabilityReport` API resource name. Format:
 *  `projects/{project_number}/locations/{location}/instances/{instance_id}/vulnerabilityReport`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The timestamp for when the last vulnerability report was
 *  generated for the VM.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Output only. List of vulnerabilities affecting the VM. */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_VulnerabilityReportVulnerability *> *vulnerabilities;

@end


/**
 *  A vulnerability affecting the VM instance.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLROSConfig_VulnerabilityReportVulnerability : GTLRCollectionObject

/**
 *  Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM. If the
 *  vulnerability report was not updated after the VM inventory update, these
 *  values might not display in VM inventory. If there is no available fix, the
 *  field is empty. The `inventory_item` value specifies the latest
 *  `SoftwarePackage` available to the VM that fixes the vulnerability.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *availableInventoryItemIds;

/** The timestamp for when the vulnerability was first detected. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Contains metadata as per the upstream feed of the operating system and NVD.
 */
@property(nonatomic, strong, nullable) GTLROSConfig_VulnerabilityReportVulnerabilityDetails *details;

/**
 *  Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM. This field
 *  displays the inventory items affected by this vulnerability. If the
 *  vulnerability report was not updated after the VM inventory update, these
 *  values might not display in VM inventory. For some distros, this field may
 *  be empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *installedInventoryItemIds;

/**
 *  List of items affected by the vulnerability.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_VulnerabilityReportVulnerabilityItem *> *items;

/** The timestamp for when the vulnerability was last modified. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Contains metadata information for the vulnerability. This information is
 *  collected from the upstream feed of the operating system.
 */
@interface GTLROSConfig_VulnerabilityReportVulnerabilityDetails : GTLRObject

/**
 *  The CVE of the vulnerability. CVE cannot be empty and the combination of
 *  should be unique across vulnerabilities for a VM.
 */
@property(nonatomic, copy, nullable) NSString *cve;

/**
 *  The CVSS V2 score of this vulnerability. CVSS V2 score is on a scale of 0 -
 *  10 where 0 indicates low severity and 10 indicates high severity.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssV2Score;

/** The full description of the CVSSv3 for this vulnerability from NVD. */
@property(nonatomic, strong, nullable) GTLROSConfig_CVSSv3 *cvssV3;

/**
 *  The note or description describing the vulnerability from the distro.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Corresponds to the references attached to the `VulnerabilityDetails`. */
@property(nonatomic, strong, nullable) NSArray<GTLROSConfig_VulnerabilityReportVulnerabilityDetailsReference *> *references;

/** Assigned severity/impact ranking from the distro. */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  A reference for this vulnerability.
 */
@interface GTLROSConfig_VulnerabilityReportVulnerabilityDetailsReference : GTLRObject

/** The source of the reference e.g. NVD. */
@property(nonatomic, copy, nullable) NSString *source;

/** The url of the reference. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  OS inventory item that is affected by a vulnerability or fixed as a result
 *  of a vulnerability.
 */
@interface GTLROSConfig_VulnerabilityReportVulnerabilityItem : GTLRObject

/**
 *  Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM. If the
 *  vulnerability report was not updated after the VM inventory update, these
 *  values might not display in VM inventory. If there is no available fix, the
 *  field is empty. The `inventory_item` value specifies the latest
 *  `SoftwarePackage` available to the VM that fixes the vulnerability.
 */
@property(nonatomic, copy, nullable) NSString *availableInventoryItemId;

/**
 *  The recommended [CPE URI](https://cpe.mitre.org/specification/) update that
 *  contains a fix for this vulnerability.
 */
@property(nonatomic, copy, nullable) NSString *fixedCpeUri;

/**
 *  Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM. This field
 *  displays the inventory items affected by this vulnerability. If the
 *  vulnerability report was not updated after the VM inventory update, these
 *  values might not display in VM inventory. For some operating systems, this
 *  field might be empty.
 */
@property(nonatomic, copy, nullable) NSString *installedInventoryItemId;

/** The upstream OS patch, packages or KB that fixes the vulnerability. */
@property(nonatomic, copy, nullable) NSString *upstreamFix;

@end


/**
 *  Represents one week day in a month. An example is "the 4th Sunday".
 */
@interface GTLROSConfig_WeekDayOfMonth : GTLRObject

/**
 *  Optional. Represents the number of days before or after the given week day
 *  of month that the patch deployment is scheduled for. For example if
 *  `week_ordinal` and `day_of_week` values point to the second day of the month
 *  and this `day_offset` value is set to `3`, the patch deployment takes place
 *  three days after the second Tuesday of the month. If this value is negative,
 *  for example -5, the patches are deployed five days before before the second
 *  Tuesday of the month. Allowed values are in range [-30, 30].
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dayOffset;

/**
 *  Required. A day of the week.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_DayOfWeekUnspecified The
 *        day of the week is unspecified. (Value: "DAY_OF_WEEK_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Friday Friday (Value:
 *        "FRIDAY")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Monday Monday (Value:
 *        "MONDAY")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Saturday Saturday (Value:
 *        "SATURDAY")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Sunday Sunday (Value:
 *        "SUNDAY")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Thursday Thursday (Value:
 *        "THURSDAY")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Tuesday Tuesday (Value:
 *        "TUESDAY")
 *    @arg @c kGTLROSConfig_WeekDayOfMonth_DayOfWeek_Wednesday Wednesday (Value:
 *        "WEDNESDAY")
 */
@property(nonatomic, copy, nullable) NSString *dayOfWeek;

/**
 *  Required. Week number in a month. 1-4 indicates the 1st to 4th week of the
 *  month. -1 indicates the last week of the month.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *weekOrdinal;

@end


/**
 *  Represents a weekly schedule.
 */
@interface GTLROSConfig_WeeklySchedule : GTLRObject

/**
 *  Required. Day of the week.
 *
 *  Likely values:
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_DayOfWeekUnspecified The
 *        day of the week is unspecified. (Value: "DAY_OF_WEEK_UNSPECIFIED")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Friday Friday (Value:
 *        "FRIDAY")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Monday Monday (Value:
 *        "MONDAY")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Saturday Saturday (Value:
 *        "SATURDAY")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Sunday Sunday (Value:
 *        "SUNDAY")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Thursday Thursday (Value:
 *        "THURSDAY")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Tuesday Tuesday (Value:
 *        "TUESDAY")
 *    @arg @c kGTLROSConfig_WeeklySchedule_DayOfWeek_Wednesday Wednesday (Value:
 *        "WEDNESDAY")
 */
@property(nonatomic, copy, nullable) NSString *dayOfWeek;

@end


/**
 *  Windows patching is performed using the Windows Update Agent.
 */
@interface GTLROSConfig_WindowsUpdateSettings : GTLRObject

/**
 *  Only apply updates of these windows update classifications. If empty, all
 *  updates are applied.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *classifications;

/** List of KBs to exclude from update. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludes;

/**
 *  An exclusive list of kbs to be updated. These are the only patches that will
 *  be updated. This field must not be used with other patch configurations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exclusivePatches;

@end


/**
 *  Yum patching is performed by executing `yum update`. Additional options can
 *  be set to control how this is executed. Note that not all settings are
 *  supported on all platforms.
 */
@interface GTLROSConfig_YumSettings : GTLRObject

/**
 *  List of packages to exclude from update. These packages are excluded by
 *  using the yum `--exclude` flag.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludes;

/**
 *  An exclusive list of packages to be updated. These are the only packages
 *  that will be updated. If these packages are not installed, they will be
 *  ignored. This field must not be specified with any other patch configuration
 *  fields.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exclusivePackages;

/**
 *  Will cause patch to run `yum update-minimal` instead.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimal;

/**
 *  Adds the `--security` flag to `yum update`. Not supported on all platforms.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *security;

@end


/**
 *  Zypper patching is performed by running `zypper patch`. See also
 *  https://en.opensuse.org/SDB:Zypper_manual.
 */
@interface GTLROSConfig_ZypperSettings : GTLRObject

/**
 *  Install only patches with these categories. Common categories include
 *  security, recommended, and feature.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *categories;

/** List of patches to exclude from update. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludes;

/**
 *  An exclusive list of patches to be updated. These are the only patches that
 *  will be installed using 'zypper patch patch:' command. This field must not
 *  be used with any other patch configuration fields.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exclusivePatches;

/**
 *  Install only patches with these severities. Common severities include
 *  critical, important, moderate, and low.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *severities;

/**
 *  Adds the `--with-optional` flag to `zypper patch`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *withOptional;

/**
 *  Adds the `--with-update` flag, to `zypper patch`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *withUpdate;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
