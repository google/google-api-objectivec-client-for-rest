// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Compute Engine API (compute/v1)
// Description:
//   Creates and runs virtual machines on Google Cloud Platform.
// Documentation:
//   https://cloud.google.com/compute/

#import <GoogleAPIClientForREST/GTLRQuery.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

#import "GTLRComputeObjects.h"

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the query classes' properties below.

// ----------------------------------------------------------------------------
// direction

/**
 *  For routes exported from peer network.
 *
 *  Value: "INCOMING"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeDirectionIncoming;
/**
 *  For routes exported from local network.
 *
 *  Value: "OUTGOING"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeDirectionOutgoing;

// ----------------------------------------------------------------------------
// minimalAction

/** Value: "INVALID" */
FOUNDATION_EXTERN NSString * const kGTLRComputeMinimalActionInvalid;
/**
 *  No changes can be made to the instance.
 *
 *  Value: "NO_EFFECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeMinimalActionNoEffect;
/**
 *  The instance will not restart.
 *
 *  Value: "REFRESH"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeMinimalActionRefresh;
/**
 *  The instance will restart.
 *
 *  Value: "RESTART"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeMinimalActionRestart;

// ----------------------------------------------------------------------------
// mostDisruptiveAllowedAction

/** Value: "INVALID" */
FOUNDATION_EXTERN NSString * const kGTLRComputeMostDisruptiveAllowedActionInvalid;
/**
 *  No changes can be made to the instance.
 *
 *  Value: "NO_EFFECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeMostDisruptiveAllowedActionNoEffect;
/**
 *  The instance will not restart.
 *
 *  Value: "REFRESH"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeMostDisruptiveAllowedActionRefresh;
/**
 *  The instance will restart.
 *
 *  Value: "RESTART"
 */
FOUNDATION_EXTERN NSString * const kGTLRComputeMostDisruptiveAllowedActionRestart;

// ----------------------------------------------------------------------------
// Query Classes
//

/**
 *  Parent class for other Compute query classes.
 */
@interface GTLRComputeQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Retrieves an aggregated list of accelerator types. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  Method: compute.acceleratorTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_AcceleratorTypeAggregatedList.
 *
 *  Retrieves an aggregated list of accelerator types. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_AcceleratorTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified accelerator type.
 *
 *  Method: compute.acceleratorTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesGet : GTLRComputeQuery

/** Name of the accelerator type to return. */
@property(nonatomic, copy, nullable) NSString *acceleratorType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AcceleratorType.
 *
 *  Returns the specified accelerator type.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param acceleratorType Name of the accelerator type to return.
 *
 *  @return GTLRComputeQuery_AcceleratorTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                 acceleratorType:(NSString *)acceleratorType;

@end

/**
 *  Retrieves a list of accelerator types that are available to the specified
 *  project.
 *
 *  Method: compute.acceleratorTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AcceleratorTypesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AcceleratorTypeList.
 *
 *  Retrieves a list of accelerator types that are available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AcceleratorTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves an aggregated list of addresses. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.addresses.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_AddressAggregatedList.
 *
 *  Retrieves an aggregated list of addresses. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_AddressesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.addresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesDelete : GTLRComputeQuery

/** Name of the address resource to delete. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @return GTLRComputeQuery_AddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource.
 *
 *  Method: compute.addresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesGet : GTLRComputeQuery

/** Name of the address resource to return. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to return.
 *
 *  @return GTLRComputeQuery_AddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project by using the data
 *  included in the request.
 *
 *  Method: compute.addresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project by using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_AddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  Method: compute.addresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AddressesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of addresses contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_AddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Moves the specified address resource.
 *
 *  Method: compute.addresses.move
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesMove : GTLRComputeQuery

/** Name of the address resource to move. */
@property(nonatomic, copy, nullable) NSString *address;

/** Source project ID which the Address is moved from. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves the specified address resource.
 *
 *  @param object The @c GTLRCompute_RegionAddressesMoveRequest to include in
 *    the query.
 *  @param project Source project ID which the Address is moved from.
 *  @param region Name of the region for this request.
 *  @param address Name of the address resource to move.
 *
 *  @return GTLRComputeQuery_AddressesMove
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionAddressesMoveRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                        address:(NSString *)address;

@end

/**
 *  Sets the labels on an Address. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.addresses.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AddressesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an Address. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_AddressesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of autoscalers. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.autoscalers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_AutoscalerAggregatedList.
 *
 *  Retrieves an aggregated list of autoscalers. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.autoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersDelete : GTLRComputeQuery

/** Name of the autoscaler to delete. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @return GTLRComputeQuery_AutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler resource.
 *
 *  Method: compute.autoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersGet : GTLRComputeQuery

/** Name of the autoscaler to return. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @return GTLRComputeQuery_AutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  Method: compute.autoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_AutoscalersList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_AutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.autoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersPatch : GTLRComputeQuery

/** Name of the autoscaler to patch. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.autoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_AutoscalersUpdate : GTLRComputeQuery

/** Name of the autoscaler to update. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_AutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Adds a key for validating requests with signed URLs for this backend bucket.
 *
 *  Method: compute.backendBuckets.addSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsAddSignedUrlKey : GTLRComputeQuery

/**
 *  Name of the BackendBucket resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a key for validating requests with signed URLs for this backend bucket.
 *
 *  @param object The @c GTLRCompute_SignedUrlKey to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to which the Signed
 *    URL Key should be added. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendBucketsAddSignedUrlKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_SignedUrlKey *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Deletes the specified BackendBucket resource.
 *
 *  Method: compute.backendBuckets.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsDelete : GTLRComputeQuery

/** Name of the BackendBucket resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendBucket resource.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to delete.
 *
 *  @return GTLRComputeQuery_BackendBucketsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket;

@end

/**
 *  Deletes a key for validating requests with signed URLs for this backend
 *  bucket.
 *
 *  Method: compute.backendBuckets.deleteSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsDeleteSignedUrlKey : GTLRComputeQuery

/**
 *  Name of the BackendBucket resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** The name of the Signed URL Key to delete. */
@property(nonatomic, copy, nullable) NSString *keyName;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a key for validating requests with signed URLs for this backend
 *  bucket.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to which the Signed
 *    URL Key should be added. The name should conform to RFC1035.
 *  @param keyName The name of the Signed URL Key to delete.
 *
 *  @return GTLRComputeQuery_BackendBucketsDeleteSignedUrlKey
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket
                         keyName:(NSString *)keyName;

@end

/**
 *  Returns the specified BackendBucket resource.
 *
 *  Method: compute.backendBuckets.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsGet : GTLRComputeQuery

/** Name of the BackendBucket resource to return. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendBucket.
 *
 *  Returns the specified BackendBucket resource.
 *
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to return.
 *
 *  @return GTLRComputeQuery_BackendBucketsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                   backendBucket:(NSString *)backendBucket;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.backendBuckets.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates a BackendBucket resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.backendBuckets.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendBucket resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendBucket resources available to the specified
 *  project.
 *
 *  Method: compute.backendBuckets.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_BackendBucketList.
 *
 *  Retrieves the list of BackendBucket resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified BackendBucket resource with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.backendBuckets.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsPatch : GTLRComputeQuery

/** Name of the BackendBucket resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendBucket resource with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to patch.
 *
 *  @return GTLRComputeQuery_BackendBucketsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Sets the edge security policy for the specified backend bucket.
 *
 *  Method: compute.backendBuckets.setEdgeSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsSetEdgeSecurityPolicy : GTLRComputeQuery

/**
 *  Name of the BackendBucket resource to which the security policy should be
 *  set. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the edge security policy for the specified backend bucket.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to which the
 *    security policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendBucketsSetEdgeSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.backendBuckets.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.backendBuckets.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendBucketsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_BackendBucketsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Updates the specified BackendBucket resource with the data included in the
 *  request.
 *
 *  Method: compute.backendBuckets.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendBucketsUpdate : GTLRComputeQuery

/** Name of the BackendBucket resource to update. */
@property(nonatomic, copy, nullable) NSString *backendBucket;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendBucket resource with the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_BackendBucket to include in the query.
 *  @param project Project ID for this request.
 *  @param backendBucket Name of the BackendBucket resource to update.
 *
 *  @return GTLRComputeQuery_BackendBucketsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendBucket *)object
                        project:(NSString *)project
                  backendBucket:(NSString *)backendBucket;

@end

/**
 *  Adds a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  Method: compute.backendServices.addSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesAddSignedUrlKey : GTLRComputeQuery

/**
 *  Name of the BackendService resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  @param object The @c GTLRCompute_SignedUrlKey to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the
 *    Signed URL Key should be added. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendServicesAddSignedUrlKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_SignedUrlKey *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves the list of all BackendService resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.backendServices.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_BackendServiceAggregatedList.
 *
 *  Retrieves the list of all BackendService resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_BackendServicesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified BackendService resource.
 *
 *  Method: compute.backendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesDelete : GTLRComputeQuery

/** Name of the BackendService resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @return GTLRComputeQuery_BackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Deletes a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  Method: compute.backendServices.deleteSignedUrlKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesDeleteSignedUrlKey : GTLRComputeQuery

/**
 *  Name of the BackendService resource to which the Signed URL Key should be
 *  added. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** The name of the Signed URL Key to delete. */
@property(nonatomic, copy, nullable) NSString *keyName;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a key for validating requests with signed URLs for this backend
 *  service.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the
 *    Signed URL Key should be added. The name should conform to RFC1035.
 *  @param keyName The name of the Signed URL Key to delete.
 *
 *  @return GTLRComputeQuery_BackendServicesDeleteSignedUrlKey
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService
                         keyName:(NSString *)keyName;

@end

/**
 *  Returns the specified BackendService resource.
 *
 *  Method: compute.backendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGet : GTLRComputeQuery

/** Name of the BackendService resource to return. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @return GTLRComputeQuery_BackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this BackendService. Example
 *  request body: { "group":
 *  "/zones/us-east1-b/instanceGroups/lb-backend-example" }
 *
 *  Method: compute.backendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGetHealth : GTLRComputeQuery

/**
 *  Name of the BackendService resource to which the queried instance belongs.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this BackendService. Example
 *  request body: { "group":
 *  "/zones/us-east1-b/instanceGroups/lb-backend-example" }
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param backendService Name of the BackendService resource to which the
 *    queried instance belongs.
 *
 *  @return GTLRComputeQuery_BackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.backendServices.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. For more information, see Backend services overview
 *  .
 *
 *  Method: compute.backendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a BackendService resource in the specified project using the data
 *  included in the request. For more information, see Backend services overview
 *  .
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  Method: compute.backendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of BackendService resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Retrieves a list of all usable backend services in the specified project.
 *
 *  Method: compute.backendServices.listUsable
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesListUsable : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_BackendServiceListUsable.
 *
 *  Retrieves a list of all usable backend services in the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesListUsable
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified BackendService resource with the data included in the
 *  request. For more information, see Backend services overview. This method
 *  supports PATCH semantics and uses the JSON merge patch format and processing
 *  rules.
 *
 *  Method: compute.backendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesPatch : GTLRComputeQuery

/** Name of the BackendService resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified BackendService resource with the data included in the
 *  request. For more information, see Backend services overview. This method
 *  supports PATCH semantics and uses the JSON merge patch format and processing
 *  rules.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to patch.
 *
 *  @return GTLRComputeQuery_BackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Sets the edge security policy for the specified backend service.
 *
 *  Method: compute.backendServices.setEdgeSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesSetEdgeSecurityPolicy : GTLRComputeQuery

/**
 *  Name of the BackendService resource to which the edge security policy should
 *  be set. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the edge security policy for the specified backend service.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the edge
 *    security policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendServicesSetEdgeSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.backendServices.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Sets the Google Cloud Armor security policy for the specified backend
 *  service. For more information, see Google Cloud Armor Overview
 *
 *  Method: compute.backendServices.setSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesSetSecurityPolicy : GTLRComputeQuery

/**
 *  Name of the BackendService resource to which the security policy should be
 *  set. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Google Cloud Armor security policy for the specified backend
 *  service. For more information, see Google Cloud Armor Overview
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to which the
 *    security policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_BackendServicesSetSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.backendServices.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_BackendServicesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_BackendServicesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Updates the specified BackendService resource with the data included in the
 *  request. For more information, see Backend services overview.
 *
 *  Method: compute.backendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_BackendServicesUpdate : GTLRComputeQuery

/** Name of the BackendService resource to update. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified BackendService resource with the data included in the
 *  request. For more information, see Backend services overview.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @return GTLRComputeQuery_BackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                 backendService:(NSString *)backendService;

@end

/**
 *  Adds existing resource policies to a disk. You can only add one policy which
 *  will be applied to this disk for scheduling snapshot creation.
 *
 *  Method: compute.disks.addResourcePolicies
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksAddResourcePolicies : GTLRComputeQuery

/** The disk name for this request. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds existing resource policies to a disk. You can only add one policy which
 *  will be applied to this disk for scheduling snapshot creation.
 *
 *  @param object The @c GTLRCompute_DisksAddResourcePoliciesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The disk name for this request.
 *
 *  @return GTLRComputeQuery_DisksAddResourcePolicies
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksAddResourcePoliciesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Retrieves an aggregated list of persistent disks. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.disks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_DiskAggregatedList.
 *
 *  Retrieves an aggregated list of persistent disks. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_DisksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Bulk create a set of disks.
 *
 *  Method: compute.disks.bulkInsert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksBulkInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Bulk create a set of disks.
 *
 *  @param object The @c GTLRCompute_BulkInsertDiskResource to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DisksBulkInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BulkInsertDiskResource *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Creates a snapshot of a specified persistent disk. For regular snapshot
 *  creation, consider using snapshots.insert instead, as that method supports
 *  more features, such as creating snapshots in a project different from the
 *  source disk project.
 *
 *  Method: compute.disks.createSnapshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksCreateSnapshot : GTLRComputeQuery

/** Name of the persistent disk to snapshot. */
@property(nonatomic, copy, nullable) NSString *disk;

/**
 *  [Input Only] Whether to attempt an application consistent snapshot by
 *  informing the OS to prepare for the snapshot process.
 */
@property(nonatomic, assign) BOOL guestFlush;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot of a specified persistent disk. For regular snapshot
 *  creation, consider using snapshots.insert instead, as that method supports
 *  more features, such as creating snapshots in a project different from the
 *  source disk project.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to snapshot.
 *
 *  @return GTLRComputeQuery_DisksCreateSnapshot
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  Method: compute.disks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksDelete : GTLRComputeQuery

/** Name of the persistent disk to delete. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified persistent disk. Deleting a disk removes its data
 *  permanently and is irreversible. However, deleting a disk does not delete
 *  any snapshots previously made from the disk. You must separately delete
 *  snapshots.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to delete.
 *
 *  @return GTLRComputeQuery_DisksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Returns the specified persistent disk.
 *
 *  Method: compute.disks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksGet : GTLRComputeQuery

/** Name of the persistent disk to return. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Disk.
 *
 *  Returns the specified persistent disk.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk Name of the persistent disk to return.
 *
 *  @return GTLRComputeQuery_DisksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.disks.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk from a source (sourceImage, sourceSnapshot,
 *  or sourceDisk) or create an empty 500 GB data disk by omitting all
 *  properties. You can also create a disk that is larger than the default size
 *  by specifying the sizeGb property.
 *
 *  Method: compute.disks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Source image to restore onto a disk. This field is optional. */
@property(nonatomic, copy, nullable) NSString *sourceImage;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a persistent disk in the specified project using the data in the
 *  request. You can create a disk from a source (sourceImage, sourceSnapshot,
 *  or sourceDisk) or create an empty 500 GB data disk by omitting all
 *  properties. You can also create a disk that is larger than the default size
 *  by specifying the sizeGb property.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DisksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  Method: compute.disks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskList.
 *
 *  Retrieves a list of persistent disks contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DisksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Removes resource policies from a disk.
 *
 *  Method: compute.disks.removeResourcePolicies
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksRemoveResourcePolicies : GTLRComputeQuery

/** The disk name for this request. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes resource policies from a disk.
 *
 *  @param object The @c GTLRCompute_DisksRemoveResourcePoliciesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The disk name for this request.
 *
 *  @return GTLRComputeQuery_DisksRemoveResourcePolicies
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksRemoveResourcePoliciesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Resizes the specified persistent disk. You can only increase the size of the
 *  disk.
 *
 *  Method: compute.disks.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksResize : GTLRComputeQuery

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the specified persistent disk. You can only increase the size of the
 *  disk.
 *
 *  @param object The @c GTLRCompute_DisksResizeRequest to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @return GTLRComputeQuery_DisksResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksResizeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.disks.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on a disk. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.disks.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a disk. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_ZoneSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Starts asynchronous replication. Must be invoked on the primary disk.
 *
 *  Method: compute.disks.startAsyncReplication
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksStartAsyncReplication : GTLRComputeQuery

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts asynchronous replication. Must be invoked on the primary disk.
 *
 *  @param object The @c GTLRCompute_DisksStartAsyncReplicationRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @return GTLRComputeQuery_DisksStartAsyncReplication
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksStartAsyncReplicationRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Stops asynchronous replication. Can be invoked either on the primary or on
 *  the secondary disk.
 *
 *  Method: compute.disks.stopAsyncReplication
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksStopAsyncReplication : GTLRComputeQuery

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops asynchronous replication. Can be invoked either on the primary or on
 *  the secondary disk.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @return GTLRComputeQuery_DisksStopAsyncReplication
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                            disk:(NSString *)disk;

@end

/**
 *  Stops asynchronous replication for a consistency group of disks. Can be
 *  invoked either in the primary or secondary scope.
 *
 *  Method: compute.disks.stopGroupAsyncReplication
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksStopGroupAsyncReplication : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request. This must be the zone of the primary
 *  or secondary disks in the consistency group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops asynchronous replication for a consistency group of disks. Can be
 *  invoked either in the primary or secondary scope.
 *
 *  @param object The @c GTLRCompute_DisksStopGroupAsyncReplicationResource to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request. This must be the
 *    zone of the primary or secondary disks in the consistency group.
 *
 *  @return GTLRComputeQuery_DisksStopGroupAsyncReplication
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksStopGroupAsyncReplicationResource *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.disks.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DisksTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_DisksTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Updates the specified disk with the data included in the request. The update
 *  is performed only on selected fields included as part of update-mask. Only
 *  the following fields can be modified: user_license.
 *
 *  Method: compute.disks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_DisksUpdate : GTLRComputeQuery

/** The disk name for this request. */
@property(nonatomic, copy, nullable) NSString *disk;

@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified disk with the data included in the request. The update
 *  is performed only on selected fields included as part of update-mask. Only
 *  the following fields can be modified: user_license.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param disk The disk name for this request.
 *
 *  @return GTLRComputeQuery_DisksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                           disk:(NSString *)disk;

@end

/**
 *  Retrieves an aggregated list of disk types. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.diskTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_DiskTypeAggregatedList.
 *
 *  Retrieves an aggregated list of disk types. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_DiskTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified disk type.
 *
 *  Method: compute.diskTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesGet : GTLRComputeQuery

/** Name of the disk type to return. */
@property(nonatomic, copy, nullable) NSString *diskType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskType.
 *
 *  Returns the specified disk type.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param diskType Name of the disk type to return.
 *
 *  @return GTLRComputeQuery_DiskTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        diskType:(NSString *)diskType;

@end

/**
 *  Retrieves a list of disk types available to the specified project.
 *
 *  Method: compute.diskTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_DiskTypesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_DiskTypeList.
 *
 *  Retrieves a list of disk types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_DiskTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified externalVpnGateway.
 *
 *  Method: compute.externalVpnGateways.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ExternalVpnGatewaysDelete : GTLRComputeQuery

/** Name of the externalVpnGateways to delete. */
@property(nonatomic, copy, nullable) NSString *externalVpnGateway;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified externalVpnGateway.
 *
 *  @param project Project ID for this request.
 *  @param externalVpnGateway Name of the externalVpnGateways to delete.
 *
 *  @return GTLRComputeQuery_ExternalVpnGatewaysDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
              externalVpnGateway:(NSString *)externalVpnGateway;

@end

/**
 *  Returns the specified externalVpnGateway. Get a list of available
 *  externalVpnGateways by making a list() request.
 *
 *  Method: compute.externalVpnGateways.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ExternalVpnGatewaysGet : GTLRComputeQuery

/** Name of the externalVpnGateway to return. */
@property(nonatomic, copy, nullable) NSString *externalVpnGateway;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ExternalVpnGateway.
 *
 *  Returns the specified externalVpnGateway. Get a list of available
 *  externalVpnGateways by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param externalVpnGateway Name of the externalVpnGateway to return.
 *
 *  @return GTLRComputeQuery_ExternalVpnGatewaysGet
 */
+ (instancetype)queryWithProject:(NSString *)project
              externalVpnGateway:(NSString *)externalVpnGateway;

@end

/**
 *  Creates a ExternalVpnGateway in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.externalVpnGateways.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ExternalVpnGatewaysInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ExternalVpnGateway in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_ExternalVpnGateway to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ExternalVpnGatewaysInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ExternalVpnGateway *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of ExternalVpnGateway available to the specified project.
 *
 *  Method: compute.externalVpnGateways.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ExternalVpnGatewaysList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ExternalVpnGatewayList.
 *
 *  Retrieves the list of ExternalVpnGateway available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ExternalVpnGatewaysList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the labels on an ExternalVpnGateway. To learn more about labels, read
 *  the Labeling Resources documentation.
 *
 *  Method: compute.externalVpnGateways.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ExternalVpnGatewaysSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an ExternalVpnGateway. To learn more about labels, read
 *  the Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ExternalVpnGatewaysSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.externalVpnGateways.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ExternalVpnGatewaysTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ExternalVpnGatewaysTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Inserts an association for the specified firewall policy.
 *
 *  Method: compute.firewallPolicies.addAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesAddAssociation : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  Indicates whether or not to replace it if an association of the attachment
 *  already exists. This is false by default, in which case an error will be
 *  returned if an association already exists.
 */
@property(nonatomic, assign) BOOL replaceExistingAssociation;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts an association for the specified firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyAssociation to include in the
 *    query.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesAddAssociation
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyAssociation *)object
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Inserts a rule into a firewall policy.
 *
 *  Method: compute.firewallPolicies.addRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesAddRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts a rule into a firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyRule to include in the query.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesAddRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyRule *)object
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Copies rules to the specified firewall policy.
 *
 *  Method: compute.firewallPolicies.cloneRules
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesCloneRules : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** The firewall policy from which to copy rules. */
@property(nonatomic, copy, nullable) NSString *sourceFirewallPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Copies rules to the specified firewall policy.
 *
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesCloneRules
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Deletes the specified policy.
 *
 *  Method: compute.firewallPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesDelete : GTLRComputeQuery

/** Name of the firewall policy to delete. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified policy.
 *
 *  @param firewallPolicy Name of the firewall policy to delete.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesDelete
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Returns the specified firewall policy.
 *
 *  Method: compute.firewallPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesGet : GTLRComputeQuery

/** Name of the firewall policy to get. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicy.
 *
 *  Returns the specified firewall policy.
 *
 *  @param firewallPolicy Name of the firewall policy to get.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesGet
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Gets an association with the specified name.
 *
 *  Method: compute.firewallPolicies.getAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesGetAssociation : GTLRComputeQuery

/** Name of the firewall policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The name of the association to get from the firewall policy. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyAssociation.
 *
 *  Gets an association with the specified name.
 *
 *  @param firewallPolicy Name of the firewall policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesGetAssociation
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.firewallPolicies.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesGetIamPolicy
 */
+ (instancetype)queryWithResource:(NSString *)resource;

@end

/**
 *  Gets a rule of the specified priority.
 *
 *  Method: compute.firewallPolicies.getRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesGetRule : GTLRComputeQuery

/** Name of the firewall policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to get from the firewall policy. */
@property(nonatomic, assign) NSInteger priority;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyRule.
 *
 *  Gets a rule of the specified priority.
 *
 *  @param firewallPolicy Name of the firewall policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesGetRule
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.firewallPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesInsert : GTLRComputeQuery

/**
 *  Parent ID for this request. The ID can be either be "folders/[FOLDER_ID]" if
 *  the parent is a folder or "organizations/[ORGANIZATION_ID]" if the parent is
 *  an organization.
 */
@property(nonatomic, copy, nullable) NSString *parentId;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_FirewallPolicy to include in the query.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicy *)object;

@end

/**
 *  Lists all the policies that have been configured for the specified folder or
 *  organization.
 *
 *  Method: compute.firewallPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Parent ID for this request. The ID can be either be "folders/[FOLDER_ID]" if
 *  the parent is a folder or "organizations/[ORGANIZATION_ID]" if the parent is
 *  an organization.
 */
@property(nonatomic, copy, nullable) NSString *parentId;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyList.
 *
 *  Lists all the policies that have been configured for the specified folder or
 *  organization.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)query;

@end

/**
 *  Lists associations of a specified target, i.e., organization or folder.
 *
 *  Method: compute.firewallPolicies.listAssociations
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesListAssociations : GTLRComputeQuery

/**
 *  The target resource to list associations. It is an organization, or a
 *  folder.
 */
@property(nonatomic, copy, nullable) NSString *targetResource;

/**
 *  Fetches a @c GTLRCompute_FirewallPoliciesListAssociationsResponse.
 *
 *  Lists associations of a specified target, i.e., organization or folder.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesListAssociations
 */
+ (instancetype)query;

@end

/**
 *  Moves the specified firewall policy.
 *
 *  Method: compute.firewallPolicies.move
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesMove : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  The new parent of the firewall policy. The ID can be either be
 *  "folders/[FOLDER_ID]" if the parent is a folder or
 *  "organizations/[ORGANIZATION_ID]" if the parent is an organization.
 */
@property(nonatomic, copy, nullable) NSString *parentId;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves the specified firewall policy.
 *
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesMove
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Patches the specified policy with the data included in the request.
 *
 *  Method: compute.firewallPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesPatch : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_FirewallPolicy to include in the query.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicy *)object
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Patches a rule of the specified priority.
 *
 *  Method: compute.firewallPolicies.patchRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesPatchRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to patch. */
@property(nonatomic, assign) NSInteger priority;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches a rule of the specified priority.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyRule to include in the query.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesPatchRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyRule *)object
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Removes an association for the specified firewall policy.
 *
 *  Method: compute.firewallPolicies.removeAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesRemoveAssociation : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Name for the attachment that will be removed. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes an association for the specified firewall policy.
 *
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesRemoveAssociation
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Deletes a rule of the specified priority.
 *
 *  Method: compute.firewallPolicies.removeRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesRemoveRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to remove from the firewall policy. */
@property(nonatomic, assign) NSInteger priority;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a rule of the specified priority.
 *
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesRemoveRule
 */
+ (instancetype)queryWithFirewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.firewallPolicies.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallPoliciesSetIamPolicy : GTLRComputeQuery

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalOrganizationSetPolicyRequest to
 *    include in the query.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalOrganizationSetPolicyRequest *)object
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.firewallPolicies.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallPoliciesTestIamPermissions : GTLRComputeQuery

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_FirewallPoliciesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified firewall.
 *
 *  Method: compute.firewalls.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsDelete : GTLRComputeQuery

/** Name of the firewall rule to delete. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to delete.
 *
 *  @return GTLRComputeQuery_FirewallsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Returns the specified firewall.
 *
 *  Method: compute.firewalls.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsGet : GTLRComputeQuery

/** Name of the firewall rule to return. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Firewall.
 *
 *  Returns the specified firewall.
 *
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to return.
 *
 *  @return GTLRComputeQuery_FirewallsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        firewall:(NSString *)firewall;

@end

/**
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.firewalls.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a firewall rule in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_FirewallsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  Method: compute.firewalls.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_FirewallsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_FirewallList.
 *
 *  Retrieves the list of firewall rules available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_FirewallsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.firewalls.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsPatch : GTLRComputeQuery

/** Name of the firewall rule to patch. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to patch.
 *
 *  @return GTLRComputeQuery_FirewallsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Updates the specified firewall rule with the data included in the request.
 *  Note that all fields will be updated if using PUT, even fields that are not
 *  specified. To update individual fields, please use PATCH instead.
 *
 *  Method: compute.firewalls.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_FirewallsUpdate : GTLRComputeQuery

/** Name of the firewall rule to update. */
@property(nonatomic, copy, nullable) NSString *firewall;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified firewall rule with the data included in the request.
 *  Note that all fields will be updated if using PUT, even fields that are not
 *  specified. To update individual fields, please use PATCH instead.
 *
 *  @param object The @c GTLRCompute_Firewall to include in the query.
 *  @param project Project ID for this request.
 *  @param firewall Name of the firewall rule to update.
 *
 *  @return GTLRComputeQuery_FirewallsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Firewall *)object
                        project:(NSString *)project
                       firewall:(NSString *)firewall;

@end

/**
 *  Retrieves an aggregated list of forwarding rules. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.forwardingRules.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleAggregatedList.
 *
 *  Retrieves an aggregated list of forwarding rules. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesDelete : GTLRComputeQuery

/** Name of the ForwardingRule resource to delete. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @return GTLRComputeQuery_ForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified ForwardingRule resource.
 *
 *  Method: compute.forwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesGet : GTLRComputeQuery

/** Name of the ForwardingRule resource to return. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified ForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @return GTLRComputeQuery_ForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.forwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ForwardingRule resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  Method: compute.forwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ForwardingRulesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of ForwardingRule resources available to the specified
 *  project and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified forwarding rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules. Currently, you can only patch the network_tier field.
 *
 *  Method: compute.forwardingRules.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesPatch : GTLRComputeQuery

/** Name of the ForwardingRule resource to patch. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified forwarding rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules. Currently, you can only patch the network_tier field.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource to patch.
 *
 *  @return GTLRComputeQuery_ForwardingRulesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Sets the labels on the specified resource. To learn more about labels, read
 *  the Labeling Resources documentation.
 *
 *  Method: compute.forwardingRules.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on the specified resource. To learn more about labels, read
 *  the Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ForwardingRulesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  Method: compute.forwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ForwardingRulesSetTarget : GTLRComputeQuery

/** Name of the ForwardingRule resource in which target is to be set. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for forwarding rule. The new target should be of the same
 *  type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @return GTLRComputeQuery_ForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Deletes the specified address resource.
 *
 *  Method: compute.globalAddresses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesDelete : GTLRComputeQuery

/** Name of the address resource to delete. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to delete.
 *
 *  @return GTLRComputeQuery_GlobalAddressesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Returns the specified address resource.
 *
 *  Method: compute.globalAddresses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesGet : GTLRComputeQuery

/** Name of the address resource to return. */
@property(nonatomic, copy, nullable) NSString *address;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Address.
 *
 *  Returns the specified address resource.
 *
 *  @param project Project ID for this request.
 *  @param address Name of the address resource to return.
 *
 *  @return GTLRComputeQuery_GlobalAddressesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         address:(NSString *)address;

@end

/**
 *  Creates an address resource in the specified project by using the data
 *  included in the request.
 *
 *  Method: compute.globalAddresses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an address resource in the specified project by using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Address to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalAddressesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Address *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of global addresses.
 *
 *  Method: compute.globalAddresses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalAddressesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_AddressList.
 *
 *  Retrieves a list of global addresses.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalAddressesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Moves the specified address resource from one project to another project.
 *
 *  Method: compute.globalAddresses.move
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesMove : GTLRComputeQuery

/** Name of the address resource to move. */
@property(nonatomic, copy, nullable) NSString *address;

/** Source project ID which the Address is moved from. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves the specified address resource from one project to another project.
 *
 *  @param object The @c GTLRCompute_GlobalAddressesMoveRequest to include in
 *    the query.
 *  @param project Source project ID which the Address is moved from.
 *  @param address Name of the address resource to move.
 *
 *  @return GTLRComputeQuery_GlobalAddressesMove
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalAddressesMoveRequest *)object
                        project:(NSString *)project
                        address:(NSString *)address;

@end

/**
 *  Sets the labels on a GlobalAddress. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.globalAddresses.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalAddressesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a GlobalAddress. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_GlobalAddressesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified GlobalForwardingRule resource.
 *
 *  Method: compute.globalForwardingRules.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesDelete : GTLRComputeQuery

/** Name of the ForwardingRule resource to delete. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified GlobalForwardingRule resource.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to delete.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Returns the specified GlobalForwardingRule resource. Gets a list of
 *  available forwarding rules by making a list() request.
 *
 *  Method: compute.globalForwardingRules.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesGet : GTLRComputeQuery

/** Name of the ForwardingRule resource to return. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_ForwardingRule.
 *
 *  Returns the specified GlobalForwardingRule resource. Gets a list of
 *  available forwarding rules by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to return.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Creates a GlobalForwardingRule resource in the specified project using the
 *  data included in the request.
 *
 *  Method: compute.globalForwardingRules.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a GlobalForwardingRule resource in the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of GlobalForwardingRule resources available to the
 *  specified project.
 *
 *  Method: compute.globalForwardingRules.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalForwardingRulesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ForwardingRuleList.
 *
 *  Retrieves a list of GlobalForwardingRule resources available to the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified forwarding rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules. Currently, you can only patch the network_tier field.
 *
 *  Method: compute.globalForwardingRules.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesPatch : GTLRComputeQuery

/** Name of the ForwardingRule resource to patch. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified forwarding rule with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules. Currently, you can only patch the network_tier field.
 *
 *  @param object The @c GTLRCompute_ForwardingRule to include in the query.
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource to patch.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_ForwardingRule *)object
                        project:(NSString *)project
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Sets the labels on the specified resource. To learn more about labels, read
 *  the Labeling resources documentation.
 *
 *  Method: compute.globalForwardingRules.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on the specified resource. To learn more about labels, read
 *  the Labeling resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Changes target URL for the GlobalForwardingRule resource. The new target
 *  should be of the same type as the old target.
 *
 *  Method: compute.globalForwardingRules.setTarget
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalForwardingRulesSetTarget : GTLRComputeQuery

/** Name of the ForwardingRule resource in which target is to be set. */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes target URL for the GlobalForwardingRule resource. The new target
 *  should be of the same type as the old target.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param forwardingRule Name of the ForwardingRule resource in which target is
 *    to be set.
 *
 *  @return GTLRComputeQuery_GlobalForwardingRulesSetTarget
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                 forwardingRule:(NSString *)forwardingRule;

@end

/**
 *  Attach a network endpoint to the specified network endpoint group.
 *
 *  Method: compute.globalNetworkEndpointGroups.attachNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsAttachNetworkEndpoints : GTLRComputeQuery

/**
 *  The name of the network endpoint group where you are attaching network
 *  endpoints to. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attach a network endpoint to the specified network endpoint group.
 *
 *  @param object The @c
 *    GTLRCompute_GlobalNetworkEndpointGroupsAttachEndpointsRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param networkEndpointGroup The name of the network endpoint group where you
 *    are attaching network endpoints to. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsAttachNetworkEndpoints
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalNetworkEndpointGroupsAttachEndpointsRequest *)object
                        project:(NSString *)project
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Deletes the specified network endpoint group.Note that the NEG cannot be
 *  deleted if there are backend services referencing it.
 *
 *  Method: compute.globalNetworkEndpointGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsDelete : GTLRComputeQuery

/**
 *  The name of the network endpoint group to delete. It should comply with
 *  RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network endpoint group.Note that the NEG cannot be
 *  deleted if there are backend services referencing it.
 *
 *  @param project Project ID for this request.
 *  @param networkEndpointGroup The name of the network endpoint group to
 *    delete. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Detach the network endpoint from the specified network endpoint group.
 *
 *  Method: compute.globalNetworkEndpointGroups.detachNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsDetachNetworkEndpoints : GTLRComputeQuery

/**
 *  The name of the network endpoint group where you are removing network
 *  endpoints. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detach the network endpoint from the specified network endpoint group.
 *
 *  @param object The @c
 *    GTLRCompute_GlobalNetworkEndpointGroupsDetachEndpointsRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param networkEndpointGroup The name of the network endpoint group where you
 *    are removing network endpoints. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsDetachNetworkEndpoints
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalNetworkEndpointGroupsDetachEndpointsRequest *)object
                        project:(NSString *)project
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Returns the specified network endpoint group.
 *
 *  Method: compute.globalNetworkEndpointGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsGet : GTLRComputeQuery

/** The name of the network endpoint group. It should comply with RFC1035. */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroup.
 *
 *  Returns the specified network endpoint group.
 *
 *  @param project Project ID for this request.
 *  @param networkEndpointGroup The name of the network endpoint group. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Creates a network endpoint group in the specified project using the
 *  parameters that are included in the request.
 *
 *  Method: compute.globalNetworkEndpointGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network endpoint group in the specified project using the
 *  parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_NetworkEndpointGroup to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEndpointGroup *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of network endpoint groups that are located in the
 *  specified project.
 *
 *  Method: compute.globalNetworkEndpointGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupList.
 *
 *  Retrieves the list of network endpoint groups that are located in the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Lists the network endpoints in the specified network endpoint group.
 *
 *  Method: compute.globalNetworkEndpointGroups.listNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalNetworkEndpointGroupsListNetworkEndpoints : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  The name of the network endpoint group from which you want to generate a
 *  list of included network endpoints. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupsListNetworkEndpoints.
 *
 *  Lists the network endpoints in the specified network endpoint group.
 *
 *  @param project Project ID for this request.
 *  @param networkEndpointGroup The name of the network endpoint group from
 *    which you want to generate a list of included network endpoints. It should
 *    comply with RFC1035.
 *
 *  @return GTLRComputeQuery_GlobalNetworkEndpointGroupsListNetworkEndpoints
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Retrieves an aggregated list of all operations. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.globalOperations.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_OperationAggregatedList.
 *
 *  Retrieves an aggregated list of all operations. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalOperationsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Operations resource.
 *
 *  Method: compute.globalOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalOperationsDelete : GTLRComputeQuery

/**
 *  Name of the Operations resource to delete, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to delete, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_GlobalOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified Operations resource.
 *
 *  Method: compute.globalOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsGet : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_GlobalOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  Method: compute.globalOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Waits for the specified Operation resource to return as `DONE` or for the
 *  request to approach the 2 minute deadline, and retrieves the specified
 *  Operation resource. This method differs from the `GET` method in that it
 *  waits for no more than the default deadline (2 minutes) and then returns the
 *  current state of the operation, which might be `DONE` or still in progress.
 *  This method is called on a best-effort basis. Specifically: - In uncommon
 *  cases, when the server is overloaded, the request might return before the
 *  default deadline is reached, or might return after zero seconds. - If the
 *  default deadline is reached, there is no guarantee that the operation is
 *  actually done when the method returns. Be prepared to retry if the operation
 *  is not `DONE`.
 *
 *  Method: compute.globalOperations.wait
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOperationsWait : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Waits for the specified Operation resource to return as `DONE` or for the
 *  request to approach the 2 minute deadline, and retrieves the specified
 *  Operation resource. This method differs from the `GET` method in that it
 *  waits for no more than the default deadline (2 minutes) and then returns the
 *  current state of the operation, which might be `DONE` or still in progress.
 *  This method is called on a best-effort basis. Specifically: - In uncommon
 *  cases, when the server is overloaded, the request might return before the
 *  default deadline is reached, or might return after zero seconds. - If the
 *  default deadline is reached, there is no guarantee that the operation is
 *  actually done when the method returns. Be prepared to retry if the operation
 *  is not `DONE`.
 *
 *  @param project Project ID for this request.
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_GlobalOperationsWait
 */
+ (instancetype)queryWithProject:(NSString *)project
                       operation:(NSString *)operation;

@end

/**
 *  Deletes the specified Operations resource.
 *
 *  Method: compute.globalOrganizationOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalOrganizationOperationsDelete : GTLRComputeQuery

/**
 *  Name of the Operations resource to delete, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Parent ID for this request. */
@property(nonatomic, copy, nullable) NSString *parentId;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified Operations resource.
 *
 *  @param operation Name of the Operations resource to delete, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_GlobalOrganizationOperationsDelete
 */
+ (instancetype)queryWithOperation:(NSString *)operation;

@end

/**
 *  Retrieves the specified Operations resource. Gets a list of operations by
 *  making a `list()` request.
 *
 *  Method: compute.globalOrganizationOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOrganizationOperationsGet : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Parent ID for this request. */
@property(nonatomic, copy, nullable) NSString *parentId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified Operations resource. Gets a list of operations by
 *  making a `list()` request.
 *
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_GlobalOrganizationOperationsGet
 */
+ (instancetype)queryWithOperation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  organization.
 *
 *  Method: compute.globalOrganizationOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalOrganizationOperationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Parent ID for this request. */
@property(nonatomic, copy, nullable) NSString *parentId;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  organization.
 *
 *  @return GTLRComputeQuery_GlobalOrganizationOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)query;

@end

/**
 *  Deletes the specified global PublicDelegatedPrefix.
 *
 *  Method: compute.globalPublicDelegatedPrefixes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalPublicDelegatedPrefixesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicDelegatedPrefix resource to delete. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified global PublicDelegatedPrefix.
 *
 *  @param project Project ID for this request.
 *  @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to
 *    delete.
 *
 *  @return GTLRComputeQuery_GlobalPublicDelegatedPrefixesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
           publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Returns the specified global PublicDelegatedPrefix resource.
 *
 *  Method: compute.globalPublicDelegatedPrefixes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalPublicDelegatedPrefixesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicDelegatedPrefix resource to return. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/**
 *  Fetches a @c GTLRCompute_PublicDelegatedPrefix.
 *
 *  Returns the specified global PublicDelegatedPrefix resource.
 *
 *  @param project Project ID for this request.
 *  @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to
 *    return.
 *
 *  @return GTLRComputeQuery_GlobalPublicDelegatedPrefixesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
           publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Creates a global PublicDelegatedPrefix in the specified project using the
 *  parameters that are included in the request.
 *
 *  Method: compute.globalPublicDelegatedPrefixes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalPublicDelegatedPrefixesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a global PublicDelegatedPrefix in the specified project using the
 *  parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_PublicDelegatedPrefix to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalPublicDelegatedPrefixesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_PublicDelegatedPrefix *)object
                        project:(NSString *)project;

@end

/**
 *  Lists the global PublicDelegatedPrefixes for a project.
 *
 *  Method: compute.globalPublicDelegatedPrefixes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_GlobalPublicDelegatedPrefixesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_PublicDelegatedPrefixList.
 *
 *  Lists the global PublicDelegatedPrefixes for a project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_GlobalPublicDelegatedPrefixesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified global PublicDelegatedPrefix resource with the data
 *  included in the request. This method supports PATCH semantics and uses JSON
 *  merge patch format and processing rules.
 *
 *  Method: compute.globalPublicDelegatedPrefixes.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_GlobalPublicDelegatedPrefixesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicDelegatedPrefix resource to patch. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified global PublicDelegatedPrefix resource with the data
 *  included in the request. This method supports PATCH semantics and uses JSON
 *  merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_PublicDelegatedPrefix to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to
 *    patch.
 *
 *  @return GTLRComputeQuery_GlobalPublicDelegatedPrefixesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_PublicDelegatedPrefix *)object
                        project:(NSString *)project
          publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Retrieves the list of all HealthCheck resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.healthChecks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_HealthChecksAggregatedList.
 *
 *  Retrieves the list of all HealthCheck resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_HealthChecksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified HealthCheck resource.
 *
 *  Method: compute.healthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksDelete : GTLRComputeQuery

/** Name of the HealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_HealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Returns the specified HealthCheck resource.
 *
 *  Method: compute.healthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksGet : GTLRComputeQuery

/** Name of the HealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HealthCheck.
 *
 *  Returns the specified HealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_HealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.healthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.healthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HealthChecksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_HealthCheckList.
 *
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.healthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksPatch : GTLRComputeQuery

/** Name of the HealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_HealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.healthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HealthChecksUpdate : GTLRComputeQuery

/** Name of the HealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param healthCheck Name of the HealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_HealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  Method: compute.httpHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksDelete : GTLRComputeQuery

/** Name of the HttpHealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Returns the specified HttpHealthCheck resource.
 *
 *  Method: compute.httpHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksGet : GTLRComputeQuery

/** Name of the HttpHealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheck.
 *
 *  Returns the specified HttpHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpHealthChecksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_HttpHealthCheckList.
 *
 *  Retrieves the list of HttpHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.httpHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksPatch : GTLRComputeQuery

/** Name of the HttpHealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpHealthChecksUpdate : GTLRComputeQuery

/** Name of the HttpHealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *httpHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpHealthCheck Name of the HttpHealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_HttpHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpHealthCheck *)object
                        project:(NSString *)project
                httpHealthCheck:(NSString *)httpHealthCheck;

@end

/**
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  Method: compute.httpsHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksDelete : GTLRComputeQuery

/** Name of the HttpsHealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HttpsHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Returns the specified HttpsHealthCheck resource.
 *
 *  Method: compute.httpsHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksGet : GTLRComputeQuery

/** Name of the HttpsHealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheck.
 *
 *  Returns the specified HttpsHealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.httpsHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_HttpsHealthChecksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_HttpsHealthCheckList.
 *
 *  Retrieves the list of HttpsHealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.httpsHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksPatch : GTLRComputeQuery

/** Name of the HttpsHealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.httpsHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_HttpsHealthChecksUpdate : GTLRComputeQuery

/** Name of the HttpsHealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *httpsHealthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HttpsHealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HttpsHealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param httpsHealthCheck Name of the HttpsHealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_HttpsHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HttpsHealthCheck *)object
                        project:(NSString *)project
               httpsHealthCheck:(NSString *)httpsHealthCheck;

@end

/**
 *  Returns the latest image that is part of an image family, is not deprecated
 *  and is rolled out in the specified zone.
 *
 *  Method: compute.imageFamilyViews.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImageFamilyViewsGet : GTLRComputeQuery

/** Name of the image family to search for. */
@property(nonatomic, copy, nullable) NSString *family;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_ImageFamilyView.
 *
 *  Returns the latest image that is part of an image family, is not deprecated
 *  and is rolled out in the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param family Name of the image family to search for.
 *
 *  @return GTLRComputeQuery_ImageFamilyViewsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                          family:(NSString *)family;

@end

/**
 *  Deletes the specified image.
 *
 *  Method: compute.images.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDelete : GTLRComputeQuery

/** Name of the image resource to delete. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified image.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to delete.
 *
 *  @return GTLRComputeQuery_ImagesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Sets the deprecation status of an image. If an empty request body is given,
 *  clears the deprecation status instead.
 *
 *  Method: compute.images.deprecate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesDeprecate : GTLRComputeQuery

/** Image name. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the deprecation status of an image. If an empty request body is given,
 *  clears the deprecation status instead.
 *
 *  @param object The @c GTLRCompute_DeprecationStatus to include in the query.
 *  @param project Project ID for this request.
 *  @param image Image name.
 *
 *  @return GTLRComputeQuery_ImagesDeprecate
 */
+ (instancetype)queryWithObject:(GTLRCompute_DeprecationStatus *)object
                        project:(NSString *)project
                          image:(NSString *)image;

@end

/**
 *  Returns the specified image.
 *
 *  Method: compute.images.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGet : GTLRComputeQuery

/** Name of the image resource to return. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the specified image.
 *
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to return.
 *
 *  @return GTLRComputeQuery_ImagesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           image:(NSString *)image;

@end

/**
 *  Returns the latest image that is part of an image family and is not
 *  deprecated. For more information on image families, see Public image
 *  families documentation.
 *
 *  Method: compute.images.getFromFamily
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGetFromFamily : GTLRComputeQuery

/** Name of the image family to search for. */
@property(nonatomic, copy, nullable) NSString *family;

/**
 *  The image project that the image belongs to. For example, to get a CentOS
 *  image, specify centos-cloud as the image project.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Image.
 *
 *  Returns the latest image that is part of an image family and is not
 *  deprecated. For more information on image families, see Public image
 *  families documentation.
 *
 *  @param project The image project that the image belongs to. For example, to
 *    get a CentOS image, specify centos-cloud as the image project.
 *  @param family Name of the image family to search for.
 *
 *  @return GTLRComputeQuery_ImagesGetFromFamily
 */
+ (instancetype)queryWithProject:(NSString *)project
                          family:(NSString *)family;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.images.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.images.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ImagesInsert : GTLRComputeQuery

/** Force image creation if true. */
@property(nonatomic, assign) BOOL forceCreate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an image in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Image to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ImagesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Image *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of custom images available to the specified project.
 *  Custom images are images you create that belong to your project. This method
 *  does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 8. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *
 *  Method: compute.images.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ImageList.
 *
 *  Retrieves the list of custom images available to the specified project.
 *  Custom images are images you create that belong to your project. This method
 *  does not get any images that belong to other projects, including
 *  publicly-available images, like Debian 8. If you want to get a list of
 *  publicly-available images, use this method to make a request to the
 *  respective image project, such as debian-cloud or windows-cloud.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ImagesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified image with the data included in the request. Only the
 *  following fields can be modified: family, description, deprecation status.
 *
 *  Method: compute.images.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesPatch : GTLRComputeQuery

/** Name of the image resource to patch. */
@property(nonatomic, copy, nullable) NSString *image;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified image with the data included in the request. Only the
 *  following fields can be modified: family, description, deprecation status.
 *
 *  @param object The @c GTLRCompute_Image to include in the query.
 *  @param project Project ID for this request.
 *  @param image Name of the image resource to patch.
 *
 *  @return GTLRComputeQuery_ImagesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Image *)object
                        project:(NSString *)project
                          image:(NSString *)image;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.images.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on an image. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.images.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ImagesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an image. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.images.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ImagesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ImagesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Cancels the specified resize request and removes it from the queue.
 *  Cancelled resize request does no longer wait for the resources to be
 *  provisioned. Cancel is only possible for requests that are accepted in the
 *  queue.
 *
 *  Method: compute.instanceGroupManagerResizeRequests.cancel
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagerResizeRequestsCancel : GTLRComputeQuery

/**
 *  The name of the managed instance group. The name should conform to RFC1035
 *  or be a resource ID.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the resize request to cancel. The name should conform to RFC1035
 *  or be a resource ID.
 */
@property(nonatomic, copy, nullable) NSString *resizeRequest;

/**
 *  The name of the zone where the managed instance group is located. The name
 *  should conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Cancels the specified resize request and removes it from the queue.
 *  Cancelled resize request does no longer wait for the resources to be
 *  provisioned. Cancel is only possible for requests that are accepted in the
 *  queue.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. The name should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. The name
 *    should conform to RFC1035 or be a resource ID.
 *  @param resizeRequest The name of the resize request to cancel. The name
 *    should conform to RFC1035 or be a resource ID.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagerResizeRequestsCancel
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                   resizeRequest:(NSString *)resizeRequest;

@end

/**
 *  Deletes the specified, inactive resize request. Requests that are still
 *  active cannot be deleted. Deleting request does not delete instances that
 *  were provisioned previously.
 *
 *  Method: compute.instanceGroupManagerResizeRequests.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagerResizeRequestsDelete : GTLRComputeQuery

/**
 *  The name of the managed instance group. The name should conform to RFC1035
 *  or be a resource ID.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the resize request to delete. The name should conform to RFC1035
 *  or be a resource ID.
 */
@property(nonatomic, copy, nullable) NSString *resizeRequest;

/**
 *  The name of the zone where the managed instance group is located. The name
 *  should conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified, inactive resize request. Requests that are still
 *  active cannot be deleted. Deleting request does not delete instances that
 *  were provisioned previously.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. The name should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. The name
 *    should conform to RFC1035 or be a resource ID.
 *  @param resizeRequest The name of the resize request to delete. The name
 *    should conform to RFC1035 or be a resource ID.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagerResizeRequestsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                   resizeRequest:(NSString *)resizeRequest;

@end

/**
 *  Returns all of the details about the specified resize request.
 *
 *  Method: compute.instanceGroupManagerResizeRequests.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagerResizeRequestsGet : GTLRComputeQuery

/**
 *  The name of the managed instance group. Name should conform to RFC1035 or be
 *  a resource ID.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the resize request. Name should conform to RFC1035 or be a
 *  resource ID.
 */
@property(nonatomic, copy, nullable) NSString *resizeRequest;

/**
 *  Name of the href="/compute/docs/regions-zones/#available">zone scoping this
 *  request. Name should conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerResizeRequest.
 *
 *  Returns all of the details about the specified resize request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the
 *    href="/compute/docs/regions-zones/#available">zone scoping this request.
 *    Name should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. Name
 *    should conform to RFC1035 or be a resource ID.
 *  @param resizeRequest The name of the resize request. Name should conform to
 *    RFC1035 or be a resource ID.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagerResizeRequestsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                   resizeRequest:(NSString *)resizeRequest;

@end

/**
 *  Creates a new resize request that starts provisioning VMs immediately or
 *  queues VM creation.
 *
 *  Method: compute.instanceGroupManagerResizeRequests.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagerResizeRequestsInsert : GTLRComputeQuery

/**
 *  The name of the managed instance group to which the resize request will be
 *  added. Name should conform to RFC1035 or be a resource ID.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located and where
 *  the resize request will be created. Name should conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new resize request that starts provisioning VMs immediately or
 *  queues VM creation.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagerResizeRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located and where the resize request will be created. Name should conform
 *    to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group to which
 *    the resize request will be added. Name should conform to RFC1035 or be a
 *    resource ID.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagerResizeRequestsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagerResizeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Retrieves a list of resize requests that are contained in the managed
 *  instance group.
 *
 *  Method: compute.instanceGroupManagerResizeRequests.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagerResizeRequestsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The name of the managed instance group. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the managed instance group is located. The name
 *  should conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerResizeRequestsListResponse.
 *
 *  Retrieves a list of resize requests that are contained in the managed
 *  instance group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. The name should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. The name
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagerResizeRequestsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances to be removed from the managed instance group.
 *  Abandoning an instance does not delete the instance, but it does remove the
 *  instance from any target pools that are applied by the managed instance
 *  group. This method reduces the targetSize of the managed instance group by
 *  the number of instances that you abandon. This operation is marked as DONE
 *  when the action is scheduled even if the instances have not yet been removed
 *  from the group. You must separately verify the status of the abandoning
 *  action with the listmanagedinstances method. If the group is part of a
 *  backend service that has enabled connection draining, it can take up to 60
 *  seconds after the connection draining duration has elapsed before the VM
 *  instance is removed or deleted. You can specify a maximum of 1000 instances
 *  with this method per request.
 *
 *  Method: compute.instanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersAbandonInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances to be removed from the managed instance group.
 *  Abandoning an instance does not delete the instance, but it does remove the
 *  instance from any target pools that are applied by the managed instance
 *  group. This method reduces the targetSize of the managed instance group by
 *  the number of instances that you abandon. This operation is marked as DONE
 *  when the action is scheduled even if the instances have not yet been removed
 *  from the group. You must separately verify the status of the abandoning
 *  action with the listmanagedinstances method. If the group is part of a
 *  backend service that has enabled connection draining, it can take up to 60
 *  seconds after the connection draining duration has elapsed before the VM
 *  instance is removed or deleted. You can specify a maximum of 1000 instances
 *  with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersAbandonInstancesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Retrieves the list of managed instance groups and groups them by zone. To
 *  prevent failure, Google recommends that you set the `returnPartialSuccess`
 *  parameter to `true`.
 *
 *  Method: compute.instanceGroupManagers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerAggregatedList.
 *
 *  Retrieves the list of managed instance groups and groups them by zone. To
 *  prevent failure, Google recommends that you set the `returnPartialSuccess`
 *  parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Applies changes to selected instances on the managed instance group. This
 *  method can be used to apply new overrides and/or new versions.
 *
 *  Method: compute.instanceGroupManagers.applyUpdatesToInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersApplyUpdatesToInstances : GTLRComputeQuery

/** The name of the managed instance group, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located. Should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Applies changes to selected instances on the managed instance group. This
 *  method can be used to apply new overrides and/or new versions.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersApplyUpdatesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. Should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group, should
 *    conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersApplyUpdatesToInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersApplyUpdatesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates instances with per-instance configurations in this managed instance
 *  group. Instances are created using the current instance template. The create
 *  instances operation is marked DONE if the createInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the creating or actions with the listmanagedinstances
 *  method.
 *
 *  Method: compute.instanceGroupManagers.createInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersCreateInstances : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located. It should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates instances with per-instance configurations in this managed instance
 *  group. Instances are created using the current instance template. The create
 *  instances operation is marked DONE if the createInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the creating or actions with the listmanagedinstances
 *  method.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersCreateInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersCreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersCreateInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDelete : GTLRComputeQuery

/** The name of the managed instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group. Note that the instance group must not belong to a backend
 *  service. Read Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group to
 *    delete.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group for immediate
 *  deletion. The instances are also removed from any target pools of which they
 *  were a member. This method reduces the targetSize of the managed instance
 *  group by the number of instances that you delete. This operation is marked
 *  as DONE when the action is scheduled even if the instances are still being
 *  deleted. You must separately verify the status of the deleting action with
 *  the listmanagedinstances method. If the group is part of a backend service
 *  that has enabled connection draining, it can take up to 60 seconds after the
 *  connection draining duration has elapsed before the VM instance is removed
 *  or deleted. You can specify a maximum of 1000 instances with this method per
 *  request.
 *
 *  Method: compute.instanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDeleteInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group for immediate
 *  deletion. The instances are also removed from any target pools of which they
 *  were a member. This method reduces the targetSize of the managed instance
 *  group by the number of instances that you delete. This operation is marked
 *  as DONE when the action is scheduled even if the instances are still being
 *  deleted. You must separately verify the status of the deleting action with
 *  the listmanagedinstances method. If the group is part of a backend service
 *  that has enabled connection draining, it can take up to 60 seconds after the
 *  connection draining duration has elapsed before the VM instance is removed
 *  or deleted. You can specify a maximum of 1000 instances with this method per
 *  request.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Deletes selected per-instance configurations for the managed instance group.
 *
 *  Method: compute.instanceGroupManagers.deletePerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersDeletePerInstanceConfigs : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located. It should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes selected per-instance configurations for the managed instance group.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersDeletePerInstanceConfigsReq to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersDeletePerInstanceConfigs
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersDeletePerInstanceConfigsReq *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group.
 *
 *  Method: compute.instanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersGet : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method. A managed instance group can have up
 *  to 1000 VM instances per group. Please contact Cloud Support if you need an
 *  increase in this limit.
 *
 *  Method: compute.instanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the managed instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method. A managed instance group can have up
 *  to 1000 VM instances per group. Please contact Cloud Support if you need an
 *  increase in this limit.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  Method: compute.instanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagerList.
 *
 *  Retrieves a list of managed instance groups that are contained within the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists all errors thrown by actions on instances for a given managed instance
 *  group. The filter and orderBy query parameters are not supported.
 *
 *  Method: compute.instanceGroupManagers.listErrors
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersListErrors : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The name of the managed instance group. It must be a string that meets the
 *  requirements in RFC1035, or an unsigned long integer: must match regexp
 *  pattern: (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the managed instance group is located. It should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagersListErrorsResponse.
 *
 *  Lists all errors thrown by actions on instances for a given managed instance
 *  group. The filter and orderBy query parameters are not supported.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It must
 *    be a string that meets the requirements in RFC1035, or an unsigned long
 *    integer: must match regexp pattern:
 *    (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersListErrors
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action. The
 *  orderBy query parameter is not supported. The `pageToken` query parameter is
 *  supported only if the group's `listManagedInstancesResults` field is set to
 *  `PAGINATED`.
 *
 *  Method: compute.instanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersListManagedInstances : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagersListManagedInstancesResponse.
 *
 *  Lists all of the instances in the managed instance group. Each instance in
 *  the list has a currentAction, which indicates the action that the managed
 *  instance group is performing on the instance. For example, if the group is
 *  still creating an instance, the currentAction is CREATING. If a previous
 *  action failed, the list displays the errors for that failed action. The
 *  orderBy query parameter is not supported. The `pageToken` query parameter is
 *  supported only if the group's `listManagedInstancesResults` field is set to
 *  `PAGINATED`.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersListManagedInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Lists all of the per-instance configurations defined for the managed
 *  instance group. The orderBy query parameter is not supported.
 *
 *  Method: compute.instanceGroupManagers.listPerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupManagersListPerInstanceConfigs : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the managed instance group is located. It should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManagersListPerInstanceConfigsResp.
 *
 *  Lists all of the per-instance configurations defined for the managed
 *  instance group. The orderBy query parameter is not supported.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersListPerInstanceConfigs
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listManagedInstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules. If you update your group
 *  to specify a new template or instance configuration, it's possible that your
 *  intended specification for each VM in the group is different from the
 *  current state of that VM. To learn how to apply an updated configuration to
 *  the VMs in a MIG, see Updating instances in a MIG.
 *
 *  Method: compute.instanceGroupManagers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersPatch : GTLRComputeQuery

/** The name of the instance group manager. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the managed instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listManagedInstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules. If you update your group
 *  to specify a new template or instance configuration, it's possible that your
 *  intended specification for each VM in the group is different from the
 *  current state of that VM. To learn how to apply an updated configuration to
 *  the VMs in a MIG, see Updating instances in a MIG.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    managed instance group.
 *  @param instanceGroupManager The name of the instance group manager.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Inserts or patches per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  Method: compute.instanceGroupManagers.patchPerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersPatchPerInstanceConfigs : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located. It should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts or patches per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersPatchPerInstanceConfigsReq to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersPatchPerInstanceConfigs
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersPatchPerInstanceConfigsReq *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified VM instances in the managed instance group to be
 *  immediately recreated. Each instance is recreated using the group's current
 *  configuration. This operation is marked as DONE when the flag is set even if
 *  the instances have not yet been recreated. You must separately verify the
 *  status of each instance by checking its currentAction field; for more
 *  information, see Checking the status of managed instances. If the group is
 *  part of a backend service that has enabled connection draining, it can take
 *  up to 60 seconds after the connection draining duration has elapsed before
 *  the VM instance is removed or deleted. You can specify a maximum of 1000
 *  instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersRecreateInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified VM instances in the managed instance group to be
 *  immediately recreated. Each instance is recreated using the group's current
 *  configuration. This operation is marked as DONE when the flag is set even if
 *  the instances have not yet been recreated. You must separately verify the
 *  status of each instance by checking its currentAction field; for more
 *  information, see Checking the status of managed instances. If the group is
 *  part of a backend service that has enabled connection draining, it can take
 *  up to 60 seconds after the connection draining duration has elapsed before
 *  the VM instance is removed or deleted. You can specify a maximum of 1000
 *  instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersRecreateInstancesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersRecreateInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method. When resizing
 *  down, the instance group arbitrarily chooses the order in which VMs are
 *  deleted. The group takes into account some VM attributes when making the
 *  selection including: + The status of the VM instance. + The health of the VM
 *  instance. + The instance template version the VM is based on. + For regional
 *  managed instance groups, the location of the VM instance. This list is
 *  subject to change. If the group is part of a backend service that has
 *  enabled connection draining, it can take up to 60 seconds after the
 *  connection draining duration has elapsed before the VM instance is removed
 *  or deleted.
 *
 *  Method: compute.instanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersResize : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The number of running instances that the managed instance group should
 *  maintain at any given time. The group automatically adds or removes
 *  instances to maintain the number of instances specified by this parameter.
 */
@property(nonatomic, assign) NSInteger size;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the managed instance group. If you increase the size, the group
 *  creates new instances using the current instance template. If you decrease
 *  the size, the group deletes instances. The resize operation is marked DONE
 *  when the resize actions are scheduled even if the group has not yet added or
 *  deleted any instances. You must separately verify the status of the creating
 *  or deleting actions with the listmanagedinstances method. When resizing
 *  down, the instance group arbitrarily chooses the order in which VMs are
 *  deleted. The group takes into account some VM attributes when making the
 *  selection including: + The status of the VM instance. + The health of the VM
 *  instance. + The instance template version the VM is based on. + For regional
 *  managed instance groups, the location of the VM instance. This list is
 *  subject to change. If the group is part of a backend service that has
 *  enabled connection draining, it can take up to 60 seconds after the
 *  connection draining duration has elapsed before the VM instance is removed
 *  or deleted.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *  @param size The number of running instances that the managed instance group
 *    should maintain at any given time. The group automatically adds or removes
 *    instances to maintain the number of instances specified by this parameter.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Flags the specified instances in the managed instance group to be resumed.
 *  This method increases the targetSize and decreases the targetSuspendedSize
 *  of the managed instance group by the number of instances that you resume.
 *  The resumeInstances operation is marked DONE if the resumeInstances request
 *  is successful. The underlying actions take additional time. You must
 *  separately verify the status of the RESUMING action with the
 *  listmanagedinstances method. In this request, you can only specify instances
 *  that are suspended. For example, if an instance was previously suspended
 *  using the suspendInstances method, it can be resumed using the
 *  resumeInstances method. If a health check is attached to the managed
 *  instance group, the specified instances will be verified as healthy after
 *  they are resumed. You can specify a maximum of 1000 instances with this
 *  method per request.
 *
 *  Method: compute.instanceGroupManagers.resumeInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersResumeInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be resumed.
 *  This method increases the targetSize and decreases the targetSuspendedSize
 *  of the managed instance group by the number of instances that you resume.
 *  The resumeInstances operation is marked DONE if the resumeInstances request
 *  is successful. The underlying actions take additional time. You must
 *  separately verify the status of the RESUMING action with the
 *  listmanagedinstances method. In this request, you can only specify instances
 *  that are suspended. For example, if an instance was previously suspended
 *  using the suspendInstances method, it can be resumed using the
 *  resumeInstances method. If a health check is attached to the managed
 *  instance group, the specified instances will be verified as healthy after
 *  they are resumed. You can specify a maximum of 1000 instances with this
 *  method per request.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersResumeInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersResumeInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersResumeInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you run recreateInstances, run applyUpdatesToInstances, or set the
 *  group's updatePolicy.type to PROACTIVE.
 *
 *  Method: compute.instanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Specifies the instance template to use when creating new instances in this
 *  group. The templates for existing instances in the group do not change
 *  unless you run recreateInstances, run applyUpdatesToInstances, or set the
 *  group's updatePolicy.type to PROACTIVE.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  Method: compute.instanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSetTargetPools : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all instances in this managed instance
 *  group are assigned. The target pools automatically apply to all of the
 *  instances in the managed instance group. This operation is marked DONE when
 *  you make the request even if the instances have not yet been added to their
 *  target pools. The change might take some time to apply to all of the
 *  instances in the group depending on the size of the group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be started.
 *  This method increases the targetSize and decreases the targetStoppedSize of
 *  the managed instance group by the number of instances that you start. The
 *  startInstances operation is marked DONE if the startInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the STARTING action with the listmanagedinstances
 *  method. In this request, you can only specify instances that are stopped.
 *  For example, if an instance was previously stopped using the stopInstances
 *  method, it can be started using the startInstances method. If a health check
 *  is attached to the managed instance group, the specified instances will be
 *  verified as healthy after they are started. You can specify a maximum of
 *  1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.startInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersStartInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be started.
 *  This method increases the targetSize and decreases the targetStoppedSize of
 *  the managed instance group by the number of instances that you start. The
 *  startInstances operation is marked DONE if the startInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the STARTING action with the listmanagedinstances
 *  method. In this request, you can only specify instances that are stopped.
 *  For example, if an instance was previously stopped using the stopInstances
 *  method, it can be started using the startInstances method. If a health check
 *  is attached to the managed instance group, the specified instances will be
 *  verified as healthy after they are started. You can specify a maximum of
 *  1000 instances with this method per request.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersStartInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersStartInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersStartInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately stopped. You can only specify instances that are running in this
 *  request. This method reduces the targetSize and increases the
 *  targetStoppedSize of the managed instance group by the number of instances
 *  that you stop. The stopInstances operation is marked DONE if the
 *  stopInstances request is successful. The underlying actions take additional
 *  time. You must separately verify the status of the STOPPING action with the
 *  listmanagedinstances method. If the standbyPolicy.initialDelaySec field is
 *  set, the group delays stopping the instances until initialDelaySec have
 *  passed from instance.creationTimestamp (that is, when the instance was
 *  created). This delay gives your application time to set itself up and
 *  initialize on the instance. If more than initialDelaySec seconds have passed
 *  since instance.creationTimestamp when this method is called, there will be
 *  zero delay. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is stopped. Stopped
 *  instances can be started using the startInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.stopInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersStopInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately stopped. You can only specify instances that are running in this
 *  request. This method reduces the targetSize and increases the
 *  targetStoppedSize of the managed instance group by the number of instances
 *  that you stop. The stopInstances operation is marked DONE if the
 *  stopInstances request is successful. The underlying actions take additional
 *  time. You must separately verify the status of the STOPPING action with the
 *  listmanagedinstances method. If the standbyPolicy.initialDelaySec field is
 *  set, the group delays stopping the instances until initialDelaySec have
 *  passed from instance.creationTimestamp (that is, when the instance was
 *  created). This delay gives your application time to set itself up and
 *  initialize on the instance. If more than initialDelaySec seconds have passed
 *  since instance.creationTimestamp when this method is called, there will be
 *  zero delay. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is stopped. Stopped
 *  instances can be started using the startInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManagersStopInstancesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersStopInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersStopInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately suspended. You can only specify instances that are running in
 *  this request. This method reduces the targetSize and increases the
 *  targetSuspendedSize of the managed instance group by the number of instances
 *  that you suspend. The suspendInstances operation is marked DONE if the
 *  suspendInstances request is successful. The underlying actions take
 *  additional time. You must separately verify the status of the SUSPENDING
 *  action with the listmanagedinstances method. If the
 *  standbyPolicy.initialDelaySec field is set, the group delays suspension of
 *  the instances until initialDelaySec have passed from
 *  instance.creationTimestamp (that is, when the instance was created). This
 *  delay gives your application time to set itself up and initialize on the
 *  instance. If more than initialDelaySec seconds have passed since
 *  instance.creationTimestamp when this method is called, there will be zero
 *  delay. If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is suspended. Suspended
 *  instances can be resumed using the resumeInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  Method: compute.instanceGroupManagers.suspendInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersSuspendInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately suspended. You can only specify instances that are running in
 *  this request. This method reduces the targetSize and increases the
 *  targetSuspendedSize of the managed instance group by the number of instances
 *  that you suspend. The suspendInstances operation is marked DONE if the
 *  suspendInstances request is successful. The underlying actions take
 *  additional time. You must separately verify the status of the SUSPENDING
 *  action with the listmanagedinstances method. If the
 *  standbyPolicy.initialDelaySec field is set, the group delays suspension of
 *  the instances until initialDelaySec have passed from
 *  instance.creationTimestamp (that is, when the instance was created). This
 *  delay gives your application time to set itself up and initialize on the
 *  instance. If more than initialDelaySec seconds have passed since
 *  instance.creationTimestamp when this method is called, there will be zero
 *  delay. If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is suspended. Suspended
 *  instances can be resumed using the resumeInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersSuspendInstancesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersSuspendInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersSuspendInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Inserts or updates per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  Method: compute.instanceGroupManagers.updatePerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupManagersUpdatePerInstanceConfigs : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the managed instance group is located. It should
 *  conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts or updates per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  @param object The @c
 *    GTLRCompute_InstanceGroupManagersUpdatePerInstanceConfigsReq to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceGroupManagersUpdatePerInstanceConfigs
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManagersUpdatePerInstanceConfigsReq *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  Method: compute.instanceGroups.addInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsAddInstances : GTLRComputeQuery

/** The name of the instance group where you are adding instances. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a list of instances to the specified instance group. All of the
 *  instances in the instance group must be in the same network/subnetwork. Read
 *  Adding instances for more information.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsAddInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where you are adding
 *    instances.
 *
 *  @return GTLRComputeQuery_InstanceGroupsAddInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsAddInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance groups and sorts them by zone. To prevent
 *  failure, Google recommends that you set the `returnPartialSuccess` parameter
 *  to `true`.
 *
 *  Method: compute.instanceGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupAggregatedList.
 *
 *  Retrieves the list of instance groups and sorts them by zone. To prevent
 *  failure, Google recommends that you set the `returnPartialSuccess` parameter
 *  to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  Method: compute.instanceGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsDelete : GTLRComputeQuery

/** The name of the instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance group. The instances in the group are not
 *  deleted. Note that instance group must not belong to a backend service. Read
 *  Deleting an instance group for more information.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group to delete.
 *
 *  @return GTLRComputeQuery_InstanceGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Returns the specified zonal instance group. Get a list of available zonal
 *  instance groups by making a list() request. For managed instance groups, use
 *  the instanceGroupManagers or regionInstanceGroupManagers methods instead.
 *
 *  Method: compute.instanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsGet : GTLRComputeQuery

/** The name of the instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified zonal instance group. Get a list of available zonal
 *  instance groups by making a list() request. For managed instance groups, use
 *  the instanceGroupManagers or regionInstanceGroupManagers methods instead.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  Method: compute.instanceGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the instance group.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance group in the specified project using the parameters that
 *  are included in the request.
 *
 *  @param object The @c GTLRCompute_InstanceGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    instance group.
 *
 *  @return GTLRComputeQuery_InstanceGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of zonal instance group resources contained within the
 *  specified zone. For managed instance groups, use the instanceGroupManagers
 *  or regionInstanceGroupManagers methods instead.
 *
 *  Method: compute.instanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupList.
 *
 *  Retrieves the list of zonal instance group resources contained within the
 *  specified zone. For managed instance groups, use the instanceGroupManagers
 *  or regionInstanceGroupManagers methods instead.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *
 *  @return GTLRComputeQuery_InstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists the instances in the specified instance group. The orderBy query
 *  parameter is not supported. The filter query parameter is supported, but
 *  only for expressions that use `eq` (equal) or `ne` (not equal) operators.
 *
 *  Method: compute.instanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceGroupsListInstances : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The name of the instance group from which you want to generate a list of
 *  included instances.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group. The orderBy query
 *  parameter is not supported. The filter query parameter is supported, but
 *  only for expressions that use `eq` (equal) or `ne` (not equal) operators.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group from which you want to
 *    generate a list of included instances.
 *
 *  @return GTLRComputeQuery_InstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances. If the group is part of a backend service that
 *  has enabled connection draining, it can take up to 60 seconds after the
 *  connection draining duration before the VM instance is removed or deleted.
 *
 *  Method: compute.instanceGroups.removeInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsRemoveInstances : GTLRComputeQuery

/**
 *  The name of the instance group where the specified instances will be
 *  removed.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes one or more instances from the specified instance group, but does
 *  not delete those instances. If the group is part of a backend service that
 *  has enabled connection draining, it can take up to 60 seconds after the
 *  connection draining duration before the VM instance is removed or deleted.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsRemoveInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the specified
 *    instances will be removed.
 *
 *  @return GTLRComputeQuery_InstanceGroupsRemoveInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsRemoveInstancesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified instance group.
 *
 *  Method: compute.instanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceGroupsSetNamedPorts : GTLRComputeQuery

/** The name of the instance group where the named ports are updated. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified instance group.
 *
 *  @param object The @c GTLRCompute_InstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the instance group is
 *    located.
 *  @param instanceGroup The name of the instance group where the named ports
 *    are updated.
 *
 *  @return GTLRComputeQuery_InstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Adds an access config to an instance's network interface.
 *
 *  Method: compute.instances.addAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAddAccessConfig : GTLRComputeQuery

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface to add to this instance. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an access config to an instance's network interface.
 *
 *  @param object The @c GTLRCompute_AccessConfig to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface to add to this
 *    instance.
 *
 *  @return GTLRComputeQuery_InstancesAddAccessConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_AccessConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Adds existing resource policies to an instance. You can only add one policy
 *  right now which will be applied to this instance for scheduling live
 *  migrations.
 *
 *  Method: compute.instances.addResourcePolicies
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAddResourcePolicies : GTLRComputeQuery

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds existing resource policies to an instance. You can only add one policy
 *  right now which will be applied to this instance for scheduling live
 *  migrations.
 *
 *  @param object The @c GTLRCompute_InstancesAddResourcePoliciesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesAddResourcePolicies
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesAddResourcePoliciesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Retrieves an aggregated list of all of the instances in your project across
 *  all regions and zones. The performance of this method degrades when a filter
 *  is specified on a project that has a very large number of instances. To
 *  prevent failure, Google recommends that you set the `returnPartialSuccess`
 *  parameter to `true`.
 *
 *  Method: compute.instances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_InstanceAggregatedList.
 *
 *  Retrieves an aggregated list of all of the instances in your project across
 *  all regions and zones. The performance of this method degrades when a filter
 *  is specified on a project that has a very large number of instances. To
 *  prevent failure, Google recommends that you set the `returnPartialSuccess`
 *  parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Attaches an existing Disk resource to an instance. You must first create the
 *  disk before you can attach it. It is not possible to create and attach a
 *  disk at the same time. For more information, read Adding a persistent disk
 *  to your instance.
 *
 *  Method: compute.instances.attachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesAttachDisk : GTLRComputeQuery

/**
 *  Whether to force attach the regional disk even if it's currently attached to
 *  another instance. If you try to force attach a zonal disk to an instance,
 *  you will receive an error.
 */
@property(nonatomic, assign) BOOL forceAttach;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attaches an existing Disk resource to an instance. You must first create the
 *  disk before you can attach it. It is not possible to create and attach a
 *  disk at the same time. For more information, read Adding a persistent disk
 *  to your instance.
 *
 *  @param object The @c GTLRCompute_AttachedDisk to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesAttachDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_AttachedDisk *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Creates multiple instances. Count specifies the number of instances to
 *  create. For more information, see About bulk creation of VMs.
 *
 *  Method: compute.instances.bulkInsert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesBulkInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates multiple instances. Count specifies the number of instances to
 *  create. For more information, see About bulk creation of VMs.
 *
 *  @param object The @c GTLRCompute_BulkInsertInstanceResource to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstancesBulkInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BulkInsertInstanceResource *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Deletes the specified Instance resource. For more information, see Deleting
 *  an instance.
 *
 *  Method: compute.instances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDelete : GTLRComputeQuery

/** Name of the instance resource to delete. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Instance resource. For more information, see Deleting
 *  an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to delete.
 *
 *  @return GTLRComputeQuery_InstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Deletes an access config from an instance's network interface.
 *
 *  Method: compute.instances.deleteAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDeleteAccessConfig : GTLRComputeQuery

/** The name of the access config to delete. */
@property(nonatomic, copy, nullable) NSString *accessConfig;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes an access config from an instance's network interface.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param accessConfig The name of the access config to delete.
 *  @param networkInterface The name of the network interface.
 *
 *  @return GTLRComputeQuery_InstancesDeleteAccessConfig
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                    accessConfig:(NSString *)accessConfig
                networkInterface:(NSString *)networkInterface;

@end

/**
 *  Detaches a disk from an instance.
 *
 *  Method: compute.instances.detachDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesDetachDisk : GTLRComputeQuery

/**
 *  The device name of the disk to detach. Make a get() request on the instance
 *  to view currently attached disks and device names.
 */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** Instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detaches a disk from an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name for this request.
 *  @param deviceName The device name of the disk to detach. Make a get()
 *    request on the instance to view currently attached disks and device names.
 *
 *  @return GTLRComputeQuery_InstancesDetachDisk
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Get Instance settings.
 *
 *  Method: compute.instanceSettings.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceSettingsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceSettings.
 *
 *  Get Instance settings.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstanceSettingsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Patch Instance settings
 *
 *  Method: compute.instanceSettings.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceSettingsPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  The zone scoping this request. It should conform to RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patch Instance settings
 *
 *  @param object The @c GTLRCompute_InstanceSettings to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The zone scoping this request. It should conform to
 *    RFC1035.
 *
 *  @return GTLRComputeQuery_InstanceSettingsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceSettings *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Returns the specified Instance resource.
 *
 *  Method: compute.instances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGet : GTLRComputeQuery

/** Name of the instance resource to return. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Instance.
 *
 *  Returns the specified Instance resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to return.
 *
 *  @return GTLRComputeQuery_InstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns effective firewalls applied to an interface of the instance.
 *
 *  Method: compute.instances.getEffectiveFirewalls
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetEffectiveFirewalls : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface to get the effective firewalls. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstancesGetEffectiveFirewallsResponse.
 *
 *  Returns effective firewalls applied to an interface of the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *  @param networkInterface The name of the network interface to get the
 *    effective firewalls.
 *
 *  @return GTLRComputeQuery_InstancesGetEffectiveFirewalls
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                networkInterface:(NSString *)networkInterface;

@end

/**
 *  Returns the specified guest attributes entry.
 *
 *  Method: compute.instances.getGuestAttributes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetGuestAttributes : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Specifies the guest attributes path to be queried. */
@property(nonatomic, copy, nullable) NSString *queryPath;

/** Specifies the key for the guest attributes entry. */
@property(nonatomic, copy, nullable) NSString *variableKey;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_GuestAttributes.
 *
 *  Returns the specified guest attributes entry.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesGetGuestAttributes
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.instances.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Returns the screenshot from the specified instance.
 *
 *  Method: compute.instances.getScreenshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetScreenshot : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Screenshot.
 *
 *  Returns the screenshot from the specified instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesGetScreenshot
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns the last 1 MB of serial port output from the specified instance.
 *
 *  Method: compute.instances.getSerialPortOutput
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetSerialPortOutput : GTLRComputeQuery

/** Name of the instance for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  Specifies which COM or serial port to retrieve data from.
 *
 *  @note If not set, the documented server-side default will be 1 (from the
 *        range 1..4).
 */
@property(nonatomic, assign) NSInteger port;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Specifies the starting byte position of the output to return. To start with
 *  the first byte of output to the specified port, omit this field or set it to
 *  `0`. If the output for that byte position is available, this field matches
 *  the `start` parameter sent with the request. If the amount of serial console
 *  output exceeds the size of the buffer (1 MB), the oldest output is discarded
 *  and is no longer available. If the requested start position refers to
 *  discarded output, the start position is adjusted to the oldest output still
 *  available, and the adjusted start position is returned as the `start`
 *  property value. You can also provide a negative start position, which
 *  translates to the most recent number of bytes written to the serial port.
 *  For example, -3 is interpreted as the most recent 3 bytes written to the
 *  serial console. Note that the negative start is bounded by the retained
 *  buffer size, and the returned serial console output will not exceed the max
 *  buffer size.
 */
@property(nonatomic, assign) long long start;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_SerialPortOutput.
 *
 *  Returns the last 1 MB of serial port output from the specified instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance for this request.
 *
 *  @return GTLRComputeQuery_InstancesGetSerialPortOutput
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns the Shielded Instance Identity of an instance
 *
 *  Method: compute.instances.getShieldedInstanceIdentity
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesGetShieldedInstanceIdentity : GTLRComputeQuery

/** Name or id of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_ShieldedInstanceIdentity.
 *
 *  Returns the Shielded Instance Identity of an instance
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name or id of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesGetShieldedInstanceIdentity
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.instances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Specifies instance template to create the instance. This field is optional.
 *  It can be a full or partial URL. For example, the following are all valid
 *  URLs to an instance template: -
 *  https://www.googleapis.com/compute/v1/projects/project
 *  /global/instanceTemplates/instanceTemplate -
 *  projects/project/global/instanceTemplates/instanceTemplate -
 *  global/instanceTemplates/instanceTemplate
 */
@property(nonatomic, copy, nullable) NSString *sourceInstanceTemplate;

/**
 *  Specifies the machine image to use to create the instance. This field is
 *  optional. It can be a full or partial URL. For example, the following are
 *  all valid URLs to a machine image: -
 *  https://www.googleapis.com/compute/v1/projects/project/global/global
 *  /machineImages/machineImage -
 *  projects/project/global/global/machineImages/machineImage -
 *  global/machineImages/machineImage
 */
@property(nonatomic, copy, nullable) NSString *sourceMachineImage;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Instance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Instance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  Method: compute.instances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceList.
 *
 *  Retrieves the list of instances contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of resources that refer to the VM instance specified in the
 *  request. For example, if the VM instance is part of a managed or unmanaged
 *  instance group, the referrers list includes the instance group. For more
 *  information, read Viewing referrers to VM instances.
 *
 *  Method: compute.instances.listReferrers
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesListReferrers : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Name of the target instance scoping this request, or '-' if the request
 *  should span over all instances in the container.
 */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstanceListReferrers.
 *
 *  Retrieves a list of resources that refer to the VM instance specified in the
 *  request. For example, if the VM instance is part of a managed or unmanaged
 *  instance group, the referrers list includes the instance group. For more
 *  information, read Viewing referrers to VM instances.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the target instance scoping this request, or '-' if
 *    the request should span over all instances in the container.
 *
 *  @return GTLRComputeQuery_InstancesListReferrers
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Perform a manual maintenance on the instance.
 *
 *  Method: compute.instances.performMaintenance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesPerformMaintenance : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Perform a manual maintenance on the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesPerformMaintenance
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Removes resource policies from an instance.
 *
 *  Method: compute.instances.removeResourcePolicies
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesRemoveResourcePolicies : GTLRComputeQuery

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes resource policies from an instance.
 *
 *  @param object The @c GTLRCompute_InstancesRemoveResourcePoliciesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesRemoveResourcePolicies
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesRemoveResourcePoliciesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Performs a reset on the instance. This is a hard reset. The VM does not do a
 *  graceful shutdown. For more information, see Resetting an instance.
 *
 *  Method: compute.instances.reset
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesReset : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Performs a reset on the instance. This is a hard reset. The VM does not do a
 *  graceful shutdown. For more information, see Resetting an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesReset
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Resumes an instance that was suspended using the instances().suspend method.
 *
 *  Method: compute.instances.resume
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesResume : GTLRComputeQuery

/** Name of the instance resource to resume. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resumes an instance that was suspended using the instances().suspend method.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to resume.
 *
 *  @return GTLRComputeQuery_InstancesResume
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Sends diagnostic interrupt to the instance.
 *
 *  Method: compute.instances.sendDiagnosticInterrupt
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSendDiagnosticInterrupt : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Sends diagnostic interrupt to the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSendDiagnosticInterrupt
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Sets deletion protection on the instance.
 *
 *  Method: compute.instances.setDeletionProtection
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetDeletionProtection : GTLRComputeQuery

/**
 *  Whether the resource should be protected against deletion.
 *
 *  @note If not set, the documented server-side default will be true.
 */
@property(nonatomic, assign) BOOL deletionProtection;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets deletion protection on the instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetDeletionProtection
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  Method: compute.instances.setDiskAutoDelete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetDiskAutoDelete : GTLRComputeQuery

/** Whether to auto-delete the disk when the instance is deleted. */
@property(nonatomic, assign) BOOL autoDelete;

/**
 *  The device name of the disk to modify. Make a get() request on the instance
 *  to view currently attached disks and device names.
 */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the auto-delete flag for a disk attached to an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param autoDelete Whether to auto-delete the disk when the instance is
 *    deleted.
 *  @param deviceName The device name of the disk to modify. Make a get()
 *    request on the instance to view currently attached disks and device names.
 *
 *  @return GTLRComputeQuery_InstancesSetDiskAutoDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance
                      autoDelete:(BOOL)autoDelete
                      deviceName:(NSString *)deviceName;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.instances.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Sets labels on an instance. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.instances.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetLabels : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets labels on an instance. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_InstancesSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the number and/or type of accelerator for a stopped instance to the
 *  values specified in the request.
 *
 *  Method: compute.instances.setMachineResources
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineResources : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the number and/or type of accelerator for a stopped instance to the
 *  values specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineResourcesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMachineResources
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineResourcesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  Method: compute.instances.setMachineType
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMachineType : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the machine type for a stopped instance to the machine type
 *  specified in the request.
 *
 *  @param object The @c GTLRCompute_InstancesSetMachineTypeRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMachineType
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMachineTypeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  Method: compute.instances.setMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMetadata : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata for the specified instance to the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Changes the minimum CPU platform that this instance should use. This method
 *  can only be called on a stopped instance. For more information, read
 *  Specifying a Minimum CPU Platform.
 *
 *  Method: compute.instances.setMinCpuPlatform
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetMinCpuPlatform : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the minimum CPU platform that this instance should use. This method
 *  can only be called on a stopped instance. For more information, read
 *  Specifying a Minimum CPU Platform.
 *
 *  @param object The @c GTLRCompute_InstancesSetMinCpuPlatformRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetMinCpuPlatform
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetMinCpuPlatformRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets name of an instance.
 *
 *  Method: compute.instances.setName
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetName : GTLRComputeQuery

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets name of an instance.
 *
 *  @param object The @c GTLRCompute_InstancesSetNameRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetName
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetNameRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets an instance's scheduling options. You can only call this method on a
 *  stopped instance, that is, a VM instance that is in a `TERMINATED` state.
 *  See Instance Life Cycle for more information on the possible instance
 *  states. For more information about setting scheduling options for a VM, see
 *  Set VM host maintenance policy.
 *
 *  Method: compute.instances.setScheduling
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetScheduling : GTLRComputeQuery

/** Instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets an instance's scheduling options. You can only call this method on a
 *  stopped instance, that is, a VM instance that is in a `TERMINATED` state.
 *  See Instance Life Cycle for more information on the possible instance
 *  states. For more information about setting scheduling options for a VM, see
 *  Set VM host maintenance policy.
 *
 *  @param object The @c GTLRCompute_Scheduling to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Instance name for this request.
 *
 *  @return GTLRComputeQuery_InstancesSetScheduling
 */
+ (instancetype)queryWithObject:(GTLRCompute_Scheduling *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets the Google Cloud Armor security policy for the specified instance. For
 *  more information, see Google Cloud Armor Overview
 *
 *  Method: compute.instances.setSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetSecurityPolicy : GTLRComputeQuery

/**
 *  Name of the Instance resource to which the security policy should be set.
 *  The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Google Cloud Armor security policy for the specified instance. For
 *  more information, see Google Cloud Armor Overview
 *
 *  @param object The @c GTLRCompute_InstancesSetSecurityPolicyRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param instance Name of the Instance resource to which the security policy
 *    should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_InstancesSetSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetSecurityPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets the service account on the instance. For more information, read
 *  Changing the service account and access scopes for an instance.
 *
 *  Method: compute.instances.setServiceAccount
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetServiceAccount : GTLRComputeQuery

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the service account on the instance. For more information, read
 *  Changing the service account and access scopes for an instance.
 *
 *  @param object The @c GTLRCompute_InstancesSetServiceAccountRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @return GTLRComputeQuery_InstancesSetServiceAccount
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesSetServiceAccountRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets the Shielded Instance integrity policy for an instance. You can only
 *  use this method on a running instance. This method supports PATCH semantics
 *  and uses the JSON merge patch format and processing rules.
 *
 *  Method: compute.instances.setShieldedInstanceIntegrityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetShieldedInstanceIntegrityPolicy : GTLRComputeQuery

/** Name or id of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Shielded Instance integrity policy for an instance. You can only
 *  use this method on a running instance. This method supports PATCH semantics
 *  and uses the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_ShieldedInstanceIntegrityPolicy to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name or id of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetShieldedInstanceIntegrityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ShieldedInstanceIntegrityPolicy *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Sets network tags for the specified instance to the data included in the
 *  request.
 *
 *  Method: compute.instances.setTags
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSetTags : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets network tags for the specified instance to the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Tags to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSetTags
 */
+ (instancetype)queryWithObject:(GTLRCompute_Tags *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Simulates a host maintenance event on a VM. For more information, see
 *  Simulate a host maintenance event.
 *
 *  Method: compute.instances.simulateMaintenanceEvent
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSimulateMaintenanceEvent : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Determines whether the customers receive notifications before migration.
 *  Only applicable to SF vms.
 */
@property(nonatomic, assign) BOOL withExtendedNotifications;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Simulates a host maintenance event on a VM. For more information, see
 *  Simulate a host maintenance event.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesSimulateMaintenanceEvent
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  Method: compute.instances.start
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStart : GTLRComputeQuery

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @return GTLRComputeQuery_InstancesStart
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  Method: compute.instances.startWithEncryptionKey
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStartWithEncryptionKey : GTLRComputeQuery

/** Name of the instance resource to start. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts an instance that was stopped using the instances().stop method. For
 *  more information, see Restart an instance.
 *
 *  @param object The @c GTLRCompute_InstancesStartWithEncryptionKeyRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to start.
 *
 *  @return GTLRComputeQuery_InstancesStartWithEncryptionKey
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstancesStartWithEncryptionKeyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur VM
 *  usage charges while they are stopped. However, resources that the VM is
 *  using, such as persistent disks and static IP addresses, will continue to be
 *  charged until they are deleted. For more information, see Stopping an
 *  instance.
 *
 *  Method: compute.instances.stop
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesStop : GTLRComputeQuery

/**
 *  This property is required if the instance has any attached Local SSD disks.
 *  If false, Local SSD data will be preserved when the instance is suspended.
 *  If true, the contents of any attached Local SSD disks will be discarded.
 */
@property(nonatomic, assign) BOOL discardLocalSsd;

/** Name of the instance resource to stop. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops a running instance, shutting it down cleanly, and allows you to
 *  restart the instance at a later time. Stopped instances do not incur VM
 *  usage charges while they are stopped. However, resources that the VM is
 *  using, such as persistent disks and static IP addresses, will continue to be
 *  charged until they are deleted. For more information, see Stopping an
 *  instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to stop.
 *
 *  @return GTLRComputeQuery_InstancesStop
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  This method suspends a running instance, saving its state to persistent
 *  storage, and allows you to resume the instance at a later time. Suspended
 *  instances have no compute costs (cores or RAM), and incur only storage
 *  charges for the saved VM memory and localSSD data. Any charged resources the
 *  virtual machine was using, such as persistent disks and static IP addresses,
 *  will continue to be charged while the instance is suspended. For more
 *  information, see Suspending and resuming an instance.
 *
 *  Method: compute.instances.suspend
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesSuspend : GTLRComputeQuery

/**
 *  This property is required if the instance has any attached Local SSD disks.
 *  If false, Local SSD data will be preserved when the instance is suspended.
 *  If true, the contents of any attached Local SSD disks will be discarded.
 */
@property(nonatomic, assign) BOOL discardLocalSsd;

/** Name of the instance resource to suspend. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  This method suspends a running instance, saving its state to persistent
 *  storage, and allows you to resume the instance at a later time. Suspended
 *  instances have no compute costs (cores or RAM), and incur only storage
 *  charges for the saved VM memory and localSSD data. Any charged resources the
 *  virtual machine was using, such as persistent disks and static IP addresses,
 *  will continue to be charged while the instance is suspended. For more
 *  information, see Suspending and resuming an instance.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to suspend.
 *
 *  @return GTLRComputeQuery_InstancesSuspend
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        instance:(NSString *)instance;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.instances.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstancesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstancesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Updates an instance only if the necessary resources are available. This
 *  method can update only a specific set of instance properties. See Updating a
 *  running instance for a list of updatable instance properties.
 *
 *  Method: compute.instances.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdate : GTLRComputeQuery

/** Name of the instance resource to update. */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  Specifies the action to take when updating an instance even if the updated
 *  properties do not require it. If not specified, then Compute Engine acts
 *  based on the minimum action that the updated properties require.
 *
 *  Likely values:
 *    @arg @c kGTLRComputeMinimalActionInvalid Value "INVALID"
 *    @arg @c kGTLRComputeMinimalActionNoEffect No changes can be made to the
 *        instance. (Value: "NO_EFFECT")
 *    @arg @c kGTLRComputeMinimalActionRefresh The instance will not restart.
 *        (Value: "REFRESH")
 *    @arg @c kGTLRComputeMinimalActionRestart The instance will restart.
 *        (Value: "RESTART")
 */
@property(nonatomic, copy, nullable) NSString *minimalAction;

/**
 *  Specifies the most disruptive action that can be taken on the instance as
 *  part of the update. Compute Engine returns an error if the instance
 *  properties require a more disruptive action as part of the instance update.
 *  Valid options from lowest to highest are NO_EFFECT, REFRESH, and RESTART.
 *
 *  Likely values:
 *    @arg @c kGTLRComputeMostDisruptiveAllowedActionInvalid Value "INVALID"
 *    @arg @c kGTLRComputeMostDisruptiveAllowedActionNoEffect No changes can be
 *        made to the instance. (Value: "NO_EFFECT")
 *    @arg @c kGTLRComputeMostDisruptiveAllowedActionRefresh The instance will
 *        not restart. (Value: "REFRESH")
 *    @arg @c kGTLRComputeMostDisruptiveAllowedActionRestart The instance will
 *        restart. (Value: "RESTART")
 */
@property(nonatomic, copy, nullable) NSString *mostDisruptiveAllowedAction;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an instance only if the necessary resources are available. This
 *  method can update only a specific set of instance properties. See Updating a
 *  running instance for a list of updatable instance properties.
 *
 *  @param object The @c GTLRCompute_Instance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance resource to update.
 *
 *  @return GTLRComputeQuery_InstancesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Instance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Updates the specified access config from an instance's network interface
 *  with the data included in the request. This method supports PATCH semantics
 *  and uses the JSON merge patch format and processing rules.
 *
 *  Method: compute.instances.updateAccessConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdateAccessConfig : GTLRComputeQuery

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface where the access config is attached. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified access config from an instance's network interface
 *  with the data included in the request. This method supports PATCH semantics
 *  and uses the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_AccessConfig to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface where the access
 *    config is attached.
 *
 *  @return GTLRComputeQuery_InstancesUpdateAccessConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_AccessConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Updates the Display config for a VM instance. You can only use this method
 *  on a stopped VM instance. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.instances.updateDisplayDevice
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdateDisplayDevice : GTLRComputeQuery

/** Name of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the Display config for a VM instance. You can only use this method
 *  on a stopped VM instance. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_DisplayDevice to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesUpdateDisplayDevice
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisplayDevice *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Updates an instance's network interface. This method can only update an
 *  interface's alias IP range and attached network. See Modifying alias IP
 *  ranges for an existing instance for instructions on changing alias IP
 *  ranges. See Migrating a VM between networks for instructions on migrating an
 *  interface. This method follows PATCH semantics.
 *
 *  Method: compute.instances.updateNetworkInterface
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdateNetworkInterface : GTLRComputeQuery

/** The instance name for this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** The name of the network interface to update. */
@property(nonatomic, copy, nullable) NSString *networkInterface;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an instance's network interface. This method can only update an
 *  interface's alias IP range and attached network. See Modifying alias IP
 *  ranges for an existing instance for instructions on changing alias IP
 *  ranges. See Migrating a VM between networks for instructions on migrating an
 *  interface. This method follows PATCH semantics.
 *
 *  @param object The @c GTLRCompute_NetworkInterface to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance The instance name for this request.
 *  @param networkInterface The name of the network interface to update.
 *
 *  @return GTLRComputeQuery_InstancesUpdateNetworkInterface
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkInterface *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance
               networkInterface:(NSString *)networkInterface;

@end

/**
 *  Updates the Shielded Instance config for an instance. You can only use this
 *  method on a stopped instance. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules.
 *
 *  Method: compute.instances.updateShieldedInstanceConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstancesUpdateShieldedInstanceConfig : GTLRComputeQuery

/** Name or id of the instance scoping this request. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the Shielded Instance config for an instance. You can only use this
 *  method on a stopped instance. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_ShieldedInstanceConfig to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instance Name or id of the instance scoping this request.
 *
 *  @return GTLRComputeQuery_InstancesUpdateShieldedInstanceConfig
 */
+ (instancetype)queryWithObject:(GTLRCompute_ShieldedInstanceConfig *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       instance:(NSString *)instance;

@end

/**
 *  Retrieves the list of all InstanceTemplates resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.instanceTemplates.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplateAggregatedList.
 *
 *  Retrieves the list of all InstanceTemplates resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified instance template. Deleting an instance template is
 *  permanent and cannot be undone. It is not possible to delete templates that
 *  are already in use by a managed instance group.
 *
 *  Method: compute.instanceTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesDelete : GTLRComputeQuery

/** The name of the instance template to delete. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance template. Deleting an instance template is
 *  permanent and cannot be undone. It is not possible to delete templates that
 *  are already in use by a managed instance group.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template to delete.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Returns the specified instance template.
 *
 *  Method: compute.instanceTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesGet : GTLRComputeQuery

/** The name of the instance template. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplate.
 *
 *  Returns the specified instance template.
 *
 *  @param project Project ID for this request.
 *  @param instanceTemplate The name of the instance template.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.instanceTemplates.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  Method: compute.instanceTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance template in the specified project using the data that is
 *  included in the request. If you are creating a new template to update an
 *  existing instance group, your new instance template must use the same
 *  network or, if applicable, the same subnetwork as the original template.
 *
 *  @param object The @c GTLRCompute_InstanceTemplate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceTemplate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of instance templates that are contained within the
 *  specified project.
 *
 *  Method: compute.instanceTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplateList.
 *
 *  Retrieves a list of instance templates that are contained within the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.instanceTemplates.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstanceTemplatesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.instanceTemplates.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstanceTemplatesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstanceTemplatesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of instantSnapshots. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.instantSnapshots.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstantSnapshotsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_InstantSnapshotAggregatedList.
 *
 *  Retrieves an aggregated list of instantSnapshots. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified InstantSnapshot resource. Keep in mind that deleting a
 *  single instantSnapshot might not necessarily delete all the data on that
 *  instantSnapshot. If any data on the instantSnapshot that is marked for
 *  deletion is needed for subsequent instantSnapshots, the data will be moved
 *  to the next corresponding instantSnapshot. For more information, see
 *  Deleting instantSnapshots.
 *
 *  Method: compute.instantSnapshots.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstantSnapshotsDelete : GTLRComputeQuery

/** Name of the InstantSnapshot resource to delete. */
@property(nonatomic, copy, nullable) NSString *instantSnapshot;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified InstantSnapshot resource. Keep in mind that deleting a
 *  single instantSnapshot might not necessarily delete all the data on that
 *  instantSnapshot. If any data on the instantSnapshot that is marked for
 *  deletion is needed for subsequent instantSnapshots, the data will be moved
 *  to the next corresponding instantSnapshot. For more information, see
 *  Deleting instantSnapshots.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instantSnapshot Name of the InstantSnapshot resource to delete.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                 instantSnapshot:(NSString *)instantSnapshot;

@end

/**
 *  Returns the specified InstantSnapshot resource in the specified zone.
 *
 *  Method: compute.instantSnapshots.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstantSnapshotsGet : GTLRComputeQuery

/** Name of the InstantSnapshot resource to return. */
@property(nonatomic, copy, nullable) NSString *instantSnapshot;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstantSnapshot.
 *
 *  Returns the specified InstantSnapshot resource in the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param instantSnapshot Name of the InstantSnapshot resource to return.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                 instantSnapshot:(NSString *)instantSnapshot;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.instantSnapshots.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstantSnapshotsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates an instant snapshot in the specified zone.
 *
 *  Method: compute.instantSnapshots.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstantSnapshotsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instant snapshot in the specified zone.
 *
 *  @param object The @c GTLRCompute_InstantSnapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstantSnapshot *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of InstantSnapshot resources contained within the
 *  specified zone.
 *
 *  Method: compute.instantSnapshots.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstantSnapshotsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_InstantSnapshotList.
 *
 *  Retrieves the list of InstantSnapshot resources contained within the
 *  specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.instantSnapshots.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstantSnapshotsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on a instantSnapshot in the given zone. To learn more about
 *  labels, read the Labeling Resources documentation.
 *
 *  Method: compute.instantSnapshots.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InstantSnapshotsSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a instantSnapshot in the given zone. To learn more about
 *  labels, read the Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_ZoneSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetLabelsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.instantSnapshots.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InstantSnapshotsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InstantSnapshotsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of interconnect attachments. To prevent
 *  failure, Google recommends that you set the `returnPartialSuccess` parameter
 *  to `true`.
 *
 *  Method: compute.interconnectAttachments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectAttachmentsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_InterconnectAttachmentAggregatedList.
 *
 *  Retrieves an aggregated list of interconnect attachments. To prevent
 *  failure, Google recommends that you set the `returnPartialSuccess` parameter
 *  to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified interconnect attachment.
 *
 *  Method: compute.interconnectAttachments.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsDelete : GTLRComputeQuery

/** Name of the interconnect attachment to delete. */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified interconnect attachment.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param interconnectAttachment Name of the interconnect attachment to delete.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
          interconnectAttachment:(NSString *)interconnectAttachment;

@end

/**
 *  Returns the specified interconnect attachment.
 *
 *  Method: compute.interconnectAttachments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectAttachmentsGet : GTLRComputeQuery

/** Name of the interconnect attachment to return. */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InterconnectAttachment.
 *
 *  Returns the specified interconnect attachment.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param interconnectAttachment Name of the interconnect attachment to return.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
          interconnectAttachment:(NSString *)interconnectAttachment;

@end

/**
 *  Creates an InterconnectAttachment in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.interconnectAttachments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an InterconnectAttachment in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_InterconnectAttachment to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InterconnectAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of interconnect attachments contained within the
 *  specified region.
 *
 *  Method: compute.interconnectAttachments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectAttachmentsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InterconnectAttachmentList.
 *
 *  Retrieves the list of interconnect attachments contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified interconnect attachment with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.interconnectAttachments.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsPatch : GTLRComputeQuery

/** Name of the interconnect attachment to patch. */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified interconnect attachment with the data included in the
 *  request. This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_InterconnectAttachment to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param interconnectAttachment Name of the interconnect attachment to patch.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InterconnectAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region
         interconnectAttachment:(NSString *)interconnectAttachment;

@end

/**
 *  Sets the labels on an InterconnectAttachment. To learn more about labels,
 *  read the Labeling Resources documentation.
 *
 *  Method: compute.interconnectAttachments.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectAttachmentsSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an InterconnectAttachment. To learn more about labels,
 *  read the Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InterconnectAttachmentsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns the details for the specified interconnect location. Gets a list of
 *  available interconnect locations by making a list() request.
 *
 *  Method: compute.interconnectLocations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectLocationsGet : GTLRComputeQuery

/** Name of the interconnect location to return. */
@property(nonatomic, copy, nullable) NSString *interconnectLocation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectLocation.
 *
 *  Returns the details for the specified interconnect location. Gets a list of
 *  available interconnect locations by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param interconnectLocation Name of the interconnect location to return.
 *
 *  @return GTLRComputeQuery_InterconnectLocationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
            interconnectLocation:(NSString *)interconnectLocation;

@end

/**
 *  Retrieves the list of interconnect locations available to the specified
 *  project.
 *
 *  Method: compute.interconnectLocations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectLocationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InterconnectLocationList.
 *
 *  Retrieves the list of interconnect locations available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectLocationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the details for the specified interconnect remote location. Gets a
 *  list of available interconnect remote locations by making a list() request.
 *
 *  Method: compute.interconnectRemoteLocations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectRemoteLocationsGet : GTLRComputeQuery

/** Name of the interconnect remote location to return. */
@property(nonatomic, copy, nullable) NSString *interconnectRemoteLocation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectRemoteLocation.
 *
 *  Returns the details for the specified interconnect remote location. Gets a
 *  list of available interconnect remote locations by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param interconnectRemoteLocation Name of the interconnect remote location
 *    to return.
 *
 *  @return GTLRComputeQuery_InterconnectRemoteLocationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
      interconnectRemoteLocation:(NSString *)interconnectRemoteLocation;

@end

/**
 *  Retrieves the list of interconnect remote locations available to the
 *  specified project.
 *
 *  Method: compute.interconnectRemoteLocations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectRemoteLocationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InterconnectRemoteLocationList.
 *
 *  Retrieves the list of interconnect remote locations available to the
 *  specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectRemoteLocationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Interconnect.
 *
 *  Method: compute.interconnects.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsDelete : GTLRComputeQuery

/** Name of the interconnect to delete. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Interconnect.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect to delete.
 *
 *  @return GTLRComputeQuery_InterconnectsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Returns the specified Interconnect. Get a list of available Interconnects by
 *  making a list() request.
 *
 *  Method: compute.interconnects.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsGet : GTLRComputeQuery

/** Name of the interconnect to return. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Interconnect.
 *
 *  Returns the specified Interconnect. Get a list of available Interconnects by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect to return.
 *
 *  @return GTLRComputeQuery_InterconnectsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Returns the interconnectDiagnostics for the specified Interconnect. In the
 *  event of a global outage, do not use this API to make decisions about where
 *  to redirect your network traffic. Unlike a VLAN attachment, which is
 *  regional, a Cloud Interconnect connection is a global resource. A global
 *  outage can prevent this API from functioning properly.
 *
 *  Method: compute.interconnects.getDiagnostics
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsGetDiagnostics : GTLRComputeQuery

/** Name of the interconnect resource to query. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectsGetDiagnosticsResponse.
 *
 *  Returns the interconnectDiagnostics for the specified Interconnect. In the
 *  event of a global outage, do not use this API to make decisions about where
 *  to redirect your network traffic. Unlike a VLAN attachment, which is
 *  regional, a Cloud Interconnect connection is a global resource. A global
 *  outage can prevent this API from functioning properly.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect resource to query.
 *
 *  @return GTLRComputeQuery_InterconnectsGetDiagnostics
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Returns the interconnectMacsecConfig for the specified Interconnect.
 *
 *  Method: compute.interconnects.getMacsecConfig
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsGetMacsecConfig : GTLRComputeQuery

/** Name of the interconnect resource to query. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_InterconnectsGetMacsecConfigResponse.
 *
 *  Returns the interconnectMacsecConfig for the specified Interconnect.
 *
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect resource to query.
 *
 *  @return GTLRComputeQuery_InterconnectsGetMacsecConfig
 */
+ (instancetype)queryWithProject:(NSString *)project
                    interconnect:(NSString *)interconnect;

@end

/**
 *  Creates an Interconnect in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.interconnects.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an Interconnect in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Interconnect to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Interconnect *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of Interconnects available to the specified project.
 *
 *  Method: compute.interconnects.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_InterconnectsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InterconnectList.
 *
 *  Retrieves the list of Interconnects available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_InterconnectsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Updates the specified Interconnect with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.interconnects.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsPatch : GTLRComputeQuery

/** Name of the interconnect to update. */
@property(nonatomic, copy, nullable) NSString *interconnect;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified Interconnect with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_Interconnect to include in the query.
 *  @param project Project ID for this request.
 *  @param interconnect Name of the interconnect to update.
 *
 *  @return GTLRComputeQuery_InterconnectsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Interconnect *)object
                        project:(NSString *)project
                   interconnect:(NSString *)interconnect;

@end

/**
 *  Sets the labels on an Interconnect. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.interconnects.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_InterconnectsSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on an Interconnect. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_InterconnectsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Return a specified license code. License codes are mirrored across all
 *  projects that have permissions to read the License Code. *Caution* This
 *  resource is intended for use only by third-party partners who are creating
 *  Cloud Marketplace images.
 *
 *  Method: compute.licenseCodes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicenseCodesGet : GTLRComputeQuery

/** Number corresponding to the License code resource to return. */
@property(nonatomic, copy, nullable) NSString *licenseCode;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_LicenseCode.
 *
 *  Return a specified license code. License codes are mirrored across all
 *  projects that have permissions to read the License Code. *Caution* This
 *  resource is intended for use only by third-party partners who are creating
 *  Cloud Marketplace images.
 *
 *  @param project Project ID for this request.
 *  @param licenseCode Number corresponding to the License code resource to
 *    return.
 *
 *  @return GTLRComputeQuery_LicenseCodesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                     licenseCode:(NSString *)licenseCode;

@end

/**
 *  Returns permissions that a caller has on the specified resource. *Caution*
 *  This resource is intended for use only by third-party partners who are
 *  creating Cloud Marketplace images.
 *
 *  Method: compute.licenseCodes.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicenseCodesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource. *Caution*
 *  This resource is intended for use only by third-party partners who are
 *  creating Cloud Marketplace images.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicenseCodesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified license. *Caution* This resource is intended for use
 *  only by third-party partners who are creating Cloud Marketplace images.
 *
 *  Method: compute.licenses.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_LicensesDelete : GTLRComputeQuery

/** Name of the license resource to delete. */
@property(nonatomic, copy, nullable) NSString *license;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified license. *Caution* This resource is intended for use
 *  only by third-party partners who are creating Cloud Marketplace images.
 *
 *  @param project Project ID for this request.
 *  @param license Name of the license resource to delete.
 *
 *  @return GTLRComputeQuery_LicensesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         license:(NSString *)license;

@end

/**
 *  Returns the specified License resource. *Caution* This resource is intended
 *  for use only by third-party partners who are creating Cloud Marketplace
 *  images.
 *
 *  Method: compute.licenses.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesGet : GTLRComputeQuery

/** Name of the License resource to return. */
@property(nonatomic, copy, nullable) NSString *license;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_License.
 *
 *  Returns the specified License resource. *Caution* This resource is intended
 *  for use only by third-party partners who are creating Cloud Marketplace
 *  images.
 *
 *  @param project Project ID for this request.
 *  @param license Name of the License resource to return.
 *
 *  @return GTLRComputeQuery_LicensesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         license:(NSString *)license;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists. *Caution* This resource is intended for use only
 *  by third-party partners who are creating Cloud Marketplace images.
 *
 *  Method: compute.licenses.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists. *Caution* This resource is intended for use only
 *  by third-party partners who are creating Cloud Marketplace images.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicensesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Create a License resource in the specified project. *Caution* This resource
 *  is intended for use only by third-party partners who are creating Cloud
 *  Marketplace images.
 *
 *  Method: compute.licenses.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_LicensesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Create a License resource in the specified project. *Caution* This resource
 *  is intended for use only by third-party partners who are creating Cloud
 *  Marketplace images.
 *
 *  @param object The @c GTLRCompute_License to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_LicensesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_License *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of licenses available in the specified project. This
 *  method does not get any licenses that belong to other projects, including
 *  licenses attached to publicly-available images, like Debian 9. If you want
 *  to get a list of publicly-available licenses, use this method to make a
 *  request to the respective image project, such as debian-cloud or
 *  windows-cloud. *Caution* This resource is intended for use only by
 *  third-party partners who are creating Cloud Marketplace images.
 *
 *  Method: compute.licenses.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_LicensesListResponse.
 *
 *  Retrieves the list of licenses available in the specified project. This
 *  method does not get any licenses that belong to other projects, including
 *  licenses attached to publicly-available images, like Debian 9. If you want
 *  to get a list of publicly-available licenses, use this method to make a
 *  request to the respective image project, such as debian-cloud or
 *  windows-cloud. *Caution* This resource is intended for use only by
 *  third-party partners who are creating Cloud Marketplace images.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_LicensesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy. *Caution* This resource is intended for use only by
 *  third-party partners who are creating Cloud Marketplace images.
 *
 *  Method: compute.licenses.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_LicensesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy. *Caution* This resource is intended for use only by
 *  third-party partners who are creating Cloud Marketplace images.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicensesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource. *Caution*
 *  This resource is intended for use only by third-party partners who are
 *  creating Cloud Marketplace images.
 *
 *  Method: compute.licenses.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_LicensesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource. *Caution*
 *  This resource is intended for use only by third-party partners who are
 *  creating Cloud Marketplace images.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_LicensesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified machine image. Deleting a machine image is permanent
 *  and cannot be undone.
 *
 *  Method: compute.machineImages.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_MachineImagesDelete : GTLRComputeQuery

/** The name of the machine image to delete. */
@property(nonatomic, copy, nullable) NSString *machineImage;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified machine image. Deleting a machine image is permanent
 *  and cannot be undone.
 *
 *  @param project Project ID for this request.
 *  @param machineImage The name of the machine image to delete.
 *
 *  @return GTLRComputeQuery_MachineImagesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    machineImage:(NSString *)machineImage;

@end

/**
 *  Returns the specified machine image.
 *
 *  Method: compute.machineImages.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineImagesGet : GTLRComputeQuery

/** The name of the machine image. */
@property(nonatomic, copy, nullable) NSString *machineImage;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_MachineImage.
 *
 *  Returns the specified machine image.
 *
 *  @param project Project ID for this request.
 *  @param machineImage The name of the machine image.
 *
 *  @return GTLRComputeQuery_MachineImagesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    machineImage:(NSString *)machineImage;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.machineImages.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineImagesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_MachineImagesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates a machine image in the specified project using the data that is
 *  included in the request. If you are creating a new machine image to update
 *  an existing instance, your new machine image should use the same network or,
 *  if applicable, the same subnetwork as the original instance.
 *
 *  Method: compute.machineImages.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_MachineImagesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Required. Source instance that is used to create the machine image from.
 */
@property(nonatomic, copy, nullable) NSString *sourceInstance;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a machine image in the specified project using the data that is
 *  included in the request. If you are creating a new machine image to update
 *  an existing instance, your new machine image should use the same network or,
 *  if applicable, the same subnetwork as the original instance.
 *
 *  @param object The @c GTLRCompute_MachineImage to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_MachineImagesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_MachineImage *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves a list of machine images that are contained within the specified
 *  project.
 *
 *  Method: compute.machineImages.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineImagesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_MachineImageList.
 *
 *  Retrieves a list of machine images that are contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_MachineImagesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.machineImages.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_MachineImagesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_MachineImagesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.machineImages.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineImagesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_MachineImagesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of machine types. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.machineTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_MachineTypeAggregatedList.
 *
 *  Retrieves an aggregated list of machine types. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_MachineTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified machine type.
 *
 *  Method: compute.machineTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesGet : GTLRComputeQuery

/** Name of the machine type to return. */
@property(nonatomic, copy, nullable) NSString *machineType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineType.
 *
 *  Returns the specified machine type.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param machineType Name of the machine type to return.
 *
 *  @return GTLRComputeQuery_MachineTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     machineType:(NSString *)machineType;

@end

/**
 *  Retrieves a list of machine types available to the specified project.
 *
 *  Method: compute.machineTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_MachineTypesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_MachineTypeList.
 *
 *  Retrieves a list of machine types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_MachineTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of all NetworkAttachment resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.networkAttachments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkAttachmentsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NetworkAttachmentAggregatedList.
 *
 *  Retrieves the list of all NetworkAttachment resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified NetworkAttachment in the given scope
 *
 *  Method: compute.networkAttachments.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkAttachmentsDelete : GTLRComputeQuery

/** Name of the NetworkAttachment resource to delete. */
@property(nonatomic, copy, nullable) NSString *networkAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 *  end_interface: MixerMutationRequestBuilder
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified NetworkAttachment in the given scope
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *  @param networkAttachment Name of the NetworkAttachment resource to delete.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
               networkAttachment:(NSString *)networkAttachment;

@end

/**
 *  Returns the specified NetworkAttachment resource in the given scope.
 *
 *  Method: compute.networkAttachments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkAttachmentsGet : GTLRComputeQuery

/** Name of the NetworkAttachment resource to return. */
@property(nonatomic, copy, nullable) NSString *networkAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NetworkAttachment.
 *
 *  Returns the specified NetworkAttachment resource in the given scope.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *  @param networkAttachment Name of the NetworkAttachment resource to return.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
               networkAttachment:(NSString *)networkAttachment;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.networkAttachments.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkAttachmentsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a NetworkAttachment in the specified project in the given scope
 *  using the parameters that are included in the request.
 *
 *  Method: compute.networkAttachments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkAttachmentsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 *  end_interface: MixerMutationRequestBuilder
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a NetworkAttachment in the specified project in the given scope
 *  using the parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_NetworkAttachment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists the NetworkAttachments for a project in the given scope.
 *
 *  Method: compute.networkAttachments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkAttachmentsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkAttachmentList.
 *
 *  Lists the NetworkAttachments for a project in the given scope.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified NetworkAttachment resource with the data included in
 *  the request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.networkAttachments.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkAttachmentsPatch : GTLRComputeQuery

/** Name of the NetworkAttachment resource to patch. */
@property(nonatomic, copy, nullable) NSString *networkAttachment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 *  end_interface: MixerMutationRequestBuilder
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified NetworkAttachment resource with the data included in
 *  the request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_NetworkAttachment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param networkAttachment Name of the NetworkAttachment resource to patch.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region
              networkAttachment:(NSString *)networkAttachment;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.networkAttachments.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkAttachmentsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.networkAttachments.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkAttachmentsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkAttachmentsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves the list of all NetworkEdgeSecurityService resources available to
 *  the specified project. To prevent failure, Google recommends that you set
 *  the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.networkEdgeSecurityServices.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEdgeSecurityServicesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NetworkEdgeSecurityServiceAggregatedList.
 *
 *  Retrieves the list of all NetworkEdgeSecurityService resources available to
 *  the specified project. To prevent failure, Google recommends that you set
 *  the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_NetworkEdgeSecurityServicesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified service.
 *
 *  Method: compute.networkEdgeSecurityServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEdgeSecurityServicesDelete : GTLRComputeQuery

/** Name of the network edge security service to delete. */
@property(nonatomic, copy, nullable) NSString *networkEdgeSecurityService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified service.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param networkEdgeSecurityService Name of the network edge security service
 *    to delete.
 *
 *  @return GTLRComputeQuery_NetworkEdgeSecurityServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
      networkEdgeSecurityService:(NSString *)networkEdgeSecurityService;

@end

/**
 *  Gets a specified NetworkEdgeSecurityService.
 *
 *  Method: compute.networkEdgeSecurityServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEdgeSecurityServicesGet : GTLRComputeQuery

/** Name of the network edge security service to get. */
@property(nonatomic, copy, nullable) NSString *networkEdgeSecurityService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NetworkEdgeSecurityService.
 *
 *  Gets a specified NetworkEdgeSecurityService.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param networkEdgeSecurityService Name of the network edge security service
 *    to get.
 *
 *  @return GTLRComputeQuery_NetworkEdgeSecurityServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
      networkEdgeSecurityService:(NSString *)networkEdgeSecurityService;

@end

/**
 *  Creates a new service in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.networkEdgeSecurityServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEdgeSecurityServicesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new service in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_NetworkEdgeSecurityService to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_NetworkEdgeSecurityServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEdgeSecurityService *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Patches the specified policy with the data included in the request.
 *
 *  Method: compute.networkEdgeSecurityServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEdgeSecurityServicesPatch : GTLRComputeQuery

/** Name of the network edge security service to update. */
@property(nonatomic, copy, nullable) NSString *networkEdgeSecurityService;

@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_NetworkEdgeSecurityService to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param networkEdgeSecurityService Name of the network edge security service
 *    to update.
 *
 *  @return GTLRComputeQuery_NetworkEdgeSecurityServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEdgeSecurityService *)object
                        project:(NSString *)project
                         region:(NSString *)region
     networkEdgeSecurityService:(NSString *)networkEdgeSecurityService;

@end

/**
 *  Retrieves the list of network endpoint groups and sorts them by zone. To
 *  prevent failure, Google recommends that you set the `returnPartialSuccess`
 *  parameter to `true`.
 *
 *  Method: compute.networkEndpointGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupAggregatedList.
 *
 *  Retrieves the list of network endpoint groups and sorts them by zone. To
 *  prevent failure, Google recommends that you set the `returnPartialSuccess`
 *  parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Attach a list of network endpoints to the specified network endpoint group.
 *
 *  Method: compute.networkEndpointGroups.attachNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsAttachNetworkEndpoints : GTLRComputeQuery

/**
 *  The name of the network endpoint group where you are attaching network
 *  endpoints to. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the network endpoint group is located. It should
 *  comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attach a list of network endpoints to the specified network endpoint group.
 *
 *  @param object The @c GTLRCompute_NetworkEndpointGroupsAttachEndpointsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group where you
 *    are attaching network endpoints to. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsAttachNetworkEndpoints
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEndpointGroupsAttachEndpointsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Deletes the specified network endpoint group. The network endpoints in the
 *  NEG and the VM instances they belong to are not terminated when the NEG is
 *  deleted. Note that the NEG cannot be deleted if there are backend services
 *  referencing it.
 *
 *  Method: compute.networkEndpointGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsDelete : GTLRComputeQuery

/**
 *  The name of the network endpoint group to delete. It should comply with
 *  RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the network endpoint group is located. It should
 *  comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network endpoint group. The network endpoints in the
 *  NEG and the VM instances they belong to are not terminated when the NEG is
 *  deleted. Note that the NEG cannot be deleted if there are backend services
 *  referencing it.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group to
 *    delete. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Detach a list of network endpoints from the specified network endpoint
 *  group.
 *
 *  Method: compute.networkEndpointGroups.detachNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsDetachNetworkEndpoints : GTLRComputeQuery

/**
 *  The name of the network endpoint group where you are removing network
 *  endpoints. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where the network endpoint group is located. It should
 *  comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detach a list of network endpoints from the specified network endpoint
 *  group.
 *
 *  @param object The @c GTLRCompute_NetworkEndpointGroupsDetachEndpointsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group where you
 *    are removing network endpoints. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsDetachNetworkEndpoints
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEndpointGroupsDetachEndpointsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Returns the specified network endpoint group.
 *
 *  Method: compute.networkEndpointGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsGet : GTLRComputeQuery

/** The name of the network endpoint group. It should comply with RFC1035. */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone where the network endpoint group is located. It should
 *  comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroup.
 *
 *  Returns the specified network endpoint group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Creates a network endpoint group in the specified project using the
 *  parameters that are included in the request.
 *
 *  Method: compute.networkEndpointGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone where you want to create the network endpoint group. It
 *  should comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network endpoint group in the specified project using the
 *  parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_NetworkEndpointGroup to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where you want to create the
 *    network endpoint group. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEndpointGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of network endpoint groups that are located in the
 *  specified project and zone.
 *
 *  Method: compute.networkEndpointGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the network endpoint group is located. It should
 *  comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupList.
 *
 *  Retrieves the list of network endpoint groups that are located in the
 *  specified project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the network endpoint group is
 *    located. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists the network endpoints in the specified network endpoint group.
 *
 *  Method: compute.networkEndpointGroups.listNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsListNetworkEndpoints : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  The name of the network endpoint group from which you want to generate a
 *  list of included network endpoints. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone where the network endpoint group is located. It should
 *  comply with RFC1035.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupsListNetworkEndpoints.
 *
 *  Lists the network endpoints in the specified network endpoint group.
 *
 *  @param object The @c GTLRCompute_NetworkEndpointGroupsListEndpointsRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group from
 *    which you want to generate a list of included network endpoints. It should
 *    comply with RFC1035.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsListNetworkEndpoints
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEndpointGroupsListEndpointsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.networkEndpointGroups.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkEndpointGroupsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkEndpointGroupsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Inserts an association for the specified firewall policy.
 *
 *  Method: compute.networkFirewallPolicies.addAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesAddAssociation : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Indicates whether or not to replace it if an association of the attachment
 *  already exists. This is false by default, in which case an error will be
 *  returned if an association already exists.
 */
@property(nonatomic, assign) BOOL replaceExistingAssociation;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts an association for the specified firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyAssociation to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesAddAssociation
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyAssociation *)object
                        project:(NSString *)project
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Inserts a rule into a firewall policy.
 *
 *  Method: compute.networkFirewallPolicies.addRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesAddRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  When rule.priority is not specified, auto choose a unused priority between
 *  minPriority and maxPriority>. This field is exclusive with rule.priority.
 */
@property(nonatomic, assign) NSInteger maxPriority;

/**
 *  When rule.priority is not specified, auto choose a unused priority between
 *  minPriority and maxPriority>. This field is exclusive with rule.priority.
 */
@property(nonatomic, assign) NSInteger minPriority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts a rule into a firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesAddRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyRule *)object
                        project:(NSString *)project
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Retrieves an aggregated list of network firewall policies, listing network
 *  firewall policies from all applicable scopes (global and regional) and
 *  grouping the results per scope. To prevent failure, Google recommends that
 *  you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.networkFirewallPolicies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NetworkFirewallPolicyAggregatedList.
 *
 *  Retrieves an aggregated list of network firewall policies, listing network
 *  firewall policies from all applicable scopes (global and regional) and
 *  grouping the results per scope. To prevent failure, Google recommends that
 *  you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Copies rules to the specified firewall policy.
 *
 *  Method: compute.networkFirewallPolicies.cloneRules
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesCloneRules : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** The firewall policy from which to copy rules. */
@property(nonatomic, copy, nullable) NSString *sourceFirewallPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Copies rules to the specified firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesCloneRules
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Deletes the specified policy.
 *
 *  Method: compute.networkFirewallPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesDelete : GTLRComputeQuery

/** Name of the firewall policy to delete. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified policy.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to delete.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Returns the specified network firewall policy.
 *
 *  Method: compute.networkFirewallPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesGet : GTLRComputeQuery

/** Name of the firewall policy to get. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicy.
 *
 *  Returns the specified network firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to get.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Gets an association with the specified name.
 *
 *  Method: compute.networkFirewallPolicies.getAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesGetAssociation : GTLRComputeQuery

/** Name of the firewall policy to which the queried association belongs. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The name of the association to get from the firewall policy. */
@property(nonatomic, copy, nullable) NSString *name;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyAssociation.
 *
 *  Gets an association with the specified name.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to which the queried
 *    association belongs.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesGetAssociation
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.networkFirewallPolicies.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Gets a rule of the specified priority.
 *
 *  Method: compute.networkFirewallPolicies.getRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesGetRule : GTLRComputeQuery

/** Name of the firewall policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to get from the firewall policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyRule.
 *
 *  Gets a rule of the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesGetRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.networkFirewallPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_FirewallPolicy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicy *)object
                        project:(NSString *)project;

@end

/**
 *  Lists all the policies that have been configured for the specified project.
 *
 *  Method: compute.networkFirewallPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyList.
 *
 *  Lists all the policies that have been configured for the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified policy with the data included in the request.
 *
 *  Method: compute.networkFirewallPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesPatch : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_FirewallPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicy *)object
                        project:(NSString *)project
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Patches a rule of the specified priority.
 *
 *  Method: compute.networkFirewallPolicies.patchRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesPatchRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to patch. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches a rule of the specified priority.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesPatchRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyRule *)object
                        project:(NSString *)project
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Removes an association for the specified firewall policy.
 *
 *  Method: compute.networkFirewallPolicies.removeAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesRemoveAssociation : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Name for the attachment that will be removed. */
@property(nonatomic, copy, nullable) NSString *name;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes an association for the specified firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesRemoveAssociation
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Deletes a rule of the specified priority.
 *
 *  Method: compute.networkFirewallPolicies.removeRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesRemoveRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to remove from the firewall policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a rule of the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesRemoveRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.networkFirewallPolicies.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.networkFirewallPolicies.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkFirewallPoliciesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NetworkFirewallPoliciesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns the specified network profile.
 *
 *  Method: compute.networkProfiles.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkProfilesGet : GTLRComputeQuery

/** Name of the network profile to return. */
@property(nonatomic, copy, nullable) NSString *networkProfile;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NetworkProfile.
 *
 *  Returns the specified network profile.
 *
 *  @param project Project ID for this request.
 *  @param networkProfile Name of the network profile to return.
 *
 *  @return GTLRComputeQuery_NetworkProfilesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  networkProfile:(NSString *)networkProfile;

@end

/**
 *  Retrieves a list of network profiles available to the specified project.
 *
 *  Method: compute.networkProfiles.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworkProfilesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkProfilesListResponse.
 *
 *  Retrieves a list of network profiles available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworkProfilesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Adds a peering to the specified network.
 *
 *  Method: compute.networks.addPeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksAddPeering : GTLRComputeQuery

/** Name of the network resource to add peering to. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds a peering to the specified network.
 *
 *  @param object The @c GTLRCompute_NetworksAddPeeringRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource to add peering to.
 *
 *  @return GTLRComputeQuery_NetworksAddPeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksAddPeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Deletes the specified network.
 *
 *  Method: compute.networks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksDelete : GTLRComputeQuery

/** Name of the network to delete. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to delete.
 *
 *  @return GTLRComputeQuery_NetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Returns the specified network.
 *
 *  Method: compute.networks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksGet : GTLRComputeQuery

/** Name of the network to return. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Network.
 *
 *  Returns the specified network.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to return.
 *
 *  @return GTLRComputeQuery_NetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Returns the effective firewalls on a given network.
 *
 *  Method: compute.networks.getEffectiveFirewalls
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksGetEffectiveFirewalls : GTLRComputeQuery

/** Name of the network for this request. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_NetworksGetEffectiveFirewallsResponse.
 *
 *  Returns the effective firewalls on a given network.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network for this request.
 *
 *  @return GTLRComputeQuery_NetworksGetEffectiveFirewalls
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.networks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of networks available to the specified project.
 *
 *  Method: compute.networks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkList.
 *
 *  Retrieves the list of networks available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Lists the peering routes exchanged over peering connection.
 *
 *  Method: compute.networks.listPeeringRoutes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NetworksListPeeringRoutes : GTLRComputeQuery

/**
 *  The direction of the exchanged routes.
 *
 *  Likely values:
 *    @arg @c kGTLRComputeDirectionIncoming For routes exported from peer
 *        network. (Value: "INCOMING")
 *    @arg @c kGTLRComputeDirectionOutgoing For routes exported from local
 *        network. (Value: "OUTGOING")
 */
@property(nonatomic, copy, nullable) NSString *direction;

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/** Name of the network for this request. */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  The response will show routes exchanged over the given peering connection.
 */
@property(nonatomic, copy, nullable) NSString *peeringName;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The region of the request. The response will include all subnet routes,
 *  static routes and dynamic routes in the region.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ExchangedPeeringRoutesList.
 *
 *  Lists the peering routes exchanged over peering connection.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network for this request.
 *
 *  @return GTLRComputeQuery_NetworksListPeeringRoutes
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Patches the specified network with the data included in the request. Only
 *  routingConfig can be modified.
 *
 *  Method: compute.networks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksPatch : GTLRComputeQuery

/** Name of the network to update. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified network with the data included in the request. Only
 *  routingConfig can be modified.
 *
 *  @param object The @c GTLRCompute_Network to include in the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network to update.
 *
 *  @return GTLRComputeQuery_NetworksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Network *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Removes a peering from the specified network.
 *
 *  Method: compute.networks.removePeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksRemovePeering : GTLRComputeQuery

/** Name of the network resource to remove peering from. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes a peering from the specified network.
 *
 *  @param object The @c GTLRCompute_NetworksRemovePeeringRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource to remove peering from.
 *
 *  @return GTLRComputeQuery_NetworksRemovePeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksRemovePeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Switches the network mode from auto subnet mode to custom subnet mode.
 *
 *  Method: compute.networks.switchToCustomMode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksSwitchToCustomMode : GTLRComputeQuery

/** Name of the network to be updated. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Switches the network mode from auto subnet mode to custom subnet mode.
 *
 *  @param project Project ID for this request.
 *  @param network Name of the network to be updated.
 *
 *  @return GTLRComputeQuery_NetworksSwitchToCustomMode
 */
+ (instancetype)queryWithProject:(NSString *)project
                         network:(NSString *)network;

@end

/**
 *  Updates the specified network peering with the data included in the request.
 *  You can only modify the NetworkPeering.export_custom_routes field and the
 *  NetworkPeering.import_custom_routes field.
 *
 *  Method: compute.networks.updatePeering
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NetworksUpdatePeering : GTLRComputeQuery

/** Name of the network resource which the updated peering is belonging to. */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified network peering with the data included in the request.
 *  You can only modify the NetworkPeering.export_custom_routes field and the
 *  NetworkPeering.import_custom_routes field.
 *
 *  @param object The @c GTLRCompute_NetworksUpdatePeeringRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param network Name of the network resource which the updated peering is
 *    belonging to.
 *
 *  @return GTLRComputeQuery_NetworksUpdatePeering
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworksUpdatePeeringRequest *)object
                        project:(NSString *)project
                        network:(NSString *)network;

@end

/**
 *  Adds specified number of nodes to the node group.
 *
 *  Method: compute.nodeGroups.addNodes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsAddNodes : GTLRComputeQuery

/** Name of the NodeGroup resource. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds specified number of nodes to the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsAddNodesRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource.
 *
 *  @return GTLRComputeQuery_NodeGroupsAddNodes
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsAddNodesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes
 *  for more details about each group. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.nodeGroups.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NodeGroupAggregatedList.
 *
 *  Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes
 *  for more details about each group. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified NodeGroup resource.
 *
 *  Method: compute.nodeGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsDelete : GTLRComputeQuery

/** Name of the NodeGroup resource to delete. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified NodeGroup resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource to delete.
 *
 *  @return GTLRComputeQuery_NodeGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Deletes specified nodes from the node group.
 *
 *  Method: compute.nodeGroups.deleteNodes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsDeleteNodes : GTLRComputeQuery

/** Name of the NodeGroup resource whose nodes will be deleted. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes specified nodes from the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsDeleteNodesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource whose nodes will be deleted.
 *
 *  @return GTLRComputeQuery_NodeGroupsDeleteNodes
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsDeleteNodesRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Returns the specified NodeGroup. Get a list of available NodeGroups by
 *  making a list() request. Note: the "nodes" field should not be used. Use
 *  nodeGroups.listNodes instead.
 *
 *  Method: compute.nodeGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsGet : GTLRComputeQuery

/** Name of the node group to return. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeGroup.
 *
 *  Returns the specified NodeGroup. Get a list of available NodeGroups by
 *  making a list() request. Note: the "nodes" field should not be used. Use
 *  nodeGroups.listNodes instead.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the node group to return.
 *
 *  @return GTLRComputeQuery_NodeGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.nodeGroups.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates a NodeGroup resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.nodeGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsInsert : GTLRComputeQuery

/** Initial count of nodes in the node group. */
@property(nonatomic, assign) NSInteger initialNodeCount;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a NodeGroup resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_NodeGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param initialNodeCount Initial count of nodes in the node group.
 *
 *  @return GTLRComputeQuery_NodeGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
               initialNodeCount:(NSInteger)initialNodeCount;

@end

/**
 *  Retrieves a list of node groups available to the specified project. Note:
 *  use nodeGroups.listNodes for more details about each group.
 *
 *  Method: compute.nodeGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeGroupList.
 *
 *  Retrieves a list of node groups available to the specified project. Note:
 *  use nodeGroups.listNodes for more details about each group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists nodes in the node group.
 *
 *  Method: compute.nodeGroups.listNodes
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsListNodes : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/** Name of the NodeGroup resource whose nodes you want to list. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeGroupsListNodes.
 *
 *  Lists nodes in the node group.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource whose nodes you want to
 *    list.
 *
 *  @return GTLRComputeQuery_NodeGroupsListNodes
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Updates the specified node group.
 *
 *  Method: compute.nodeGroups.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsPatch : GTLRComputeQuery

/** Name of the NodeGroup resource to update. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified node group.
 *
 *  @param object The @c GTLRCompute_NodeGroup to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource to update.
 *
 *  @return GTLRComputeQuery_NodeGroupsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroup *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Perform maintenance on a subset of nodes in the node group.
 *
 *  Method: compute.nodeGroups.performMaintenance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsPerformMaintenance : GTLRComputeQuery

/** Name of the node group scoping this request. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Perform maintenance on a subset of nodes in the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsPerformMaintenanceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the node group scoping this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsPerformMaintenance
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsPerformMaintenanceRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.nodeGroups.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Updates the node template of the node group.
 *
 *  Method: compute.nodeGroups.setNodeTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsSetNodeTemplate : GTLRComputeQuery

/** Name of the NodeGroup resource to update. */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the node template of the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsSetNodeTemplateRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource to update.
 *
 *  @return GTLRComputeQuery_NodeGroupsSetNodeTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsSetNodeTemplateRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Simulates maintenance event on specified nodes from the node group.
 *
 *  Method: compute.nodeGroups.simulateMaintenanceEvent
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeGroupsSimulateMaintenanceEvent : GTLRComputeQuery

/**
 *  Name of the NodeGroup resource whose nodes will go under maintenance
 *  simulation.
 */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Simulates maintenance event on specified nodes from the node group.
 *
 *  @param object The @c GTLRCompute_NodeGroupsSimulateMaintenanceEventRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeGroup Name of the NodeGroup resource whose nodes will go under
 *    maintenance simulation.
 *
 *  @return GTLRComputeQuery_NodeGroupsSimulateMaintenanceEvent
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeGroupsSimulateMaintenanceEventRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                      nodeGroup:(NSString *)nodeGroup;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.nodeGroups.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeGroupsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeGroupsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of node templates. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.nodeTemplates.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NodeTemplateAggregatedList.
 *
 *  Retrieves an aggregated list of node templates. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified NodeTemplate resource.
 *
 *  Method: compute.nodeTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeTemplatesDelete : GTLRComputeQuery

/** Name of the NodeTemplate resource to delete. */
@property(nonatomic, copy, nullable) NSString *nodeTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified NodeTemplate resource.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param nodeTemplate Name of the NodeTemplate resource to delete.
 *
 *  @return GTLRComputeQuery_NodeTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                    nodeTemplate:(NSString *)nodeTemplate;

@end

/**
 *  Returns the specified node template.
 *
 *  Method: compute.nodeTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesGet : GTLRComputeQuery

/** Name of the node template to return. */
@property(nonatomic, copy, nullable) NSString *nodeTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NodeTemplate.
 *
 *  Returns the specified node template.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param nodeTemplate Name of the node template to return.
 *
 *  @return GTLRComputeQuery_NodeTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                    nodeTemplate:(NSString *)nodeTemplate;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.nodeTemplates.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a NodeTemplate resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.nodeTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeTemplatesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a NodeTemplate resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_NodeTemplate to include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NodeTemplate *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of node templates available to the specified project.
 *
 *  Method: compute.nodeTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NodeTemplateList.
 *
 *  Retrieves a list of node templates available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.nodeTemplates.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_NodeTemplatesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.nodeTemplates.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTemplatesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_NodeTemplatesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of node types. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.nodeTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTypesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_NodeTypeAggregatedList.
 *
 *  Retrieves an aggregated list of node types. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_NodeTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified node type.
 *
 *  Method: compute.nodeTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTypesGet : GTLRComputeQuery

/** Name of the node type to return. */
@property(nonatomic, copy, nullable) NSString *nodeType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeType.
 *
 *  Returns the specified node type.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param nodeType Name of the node type to return.
 *
 *  @return GTLRComputeQuery_NodeTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        nodeType:(NSString *)nodeType;

@end

/**
 *  Retrieves a list of node types available to the specified project.
 *
 *  Method: compute.nodeTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_NodeTypesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_NodeTypeList.
 *
 *  Retrieves a list of node types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_NodeTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves an aggregated list of packetMirrorings. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.packetMirrorings.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PacketMirroringsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_PacketMirroringAggregatedList.
 *
 *  Retrieves an aggregated list of packetMirrorings. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_PacketMirroringsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified PacketMirroring resource.
 *
 *  Method: compute.packetMirrorings.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PacketMirroringsDelete : GTLRComputeQuery

/** Name of the PacketMirroring resource to delete. */
@property(nonatomic, copy, nullable) NSString *packetMirroring;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified PacketMirroring resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param packetMirroring Name of the PacketMirroring resource to delete.
 *
 *  @return GTLRComputeQuery_PacketMirroringsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                 packetMirroring:(NSString *)packetMirroring;

@end

/**
 *  Returns the specified PacketMirroring resource.
 *
 *  Method: compute.packetMirrorings.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PacketMirroringsGet : GTLRComputeQuery

/** Name of the PacketMirroring resource to return. */
@property(nonatomic, copy, nullable) NSString *packetMirroring;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_PacketMirroring.
 *
 *  Returns the specified PacketMirroring resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param packetMirroring Name of the PacketMirroring resource to return.
 *
 *  @return GTLRComputeQuery_PacketMirroringsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                 packetMirroring:(NSString *)packetMirroring;

@end

/**
 *  Creates a PacketMirroring resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.packetMirrorings.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PacketMirroringsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a PacketMirroring resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_PacketMirroring to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_PacketMirroringsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_PacketMirroring *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of PacketMirroring resources available to the specified
 *  project and region.
 *
 *  Method: compute.packetMirrorings.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PacketMirroringsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_PacketMirroringList.
 *
 *  Retrieves a list of PacketMirroring resources available to the specified
 *  project and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_PacketMirroringsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified PacketMirroring resource with the data included in the
 *  request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.packetMirrorings.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PacketMirroringsPatch : GTLRComputeQuery

/** Name of the PacketMirroring resource to patch. */
@property(nonatomic, copy, nullable) NSString *packetMirroring;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified PacketMirroring resource with the data included in the
 *  request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_PacketMirroring to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param packetMirroring Name of the PacketMirroring resource to patch.
 *
 *  @return GTLRComputeQuery_PacketMirroringsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_PacketMirroring *)object
                        project:(NSString *)project
                         region:(NSString *)region
                packetMirroring:(NSString *)packetMirroring;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.packetMirrorings.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PacketMirroringsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_PacketMirroringsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Disable this project as a shared VPC host project.
 *
 *  Method: compute.projects.disableXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsDisableXpnHost : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Disable this project as a shared VPC host project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsDisableXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Disable a service resource (also known as service project) associated with
 *  this host project.
 *
 *  Method: compute.projects.disableXpnResource
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsDisableXpnResource : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Disable a service resource (also known as service project) associated with
 *  this host project.
 *
 *  @param object The @c GTLRCompute_ProjectsDisableXpnResourceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsDisableXpnResource
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsDisableXpnResourceRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Enable this project as a shared VPC host project.
 *
 *  Method: compute.projects.enableXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsEnableXpnHost : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enable this project as a shared VPC host project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsEnableXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Enable service resource (a.k.a service project) for a host project, so that
 *  subnets in the host project can be used by instances in the service project.
 *
 *  Method: compute.projects.enableXpnResource
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsEnableXpnResource : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enable service resource (a.k.a service project) for a host project, so that
 *  subnets in the host project can be used by instances in the service project.
 *
 *  @param object The @c GTLRCompute_ProjectsEnableXpnResourceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsEnableXpnResource
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsEnableXpnResourceRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Returns the specified Project resource. To decrease latency for this method,
 *  you can optionally omit any unneeded information from the response by using
 *  a field mask. This practice is especially recommended for unused quota
 *  information (the `quotas` field). To exclude one or more fields, set your
 *  request's `fields` query parameter to only include the fields you need. For
 *  example, to only include the `id` and `selfLink` fields, add the query
 *  parameter `?fields=id,selfLink` to your request.
 *
 *  Method: compute.projects.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ProjectsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Returns the specified Project resource. To decrease latency for this method,
 *  you can optionally omit any unneeded information from the response by using
 *  a field mask. This practice is especially recommended for unused quota
 *  information (the `quotas` field). To exclude one or more fields, set your
 *  request's `fields` query parameter to only include the fields you need. For
 *  example, to only include the `id` and `selfLink` fields, add the query
 *  parameter `?fields=id,selfLink` to your request.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsGet
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Gets the shared VPC host project that this project links to. May be empty if
 *  no link exists.
 *
 *  Method: compute.projects.getXpnHost
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsGetXpnHost : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_Project.
 *
 *  Gets the shared VPC host project that this project links to. May be empty if
 *  no link exists.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsGetXpnHost
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Gets service resources (a.k.a service project) associated with this host
 *  project.
 *
 *  Method: compute.projects.getXpnResources
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsGetXpnResources : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ProjectsGetXpnResources.
 *
 *  Gets service resources (a.k.a service project) associated with this host
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsGetXpnResources
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Lists all shared VPC host projects visible to the user in an organization.
 *
 *  Method: compute.projects.listXpnHosts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsListXpnHosts : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_XpnHostList.
 *
 *  Lists all shared VPC host projects visible to the user in an organization.
 *
 *  @param object The @c GTLRCompute_ProjectsListXpnHostsRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsListXpnHosts
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsListXpnHostsRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves a persistent disk from one zone to another.
 *
 *  Method: compute.projects.moveDisk
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsMoveDisk : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves a persistent disk from one zone to another.
 *
 *  @param object The @c GTLRCompute_DiskMoveRequest to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsMoveDisk
 */
+ (instancetype)queryWithObject:(GTLRCompute_DiskMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Moves an instance and its attached persistent disks from one zone to
 *  another. *Note*: Moving VMs or disks by using this method might cause
 *  unexpected behavior. For more information, see the [known
 *  issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
 *  [Deprecated] This method is deprecated. See [moving instance across
 *  zones](/compute/docs/instances/moving-instance-across-zones) instead.
 *
 *  Method: compute.projects.moveInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
GTLR_DEPRECATED
@interface GTLRComputeQuery_ProjectsMoveInstance : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Moves an instance and its attached persistent disks from one zone to
 *  another. *Note*: Moving VMs or disks by using this method might cause
 *  unexpected behavior. For more information, see the [known
 *  issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
 *  [Deprecated] This method is deprecated. See [moving instance across
 *  zones](/compute/docs/instances/moving-instance-across-zones) instead.
 *
 *  @param object The @c GTLRCompute_InstanceMoveRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsMoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceMoveRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Sets the Cloud Armor tier of the project. To set ENTERPRISE or above the
 *  billing account of the project must be subscribed to Cloud Armor Enterprise.
 *  See Subscribing to Cloud Armor Enterprise for more information.
 *
 *  Method: compute.projects.setCloudArmorTier
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetCloudArmorTier : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Cloud Armor tier of the project. To set ENTERPRISE or above the
 *  billing account of the project must be subscribed to Cloud Armor Enterprise.
 *  See Subscribing to Cloud Armor Enterprise for more information.
 *
 *  @param object The @c GTLRCompute_ProjectsSetCloudArmorTierRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetCloudArmorTier
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsSetCloudArmorTierRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  Method: compute.projects.setCommonInstanceMetadata
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetCommonInstanceMetadata : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets metadata common to all instances within the specified project using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_Metadata to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetCommonInstanceMetadata
 */
+ (instancetype)queryWithObject:(GTLRCompute_Metadata *)object
                        project:(NSString *)project;

@end

/**
 *  Sets the default network tier of the project. The default network tier is
 *  used when an address/forwardingRule/instance is created without specifying
 *  the network tier field.
 *
 *  Method: compute.projects.setDefaultNetworkTier
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ProjectsSetDefaultNetworkTier : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the default network tier of the project. The default network tier is
 *  used when an address/forwardingRule/instance is created without specifying
 *  the network tier field.
 *
 *  @param object The @c GTLRCompute_ProjectsSetDefaultNetworkTierRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetDefaultNetworkTier
 */
+ (instancetype)queryWithObject:(GTLRCompute_ProjectsSetDefaultNetworkTierRequest *)object
                        project:(NSString *)project;

@end

/**
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  Method: compute.projects.setUsageExportBucket
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeDevstorageFullControl
 *    @c kGTLRAuthScopeComputeDevstorageReadOnly
 *    @c kGTLRAuthScopeComputeDevstorageReadWrite
 */
@interface GTLRComputeQuery_ProjectsSetUsageExportBucket : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Enables the usage export feature and sets the usage export bucket where
 *  reports are stored. If you provide an empty request body using this method,
 *  the usage export feature will be disabled.
 *
 *  @param object The @c GTLRCompute_UsageExportLocation to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ProjectsSetUsageExportBucket
 */
+ (instancetype)queryWithObject:(GTLRCompute_UsageExportLocation *)object
                        project:(NSString *)project;

@end

/**
 *  Announces the specified PublicAdvertisedPrefix
 *
 *  Method: compute.publicAdvertisedPrefixes.announce
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesAnnounce : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the public advertised prefix. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *publicAdvertisedPrefix;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Announces the specified PublicAdvertisedPrefix
 *
 *  @param project Project ID for this request.
 *  @param publicAdvertisedPrefix The name of the public advertised prefix. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesAnnounce
 */
+ (instancetype)queryWithProject:(NSString *)project
          publicAdvertisedPrefix:(NSString *)publicAdvertisedPrefix;

@end

/**
 *  Deletes the specified PublicAdvertisedPrefix
 *
 *  Method: compute.publicAdvertisedPrefixes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicAdvertisedPrefix resource to delete. */
@property(nonatomic, copy, nullable) NSString *publicAdvertisedPrefix;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified PublicAdvertisedPrefix
 *
 *  @param project Project ID for this request.
 *  @param publicAdvertisedPrefix Name of the PublicAdvertisedPrefix resource to
 *    delete.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
          publicAdvertisedPrefix:(NSString *)publicAdvertisedPrefix;

@end

/**
 *  Returns the specified PublicAdvertisedPrefix resource.
 *
 *  Method: compute.publicAdvertisedPrefixes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicAdvertisedPrefix resource to return. */
@property(nonatomic, copy, nullable) NSString *publicAdvertisedPrefix;

/**
 *  Fetches a @c GTLRCompute_PublicAdvertisedPrefix.
 *
 *  Returns the specified PublicAdvertisedPrefix resource.
 *
 *  @param project Project ID for this request.
 *  @param publicAdvertisedPrefix Name of the PublicAdvertisedPrefix resource to
 *    return.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
          publicAdvertisedPrefix:(NSString *)publicAdvertisedPrefix;

@end

/**
 *  Creates a PublicAdvertisedPrefix in the specified project using the
 *  parameters that are included in the request.
 *
 *  Method: compute.publicAdvertisedPrefixes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a PublicAdvertisedPrefix in the specified project using the
 *  parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_PublicAdvertisedPrefix to include in the
 *    query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_PublicAdvertisedPrefix *)object
                        project:(NSString *)project;

@end

/**
 *  Lists the PublicAdvertisedPrefixes for a project.
 *
 *  Method: compute.publicAdvertisedPrefixes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_PublicAdvertisedPrefixList.
 *
 *  Lists the PublicAdvertisedPrefixes for a project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  Method: compute.publicAdvertisedPrefixes.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicAdvertisedPrefix resource to patch. */
@property(nonatomic, copy, nullable) NSString *publicAdvertisedPrefix;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  @param object The @c GTLRCompute_PublicAdvertisedPrefix to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param publicAdvertisedPrefix Name of the PublicAdvertisedPrefix resource to
 *    patch.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_PublicAdvertisedPrefix *)object
                        project:(NSString *)project
         publicAdvertisedPrefix:(NSString *)publicAdvertisedPrefix;

@end

/**
 *  Withdraws the specified PublicAdvertisedPrefix
 *
 *  Method: compute.publicAdvertisedPrefixes.withdraw
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicAdvertisedPrefixesWithdraw : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the public advertised prefix. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *publicAdvertisedPrefix;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Withdraws the specified PublicAdvertisedPrefix
 *
 *  @param project Project ID for this request.
 *  @param publicAdvertisedPrefix The name of the public advertised prefix. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_PublicAdvertisedPrefixesWithdraw
 */
+ (instancetype)queryWithProject:(NSString *)project
          publicAdvertisedPrefix:(NSString *)publicAdvertisedPrefix;

@end

/**
 *  Lists all PublicDelegatedPrefix resources owned by the specific project
 *  across all scopes. To prevent failure, Google recommends that you set the
 *  `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.publicDelegatedPrefixes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_PublicDelegatedPrefixAggregatedList.
 *
 *  Lists all PublicDelegatedPrefix resources owned by the specific project
 *  across all scopes. To prevent failure, Google recommends that you set the
 *  `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Announces the specified PublicDelegatedPrefix in the given region.
 *
 *  Method: compute.publicDelegatedPrefixes.announce
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesAnnounce : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the public delegated prefix. It should comply with RFC1035. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/**
 *  The name of the region where the public delegated prefix is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Announces the specified PublicDelegatedPrefix in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region where the public delegated prefix is
 *    located. It should comply with RFC1035.
 *  @param publicDelegatedPrefix The name of the public delegated prefix. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesAnnounce
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
           publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Deletes the specified PublicDelegatedPrefix in the given region.
 *
 *  Method: compute.publicDelegatedPrefixes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicDelegatedPrefix resource to delete. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified PublicDelegatedPrefix in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *  @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to
 *    delete.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
           publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Returns the specified PublicDelegatedPrefix resource in the given region.
 *
 *  Method: compute.publicDelegatedPrefixes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicDelegatedPrefix resource to return. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_PublicDelegatedPrefix.
 *
 *  Returns the specified PublicDelegatedPrefix resource in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *  @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to
 *    return.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
           publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Creates a PublicDelegatedPrefix in the specified project in the given region
 *  using the parameters that are included in the request.
 *
 *  Method: compute.publicDelegatedPrefixes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a PublicDelegatedPrefix in the specified project in the given region
 *  using the parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_PublicDelegatedPrefix to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_PublicDelegatedPrefix *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists the PublicDelegatedPrefixes for a project in the given region.
 *
 *  Method: compute.publicDelegatedPrefixes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_PublicDelegatedPrefixList.
 *
 *  Lists the PublicDelegatedPrefixes for a project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified PublicDelegatedPrefix resource with the data included
 *  in the request. This method supports PATCH semantics and uses JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.publicDelegatedPrefixes.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the PublicDelegatedPrefix resource to patch. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified PublicDelegatedPrefix resource with the data included
 *  in the request. This method supports PATCH semantics and uses JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_PublicDelegatedPrefix to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param publicDelegatedPrefix Name of the PublicDelegatedPrefix resource to
 *    patch.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_PublicDelegatedPrefix *)object
                        project:(NSString *)project
                         region:(NSString *)region
          publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Withdraws the specified PublicDelegatedPrefix in the given region.
 *
 *  Method: compute.publicDelegatedPrefixes.withdraw
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_PublicDelegatedPrefixesWithdraw : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the public delegated prefix. It should comply with RFC1035. */
@property(nonatomic, copy, nullable) NSString *publicDelegatedPrefix;

/**
 *  The name of the region where the public delegated prefix is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Withdraws the specified PublicDelegatedPrefix in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region where the public delegated prefix is
 *    located. It should comply with RFC1035.
 *  @param publicDelegatedPrefix The name of the public delegated prefix. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_PublicDelegatedPrefixesWithdraw
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
           publicDelegatedPrefix:(NSString *)publicDelegatedPrefix;

@end

/**
 *  Deletes the specified autoscaler.
 *
 *  Method: compute.regionAutoscalers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersDelete : GTLRComputeQuery

/** Name of the autoscaler to delete. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param autoscaler Name of the autoscaler to delete.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Returns the specified autoscaler.
 *
 *  Method: compute.regionAutoscalers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionAutoscalersGet : GTLRComputeQuery

/** Name of the autoscaler to return. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Autoscaler.
 *
 *  Returns the specified autoscaler.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param autoscaler Name of the autoscaler to return.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      autoscaler:(NSString *)autoscaler;

@end

/**
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.regionAutoscalers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of autoscalers contained within the specified region.
 *
 *  Method: compute.regionAutoscalers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionAutoscalersList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionAutoscalerList.
 *
 *  Retrieves a list of autoscalers contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  Method: compute.regionAutoscalers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersPatch : GTLRComputeQuery

/** Name of the autoscaler to patch. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request. This method supports PATCH semantics and uses the JSON merge
 *  patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.regionAutoscalers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionAutoscalersUpdate : GTLRComputeQuery

/** Name of the autoscaler to update. */
@property(nonatomic, copy, nullable) NSString *autoscaler;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates an autoscaler in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Autoscaler to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionAutoscalersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Autoscaler *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Deletes the specified regional BackendService resource.
 *
 *  Method: compute.regionBackendServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesDelete : GTLRComputeQuery

/** Name of the BackendService resource to delete. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified regional BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to delete.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  backendService:(NSString *)backendService;

@end

/**
 *  Returns the specified regional BackendService resource.
 *
 *  Method: compute.regionBackendServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGet : GTLRComputeQuery

/** Name of the BackendService resource to return. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendService.
 *
 *  Returns the specified regional BackendService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to return.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  backendService:(NSString *)backendService;

@end

/**
 *  Gets the most recent health check results for this regional BackendService.
 *
 *  Method: compute.regionBackendServices.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGetHealth : GTLRComputeQuery

/** Name of the BackendService resource for which to get health. */
@property(nonatomic, copy, nullable) NSString *backendService;

@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_BackendServiceGroupHealth.
 *
 *  Gets the most recent health check results for this regional BackendService.
 *
 *  @param object The @c GTLRCompute_ResourceGroupReference to include in the
 *    query.
 *  @param project NSString
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource for which to get
 *    health.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourceGroupReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.regionBackendServices.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a regional BackendService resource in the specified project using
 *  the data included in the request. For more information, see Backend services
 *  overview.
 *
 *  Method: compute.regionBackendServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a regional BackendService resource in the specified project using
 *  the data included in the request. For more information, see Backend services
 *  overview.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of regional BackendService resources available to the
 *  specified project in the given region.
 *
 *  Method: compute.regionBackendServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_BackendServiceList.
 *
 *  Retrieves the list of regional BackendService resources available to the
 *  specified project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves a list of all usable backend services in the specified project in
 *  the given region.
 *
 *  Method: compute.regionBackendServices.listUsable
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesListUsable : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the region scoping this request. It must be a string that meets the
 *  requirements in RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_BackendServiceListUsable.
 *
 *  Retrieves a list of all usable backend services in the specified project in
 *  the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request. It must be a string
 *    that meets the requirements in RFC1035.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesListUsable
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. For more information, see Understanding backend
 *  services This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.regionBackendServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesPatch : GTLRComputeQuery

/** Name of the BackendService resource to patch. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. For more information, see Understanding backend
 *  services This method supports PATCH semantics and uses the JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to patch.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.regionBackendServices.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Sets the Google Cloud Armor security policy for the specified backend
 *  service. For more information, see Google Cloud Armor Overview
 *
 *  Method: compute.regionBackendServices.setSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesSetSecurityPolicy : GTLRComputeQuery

/**
 *  Name of the BackendService resource to which the security policy should be
 *  set. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Google Cloud Armor security policy for the specified backend
 *  service. For more information, see Google Cloud Armor Overview
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to which the
 *    security policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesSetSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.regionBackendServices.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionBackendServicesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. For more information, see Backend services overview
 *  .
 *
 *  Method: compute.regionBackendServices.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionBackendServicesUpdate : GTLRComputeQuery

/** Name of the BackendService resource to update. */
@property(nonatomic, copy, nullable) NSString *backendService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional BackendService resource with the data
 *  included in the request. For more information, see Backend services overview
 *  .
 *
 *  @param object The @c GTLRCompute_BackendService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param backendService Name of the BackendService resource to update.
 *
 *  @return GTLRComputeQuery_RegionBackendServicesUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_BackendService *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 backendService:(NSString *)backendService;

@end

/**
 *  Retrieves an aggregated list of commitments by region. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  Method: compute.regionCommitments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_CommitmentAggregatedList.
 *
 *  Retrieves an aggregated list of commitments by region. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified commitment resource.
 *
 *  Method: compute.regionCommitments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsGet : GTLRComputeQuery

/** Name of the commitment to return. */
@property(nonatomic, copy, nullable) NSString *commitment;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Commitment.
 *
 *  Returns the specified commitment resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param commitment Name of the commitment to return.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      commitment:(NSString *)commitment;

@end

/**
 *  Creates a commitment in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.regionCommitments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionCommitmentsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a commitment in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Commitment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Commitment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of commitments contained within the specified region.
 *
 *  Method: compute.regionCommitments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionCommitmentsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_CommitmentList.
 *
 *  Retrieves a list of commitments contained within the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified commitment with the data included in the request.
 *  Update is performed only on selected fields included as part of update-mask.
 *  Only the following fields can be modified: auto_renew.
 *
 *  Method: compute.regionCommitments.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionCommitmentsUpdate : GTLRComputeQuery

/** Name of the commitment for which auto renew is being updated. */
@property(nonatomic, copy, nullable) NSString *commitment;

@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified commitment with the data included in the request.
 *  Update is performed only on selected fields included as part of update-mask.
 *  Only the following fields can be modified: auto_renew.
 *
 *  @param object The @c GTLRCompute_Commitment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param commitment Name of the commitment for which auto renew is being
 *    updated.
 *
 *  @return GTLRComputeQuery_RegionCommitmentsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Commitment *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     commitment:(NSString *)commitment;

@end

/**
 *  Adds existing resource policies to a regional disk. You can only add one
 *  policy which will be applied to this disk for scheduling snapshot creation.
 *
 *  Method: compute.regionDisks.addResourcePolicies
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksAddResourcePolicies : GTLRComputeQuery

/** The disk name for this request. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds existing resource policies to a regional disk. You can only add one
 *  policy which will be applied to this disk for scheduling snapshot creation.
 *
 *  @param object The @c GTLRCompute_RegionDisksAddResourcePoliciesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param disk The disk name for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksAddResourcePolicies
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionDisksAddResourcePoliciesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Bulk create a set of disks.
 *
 *  Method: compute.regionDisks.bulkInsert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksBulkInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Bulk create a set of disks.
 *
 *  @param object The @c GTLRCompute_BulkInsertDiskResource to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksBulkInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BulkInsertDiskResource *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Creates a snapshot of a specified persistent disk. For regular snapshot
 *  creation, consider using snapshots.insert instead, as that method supports
 *  more features, such as creating snapshots in a project different from the
 *  source disk project.
 *
 *  Method: compute.regionDisks.createSnapshot
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksCreateSnapshot : GTLRComputeQuery

/** Name of the regional persistent disk to snapshot. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot of a specified persistent disk. For regular snapshot
 *  creation, consider using snapshots.insert instead, as that method supports
 *  more features, such as creating snapshots in a project different from the
 *  source disk project.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk to snapshot.
 *
 *  @return GTLRComputeQuery_RegionDisksCreateSnapshot
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Deletes the specified regional persistent disk. Deleting a regional disk
 *  removes all the replicas of its data permanently and is irreversible.
 *  However, deleting a disk does not delete any snapshots previously made from
 *  the disk. You must separately delete snapshots.
 *
 *  Method: compute.regionDisks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksDelete : GTLRComputeQuery

/** Name of the regional persistent disk to delete. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified regional persistent disk. Deleting a regional disk
 *  removes all the replicas of its data permanently and is irreversible.
 *  However, deleting a disk does not delete any snapshots previously made from
 *  the disk. You must separately delete snapshots.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk to delete.
 *
 *  @return GTLRComputeQuery_RegionDisksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                            disk:(NSString *)disk;

@end

/**
 *  Returns a specified regional persistent disk.
 *
 *  Method: compute.regionDisks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksGet : GTLRComputeQuery

/** Name of the regional persistent disk to return. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Disk.
 *
 *  Returns a specified regional persistent disk.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk to return.
 *
 *  @return GTLRComputeQuery_RegionDisksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                            disk:(NSString *)disk;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.regionDisks.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a persistent regional disk in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.regionDisks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Source image to restore onto a disk. This field is optional. */
@property(nonatomic, copy, nullable) NSString *sourceImage;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a persistent regional disk in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of persistent disks contained within the specified
 *  region.
 *
 *  Method: compute.regionDisks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_DiskList.
 *
 *  Retrieves the list of persistent disks contained within the specified
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Removes resource policies from a regional disk.
 *
 *  Method: compute.regionDisks.removeResourcePolicies
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksRemoveResourcePolicies : GTLRComputeQuery

/** The disk name for this request. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes resource policies from a regional disk.
 *
 *  @param object The @c GTLRCompute_RegionDisksRemoveResourcePoliciesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param disk The disk name for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksRemoveResourcePolicies
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionDisksRemoveResourcePoliciesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Resizes the specified regional persistent disk.
 *
 *  Method: compute.regionDisks.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksResize : GTLRComputeQuery

/** Name of the regional persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** The project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the specified regional persistent disk.
 *
 *  @param object The @c GTLRCompute_RegionDisksResizeRequest to include in the
 *    query.
 *  @param project The project ID for this request.
 *  @param region Name of the region for this request.
 *  @param disk Name of the regional persistent disk.
 *
 *  @return GTLRComputeQuery_RegionDisksResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionDisksResizeRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.regionDisks.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on the target regional disk.
 *
 *  Method: compute.regionDisks.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on the target regional disk.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Starts asynchronous replication. Must be invoked on the primary disk.
 *
 *  Method: compute.regionDisks.startAsyncReplication
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksStartAsyncReplication : GTLRComputeQuery

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Starts asynchronous replication. Must be invoked on the primary disk.
 *
 *  @param object The @c GTLRCompute_RegionDisksStartAsyncReplicationRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @return GTLRComputeQuery_RegionDisksStartAsyncReplication
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionDisksStartAsyncReplicationRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Stops asynchronous replication. Can be invoked either on the primary or on
 *  the secondary disk.
 *
 *  Method: compute.regionDisks.stopAsyncReplication
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksStopAsyncReplication : GTLRComputeQuery

/** The name of the persistent disk. */
@property(nonatomic, copy, nullable) NSString *disk;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops asynchronous replication. Can be invoked either on the primary or on
 *  the secondary disk.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param disk The name of the persistent disk.
 *
 *  @return GTLRComputeQuery_RegionDisksStopAsyncReplication
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                            disk:(NSString *)disk;

@end

/**
 *  Stops asynchronous replication for a consistency group of disks. Can be
 *  invoked either in the primary or secondary scope.
 *
 *  Method: compute.regionDisks.stopGroupAsyncReplication
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksStopGroupAsyncReplication : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region for this request. This must be the region of the
 *  primary or secondary disks in the consistency group.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Stops asynchronous replication for a consistency group of disks. Can be
 *  invoked either in the primary or secondary scope.
 *
 *  @param object The @c GTLRCompute_DisksStopGroupAsyncReplicationResource to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request. This must be the
 *    region of the primary or secondary disks in the consistency group.
 *
 *  @return GTLRComputeQuery_RegionDisksStopGroupAsyncReplication
 */
+ (instancetype)queryWithObject:(GTLRCompute_DisksStopGroupAsyncReplicationResource *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.regionDisks.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDisksTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Update the specified disk with the data included in the request. Update is
 *  performed only on selected fields included as part of update-mask. Only the
 *  following fields can be modified: user_license.
 *
 *  Method: compute.regionDisks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionDisksUpdate : GTLRComputeQuery

/** The disk name for this request. */
@property(nonatomic, copy, nullable) NSString *disk;

@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Update the specified disk with the data included in the request. Update is
 *  performed only on selected fields included as part of update-mask. Only the
 *  following fields can be modified: user_license.
 *
 *  @param object The @c GTLRCompute_Disk to include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param disk The disk name for this request.
 *
 *  @return GTLRComputeQuery_RegionDisksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Disk *)object
                        project:(NSString *)project
                         region:(NSString *)region
                           disk:(NSString *)disk;

@end

/**
 *  Returns the specified regional disk type.
 *
 *  Method: compute.regionDiskTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDiskTypesGet : GTLRComputeQuery

/** Name of the disk type to return. */
@property(nonatomic, copy, nullable) NSString *diskType;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_DiskType.
 *
 *  Returns the specified regional disk type.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param diskType Name of the disk type to return.
 *
 *  @return GTLRComputeQuery_RegionDiskTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        diskType:(NSString *)diskType;

@end

/**
 *  Retrieves a list of regional disk types available to the specified project.
 *
 *  Method: compute.regionDiskTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionDiskTypesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionDiskTypeList.
 *
 *  Retrieves a list of regional disk types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionDiskTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified HealthCheck resource.
 *
 *  Method: compute.regionHealthChecks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthChecksDelete : GTLRComputeQuery

/** Name of the HealthCheck resource to delete. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified HealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheck Name of the HealthCheck resource to delete.
 *
 *  @return GTLRComputeQuery_RegionHealthChecksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Deletes the specified regional HealthCheckService.
 *
 *  Method: compute.regionHealthCheckServices.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthCheckServicesDelete : GTLRComputeQuery

/**
 *  Name of the HealthCheckService to delete. The name must be 1-63 characters
 *  long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *healthCheckService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified regional HealthCheckService.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheckService Name of the HealthCheckService to delete. The name
 *    must be 1-63 characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionHealthCheckServicesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
              healthCheckService:(NSString *)healthCheckService;

@end

/**
 *  Returns the specified regional HealthCheckService resource.
 *
 *  Method: compute.regionHealthCheckServices.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionHealthCheckServicesGet : GTLRComputeQuery

/**
 *  Name of the HealthCheckService to update. The name must be 1-63 characters
 *  long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *healthCheckService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_HealthCheckService.
 *
 *  Returns the specified regional HealthCheckService resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheckService Name of the HealthCheckService to update. The name
 *    must be 1-63 characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionHealthCheckServicesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
              healthCheckService:(NSString *)healthCheckService;

@end

/**
 *  Creates a regional HealthCheckService resource in the specified project and
 *  region using the data included in the request.
 *
 *  Method: compute.regionHealthCheckServices.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthCheckServicesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a regional HealthCheckService resource in the specified project and
 *  region using the data included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheckService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionHealthCheckServicesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheckService *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists all the HealthCheckService resources that have been configured for the
 *  specified project in the given region.
 *
 *  Method: compute.regionHealthCheckServices.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionHealthCheckServicesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_HealthCheckServicesList.
 *
 *  Lists all the HealthCheckService resources that have been configured for the
 *  specified project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionHealthCheckServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates the specified regional HealthCheckService resource with the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.regionHealthCheckServices.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthCheckServicesPatch : GTLRComputeQuery

/**
 *  Name of the HealthCheckService to update. The name must be 1-63 characters
 *  long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *healthCheckService;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified regional HealthCheckService resource with the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HealthCheckService to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheckService Name of the HealthCheckService to update. The name
 *    must be 1-63 characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionHealthCheckServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheckService *)object
                        project:(NSString *)project
                         region:(NSString *)region
             healthCheckService:(NSString *)healthCheckService;

@end

/**
 *  Returns the specified HealthCheck resource.
 *
 *  Method: compute.regionHealthChecks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionHealthChecksGet : GTLRComputeQuery

/** Name of the HealthCheck resource to return. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_HealthCheck.
 *
 *  Returns the specified HealthCheck resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheck Name of the HealthCheck resource to return.
 *
 *  @return GTLRComputeQuery_RegionHealthChecksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                     healthCheck:(NSString *)healthCheck;

@end

/**
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.regionHealthChecks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthChecksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionHealthChecksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  Method: compute.regionHealthChecks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionHealthChecksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_HealthCheckList.
 *
 *  Retrieves the list of HealthCheck resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionHealthChecksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  Method: compute.regionHealthChecks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthChecksPatch : GTLRComputeQuery

/** Name of the HealthCheck resource to patch. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request. This method supports PATCH semantics and uses the
 *  JSON merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheck Name of the HealthCheck resource to patch.
 *
 *  @return GTLRComputeQuery_RegionHealthChecksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                         region:(NSString *)region
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.regionHealthChecks.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionHealthChecksUpdate : GTLRComputeQuery

/** Name of the HealthCheck resource to update. */
@property(nonatomic, copy, nullable) NSString *healthCheck;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a HealthCheck resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_HealthCheck to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param healthCheck Name of the HealthCheck resource to update.
 *
 *  @return GTLRComputeQuery_RegionHealthChecksUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_HealthCheck *)object
                        project:(NSString *)project
                         region:(NSString *)region
                    healthCheck:(NSString *)healthCheck;

@end

/**
 *  Flags the specified instances to be immediately removed from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method. If the group
 *  is part of a backend service that has enabled connection draining, it can
 *  take up to 60 seconds after the connection draining duration has elapsed
 *  before the VM instance is removed or deleted. You can specify a maximum of
 *  1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.abandonInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersAbandonInstances : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances to be immediately removed from the managed
 *  instance group. Abandoning an instance does not delete the instance, but it
 *  does remove the instance from any target pools that are applied by the
 *  managed instance group. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you abandon. This operation
 *  is marked as DONE when the action is scheduled even if the instances have
 *  not yet been removed from the group. You must separately verify the status
 *  of the abandoning action with the listmanagedinstances method. If the group
 *  is part of a backend service that has enabled connection draining, it can
 *  take up to 60 seconds after the connection draining duration has elapsed
 *  before the VM instance is removed or deleted. You can specify a maximum of
 *  1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersAbandonInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersAbandonInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Apply updates to selected instances the managed instance group.
 *
 *  Method: compute.regionInstanceGroupManagers.applyUpdatesToInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersApplyUpdatesToInstances : GTLRComputeQuery

/** The name of the managed instance group, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Apply updates to selected instances the managed instance group.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersApplyUpdatesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request, should conform to
 *    RFC1035.
 *  @param instanceGroupManager The name of the managed instance group, should
 *    conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersApplyUpdatesToInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersApplyUpdatesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates instances with per-instance configurations in this regional managed
 *  instance group. Instances are created using the current instance template.
 *  The create instances operation is marked DONE if the createInstances request
 *  is successful. The underlying actions take additional time. You must
 *  separately verify the status of the creating or actions with the
 *  listmanagedinstances method.
 *
 *  Method: compute.regionInstanceGroupManagers.createInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersCreateInstances : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where the managed instance group is located. It
 *  should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates instances with per-instance configurations in this regional managed
 *  instance group. Instances are created using the current instance template.
 *  The create instances operation is marked DONE if the createInstances request
 *  is successful. The underlying actions take additional time. You must
 *  separately verify the status of the creating or actions with the
 *  listmanagedinstances method.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersCreateInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region where the managed instance group is
 *    located. It should conform to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersCreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersCreateInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Deletes the specified managed instance group and all of the instances in
 *  that group.
 *
 *  Method: compute.regionInstanceGroupManagers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDelete : GTLRComputeQuery

/** Name of the managed instance group to delete. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified managed instance group and all of the instances in
 *  that group.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group to delete.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately deleted. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. The
 *  deleteInstances operation is marked DONE if the deleteInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the deleting action with the listmanagedinstances
 *  method. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.deleteInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDeleteInstances : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately deleted. The instances are also removed from any target pools of
 *  which they were a member. This method reduces the targetSize of the managed
 *  instance group by the number of instances that you delete. The
 *  deleteInstances operation is marked DONE if the deleteInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the deleting action with the listmanagedinstances
 *  method. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is removed or deleted.
 *  You can specify a maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersDeleteInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersDeleteInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Deletes selected per-instance configurations for the managed instance group.
 *
 *  Method: compute.regionInstanceGroupManagers.deletePerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersDeletePerInstanceConfigs : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes selected per-instance configurations for the managed instance group.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagerDeleteInstanceConfigReq to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request, should conform to
 *    RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersDeletePerInstanceConfigs
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagerDeleteInstanceConfigReq *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns all of the details about the specified managed instance group.
 *
 *  Method: compute.regionInstanceGroupManagers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersGet : GTLRComputeQuery

/** Name of the managed instance group to return. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceGroupManager.
 *
 *  Returns all of the details about the specified managed instance group.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group to return.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method. A regional managed instance group can
 *  contain up to 2000 instances.
 *
 *  Method: compute.regionInstanceGroupManagers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a managed instance group using the information that you specify in
 *  the request. After the group is created, instances in the group are created
 *  using the specified instance template. This operation is marked as DONE when
 *  the group is created even if the instances in the group have not yet been
 *  created. You must separately verify the status of the individual instances
 *  with the listmanagedinstances method. A regional managed instance group can
 *  contain up to 2000 instances.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of managed instance groups that are contained within the
 *  specified region.
 *
 *  Method: compute.regionInstanceGroupManagers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagerList.
 *
 *  Retrieves the list of managed instance groups that are contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists all errors thrown by actions on instances for a given regional managed
 *  instance group. The filter and orderBy query parameters are not supported.
 *
 *  Method: compute.regionInstanceGroupManagers.listErrors
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersListErrors : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The name of the managed instance group. It must be a string that meets the
 *  requirements in RFC1035, or an unsigned long integer: must match regexp
 *  pattern: (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the region scoping this request. This should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagersListErrorsResponse.
 *
 *  Lists all errors thrown by actions on instances for a given regional managed
 *  instance group. The filter and orderBy query parameters are not supported.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request. This should conform
 *    to RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It must
 *    be a string that meets the requirements in RFC1035, or an unsigned long
 *    integer: must match regexp pattern:
 *    (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersListErrors
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Lists the instances in the managed instance group and instances that are
 *  scheduled to be created. The list includes any current actions that the
 *  group has scheduled for its instances. The orderBy query parameter is not
 *  supported. The `pageToken` query parameter is supported only if the group's
 *  `listManagedInstancesResults` field is set to `PAGINATED`.
 *
 *  Method: compute.regionInstanceGroupManagers.listManagedInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersListManagedInstances : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagersListInstancesResponse.
 *
 *  Lists the instances in the managed instance group and instances that are
 *  scheduled to be created. The list includes any current actions that the
 *  group has scheduled for its instances. The orderBy query parameter is not
 *  supported. The `pageToken` query parameter is supported only if the group's
 *  `listManagedInstancesResults` field is set to `PAGINATED`.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersListManagedInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Lists all of the per-instance configurations defined for the managed
 *  instance group. The orderBy query parameter is not supported.
 *
 *  Method: compute.regionInstanceGroupManagers.listPerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersListPerInstanceConfigs : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupManagersListInstanceConfigsResp.
 *
 *  Lists all of the per-instance configurations defined for the managed
 *  instance group. The orderBy query parameter is not supported.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request, should conform to
 *    RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersListPerInstanceConfigs
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listmanagedinstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules. If you update your group
 *  to specify a new template or instance configuration, it's possible that your
 *  intended specification for each VM in the group is different from the
 *  current state of that VM. To learn how to apply an updated configuration to
 *  the VMs in a MIG, see Updating instances in a MIG.
 *
 *  Method: compute.regionInstanceGroupManagers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersPatch : GTLRComputeQuery

/** The name of the instance group manager. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates a managed instance group using the information that you specify in
 *  the request. This operation is marked as DONE when the group is patched even
 *  if the instances in the group are still in the process of being patched. You
 *  must separately verify the status of the individual instances with the
 *  listmanagedinstances method. This method supports PATCH semantics and uses
 *  the JSON merge patch format and processing rules. If you update your group
 *  to specify a new template or instance configuration, it's possible that your
 *  intended specification for each VM in the group is different from the
 *  current state of that VM. To learn how to apply an updated configuration to
 *  the VMs in a MIG, see Updating instances in a MIG.
 *
 *  @param object The @c GTLRCompute_InstanceGroupManager to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the instance group manager.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceGroupManager *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Inserts or patches per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  Method: compute.regionInstanceGroupManagers.patchPerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersPatchPerInstanceConfigs : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts or patches per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagerPatchInstanceConfigReq to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request, should conform to
 *    RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersPatchPerInstanceConfigs
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagerPatchInstanceConfigReq *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified VM instances in the managed instance group to be
 *  immediately recreated. Each instance is recreated using the group's current
 *  configuration. This operation is marked as DONE when the flag is set even if
 *  the instances have not yet been recreated. You must separately verify the
 *  status of each instance by checking its currentAction field; for more
 *  information, see Checking the status of managed instances. If the group is
 *  part of a backend service that has enabled connection draining, it can take
 *  up to 60 seconds after the connection draining duration has elapsed before
 *  the VM instance is removed or deleted. You can specify a maximum of 1000
 *  instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.recreateInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersRecreateInstances : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified VM instances in the managed instance group to be
 *  immediately recreated. Each instance is recreated using the group's current
 *  configuration. This operation is marked as DONE when the flag is set even if
 *  the instances have not yet been recreated. You must separately verify the
 *  status of each instance by checking its currentAction field; for more
 *  information, see Checking the status of managed instances. If the group is
 *  part of a backend service that has enabled connection draining, it can take
 *  up to 60 seconds after the connection draining duration has elapsed before
 *  the VM instance is removed or deleted. You can specify a maximum of 1000
 *  instances with this method per request.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupManagersRecreateRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersRecreateInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersRecreateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Changes the intended size of the managed instance group. If you increase the
 *  size, the group creates new instances using the current instance template.
 *  If you decrease the size, the group deletes one or more instances. The
 *  resize operation is marked DONE if the resize request is successful. The
 *  underlying actions take additional time. You must separately verify the
 *  status of the creating or deleting actions with the listmanagedinstances
 *  method. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is removed or deleted.
 *
 *  Method: compute.regionInstanceGroupManagers.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersResize : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Number of instances that should exist in this instance group manager. */
@property(nonatomic, assign) NSInteger size;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the intended size of the managed instance group. If you increase the
 *  size, the group creates new instances using the current instance template.
 *  If you decrease the size, the group deletes one or more instances. The
 *  resize operation is marked DONE if the resize request is successful. The
 *  underlying actions take additional time. You must separately verify the
 *  status of the creating or deleting actions with the listmanagedinstances
 *  method. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is removed or deleted.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *  @param size Number of instances that should exist in this instance group
 *    manager.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersResize
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            instanceGroupManager:(NSString *)instanceGroupManager
                            size:(NSInteger)size;

@end

/**
 *  Flags the specified instances in the managed instance group to be resumed.
 *  This method increases the targetSize and decreases the targetSuspendedSize
 *  of the managed instance group by the number of instances that you resume.
 *  The resumeInstances operation is marked DONE if the resumeInstances request
 *  is successful. The underlying actions take additional time. You must
 *  separately verify the status of the RESUMING action with the
 *  listmanagedinstances method. In this request, you can only specify instances
 *  that are suspended. For example, if an instance was previously suspended
 *  using the suspendInstances method, it can be resumed using the
 *  resumeInstances method. If a health check is attached to the managed
 *  instance group, the specified instances will be verified as healthy after
 *  they are resumed. You can specify a maximum of 1000 instances with this
 *  method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.resumeInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersResumeInstances : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be resumed.
 *  This method increases the targetSize and decreases the targetSuspendedSize
 *  of the managed instance group by the number of instances that you resume.
 *  The resumeInstances operation is marked DONE if the resumeInstances request
 *  is successful. The underlying actions take additional time. You must
 *  separately verify the status of the RESUMING action with the
 *  listmanagedinstances method. In this request, you can only specify instances
 *  that are suspended. For example, if an instance was previously suspended
 *  using the suspendInstances method, it can be resumed using the
 *  resumeInstances method. If a health check is attached to the managed
 *  instance group, the specified instances will be verified as healthy after
 *  they are resumed. You can specify a maximum of 1000 instances with this
 *  method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersResumeInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersResumeInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersResumeInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Sets the instance template to use when creating new instances or recreating
 *  instances in this group. Existing instances are not affected.
 *
 *  Method: compute.regionInstanceGroupManagers.setInstanceTemplate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSetInstanceTemplate : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the instance template to use when creating new instances or recreating
 *  instances in this group. Existing instances are not affected.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersSetInstanceTemplate
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSetTemplateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Modifies the target pools to which all new instances in this group are
 *  assigned. Existing instances in the group are not affected.
 *
 *  Method: compute.regionInstanceGroupManagers.setTargetPools
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSetTargetPools : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modifies the target pools to which all new instances in this group are
 *  assigned. Existing instances in the group are not affected.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersSetTargetPools
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSetTargetPoolsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be started.
 *  This method increases the targetSize and decreases the targetStoppedSize of
 *  the managed instance group by the number of instances that you start. The
 *  startInstances operation is marked DONE if the startInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the STARTING action with the listmanagedinstances
 *  method. In this request, you can only specify instances that are stopped.
 *  For example, if an instance was previously stopped using the stopInstances
 *  method, it can be started using the startInstances method. If a health check
 *  is attached to the managed instance group, the specified instances will be
 *  verified as healthy after they are started. You can specify a maximum of
 *  1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.startInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersStartInstances : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be started.
 *  This method increases the targetSize and decreases the targetStoppedSize of
 *  the managed instance group by the number of instances that you start. The
 *  startInstances operation is marked DONE if the startInstances request is
 *  successful. The underlying actions take additional time. You must separately
 *  verify the status of the STARTING action with the listmanagedinstances
 *  method. In this request, you can only specify instances that are stopped.
 *  For example, if an instance was previously stopped using the stopInstances
 *  method, it can be started using the startInstances method. If a health check
 *  is attached to the managed instance group, the specified instances will be
 *  verified as healthy after they are started. You can specify a maximum of
 *  1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersStartInstancesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersStartInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersStartInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately stopped. You can only specify instances that are running in this
 *  request. This method reduces the targetSize and increases the
 *  targetStoppedSize of the managed instance group by the number of instances
 *  that you stop. The stopInstances operation is marked DONE if the
 *  stopInstances request is successful. The underlying actions take additional
 *  time. You must separately verify the status of the STOPPING action with the
 *  listmanagedinstances method. If the standbyPolicy.initialDelaySec field is
 *  set, the group delays stopping the instances until initialDelaySec have
 *  passed from instance.creationTimestamp (that is, when the instance was
 *  created). This delay gives your application time to set itself up and
 *  initialize on the instance. If more than initialDelaySec seconds have passed
 *  since instance.creationTimestamp when this method is called, there will be
 *  zero delay. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is stopped. Stopped
 *  instances can be started using the startInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.stopInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersStopInstances : GTLRComputeQuery

/** The name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately stopped. You can only specify instances that are running in this
 *  request. This method reduces the targetSize and increases the
 *  targetStoppedSize of the managed instance group by the number of instances
 *  that you stop. The stopInstances operation is marked DONE if the
 *  stopInstances request is successful. The underlying actions take additional
 *  time. You must separately verify the status of the STOPPING action with the
 *  listmanagedinstances method. If the standbyPolicy.initialDelaySec field is
 *  set, the group delays stopping the instances until initialDelaySec have
 *  passed from instance.creationTimestamp (that is, when the instance was
 *  created). This delay gives your application time to set itself up and
 *  initialize on the instance. If more than initialDelaySec seconds have passed
 *  since instance.creationTimestamp when this method is called, there will be
 *  zero delay. If the group is part of a backend service that has enabled
 *  connection draining, it can take up to 60 seconds after the connection
 *  draining duration has elapsed before the VM instance is stopped. Stopped
 *  instances can be started using the startInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersStopInstancesRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager The name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersStopInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersStopInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Flags the specified instances in the managed instance group to be
 *  immediately suspended. You can only specify instances that are running in
 *  this request. This method reduces the targetSize and increases the
 *  targetSuspendedSize of the managed instance group by the number of instances
 *  that you suspend. The suspendInstances operation is marked DONE if the
 *  suspendInstances request is successful. The underlying actions take
 *  additional time. You must separately verify the status of the SUSPENDING
 *  action with the listmanagedinstances method. If the
 *  standbyPolicy.initialDelaySec field is set, the group delays suspension of
 *  the instances until initialDelaySec have passed from
 *  instance.creationTimestamp (that is, when the instance was created). This
 *  delay gives your application time to set itself up and initialize on the
 *  instance. If more than initialDelaySec seconds have passed since
 *  instance.creationTimestamp when this method is called, there will be zero
 *  delay. If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is suspended. Suspended
 *  instances can be resumed using the resumeInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  Method: compute.regionInstanceGroupManagers.suspendInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersSuspendInstances : GTLRComputeQuery

/** Name of the managed instance group. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Flags the specified instances in the managed instance group to be
 *  immediately suspended. You can only specify instances that are running in
 *  this request. This method reduces the targetSize and increases the
 *  targetSuspendedSize of the managed instance group by the number of instances
 *  that you suspend. The suspendInstances operation is marked DONE if the
 *  suspendInstances request is successful. The underlying actions take
 *  additional time. You must separately verify the status of the SUSPENDING
 *  action with the listmanagedinstances method. If the
 *  standbyPolicy.initialDelaySec field is set, the group delays suspension of
 *  the instances until initialDelaySec have passed from
 *  instance.creationTimestamp (that is, when the instance was created). This
 *  delay gives your application time to set itself up and initialize on the
 *  instance. If more than initialDelaySec seconds have passed since
 *  instance.creationTimestamp when this method is called, there will be zero
 *  delay. If the group is part of a backend service that has enabled connection
 *  draining, it can take up to 60 seconds after the connection draining
 *  duration has elapsed before the VM instance is suspended. Suspended
 *  instances can be resumed using the resumeInstances method. You can specify a
 *  maximum of 1000 instances with this method per request.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagersSuspendInstancesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroupManager Name of the managed instance group.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersSuspendInstances
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagersSuspendInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Inserts or updates per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  Method: compute.regionInstanceGroupManagers.updatePerInstanceConfigs
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupManagersUpdatePerInstanceConfigs : GTLRComputeQuery

/** The name of the managed instance group. It should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *instanceGroupManager;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request, should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts or updates per-instance configurations for the managed instance
 *  group. perInstanceConfig.name serves as a key used to distinguish whether to
 *  perform insert or patch.
 *
 *  @param object The @c
 *    GTLRCompute_RegionInstanceGroupManagerUpdateInstanceConfigReq to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request, should conform to
 *    RFC1035.
 *  @param instanceGroupManager The name of the managed instance group. It
 *    should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupManagersUpdatePerInstanceConfigs
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupManagerUpdateInstanceConfigReq *)object
                        project:(NSString *)project
                         region:(NSString *)region
           instanceGroupManager:(NSString *)instanceGroupManager;

@end

/**
 *  Returns the specified instance group resource.
 *
 *  Method: compute.regionInstanceGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsGet : GTLRComputeQuery

/** Name of the instance group resource to return. */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceGroup.
 *
 *  Returns the specified instance group resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup Name of the instance group resource to return.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                   instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Retrieves the list of instance group resources contained within the
 *  specified region.
 *
 *  Method: compute.regionInstanceGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupList.
 *
 *  Retrieves the list of instance group resources contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists the instances in the specified instance group and displays information
 *  about the named ports. Depending on the specified options, this method can
 *  list all instances or only the instances that are running. The orderBy query
 *  parameter is not supported.
 *
 *  Method: compute.regionInstanceGroups.listInstances
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceGroupsListInstances : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Name of the regional instance group for which we want to list the instances.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionInstanceGroupsListInstances.
 *
 *  Lists the instances in the specified instance group and displays information
 *  about the named ports. Depending on the specified options, this method can
 *  list all instances or only the instances that are running. The orderBy query
 *  parameter is not supported.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupsListInstancesRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup Name of the regional instance group for which we want
 *    to list the instances.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsListInstances
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupsListInstancesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Sets the named ports for the specified regional instance group.
 *
 *  Method: compute.regionInstanceGroups.setNamedPorts
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceGroupsSetNamedPorts : GTLRComputeQuery

/**
 *  The name of the regional instance group where the named ports are updated.
 */
@property(nonatomic, copy, nullable) NSString *instanceGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the named ports for the specified regional instance group.
 *
 *  @param object The @c GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param instanceGroup The name of the regional instance group where the named
 *    ports are updated.
 *
 *  @return GTLRComputeQuery_RegionInstanceGroupsSetNamedPorts
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionInstanceGroupsSetNamedPortsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                  instanceGroup:(NSString *)instanceGroup;

@end

/**
 *  Creates multiple instances in a given region. Count specifies the number of
 *  instances to create.
 *
 *  Method: compute.regionInstances.bulkInsert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstancesBulkInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates multiple instances in a given region. Count specifies the number of
 *  instances to create.
 *
 *  @param object The @c GTLRCompute_BulkInsertInstanceResource to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionInstancesBulkInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_BulkInsertInstanceResource *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Deletes the specified instance template. Deleting an instance template is
 *  permanent and cannot be undone.
 *
 *  Method: compute.regionInstanceTemplates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceTemplatesDelete : GTLRComputeQuery

/** The name of the instance template to delete. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified instance template. Deleting an instance template is
 *  permanent and cannot be undone.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param instanceTemplate The name of the instance template to delete.
 *
 *  @return GTLRComputeQuery_RegionInstanceTemplatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Returns the specified instance template.
 *
 *  Method: compute.regionInstanceTemplates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceTemplatesGet : GTLRComputeQuery

/** The name of the instance template. */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplate.
 *
 *  Returns the specified instance template.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param instanceTemplate The name of the instance template.
 *
 *  @return GTLRComputeQuery_RegionInstanceTemplatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                instanceTemplate:(NSString *)instanceTemplate;

@end

/**
 *  Creates an instance template in the specified project and region using the
 *  global instance template whose URL is included in the request.
 *
 *  Method: compute.regionInstanceTemplates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstanceTemplatesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instance template in the specified project and region using the
 *  global instance template whose URL is included in the request.
 *
 *  @param object The @c GTLRCompute_InstanceTemplate to include in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceTemplatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceTemplate *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of instance templates that are contained within the
 *  specified project and region.
 *
 *  Method: compute.regionInstanceTemplates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstanceTemplatesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the regions for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InstanceTemplateList.
 *
 *  Retrieves a list of instance templates that are contained within the
 *  specified project and region.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the regions for this request.
 *
 *  @return GTLRComputeQuery_RegionInstanceTemplatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified InstantSnapshot resource. Keep in mind that deleting a
 *  single instantSnapshot might not necessarily delete all the data on that
 *  instantSnapshot. If any data on the instantSnapshot that is marked for
 *  deletion is needed for subsequent instantSnapshots, the data will be moved
 *  to the next corresponding instantSnapshot. For more information, see
 *  Deleting instantSnapshots.
 *
 *  Method: compute.regionInstantSnapshots.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsDelete : GTLRComputeQuery

/** Name of the InstantSnapshot resource to delete. */
@property(nonatomic, copy, nullable) NSString *instantSnapshot;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified InstantSnapshot resource. Keep in mind that deleting a
 *  single instantSnapshot might not necessarily delete all the data on that
 *  instantSnapshot. If any data on the instantSnapshot that is marked for
 *  deletion is needed for subsequent instantSnapshots, the data will be moved
 *  to the next corresponding instantSnapshot. For more information, see
 *  Deleting instantSnapshots.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param instantSnapshot Name of the InstantSnapshot resource to delete.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                 instantSnapshot:(NSString *)instantSnapshot;

@end

/**
 *  Returns the specified InstantSnapshot resource in the specified region.
 *
 *  Method: compute.regionInstantSnapshots.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsGet : GTLRComputeQuery

/** Name of the InstantSnapshot resource to return. */
@property(nonatomic, copy, nullable) NSString *instantSnapshot;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_InstantSnapshot.
 *
 *  Returns the specified InstantSnapshot resource in the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param instantSnapshot Name of the InstantSnapshot resource to return.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                 instantSnapshot:(NSString *)instantSnapshot;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.regionInstantSnapshots.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates an instant snapshot in the specified region.
 *
 *  Method: compute.regionInstantSnapshots.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates an instant snapshot in the specified region.
 *
 *  @param object The @c GTLRCompute_InstantSnapshot to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstantSnapshot *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of InstantSnapshot resources contained within the
 *  specified region.
 *
 *  Method: compute.regionInstantSnapshots.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_InstantSnapshotList.
 *
 *  Retrieves the list of InstantSnapshot resources contained within the
 *  specified region.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.regionInstantSnapshots.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on a instantSnapshot in the given region. To learn more
 *  about labels, read the Labeling Resources documentation.
 *
 *  Method: compute.regionInstantSnapshots.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a instantSnapshot in the given region. To learn more
 *  about labels, read the Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.regionInstantSnapshots.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionInstantSnapshotsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionInstantSnapshotsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Attach a list of network endpoints to the specified network endpoint group.
 *
 *  Method: compute.regionNetworkEndpointGroups.attachNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsAttachNetworkEndpoints : GTLRComputeQuery

/**
 *  The name of the network endpoint group where you are attaching network
 *  endpoints to. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where you want to create the network endpoint group.
 *  It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Attach a list of network endpoints to the specified network endpoint group.
 *
 *  @param object The @c
 *    GTLRCompute_RegionNetworkEndpointGroupsAttachEndpointsRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region where you want to create the network
 *    endpoint group. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group where you
 *    are attaching network endpoints to. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsAttachNetworkEndpoints
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionNetworkEndpointGroupsAttachEndpointsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Deletes the specified network endpoint group. Note that the NEG cannot be
 *  deleted if it is configured as a backend of a backend service.
 *
 *  Method: compute.regionNetworkEndpointGroups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsDelete : GTLRComputeQuery

/**
 *  The name of the network endpoint group to delete. It should comply with
 *  RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where the network endpoint group is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network endpoint group. Note that the NEG cannot be
 *  deleted if it is configured as a backend of a backend service.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group to
 *    delete. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Detach the network endpoint from the specified network endpoint group.
 *
 *  Method: compute.regionNetworkEndpointGroups.detachNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsDetachNetworkEndpoints : GTLRComputeQuery

/**
 *  The name of the network endpoint group you are detaching network endpoints
 *  from. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where the network endpoint group is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 *  end_interface: MixerMutationRequestBuilder
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Detach the network endpoint from the specified network endpoint group.
 *
 *  @param object The @c
 *    GTLRCompute_RegionNetworkEndpointGroupsDetachEndpointsRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region The name of the region where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group you are
 *    detaching network endpoints from. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsDetachNetworkEndpoints
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionNetworkEndpointGroupsDetachEndpointsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
           networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Returns the specified network endpoint group.
 *
 *  Method: compute.regionNetworkEndpointGroups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsGet : GTLRComputeQuery

/** The name of the network endpoint group. It should comply with RFC1035. */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where the network endpoint group is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroup.
 *
 *  Returns the specified network endpoint group.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group. It
 *    should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Creates a network endpoint group in the specified project using the
 *  parameters that are included in the request.
 *
 *  Method: compute.regionNetworkEndpointGroups.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where you want to create the network endpoint group.
 *  It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a network endpoint group in the specified project using the
 *  parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_NetworkEndpointGroup to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region where you want to create the network
 *    endpoint group. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NetworkEndpointGroup *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of regional network endpoint groups available to the
 *  specified project in the given region.
 *
 *  Method: compute.regionNetworkEndpointGroups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where the network endpoint group is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupList.
 *
 *  Retrieves the list of regional network endpoint groups available to the
 *  specified project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region where the network endpoint group is
 *    located. It should comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists the network endpoints in the specified network endpoint group.
 *
 *  Method: compute.regionNetworkEndpointGroups.listNetworkEndpoints
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkEndpointGroupsListNetworkEndpoints : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  The name of the network endpoint group from which you want to generate a
 *  list of included network endpoints. It should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *networkEndpointGroup;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The name of the region where the network endpoint group is located. It
 *  should comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NetworkEndpointGroupsListNetworkEndpoints.
 *
 *  Lists the network endpoints in the specified network endpoint group.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region where the network endpoint group is
 *    located. It should comply with RFC1035.
 *  @param networkEndpointGroup The name of the network endpoint group from
 *    which you want to generate a list of included network endpoints. It should
 *    comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionNetworkEndpointGroupsListNetworkEndpoints
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            networkEndpointGroup:(NSString *)networkEndpointGroup;

@end

/**
 *  Inserts an association for the specified network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.addAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesAddAssociation : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Indicates whether or not to replace it if an association already exists.
 *  This is false by default, in which case an error will be returned if an
 *  association already exists.
 */
@property(nonatomic, assign) BOOL replaceExistingAssociation;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts an association for the specified network firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyAssociation to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesAddAssociation
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyAssociation *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Inserts a rule into a network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.addRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesAddRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/**
 *  When rule.priority is not specified, auto choose a unused priority between
 *  minPriority and maxPriority>. This field is exclusive with rule.priority.
 */
@property(nonatomic, assign) NSInteger maxPriority;

/**
 *  When rule.priority is not specified, auto choose a unused priority between
 *  minPriority and maxPriority>. This field is exclusive with rule.priority.
 */
@property(nonatomic, assign) NSInteger minPriority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts a rule into a network firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesAddRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyRule *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Copies rules to the specified network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.cloneRules
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesCloneRules : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** The firewall policy from which to copy rules. */
@property(nonatomic, copy, nullable) NSString *sourceFirewallPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Copies rules to the specified network firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesCloneRules
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Deletes the specified network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesDelete : GTLRComputeQuery

/** Name of the firewall policy to delete. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified network firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to delete.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Returns the specified network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesGet : GTLRComputeQuery

/** Name of the firewall policy to get. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicy.
 *
 *  Returns the specified network firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to get.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Gets an association with the specified name.
 *
 *  Method: compute.regionNetworkFirewallPolicies.getAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesGetAssociation : GTLRComputeQuery

/** Name of the firewall policy to which the queried association belongs. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The name of the association to get from the firewall policy. */
@property(nonatomic, copy, nullable) NSString *name;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyAssociation.
 *
 *  Gets an association with the specified name.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to which the queried
 *    association belongs.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesGetAssociation
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Returns the effective firewalls on a given network.
 *
 *  Method: compute.regionNetworkFirewallPolicies.getEffectiveFirewalls
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesGetEffectiveFirewalls : GTLRComputeQuery

/** Network reference */
@property(nonatomic, copy, nullable) NSString *network;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c
 *  GTLRCompute_RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse.
 *
 *  Returns the effective firewalls on a given network.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param network Network reference
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesGetEffectiveFirewalls
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                         network:(NSString *)network;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.regionNetworkFirewallPolicies.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Gets a rule of the specified priority.
 *
 *  Method: compute.regionNetworkFirewallPolicies.getRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesGetRule : GTLRComputeQuery

/** Name of the firewall policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to get from the firewall policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyRule.
 *
 *  Gets a rule of the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesGetRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Creates a new network firewall policy in the specified project and region.
 *
 *  Method: compute.regionNetworkFirewallPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new network firewall policy in the specified project and region.
 *
 *  @param object The @c GTLRCompute_FirewallPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists all the network firewall policies that have been configured for the
 *  specified project in the given region.
 *
 *  Method: compute.regionNetworkFirewallPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_FirewallPolicyList.
 *
 *  Lists all the network firewall policies that have been configured for the
 *  specified project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesPatch : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified network firewall policy.
 *
 *  @param object The @c GTLRCompute_FirewallPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Patches a rule of the specified priority.
 *
 *  Method: compute.regionNetworkFirewallPolicies.patchRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesPatchRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to patch. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches a rule of the specified priority.
 *
 *  @param object The @c GTLRCompute_FirewallPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesPatchRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_FirewallPolicyRule *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Removes an association for the specified network firewall policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.removeAssociation
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesRemoveAssociation : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** Name for the association that will be removed. */
@property(nonatomic, copy, nullable) NSString *name;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes an association for the specified network firewall policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesRemoveAssociation
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Deletes a rule of the specified priority.
 *
 *  Method: compute.regionNetworkFirewallPolicies.removeRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesRemoveRule : GTLRComputeQuery

/** Name of the firewall policy to update. */
@property(nonatomic, copy, nullable) NSString *firewallPolicy;

/** The priority of the rule to remove from the firewall policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a rule of the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param firewallPolicy Name of the firewall policy to update.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesRemoveRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  firewallPolicy:(NSString *)firewallPolicy;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.regionNetworkFirewallPolicies.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.regionNetworkFirewallPolicies.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNetworkFirewallPoliciesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionNetworkFirewallPoliciesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified NotificationEndpoint in the given region
 *
 *  Method: compute.regionNotificationEndpoints.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNotificationEndpointsDelete : GTLRComputeQuery

/** Name of the NotificationEndpoint resource to delete. */
@property(nonatomic, copy, nullable) NSString *notificationEndpoint;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified NotificationEndpoint in the given region
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param notificationEndpoint Name of the NotificationEndpoint resource to
 *    delete.
 *
 *  @return GTLRComputeQuery_RegionNotificationEndpointsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            notificationEndpoint:(NSString *)notificationEndpoint;

@end

/**
 *  Returns the specified NotificationEndpoint resource in the given region.
 *
 *  Method: compute.regionNotificationEndpoints.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNotificationEndpointsGet : GTLRComputeQuery

/** Name of the NotificationEndpoint resource to return. */
@property(nonatomic, copy, nullable) NSString *notificationEndpoint;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_NotificationEndpoint.
 *
 *  Returns the specified NotificationEndpoint resource in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param notificationEndpoint Name of the NotificationEndpoint resource to
 *    return.
 *
 *  @return GTLRComputeQuery_RegionNotificationEndpointsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
            notificationEndpoint:(NSString *)notificationEndpoint;

@end

/**
 *  Create a NotificationEndpoint in the specified project in the given region
 *  using the parameters that are included in the request.
 *
 *  Method: compute.regionNotificationEndpoints.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionNotificationEndpointsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Create a NotificationEndpoint in the specified project in the given region
 *  using the parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_NotificationEndpoint to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionNotificationEndpointsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_NotificationEndpoint *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists the NotificationEndpoints for a project in the given region.
 *
 *  Method: compute.regionNotificationEndpoints.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionNotificationEndpointsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_NotificationEndpointList.
 *
 *  Lists the NotificationEndpoints for a project in the given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionNotificationEndpointsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionOperationsDelete : GTLRComputeQuery

/**
 *  Name of the Operations resource to delete, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to delete, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_RegionOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified region-specific Operations resource.
 *
 *  Method: compute.regionOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsGet : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified region-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_RegionOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  Method: compute.regionOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RegionOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Waits for the specified Operation resource to return as `DONE` or for the
 *  request to approach the 2 minute deadline, and retrieves the specified
 *  Operation resource. This method differs from the `GET` method in that it
 *  waits for no more than the default deadline (2 minutes) and then returns the
 *  current state of the operation, which might be `DONE` or still in progress.
 *  This method is called on a best-effort basis. Specifically: - In uncommon
 *  cases, when the server is overloaded, the request might return before the
 *  default deadline is reached, or might return after zero seconds. - If the
 *  default deadline is reached, there is no guarantee that the operation is
 *  actually done when the method returns. Be prepared to retry if the operation
 *  is not `DONE`.
 *
 *  Method: compute.regionOperations.wait
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionOperationsWait : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Waits for the specified Operation resource to return as `DONE` or for the
 *  request to approach the 2 minute deadline, and retrieves the specified
 *  Operation resource. This method differs from the `GET` method in that it
 *  waits for no more than the default deadline (2 minutes) and then returns the
 *  current state of the operation, which might be `DONE` or still in progress.
 *  This method is called on a best-effort basis. Specifically: - In uncommon
 *  cases, when the server is overloaded, the request might return before the
 *  default deadline is reached, or might return after zero seconds. - If the
 *  default deadline is reached, there is no guarantee that the operation is
 *  actually done when the method returns. Be prepared to retry if the operation
 *  is not `DONE`.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_RegionOperationsWait
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       operation:(NSString *)operation;

@end

/**
 *  Inserts a rule into a security policy.
 *
 *  Method: compute.regionSecurityPolicies.addRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesAddRule : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts a rule into a security policy.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesAddRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyRule *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Deletes the specified policy.
 *
 *  Method: compute.regionSecurityPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the security policy to delete. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to delete.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  List all of the ordered rules present in a single specified policy.
 *
 *  Method: compute.regionSecurityPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the security policy to get. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicy.
 *
 *  List all of the ordered rules present in a single specified policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to get.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Gets a rule at the specified priority.
 *
 *  Method: compute.regionSecurityPolicies.getRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesGetRule : GTLRComputeQuery

/** The priority of the rule to get from the security policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the security policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicyRule.
 *
 *  Gets a rule at the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesGetRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.regionSecurityPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_SecurityPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  List all the policies that have been configured for the specified project
 *  and region.
 *
 *  Method: compute.regionSecurityPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicyList.
 *
 *  List all the policies that have been configured for the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified policy with the data included in the request. To clear
 *  fields in the policy, leave the fields empty and specify them in the
 *  updateMask. This cannot be used to be update the rules in the policy. Please
 *  use the per rule methods like addRule, patchRule, and removeRule instead.
 *
 *  Method: compute.regionSecurityPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Indicates fields to be cleared as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified policy with the data included in the request. To clear
 *  fields in the policy, leave the fields empty and specify them in the
 *  updateMask. This cannot be used to be update the rules in the policy. Please
 *  use the per rule methods like addRule, patchRule, and removeRule instead.
 *
 *  @param object The @c GTLRCompute_SecurityPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Patches a rule at the specified priority. To clear fields in the rule, leave
 *  the fields empty and specify them in the updateMask.
 *
 *  Method: compute.regionSecurityPolicies.patchRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesPatchRule : GTLRComputeQuery

/** The priority of the rule to patch. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Indicates fields to be cleared as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches a rule at the specified priority. To clear fields in the rule, leave
 *  the fields empty and specify them in the updateMask.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesPatchRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyRule *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Deletes a rule at the specified priority.
 *
 *  Method: compute.regionSecurityPolicies.removeRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesRemoveRule : GTLRComputeQuery

/** The priority of the rule to remove from the security policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a rule at the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesRemoveRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Sets the labels on a security policy. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.regionSecurityPolicies.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSecurityPoliciesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a security policy. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_RegionSecurityPoliciesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns the specified Region resource. To decrease latency for this method,
 *  you can optionally omit any unneeded information from the response by using
 *  a field mask. This practice is especially recommended for unused quota
 *  information (the `quotas` field). To exclude one or more fields, set your
 *  request's `fields` query parameter to only include the fields you need. For
 *  example, to only include the `id` and `selfLink` fields, add the query
 *  parameter `?fields=id,selfLink` to your request. This method fails if the
 *  quota information is unavailable for the region and if the organization
 *  policy constraint compute.requireBasicQuotaInResponse is enforced. This
 *  constraint, when enforced, disables the fail-open behaviour when quota
 *  information (the `items.quotas` field) is unavailable for the region. It is
 *  recommended to use the default setting for the constraint unless your
 *  application requires the fail-closed behaviour for this method.
 *
 *  Method: compute.regions.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region resource to return. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Fetches a @c GTLRCompute_Region.
 *
 *  Returns the specified Region resource. To decrease latency for this method,
 *  you can optionally omit any unneeded information from the response by using
 *  a field mask. This practice is especially recommended for unused quota
 *  information (the `quotas` field). To exclude one or more fields, set your
 *  request's `fields` query parameter to only include the fields you need. For
 *  example, to only include the `id` and `selfLink` fields, add the query
 *  parameter `?fields=id,selfLink` to your request. This method fails if the
 *  quota information is unavailable for the region and if the organization
 *  policy constraint compute.requireBasicQuotaInResponse is enforced. This
 *  constraint, when enforced, disables the fail-open behaviour when quota
 *  information (the `items.quotas` field) is unavailable for the region. It is
 *  recommended to use the default setting for the constraint unless your
 *  application requires the fail-closed behaviour for this method.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region resource to return.
 *
 *  @return GTLRComputeQuery_RegionsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves the list of region resources available to the specified project.
 *  To decrease latency for this method, you can optionally omit any unneeded
 *  information from the response by using a field mask. This practice is
 *  especially recommended for unused quota information (the `items.quotas`
 *  field). To exclude one or more fields, set your request's `fields` query
 *  parameter to only include the fields you need. For example, to only include
 *  the `id` and `selfLink` fields, add the query parameter
 *  `?fields=id,selfLink` to your request. This method fails if the quota
 *  information is unavailable for the region and if the organization policy
 *  constraint compute.requireBasicQuotaInResponse is enforced. This constraint,
 *  when enforced, disables the fail-open behaviour when quota information (the
 *  `items.quotas` field) is unavailable for the region. It is recommended to
 *  use the default setting for the constraint unless your application requires
 *  the fail-closed behaviour for this method.
 *
 *  Method: compute.regions.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RegionList.
 *
 *  Retrieves the list of region resources available to the specified project.
 *  To decrease latency for this method, you can optionally omit any unneeded
 *  information from the response by using a field mask. This practice is
 *  especially recommended for unused quota information (the `items.quotas`
 *  field). To exclude one or more fields, set your request's `fields` query
 *  parameter to only include the fields you need. For example, to only include
 *  the `id` and `selfLink` fields, add the query parameter
 *  `?fields=id,selfLink` to your request. This method fails if the quota
 *  information is unavailable for the region and if the organization policy
 *  constraint compute.requireBasicQuotaInResponse is enforced. This constraint,
 *  when enforced, disables the fail-open behaviour when quota information (the
 *  `items.quotas` field) is unavailable for the region. It is recommended to
 *  use the default setting for the constraint unless your application requires
 *  the fail-closed behaviour for this method.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RegionsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified SslCertificate resource in the region.
 *
 *  Method: compute.regionSslCertificates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSslCertificatesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the SslCertificate resource to delete. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SslCertificate resource in the region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param sslCertificate Name of the SslCertificate resource to delete.
 *
 *  @return GTLRComputeQuery_RegionSslCertificatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Returns the specified SslCertificate resource in the specified region. Get a
 *  list of available SSL certificates by making a list() request.
 *
 *  Method: compute.regionSslCertificates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSslCertificatesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the SslCertificate resource to return. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_SslCertificate.
 *
 *  Returns the specified SslCertificate resource in the specified region. Get a
 *  list of available SSL certificates by making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param sslCertificate Name of the SslCertificate resource to return.
 *
 *  @return GTLRComputeQuery_RegionSslCertificatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Creates a SslCertificate resource in the specified project and region using
 *  the data included in the request
 *
 *  Method: compute.regionSslCertificates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSslCertificatesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a SslCertificate resource in the specified project and region using
 *  the data included in the request
 *
 *  @param object The @c GTLRCompute_SslCertificate to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSslCertificatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslCertificate *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project in the specified region.
 *
 *  Method: compute.regionSslCertificates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSslCertificatesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SslCertificateList.
 *
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project in the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSslCertificatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified SSL policy. The SSL policy resource can be deleted
 *  only if it is not in use by any TargetHttpsProxy or TargetSslProxy
 *  resources.
 *
 *  Method: compute.regionSslPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSslPoliciesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the SSL policy to delete. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SSL policy. The SSL policy resource can be deleted
 *  only if it is not in use by any TargetHttpsProxy or TargetSslProxy
 *  resources.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param sslPolicy Name of the SSL policy to delete. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionSslPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Lists all of the ordered rules present in a single specified policy.
 *
 *  Method: compute.regionSslPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSslPoliciesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Name of the SSL policy to update. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_SslPolicy.
 *
 *  Lists all of the ordered rules present in a single specified policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param sslPolicy Name of the SSL policy to update. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionSslPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Creates a new policy in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.regionSslPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSslPoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new policy in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_SslPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSslPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists all the SSL policies that have been configured for the specified
 *  project and region.
 *
 *  Method: compute.regionSslPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSslPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesList.
 *
 *  Lists all the SSL policies that have been configured for the specified
 *  project and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSslPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Lists all features that can be specified in the SSL policy when using custom
 *  profile.
 *
 *  Method: compute.regionSslPolicies.listAvailableFeatures
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionSslPoliciesListAvailableFeatures : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesListAvailableFeaturesResponse.
 *
 *  Lists all features that can be specified in the SSL policy when using custom
 *  profile.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionSslPoliciesListAvailableFeatures
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified SSL policy with the data included in the request.
 *
 *  Method: compute.regionSslPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionSslPoliciesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the SSL policy to update. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified SSL policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_SslPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param sslPolicy Name of the SSL policy to update. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_RegionSslPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region
                      sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  Method: compute.regionTargetHttpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Returns the specified TargetHttpProxy resource in the specified region.
 *
 *  Method: compute.regionTargetHttpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionTargetHttpProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetHttpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxy.
 *
 *  Returns the specified TargetHttpProxy resource in the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to return.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Creates a TargetHttpProxy resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.regionTargetHttpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpProxy resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpProxy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project in the specified region.
 *
 *  Method: compute.regionTargetHttpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionTargetHttpProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxyList.
 *
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project in the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Changes the URL map for TargetHttpProxy.
 *
 *  Method: compute.regionTargetHttpProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpProxiesSetUrlMap : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy to set a URL map for. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  Method: compute.regionTargetHttpsProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Returns the specified TargetHttpsProxy resource in the specified region.
 *
 *  Method: compute.regionTargetHttpsProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetHttpsProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxy.
 *
 *  Returns the specified TargetHttpsProxy resource in the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Creates a TargetHttpsProxy resource in the specified project and region
 *  using the data included in the request.
 *
 *  Method: compute.regionTargetHttpsProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpsProxy resource in the specified project and region
 *  using the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project in the specified region.
 *
 *  Method: compute.regionTargetHttpsProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxyList.
 *
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project in the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified regional TargetHttpsProxy resource with the data
 *  included in the request. This method supports PATCH semantics and uses JSON
 *  merge patch format and processing rules.
 *
 *  Method: compute.regionTargetHttpsProxies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource to patch. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified regional TargetHttpsProxy resource with the data
 *  included in the request. This method supports PATCH semantics and uses JSON
 *  merge patch format and processing rules.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to patch.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project
                         region:(NSString *)region
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  Method: compute.regionTargetHttpsProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesSetSslCertificates : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource to set an SslCertificates resource
 *  for.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  @param object The @c
 *    GTLRCompute_RegionTargetHttpsProxiesSetSslCertificatesRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an
 *    SslCertificates resource for.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionTargetHttpsProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  Method: compute.regionTargetHttpsProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetHttpsProxiesSetUrlMap : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy to set a URL map for. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy to set a URL map for.
 *
 *  @return GTLRComputeQuery_RegionTargetHttpsProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  Method: compute.regionTargetTcpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetTcpProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to delete.
 *
 *  @return GTLRComputeQuery_RegionTargetTcpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Returns the specified TargetTcpProxy resource.
 *
 *  Method: compute.regionTargetTcpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionTargetTcpProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetTcpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxy.
 *
 *  Returns the specified TargetTcpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to return.
 *
 *  @return GTLRComputeQuery_RegionTargetTcpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Creates a TargetTcpProxy resource in the specified project and region using
 *  the data included in the request.
 *
 *  Method: compute.regionTargetTcpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionTargetTcpProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetTcpProxy resource in the specified project and region using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionTargetTcpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of TargetTcpProxy resources available to the specified
 *  project in a given region.
 *
 *  Method: compute.regionTargetTcpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionTargetTcpProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxyList.
 *
 *  Retrieves a list of TargetTcpProxy resources available to the specified
 *  project in a given region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionTargetTcpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Deletes the specified UrlMap resource.
 *
 *  Method: compute.regionUrlMaps.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionUrlMapsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  begin_interface: MixerMutationRequestBuilder Request ID to support
 *  idempotency.
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to delete. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param urlMap Name of the UrlMap resource to delete.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Returns the specified UrlMap resource.
 *
 *  Method: compute.regionUrlMaps.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionUrlMapsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the UrlMap resource to return. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMap.
 *
 *  Returns the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param urlMap Name of the UrlMap resource to return.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.regionUrlMaps.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionUrlMapsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  begin_interface: MixerMutationRequestBuilder Request ID to support
 *  idempotency.
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves the list of UrlMap resources available to the specified project in
 *  the specified region.
 *
 *  Method: compute.regionUrlMaps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionUrlMapsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_UrlMapList.
 *
 *  Retrieves the list of UrlMap resources available to the specified project in
 *  the specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  Method: compute.regionUrlMaps.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionUrlMapsPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  begin_interface: MixerMutationRequestBuilder Request ID to support
 *  idempotency.
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to patch. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param urlMap Name of the UrlMap resource to patch.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  Method: compute.regionUrlMaps.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionUrlMapsUpdate : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  begin_interface: MixerMutationRequestBuilder Request ID to support
 *  idempotency.
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to update. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param urlMap Name of the UrlMap resource to update.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  Method: compute.regionUrlMaps.validate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RegionUrlMapsValidate : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the UrlMap resource to be validated as. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMapsValidateResponse.
 *
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  @param object The @c GTLRCompute_RegionUrlMapsValidateRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param urlMap Name of the UrlMap resource to be validated as.
 *
 *  @return GTLRComputeQuery_RegionUrlMapsValidate
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionUrlMapsValidateRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves the list of Zone resources under the specific region available to
 *  the specified project.
 *
 *  Method: compute.regionZones.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RegionZonesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ZoneList.
 *
 *  Retrieves the list of Zone resources under the specific region available to
 *  the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Region for this request.
 *
 *  @return GTLRComputeQuery_RegionZonesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves an aggregated list of reservations. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.reservations.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ReservationsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_ReservationAggregatedList.
 *
 *  Retrieves an aggregated list of reservations. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ReservationsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified reservation.
 *
 *  Method: compute.reservations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ReservationsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the reservation to delete. */
@property(nonatomic, copy, nullable) NSString *reservation;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified reservation.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param reservation Name of the reservation to delete.
 *
 *  @return GTLRComputeQuery_ReservationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     reservation:(NSString *)reservation;

@end

/**
 *  Retrieves information about the specified reservation.
 *
 *  Method: compute.reservations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ReservationsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the reservation to retrieve. */
@property(nonatomic, copy, nullable) NSString *reservation;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Reservation.
 *
 *  Retrieves information about the specified reservation.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param reservation Name of the reservation to retrieve.
 *
 *  @return GTLRComputeQuery_ReservationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     reservation:(NSString *)reservation;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.reservations.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ReservationsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ReservationsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates a new reservation. For more information, read Reserving zonal
 *  resources.
 *
 *  Method: compute.reservations.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ReservationsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new reservation. For more information, read Reserving zonal
 *  resources.
 *
 *  @param object The @c GTLRCompute_Reservation to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_ReservationsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Reservation *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  A list of all the reservations that have been configured for the specified
 *  project in specified zone.
 *
 *  Method: compute.reservations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ReservationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_ReservationList.
 *
 *  A list of all the reservations that have been configured for the specified
 *  project in specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *
 *  @return GTLRComputeQuery_ReservationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Resizes the reservation (applicable to standalone reservations only). For
 *  more information, read Modifying reservations.
 *
 *  Method: compute.reservations.resize
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ReservationsResize : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the reservation to update. */
@property(nonatomic, copy, nullable) NSString *reservation;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Resizes the reservation (applicable to standalone reservations only). For
 *  more information, read Modifying reservations.
 *
 *  @param object The @c GTLRCompute_ReservationsResizeRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param reservation Name of the reservation to update.
 *
 *  @return GTLRComputeQuery_ReservationsResize
 */
+ (instancetype)queryWithObject:(GTLRCompute_ReservationsResizeRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                    reservation:(NSString *)reservation;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.reservations.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ReservationsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ReservationsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.reservations.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ReservationsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ReservationsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Update share settings of the reservation.
 *
 *  Method: compute.reservations.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ReservationsUpdate : GTLRComputeQuery

@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the reservation to update. */
@property(nonatomic, copy, nullable) NSString *reservation;

/**
 *  Update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Update share settings of the reservation.
 *
 *  @param object The @c GTLRCompute_Reservation to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param reservation Name of the reservation to update.
 *
 *  @return GTLRComputeQuery_ReservationsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Reservation *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                    reservation:(NSString *)reservation;

@end

/**
 *  Retrieves an aggregated list of resource policies. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  Method: compute.resourcePolicies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ResourcePoliciesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_ResourcePolicyAggregatedList.
 *
 *  Retrieves an aggregated list of resource policies. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified resource policy.
 *
 *  Method: compute.resourcePolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ResourcePoliciesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the resource policy to delete. */
@property(nonatomic, copy, nullable) NSString *resourcePolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified resource policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param resourcePolicy Name of the resource policy to delete.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  resourcePolicy:(NSString *)resourcePolicy;

@end

/**
 *  Retrieves all information of the specified resource policy.
 *
 *  Method: compute.resourcePolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ResourcePoliciesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the resource policy to retrieve. */
@property(nonatomic, copy, nullable) NSString *resourcePolicy;

/**
 *  Fetches a @c GTLRCompute_ResourcePolicy.
 *
 *  Retrieves all information of the specified resource policy.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param resourcePolicy Name of the resource policy to retrieve.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                  resourcePolicy:(NSString *)resourcePolicy;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.resourcePolicies.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ResourcePoliciesGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a new resource policy.
 *
 *  Method: compute.resourcePolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ResourcePoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new resource policy.
 *
 *  @param object The @c GTLRCompute_ResourcePolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourcePolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  A list all the resource policies that have been configured for the specified
 *  project in specified region.
 *
 *  Method: compute.resourcePolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ResourcePoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ResourcePolicyList.
 *
 *  A list all the resource policies that have been configured for the specified
 *  project in specified region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Modify the specified resource policy.
 *
 *  Method: compute.resourcePolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ResourcePoliciesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Id of the resource policy to patch. */
@property(nonatomic, copy, nullable) NSString *resourcePolicy;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Modify the specified resource policy.
 *
 *  @param object The @c GTLRCompute_ResourcePolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param resourcePolicy Id of the resource policy to patch.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_ResourcePolicy *)object
                        project:(NSString *)project
                         region:(NSString *)region
                 resourcePolicy:(NSString *)resourcePolicy;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.resourcePolicies.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ResourcePoliciesSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.resourcePolicies.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ResourcePoliciesTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ResourcePoliciesTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of routers. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.routers.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_RouterAggregatedList.
 *
 *  Retrieves an aggregated list of routers. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RoutersAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified Router resource.
 *
 *  Method: compute.routers.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to delete. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Router resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to delete.
 *
 *  @return GTLRComputeQuery_RoutersDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Returns the specified Router resource.
 *
 *  Method: compute.routers.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to return. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Router.
 *
 *  Returns the specified Router resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to return.
 *
 *  @return GTLRComputeQuery_RoutersGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Retrieves runtime NAT IP information.
 *
 *  Method: compute.routers.getNatIpInfo
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGetNatIpInfo : GTLRComputeQuery

/**
 *  Name of the nat service to filter the NAT IP information. If it is omitted,
 *  all nats for this router will be returned. Name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *natName;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Name of the Router resource to query for Nat IP information. The name should
 *  conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_NatIpInfoResponse.
 *
 *  Retrieves runtime NAT IP information.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query for Nat IP information.
 *    The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_RoutersGetNatIpInfo
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Retrieves runtime Nat mapping information of VM endpoints.
 *
 *  Method: compute.routers.getNatMappingInfo
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGetNatMappingInfo : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Name of the nat service to filter the Nat Mapping information. If it is
 *  omitted, all nats for this router will be returned. Name should conform to
 *  RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *natName;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Name of the Router resource to query for Nat Mapping information of VM
 *  endpoints.
 */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_VmEndpointNatMappingsList.
 *
 *  Retrieves runtime Nat mapping information of VM endpoints.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query for Nat Mapping
 *    information of VM endpoints.
 *
 *  @return GTLRComputeQuery_RoutersGetNatMappingInfo
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Retrieves runtime information of the specified router.
 *
 *  Method: compute.routers.getRouterStatus
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersGetRouterStatus : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to query. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_RouterStatusResponse.
 *
 *  Retrieves runtime information of the specified router.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query.
 *
 *  @return GTLRComputeQuery_RoutersGetRouterStatus
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                          router:(NSString *)router;

@end

/**
 *  Creates a Router resource in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.routers.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Router resource in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RoutersInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of Router resources available to the specified project.
 *
 *  Method: compute.routers.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RouterList.
 *
 *  Retrieves a list of Router resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_RoutersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  Method: compute.routers.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to patch. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified Router resource with the data included in the request.
 *  This method supports PATCH semantics and uses JSON merge patch format and
 *  processing rules.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to patch.
 *
 *  @return GTLRComputeQuery_RoutersPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Preview fields auto-generated during router create and update operations.
 *  Calling this method does NOT create or update the router.
 *
 *  Method: compute.routers.preview
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutersPreview : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Router resource to query. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_RoutersPreviewResponse.
 *
 *  Preview fields auto-generated during router create and update operations.
 *  Calling this method does NOT create or update the router.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to query.
 *
 *  @return GTLRComputeQuery_RoutersPreview
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Updates the specified Router resource with the data included in the request.
 *  This method conforms to PUT semantics, which requests that the state of the
 *  target resource be created or replaced with the state defined by the
 *  representation enclosed in the request message payload.
 *
 *  Method: compute.routers.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutersUpdate : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Router resource to update. */
@property(nonatomic, copy, nullable) NSString *router;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified Router resource with the data included in the request.
 *  This method conforms to PUT semantics, which requests that the state of the
 *  target resource be created or replaced with the state defined by the
 *  representation enclosed in the request message payload.
 *
 *  @param object The @c GTLRCompute_Router to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param router Name of the Router resource to update.
 *
 *  @return GTLRComputeQuery_RoutersUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_Router *)object
                        project:(NSString *)project
                         region:(NSString *)region
                         router:(NSString *)router;

@end

/**
 *  Deletes the specified Route resource.
 *
 *  Method: compute.routes.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Route resource to delete. */
@property(nonatomic, copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Route resource.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to delete.
 *
 *  @return GTLRComputeQuery_RoutesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Returns the specified Route resource.
 *
 *  Method: compute.routes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the Route resource to return. */
@property(nonatomic, copy, nullable) NSString *route;

/**
 *  Fetches a @c GTLRCompute_Route.
 *
 *  Returns the specified Route resource.
 *
 *  @param project Project ID for this request.
 *  @param route Name of the Route resource to return.
 *
 *  @return GTLRComputeQuery_RoutesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                           route:(NSString *)route;

@end

/**
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  Method: compute.routes.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_RoutesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a Route resource in the specified project using the data included in
 *  the request.
 *
 *  @param object The @c GTLRCompute_Route to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RoutesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Route *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  Method: compute.routes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_RoutesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_RouteList.
 *
 *  Retrieves the list of Route resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_RoutesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Inserts a rule into a security policy.
 *
 *  Method: compute.securityPolicies.addRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesAddRule : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Inserts a rule into a security policy.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesAddRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyRule *)object
                        project:(NSString *)project
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Retrieves the list of all SecurityPolicy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.securityPolicies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_SecurityPoliciesAggregatedList.
 *
 *  Retrieves the list of all SecurityPolicy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified policy.
 *
 *  Method: compute.securityPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the security policy to delete. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified policy.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to delete.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  List all of the ordered rules present in a single specified policy.
 *
 *  Method: compute.securityPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to get. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicy.
 *
 *  List all of the ordered rules present in a single specified policy.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to get.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Gets a rule at the specified priority.
 *
 *  Method: compute.securityPolicies.getRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesGetRule : GTLRComputeQuery

/** The priority of the rule to get from the security policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to which the queried rule belongs. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicyRule.
 *
 *  Gets a rule at the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to which the queried rule
 *    belongs.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesGetRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.securityPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a new policy in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_SecurityPolicy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicy *)object
                        project:(NSString *)project;

@end

/**
 *  List all the policies that have been configured for the specified project.
 *
 *  Method: compute.securityPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SecurityPolicyList.
 *
 *  List all the policies that have been configured for the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Gets the current list of preconfigured Web Application Firewall (WAF)
 *  expressions.
 *
 *  Method: compute.securityPolicies.listPreconfiguredExpressionSets
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SecurityPoliciesListPreconfiguredExpressionSets : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c
 *  GTLRCompute_SecurityPoliciesListPreconfiguredExpressionSetsResponse.
 *
 *  Gets the current list of preconfigured Web Application Firewall (WAF)
 *  expressions.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesListPreconfiguredExpressionSets
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified policy with the data included in the request. To clear
 *  fields in the policy, leave the fields empty and specify them in the
 *  updateMask. This cannot be used to be update the rules in the policy. Please
 *  use the per rule methods like addRule, patchRule, and removeRule instead.
 *
 *  Method: compute.securityPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Indicates fields to be cleared as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified policy with the data included in the request. To clear
 *  fields in the policy, leave the fields empty and specify them in the
 *  updateMask. This cannot be used to be update the rules in the policy. Please
 *  use the per rule methods like addRule, patchRule, and removeRule instead.
 *
 *  @param object The @c GTLRCompute_SecurityPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicy *)object
                        project:(NSString *)project
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Patches a rule at the specified priority. To clear fields in the rule, leave
 *  the fields empty and specify them in the updateMask.
 *
 *  Method: compute.securityPolicies.patchRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesPatchRule : GTLRComputeQuery

/** The priority of the rule to patch. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Indicates fields to be cleared as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/** If true, the request will not be committed. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches a rule at the specified priority. To clear fields in the rule, leave
 *  the fields empty and specify them in the updateMask.
 *
 *  @param object The @c GTLRCompute_SecurityPolicyRule to include in the query.
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesPatchRule
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyRule *)object
                        project:(NSString *)project
                 securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Deletes a rule at the specified priority.
 *
 *  Method: compute.securityPolicies.removeRule
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesRemoveRule : GTLRComputeQuery

/** The priority of the rule to remove from the security policy. */
@property(nonatomic, assign) NSInteger priority;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the security policy to update. */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes a rule at the specified priority.
 *
 *  @param project Project ID for this request.
 *  @param securityPolicy Name of the security policy to update.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesRemoveRule
 */
+ (instancetype)queryWithProject:(NSString *)project
                  securityPolicy:(NSString *)securityPolicy;

@end

/**
 *  Sets the labels on a security policy. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.securityPolicies.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SecurityPoliciesSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a security policy. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SecurityPoliciesSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves the list of all ServiceAttachment resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.serviceAttachments.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ServiceAttachmentsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_ServiceAttachmentAggregatedList.
 *
 *  Retrieves the list of all ServiceAttachment resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified ServiceAttachment in the given scope
 *
 *  Method: compute.serviceAttachments.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ServiceAttachmentsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the ServiceAttachment resource to delete. */
@property(nonatomic, copy, nullable) NSString *serviceAttachment;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified ServiceAttachment in the given scope
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *  @param serviceAttachment Name of the ServiceAttachment resource to delete.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
               serviceAttachment:(NSString *)serviceAttachment;

@end

/**
 *  Returns the specified ServiceAttachment resource in the given scope.
 *
 *  Method: compute.serviceAttachments.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ServiceAttachmentsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the ServiceAttachment resource to return. */
@property(nonatomic, copy, nullable) NSString *serviceAttachment;

/**
 *  Fetches a @c GTLRCompute_ServiceAttachment.
 *
 *  Returns the specified ServiceAttachment resource in the given scope.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *  @param serviceAttachment Name of the ServiceAttachment resource to return.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
               serviceAttachment:(NSString *)serviceAttachment;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.serviceAttachments.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ServiceAttachmentsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a ServiceAttachment in the specified project in the given scope
 *  using the parameters that are included in the request.
 *
 *  Method: compute.serviceAttachments.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ServiceAttachmentsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a ServiceAttachment in the specified project in the given scope
 *  using the parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_ServiceAttachment to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_ServiceAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Lists the ServiceAttachments for a project in the given scope.
 *
 *  Method: compute.serviceAttachments.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ServiceAttachmentsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region of this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ServiceAttachmentList.
 *
 *  Lists the ServiceAttachments for a project in the given scope.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region of this request.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Patches the specified ServiceAttachment resource with the data included in
 *  the request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.serviceAttachments.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ServiceAttachmentsPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region scoping this request and should conform to RFC1035. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The resource id of the ServiceAttachment to patch. It should conform to
 *  RFC1035 resource name or be a string form on an unsigned long number.
 */
@property(nonatomic, copy, nullable) NSString *serviceAttachment;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified ServiceAttachment resource with the data included in
 *  the request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_ServiceAttachment to include in the query.
 *  @param project Project ID for this request.
 *  @param region The region scoping this request and should conform to RFC1035.
 *  @param serviceAttachment The resource id of the ServiceAttachment to patch.
 *    It should conform to RFC1035 resource name or be a string form on an
 *    unsigned long number.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_ServiceAttachment *)object
                        project:(NSString *)project
                         region:(NSString *)region
              serviceAttachment:(NSString *)serviceAttachment;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.serviceAttachments.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ServiceAttachmentsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.serviceAttachments.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ServiceAttachmentsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_ServiceAttachmentsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot. For
 *  more information, see Deleting snapshots.
 *
 *  Method: compute.snapshots.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Snapshot resource to delete. */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified Snapshot resource. Keep in mind that deleting a single
 *  snapshot might not necessarily delete all the data on that snapshot. If any
 *  data on the snapshot that is marked for deletion is needed for subsequent
 *  snapshots, the data will be moved to the next corresponding snapshot. For
 *  more information, see Deleting snapshots.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to delete.
 *
 *  @return GTLRComputeQuery_SnapshotsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Get snapshot settings.
 *
 *  Method: compute.snapshotSettings.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotSettingsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Fetches a @c GTLRCompute_SnapshotSettings.
 *
 *  Get snapshot settings.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SnapshotSettingsGet
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patch snapshot settings.
 *
 *  Method: compute.snapshotSettings.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotSettingsPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patch snapshot settings.
 *
 *  @param object The @c GTLRCompute_SnapshotSettings to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SnapshotSettingsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SnapshotSettings *)object
                        project:(NSString *)project;

@end

/**
 *  Returns the specified Snapshot resource.
 *
 *  Method: compute.snapshots.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the Snapshot resource to return. */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Fetches a @c GTLRCompute_Snapshot.
 *
 *  Returns the specified Snapshot resource.
 *
 *  @param project Project ID for this request.
 *  @param snapshot Name of the Snapshot resource to return.
 *
 *  @return GTLRComputeQuery_SnapshotsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                        snapshot:(NSString *)snapshot;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.snapshots.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                        resource:(NSString *)resource;

@end

/**
 *  Creates a snapshot in the specified project using the data included in the
 *  request. For regular snapshot creation, consider using this method instead
 *  of disks.createSnapshot, as this method supports more features, such as
 *  creating snapshots in a project different from the source disk project.
 *
 *  Method: compute.snapshots.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a snapshot in the specified project using the data included in the
 *  request. For regular snapshot creation, consider using this method instead
 *  of disks.createSnapshot, as this method supports more features, such as
 *  creating snapshots in a project different from the source disk project.
 *
 *  @param object The @c GTLRCompute_Snapshot to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Snapshot *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  Method: compute.snapshots.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SnapshotList.
 *
 *  Retrieves the list of Snapshot resources contained within the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.snapshots.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_GlobalSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetPolicyRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Sets the labels on a snapshot. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  Method: compute.snapshots.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SnapshotsSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a snapshot. To learn more about labels, read the Labeling
 *  Resources documentation.
 *
 *  @param object The @c GTLRCompute_GlobalSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_GlobalSetLabelsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.snapshots.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SnapshotsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SnapshotsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves the list of all SslCertificate resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.sslCertificates.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_SslCertificateAggregatedList.
 *
 *  Retrieves the list of all SslCertificate resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_SslCertificatesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified SslCertificate resource.
 *
 *  Method: compute.sslCertificates.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the SslCertificate resource to delete. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SslCertificate resource.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to delete.
 *
 *  @return GTLRComputeQuery_SslCertificatesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Returns the specified SslCertificate resource.
 *
 *  Method: compute.sslCertificates.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the SslCertificate resource to return. */
@property(nonatomic, copy, nullable) NSString *sslCertificate;

/**
 *  Fetches a @c GTLRCompute_SslCertificate.
 *
 *  Returns the specified SslCertificate resource.
 *
 *  @param project Project ID for this request.
 *  @param sslCertificate Name of the SslCertificate resource to return.
 *
 *  @return GTLRComputeQuery_SslCertificatesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  sslCertificate:(NSString *)sslCertificate;

@end

/**
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.sslCertificates.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslCertificatesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a SslCertificate resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_SslCertificate to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslCertificatesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslCertificate *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  Method: compute.sslCertificates.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslCertificatesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SslCertificateList.
 *
 *  Retrieves the list of SslCertificate resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslCertificatesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Retrieves the list of all SslPolicy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.sslPolicies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesAggregatedList.
 *
 *  Retrieves the list of all SslPolicy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified SSL policy. The SSL policy resource can be deleted
 *  only if it is not in use by any TargetHttpsProxy or TargetSslProxy
 *  resources.
 *
 *  Method: compute.sslPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslPoliciesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the SSL policy to delete. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified SSL policy. The SSL policy resource can be deleted
 *  only if it is not in use by any TargetHttpsProxy or TargetSslProxy
 *  resources.
 *
 *  @param project Project ID for this request.
 *  @param sslPolicy Name of the SSL policy to delete. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_SslPoliciesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                       sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Lists all of the ordered rules present in a single specified policy.
 *
 *  Method: compute.sslPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the SSL policy to update. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_SslPolicy.
 *
 *  Lists all of the ordered rules present in a single specified policy.
 *
 *  @param project Project ID for this request.
 *  @param sslPolicy Name of the SSL policy to update. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_SslPoliciesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                       sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Returns the specified SSL policy resource.
 *
 *  Method: compute.sslPolicies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslPoliciesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Returns the specified SSL policy resource.
 *
 *  @param object The @c GTLRCompute_SslPolicy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicy *)object
                        project:(NSString *)project;

@end

/**
 *  Lists all the SSL policies that have been configured for the specified
 *  project.
 *
 *  Method: compute.sslPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesList.
 *
 *  Lists all the SSL policies that have been configured for the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Lists all features that can be specified in the SSL policy when using custom
 *  profile.
 *
 *  Method: compute.sslPolicies.listAvailableFeatures
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SslPoliciesListAvailableFeatures : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SslPoliciesListAvailableFeaturesResponse.
 *
 *  Lists all features that can be specified in the SSL policy when using custom
 *  profile.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SslPoliciesListAvailableFeatures
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified SSL policy with the data included in the request.
 *
 *  Method: compute.sslPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SslPoliciesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the SSL policy to update. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *sslPolicy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified SSL policy with the data included in the request.
 *
 *  @param object The @c GTLRCompute_SslPolicy to include in the query.
 *  @param project Project ID for this request.
 *  @param sslPolicy Name of the SSL policy to update. The name must be 1-63
 *    characters long, and comply with RFC1035.
 *
 *  @return GTLRComputeQuery_SslPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicy *)object
                        project:(NSString *)project
                      sslPolicy:(NSString *)sslPolicy;

@end

/**
 *  Retrieves an aggregated list of storage pools. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.storagePools.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_StoragePoolAggregatedList.
 *
 *  Retrieves an aggregated list of storage pools. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified storage pool. Deleting a storagePool removes its data
 *  permanently and is irreversible. However, deleting a storagePool does not
 *  delete any snapshots previously made from the storagePool. You must
 *  separately delete snapshots.
 *
 *  Method: compute.storagePools.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_StoragePoolsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the storage pool to delete. */
@property(nonatomic, copy, nullable) NSString *storagePool;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified storage pool. Deleting a storagePool removes its data
 *  permanently and is irreversible. However, deleting a storagePool does not
 *  delete any snapshots previously made from the storagePool. You must
 *  separately delete snapshots.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param storagePool Name of the storage pool to delete.
 *
 *  @return GTLRComputeQuery_StoragePoolsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     storagePool:(NSString *)storagePool;

@end

/**
 *  Returns a specified storage pool. Gets a list of available storage pools by
 *  making a list() request.
 *
 *  Method: compute.storagePools.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the storage pool to return. */
@property(nonatomic, copy, nullable) NSString *storagePool;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_StoragePool.
 *
 *  Returns a specified storage pool. Gets a list of available storage pools by
 *  making a list() request.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param storagePool Name of the storage pool to return.
 *
 *  @return GTLRComputeQuery_StoragePoolsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     storagePool:(NSString *)storagePool;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.storagePools.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolsGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                        resource:(NSString *)resource;

@end

/**
 *  Creates a storage pool in the specified project using the data in the
 *  request.
 *
 *  Method: compute.storagePools.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_StoragePoolsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a storage pool in the specified project using the data in the
 *  request.
 *
 *  @param object The @c GTLRCompute_StoragePool to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_StoragePool *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of storage pools contained within the specified zone.
 *
 *  Method: compute.storagePools.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_StoragePoolList.
 *
 *  Retrieves a list of storage pools contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Lists the disks in a specified storage pool.
 *
 *  Method: compute.storagePools.listDisks
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolsListDisks : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/** Name of the storage pool to list disks of. */
@property(nonatomic, copy, nullable) NSString *storagePool;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_StoragePoolListDisks.
 *
 *  Lists the disks in a specified storage pool.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param storagePool Name of the storage pool to list disks of.
 *
 *  @return GTLRComputeQuery_StoragePoolsListDisks
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                     storagePool:(NSString *)storagePool;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.storagePools.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_StoragePoolsSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_ZoneSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_ZoneSetPolicyRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.storagePools.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolsTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                       resource:(NSString *)resource;

@end

/**
 *  Updates the specified storagePool with the data included in the request. The
 *  update is performed only on selected fields included as part of update-mask.
 *  Only the following fields can be modified: pool_provisioned_capacity_gb,
 *  pool_provisioned_iops and pool_provisioned_throughput.
 *
 *  Method: compute.storagePools.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_StoragePoolsUpdate : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** The storagePool name for this request. */
@property(nonatomic, copy, nullable) NSString *storagePool;

/**
 *  update_mask indicates fields to be updated as part of this request.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified storagePool with the data included in the request. The
 *  update is performed only on selected fields included as part of update-mask.
 *  Only the following fields can be modified: pool_provisioned_capacity_gb,
 *  pool_provisioned_iops and pool_provisioned_throughput.
 *
 *  @param object The @c GTLRCompute_StoragePool to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param storagePool The storagePool name for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_StoragePool *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                    storagePool:(NSString *)storagePool;

@end

/**
 *  Retrieves an aggregated list of storage pool types. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  Method: compute.storagePoolTypes.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolTypesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_StoragePoolTypeAggregatedList.
 *
 *  Retrieves an aggregated list of storage pool types. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolTypesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Returns the specified storage pool type.
 *
 *  Method: compute.storagePoolTypes.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolTypesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the storage pool type to return. */
@property(nonatomic, copy, nullable) NSString *storagePoolType;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_StoragePoolType.
 *
 *  Returns the specified storage pool type.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *  @param storagePoolType Name of the storage pool type to return.
 *
 *  @return GTLRComputeQuery_StoragePoolTypesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                 storagePoolType:(NSString *)storagePoolType;

@end

/**
 *  Retrieves a list of storage pool types available to the specified project.
 *
 *  Method: compute.storagePoolTypes.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_StoragePoolTypesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_StoragePoolTypeList.
 *
 *  Retrieves a list of storage pool types available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty The name of the zone for this request.
 *
 *  @return GTLRComputeQuery_StoragePoolTypesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves an aggregated list of subnetworks. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.subnetworks.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_SubnetworkAggregatedList.
 *
 *  Retrieves an aggregated list of subnetworks. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified subnetwork.
 *
 *  Method: compute.subnetworks.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to delete. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified subnetwork.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to delete.
 *
 *  @return GTLRComputeQuery_SubnetworksDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Expands the IP CIDR range of the subnetwork to a specified value.
 *
 *  Method: compute.subnetworks.expandIpCidrRange
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksExpandIpCidrRange : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to update. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Expands the IP CIDR range of the subnetwork to a specified value.
 *
 *  @param object The @c GTLRCompute_SubnetworksExpandIpCidrRangeRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to update.
 *
 *  @return GTLRComputeQuery_SubnetworksExpandIpCidrRange
 */
+ (instancetype)queryWithObject:(GTLRCompute_SubnetworksExpandIpCidrRangeRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Returns the specified subnetwork.
 *
 *  Method: compute.subnetworks.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the Subnetwork resource to return. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Subnetwork.
 *
 *  Returns the specified subnetwork.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to return.
 *
 *  @return GTLRComputeQuery_SubnetworksGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      subnetwork:(NSString *)subnetwork;

@end

/**
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  Method: compute.subnetworks.getIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksGetIamPolicy : GTLRComputeQuery

/** Requested IAM Policy version. */
@property(nonatomic, assign) NSInteger optionsRequestedPolicyVersion;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Gets the access control policy for a resource. May be empty if no such
 *  policy or resource exists.
 *
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksGetIamPolicy
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                        resource:(NSString *)resource;

@end

/**
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  Method: compute.subnetworks.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a subnetwork in the specified project using the data included in the
 *  request.
 *
 *  @param object The @c GTLRCompute_Subnetwork to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_SubnetworksInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_Subnetwork *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  Method: compute.subnetworks.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_SubnetworkList.
 *
 *  Retrieves a list of subnetworks available to the specified project.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_SubnetworksList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Retrieves an aggregated list of all usable subnetworks in the project.
 *
 *  Method: compute.subnetworks.listUsable
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksListUsable : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_UsableSubnetworksAggregatedList.
 *
 *  Retrieves an aggregated list of all usable subnetworks in the project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksListUsable
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified subnetwork with the data included in the request. Only
 *  certain fields can be updated with a patch request as indicated in the field
 *  descriptions. You must specify the current fingerprint of the subnetwork
 *  resource being patched.
 *
 *  Method: compute.subnetworks.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksPatch : GTLRComputeQuery

/**
 *  The drain timeout specifies the upper bound in seconds on the amount of time
 *  allowed to drain connections from the current ACTIVE subnetwork to the
 *  current BACKUP subnetwork. The drain timeout is only applicable when the
 *  following conditions are true: - the subnetwork being patched has purpose =
 *  INTERNAL_HTTPS_LOAD_BALANCER - the subnetwork being patched has role =
 *  BACKUP - the patch request is setting the role to ACTIVE. Note that after
 *  this patch operation the roles of the ACTIVE and BACKUP subnetworks will be
 *  swapped.
 */
@property(nonatomic, assign) NSInteger drainTimeoutSeconds;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource to patch. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified subnetwork with the data included in the request. Only
 *  certain fields can be updated with a patch request as indicated in the field
 *  descriptions. You must specify the current fingerprint of the subnetwork
 *  resource being patched.
 *
 *  @param object The @c GTLRCompute_Subnetwork to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource to patch.
 *
 *  @return GTLRComputeQuery_SubnetworksPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_Subnetwork *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  Method: compute.subnetworks.setIamPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksSetIamPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Policy.
 *
 *  Sets the access control policy on the specified resource. Replaces any
 *  existing policy.
 *
 *  @param object The @c GTLRCompute_RegionSetPolicyRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksSetIamPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetPolicyRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Set whether VMs in this subnet can access Google services without assigning
 *  external IP addresses through Private Google Access.
 *
 *  Method: compute.subnetworks.setPrivateIpGoogleAccess
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_SubnetworksSetPrivateIpGoogleAccess : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the Subnetwork resource. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Set whether VMs in this subnet can access Google services without assigning
 *  external IP addresses through Private Google Access.
 *
 *  @param object The @c GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param subnetwork Name of the Subnetwork resource.
 *
 *  @return GTLRComputeQuery_SubnetworksSetPrivateIpGoogleAccess
 */
+ (instancetype)queryWithObject:(GTLRCompute_SubnetworksSetPrivateIpGoogleAccessRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     subnetwork:(NSString *)subnetwork;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.subnetworks.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_SubnetworksTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_SubnetworksTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified TargetGrpcProxy in the given scope
 *
 *  Method: compute.targetGrpcProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetGrpcProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetGrpcProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetGrpcProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetGrpcProxy in the given scope
 *
 *  @param project Project ID for this request.
 *  @param targetGrpcProxy Name of the TargetGrpcProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetGrpcProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetGrpcProxy:(NSString *)targetGrpcProxy;

@end

/**
 *  Returns the specified TargetGrpcProxy resource in the given scope.
 *
 *  Method: compute.targetGrpcProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetGrpcProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetGrpcProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetGrpcProxy;

/**
 *  Fetches a @c GTLRCompute_TargetGrpcProxy.
 *
 *  Returns the specified TargetGrpcProxy resource in the given scope.
 *
 *  @param project Project ID for this request.
 *  @param targetGrpcProxy Name of the TargetGrpcProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetGrpcProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetGrpcProxy:(NSString *)targetGrpcProxy;

@end

/**
 *  Creates a TargetGrpcProxy in the specified project in the given scope using
 *  the parameters that are included in the request.
 *
 *  Method: compute.targetGrpcProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetGrpcProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetGrpcProxy in the specified project in the given scope using
 *  the parameters that are included in the request.
 *
 *  @param object The @c GTLRCompute_TargetGrpcProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetGrpcProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetGrpcProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Lists the TargetGrpcProxies for a project in the given scope.
 *
 *  Method: compute.targetGrpcProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetGrpcProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetGrpcProxyList.
 *
 *  Lists the TargetGrpcProxies for a project in the given scope.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetGrpcProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified TargetGrpcProxy resource with the data included in the
 *  request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.targetGrpcProxies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetGrpcProxiesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetGrpcProxy resource to patch. */
@property(nonatomic, copy, nullable) NSString *targetGrpcProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified TargetGrpcProxy resource with the data included in the
 *  request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_TargetGrpcProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param targetGrpcProxy Name of the TargetGrpcProxy resource to patch.
 *
 *  @return GTLRComputeQuery_TargetGrpcProxiesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetGrpcProxy *)object
                        project:(NSString *)project
                targetGrpcProxy:(NSString *)targetGrpcProxy;

@end

/**
 *  Retrieves the list of all TargetHttpProxy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.targetHttpProxies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxyAggregatedList.
 *
 *  Retrieves the list of all TargetHttpProxy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  Method: compute.targetHttpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Returns the specified TargetHttpProxy resource.
 *
 *  Method: compute.targetHttpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetHttpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxy.
 *
 *  Returns the specified TargetHttpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                 targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetHttpProxyList.
 *
 *  Retrieves the list of TargetHttpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified TargetHttpProxy resource with the data included in the
 *  request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.targetHttpProxies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy resource to patch. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified TargetHttpProxy resource with the data included in the
 *  request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_TargetHttpProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy resource to patch.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpProxy *)object
                        project:(NSString *)project
                targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Changes the URL map for TargetHttpProxy.
 *
 *  Method: compute.targetHttpProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpProxiesSetUrlMap : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpProxy to set a URL map for. */
@property(nonatomic, copy, nullable) NSString *targetHttpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpProxy Name of the TargetHttpProxy to set a URL map for.
 *
 *  @return GTLRComputeQuery_TargetHttpProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
                targetHttpProxy:(NSString *)targetHttpProxy;

@end

/**
 *  Retrieves the list of all TargetHttpsProxy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.targetHttpsProxies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxyAggregatedList.
 *
 *  Retrieves the list of all TargetHttpsProxy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  Method: compute.targetHttpsProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetHttpsProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Returns the specified TargetHttpsProxy resource.
 *
 *  Method: compute.targetHttpsProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetHttpsProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxy.
 *
 *  Returns the specified TargetHttpsProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetHttpsProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetHttpsProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetHttpsProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetHttpsProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetHttpsProxyList.
 *
 *  Retrieves the list of TargetHttpsProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified TargetHttpsProxy resource with the data included in
 *  the request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  Method: compute.targetHttpsProxies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource to patch. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified TargetHttpsProxy resource with the data included in
 *  the request. This method supports PATCH semantics and uses JSON merge patch
 *  format and processing rules.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxy to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to patch.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxy *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Changes the Certificate Map for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setCertificateMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetCertificateMap : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource whose CertificateMap is to be set. The
 *  name must be 1-63 characters long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the Certificate Map for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetCertificateMapRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose
 *    CertificateMap is to be set. The name must be 1-63 characters long, and
 *    comply with RFC1035.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetCertificateMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetCertificateMapRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Sets the QUIC override policy for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setQuicOverride
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetQuicOverride : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource to set the QUIC override policy for.
 *  The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the QUIC override policy for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetQuicOverrideRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set the
 *    QUIC override policy for. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetQuicOverride
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetQuicOverrideRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource to set an SslCertificates resource
 *  for.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Replaces SslCertificates for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource to set an
 *    SslCertificates resource for.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the HTTPS proxy load balancer. They do not affect the connection
 *  between the load balancer and the backends.
 *
 *  Method: compute.targetHttpsProxies.setSslPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetSslPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetHttpsProxy resource whose SSL policy is to be set. The
 *  name must be 1-63 characters long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the HTTPS proxy load balancer. They do not affect the connection
 *  between the load balancer and the backends.
 *
 *  @param object The @c GTLRCompute_SslPolicyReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose SSL
 *    policy is to be set. The name must be 1-63 characters long, and comply
 *    with RFC1035.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetSslPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicyReference *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  Method: compute.targetHttpsProxies.setUrlMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetHttpsProxiesSetUrlMap : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetHttpsProxy resource whose URL map is to be set. */
@property(nonatomic, copy, nullable) NSString *targetHttpsProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the URL map for TargetHttpsProxy.
 *
 *  @param object The @c GTLRCompute_UrlMapReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetHttpsProxy Name of the TargetHttpsProxy resource whose URL map
 *    is to be set.
 *
 *  @return GTLRComputeQuery_TargetHttpsProxiesSetUrlMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapReference *)object
                        project:(NSString *)project
               targetHttpsProxy:(NSString *)targetHttpsProxy;

@end

/**
 *  Retrieves an aggregated list of target instances. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.targetInstances.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceAggregatedList.
 *
 *  Retrieves an aggregated list of target instances. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetInstancesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetInstance resource.
 *
 *  Method: compute.targetInstances.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetInstance resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetInstance resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to delete.
 *
 *  @return GTLRComputeQuery_TargetInstancesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Returns the specified TargetInstance resource.
 *
 *  Method: compute.targetInstances.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetInstance resource to return. */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstance.
 *
 *  Returns the specified TargetInstance resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to return.
 *
 *  @return GTLRComputeQuery_TargetInstancesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                  targetInstance:(NSString *)targetInstance;

@end

/**
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  Method: compute.targetInstances.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetInstance resource in the specified project and zone using
 *  the data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetInstance to include in the query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @return GTLRComputeQuery_TargetInstancesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetInstance *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  Method: compute.targetInstances.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetInstancesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_TargetInstanceList.
 *
 *  Retrieves a list of TargetInstance resources available to the specified
 *  project and zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *
 *  @return GTLRComputeQuery_TargetInstancesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Sets the Google Cloud Armor security policy for the specified target
 *  instance. For more information, see Google Cloud Armor Overview
 *
 *  Method: compute.targetInstances.setSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetInstancesSetSecurityPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetInstance resource to which the security policy should be
 *  set. The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetInstance;

/**
 *  Name of the zone scoping this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Google Cloud Armor security policy for the specified target
 *  instance. For more information, see Google Cloud Armor Overview
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone scoping this request.
 *  @param targetInstance Name of the TargetInstance resource to which the
 *    security policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_TargetInstancesSetSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                   zoneProperty:(NSString *)zoneProperty
                 targetInstance:(NSString *)targetInstance;

@end

/**
 *  Adds health check URLs to a target pool.
 *
 *  Method: compute.targetPools.addHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddHealthCheck : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target pool to add a health check to. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds health check URLs to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddHealthCheckRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the target pool to add a health check to.
 *
 *  @return GTLRComputeQuery_TargetPoolsAddHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Adds an instance to a target pool.
 *
 *  Method: compute.targetPools.addInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsAddInstance : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to add instances to. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Adds an instance to a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsAddInstanceRequest to include in
 *    the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to add instances to.
 *
 *  @return GTLRComputeQuery_TargetPoolsAddInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsAddInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Retrieves an aggregated list of target pools. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.targetPools.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_TargetPoolAggregatedList.
 *
 *  Retrieves an aggregated list of target pools. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetPoolsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target pool.
 *
 *  Method: compute.targetPools.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target pool.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to delete.
 *
 *  @return GTLRComputeQuery_TargetPoolsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Returns the specified target pool.
 *
 *  Method: compute.targetPools.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetPool resource to return. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPool.
 *
 *  Returns the specified target pool.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to return.
 *
 *  @return GTLRComputeQuery_TargetPoolsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      targetPool:(NSString *)targetPool;

@end

/**
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  Method: compute.targetPools.getHealth
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsGetHealth : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the TargetPool resource to which the queried instance belongs. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_TargetPoolInstanceHealth.
 *
 *  Gets the most recent health check results for each IP for the instance that
 *  is referenced by the given target pool.
 *
 *  @param object The @c GTLRCompute_InstanceReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to which the queried
 *    instance belongs.
 *
 *  @return GTLRComputeQuery_TargetPoolsGetHealth
 */
+ (instancetype)queryWithObject:(GTLRCompute_InstanceReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.targetPools.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target pool in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetPool to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_TargetPoolsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPool *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  Method: compute.targetPools.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetPoolsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetPoolList.
 *
 *  Retrieves a list of target pools available to the specified project and
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *
 *  @return GTLRComputeQuery_TargetPoolsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Removes health check URL from a target pool.
 *
 *  Method: compute.targetPools.removeHealthCheck
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveHealthCheck : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target pool to remove health checks from. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes health check URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveHealthCheckRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetPool Name of the target pool to remove health checks from.
 *
 *  @return GTLRComputeQuery_TargetPoolsRemoveHealthCheck
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveHealthCheckRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Removes instance URL from a target pool.
 *
 *  Method: compute.targetPools.removeInstance
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsRemoveInstance : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to remove instances from. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Removes instance URL from a target pool.
 *
 *  @param object The @c GTLRCompute_TargetPoolsRemoveInstanceRequest to include
 *    in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to remove instances from.
 *
 *  @return GTLRComputeQuery_TargetPoolsRemoveInstance
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetPoolsRemoveInstanceRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Changes a backup target pool's configurations.
 *
 *  Method: compute.targetPools.setBackup
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsSetBackup : GTLRComputeQuery

/** New failoverRatio value for the target pool. */
@property(nonatomic, assign) float failoverRatio;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetPool resource to set a backup pool for. */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes a backup target pool's configurations.
 *
 *  @param object The @c GTLRCompute_TargetReference to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to set a backup pool for.
 *
 *  @return GTLRComputeQuery_TargetPoolsSetBackup
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Sets the Google Cloud Armor security policy for the specified target pool.
 *  For more information, see Google Cloud Armor Overview
 *
 *  Method: compute.targetPools.setSecurityPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetPoolsSetSecurityPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region scoping this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetPool resource to which the security policy should be set.
 *  The name should conform to RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetPool;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the Google Cloud Armor security policy for the specified target pool.
 *  For more information, see Google Cloud Armor Overview
 *
 *  @param object The @c GTLRCompute_SecurityPolicyReference to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region Name of the region scoping this request.
 *  @param targetPool Name of the TargetPool resource to which the security
 *    policy should be set. The name should conform to RFC1035.
 *
 *  @return GTLRComputeQuery_TargetPoolsSetSecurityPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SecurityPolicyReference *)object
                        project:(NSString *)project
                         region:(NSString *)region
                     targetPool:(NSString *)targetPool;

@end

/**
 *  Deletes the specified TargetSslProxy resource.
 *
 *  Method: compute.targetSslProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetSslProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetSslProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Returns the specified TargetSslProxy resource.
 *
 *  Method: compute.targetSslProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetSslProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetSslProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_TargetSslProxy.
 *
 *  Returns the specified TargetSslProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Creates a TargetSslProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetSslProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetSslProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetSslProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetSslProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetSslProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetSslProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetSslProxyList.
 *
 *  Retrieves the list of TargetSslProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the BackendService for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setBackendService
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetBackendService : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose BackendService resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the BackendService for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetBackendServiceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    BackendService resource is to be set.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetBackendService
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetBackendServiceRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes the Certificate Map for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setCertificateMap
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetCertificateMap : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose CertificateMap is to be set. The
 *  name must be 1-63 characters long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the Certificate Map for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetCertificateMapRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    CertificateMap is to be set. The name must be 1-63 characters long, and
 *    comply with RFC1035.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetCertificateMap
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetCertificateMapRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes the ProxyHeaderType for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setProxyHeader
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetProxyHeader : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetSslProxy resource whose ProxyHeader is to be set. */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the ProxyHeaderType for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetProxyHeaderRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose ProxyHeader
 *    is to be set.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetProxyHeader
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetProxyHeaderRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Changes SslCertificates for TargetSslProxy.
 *
 *  Method: compute.targetSslProxies.setSslCertificates
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetSslCertificates : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose SslCertificate resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes SslCertificates for TargetSslProxy.
 *
 *  @param object The @c GTLRCompute_TargetSslProxiesSetSslCertificatesRequest
 *    to include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose
 *    SslCertificate resource is to be set.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetSslCertificates
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetSslProxiesSetSslCertificatesRequest *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the load balancer. They do not affect the connection between the
 *  load balancer and the backends.
 *
 *  Method: compute.targetSslProxies.setSslPolicy
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetSslProxiesSetSslPolicy : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetSslProxy resource whose SSL policy is to be set. The name
 *  must be 1-63 characters long, and comply with RFC1035.
 */
@property(nonatomic, copy, nullable) NSString *targetSslProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
 *  server-side support for SSL features. This affects connections between
 *  clients and the load balancer. They do not affect the connection between the
 *  load balancer and the backends.
 *
 *  @param object The @c GTLRCompute_SslPolicyReference to include in the query.
 *  @param project Project ID for this request.
 *  @param targetSslProxy Name of the TargetSslProxy resource whose SSL policy
 *    is to be set. The name must be 1-63 characters long, and comply with
 *    RFC1035.
 *
 *  @return GTLRComputeQuery_TargetSslProxiesSetSslPolicy
 */
+ (instancetype)queryWithObject:(GTLRCompute_SslPolicyReference *)object
                        project:(NSString *)project
                 targetSslProxy:(NSString *)targetSslProxy;

@end

/**
 *  Retrieves the list of all TargetTcpProxy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.targetTcpProxies.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxyAggregatedList.
 *
 *  Retrieves the list of all TargetTcpProxy resources, regional and global,
 *  available to the specified project. To prevent failure, Google recommends
 *  that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  Method: compute.targetTcpProxies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource to delete. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified TargetTcpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to delete.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Returns the specified TargetTcpProxy resource.
 *
 *  Method: compute.targetTcpProxies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the TargetTcpProxy resource to return. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxy.
 *
 *  Returns the specified TargetTcpProxy resource.
 *
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource to return.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                  targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Creates a TargetTcpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  Method: compute.targetTcpProxies.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a TargetTcpProxy resource in the specified project using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxy to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxy *)object
                        project:(NSString *)project;

@end

/**
 *  Retrieves the list of TargetTcpProxy resources available to the specified
 *  project.
 *
 *  Method: compute.targetTcpProxies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetTcpProxiesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetTcpProxyList.
 *
 *  Retrieves the list of TargetTcpProxy resources available to the specified
 *  project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Changes the BackendService for TargetTcpProxy.
 *
 *  Method: compute.targetTcpProxies.setBackendService
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesSetBackendService : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Name of the TargetTcpProxy resource whose BackendService resource is to be
 *  set.
 */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the BackendService for TargetTcpProxy.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxiesSetBackendServiceRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource whose
 *    BackendService resource is to be set.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesSetBackendService
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxiesSetBackendServiceRequest *)object
                        project:(NSString *)project
                 targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Changes the ProxyHeaderType for TargetTcpProxy.
 *
 *  Method: compute.targetTcpProxies.setProxyHeader
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetTcpProxiesSetProxyHeader : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the TargetTcpProxy resource whose ProxyHeader is to be set. */
@property(nonatomic, copy, nullable) NSString *targetTcpProxy;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Changes the ProxyHeaderType for TargetTcpProxy.
 *
 *  @param object The @c GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest to
 *    include in the query.
 *  @param project Project ID for this request.
 *  @param targetTcpProxy Name of the TargetTcpProxy resource whose ProxyHeader
 *    is to be set.
 *
 *  @return GTLRComputeQuery_TargetTcpProxiesSetProxyHeader
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetTcpProxiesSetProxyHeaderRequest *)object
                        project:(NSString *)project
                 targetTcpProxy:(NSString *)targetTcpProxy;

@end

/**
 *  Retrieves an aggregated list of target VPN gateways. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  Method: compute.targetVpnGateways.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayAggregatedList.
 *
 *  Retrieves an aggregated list of target VPN gateways. To prevent failure,
 *  Google recommends that you set the `returnPartialSuccess` parameter to
 *  `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified target VPN gateway.
 *
 *  Method: compute.targetVpnGateways.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the target VPN gateway to delete. */
@property(nonatomic, copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified target VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to delete.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Returns the specified target VPN gateway.
 *
 *  Method: compute.targetVpnGateways.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the target VPN gateway to return. */
@property(nonatomic, copy, nullable) NSString *targetVpnGateway;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGateway.
 *
 *  Returns the specified target VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param targetVpnGateway Name of the target VPN gateway to return.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                targetVpnGateway:(NSString *)targetVpnGateway;

@end

/**
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.targetVpnGateways.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a target VPN gateway in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_TargetVpnGateway to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_TargetVpnGateway *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  Method: compute.targetVpnGateways.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_TargetVpnGatewaysList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_TargetVpnGatewayList.
 *
 *  Retrieves a list of target VPN gateways available to the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Sets the labels on a TargetVpnGateway. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.targetVpnGateways.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_TargetVpnGatewaysSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a TargetVpnGateway. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_TargetVpnGatewaysSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves the list of all UrlMap resources, regional and global, available
 *  to the specified project. To prevent failure, Google recommends that you set
 *  the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.urlMaps.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Name of the project scoping this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_UrlMapsAggregatedList.
 *
 *  Retrieves the list of all UrlMap resources, regional and global, available
 *  to the specified project. To prevent failure, Google recommends that you set
 *  the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Name of the project scoping this request.
 *
 *  @return GTLRComputeQuery_UrlMapsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified UrlMap resource.
 *
 *  Method: compute.urlMaps.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to delete. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to delete.
 *
 *  @return GTLRComputeQuery_UrlMapsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Returns the specified UrlMap resource.
 *
 *  Method: compute.urlMaps.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the UrlMap resource to return. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMap.
 *
 *  Returns the specified UrlMap resource.
 *
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to return.
 *
 *  @return GTLRComputeQuery_UrlMapsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          urlMap:(NSString *)urlMap;

@end

/**
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  Method: compute.urlMaps.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a UrlMap resource in the specified project using the data included
 *  in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_UrlMapsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project;

@end

/**
 *  Initiates a cache invalidation operation, invalidating the specified path,
 *  scoped to the specified UrlMap. For more information, see [Invalidating
 *  cached content](/cdn/docs/invalidating-cached-content).
 *
 *  Method: compute.urlMaps.invalidateCache
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsInvalidateCache : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap scoping this request. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Initiates a cache invalidation operation, invalidating the specified path,
 *  scoped to the specified UrlMap. For more information, see [Invalidating
 *  cached content](/cdn/docs/invalidating-cached-content).
 *
 *  @param object The @c GTLRCompute_CacheInvalidationRule to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap scoping this request.
 *
 *  @return GTLRComputeQuery_UrlMapsInvalidateCache
 */
+ (instancetype)queryWithObject:(GTLRCompute_CacheInvalidationRule *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  Method: compute.urlMaps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_UrlMapsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_UrlMapList.
 *
 *  Retrieves the list of UrlMap resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_UrlMapsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  Method: compute.urlMaps.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsPatch : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to patch. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Patches the specified UrlMap resource with the data included in the request.
 *  This method supports PATCH semantics and uses the JSON merge patch format
 *  and processing rules.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to patch.
 *
 *  @return GTLRComputeQuery_UrlMapsPatch
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  Method: compute.urlMaps.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsUpdate : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the UrlMap resource to update. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Updates the specified UrlMap resource with the data included in the request.
 *
 *  @param object The @c GTLRCompute_UrlMap to include in the query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to update.
 *
 *  @return GTLRComputeQuery_UrlMapsUpdate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMap *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  Method: compute.urlMaps.validate
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_UrlMapsValidate : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the UrlMap resource to be validated as. */
@property(nonatomic, copy, nullable) NSString *urlMap;

/**
 *  Fetches a @c GTLRCompute_UrlMapsValidateResponse.
 *
 *  Runs static validation for the UrlMap. In particular, the tests of the
 *  provided UrlMap will be run. Calling this method does NOT create the UrlMap.
 *
 *  @param object The @c GTLRCompute_UrlMapsValidateRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param urlMap Name of the UrlMap resource to be validated as.
 *
 *  @return GTLRComputeQuery_UrlMapsValidate
 */
+ (instancetype)queryWithObject:(GTLRCompute_UrlMapsValidateRequest *)object
                        project:(NSString *)project
                         urlMap:(NSString *)urlMap;

@end

/**
 *  Retrieves an aggregated list of VPN gateways. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.vpnGateways.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnGatewaysAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_VpnGatewayAggregatedList.
 *
 *  Retrieves an aggregated list of VPN gateways. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_VpnGatewaysAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified VPN gateway.
 *
 *  Method: compute.vpnGateways.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnGatewaysDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the VPN gateway to delete. */
@property(nonatomic, copy, nullable) NSString *vpnGateway;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnGateway Name of the VPN gateway to delete.
 *
 *  @return GTLRComputeQuery_VpnGatewaysDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      vpnGateway:(NSString *)vpnGateway;

@end

/**
 *  Returns the specified VPN gateway.
 *
 *  Method: compute.vpnGateways.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnGatewaysGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the VPN gateway to return. */
@property(nonatomic, copy, nullable) NSString *vpnGateway;

/**
 *  Fetches a @c GTLRCompute_VpnGateway.
 *
 *  Returns the specified VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnGateway Name of the VPN gateway to return.
 *
 *  @return GTLRComputeQuery_VpnGatewaysGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      vpnGateway:(NSString *)vpnGateway;

@end

/**
 *  Returns the status for the specified VPN gateway.
 *
 *  Method: compute.vpnGateways.getStatus
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnGatewaysGetStatus : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the VPN gateway to return. */
@property(nonatomic, copy, nullable) NSString *vpnGateway;

/**
 *  Fetches a @c GTLRCompute_VpnGatewaysGetStatusResponse.
 *
 *  Returns the status for the specified VPN gateway.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnGateway Name of the VPN gateway to return.
 *
 *  @return GTLRComputeQuery_VpnGatewaysGetStatus
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                      vpnGateway:(NSString *)vpnGateway;

@end

/**
 *  Creates a VPN gateway in the specified project and region using the data
 *  included in the request.
 *
 *  Method: compute.vpnGateways.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnGatewaysInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a VPN gateway in the specified project and region using the data
 *  included in the request.
 *
 *  @param object The @c GTLRCompute_VpnGateway to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_VpnGatewaysInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_VpnGateway *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of VPN gateways available to the specified project and
 *  region.
 *
 *  Method: compute.vpnGateways.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnGatewaysList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_VpnGatewayList.
 *
 *  Retrieves a list of VPN gateways available to the specified project and
 *  region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_VpnGatewaysList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Sets the labels on a VpnGateway. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.vpnGateways.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnGatewaysSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a VpnGateway. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_VpnGatewaysSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Returns permissions that a caller has on the specified resource.
 *
 *  Method: compute.vpnGateways.testIamPermissions
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnGatewaysTestIamPermissions : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_TestPermissionsResponse.
 *
 *  Returns permissions that a caller has on the specified resource.
 *
 *  @param object The @c GTLRCompute_TestPermissionsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The name of the region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_VpnGatewaysTestIamPermissions
 */
+ (instancetype)queryWithObject:(GTLRCompute_TestPermissionsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Retrieves an aggregated list of VPN tunnels. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  Method: compute.vpnTunnels.aggregatedList
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsAggregatedList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Indicates whether every visible scope for each scope type (zone, region,
 *  global) should be included in the response. For new resource types added
 *  after this field, the flag has no effect as new resource types will always
 *  include every visible scope for each scope type in response. For resource
 *  types which predate this field, if this flag is omitted or false, only
 *  scopes of the scope types where the resource type is expected to be found
 *  will be included.
 */
@property(nonatomic, assign) BOOL includeAllScopes;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  The Shared VPC service project id or service project number for which
 *  aggregated list request is invoked for subnetworks list-usable api.
 */
@property(nonatomic, assign) long long serviceProjectNumber;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelAggregatedList.
 *
 *  Retrieves an aggregated list of VPN tunnels. To prevent failure, Google
 *  recommends that you set the `returnPartialSuccess` parameter to `true`.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsAggregatedList
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

/**
 *  Deletes the specified VpnTunnel resource.
 *
 *  Method: compute.vpnTunnels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsDelete : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name of the VpnTunnel resource to delete. */
@property(nonatomic, copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Deletes the specified VpnTunnel resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to delete.
 *
 *  @return GTLRComputeQuery_VpnTunnelsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Returns the specified VpnTunnel resource.
 *
 *  Method: compute.vpnTunnels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/** Name of the VpnTunnel resource to return. */
@property(nonatomic, copy, nullable) NSString *vpnTunnel;

/**
 *  Fetches a @c GTLRCompute_VpnTunnel.
 *
 *  Returns the specified VpnTunnel resource.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *  @param vpnTunnel Name of the VpnTunnel resource to return.
 *
 *  @return GTLRComputeQuery_VpnTunnelsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region
                       vpnTunnel:(NSString *)vpnTunnel;

@end

/**
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  Method: compute.vpnTunnels.insert
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsInsert : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Creates a VpnTunnel resource in the specified project and region using the
 *  data included in the request.
 *
 *  @param object The @c GTLRCompute_VpnTunnel to include in the query.
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsInsert
 */
+ (instancetype)queryWithObject:(GTLRCompute_VpnTunnel *)object
                        project:(NSString *)project
                         region:(NSString *)region;

@end

/**
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  Method: compute.vpnTunnels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_VpnTunnelsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** Name of the region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_VpnTunnelList.
 *
 *  Retrieves a list of VpnTunnel resources contained in the specified project
 *  and region.
 *
 *  @param project Project ID for this request.
 *  @param region Name of the region for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                          region:(NSString *)region;

@end

/**
 *  Sets the labels on a VpnTunnel. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  Method: compute.vpnTunnels.setLabels
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_VpnTunnelsSetLabels : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/** The region for this request. */
@property(nonatomic, copy, nullable) NSString *region;

/**
 *  An optional request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server will know to ignore the
 *  request if it has already been completed. For example, consider a situation
 *  where you make an initial request and the request times out. If you make the
 *  request again with the same request ID, the server can check if original
 *  operation with the same request ID was received, and if so, will ignore the
 *  second request. This prevents clients from accidentally creating duplicate
 *  commitments. The request ID must be a valid UUID with the exception that
 *  zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Name or id of the resource for this request. */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Sets the labels on a VpnTunnel. To learn more about labels, read the
 *  Labeling Resources documentation.
 *
 *  @param object The @c GTLRCompute_RegionSetLabelsRequest to include in the
 *    query.
 *  @param project Project ID for this request.
 *  @param region The region for this request.
 *  @param resource Name or id of the resource for this request.
 *
 *  @return GTLRComputeQuery_VpnTunnelsSetLabels
 */
+ (instancetype)queryWithObject:(GTLRCompute_RegionSetLabelsRequest *)object
                        project:(NSString *)project
                         region:(NSString *)region
                       resource:(NSString *)resource;

@end

/**
 *  Deletes the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 */
@interface GTLRComputeQuery_ZoneOperationsDelete : GTLRComputeQuery

/**
 *  Name of the Operations resource to delete, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Upon successful completion, the callback's object and error parameters will
 *  be nil. This query does not fetch an object.
 *
 *  Deletes the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to delete, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_ZoneOperationsDelete
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  Method: compute.zoneOperations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsGet : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Retrieves the specified zone-specific Operations resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_ZoneOperationsGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  Method: compute.zoneOperations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Name of the zone for request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_OperationList.
 *
 *  Retrieves a list of Operation resources contained within the specified zone.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for request.
 *
 *  @return GTLRComputeQuery_ZoneOperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Waits for the specified Operation resource to return as `DONE` or for the
 *  request to approach the 2 minute deadline, and retrieves the specified
 *  Operation resource. This method waits for no more than the 2 minutes and
 *  then returns the current state of the operation, which might be `DONE` or
 *  still in progress. This method is called on a best-effort basis.
 *  Specifically: - In uncommon cases, when the server is overloaded, the
 *  request might return before the default deadline is reached, or might return
 *  after zero seconds. - If the default deadline is reached, there is no
 *  guarantee that the operation is actually done when the method returns. Be
 *  prepared to retry if the operation is not `DONE`.
 *
 *  Method: compute.zoneOperations.wait
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZoneOperationsWait : GTLRComputeQuery

/**
 *  Name of the Operations resource to return, or its unique numeric identifier.
 */
@property(nonatomic, copy, nullable) NSString *operation;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone for this request.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Operation.
 *
 *  Waits for the specified Operation resource to return as `DONE` or for the
 *  request to approach the 2 minute deadline, and retrieves the specified
 *  Operation resource. This method waits for no more than the 2 minutes and
 *  then returns the current state of the operation, which might be `DONE` or
 *  still in progress. This method is called on a best-effort basis.
 *  Specifically: - In uncommon cases, when the server is overloaded, the
 *  request might return before the default deadline is reached, or might return
 *  after zero seconds. - If the default deadline is reached, there is no
 *  guarantee that the operation is actually done when the method returns. Be
 *  prepared to retry if the operation is not `DONE`.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone for this request.
 *  @param operation Name of the Operations resource to return, or its unique
 *    numeric identifier.
 *
 *  @return GTLRComputeQuery_ZoneOperationsWait
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty
                       operation:(NSString *)operation;

@end

/**
 *  Returns the specified Zone resource.
 *
 *  Method: compute.zones.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesGet : GTLRComputeQuery

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Name of the zone resource to return.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

/**
 *  Fetches a @c GTLRCompute_Zone.
 *
 *  Returns the specified Zone resource.
 *
 *  @param project Project ID for this request.
 *  @param zoneProperty Name of the zone resource to return.
 *
 *  @return GTLRComputeQuery_ZonesGet
 */
+ (instancetype)queryWithProject:(NSString *)project
                    zoneProperty:(NSString *)zoneProperty;

@end

/**
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  Method: compute.zones.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeCompute
 *    @c kGTLRAuthScopeComputeCloudPlatform
 *    @c kGTLRAuthScopeComputeReadonly
 */
@interface GTLRComputeQuery_ZonesList : GTLRComputeQuery

/**
 *  A filter expression that filters resources listed in the response. Most
 *  Compute resources support two types of filter expressions: expressions that
 *  support regular expressions and expressions that follow API improvement
 *  proposal AIP-160. These two types of filter expressions cannot be mixed in
 *  one request. If you want to use AIP-160, your expression must specify the
 *  field name, an operator, and the value that you want to use for filtering.
 *  The value must be a string, a number, or a boolean. The operator must be
 *  either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are
 *  filtering Compute Engine instances, you can exclude instances named
 *  `example-instance` by specifying `name != example-instance`. The `:*`
 *  comparison can be used to test whether a key has been defined. For example,
 *  to find all objects with `owner` label use: ``` labels.owner:* ``` You can
 *  also filter nested fields. For example, you could specify
 *  `scheduling.automaticRestart = false` to include instances only if they are
 *  not scheduled for automatic restarts. You can use filtering on nested fields
 *  to filter based on resource labels. To filter on multiple expressions,
 *  provide each separate expression within parentheses. For example: ```
 *  (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By
 *  default, each expression is an `AND` expression. However, you can include
 *  `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform =
 *  "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND
 *  (scheduling.automaticRestart = true) ``` If you want to use a regular
 *  expression, use the `eq` (equal) or `ne` (not equal) operator against a
 *  single un-parenthesized expression with or without quotes or against
 *  multiple parenthesized expressions. Examples: `fieldname eq unquoted
 *  literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted
 *  literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal
 *  value is interpreted as a regular expression using Google RE2 library
 *  syntax. The literal value must match the entire field. For example, to
 *  filter for instances that do not end with name "instance", you would use
 *  `name ne .*instance`. You cannot combine constraints on multiple fields
 *  using regular expressions.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The maximum number of results per page that should be returned. If the
 *  number of available results is larger than `maxResults`, Compute Engine
 *  returns a `nextPageToken` that can be used to get the next page of results
 *  in subsequent list requests. Acceptable values are `0` to `500`, inclusive.
 *  (Default: `500`)
 *
 *  @note If not set, the documented server-side default will be 500.
 */
@property(nonatomic, assign) NSUInteger maxResults;

/**
 *  Sorts list results by a certain order. By default, results are returned in
 *  alphanumerical order based on the resource name. You can also sort results
 *  in descending order based on the creation timestamp using
 *  `orderBy="creationTimestamp desc"`. This sorts results based on the
 *  `creationTimestamp` field in reverse chronological order (newest result
 *  first). Use this to sort resources like operations so that the newest
 *  operation is returned first. Currently, only sorting by `name` or
 *  `creationTimestamp desc` is supported.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  Specifies a page token to use. Set `pageToken` to the `nextPageToken`
 *  returned by a previous list request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Project ID for this request. */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Opt-in for partial success behavior which provides partial results in case
 *  of failure. The default value is false. For example, when partial success
 *  behavior is enabled, aggregatedList for a single zone scope either returns
 *  all resources in the zone or no resources, with an error code.
 */
@property(nonatomic, assign) BOOL returnPartialSuccess;

/**
 *  Fetches a @c GTLRCompute_ZoneList.
 *
 *  Retrieves the list of Zone resources available to the specified project.
 *
 *  @param project Project ID for this request.
 *
 *  @return GTLRComputeQuery_ZonesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithProject:(NSString *)project;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
