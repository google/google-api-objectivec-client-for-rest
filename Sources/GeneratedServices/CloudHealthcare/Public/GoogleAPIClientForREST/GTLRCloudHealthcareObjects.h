// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Healthcare API (healthcare/v1)
// Description:
//   Manage, store, and access healthcare data in Google Cloud Platform.
// Documentation:
//   https://cloud.google.com/healthcare

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCloudHealthcare_Attribute;
@class GTLRCloudHealthcare_AttributeDefinition;
@class GTLRCloudHealthcare_AuditConfig;
@class GTLRCloudHealthcare_AuditLogConfig;
@class GTLRCloudHealthcare_Binding;
@class GTLRCloudHealthcare_CharacterMaskConfig;
@class GTLRCloudHealthcare_CheckDataAccessRequest_RequestAttributes;
@class GTLRCloudHealthcare_CheckDataAccessResponse_ConsentDetails;
@class GTLRCloudHealthcare_Consent;
@class GTLRCloudHealthcare_Consent_Metadata;
@class GTLRCloudHealthcare_ConsentArtifact;
@class GTLRCloudHealthcare_ConsentArtifact_Metadata;
@class GTLRCloudHealthcare_ConsentEvaluation;
@class GTLRCloudHealthcare_ConsentList;
@class GTLRCloudHealthcare_ConsentStore;
@class GTLRCloudHealthcare_ConsentStore_Labels;
@class GTLRCloudHealthcare_CryptoHashConfig;
@class GTLRCloudHealthcare_Dataset;
@class GTLRCloudHealthcare_DateShiftConfig;
@class GTLRCloudHealthcare_DeidentifiedStoreDestination;
@class GTLRCloudHealthcare_DeidentifyConfig;
@class GTLRCloudHealthcare_DicomConfig;
@class GTLRCloudHealthcare_DicomFilterConfig;
@class GTLRCloudHealthcare_DicomStore;
@class GTLRCloudHealthcare_DicomStore_Labels;
@class GTLRCloudHealthcare_Entity;
@class GTLRCloudHealthcare_EntityMention;
@class GTLRCloudHealthcare_EntityMentionRelationship;
@class GTLRCloudHealthcare_EvaluateUserConsentsRequest_RequestAttributes;
@class GTLRCloudHealthcare_EvaluateUserConsentsRequest_ResourceAttributes;
@class GTLRCloudHealthcare_Expr;
@class GTLRCloudHealthcare_Feature;
@class GTLRCloudHealthcare_FhirConfig;
@class GTLRCloudHealthcare_FhirFilter;
@class GTLRCloudHealthcare_FhirStore;
@class GTLRCloudHealthcare_FhirStore_Labels;
@class GTLRCloudHealthcare_Field;
@class GTLRCloudHealthcare_FieldMetadata;
@class GTLRCloudHealthcare_GcsDestination;
@class GTLRCloudHealthcare_GcsSource;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1ConsentGcsDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1ConsentPolicy;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomGcsDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomGcsSource;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirGcsDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirGcsSource;
@class GTLRCloudHealthcare_GroupOrSegment;
@class GTLRCloudHealthcare_Hl7SchemaConfig;
@class GTLRCloudHealthcare_Hl7SchemaConfig_MessageSchemaConfigs;
@class GTLRCloudHealthcare_Hl7TypesConfig;
@class GTLRCloudHealthcare_Hl7V2NotificationConfig;
@class GTLRCloudHealthcare_Hl7V2Store;
@class GTLRCloudHealthcare_Hl7V2Store_Labels;
@class GTLRCloudHealthcare_HttpBody_Extensions_Item;
@class GTLRCloudHealthcare_Image;
@class GTLRCloudHealthcare_ImageConfig;
@class GTLRCloudHealthcare_InfoTypeTransformation;
@class GTLRCloudHealthcare_KmsWrappedCryptoKey;
@class GTLRCloudHealthcare_LinkedEntity;
@class GTLRCloudHealthcare_Location;
@class GTLRCloudHealthcare_Location_Labels;
@class GTLRCloudHealthcare_Location_Metadata;
@class GTLRCloudHealthcare_Message;
@class GTLRCloudHealthcare_Message_Labels;
@class GTLRCloudHealthcare_NotificationConfig;
@class GTLRCloudHealthcare_Operation;
@class GTLRCloudHealthcare_Operation_Metadata;
@class GTLRCloudHealthcare_Operation_Response;
@class GTLRCloudHealthcare_ParsedData;
@class GTLRCloudHealthcare_ParserConfig;
@class GTLRCloudHealthcare_PatientId;
@class GTLRCloudHealthcare_Policy;
@class GTLRCloudHealthcare_ProgressCounter;
@class GTLRCloudHealthcare_QueryAccessibleDataRequest_RequestAttributes;
@class GTLRCloudHealthcare_QueryAccessibleDataRequest_ResourceAttributes;
@class GTLRCloudHealthcare_RedactConfig;
@class GTLRCloudHealthcare_ReplaceWithInfoTypeConfig;
@class GTLRCloudHealthcare_Resources;
@class GTLRCloudHealthcare_Result;
@class GTLRCloudHealthcare_Result_ConsentDetails;
@class GTLRCloudHealthcare_SchemaConfig;
@class GTLRCloudHealthcare_SchemaGroup;
@class GTLRCloudHealthcare_SchemaPackage;
@class GTLRCloudHealthcare_SchemaSegment;
@class GTLRCloudHealthcare_SchematizedData;
@class GTLRCloudHealthcare_Segment;
@class GTLRCloudHealthcare_Segment_Fields;
@class GTLRCloudHealthcare_Signature;
@class GTLRCloudHealthcare_Signature_Metadata;
@class GTLRCloudHealthcare_Status;
@class GTLRCloudHealthcare_Status_Details_Item;
@class GTLRCloudHealthcare_StreamConfig;
@class GTLRCloudHealthcare_TagFilterList;
@class GTLRCloudHealthcare_TextConfig;
@class GTLRCloudHealthcare_TextSpan;
@class GTLRCloudHealthcare_Type;
@class GTLRCloudHealthcare_UserDataMapping;
@class GTLRCloudHealthcare_ValidationConfig;
@class GTLRCloudHealthcare_VersionSource;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_AnalyzeEntitiesRequest.licensedVocabularies

/**
 *  ICD-10-CM vocabulary
 *
 *  Value: "ICD10CM"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AnalyzeEntitiesRequest_LicensedVocabularies_Icd10cm;
/**
 *  No licensed vocabulary specified.
 *
 *  Value: "LICENSED_VOCABULARY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AnalyzeEntitiesRequest_LicensedVocabularies_LicensedVocabularyUnspecified;
/**
 *  SNOMED CT (US version) vocabulary
 *
 *  Value: "SNOMEDCT_US"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AnalyzeEntitiesRequest_LicensedVocabularies_SnomedctUs;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_AttributeDefinition.category

/**
 *  No category specified. This option is invalid.
 *
 *  Value: "CATEGORY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AttributeDefinition_Category_CategoryUnspecified;
/**
 *  Specify this category when this attribute describes the properties of
 *  requests. For example, requester's role or requester's organization.
 *
 *  Value: "REQUEST"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AttributeDefinition_Category_Request;
/**
 *  Specify this category when this attribute describes the properties of
 *  resources. For example, data anonymity or data type.
 *
 *  Value: "RESOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AttributeDefinition_Category_Resource;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_CheckDataAccessRequest.responseView

/**
 *  Only the `consented` field is populated in CheckDataAccessResponse.
 *
 *  Value: "BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_CheckDataAccessRequest_ResponseView_Basic;
/**
 *  All fields within CheckDataAccessResponse are populated. When set to `FULL`,
 *  all `ACTIVE` Consents are evaluated even if a matching policy is found
 *  during evaluation.
 *
 *  Value: "FULL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_CheckDataAccessRequest_ResponseView_Full;
/**
 *  No response view specified. The API will default to the BASIC view.
 *
 *  Value: "RESPONSE_VIEW_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_CheckDataAccessRequest_ResponseView_ResponseViewUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_Consent.state

/**
 *  The Consent is active and is considered when evaluating a user's consent on
 *  resources.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Consent_State_Active;
/**
 *  The archived state is currently not being used.
 *
 *  Value: "ARCHIVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Consent_State_Archived;
/**
 *  A draft Consent is not considered when evaluating a user's consent on
 *  resources unless explicitly specified.
 *
 *  Value: "DRAFT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Consent_State_Draft;
/**
 *  When a draft Consent is rejected by a user, it is set to a rejected state. A
 *  rejected Consent is not considered when evaluating a user's consent on
 *  resources.
 *
 *  Value: "REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Consent_State_Rejected;
/**
 *  A revoked Consent is not considered when evaluating a user's consent on
 *  resources.
 *
 *  Value: "REVOKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Consent_State_Revoked;
/**
 *  No state specified. Treated as ACTIVE only at the time of resource creation.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Consent_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_ConsentEvaluation.evaluationResult

/**
 *  No evaluation result specified. This option is invalid.
 *
 *  Value: "EVALUATION_RESULT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_EvaluationResultUnspecified;
/**
 *  The Consent has at least one policy that matches the `resource_attributes`
 *  of the evaluated resource, and at least one `authorization_rule` was
 *  satisfied.
 *
 *  Value: "HAS_SATISFIED_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_HasSatisfiedPolicy;
/**
 *  The Consent does not have a policy that matches the `resource_attributes` of
 *  the evaluated resource.
 *
 *  Value: "NO_MATCHING_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_NoMatchingPolicy;
/**
 *  The Consent has at least one policy that matches the `resource_attributes`
 *  of the evaluated resource, but no `authorization_rule` was satisfied.
 *
 *  Value: "NO_SATISFIED_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_NoSatisfiedPolicy;
/**
 *  The Consent is not applicable to the requested access determination. For
 *  example, the Consent does not apply to the user for which the access
 *  determination is requested, or it has a `state` of `REVOKED`, or it has
 *  expired.
 *
 *  Value: "NOT_APPLICABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_NotApplicable;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_DicomConfig.filterProfile

/**
 *  Remove tags based on DICOM Standard's Attribute Confidentiality Basic
 *  Profile (DICOM Standard Edition 2018e)
 *  http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html.
 *
 *  Value: "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_AttributeConfidentialityBasicProfile;
/**
 *  Inspects within tag contents and replaces sensitive text. The process can be
 *  configured using the TextConfig. Applies to all tags with the following
 *  Value Representation names: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
 *
 *  Value: "DEIDENTIFY_TAG_CONTENTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_DeidentifyTagContents;
/**
 *  Keep all tags.
 *
 *  Value: "KEEP_ALL_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_KeepAllProfile;
/**
 *  Keep only tags required to produce valid DICOM.
 *
 *  Value: "MINIMAL_KEEP_LIST_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_MinimalKeepListProfile;
/**
 *  No tag filtration profile provided. Same as KEEP_ALL_PROFILE.
 *
 *  Value: "TAG_FILTER_PROFILE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_TagFilterProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_EvaluateUserConsentsRequest.responseView

/**
 *  Only the `data_id` and `consented` fields are populated in the response.
 *
 *  Value: "BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_EvaluateUserConsentsRequest_ResponseView_Basic;
/**
 *  All fields within the response are populated. When set to `FULL`, all
 *  `ACTIVE` Consents are evaluated even if a matching policy is found during
 *  evaluation.
 *
 *  Value: "FULL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_EvaluateUserConsentsRequest_ResponseView_Full;
/**
 *  No response view specified. The API will default to the BASIC view.
 *
 *  Value: "RESPONSE_VIEW_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_EvaluateUserConsentsRequest_ResponseView_ResponseViewUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_FhirStore.complexDataTypeReferenceParsing

/**
 *  No parsing behavior specified. This is the same as DISABLED for backwards
 *  compatibility.
 *
 *  Value: "COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_ComplexDataTypeReferenceParsing_ComplexDataTypeReferenceParsingUnspecified;
/**
 *  References in complex data types are ignored.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_ComplexDataTypeReferenceParsing_Disabled;
/**
 *  References in complex data types are parsed.
 *
 *  Value: "ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_ComplexDataTypeReferenceParsing_Enabled;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_FhirStore.version

/**
 *  Draft Standard for Trial Use, [Release 2](https://www.hl7.org/fhir/DSTU2)
 *
 *  Value: "DSTU2"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_Version_Dstu2;
/**
 *  [Release 4](https://www.hl7.org/fhir/R4)
 *
 *  Value: "R4"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_Version_R4;
/**
 *  Standard for Trial Use, [Release 3](https://www.hl7.org/fhir/STU3)
 *
 *  Value: "STU3"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_Version_Stu3;
/**
 *  Users must specify a version on store creation or an error is returned.
 *
 *  Value: "VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FhirStore_Version_VersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_FieldMetadata.action

/**
 *  No action specified.
 *
 *  Value: "ACTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_ActionUnspecified;
/**
 *  Do not transform.
 *
 *  Value: "DO_NOT_TRANSFORM"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_DoNotTransform;
/**
 *  Inspect and transform any found PHI.
 *
 *  Value: "INSPECT_AND_TRANSFORM"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_InspectAndTransform;
/**
 *  Transform the entire field.
 *
 *  Value: "TRANSFORM"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_Transform;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_GcsDestination.contentStructure

/**
 *  If the content structure is not specified, the default value `MESSAGE_JSON`
 *  will be used.
 *
 *  Value: "CONTENT_STRUCTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_ContentStructure_ContentStructureUnspecified;
/**
 *  Messages are printed using the JSON format returned from the `GetMessage`
 *  API. Messages are delimited with newlines.
 *
 *  Value: "MESSAGE_JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_ContentStructure_MessageJson;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_GcsDestination.messageView

/**
 *  Server responses include only the name field.
 *
 *  Value: "BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_MessageView_Basic;
/**
 *  Server responses include all the message fields.
 *
 *  Value: "FULL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_MessageView_Full;
/**
 *  Not specified, equivalent to FULL.
 *
 *  Value: "MESSAGE_VIEW_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_MessageView_MessageViewUnspecified;
/**
 *  Server responses include all the message fields except data field, and
 *  schematized_data fields.
 *
 *  Value: "PARSED_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_MessageView_ParsedOnly;
/**
 *  Server responses include all the message fields except parsed_data field,
 *  and schematized_data fields.
 *
 *  Value: "RAW_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_MessageView_RawOnly;
/**
 *  Server responses include all the message fields except data and parsed_data
 *  fields.
 *
 *  Value: "SCHEMATIZED_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GcsDestination_MessageView_SchematizedOnly;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination.writeDisposition

/**
 *  Append data to the destination table.
 *
 *  Value: "WRITE_APPEND"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteAppend;
/**
 *  Default behavior is the same as WRITE_EMPTY.
 *
 *  Value: "WRITE_DISPOSITION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteDispositionUnspecified;
/**
 *  Only export data if the destination table is empty.
 *
 *  Value: "WRITE_EMPTY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteEmpty;
/**
 *  Erase all existing data in the destination table before writing the
 *  instances.
 *
 *  Value: "WRITE_TRUNCATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteTruncate;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination.writeDisposition

/**
 *  Append data to the destination tables.
 *
 *  Value: "WRITE_APPEND"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteAppend;
/**
 *  Default behavior is the same as WRITE_EMPTY.
 *
 *  Value: "WRITE_DISPOSITION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteDispositionUnspecified;
/**
 *  Only export data if the destination tables are empty.
 *
 *  Value: "WRITE_EMPTY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteEmpty;
/**
 *  Erase all existing data in the destination tables before writing the FHIR
 *  resources.
 *
 *  Value: "WRITE_TRUNCATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteTruncate;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_ImageConfig.textRedactionMode

/**
 *  Redact all text.
 *
 *  Value: "REDACT_ALL_TEXT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactAllText;
/**
 *  Do not redact text.
 *
 *  Value: "REDACT_NO_TEXT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactNoText;
/**
 *  Redact sensitive text. Uses the set of [Default DICOM
 *  InfoTypes](https://cloud.google.com/healthcare-api/docs/how-tos/dicom-deidentify#default_dicom_infotypes).
 *
 *  Value: "REDACT_SENSITIVE_TEXT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactSensitiveText;
/**
 *  No text redaction specified. Same as REDACT_NO_TEXT.
 *
 *  Value: "TEXT_REDACTION_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_TextRedactionModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_ImportResourcesRequest.contentStructure

/**
 *  The source file contains one or more lines of newline-delimited JSON
 *  (ndjson). Each line is a bundle that contains one or more resources.
 *
 *  Value: "BUNDLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Bundle;
/**
 *  The entire file is one JSON bundle. The JSON can span multiple lines.
 *
 *  Value: "BUNDLE_PRETTY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_BundlePretty;
/**
 *  If the content structure is not specified, the default value `BUNDLE` is
 *  used.
 *
 *  Value: "CONTENT_STRUCTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ContentStructureUnspecified;
/**
 *  The source file contains one or more lines of newline-delimited JSON
 *  (ndjson). Each line is a single resource.
 *
 *  Value: "RESOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Resource;
/**
 *  The entire file is one JSON resource. The JSON can span multiple lines.
 *
 *  Value: "RESOURCE_PRETTY"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ResourcePretty;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_ParserConfig.version

/**
 *  Unspecified parser version, equivalent to V1.
 *
 *  Value: "PARSER_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ParserConfig_Version_ParserVersionUnspecified;
/**
 *  The `parsed_data` includes every given non-empty message field except the
 *  Field Separator (MSH-1) field. As a result, the parsed MSH segment starts
 *  with the MSH-2 field and the field numbers are off-by-one with respect to
 *  the HL7 standard.
 *
 *  Value: "V1"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ParserConfig_Version_V1;
/**
 *  The `parsed_data` includes every given non-empty message field.
 *
 *  Value: "V2"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ParserConfig_Version_V2;
/**
 *  This version is the same as V2, with the following change. The `parsed_data`
 *  contains unescaped escaped field separators, component separators,
 *  sub-component separators, repetition separators, escape characters, and
 *  truncation characters. If `schema` is specified, the schematized parser uses
 *  improved parsing heuristics compared to previous versions.
 *
 *  Value: "V3"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_ParserConfig_Version_V3;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_SchemaConfig.schemaType

/**
 *  Analytics schema defined by the FHIR community. See
 *  https://github.com/FHIR/sql-on-fhir/blob/master/sql-on-fhir.md. BigQuery
 *  only allows a maximum of 10,000 columns per table. Due to this limitation,
 *  the server will not generate schemas for fields of type `Resource`, which
 *  can hold any resource type. The affected fields are
 *  `Parameters.parameter.resource`, `Bundle.entry.resource`, and
 *  `Bundle.entry.response.outcome`.
 *
 *  Value: "ANALYTICS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaConfig_SchemaType_Analytics;
/**
 *  Analytics V2, similar to schema defined by the FHIR community, with added
 *  support for extensions with one or more occurrences and contained resources
 *  in stringified JSON. Analytics V2 uses more space in the destination table
 *  than Analytics V1.
 *
 *  Value: "ANALYTICS_V2"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaConfig_SchemaType_AnalyticsV2;
/**
 *  No schema type specified. This type is unsupported.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaConfig_SchemaType_SchemaTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_SchemaPackage.schematizedParsingType

/**
 *  Messages that fail to parse are rejected from ingestion/insertion and return
 *  an error code.
 *
 *  Value: "HARD_FAIL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_SchematizedParsingType_HardFail;
/**
 *  Unspecified schematized parsing type, equivalent to `SOFT_FAIL`.
 *
 *  Value: "SCHEMATIZED_PARSING_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_SchematizedParsingType_SchematizedParsingTypeUnspecified;
/**
 *  Messages that fail to parse are still stored and ACKed but a parser error is
 *  stored in place of the schematized data.
 *
 *  Value: "SOFT_FAIL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_SchematizedParsingType_SoftFail;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_SchemaPackage.unexpectedSegmentHandling

/**
 *  Unexpected segments fail to parse and return an error.
 *
 *  Value: "FAIL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_Fail;
/**
 *  Unexpected segments do not fail, but are parsed in place and added to the
 *  current group. If a segment has a type definition, it is used, otherwise it
 *  is parsed as VARIES.
 *
 *  Value: "PARSE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_Parse;
/**
 *  Unexpected segments do not fail, but are omitted from the output.
 *
 *  Value: "SKIP"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_Skip;
/**
 *  Unspecified handling mode, equivalent to FAIL.
 *
 *  Value: "UNEXPECTED_SEGMENT_HANDLING_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_UnexpectedSegmentHandlingModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_Type.primitive

/**
 *  Not a primitive.
 *
 *  Value: "PRIMITIVE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Type_Primitive_PrimitiveUnspecified;
/**
 *  String primitive.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Type_Primitive_String;
/**
 *  Like STRING, but all delimiters below this element are ignored.
 *
 *  Value: "UNESCAPED_STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Type_Primitive_UnescapedString;
/**
 *  Element that can have unschematized children.
 *
 *  Value: "VARIES"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudHealthcare_Type_Primitive_Varies;

/**
 *  Activates the latest revision of the specified Consent by committing a new
 *  revision with `state` updated to `ACTIVE`. If the latest revision of the
 *  given Consent is in the `ACTIVE` state, no new revision is committed. A
 *  FAILED_PRECONDITION error occurs if the latest revision of the given consent
 *  is in the `REJECTED` or `REVOKED` state.
 */
@interface GTLRCloudHealthcare_ActivateConsentRequest : GTLRObject

/**
 *  Required. The resource name of the Consent artifact that contains
 *  documentation of the user's consent, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
 *  If the draft Consent had a Consent artifact, this Consent artifact
 *  overwrites it.
 */
@property(nonatomic, copy, nullable) NSString *consentArtifact;

/** Timestamp in UTC of when this Consent is considered expired. */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/** The time to live for this Consent from when it is marked as active. */
@property(nonatomic, strong, nullable) GTLRDuration *ttl;

@end


/**
 *  The request to analyze healthcare entities in a document.
 */
@interface GTLRCloudHealthcare_AnalyzeEntitiesRequest : GTLRObject

/** document_content is a document to be annotated. */
@property(nonatomic, copy, nullable) NSString *documentContent;

/**
 *  A list of licensed vocabularies to use in the request, in addition to the
 *  default unlicensed vocabularies.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *licensedVocabularies;

@end


/**
 *  Includes recognized entity mentions and relationships between them.
 */
@interface GTLRCloudHealthcare_AnalyzeEntitiesResponse : GTLRObject

/**
 *  The union of all the candidate entities that the entity_mentions in this
 *  response could link to. These are UMLS concepts or normalized mention
 *  content.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Entity *> *entities;

/**
 *  entity_mentions contains all the annotated medical entities that were
 *  mentioned in the provided document.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_EntityMention *> *entityMentions;

/**
 *  relationships contains all the binary relationships that were identified
 *  between entity mentions within the provided document.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_EntityMentionRelationship *> *relationships;

@end


/**
 *  Archives the specified User data mapping.
 */
@interface GTLRCloudHealthcare_ArchiveUserDataMappingRequest : GTLRObject
@end


/**
 *  Archives the specified User data mapping.
 */
@interface GTLRCloudHealthcare_ArchiveUserDataMappingResponse : GTLRObject
@end


/**
 *  An attribute value for a Consent or User data mapping. Each Attribute must
 *  have a corresponding AttributeDefinition in the consent store that defines
 *  the default and allowed values.
 */
@interface GTLRCloudHealthcare_Attribute : GTLRObject

/** Indicates the name of an attribute defined in the consent store. */
@property(nonatomic, copy, nullable) NSString *attributeDefinitionId;

/**
 *  Required. The value of the attribute. Must be an acceptable value as defined
 *  in the consent store. For example, if the consent store defines "data type"
 *  with acceptable values "questionnaire" and "step-count", when the attribute
 *  name is data type, this field must contain one of those values.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  A client-defined consent attribute.
 */
@interface GTLRCloudHealthcare_AttributeDefinition : GTLRObject

/**
 *  Required. Possible values for the attribute. The number of allowed values
 *  must not exceed 500. An empty list is invalid. The list can only be expanded
 *  after creation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedValues;

/**
 *  Required. The category of the attribute. The value of this field cannot be
 *  changed after creation.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_AttributeDefinition_Category_CategoryUnspecified
 *        No category specified. This option is invalid. (Value:
 *        "CATEGORY_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_AttributeDefinition_Category_Request Specify
 *        this category when this attribute describes the properties of
 *        requests. For example, requester's role or requester's organization.
 *        (Value: "REQUEST")
 *    @arg @c kGTLRCloudHealthcare_AttributeDefinition_Category_Resource Specify
 *        this category when this attribute describes the properties of
 *        resources. For example, data anonymity or data type. (Value:
 *        "RESOURCE")
 */
@property(nonatomic, copy, nullable) NSString *category;

/**
 *  Optional. Default values of the attribute in Consents. If no default values
 *  are specified, it defaults to an empty value.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *consentDefaultValues;

/**
 *  Optional. Default value of the attribute in User data mappings. If no
 *  default value is specified, it defaults to an empty value. This field is
 *  only applicable to attributes of the category `RESOURCE`.
 */
@property(nonatomic, copy, nullable) NSString *dataMappingDefaultValue;

/**
 *  Optional. A description of the attribute.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Resource name of the Attribute definition, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/attributeDefinitions/{attribute_definition_id}`.
 *  Cannot be changed after creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRCloudHealthcare_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRCloudHealthcare_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRCloudHealthcare_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
 *  An email address (plus unique identifier) representing a user that has been
 *  recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRCloudHealthcare_CancelOperationRequest : GTLRObject
@end


/**
 *  Mask a string by replacing its characters with a fixed character.
 */
@interface GTLRCloudHealthcare_CharacterMaskConfig : GTLRObject

/**
 *  Character to mask the sensitive values. If not supplied, defaults to "*".
 */
@property(nonatomic, copy, nullable) NSString *maskingCharacter;

@end


/**
 *  Checks if a particular data_id of a User data mapping in the given consent
 *  store is consented for a given use.
 */
@interface GTLRCloudHealthcare_CheckDataAccessRequest : GTLRObject

/**
 *  Optional. Specific Consents to evaluate the access request against. These
 *  Consents must have the same `user_id` as the evaluated User data mapping,
 *  must exist in the current `consent_store`, and have a `state` of either
 *  `ACTIVE` or `DRAFT`. A maximum of 100 Consents can be provided here. If no
 *  selection is specified, the access request is evaluated against all `ACTIVE`
 *  unexpired Consents with the same `user_id` as the evaluated User data
 *  mapping.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ConsentList *consentList;

/**
 *  Required. The unique identifier of the resource to check access for. This
 *  identifier must correspond to a User data mapping in the given consent
 *  store.
 */
@property(nonatomic, copy, nullable) NSString *dataId;

/** The values of request attributes associated with this access request. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_CheckDataAccessRequest_RequestAttributes *requestAttributes;

/**
 *  Optional. The view for CheckDataAccessResponse. If unspecified, defaults to
 *  `BASIC` and returns `consented` as `TRUE` or `FALSE`.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_CheckDataAccessRequest_ResponseView_Basic
 *        Only the `consented` field is populated in CheckDataAccessResponse.
 *        (Value: "BASIC")
 *    @arg @c kGTLRCloudHealthcare_CheckDataAccessRequest_ResponseView_Full All
 *        fields within CheckDataAccessResponse are populated. When set to
 *        `FULL`, all `ACTIVE` Consents are evaluated even if a matching policy
 *        is found during evaluation. (Value: "FULL")
 *    @arg @c kGTLRCloudHealthcare_CheckDataAccessRequest_ResponseView_ResponseViewUnspecified
 *        No response view specified. The API will default to the BASIC view.
 *        (Value: "RESPONSE_VIEW_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *responseView;

@end


/**
 *  The values of request attributes associated with this access request.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_CheckDataAccessRequest_RequestAttributes : GTLRObject
@end


/**
 *  Checks if a particular data_id of a User data mapping in the given consent
 *  store is consented for a given use.
 */
@interface GTLRCloudHealthcare_CheckDataAccessResponse : GTLRObject

/**
 *  The resource names of all evaluated Consents mapped to their evaluation.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_CheckDataAccessResponse_ConsentDetails *consentDetails;

/**
 *  Whether the requested resource is consented for the given use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *consented;

@end


/**
 *  The resource names of all evaluated Consents mapped to their evaluation.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudHealthcare_ConsentEvaluation. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_CheckDataAccessResponse_ConsentDetails : GTLRObject
@end


/**
 *  Represents a user's consent.
 */
@interface GTLRCloudHealthcare_Consent : GTLRObject

/**
 *  Required. The resource name of the Consent artifact that contains proof of
 *  the end user's consent, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
 */
@property(nonatomic, copy, nullable) NSString *consentArtifact;

/** Timestamp in UTC of when this Consent is considered expired. */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Optional. User-supplied key-value pairs used to organize Consent resources.
 *  Metadata keys must: - be between 1 and 63 characters long - have a UTF-8
 *  encoding of maximum 128 bytes - begin with a letter - consist of up to 63
 *  characters including lowercase letters, numeric characters, underscores, and
 *  dashes Metadata values must be: - be between 1 and 63 characters long - have
 *  a UTF-8 encoding of maximum 128 bytes - consist of up to 63 characters
 *  including lowercase letters, numeric characters, underscores, and dashes No
 *  more than 64 metadata entries can be associated with a given consent.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Consent_Metadata *metadata;

/**
 *  Resource name of the Consent, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consents/{consent_id}`.
 *  Cannot be changed after creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Represents a user's consent in terms of the resources that can be
 *  accessed and under what conditions.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_GoogleCloudHealthcareV1ConsentPolicy *> *policies;

/** Output only. The timestamp that the revision was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *revisionCreateTime;

/**
 *  Output only. The revision ID of the Consent. The format is an 8-character
 *  hexadecimal string. Refer to a specific revision of a Consent by appending
 *  `\@{revision_id}` to the Consent's resource name.
 */
@property(nonatomic, copy, nullable) NSString *revisionId;

/**
 *  Required. Indicates the current state of this Consent.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_Consent_State_Active The Consent is active
 *        and is considered when evaluating a user's consent on resources.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRCloudHealthcare_Consent_State_Archived The archived state is
 *        currently not being used. (Value: "ARCHIVED")
 *    @arg @c kGTLRCloudHealthcare_Consent_State_Draft A draft Consent is not
 *        considered when evaluating a user's consent on resources unless
 *        explicitly specified. (Value: "DRAFT")
 *    @arg @c kGTLRCloudHealthcare_Consent_State_Rejected When a draft Consent
 *        is rejected by a user, it is set to a rejected state. A rejected
 *        Consent is not considered when evaluating a user's consent on
 *        resources. (Value: "REJECTED")
 *    @arg @c kGTLRCloudHealthcare_Consent_State_Revoked A revoked Consent is
 *        not considered when evaluating a user's consent on resources. (Value:
 *        "REVOKED")
 *    @arg @c kGTLRCloudHealthcare_Consent_State_StateUnspecified No state
 *        specified. Treated as ACTIVE only at the time of resource creation.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Input only. The time to live for this Consent from when it is created. */
@property(nonatomic, strong, nullable) GTLRDuration *ttl;

/** Required. User's UUID provided by the client. */
@property(nonatomic, copy, nullable) NSString *userId;

@end


/**
 *  Optional. User-supplied key-value pairs used to organize Consent resources.
 *  Metadata keys must: - be between 1 and 63 characters long - have a UTF-8
 *  encoding of maximum 128 bytes - begin with a letter - consist of up to 63
 *  characters including lowercase letters, numeric characters, underscores, and
 *  dashes Metadata values must be: - be between 1 and 63 characters long - have
 *  a UTF-8 encoding of maximum 128 bytes - consist of up to 63 characters
 *  including lowercase letters, numeric characters, underscores, and dashes No
 *  more than 64 metadata entries can be associated with a given consent.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Consent_Metadata : GTLRObject
@end


/**
 *  Documentation of a user's consent.
 */
@interface GTLRCloudHealthcare_ConsentArtifact : GTLRObject

/**
 *  Optional. Screenshots, PDFs, or other binary information documenting the
 *  user's consent.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Image *> *consentContentScreenshots;

/**
 *  Optional. An string indicating the version of the consent information shown
 *  to the user.
 */
@property(nonatomic, copy, nullable) NSString *consentContentVersion;

/** Optional. A signature from a guardian. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Signature *guardianSignature;

/**
 *  Optional. Metadata associated with the Consent artifact. For example, the
 *  consent locale or user agent version.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ConsentArtifact_Metadata *metadata;

/**
 *  Resource name of the Consent artifact, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
 *  Cannot be changed after creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. User's UUID provided by the client. */
@property(nonatomic, copy, nullable) NSString *userId;

/** Optional. User's signature. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Signature *userSignature;

/** Optional. A signature from a witness. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Signature *witnessSignature;

@end


/**
 *  Optional. Metadata associated with the Consent artifact. For example, the
 *  consent locale or user agent version.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_ConsentArtifact_Metadata : GTLRObject
@end


/**
 *  The detailed evaluation of a particular Consent.
 */
@interface GTLRCloudHealthcare_ConsentEvaluation : GTLRObject

/**
 *  The evaluation result.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_EvaluationResultUnspecified
 *        No evaluation result specified. This option is invalid. (Value:
 *        "EVALUATION_RESULT_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_HasSatisfiedPolicy
 *        The Consent has at least one policy that matches the
 *        `resource_attributes` of the evaluated resource, and at least one
 *        `authorization_rule` was satisfied. (Value: "HAS_SATISFIED_POLICY")
 *    @arg @c kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_NoMatchingPolicy
 *        The Consent does not have a policy that matches the
 *        `resource_attributes` of the evaluated resource. (Value:
 *        "NO_MATCHING_POLICY")
 *    @arg @c kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_NoSatisfiedPolicy
 *        The Consent has at least one policy that matches the
 *        `resource_attributes` of the evaluated resource, but no
 *        `authorization_rule` was satisfied. (Value: "NO_SATISFIED_POLICY")
 *    @arg @c kGTLRCloudHealthcare_ConsentEvaluation_EvaluationResult_NotApplicable
 *        The Consent is not applicable to the requested access determination.
 *        For example, the Consent does not apply to the user for which the
 *        access determination is requested, or it has a `state` of `REVOKED`,
 *        or it has expired. (Value: "NOT_APPLICABLE")
 */
@property(nonatomic, copy, nullable) NSString *evaluationResult;

@end


/**
 *  List of resource names of Consent resources.
 */
@interface GTLRCloudHealthcare_ConsentList : GTLRObject

/**
 *  The resource names of the Consents to evaluate against, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consents/{consent_id}`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *consents;

@end


/**
 *  Represents a consent store.
 */
@interface GTLRCloudHealthcare_ConsentStore : GTLRObject

/**
 *  Optional. Default time to live for Consents created in this store. Must be
 *  at least 24 hours. Updating this field will not affect the expiration time
 *  of existing consents.
 */
@property(nonatomic, strong, nullable) GTLRDuration *defaultConsentTtl;

/**
 *  Optional. If `true`, UpdateConsent creates the Consent if it does not
 *  already exist. If unspecified, defaults to `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableConsentCreateOnUpdate;

/**
 *  Optional. User-supplied key-value pairs used to organize consent stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the following PCRE regular
 *  expression: \\p{Ll}\\p{Lo}{0,62}. Label values must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}. No more than 64 labels can be associated
 *  with a given store. For more information:
 *  https://cloud.google.com/healthcare/docs/how-tos/labeling-resources
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ConsentStore_Labels *labels;

/**
 *  Resource name of the consent store, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}`.
 *  Cannot be changed after creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Optional. User-supplied key-value pairs used to organize consent stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the following PCRE regular
 *  expression: \\p{Ll}\\p{Lo}{0,62}. Label values must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}. No more than 64 labels can be associated
 *  with a given store. For more information:
 *  https://cloud.google.com/healthcare/docs/how-tos/labeling-resources
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_ConsentStore_Labels : GTLRObject
@end


/**
 *  Creates a new message.
 */
@interface GTLRCloudHealthcare_CreateMessageRequest : GTLRObject

/** HL7v2 message. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message *message;

@end


/**
 *  Pseudonymization method that generates surrogates via cryptographic hashing.
 *  Uses SHA-256. Outputs a base64-encoded representation of the hashed output
 *  (for example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`).
 */
@interface GTLRCloudHealthcare_CryptoHashConfig : GTLRObject

/**
 *  An AES 128/192/256 bit key. Causes the hash to be computed based on this
 *  key. A default key is generated for each Deidentify operation and is used
 *  when neither `crypto_key` nor `kms_wrapped` is specified. Must not be set if
 *  `kms_wrapped` is set.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *cryptoKey;

/** KMS wrapped key. Must not be set if `crypto_key` is set. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_KmsWrappedCryptoKey *kmsWrapped;

@end


/**
 *  A message representing a health dataset. A health dataset represents a
 *  collection of healthcare data pertaining to one or more patients. This may
 *  include multiple modalities of healthcare data, such as electronic medical
 *  records or medical imaging data.
 */
@interface GTLRCloudHealthcare_Dataset : GTLRObject

/**
 *  Resource name of the dataset, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The default timezone used by this dataset. Must be a either a valid IANA
 *  time zone name such as "America/New_York" or empty, which defaults to UTC.
 *  This is used for parsing times in resources, such as HL7 messages, where no
 *  explicit timezone is specified.
 */
@property(nonatomic, copy, nullable) NSString *timeZone;

@end


/**
 *  Shift a date forward or backward in time by a random amount which is
 *  consistent for a given patient and crypto key combination.
 */
@interface GTLRCloudHealthcare_DateShiftConfig : GTLRObject

/**
 *  An AES 128/192/256 bit key. Causes the shift to be computed based on this
 *  key and the patient ID. A default key is generated for each
 *  de-identification operation and is used when neither `crypto_key` nor
 *  `kms_wrapped` is specified. Must not be set if `kms_wrapped` is set.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *cryptoKey;

/** KMS wrapped key. Must not be set if `crypto_key` is set. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_KmsWrappedCryptoKey *kmsWrapped;

@end


/**
 *  Contains configuration for streaming de-identified FHIR export.
 */
@interface GTLRCloudHealthcare_DeidentifiedStoreDestination : GTLRObject

/**
 *  The configuration to use when de-identifying resources that are added to
 *  this store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DeidentifyConfig *config;

/**
 *  The full resource name of a Cloud Healthcare FHIR store, for example,
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *store;

@end


/**
 *  Configures de-id options specific to different types of content. Each
 *  submessage customizes the handling of an https://tools.ietf.org/html/rfc6838
 *  media type or subtype. Configs are applied in a nested manner at runtime.
 */
@interface GTLRCloudHealthcare_DeidentifyConfig : GTLRObject

/** Configures de-id of application/DICOM content. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DicomConfig *dicom;

/** Configures de-id of application/FHIR content. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_FhirConfig *fhir;

/**
 *  Configures de-identification of image pixels wherever they are found in the
 *  source_dataset.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ImageConfig *image;

/**
 *  Configures de-identification of text wherever it is found in the
 *  source_dataset.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TextConfig *text;

@end


/**
 *  Redacts identifying information from the specified dataset.
 */
@interface GTLRCloudHealthcare_DeidentifyDatasetRequest : GTLRObject

/**
 *  Deidentify configuration. Only one of `config` and `gcs_config_uri` can be
 *  specified.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DeidentifyConfig *config;

/**
 *  The name of the dataset resource to create and write the redacted data to. *
 *  The destination dataset must not exist. * The destination dataset must be in
 *  the same location as the source dataset. De-identifying data across multiple
 *  locations is not supported.
 */
@property(nonatomic, copy, nullable) NSString *destinationDataset;

/**
 *  Cloud Storage location to read the JSON
 *  cloud.healthcare.deidentify.DeidentifyConfig from, overriding the default
 *  config. Must be of the form `gs://{bucket_id}/path/to/object`. The Cloud
 *  Storage location must grant the Cloud IAM role `roles/storage.objectViewer`
 *  to the project's Cloud Healthcare Service Agent service account. Only one of
 *  `config` and `gcs_config_uri` can be specified.
 */
@property(nonatomic, copy, nullable) NSString *gcsConfigUri;

@end


/**
 *  Creates a new DICOM store with sensitive information de-identified.
 */
@interface GTLRCloudHealthcare_DeidentifyDicomStoreRequest : GTLRObject

/**
 *  Deidentify configuration. Only one of `config` and `gcs_config_uri` can be
 *  specified.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DeidentifyConfig *config;

/**
 *  The name of the DICOM store to create and write the redacted data to. For
 *  example,
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}`.
 *  * The destination dataset must exist. * The source dataset and destination
 *  dataset must both reside in the same location. De-identifying data across
 *  multiple locations is not supported. * The destination DICOM store must not
 *  exist. * The caller must have the necessary permissions to create the
 *  destination DICOM store.
 */
@property(nonatomic, copy, nullable) NSString *destinationStore;

/** Filter configuration. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DicomFilterConfig *filterConfig;

/**
 *  Cloud Storage location to read the JSON
 *  cloud.healthcare.deidentify.DeidentifyConfig from, overriding the default
 *  config. Must be of the form `gs://{bucket_id}/path/to/object`. The Cloud
 *  Storage location must grant the Cloud IAM role `roles/storage.objectViewer`
 *  to the project's Cloud Healthcare Service Agent service account. Only one of
 *  `config` and `gcs_config_uri` can be specified.
 */
@property(nonatomic, copy, nullable) NSString *gcsConfigUri;

@end


/**
 *  Creates a new FHIR store with sensitive information de-identified.
 */
@interface GTLRCloudHealthcare_DeidentifyFhirStoreRequest : GTLRObject

/**
 *  Deidentify configuration. Only one of `config` and `gcs_config_uri` can be
 *  specified.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DeidentifyConfig *config;

/**
 *  The name of the FHIR store to create and write the redacted data to. For
 *  example,
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 *  * The destination dataset must exist. * The source dataset and destination
 *  dataset must both reside in the same location. De-identifying data across
 *  multiple locations is not supported. * The destination FHIR store must
 *  exist. * The caller must have the healthcare.fhirResources.update permission
 *  to write to the destination FHIR store.
 */
@property(nonatomic, copy, nullable) NSString *destinationStore;

/**
 *  Cloud Storage location to read the JSON
 *  cloud.healthcare.deidentify.DeidentifyConfig from, overriding the default
 *  config. Must be of the form `gs://{bucket_id}/path/to/object`. The Cloud
 *  Storage location must grant the Cloud IAM role `roles/storage.objectViewer`
 *  to the project's Cloud Healthcare Service Agent service account. Only one of
 *  `config` and `gcs_config_uri` can be specified.
 */
@property(nonatomic, copy, nullable) NSString *gcsConfigUri;

/**
 *  A filter specifying the resources to include in the output. If not
 *  specified, all resources are included in the output.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_FhirFilter *resourceFilter;

/**
 *  If true, skips resources that are created or modified after the de-identify
 *  operation is created.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipModifiedResources;

@end


/**
 *  Contains a summary of the Deidentify operation.
 */
@interface GTLRCloudHealthcare_DeidentifySummary : GTLRObject
@end


/**
 *  Specifies the parameters needed for de-identification of DICOM stores.
 */
@interface GTLRCloudHealthcare_DicomConfig : GTLRObject

/**
 *  Tag filtering profile that determines which tags to keep/remove.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_AttributeConfidentialityBasicProfile
 *        Remove tags based on DICOM Standard's Attribute Confidentiality Basic
 *        Profile (DICOM Standard Edition 2018e)
 *        http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html.
 *        (Value: "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_DeidentifyTagContents
 *        Inspects within tag contents and replaces sensitive text. The process
 *        can be configured using the TextConfig. Applies to all tags with the
 *        following Value Representation names: AE, LO, LT, PN, SH, ST, UC, UT,
 *        DA, DT, AS (Value: "DEIDENTIFY_TAG_CONTENTS")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_KeepAllProfile Keep
 *        all tags. (Value: "KEEP_ALL_PROFILE")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_MinimalKeepListProfile
 *        Keep only tags required to produce valid DICOM. (Value:
 *        "MINIMAL_KEEP_LIST_PROFILE")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_TagFilterProfileUnspecified
 *        No tag filtration profile provided. Same as KEEP_ALL_PROFILE. (Value:
 *        "TAG_FILTER_PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *filterProfile;

/** List of tags to keep. Remove all other tags. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TagFilterList *keepList;

/** List of tags to remove. Keep all other tags. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TagFilterList *removeList;

/**
 *  If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID,
 *  and MediaStorageSOPInstanceUID and leave them untouched. The Cloud
 *  Healthcare API regenerates these UIDs by default based on the DICOM
 *  Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an
 *  individual out of context, given access to the original images, or to a
 *  database of the original images containing the UIDs, it would be possible to
 *  recover the individual's identity."
 *  http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipIdRedaction;

@end


/**
 *  Specifies the filter configuration for DICOM resources.
 */
@interface GTLRCloudHealthcare_DicomFilterConfig : GTLRObject

/**
 *  The Cloud Storage location of the filter configuration file. The `gcs_uri`
 *  must be in the format `gs://bucket/path/to/object`. The filter configuration
 *  file must contain a list of resource paths separated by newline characters
 *  (\\n or \\r\\n). Each resource path must be in the format
 *  "/studies/{studyUID}[/series/{seriesUID}[/instances/{instanceUID}]]" The
 *  Cloud Healthcare API service account must have the
 *  `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location.
 */
@property(nonatomic, copy, nullable) NSString *resourcePathsGcsUri;

@end


/**
 *  Represents a DICOM store.
 */
@interface GTLRCloudHealthcare_DicomStore : GTLRObject

/**
 *  User-supplied key-value pairs used to organize DICOM stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DicomStore_Labels *labels;

/**
 *  Resource name of the DICOM store, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Notification destination for new DICOM instances. Supplied by the client.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_NotificationConfig *notificationConfig;

@end


/**
 *  User-supplied key-value pairs used to organize DICOM stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_DicomStore_Labels : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRCloudHealthcare_Empty : GTLRObject
@end


/**
 *  The candidate entities that an entity mention could link to.
 */
@interface GTLRCloudHealthcare_Entity : GTLRObject

/**
 *  entity_id is a first class field entity_id uniquely identifies this concept
 *  and its meta-vocabulary. For example, "UMLS/C0000970".
 */
@property(nonatomic, copy, nullable) NSString *entityId;

/**
 *  preferred_term is the preferred term for this concept. For example,
 *  "Acetaminophen". For ad hoc entities formed by normalization, this is the
 *  most popular unnormalized string.
 */
@property(nonatomic, copy, nullable) NSString *preferredTerm;

/**
 *  Vocabulary codes are first-class fields and differentiated from the concept
 *  unique identifier (entity_id). vocabulary_codes contains the representation
 *  of this concept in particular vocabularies, such as ICD-10, SNOMED-CT and
 *  RxNORM. These are prefixed by the name of the vocabulary, followed by the
 *  unique code within that vocabulary. For example, "RXNORM/A10334543".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *vocabularyCodes;

@end


/**
 *  An entity mention in the document.
 */
@interface GTLRCloudHealthcare_EntityMention : GTLRObject

/**
 *  The certainty assessment of the entity mention. Its value is one of: LIKELY,
 *  SOMEWHAT_LIKELY, UNCERTAIN, SOMEWHAT_UNLIKELY, UNLIKELY, CONDITIONAL
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Feature *certaintyAssessment;

/**
 *  The model's confidence in this entity mention annotation. A number between 0
 *  and 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *confidence;

/**
 *  linked_entities are candidate ontological concepts that this entity mention
 *  may refer to. They are sorted by decreasing confidence.it
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_LinkedEntity *> *linkedEntities;

/**
 *  mention_id uniquely identifies each entity mention in a single response.
 */
@property(nonatomic, copy, nullable) NSString *mentionId;

/**
 *  The subject this entity mention relates to. Its value is one of: PATIENT,
 *  FAMILY_MEMBER, OTHER
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Feature *subject;

/**
 *  How this entity mention relates to the subject temporally. Its value is one
 *  of: CURRENT, CLINICAL_HISTORY, FAMILY_HISTORY, UPCOMING, ALLERGY
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Feature *temporalAssessment;

/** text is the location of the entity mention in the document. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TextSpan *text;

/**
 *  The semantic type of the entity: UNKNOWN_ENTITY_TYPE, ALONE,
 *  ANATOMICAL_STRUCTURE, ASSISTED_LIVING, BF_RESULT, BM_RESULT, BM_UNIT,
 *  BM_VALUE, BODY_FUNCTION, BODY_MEASUREMENT, COMPLIANT, DOESNOT_FOLLOWUP,
 *  FAMILY, FOLLOWSUP, LABORATORY_DATA, LAB_RESULT, LAB_UNIT, LAB_VALUE,
 *  MEDICAL_DEVICE, MEDICINE, MED_DOSE, MED_DURATION, MED_FORM, MED_FREQUENCY,
 *  MED_ROUTE, MED_STATUS, MED_STRENGTH, MED_TOTALDOSE, MED_UNIT, NON_COMPLIANT,
 *  OTHER_LIVINGSTATUS, PROBLEM, PROCEDURE, PROCEDURE_RESULT, PROC_METHOD,
 *  REASON_FOR_NONCOMPLIANCE, SEVERITY, SUBSTANCE_ABUSE, UNCLEAR_FOLLOWUP.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Defines directed relationship from one entity mention to another.
 */
@interface GTLRCloudHealthcare_EntityMentionRelationship : GTLRObject

/**
 *  The model's confidence in this annotation. A number between 0 and 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *confidence;

/** object_id is the id of the object entity mention. */
@property(nonatomic, copy, nullable) NSString *objectId;

/** subject_id is the id of the subject entity mention. */
@property(nonatomic, copy, nullable) NSString *subjectId;

@end


/**
 *  Evaluate a user's Consents for all matching User data mappings. Note: User
 *  data mappings are indexed asynchronously, causing slight delays between the
 *  time mappings are created or updated and when they are included in
 *  EvaluateUserConsents results.
 */
@interface GTLRCloudHealthcare_EvaluateUserConsentsRequest : GTLRObject

/**
 *  Optional. Specific Consents to evaluate the access request against. These
 *  Consents must have the same `user_id` as the User data mappings being
 *  evalauted, must exist in the current `consent_store`, and must have a
 *  `state` of either `ACTIVE` or `DRAFT`. A maximum of 100 Consents can be
 *  provided here. If unspecified, all `ACTIVE` unexpired Consents in the
 *  current `consent_store` will be evaluated.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ConsentList *consentList;

/**
 *  Optional. Limit on the number of User data mappings to return in a single
 *  response. If not specified, 100 is used. May not be larger than 1000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pageSize;

/**
 *  Optional. Token to retrieve the next page of results, or empty to get the
 *  first page.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The values of request attributes associated with this access
 *  request.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_EvaluateUserConsentsRequest_RequestAttributes *requestAttributes;

/**
 *  Optional. The values of resource attributes associated with the resources
 *  being requested. If no values are specified, then all resources are queried.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_EvaluateUserConsentsRequest_ResourceAttributes *resourceAttributes;

/**
 *  Optional. The view for EvaluateUserConsentsResponse. If unspecified,
 *  defaults to `BASIC` and returns `consented` as `TRUE` or `FALSE`.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_EvaluateUserConsentsRequest_ResponseView_Basic
 *        Only the `data_id` and `consented` fields are populated in the
 *        response. (Value: "BASIC")
 *    @arg @c kGTLRCloudHealthcare_EvaluateUserConsentsRequest_ResponseView_Full
 *        All fields within the response are populated. When set to `FULL`, all
 *        `ACTIVE` Consents are evaluated even if a matching policy is found
 *        during evaluation. (Value: "FULL")
 *    @arg @c kGTLRCloudHealthcare_EvaluateUserConsentsRequest_ResponseView_ResponseViewUnspecified
 *        No response view specified. The API will default to the BASIC view.
 *        (Value: "RESPONSE_VIEW_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *responseView;

/** Required. User ID to evaluate consents for. */
@property(nonatomic, copy, nullable) NSString *userId;

@end


/**
 *  Required. The values of request attributes associated with this access
 *  request.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_EvaluateUserConsentsRequest_RequestAttributes : GTLRObject
@end


/**
 *  Optional. The values of resource attributes associated with the resources
 *  being requested. If no values are specified, then all resources are queried.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_EvaluateUserConsentsRequest_ResourceAttributes : GTLRObject
@end


/**
 *  GTLRCloudHealthcare_EvaluateUserConsentsResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "results" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_EvaluateUserConsentsResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list. This token is valid for 72 hours after it is created.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The consent evaluation result for each `data_id`.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Result *> *results;

@end


/**
 *  Exports data from the specified DICOM store. If a given resource, such as a
 *  DICOM object with the same SOPInstance UID, already exists in the output, it
 *  is overwritten with the version in the source dataset. Exported DICOM data
 *  persists when the DICOM store from which it was exported is deleted.
 */
@interface GTLRCloudHealthcare_ExportDicomDataRequest : GTLRObject

/**
 *  The BigQuery output destination. You can only export to a BigQuery dataset
 *  that's in the same project as the DICOM store you're exporting from. The
 *  Cloud Healthcare Service Agent requires two IAM roles on the BigQuery
 *  location: `roles/bigquery.dataEditor` and `roles/bigquery.jobUser`.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination *bigqueryDestination;

/**
 *  The Cloud Storage output destination. The Cloud Healthcare Service Agent
 *  requires the `roles/storage.objectAdmin` Cloud IAM roles on the Cloud
 *  Storage location.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomGcsDestination *gcsDestination;

@end


/**
 *  Returns additional information in regards to a completed DICOM store export.
 */
@interface GTLRCloudHealthcare_ExportDicomDataResponse : GTLRObject
@end


/**
 *  Request to schedule an export.
 */
@interface GTLRCloudHealthcare_ExportMessagesRequest : GTLRObject

/**
 *  The end of the range in `send_time` (MSH.7,
 *  https://www.hl7.org/documentcenter/public_temp_2E58C1F9-1C23-BA17-0C6126475344DA9D/wg/conf/HL7MSH.htm)
 *  to process. If not specified, the time when the export is scheduled is used.
 *  This value has to come after the `start_time` defined below. Only messages
 *  whose `send_time` lies in the range `start_time` (inclusive) to `end_time`
 *  (exclusive) are exported.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Export to a Cloud Storage destination. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GcsDestination *gcsDestination;

/**
 *  The start of the range in `send_time` (MSH.7,
 *  https://www.hl7.org/documentcenter/public_temp_2E58C1F9-1C23-BA17-0C6126475344DA9D/wg/conf/HL7MSH.htm)
 *  to process. If not specified, the UNIX epoch (1970-01-01T00:00:00Z) is used.
 *  This value has to come before the `end_time` defined below. Only messages
 *  whose `send_time` lies in the range `start_time` (inclusive) to `end_time`
 *  (exclusive) are exported.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Final response for the export operation. This structure is included in the
 *  response to describe the detailed outcome.
 */
@interface GTLRCloudHealthcare_ExportMessagesResponse : GTLRObject
@end


/**
 *  Request to export resources.
 */
@interface GTLRCloudHealthcare_ExportResourcesRequest : GTLRObject

/**
 *  If provided, only resources updated after this time are exported. The time
 *  uses the format YYYY-MM-DDThh:mm:ss.sss+zz:zz. For example,
 *  `2015-02-07T13:28:17.239+02:00` or `2017-01-01T00:00:00Z`. The time must be
 *  specified to the second and include a time zone.
 */
@property(nonatomic, copy, nullable) NSString *xSince;

/**
 *  String of comma-delimited FHIR resource types. If provided, only resources
 *  of the specified resource type(s) are exported.
 */
@property(nonatomic, copy, nullable) NSString *xType;

/**
 *  The BigQuery output destination. The Cloud Healthcare Service Agent requires
 *  two IAM roles on the BigQuery location: `roles/bigquery.dataEditor` and
 *  `roles/bigquery.jobUser`. The output is one BigQuery table per resource
 *  type. Unlike when setting `BigQueryDestination` for `StreamConfig`,
 *  `ExportResources` does not create BigQuery views.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination *bigqueryDestination;

/**
 *  The Cloud Storage output destination. The Healthcare Service Agent account
 *  requires the `roles/storage.objectAdmin` role on the Cloud Storage location.
 *  The exported outputs are organized by FHIR resource types. The server
 *  creates one object per resource type. Each object contains newline delimited
 *  JSON, and each line is a FHIR resource.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirGcsDestination *gcsDestination;

@end


/**
 *  Response when all resources export successfully. This structure is included
 *  in the response to describe the detailed outcome after the operation
 *  finishes successfully.
 */
@interface GTLRCloudHealthcare_ExportResourcesResponse : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRCloudHealthcare_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  A feature of an entity mention.
 */
@interface GTLRCloudHealthcare_Feature : GTLRObject

/**
 *  The model's confidence in this feature annotation. A number between 0 and 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *confidence;

/**
 *  The value of this feature annotation. Its range depends on the type of the
 *  feature.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Specifies how to handle de-identification of a FHIR store.
 */
@interface GTLRCloudHealthcare_FhirConfig : GTLRObject

/**
 *  The behaviour for handling FHIR extensions that aren't otherwise specified
 *  for de-identification. If true, all extensions are preserved during
 *  de-identification by default. If false or unspecified, all extensions are
 *  removed during de-identification by default.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultKeepExtensions;

/**
 *  Specifies FHIR paths to match and how to transform them. Any field that is
 *  not matched by a FieldMetadata is passed through to the output dataset
 *  unmodified. All extensions will be processed according to
 *  `default_keep_extensions`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_FieldMetadata *> *fieldMetadataList;

@end


/**
 *  Filter configuration.
 */
@interface GTLRCloudHealthcare_FhirFilter : GTLRObject

/**
 *  List of resources to include in the output. If this list is empty or not
 *  specified, all resources are included in the output.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Resources *resources;

@end


/**
 *  Represents a FHIR store.
 */
@interface GTLRCloudHealthcare_FhirStore : GTLRObject

/**
 *  Enable parsing of references within complex FHIR data types such as
 *  Extensions. If this value is set to ENABLED, then features like referential
 *  integrity and Bundle reference rewriting apply to all references. If this
 *  flag has not been specified the behavior of the FHIR store will not change,
 *  references in complex data types will not be parsed. New stores will have
 *  this value set to ENABLED after a notification period. Warning: turning on
 *  this flag causes processing existing resources to fail if they contain
 *  references to non-existent resources.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_FhirStore_ComplexDataTypeReferenceParsing_ComplexDataTypeReferenceParsingUnspecified
 *        No parsing behavior specified. This is the same as DISABLED for
 *        backwards compatibility. (Value:
 *        "COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_FhirStore_ComplexDataTypeReferenceParsing_Disabled
 *        References in complex data types are ignored. (Value: "DISABLED")
 *    @arg @c kGTLRCloudHealthcare_FhirStore_ComplexDataTypeReferenceParsing_Enabled
 *        References in complex data types are parsed. (Value: "ENABLED")
 */
@property(nonatomic, copy, nullable) NSString *complexDataTypeReferenceParsing;

/**
 *  If true, overrides the default search behavior for this FHIR store to
 *  `handling=strict` which returns an error for unrecognized search parameters.
 *  If false, uses the FHIR specification default `handling=lenient` which
 *  ignores unrecognized search parameters. The handling can always be changed
 *  from the default on an individual API call by setting the HTTP header
 *  `Prefer: handling=strict` or `Prefer: handling=lenient`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultSearchHandlingStrict;

/**
 *  Immutable. Whether to disable referential integrity in this FHIR store. This
 *  field is immutable after FHIR store creation. The default value is false,
 *  meaning that the API enforces referential integrity and fails the requests
 *  that result in inconsistent state in the FHIR store. When this field is set
 *  to true, the API skips referential integrity checks. Consequently,
 *  operations that rely on references, such as GetPatientEverything, do not
 *  return all the results if broken references exist.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableReferentialIntegrity;

/**
 *  Immutable. Whether to disable resource versioning for this FHIR store. This
 *  field can not be changed after the creation of FHIR store. If set to false,
 *  which is the default behavior, all write operations cause historical
 *  versions to be recorded automatically. The historical versions can be
 *  fetched through the history APIs, but cannot be updated. If set to true, no
 *  historical versions are kept. The server sends errors for attempts to read
 *  the historical versions.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableResourceVersioning;

/**
 *  Whether this FHIR store has the [updateCreate
 *  capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate).
 *  This determines if the client can use an Update operation to create a new
 *  resource with a client-specified ID. If false, all IDs are server-assigned
 *  through the Create operation and attempts to update a non-existent resource
 *  return errors. It is strongly advised not to include or encode any sensitive
 *  data such as patient identifiers in client-specified resource IDs. Those IDs
 *  are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub
 *  notifications. Those IDs can also be contained in reference fields within
 *  other resources.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableUpdateCreate;

/**
 *  User-supplied key-value pairs used to organize FHIR stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_FhirStore_Labels *labels;

/**
 *  Output only. Resource name of the FHIR store, of the form
 *  `projects/{project_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If non-empty, publish all resource modifications of this FHIR store to this
 *  destination. The Pub/Sub message attributes contain a map with a string
 *  describing the action that has triggered the notification. For example,
 *  "action":"CreateResource".
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_NotificationConfig *notificationConfig;

/**
 *  A list of streaming configs that configure the destinations of streaming
 *  export for every resource mutation in this FHIR store. Each store is allowed
 *  to have up to 10 streaming configs. After a new config is added, the next
 *  resource mutation is streamed to the new location in addition to the
 *  existing ones. When a location is removed from the list, the server stops
 *  streaming to that location. Before adding a new config, you must add the
 *  required
 *  [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor)
 *  role to your project's **Cloud Healthcare Service Agent** [service
 *  account](https://cloud.google.com/iam/docs/service-accounts). Some lag
 *  (typically on the order of dozens of seconds) is expected before the results
 *  show up in the streaming destination.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_StreamConfig *> *streamConfigs;

/**
 *  Configuration for how to validate incoming FHIR resources against configured
 *  profiles.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ValidationConfig *validationConfig;

/**
 *  Immutable. The FHIR specification version that this FHIR store supports
 *  natively. This field is immutable after store creation. Requests are
 *  rejected if they contain FHIR resources of a different version. Version is
 *  required for every FHIR store.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_FhirStore_Version_Dstu2 Draft Standard for
 *        Trial Use, [Release 2](https://www.hl7.org/fhir/DSTU2) (Value:
 *        "DSTU2")
 *    @arg @c kGTLRCloudHealthcare_FhirStore_Version_R4 [Release
 *        4](https://www.hl7.org/fhir/R4) (Value: "R4")
 *    @arg @c kGTLRCloudHealthcare_FhirStore_Version_Stu3 Standard for Trial
 *        Use, [Release 3](https://www.hl7.org/fhir/STU3) (Value: "STU3")
 *    @arg @c kGTLRCloudHealthcare_FhirStore_Version_VersionUnspecified Users
 *        must specify a version on store creation or an error is returned.
 *        (Value: "VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  User-supplied key-value pairs used to organize FHIR stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_FhirStore_Labels : GTLRObject
@end


/**
 *  A (sub) field of a type.
 */
@interface GTLRCloudHealthcare_Field : GTLRObject

/**
 *  The maximum number of times this field can be repeated. 0 or -1 means
 *  unbounded.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxOccurs;

/**
 *  The minimum number of times this field must be present/repeated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minOccurs;

/** The name of the field. For example, "PID-1" or just "1". */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary
 *  Language) usually refers to table "0296".
 */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The type of this field. A Type with this name must be defined in an
 *  Hl7TypesConfig.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Specifies FHIR paths to match, and how to handle de-identification of
 *  matching fields.
 */
@interface GTLRCloudHealthcare_FieldMetadata : GTLRObject

/**
 *  Deidentify action for one field.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_ActionUnspecified No
 *        action specified. (Value: "ACTION_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_DoNotTransform Do not
 *        transform. (Value: "DO_NOT_TRANSFORM")
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_InspectAndTransform
 *        Inspect and transform any found PHI. (Value: "INSPECT_AND_TRANSFORM")
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_Transform Transform the
 *        entire field. (Value: "TRANSFORM")
 */
@property(nonatomic, copy, nullable) NSString *action;

/**
 *  List of paths to FHIR fields to be redacted. Each path is a period-separated
 *  list where each component is either a field name or FHIR type name, for
 *  example: Patient, HumanName. For "choice" types (those defined in the FHIR
 *  spec with the form: field[x]) we use two separate components. For example,
 *  "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are:
 *  AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime,
 *  Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid,
 *  PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

@end


/**
 *  The Cloud Storage output destination. The Cloud Healthcare Service Agent
 *  requires the `roles/storage.objectAdmin` Cloud IAM roles on the Cloud
 *  Storage location.
 */
@interface GTLRCloudHealthcare_GcsDestination : GTLRObject

/**
 *  The format of the exported HL7v2 message files.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_ContentStructure_ContentStructureUnspecified
 *        If the content structure is not specified, the default value
 *        `MESSAGE_JSON` will be used. (Value: "CONTENT_STRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_ContentStructure_MessageJson
 *        Messages are printed using the JSON format returned from the
 *        `GetMessage` API. Messages are delimited with newlines. (Value:
 *        "MESSAGE_JSON")
 */
@property(nonatomic, copy, nullable) NSString *contentStructure;

/**
 *  Specifies the parts of the Message resource to include in the export. If not
 *  specified, FULL is used.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_MessageView_Basic Server
 *        responses include only the name field. (Value: "BASIC")
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_MessageView_Full Server
 *        responses include all the message fields. (Value: "FULL")
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_MessageView_MessageViewUnspecified
 *        Not specified, equivalent to FULL. (Value: "MESSAGE_VIEW_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_MessageView_ParsedOnly Server
 *        responses include all the message fields except data field, and
 *        schematized_data fields. (Value: "PARSED_ONLY")
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_MessageView_RawOnly Server
 *        responses include all the message fields except parsed_data field, and
 *        schematized_data fields. (Value: "RAW_ONLY")
 *    @arg @c kGTLRCloudHealthcare_GcsDestination_MessageView_SchematizedOnly
 *        Server responses include all the message fields except data and
 *        parsed_data fields. (Value: "SCHEMATIZED_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *messageView;

/**
 *  URI of an existing Cloud Storage directory where the server writes result
 *  files, in the format `gs://{bucket-id}/{path/to/destination/dir}`. If there
 *  is no trailing slash, the service appends one when composing the object
 *  path.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Specifies the configuration for importing data from Cloud Storage.
 */
@interface GTLRCloudHealthcare_GcsSource : GTLRObject

/**
 *  Points to a Cloud Storage URI containing file(s) to import. The URI must be
 *  in the following format: `gs://{bucket_id}/{object_id}`. The URI can include
 *  wildcards in `object_id` and thus identify multiple files. Supported
 *  wildcards: * `*` to match 0 or more non-separator characters * `**` to match
 *  0 or more characters (including separators). Must be used at the end of a
 *  path and with no other wildcards in the path. Can also be used with a file
 *  extension (such as .ndjson), which imports all files with the extension in
 *  the specified directory and its sub-directories. For example,
 *  `gs://my-bucket/my-directory/ **.ndjson` imports all files with `.ndjson`
 *  extensions in `my-directory/` and its sub-directories. * `?` to match 1
 *  character Files matching the wildcard are expected to contain content only,
 *  no metadata.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  The Cloud Storage location for export.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1ConsentGcsDestination : GTLRObject

/**
 *  URI for a Cloud Storage directory where the server writes result files, in
 *  the format `gs://{bucket-id}/{path/to/destination/dir}`. If there is no
 *  trailing slash, the service appends one when composing the object path. The
 *  user is responsible for creating the Cloud Storage bucket and directory
 *  referenced in `uri_prefix`.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Represents a user's consent in terms of the resources that can be accessed
 *  and under what conditions.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1ConsentPolicy : GTLRObject

/**
 *  Required. The request conditions to meet to grant access. In addition to any
 *  supported comparison operators, authorization rules may have `IN` operator
 *  as well as at most 10 logical operators that are limited to `AND` (`&&`),
 *  `OR` (`||`).
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Expr *authorizationRule;

/**
 *  The resources that this policy applies to. A resource is a match if it
 *  matches all the attributes listed here. If empty, this policy applies to all
 *  User data mappings for the given user.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Attribute *> *resourceAttributes;

@end


/**
 *  Contains a summary of the DeidentifyDicomStore operation.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1DeidentifyDeidentifyDicomStoreSummary : GTLRObject
@end


/**
 *  Contains a summary of the DeidentifyFhirStore operation.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1DeidentifyDeidentifyFhirStoreSummary : GTLRObject
@end


/**
 *  The BigQuery table where the server writes the output.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination : GTLRObject

/**
 *  Use `write_disposition` instead. If `write_disposition` is specified, this
 *  parameter is ignored. force=false is equivalent to
 *  write_disposition=WRITE_EMPTY and force=true is equivalent to
 *  write_disposition=WRITE_TRUNCATE.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *force;

/**
 *  BigQuery URI to a table, up to 2000 characters long, in the format
 *  `bq://projectId.bqDatasetId.tableId`
 */
@property(nonatomic, copy, nullable) NSString *tableUri;

/**
 *  Determines whether the existing table in the destination is to be
 *  overwritten or appended to. If a write_disposition is specified, the `force`
 *  parameter is ignored.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteAppend
 *        Append data to the destination table. (Value: "WRITE_APPEND")
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteDispositionUnspecified
 *        Default behavior is the same as WRITE_EMPTY. (Value:
 *        "WRITE_DISPOSITION_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteEmpty
 *        Only export data if the destination table is empty. (Value:
 *        "WRITE_EMPTY")
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1DicomBigQueryDestination_WriteDisposition_WriteTruncate
 *        Erase all existing data in the destination table before writing the
 *        instances. (Value: "WRITE_TRUNCATE")
 */
@property(nonatomic, copy, nullable) NSString *writeDisposition;

@end


/**
 *  The Cloud Storage location where the server writes the output and the export
 *  configuration.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomGcsDestination : GTLRObject

/**
 *  MIME types supported by DICOM spec. Each file is written in the following
 *  format:
 *  `.../{study_id}/{series_id}/{instance_id}[/{frame_number}].{extension}` The
 *  frame_number component exists only for multi-frame instances. Supported MIME
 *  types are consistent with supported formats in DICOMweb:
 *  https://cloud.google.com/healthcare/docs/dicom#retrieve_transaction.
 *  Specifically, the following are supported: - application/dicom;
 *  transfer-syntax=1.2.840.10008.1.2.1 (uncompressed DICOM) -
 *  application/dicom; transfer-syntax=1.2.840.10008.1.2.4.50 (DICOM with
 *  embedded JPEG Baseline) - application/dicom;
 *  transfer-syntax=1.2.840.10008.1.2.4.90 (DICOM with embedded JPEG 2000
 *  Lossless Only) - application/dicom; transfer-syntax=1.2.840.10008.1.2.4.91
 *  (DICOM with embedded JPEG 2000) - application/dicom; transfer-syntax=*
 *  (DICOM with no transcoding) - application/octet-stream;
 *  transfer-syntax=1.2.840.10008.1.2.1 (raw uncompressed PixelData) -
 *  application/octet-stream; transfer-syntax=* (raw PixelData in whatever
 *  format it was uploaded in) - image/jpeg;
 *  transfer-syntax=1.2.840.10008.1.2.4.50 (Consumer JPEG) - image/png The
 *  following extensions are used for output files: - application/dicom -> .dcm
 *  - image/jpeg -> .jpg - image/png -> .png - application/octet-stream -> no
 *  extension If unspecified, the instances are exported in the original DICOM
 *  format they were uploaded in.
 */
@property(nonatomic, copy, nullable) NSString *mimeType;

/**
 *  The Cloud Storage destination to export to. URI for a Cloud Storage
 *  directory where the server writes the result files, in the format
 *  `gs://{bucket-id}/{path/to/destination/dir}`). If there is no trailing
 *  slash, the service appends one when composing the object path. The user is
 *  responsible for creating the Cloud Storage bucket referenced in
 *  `uri_prefix`.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Specifies the configuration for importing data from Cloud Storage.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomGcsSource : GTLRObject

/**
 *  Points to a Cloud Storage URI containing file(s) with content only. The URI
 *  must be in the following format: `gs://{bucket_id}/{object_id}`. The URI can
 *  include wildcards in `object_id` and thus identify multiple files. Supported
 *  wildcards: * '*' to match 0 or more non-separator characters * '**' to match
 *  0 or more characters (including separators). Must be used at the end of a
 *  path and with no other wildcards in the path. Can also be used with a file
 *  extension (such as .dcm), which imports all files with the extension in the
 *  specified directory and its sub-directories. For example,
 *  `gs://my-bucket/my-directory/ **.dcm` imports all files with .dcm extensions
 *  in `my-directory/` and its sub-directories. * '?' to match 1 character. All
 *  other URI formats are invalid. Files matching the wildcard are expected to
 *  contain content only, no metadata.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  The configuration for exporting to BigQuery.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination : GTLRObject

/**
 *  BigQuery URI to an existing dataset, up to 2000 characters long, in the
 *  format `bq://projectId.bqDatasetId`.
 */
@property(nonatomic, copy, nullable) NSString *datasetUri;

/**
 *  If this flag is `TRUE`, all tables are deleted from the dataset before the
 *  new exported tables are written. If the flag is not set and the destination
 *  dataset contains tables, the export call returns an error. If
 *  `write_disposition` is specified, this parameter is ignored. force=false is
 *  equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to
 *  write_disposition=WRITE_TRUNCATE.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *force;

/** The configuration for the exported BigQuery schema. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SchemaConfig *schemaConfig;

/**
 *  Determines if existing data in the destination dataset is overwritten,
 *  appended to, or not written if the tables contain data. If a
 *  write_disposition is specified, the `force` parameter is ignored.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteAppend
 *        Append data to the destination tables. (Value: "WRITE_APPEND")
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteDispositionUnspecified
 *        Default behavior is the same as WRITE_EMPTY. (Value:
 *        "WRITE_DISPOSITION_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteEmpty
 *        Only export data if the destination tables are empty. (Value:
 *        "WRITE_EMPTY")
 *    @arg @c kGTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination_WriteDisposition_WriteTruncate
 *        Erase all existing data in the destination tables before writing the
 *        FHIR resources. (Value: "WRITE_TRUNCATE")
 */
@property(nonatomic, copy, nullable) NSString *writeDisposition;

@end


/**
 *  The configuration for exporting to Cloud Storage.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirGcsDestination : GTLRObject

/**
 *  URI for a Cloud Storage directory where result files should be written, in
 *  the format of `gs://{bucket-id}/{path/to/destination/dir}`. If there is no
 *  trailing slash, the service appends one when composing the object path. The
 *  user is responsible for creating the Cloud Storage bucket referenced in
 *  `uri_prefix`.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Specifies the configuration for importing data from Cloud Storage.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirGcsSource : GTLRObject

/**
 *  Points to a Cloud Storage URI containing file(s) to import. The URI must be
 *  in the following format: `gs://{bucket_id}/{object_id}`. The URI can include
 *  wildcards in `object_id` and thus identify multiple files. Supported
 *  wildcards: * `*` to match 0 or more non-separator characters * `**` to match
 *  0 or more characters (including separators). Must be used at the end of a
 *  path and with no other wildcards in the path. Can also be used with a file
 *  extension (such as .ndjson), which imports all files with the extension in
 *  the specified directory and its sub-directories. For example,
 *  `gs://my-bucket/my-directory/ **.ndjson` imports all files with `.ndjson`
 *  extensions in `my-directory/` and its sub-directories. * `?` to match 1
 *  character Files matching the wildcard are expected to contain content only,
 *  no metadata.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Construct representing a logical group or a segment.
 */
@interface GTLRCloudHealthcare_GroupOrSegment : GTLRObject

@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SchemaGroup *group;
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SchemaSegment *segment;

@end


/**
 *  Root config message for HL7v2 schema. This contains a schema structure of
 *  groups and segments, and filters that determine which messages to apply the
 *  schema structure to.
 */
@interface GTLRCloudHealthcare_Hl7SchemaConfig : GTLRObject

/**
 *  Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to
 *  its schema configuration root group.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Hl7SchemaConfig_MessageSchemaConfigs *messageSchemaConfigs;

/**
 *  Each VersionSource is tested and only if they all match is the schema used
 *  for the message.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_VersionSource *> *version;

@end


/**
 *  Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to
 *  its schema configuration root group.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudHealthcare_SchemaGroup. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Hl7SchemaConfig_MessageSchemaConfigs : GTLRObject
@end


/**
 *  Root config for HL7v2 datatype definitions for a specific HL7v2 version.
 */
@interface GTLRCloudHealthcare_Hl7TypesConfig : GTLRObject

/** The HL7v2 type definitions. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Type *> *type;

/**
 *  The version selectors that this config applies to. A message must match ALL
 *  version sources to apply.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_VersionSource *> *version;

@end


/**
 *  Specifies where and whether to send notifications upon changes to a data
 *  store.
 */
@interface GTLRCloudHealthcare_Hl7V2NotificationConfig : GTLRObject

/**
 *  Restricts notifications sent for messages matching a filter. If this is
 *  empty, all messages are matched. The following syntax is available: * A
 *  string field value can be written as text inside quotation marks, for
 *  example `"query text"`. The only valid relational operation for text fields
 *  is equality (`=`), where text is searched within the field, rather than
 *  having the field be equal to the text. For example, `"Comment = great"`
 *  returns messages with `great` in the comment field. * A number field value
 *  can be written as an integer, a decimal, or an exponential. The valid
 *  relational operators for number fields are the equality operator (`=`),
 *  along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note
 *  that there is no inequality (`!=`) operator. You can prepend the `NOT`
 *  operator to an expression to negate it. * A date field value must be written
 *  in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format.
 *  Leading zeros are required for one-digit months and days. The valid
 *  relational operators for date fields are the equality operator (`=`) , along
 *  with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that
 *  there is no inequality (`!=`) operator. You can prepend the `NOT` operator
 *  to an expression to negate it. * Multiple field query expressions can be
 *  combined in one query by adding `AND` or `OR` operators between the
 *  expressions. If a boolean operator appears within a quoted string, it is not
 *  treated as special, it's just another part of the character string to be
 *  matched. You can prepend the `NOT` operator to an expression to negate it.
 *  The following fields and functions are available for filtering: *
 *  `message_type`, from the MSH-9.1 field. For example, `NOT message_type =
 *  "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was
 *  sent in the dataset's time_zone, from the MSH-7 segment. For example,
 *  `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message
 *  was sent, using the RFC3339 time format for comparisons, from the MSH-7
 *  segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. *
 *  `create_time`, the timestamp when the message was created in the HL7v2
 *  store. Use the RFC3339 time format for comparisons. For example,
 *  `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care
 *  center that the message came from, from the MSH-4 segment. For example,
 *  `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the
 *  message lists a patient having an ID of the given value and type in the
 *  PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`.
 *  * `labels.x`, a string value of the label with key `x` as set using the
 *  Message.labels map. For example, `labels."priority"="high"`. The operator
 *  `:*` can be used to assert the existence of a label. For example,
 *  `labels."priority":*`.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that
 *  notifications of changes are published on. Supplied by the client. The
 *  notification is a `PubsubMessage` with the following fields: *
 *  `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId`
 *  is the ID of this notification. It's guaranteed to be unique within the
 *  topic. * `PubsubMessage.PublishTime` is the time when the message was
 *  published. Note that notifications are only sent if the topic is non-empty.
 *  [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be
 *  scoped to a project. The Cloud Healthcare API service account,
 *  service-PROJECT_NUMBER\@gcp-sa-healthcare.iam.gserviceaccount.com, must have
 *  publisher permissions on the given Pub/Sub topic. Not having adequate
 *  permissions causes the calls that send notifications to fail. If a
 *  notification cannot be published to Pub/Sub, errors are logged to Cloud
 *  Logging. For more information, see [Viewing error logs in Cloud
 *  Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

@end


/**
 *  Represents an HL7v2 store.
 */
@interface GTLRCloudHealthcare_Hl7V2Store : GTLRObject

/**
 *  User-supplied key-value pairs used to organize HL7v2 stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Hl7V2Store_Labels *labels;

/**
 *  Resource name of the HL7v2 store, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/hl7V2Stores/{hl7v2_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A list of notification configs. Each configuration uses a filter to
 *  determine whether to publish a message (both Ingest & Create) on the
 *  corresponding notification destination. Only the message name is sent as
 *  part of the notification. Supplied by the client.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Hl7V2NotificationConfig *> *notificationConfigs;

/**
 *  The configuration for the parser. It determines how the server parses the
 *  messages.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ParserConfig *parserConfig;

/**
 *  Determines whether to reject duplicate messages. A duplicate message is a
 *  message with the same raw bytes as a message that has already been
 *  ingested/created in this HL7v2 store. The default value is false, meaning
 *  that the store accepts the duplicate messages and it also returns the same
 *  ACK message in the IngestMessageResponse as has been returned previously.
 *  Note that only one resource is created in the store. When this field is set
 *  to true, CreateMessage/IngestMessage requests with a duplicate message will
 *  be rejected by the store, and IngestMessageErrorDetail returns a NACK
 *  message upon rejection.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rejectDuplicateMessage;

@end


/**
 *  User-supplied key-value pairs used to organize HL7v2 stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Hl7V2Store_Labels : GTLRObject
@end


/**
 *  Message that represents an arbitrary HTTP body. It should only be used for
 *  payload formats that can't be represented as JSON, such as raw binary or an
 *  HTML page. This message can be used both in streaming and non-streaming API
 *  methods in the request as well as the response. It can be used as a
 *  top-level request field, which is convenient if one wants to extract
 *  parameters from either the URL or HTTP template into the request fields and
 *  also want access to the raw HTTP body. Example: message GetResourceRequest {
 *  // A unique request id. string request_id = 1; // The raw HTTP body is bound
 *  to this field. google.api.HttpBody http_body = 2; } service ResourceService
 *  { rpc GetResource(GetResourceRequest) returns (google.api.HttpBody); rpc
 *  UpdateResource(google.api.HttpBody) returns (google.protobuf.Empty); }
 *  Example with streaming methods: service CaldavService { rpc
 *  GetCalendar(stream google.api.HttpBody) returns (stream
 *  google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
 *  (stream google.api.HttpBody); } Use of this type only changes how the
 *  request and response bodies are handled, all other features will continue to
 *  work unchanged.
 */
@interface GTLRCloudHealthcare_HttpBody : GTLRObject

/**
 *  The HTTP Content-Type header value specifying the content type of the body.
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The HTTP request/response body as raw binary.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  Application specific response metadata. Must be set in the first response
 *  for streaming APIs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_HttpBody_Extensions_Item *> *extensions;

@end


/**
 *  GTLRCloudHealthcare_HttpBody_Extensions_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_HttpBody_Extensions_Item : GTLRObject
@end


/**
 *  Raw bytes representing consent artifact content.
 */
@interface GTLRCloudHealthcare_Image : GTLRObject

/**
 *  Input only. Points to a Cloud Storage URI containing the consent artifact
 *  content. The URI must be in the following format:
 *  `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account
 *  must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud
 *  Storage location. The consent artifact content at this URI is copied to a
 *  Cloud Storage location managed by the Cloud Healthcare API. Responses to
 *  fetching requests return the consent artifact content in raw_bytes.
 */
@property(nonatomic, copy, nullable) NSString *gcsUri;

/**
 *  Consent artifact content represented as a stream of bytes. This field is
 *  populated when returned in GetConsentArtifact response, but not included in
 *  CreateConsentArtifact and ListConsentArtifact response.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *rawBytes;

@end


/**
 *  Specifies how to handle de-identification of image pixels.
 */
@interface GTLRCloudHealthcare_ImageConfig : GTLRObject

/**
 *  Determines how to redact text from image.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactAllText
 *        Redact all text. (Value: "REDACT_ALL_TEXT")
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactNoText Do
 *        not redact text. (Value: "REDACT_NO_TEXT")
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactSensitiveText
 *        Redact sensitive text. Uses the set of [Default DICOM
 *        InfoTypes](https://cloud.google.com/healthcare-api/docs/how-tos/dicom-deidentify#default_dicom_infotypes).
 *        (Value: "REDACT_SENSITIVE_TEXT")
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_TextRedactionModeUnspecified
 *        No text redaction specified. Same as REDACT_NO_TEXT. (Value:
 *        "TEXT_REDACTION_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *textRedactionMode;

@end


/**
 *  Imports data into the specified DICOM store. Returns an error if any of the
 *  files to import are not DICOM files. This API accepts duplicate DICOM
 *  instances by ignoring the newly-pushed instance. It does not overwrite.
 */
@interface GTLRCloudHealthcare_ImportDicomDataRequest : GTLRObject

/**
 *  Cloud Storage source data location and import configuration. The Cloud
 *  Healthcare Service Agent requires the `roles/storage.objectViewer` Cloud IAM
 *  roles on the Cloud Storage location.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1DicomGcsSource *gcsSource;

@end


/**
 *  Returns additional information in regards to a completed DICOM store import.
 */
@interface GTLRCloudHealthcare_ImportDicomDataResponse : GTLRObject
@end


/**
 *  Request to import messages.
 */
@interface GTLRCloudHealthcare_ImportMessagesRequest : GTLRObject

/**
 *  Cloud Storage source data location and import configuration. The Cloud
 *  Healthcare Service Agent requires the `roles/storage.objectViewer` Cloud IAM
 *  roles on the Cloud Storage location.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GcsSource *gcsSource;

@end


/**
 *  Final response of importing messages. This structure is included in the
 *  response to describe the detailed outcome. It is only included when the
 *  operation finishes successfully.
 */
@interface GTLRCloudHealthcare_ImportMessagesResponse : GTLRObject
@end


/**
 *  Request to import resources.
 */
@interface GTLRCloudHealthcare_ImportResourcesRequest : GTLRObject

/**
 *  The content structure in the source location. If not specified, the server
 *  treats the input source files as BUNDLE.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Bundle
 *        The source file contains one or more lines of newline-delimited JSON
 *        (ndjson). Each line is a bundle that contains one or more resources.
 *        (Value: "BUNDLE")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_BundlePretty
 *        The entire file is one JSON bundle. The JSON can span multiple lines.
 *        (Value: "BUNDLE_PRETTY")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ContentStructureUnspecified
 *        If the content structure is not specified, the default value `BUNDLE`
 *        is used. (Value: "CONTENT_STRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Resource
 *        The source file contains one or more lines of newline-delimited JSON
 *        (ndjson). Each line is a single resource. (Value: "RESOURCE")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ResourcePretty
 *        The entire file is one JSON resource. The JSON can span multiple
 *        lines. (Value: "RESOURCE_PRETTY")
 */
@property(nonatomic, copy, nullable) NSString *contentStructure;

/**
 *  Cloud Storage source data location and import configuration. The Healthcare
 *  Service Agent account requires the `roles/storage.objectAdmin` role on the
 *  Cloud Storage location. Each Cloud Storage object should be a text file that
 *  contains the format specified in ContentStructure.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirGcsSource *gcsSource;

@end


/**
 *  Final response of importing resources. This structure is included in the
 *  response to describe the detailed outcome after the operation finishes
 *  successfully.
 */
@interface GTLRCloudHealthcare_ImportResourcesResponse : GTLRObject
@end


/**
 *  A transformation to apply to text that is identified as a specific
 *  info_type.
 */
@interface GTLRCloudHealthcare_InfoTypeTransformation : GTLRObject

/** Config for character mask. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_CharacterMaskConfig *characterMaskConfig;

/** Config for crypto hash. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_CryptoHashConfig *cryptoHashConfig;

/** Config for date shift. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DateShiftConfig *dateShiftConfig;

/**
 *  InfoTypes to apply this transformation to. If this is not specified, the
 *  transformation applies to any info_type.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *infoTypes;

/** Config for text redaction. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_RedactConfig *redactConfig;

/** Config for replace with InfoType. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ReplaceWithInfoTypeConfig *replaceWithInfoTypeConfig;

@end


/**
 *  Ingests a message into the specified HL7v2 store.
 */
@interface GTLRCloudHealthcare_IngestMessageRequest : GTLRObject

/** HL7v2 message to ingest. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message *message;

@end


/**
 *  Acknowledges that a message has been ingested into the specified HL7v2
 *  store.
 */
@interface GTLRCloudHealthcare_IngestMessageResponse : GTLRObject

/**
 *  HL7v2 ACK message.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *hl7Ack;

/** Created message resource. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message *message;

@end


/**
 *  Include to use an existing data crypto key wrapped by KMS. The wrapped key
 *  must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM
 *  permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud
 *  Healthcare Service Agent service account. For more information, see
 *  [Creating a wrapped key]
 *  (https://cloud.google.com/dlp/docs/create-wrapped-key).
 */
@interface GTLRCloudHealthcare_KmsWrappedCryptoKey : GTLRObject

/**
 *  Required. The resource name of the KMS CryptoKey to use for unwrapping. For
 *  example,
 *  `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
 */
@property(nonatomic, copy, nullable) NSString *cryptoKey;

/**
 *  Required. The wrapped data crypto key.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *wrappedKey;

@end


/**
 *  EntityMentions can be linked to multiple entities using a LinkedEntity
 *  message lets us add other fields, e.g. confidence.
 */
@interface GTLRCloudHealthcare_LinkedEntity : GTLRObject

/**
 *  entity_id is a concept unique identifier. These are prefixed by a string
 *  that identifies the entity coding system, followed by the unique identifier
 *  within that system. For example, "UMLS/C0000970". This also supports ad hoc
 *  entities, which are formed by normalizing entity mention content.
 */
@property(nonatomic, copy, nullable) NSString *entityId;

@end


/**
 *  GTLRCloudHealthcare_ListAttributeDefinitionsResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "attributeDefinitions" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRCloudHealthcare_ListAttributeDefinitionsResponse : GTLRCollectionObject

/**
 *  The returned Attribute definitions. The maximum number of attributes
 *  returned is determined by the value of page_size in the
 *  ListAttributeDefinitionsRequest.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_AttributeDefinition *> *attributeDefinitions;

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  GTLRCloudHealthcare_ListConsentArtifactsResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "consentArtifacts" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRCloudHealthcare_ListConsentArtifactsResponse : GTLRCollectionObject

/**
 *  The returned Consent artifacts. The maximum number of artifacts returned is
 *  determined by the value of page_size in the ListConsentArtifactsRequest.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_ConsentArtifact *> *consentArtifacts;

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  GTLRCloudHealthcare_ListConsentRevisionsResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "consents" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListConsentRevisionsResponse : GTLRCollectionObject

/**
 *  The returned Consent revisions. The maximum number of revisions returned is
 *  determined by the value of `page_size` in the ListConsentRevisionsRequest.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Consent *> *consents;

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  GTLRCloudHealthcare_ListConsentsResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "consents" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListConsentsResponse : GTLRCollectionObject

/**
 *  The returned Consents. The maximum number of Consents returned is determined
 *  by the value of page_size in the ListConsentsRequest.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Consent *> *consents;

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  GTLRCloudHealthcare_ListConsentStoresResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "consentStores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListConsentStoresResponse : GTLRCollectionObject

/**
 *  The returned consent stores. The maximum number of stores returned is
 *  determined by the value of page_size in the ListConsentStoresRequest.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_ConsentStore *> *consentStores;

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the available datasets.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "datasets" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListDatasetsResponse : GTLRCollectionObject

/**
 *  The first page of datasets.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Dataset *> *datasets;

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the DICOM stores in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "dicomStores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListDicomStoresResponse : GTLRCollectionObject

/**
 *  The returned DICOM stores. Won't be more DICOM stores than the value of
 *  page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_DicomStore *> *dicomStores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the FHIR stores in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "fhirStores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListFhirStoresResponse : GTLRCollectionObject

/**
 *  The returned FHIR stores. Won't be more FHIR stores than the value of
 *  page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_FhirStore *> *fhirStores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the HL7v2 stores in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hl7V2Stores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListHl7V2StoresResponse : GTLRCollectionObject

/**
 *  The returned HL7v2 stores. Won't be more HL7v2 stores than the value of
 *  page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Hl7V2Store *> *hl7V2Stores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the messages in the specified HL7v2 store.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hl7V2Messages" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListMessagesResponse : GTLRCollectionObject

/**
 *  The returned Messages. Won't be more Messages than the value of page_size in
 *  the request. See view for populated fields.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Message *> *hl7V2Messages;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Operation *> *operations;

@end


/**
 *  GTLRCloudHealthcare_ListUserDataMappingsResponse
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "userDataMappings" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRCloudHealthcare_ListUserDataMappingsResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The returned User data mappings. The maximum number of User data mappings
 *  returned is determined by the value of page_size in the
 *  ListUserDataMappingsRequest.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_UserDataMapping *> *userDataMappings;

@end


/**
 *  A resource that represents Google Cloud Platform location.
 */
@interface GTLRCloudHealthcare_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Location_Metadata : GTLRObject
@end


/**
 *  A complete HL7v2 message. See [Introduction to HL7 Standards]
 *  (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details
 *  on the standard.
 */
@interface GTLRCloudHealthcare_Message : GTLRObject

/**
 *  Output only. The datetime when the message was created. Set by the server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Raw message bytes.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  User-supplied key-value pairs used to organize HL7v2 stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message_Labels *labels;

/** The message type for this message. MSH-9.1. */
@property(nonatomic, copy, nullable) NSString *messageType;

/**
 *  Resource name of the Message, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`.
 *  Assigned by the server.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. The parsed version of the raw message data. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ParsedData *parsedData;

/**
 *  All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this
 *  message.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_PatientId *> *patientIds;

/**
 *  The parsed version of the raw message data schematized according to this
 *  store's schemas and type definitions.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SchematizedData *schematizedData;

/** The hospital that this message came from. MSH-4. */
@property(nonatomic, copy, nullable) NSString *sendFacility;

/** The datetime the sending application sent this message. MSH-7. */
@property(nonatomic, strong, nullable) GTLRDateTime *sendTime;

@end


/**
 *  User-supplied key-value pairs used to organize HL7v2 stores. Label keys must
 *  be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128
 *  bytes, and must conform to the following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62} Label values are optional, must be between 1 and 63
 *  characters long, have a UTF-8 encoding of maximum 128 bytes, and must
 *  conform to the following PCRE regular expression:
 *  [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63} No more than 64 labels can be associated with
 *  a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Message_Labels : GTLRObject
@end


/**
 *  Specifies where to send notifications upon changes to a data store.
 */
@interface GTLRCloudHealthcare_NotificationConfig : GTLRObject

/**
 *  The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that
 *  notifications of changes are published on. Supplied by the client.
 *  PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is
 *  the ID of this message. It is guaranteed to be unique within the topic.
 *  PubsubMessage.PublishTime is the time at which the message was published.
 *  Notifications are only sent if the topic is non-empty. [Topic
 *  names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped
 *  to a project. Cloud Healthcare API service account must have publisher
 *  permissions on the given Pub/Sub topic. Not having adequate permissions
 *  causes the calls that send notifications to fail. If a notification can't be
 *  published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error
 *  logs in Cloud
 *  Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the
 *  number of errors exceeds a certain rate, some aren't submitted. Note that
 *  not all operations trigger notifications, see [Configuring Pub/Sub
 *  notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for
 *  specific details.
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRCloudHealthcare_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Operation_Response : GTLRObject
@end


/**
 *  OperationMetadata provides information about the operation execution.
 *  Returned in the long-running operation's metadata field.
 */
@interface GTLRCloudHealthcare_OperationMetadata : GTLRObject

/** The name of the API method that initiated the operation. */
@property(nonatomic, copy, nullable) NSString *apiMethodName;

/**
 *  Specifies if cancellation was requested for the operation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cancelRequested;

@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ProgressCounter *counter;

/** The time at which the operation was created by the API. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The time at which execution was completed. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  A link to audit and error logs in the log viewer. Error logs are generated
 *  only by some operations, listed at [Viewing error logs in Cloud
 *  Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
 */
@property(nonatomic, copy, nullable) NSString *logsUrl;

@end


/**
 *  The content of a HL7v2 message in a structured format.
 */
@interface GTLRCloudHealthcare_ParsedData : GTLRObject

@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Segment *> *segments;

@end


/**
 *  The configuration for the parser. It determines how the server parses the
 *  messages.
 */
@interface GTLRCloudHealthcare_ParserConfig : GTLRObject

/**
 *  Determines whether messages with no header are allowed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowNullHeader;

/**
 *  Schemas used to parse messages in this store, if schematized parsing is
 *  desired.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SchemaPackage *schema;

/**
 *  Byte(s) to use as the segment terminator. If this is unset, '\\r' is used as
 *  segment terminator, matching the HL7 version 2 specification.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *segmentTerminator;

/**
 *  Immutable. Determines the version of both the default parser to be used when
 *  `schema` is not given, as well as the schematized parser used when `schema`
 *  is specified. This field is immutable after HL7v2 store creation.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_ParserConfig_Version_ParserVersionUnspecified
 *        Unspecified parser version, equivalent to V1. (Value:
 *        "PARSER_VERSION_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_ParserConfig_Version_V1 The `parsed_data`
 *        includes every given non-empty message field except the Field
 *        Separator (MSH-1) field. As a result, the parsed MSH segment starts
 *        with the MSH-2 field and the field numbers are off-by-one with respect
 *        to the HL7 standard. (Value: "V1")
 *    @arg @c kGTLRCloudHealthcare_ParserConfig_Version_V2 The `parsed_data`
 *        includes every given non-empty message field. (Value: "V2")
 *    @arg @c kGTLRCloudHealthcare_ParserConfig_Version_V3 This version is the
 *        same as V2, with the following change. The `parsed_data` contains
 *        unescaped escaped field separators, component separators,
 *        sub-component separators, repetition separators, escape characters,
 *        and truncation characters. If `schema` is specified, the schematized
 *        parser uses improved parsing heuristics compared to previous versions.
 *        (Value: "V3")
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  A patient identifier and associated type.
 */
@interface GTLRCloudHealthcare_PatientId : GTLRObject

/** ID type. For example, MRN or NHS. */
@property(nonatomic, copy, nullable) NSString *type;

/** The patient's unique identifier. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRCloudHealthcare_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  ProgressCounter provides counters to describe an operation's progress.
 */
@interface GTLRCloudHealthcare_ProgressCounter : GTLRObject

/**
 *  The number of units that failed in the operation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *failure;

/**
 *  The number of units that are pending in the operation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pending;

/**
 *  The number of units that succeeded in the operation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  Queries all data_ids that are consented for a given use in the given consent
 *  store and writes them to a specified destination. The returned Operation
 *  includes a progress counter for the number of User data mappings processed.
 *  Errors are logged to Cloud Logging (see [Viewing error logs in Cloud
 *  Logging] (https://cloud.google.com/healthcare/docs/how-tos/logging) and
 *  [QueryAccessibleData] for a sample log entry).
 */
@interface GTLRCloudHealthcare_QueryAccessibleDataRequest : GTLRObject

/**
 *  The Cloud Storage destination. The Cloud Healthcare API service account must
 *  have the `roles/storage.objectAdmin` Cloud IAM role for this Cloud Storage
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1ConsentGcsDestination *gcsDestination;

/** The values of request attributes associated with this access request. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_QueryAccessibleDataRequest_RequestAttributes *requestAttributes;

/**
 *  Optional. The values of resource attributes associated with the type of
 *  resources being requested. If no values are specified, then all resource
 *  types are included in the output.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_QueryAccessibleDataRequest_ResourceAttributes *resourceAttributes;

@end


/**
 *  The values of request attributes associated with this access request.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_QueryAccessibleDataRequest_RequestAttributes : GTLRObject
@end


/**
 *  Optional. The values of resource attributes associated with the type of
 *  resources being requested. If no values are specified, then all resource
 *  types are included in the output.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_QueryAccessibleDataRequest_ResourceAttributes : GTLRObject
@end


/**
 *  Response for successful QueryAccessibleData operations. This structure is
 *  included in the response upon operation completion.
 */
@interface GTLRCloudHealthcare_QueryAccessibleDataResponse : GTLRObject

/**
 *  List of files, each of which contains a list of data_id(s) that are
 *  consented for a specified use in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *gcsUris;

@end


/**
 *  Define how to redact sensitive values. Default behaviour is erase. For
 *  example, "My name is Jane." becomes "My name is ."
 */
@interface GTLRCloudHealthcare_RedactConfig : GTLRObject
@end


/**
 *  Rejects the latest revision of the specified Consent by committing a new
 *  revision with `state` updated to `REJECTED`. If the latest revision of the
 *  given Consent is in the `REJECTED` state, no new revision is committed.
 */
@interface GTLRCloudHealthcare_RejectConsentRequest : GTLRObject

/**
 *  Optional. The resource name of the Consent artifact that contains
 *  documentation of the user's rejection of the draft Consent, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
 *  If the draft Consent had a Consent artifact, this Consent artifact
 *  overwrites it.
 */
@property(nonatomic, copy, nullable) NSString *consentArtifact;

@end


/**
 *  When using the INSPECT_AND_TRANSFORM action, each match is replaced with the
 *  name of the info_type. For example, "My name is Jane" becomes "My name is
 *  [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
 */
@interface GTLRCloudHealthcare_ReplaceWithInfoTypeConfig : GTLRObject
@end


/**
 *  A list of FHIR resources.
 */
@interface GTLRCloudHealthcare_Resources : GTLRObject

/** List of resources IDs. For example, "Patient/1234". */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resources;

@end


/**
 *  The consent evaluation result for a single `data_id`.
 */
@interface GTLRCloudHealthcare_Result : GTLRObject

/**
 *  The resource names of all evaluated Consents mapped to their evaluation.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Result_ConsentDetails *consentDetails;

/**
 *  Whether the resource is consented for the given use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *consented;

/** The unique identifier of the evaluated resource. */
@property(nonatomic, copy, nullable) NSString *dataId;

@end


/**
 *  The resource names of all evaluated Consents mapped to their evaluation.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudHealthcare_ConsentEvaluation. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Result_ConsentDetails : GTLRObject
@end


/**
 *  Revokes the latest revision of the specified Consent by committing a new
 *  revision with `state` updated to `REVOKED`. If the latest revision of the
 *  given Consent is in the `REVOKED` state, no new revision is committed.
 */
@interface GTLRCloudHealthcare_RevokeConsentRequest : GTLRObject

/**
 *  Optional. The resource name of the Consent artifact that contains proof of
 *  the user's revocation of the Consent, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
 */
@property(nonatomic, copy, nullable) NSString *consentArtifact;

@end


/**
 *  Configuration for the FHIR BigQuery schema. Determines how the server
 *  generates the schema.
 */
@interface GTLRCloudHealthcare_SchemaConfig : GTLRObject

/**
 *  The depth for all recursive structures in the output analytics schema. For
 *  example, `concept` in the CodeSystem resource is a recursive structure; when
 *  the depth is 2, the CodeSystem table will have a column called
 *  `concept.concept` but not `concept.concept.concept`. If not specified or set
 *  to 0, the server will use the default value 2. The maximum depth allowed is
 *  5.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *recursiveStructureDepth;

/**
 *  Specifies the output schema type. Schema type is required.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_SchemaConfig_SchemaType_Analytics Analytics
 *        schema defined by the FHIR community. See
 *        https://github.com/FHIR/sql-on-fhir/blob/master/sql-on-fhir.md.
 *        BigQuery only allows a maximum of 10,000 columns per table. Due to
 *        this limitation, the server will not generate schemas for fields of
 *        type `Resource`, which can hold any resource type. The affected fields
 *        are `Parameters.parameter.resource`, `Bundle.entry.resource`, and
 *        `Bundle.entry.response.outcome`. (Value: "ANALYTICS")
 *    @arg @c kGTLRCloudHealthcare_SchemaConfig_SchemaType_AnalyticsV2 Analytics
 *        V2, similar to schema defined by the FHIR community, with added
 *        support for extensions with one or more occurrences and contained
 *        resources in stringified JSON. Analytics V2 uses more space in the
 *        destination table than Analytics V1. (Value: "ANALYTICS_V2")
 *    @arg @c kGTLRCloudHealthcare_SchemaConfig_SchemaType_SchemaTypeUnspecified
 *        No schema type specified. This type is unsupported. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

@end


/**
 *  An HL7v2 logical group construct.
 */
@interface GTLRCloudHealthcare_SchemaGroup : GTLRObject

/**
 *  True indicates that this is a choice group, meaning that only one of its
 *  segments can exist in a given message.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *choice;

/**
 *  The maximum number of times this group can be repeated. 0 or -1 means
 *  unbounded.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxOccurs;

/** Nested groups and/or segments. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_GroupOrSegment *> *members;

/**
 *  The minimum number of times this group must be present/repeated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minOccurs;

/** The name of this group. For example, "ORDER_DETAIL". */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A schema package contains a set of schemas and type definitions.
 */
@interface GTLRCloudHealthcare_SchemaPackage : GTLRObject

/**
 *  Flag to ignore all min_occurs restrictions in the schema. This means that
 *  incoming messages can omit any group, segment, field, component, or
 *  subcomponent.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ignoreMinOccurs;

/**
 *  Schema configs that are layered based on their VersionSources that match the
 *  incoming message. Schema configs present in higher indices override those in
 *  lower indices with the same message type and trigger event if their
 *  VersionSources all match an incoming message.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Hl7SchemaConfig *> *schemas;

/**
 *  Determines how messages that fail to parse are handled.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_SchematizedParsingType_HardFail
 *        Messages that fail to parse are rejected from ingestion/insertion and
 *        return an error code. (Value: "HARD_FAIL")
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_SchematizedParsingType_SchematizedParsingTypeUnspecified
 *        Unspecified schematized parsing type, equivalent to `SOFT_FAIL`.
 *        (Value: "SCHEMATIZED_PARSING_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_SchematizedParsingType_SoftFail
 *        Messages that fail to parse are still stored and ACKed but a parser
 *        error is stored in place of the schematized data. (Value: "SOFT_FAIL")
 */
@property(nonatomic, copy, nullable) NSString *schematizedParsingType;

/**
 *  Schema type definitions that are layered based on their VersionSources that
 *  match the incoming message. Type definitions present in higher indices
 *  override those in lower indices with the same type name if their
 *  VersionSources all match an incoming message.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Hl7TypesConfig *> *types;

/**
 *  Determines how unexpected segments (segments not matched to the schema) are
 *  handled.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_Fail
 *        Unexpected segments fail to parse and return an error. (Value: "FAIL")
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_Parse
 *        Unexpected segments do not fail, but are parsed in place and added to
 *        the current group. If a segment has a type definition, it is used,
 *        otherwise it is parsed as VARIES. (Value: "PARSE")
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_Skip
 *        Unexpected segments do not fail, but are omitted from the output.
 *        (Value: "SKIP")
 *    @arg @c kGTLRCloudHealthcare_SchemaPackage_UnexpectedSegmentHandling_UnexpectedSegmentHandlingModeUnspecified
 *        Unspecified handling mode, equivalent to FAIL. (Value:
 *        "UNEXPECTED_SEGMENT_HANDLING_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *unexpectedSegmentHandling;

@end


/**
 *  An HL7v2 Segment.
 */
@interface GTLRCloudHealthcare_SchemaSegment : GTLRObject

/**
 *  The maximum number of times this segment can be present in this group. 0 or
 *  -1 means unbounded.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxOccurs;

/**
 *  The minimum number of times this segment can be present in this group.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minOccurs;

/** The Segment type. For example, "PID". */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The content of an HL7v2 message in a structured format as specified by a
 *  schema.
 */
@interface GTLRCloudHealthcare_SchematizedData : GTLRObject

/** JSON output of the parser. */
@property(nonatomic, copy, nullable) NSString *data;

/** The error output of the parser. */
@property(nonatomic, copy, nullable) NSString *error;

@end


/**
 *  Request to search the resources in the specified FHIR store.
 */
@interface GTLRCloudHealthcare_SearchResourcesRequest : GTLRObject

/**
 *  The FHIR resource type to search, such as Patient or Observation. For a
 *  complete list, see the FHIR Resource Index
 *  ([DSTU2](http://hl7.org/implement/standards/fhir/DSTU2/resourcelist.html),
 *  [STU3](http://hl7.org/implement/standards/fhir/STU3/resourcelist.html),
 *  [R4](http://hl7.org/implement/standards/fhir/R4/resourcelist.html)).
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  A segment in a structured format.
 */
@interface GTLRCloudHealthcare_Segment : GTLRObject

/**
 *  A mapping from the positional location to the value. The key string uses
 *  zero-based indexes separated by dots to identify Fields, components and
 *  sub-components. A bracket notation is also used to identify different
 *  instances of a repeated field. Regex for key:
 *  (\\d+)(\\[\\d+\\])?(.\\d+)?(.\\d+)? Examples of (key, value) pairs: * (0.1,
 *  "hemoglobin") denotes that the first component of Field 0 has the value
 *  "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the
 *  first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes
 *  that the first component of the first Instance of Field 1, which is
 *  repeated, has the value "HbA1c".
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Segment_Fields *fields;

/** A string that indicates the type of segment. For example, EVN or PID. */
@property(nonatomic, copy, nullable) NSString *segmentId;

/**
 *  Set ID for segments that can be in a set. This can be empty if it's missing
 *  or isn't applicable.
 */
@property(nonatomic, copy, nullable) NSString *setId;

@end


/**
 *  A mapping from the positional location to the value. The key string uses
 *  zero-based indexes separated by dots to identify Fields, components and
 *  sub-components. A bracket notation is also used to identify different
 *  instances of a repeated field. Regex for key:
 *  (\\d+)(\\[\\d+\\])?(.\\d+)?(.\\d+)? Examples of (key, value) pairs: * (0.1,
 *  "hemoglobin") denotes that the first component of Field 0 has the value
 *  "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the
 *  first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes
 *  that the first component of the first Instance of Field 1, which is
 *  repeated, has the value "HbA1c".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Segment_Fields : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRCloudHealthcare_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  User signature.
 */
@interface GTLRCloudHealthcare_Signature : GTLRObject

/** Optional. An image of the user's signature. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Image *image;

/**
 *  Optional. Metadata associated with the user's signature. For example, the
 *  user's name or the user's title.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Signature_Metadata *metadata;

/** Optional. Timestamp of the signature. */
@property(nonatomic, strong, nullable) GTLRDateTime *signatureTime;

/** Required. User's UUID provided by the client. */
@property(nonatomic, copy, nullable) NSString *userId;

@end


/**
 *  Optional. Metadata associated with the user's signature. For example, the
 *  user's name or the user's title.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Signature_Metadata : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRCloudHealthcare_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRCloudHealthcare_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Status_Details_Item : GTLRObject
@end


/**
 *  Contains configuration for streaming FHIR export.
 */
@interface GTLRCloudHealthcare_StreamConfig : GTLRObject

/**
 *  The destination BigQuery structure that contains both the dataset location
 *  and corresponding schema config. The output is organized in one table per
 *  resource type. The server reuses the existing tables (if any) that are named
 *  after the resource types. For example, "Patient", "Observation". When there
 *  is no existing table for a given resource type, the server attempts to
 *  create one. When a table schema doesn't align with the schema config, either
 *  because of existing incompatible schema or out of band incompatible
 *  modification, the server does not stream in new data. BigQuery imposes a 1
 *  MB limit on streaming insert row size, therefore any resource mutation that
 *  generates more than 1 MB of BigQuery data is not streamed. One resolution in
 *  this case is to delete the incompatible table and let the server recreate
 *  one, though the newly created table only contains data after the table
 *  recreation. Results are written to BigQuery tables according to the
 *  parameters in BigQueryDestination.WriteDisposition. Different versions of
 *  the same resource are distinguishable by the meta.versionId and
 *  meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results
 *  in the new version is recorded in the meta.tag. The tables contain all
 *  historical resource versions since streaming was enabled. For query
 *  convenience, the server also creates one view per table of the same name
 *  containing only the current resource version. The streamed data in the
 *  BigQuery dataset is not guaranteed to be completely unique. The combination
 *  of the id and meta.versionId columns should ideally identify a single unique
 *  row. But in rare cases, duplicates may exist. At query time, users may use
 *  the SQL select statement to keep only one of the duplicate rows given an id
 *  and meta.versionId pair. Alternatively, the server created view mentioned
 *  above also filters out duplicates. If a resource mutation cannot be streamed
 *  to BigQuery, errors are logged to Cloud Logging. For more information, see
 *  [Viewing error logs in Cloud
 *  Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1FhirBigQueryDestination *bigqueryDestination;

/**
 *  The destination FHIR store for de-identified resources. After this field is
 *  added, all subsequent creates/updates/patches to the source store will be
 *  de-identified using the provided configuration and applied to the
 *  destination store. Importing resources to the source store will not trigger
 *  the streaming. If the source store already contains resources when this
 *  option is enabled, those resources will not be copied to the destination
 *  store unless they are subsequently updated. This may result in invalid
 *  references in the destination store. Before adding this config, you must
 *  grant the healthcare.fhirResources.update permission on the destination
 *  store to your project's **Cloud Healthcare Service Agent** [service
 *  account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent).
 *  The destination store must set enable_update_create to true. The destination
 *  store must have disable_referential_integrity set to true. If a resource
 *  cannot be de-identified, errors will be logged to Cloud Logging (see
 *  [Viewing error logs in Cloud
 *  Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DeidentifiedStoreDestination *deidentifiedStoreDestination;

/**
 *  Supply a FHIR resource type (such as "Patient" or "Observation"). See
 *  https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR
 *  resource types. The server treats an empty list as an intent to stream all
 *  the supported resource types in this FHIR store.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceTypes;

@end


/**
 *  List of tags to be filtered.
 */
@interface GTLRCloudHealthcare_TagFilterList : GTLRObject

/**
 *  Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements,
 *  or Directory Structuring Elements, as defined at:
 *  http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,.
 *  They may be provided by "Keyword" or "Tag". For example "PatientID",
 *  "00100010".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRCloudHealthcare_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRCloudHealthcare_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  GTLRCloudHealthcare_TextConfig
 */
@interface GTLRCloudHealthcare_TextConfig : GTLRObject

/** The transformations to apply to the detected data. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_InfoTypeTransformation *> *transformations;

@end


/**
 *  A span of text in the provided document.
 */
@interface GTLRCloudHealthcare_TextSpan : GTLRObject

/**
 *  The unicode codepoint index of the beginning of this span.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *beginOffset;

/** The original text contained in this span. */
@property(nonatomic, copy, nullable) NSString *content;

@end


/**
 *  A type definition for some HL7v2 type (incl. Segments and Datatypes).
 */
@interface GTLRCloudHealthcare_Type : GTLRObject

/** The (sub) fields this type has (if not primitive). */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Field *> *fields;

/**
 *  The name of this type. This would be the segment or datatype name. For
 *  example, "PID" or "XPN".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If this is a primitive type then this field is the type of the primitive For
 *  example, STRING. Leave unspecified for composite types.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_Type_Primitive_PrimitiveUnspecified Not a
 *        primitive. (Value: "PRIMITIVE_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_Type_Primitive_String String primitive.
 *        (Value: "STRING")
 *    @arg @c kGTLRCloudHealthcare_Type_Primitive_UnescapedString Like STRING,
 *        but all delimiters below this element are ignored. (Value:
 *        "UNESCAPED_STRING")
 *    @arg @c kGTLRCloudHealthcare_Type_Primitive_Varies Element that can have
 *        unschematized children. (Value: "VARIES")
 */
@property(nonatomic, copy, nullable) NSString *primitive;

@end


/**
 *  Maps a resource to the associated user and Attributes.
 */
@interface GTLRCloudHealthcare_UserDataMapping : GTLRObject

/**
 *  Output only. Indicates whether this mapping is archived.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *archived;

/** Output only. Indicates the time when this mapping was archived. */
@property(nonatomic, strong, nullable) GTLRDateTime *archiveTime;

/** Required. A unique identifier for the mapped resource. */
@property(nonatomic, copy, nullable) NSString *dataId;

/**
 *  Resource name of the User data mapping, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/userDataMappings/{user_data_mapping_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Attributes of the resource. Only explicitly set attributes are displayed
 *  here. Attribute definitions with defaults set implicitly apply to these User
 *  data mappings. Attributes listed here must be single valued, that is,
 *  exactly one value is specified for the field "values" in each Attribute.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Attribute *> *resourceAttributes;

/** Required. User's UUID provided by the client. */
@property(nonatomic, copy, nullable) NSString *userId;

@end


/**
 *  Contains the configuration for FHIR profiles and validation.
 */
@interface GTLRCloudHealthcare_ValidationConfig : GTLRObject

/**
 *  Whether to disable FHIRPath validation for incoming resources. Set this to
 *  true to disable checking incoming resources for conformance against FHIRPath
 *  requirement defined in the FHIR specification. This property only affects
 *  resource types that do not have profiles configured for them, any rules in
 *  enabled implementation guides will still be enforced.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableFhirpathValidation;

/**
 *  Whether to disable profile validation for this FHIR store. Set this to true
 *  to disable checking incoming resources for conformance against structure
 *  definitions in this FHIR store.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableProfileValidation;

/**
 *  Whether to disable reference type validation for incoming resources. Set
 *  this to true to disable checking incoming resources for conformance against
 *  reference type requirement defined in the FHIR specification. This property
 *  only affects resource types that do not have profiles configured for them,
 *  any rules in enabled implementation guides will still be enforced.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableReferenceTypeValidation;

/**
 *  Whether to disable required fields validation for incoming resources. Set
 *  this to true to disable checking incoming resources for conformance against
 *  required fields requirement defined in the FHIR specification. This property
 *  only affects resource types that do not have profiles configured for them,
 *  any rules in enabled implementation guides will still be enforced.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableRequiredFieldValidation;

/**
 *  A list of implementation guide URLs in this FHIR store that are used to
 *  configure the profiles to use for validation. For example, to use the US
 *  Core profiles for validation, set `enabled_implementation_guides` to
 *  `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If
 *  `enabled_implementation_guides` is empty or omitted, then incoming resources
 *  are only required to conform to the base FHIR profiles. Otherwise, a
 *  resource must conform to at least one profile listed in the `global`
 *  property of one of the enabled ImplementationGuides. The Cloud Healthcare
 *  API does not currently enforce all of the rules in a StructureDefinition.
 *  The following rules are supported: - min/max - minValue/maxValue - maxLength
 *  - type - fixed[x] - pattern[x] on simple types - slicing, when using "value"
 *  as the discriminator type When a URL cannot be resolved (for example, in a
 *  type assertion), the server does not return an error.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledImplementationGuides;

@end


/**
 *  Describes a selector for extracting and matching an MSH field to a value.
 */
@interface GTLRCloudHealthcare_VersionSource : GTLRObject

/**
 *  The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
 */
@property(nonatomic, copy, nullable) NSString *mshField;

/**
 *  The value to match with the field. For example, "My Application Name" or
 *  "2.3".
 */
@property(nonatomic, copy, nullable) NSString *value;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
