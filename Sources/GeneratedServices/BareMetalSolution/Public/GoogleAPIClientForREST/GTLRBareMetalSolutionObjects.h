// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Bare Metal Solution API (baremetalsolution/v2)
// Description:
//   Provides ways to manage Bare Metal Solution hardware installed in a
//   regional extension located near a Google Cloud data center.
// Documentation:
//   https://cloud.google.com/bare-metal

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRBareMetalSolution_AllowedClient;
@class GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2LogicalInterface;
@class GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface;
@class GTLRBareMetalSolution_Instance;
@class GTLRBareMetalSolution_Instance_Labels;
@class GTLRBareMetalSolution_InstanceConfig;
@class GTLRBareMetalSolution_InstanceQuota;
@class GTLRBareMetalSolution_IntakeVlanAttachment;
@class GTLRBareMetalSolution_Location;
@class GTLRBareMetalSolution_Location_Labels;
@class GTLRBareMetalSolution_Location_Metadata;
@class GTLRBareMetalSolution_LogicalNetworkInterface;
@class GTLRBareMetalSolution_Lun;
@class GTLRBareMetalSolution_LunRange;
@class GTLRBareMetalSolution_Network;
@class GTLRBareMetalSolution_Network_Labels;
@class GTLRBareMetalSolution_NetworkAddress;
@class GTLRBareMetalSolution_NetworkAddressReservation;
@class GTLRBareMetalSolution_NetworkConfig;
@class GTLRBareMetalSolution_NetworkMountPoint;
@class GTLRBareMetalSolution_NetworkUsage;
@class GTLRBareMetalSolution_NfsExport;
@class GTLRBareMetalSolution_NfsShare;
@class GTLRBareMetalSolution_NfsShare_Labels;
@class GTLRBareMetalSolution_Operation_Metadata;
@class GTLRBareMetalSolution_Operation_Response;
@class GTLRBareMetalSolution_OSImage;
@class GTLRBareMetalSolution_ProvisioningConfig;
@class GTLRBareMetalSolution_ProvisioningQuota;
@class GTLRBareMetalSolution_QosPolicy;
@class GTLRBareMetalSolution_SnapshotReservationDetail;
@class GTLRBareMetalSolution_SSHKey;
@class GTLRBareMetalSolution_Status;
@class GTLRBareMetalSolution_Status_Details_Item;
@class GTLRBareMetalSolution_VlanAttachment;
@class GTLRBareMetalSolution_Volume;
@class GTLRBareMetalSolution_Volume_Labels;
@class GTLRBareMetalSolution_VolumeConfig;
@class GTLRBareMetalSolution_VolumeSnapshot;
@class GTLRBareMetalSolution_VRF;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_AllowedClient.mountPermissions

/**
 *  Permissions were not specified.
 *
 *  Value: "MOUNT_PERMISSIONS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_AllowedClient_MountPermissions_MountPermissionsUnspecified;
/**
 *  NFS share can be mount with read-only permissions.
 *
 *  Value: "READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_AllowedClient_MountPermissions_Read;
/**
 *  NFS share can be mount with read-write permissions.
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_AllowedClient_MountPermissions_ReadWrite;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface.type

/**
 *  Bond interface type.
 *
 *  Value: "BOND"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface_Type_Bond;
/**
 *  Unspecified value.
 *
 *  Value: "INTERFACE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface_Type_InterfaceTypeUnspecified;
/**
 *  NIC interface type.
 *
 *  Value: "NIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface_Type_Nic;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Instance.state

/**
 *  The server has been deleted.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Deleted;
/**
 *  The server is being provisioned.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Provisioning;
/**
 *  The server is running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Running;
/**
 *  The server is shutdown.
 *
 *  Value: "SHUTDOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Shutdown;
/**
 *  The server is starting.
 *
 *  Value: "STARTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Starting;
/**
 *  The server is in an unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_StateUnspecified;
/**
 *  The server is stopping.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Stopping;
/**
 *  The server is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_State_Updating;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Instance.workloadProfile

/**
 *  The workload profile is generic.
 *
 *  Value: "WORKLOAD_PROFILE_GENERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_WorkloadProfile_WorkloadProfileGeneric;
/**
 *  The workload profile is hana.
 *
 *  Value: "WORKLOAD_PROFILE_HANA"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_WorkloadProfile_WorkloadProfileHana;
/**
 *  The workload profile is in an unknown state.
 *
 *  Value: "WORKLOAD_PROFILE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Instance_WorkloadProfile_WorkloadProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_InstanceConfig.networkConfig

/**
 *  Instance part of multiple (or single) client networks and private networks.
 *
 *  Value: "MULTI_VLAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_InstanceConfig_NetworkConfig_MultiVlan;
/**
 *  The unspecified network configuration.
 *
 *  Value: "NETWORKCONFIG_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_InstanceConfig_NetworkConfig_NetworkconfigUnspecified;
/**
 *  Instance part of single client network and single private network.
 *
 *  Value: "SINGLE_VLAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_InstanceConfig_NetworkConfig_SingleVlan;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_LogicalNetworkInterface.networkType

/**
 *  Client network, a network peered to a Google Cloud VPC.
 *
 *  Value: "CLIENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_LogicalNetworkInterface_NetworkType_Client;
/**
 *  Private network, a network local to the Bare Metal Solution environment.
 *
 *  Value: "PRIVATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_LogicalNetworkInterface_NetworkType_Private;
/**
 *  Unspecified value.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_LogicalNetworkInterface_NetworkType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Lun.multiprotocolType

/**
 *  Server with Linux OS.
 *
 *  Value: "LINUX"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_MultiprotocolType_Linux;
/**
 *  Server has no OS specified.
 *
 *  Value: "MULTIPROTOCOL_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_MultiprotocolType_MultiprotocolTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Lun.state

/**
 *  The LUN is in cool off state. It will be deleted after `expire_time`.
 *
 *  Value: "COOL_OFF"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_State_CoolOff;
/**
 *  The LUN is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_State_Creating;
/**
 *  The LUN has been requested to be deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_State_Deleting;
/**
 *  The LUN is ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_State_Ready;
/**
 *  The LUN is in an unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_State_StateUnspecified;
/**
 *  The LUN is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_State_Updating;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Lun.storageType

/**
 *  This storage type for this LUN is HDD.
 *
 *  Value: "HDD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_StorageType_Hdd;
/**
 *  This storage type for this LUN is SSD.
 *
 *  Value: "SSD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_StorageType_Ssd;
/**
 *  The storage type for this LUN is unknown.
 *
 *  Value: "STORAGE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Lun_StorageType_StorageTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Network.state

/**
 *  The Network is being deprovisioned.
 *
 *  Value: "DEPROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_State_Deprovisioning;
/**
 *  The Network has been provisioned.
 *
 *  Value: "PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_State_Provisioned;
/**
 *  The Network is provisioning.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_State_Provisioning;
/**
 *  The Network is in an unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_State_StateUnspecified;
/**
 *  The Network is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_State_Updating;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Network.type

/**
 *  Client network, a network peered to a Google Cloud VPC.
 *
 *  Value: "CLIENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_Type_Client;
/**
 *  Private network, a network local to the Bare Metal Solution environment.
 *
 *  Value: "PRIVATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_Type_Private;
/**
 *  Unspecified value.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Network_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_NetworkConfig.bandwidth

/**
 *  Unspecified value.
 *
 *  Value: "BANDWIDTH_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Bandwidth_BandwidthUnspecified;
/**
 *  10 Gbps.
 *
 *  Value: "BW_10_GBPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw10Gbps;
/**
 *  1 Gbps.
 *
 *  Value: "BW_1_GBPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw1Gbps;
/**
 *  2 Gbps.
 *
 *  Value: "BW_2_GBPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw2Gbps;
/**
 *  5 Gbps.
 *
 *  Value: "BW_5_GBPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw5Gbps;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_NetworkConfig.serviceCidr

/**
 *  Services are disabled for the given network.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_Disabled;
/**
 *  Use the highest /26 block of the network to host services.
 *
 *  Value: "HIGH_26"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_High26;
/**
 *  Use the highest /27 block of the network to host services.
 *
 *  Value: "HIGH_27"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_High27;
/**
 *  Use the highest /28 block of the network to host services.
 *
 *  Value: "HIGH_28"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_High28;
/**
 *  Unspecified value.
 *
 *  Value: "SERVICE_CIDR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_ServiceCidrUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_NetworkConfig.type

/**
 *  Client network, that is a network peered to a GCP VPC.
 *
 *  Value: "CLIENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Type_Client;
/**
 *  Private network, that is a network local to the BMS POD.
 *
 *  Value: "PRIVATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Type_Private;
/**
 *  Unspecified value.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NetworkConfig_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_NfsExport.permissions

/**
 *  Unspecified value.
 *
 *  Value: "PERMISSIONS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsExport_Permissions_PermissionsUnspecified;
/**
 *  Read-only permission.
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsExport_Permissions_ReadOnly;
/**
 *  Read-write permission.
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsExport_Permissions_ReadWrite;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_NfsShare.state

/**
 *  The NFS Share is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_State_Creating;
/**
 *  The NFS Share has been requested to be deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_State_Deleting;
/**
 *  The share has been provisioned.
 *
 *  Value: "PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_State_Provisioned;
/**
 *  The share is in an unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_State_StateUnspecified;
/**
 *  The NFS Share is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_State_Updating;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_NfsShare.storageType

/**
 *  This storage type for this volume is HDD.
 *
 *  Value: "HDD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_StorageType_Hdd;
/**
 *  The storage type for this volume is SSD.
 *
 *  Value: "SSD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_StorageType_Ssd;
/**
 *  The storage type for this volume is unknown.
 *
 *  Value: "STORAGE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_NfsShare_StorageType_StorageTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_ProvisioningConfig.state

/**
 *  ProvisioningConfig was canceled.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Cancelled;
/**
 *  ProvisioningConfig is a draft and can be freely modified.
 *
 *  Value: "DRAFT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Draft;
/**
 *  The request is submitted for provisioning, with error return.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Failed;
/**
 *  ProvisioningConfig was provisioned, meaning the resources exist.
 *
 *  Value: "PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Provisioned;
/**
 *  ProvisioningConfig was in the provisioning state. Initially this state comes
 *  from the work order table in big query when SNOW is used. Later this field
 *  can be set by the work order API.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Provisioning;
/**
 *  State wasn't specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_StateUnspecified;
/**
 *  ProvisioningConfig was already submitted and cannot be modified.
 *
 *  Value: "SUBMITTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Submitted;
/**
 *  ProvisioningConfig was validated. A validation tool will be run to set this
 *  state.
 *
 *  Value: "VALIDATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningConfig_State_Validated;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_ProvisioningQuota.assetType

/**
 *  The network asset type.
 *
 *  Value: "ASSET_TYPE_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeNetwork;
/**
 *  The server asset type.
 *
 *  Value: "ASSET_TYPE_SERVER"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeServer;
/**
 *  The storage asset type.
 *
 *  Value: "ASSET_TYPE_STORAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeStorage;
/**
 *  The unspecified type.
 *
 *  Value: "ASSET_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Volume.performanceTier

/**
 *  Assigned aggregates.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_ASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierAssigned;
/**
 *  High throughput aggregates.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_HT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierHt;
/**
 *  Regular volumes, shared aggregates.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_SHARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierShared;
/**
 *  Value is not specified.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Volume.protocol

/**
 *  Fibre Channel protocol.
 *
 *  Value: "FIBRE_CHANNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_Protocol_FibreChannel;
/**
 *  NFS protocol means Volume is a NFS Share volume. Such volumes cannot be
 *  manipulated via Volumes API.
 *
 *  Value: "NFS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_Protocol_Nfs;
/**
 *  Value is not specified.
 *
 *  Value: "PROTOCOL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_Protocol_ProtocolUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Volume.snapshotAutoDeleteBehavior

/**
 *  Don't delete any snapshots. This disables new snapshot creation, as long as
 *  the snapshot reserved space is full.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_Disabled;
/**
 *  Delete the newest snapshots first.
 *
 *  Value: "NEWEST_FIRST"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_NewestFirst;
/**
 *  Delete the oldest snapshots first.
 *
 *  Value: "OLDEST_FIRST"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_OldestFirst;
/**
 *  The unspecified behavior.
 *
 *  Value: "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_SnapshotAutoDeleteBehaviorUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Volume.state

/**
 *  The storage volume is in cool off state. It will be deleted after
 *  `expire_time`.
 *
 *  Value: "COOL_OFF"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_State_CoolOff;
/**
 *  The storage volume is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_State_Creating;
/**
 *  The storage volume has been requested to be deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_State_Deleting;
/**
 *  The storage volume is ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_State_Ready;
/**
 *  The storage volume is in an unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_State_StateUnspecified;
/**
 *  The storage volume is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_State_Updating;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Volume.storageType

/**
 *  This storage type for this volume is HDD.
 *
 *  Value: "HDD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_StorageType_Hdd;
/**
 *  The storage type for this volume is SSD.
 *
 *  Value: "SSD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_StorageType_Ssd;
/**
 *  The storage type for this volume is unknown.
 *
 *  Value: "STORAGE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_StorageType_StorageTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_Volume.workloadProfile

/**
 *  The workload profile is generic.
 *
 *  Value: "GENERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_WorkloadProfile_Generic;
/**
 *  The workload profile is hana.
 *
 *  Value: "HANA"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_WorkloadProfile_Hana;
/**
 *  The workload profile is in an unknown state.
 *
 *  Value: "WORKLOAD_PROFILE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_Volume_WorkloadProfile_WorkloadProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_VolumeConfig.performanceTier

/**
 *  Assigned aggregates.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_ASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierAssigned;
/**
 *  High throughput aggregates.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_HT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierHt;
/**
 *  Regular volumes, shared aggregates.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_SHARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierShared;
/**
 *  Value is not specified.
 *
 *  Value: "VOLUME_PERFORMANCE_TIER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_VolumeConfig.protocol

/**
 *  Fibre channel.
 *
 *  Value: "PROTOCOL_FC"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_Protocol_ProtocolFc;
/**
 *  Network file system.
 *
 *  Value: "PROTOCOL_NFS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_Protocol_ProtocolNfs;
/**
 *  Unspecified value.
 *
 *  Value: "PROTOCOL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_Protocol_ProtocolUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_VolumeConfig.type

/**
 *  This Volume is on disk.
 *
 *  Value: "DISK"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_Type_Disk;
/**
 *  This Volume is on flash.
 *
 *  Value: "FLASH"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_Type_Flash;
/**
 *  The unspecified type.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeConfig_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_VolumeSnapshot.type

/**
 *  Snapshot was taken manually by user.
 *
 *  Value: "AD_HOC"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeSnapshot_Type_AdHoc;
/**
 *  Snapshot was taken automatically as a part of a snapshot schedule.
 *
 *  Value: "SCHEDULED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeSnapshot_Type_Scheduled;
/**
 *  Type is not specified.
 *
 *  Value: "SNAPSHOT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VolumeSnapshot_Type_SnapshotTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBareMetalSolution_VRF.state

/**
 *  The vrf is provisioned.
 *
 *  Value: "PROVISIONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VRF_State_Provisioned;
/**
 *  The vrf is provisioning.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VRF_State_Provisioning;
/**
 *  The unspecified state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBareMetalSolution_VRF_State_StateUnspecified;

/**
 *  Represents an 'access point' for the share.
 */
@interface GTLRBareMetalSolution_AllowedClient : GTLRObject

/**
 *  Allow dev flag. Which controls whether to allow creation of devices.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowDev;

/** The subnet of IP addresses permitted to access the share. */
@property(nonatomic, copy, nullable) NSString *allowedClientsCidr;

/**
 *  Allow the setuid flag.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowSuid;

/**
 *  Mount permissions.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_AllowedClient_MountPermissions_MountPermissionsUnspecified
 *        Permissions were not specified. (Value:
 *        "MOUNT_PERMISSIONS_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_AllowedClient_MountPermissions_Read NFS
 *        share can be mount with read-only permissions. (Value: "READ")
 *    @arg @c kGTLRBareMetalSolution_AllowedClient_MountPermissions_ReadWrite
 *        NFS share can be mount with read-write permissions. (Value:
 *        "READ_WRITE")
 */
@property(nonatomic, copy, nullable) NSString *mountPermissions;

/** The network the access point sits on. */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Output only. The path to access NFS, in format shareIP:/InstanceID
 *  InstanceID is the generated ID instead of customer provided name. example
 *  like "10.0.0.0:/g123456789-nfs001"
 */
@property(nonatomic, copy, nullable) NSString *nfsPath;

/**
 *  Disable root squashing, which is a feature of NFS. Root squash is a special
 *  mapping of the remote superuser (root) identity when using identity
 *  authentication.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *noRootSquash;

/**
 *  Output only. The IP address of the share on this network. Assigned
 *  automatically during provisioning based on the network's services_cidr.
 */
@property(nonatomic, copy, nullable) NSString *shareIp;

@end


/**
 *  Message for detach specific LUN from an Instance.
 */
@interface GTLRBareMetalSolution_DetachLunRequest : GTLRObject

/** Required. Name of the Lun to detach. */
@property(nonatomic, copy, nullable) NSString *lun;

/**
 *  If true, performs lun unmapping without instance reboot.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipReboot;

@end


/**
 *  Message for disabling the interactive serial console on an instance.
 */
@interface GTLRBareMetalSolution_DisableInteractiveSerialConsoleRequest : GTLRObject
@end


/**
 *  Message for response of DisableInteractiveSerialConsole.
 */
@interface GTLRBareMetalSolution_DisableInteractiveSerialConsoleResponse : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRBareMetalSolution_Empty : GTLRObject
@end


/**
 *  Message for enabling the interactive serial console on an instance.
 */
@interface GTLRBareMetalSolution_EnableInteractiveSerialConsoleRequest : GTLRObject
@end


/**
 *  Message for response of EnableInteractiveSerialConsole.
 */
@interface GTLRBareMetalSolution_EnableInteractiveSerialConsoleResponse : GTLRObject
@end


/**
 *  Request for skip lun cooloff and delete it.
 */
@interface GTLRBareMetalSolution_EvictLunRequest : GTLRObject
@end


/**
 *  Request for skip volume cooloff and delete it.
 */
@interface GTLRBareMetalSolution_EvictVolumeRequest : GTLRObject
@end


/**
 *  Each logical interface represents a logical abstraction of the underlying
 *  physical interface (for eg. bond, nic) of the instance. Each logical
 *  interface can effectively map to multiple network-IP pairs and still be
 *  mapped to one underlying physical interface.
 */
@interface GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2LogicalInterface : GTLRObject

/**
 *  The index of the logical interface mapping to the index of the hardware bond
 *  or nic on the chosen network template. This field is deprecated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *interfaceIndex GTLR_DEPRECATED;

/** List of logical network interfaces within a logical interface. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_LogicalNetworkInterface *> *logicalNetworkInterfaces;

/**
 *  Interface name. This is of syntax or and forms part of the network template
 *  name.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Logical interface.
 */
@interface GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface : GTLRObject

/**
 *  Interface name. This is not a globally unique identifier. Name is unique
 *  only inside the ServerNetworkTemplate. This is of syntax or and forms part
 *  of the network template name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If true, interface must have network connected.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *required;

/**
 *  Interface type.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface_Type_Bond
 *        Bond interface type. (Value: "BOND")
 *    @arg @c kGTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface_Type_InterfaceTypeUnspecified
 *        Unspecified value. (Value: "INTERFACE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface_Type_Nic
 *        NIC interface type. (Value: "NIC")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A server.
 */
@interface GTLRBareMetalSolution_Instance : GTLRObject

/** Output only. Create a time stamp. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The firmware version for the instance. */
@property(nonatomic, copy, nullable) NSString *firmwareVersion;

/**
 *  True if you enable hyperthreading for the server, otherwise false. The
 *  default value is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hyperthreadingEnabled;

/**
 *  Output only. An identifier for the `Instance`, generated by the backend.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Output only. True if the interactive serial console feature is enabled for
 *  the instance, false otherwise. The default value is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *interactiveSerialConsoleEnabled;

/** Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Instance_Labels *labels;

/**
 *  List of logical interfaces for the instance. The number of logical
 *  interfaces will be the same as number of hardware bond/nic on the chosen
 *  network template. For the non-multivlan configurations (for eg, existing
 *  servers) that use existing default network template (bondaa-bondaa), both
 *  the Instance.networks field and the Instance.logical_interfaces fields will
 *  be filled to ensure backward compatibility. For the others, only
 *  Instance.logical_interfaces will be filled.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2LogicalInterface *> *logicalInterfaces;

/** Output only. Text field about info for logging in. */
@property(nonatomic, copy, nullable) NSString *loginInfo;

/** Immutable. List of LUNs associated with this server. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Lun *> *luns;

/**
 *  Immutable. The server type. [Available server
 *  types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
 */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  Immutable. The resource name of this `Instance`. Resource names are
 *  schemeless URIs that follow the conventions in
 *  https://cloud.google.com/apis/design/resource_names. Format:
 *  `projects/{project}/locations/{location}/instances/{instance}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. List of networks associated with this server. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Network *> *networks;

/**
 *  Instance network template name. For eg, bondaa-bondaa, bondab-nic, etc.
 *  Generally, the template name follows the syntax of "bond" or "nic".
 */
@property(nonatomic, copy, nullable) NSString *networkTemplate;

/** The OS image currently installed on the server. */
@property(nonatomic, copy, nullable) NSString *osImage;

/**
 *  Immutable. Pod name. Pod is an independent part of infrastructure. Instance
 *  can be connected to the assets (networks, volumes) allocated in the same pod
 *  only.
 */
@property(nonatomic, copy, nullable) NSString *pod;

/**
 *  Output only. The state of the server.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Deleted The server has been
 *        deleted. (Value: "DELETED")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Provisioning The server is
 *        being provisioned. (Value: "PROVISIONING")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Running The server is
 *        running. (Value: "RUNNING")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Shutdown The server is
 *        shutdown. (Value: "SHUTDOWN")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Starting The server is
 *        starting. (Value: "STARTING")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_StateUnspecified The server
 *        is in an unknown state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Stopping The server is
 *        stopping. (Value: "STOPPING")
 *    @arg @c kGTLRBareMetalSolution_Instance_State_Updating The server is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. Update a time stamp. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Input only. List of Volumes to attach to this Instance on creation. This
 *  field won't be populated in Get/List responses.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Volume *> *volumes;

/**
 *  The workload profile for the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Instance_WorkloadProfile_WorkloadProfileGeneric
 *        The workload profile is generic. (Value: "WORKLOAD_PROFILE_GENERIC")
 *    @arg @c kGTLRBareMetalSolution_Instance_WorkloadProfile_WorkloadProfileHana
 *        The workload profile is hana. (Value: "WORKLOAD_PROFILE_HANA")
 *    @arg @c kGTLRBareMetalSolution_Instance_WorkloadProfile_WorkloadProfileUnspecified
 *        The workload profile is in an unknown state. (Value:
 *        "WORKLOAD_PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *workloadProfile;

@end


/**
 *  Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBareMetalSolution_Instance_Labels : GTLRObject
@end


/**
 *  Configuration parameters for a new instance.
 */
@interface GTLRBareMetalSolution_InstanceConfig : GTLRObject

/**
 *  If true networks can be from different projects of the same vendor account.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *accountNetworksEnabled;

/**
 *  Client network address. Filled if InstanceConfig.multivlan_config is false.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_NetworkAddress *clientNetwork GTLR_DEPRECATED;

/**
 *  Whether the instance should be provisioned with Hyperthreading enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hyperthreading;

/**
 *  A transient unique identifier to idenfity an instance within an
 *  ProvisioningConfig request.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Instance type. [Available
 *  types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
 */
@property(nonatomic, copy, nullable) NSString *instanceType;

/**
 *  List of logical interfaces for the instance. The number of logical
 *  interfaces will be the same as number of hardware bond/nic on the chosen
 *  network template. Filled if InstanceConfig.multivlan_config is true.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2LogicalInterface *> *logicalInterfaces;

/** Output only. The name of the instance config. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The type of network configuration on the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_InstanceConfig_NetworkConfig_MultiVlan
 *        Instance part of multiple (or single) client networks and private
 *        networks. (Value: "MULTI_VLAN")
 *    @arg @c kGTLRBareMetalSolution_InstanceConfig_NetworkConfig_NetworkconfigUnspecified
 *        The unspecified network configuration. (Value:
 *        "NETWORKCONFIG_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_InstanceConfig_NetworkConfig_SingleVlan
 *        Instance part of single client network and single private network.
 *        (Value: "SINGLE_VLAN")
 */
@property(nonatomic, copy, nullable) NSString *networkConfig;

/**
 *  Server network template name. Filled if InstanceConfig.multivlan_config is
 *  true.
 */
@property(nonatomic, copy, nullable) NSString *networkTemplate;

/**
 *  OS image to initialize the instance. [Available
 *  images](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
 */
@property(nonatomic, copy, nullable) NSString *osImage;

/**
 *  Private network address, if any. Filled if InstanceConfig.multivlan_config
 *  is false.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_NetworkAddress *privateNetwork GTLR_DEPRECATED;

/** List of names of ssh keys used to provision the instance. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *sshKeyNames;

/**
 *  User note field, it can be used by customers to add additional information
 *  for the BMS Ops team .
 */
@property(nonatomic, copy, nullable) NSString *userNote;

@end


/**
 *  A resource budget.
 */
@interface GTLRBareMetalSolution_InstanceQuota : GTLRObject

/**
 *  Number of machines than can be created for the given location and
 *  instance_type.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *availableMachineCount;

/** The gcp service of the provisioning quota. */
@property(nonatomic, copy, nullable) NSString *gcpService;

/** Instance type. Deprecated: use gcp_service. */
@property(nonatomic, copy, nullable) NSString *instanceType GTLR_DEPRECATED;

/** Location where the quota applies. */
@property(nonatomic, copy, nullable) NSString *location;

/** Output only. The name of the instance quota. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A GCP vlan attachment.
 */
@interface GTLRBareMetalSolution_IntakeVlanAttachment : GTLRObject

/**
 *  Identifier of the VLAN attachment.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Attachment pairing key. */
@property(nonatomic, copy, nullable) NSString *pairingKey;

@end


/**
 *  Response message for the list of servers.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListInstancesResponse : GTLRCollectionObject

/**
 *  The list of servers.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Instance *> *instances;

/** A token identifying a page of results from the server. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message containing the list of storage volume luns.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "luns" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListLunsResponse : GTLRCollectionObject

/**
 *  The list of luns.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Lun *> *luns;

/** A token identifying a page of results from the server. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message containing the list of networks.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "networks" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListNetworksResponse : GTLRCollectionObject

/**
 *  The list of networks.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Network *> *networks;

/** A token identifying a page of results from the server. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response with Networks with IPs
 */
@interface GTLRBareMetalSolution_ListNetworkUsageResponse : GTLRObject

/** Networks with IPs. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_NetworkUsage *> *networks;

@end


/**
 *  Response message containing the list of NFS shares.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "nfsShares" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListNfsSharesResponse : GTLRCollectionObject

/** A token identifying a page of results from the server. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of NFS shares.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_NfsShare *> *nfsShares;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Request for getting all available OS images.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "osImages" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListOSImagesResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The OS images available.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_OSImage *> *osImages;

@end


/**
 *  Response message for the list of provisioning quotas.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "provisioningQuotas" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRBareMetalSolution_ListProvisioningQuotasResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The provisioning quotas registered in this project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_ProvisioningQuota *> *provisioningQuotas;

@end


/**
 *  Message for response of ListSSHKeys.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "sshKeys" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListSSHKeysResponse : GTLRCollectionObject

/**
 *  Token to retrieve the next page of results, or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The SSH keys registered in the project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_SSHKey *> *sshKeys;

@end


/**
 *  Response message containing the list of volume snapshots.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "volumeSnapshots" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRBareMetalSolution_ListVolumeSnapshotsResponse : GTLRCollectionObject

/** A token identifying a page of results from the server. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

/**
 *  The list of snapshots.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_VolumeSnapshot *> *volumeSnapshots;

@end


/**
 *  Response message containing the list of storage volumes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "volumes" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBareMetalSolution_ListVolumesResponse : GTLRCollectionObject

/** A token identifying a page of results from the server. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

/**
 *  The list of storage volumes.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Volume *> *volumes;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRBareMetalSolution_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBareMetalSolution_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBareMetalSolution_Location_Metadata : GTLRObject
@end


/**
 *  Each logical network interface is effectively a network and IP pair.
 */
@interface GTLRBareMetalSolution_LogicalNetworkInterface : GTLRObject

/**
 *  Whether this interface is the default gateway for the instance. Only one
 *  interface can be the default gateway for the instance.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultGateway;

/**
 *  An identifier for the `Network`, generated by the backend.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** IP address in the network */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/** Name of the network */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Type of network.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_LogicalNetworkInterface_NetworkType_Client
 *        Client network, a network peered to a Google Cloud VPC. (Value:
 *        "CLIENT")
 *    @arg @c kGTLRBareMetalSolution_LogicalNetworkInterface_NetworkType_Private
 *        Private network, a network local to the Bare Metal Solution
 *        environment. (Value: "PRIVATE")
 *    @arg @c kGTLRBareMetalSolution_LogicalNetworkInterface_NetworkType_TypeUnspecified
 *        Unspecified value. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *networkType;

@end


/**
 *  A storage volume logical unit number (LUN).
 */
@interface GTLRBareMetalSolution_Lun : GTLRObject

/**
 *  Display if this LUN is a boot LUN.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bootLun;

/**
 *  Output only. Time after which LUN will be fully deleted. It is filled only
 *  for LUNs in COOL_OFF state.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  An identifier for the LUN, generated by the backend.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Output only. Instances this Lun is attached to. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instances;

/**
 *  The LUN multiprotocol type ensures the characteristics of the LUN are
 *  optimized for each operating system.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Lun_MultiprotocolType_Linux Server with
 *        Linux OS. (Value: "LINUX")
 *    @arg @c kGTLRBareMetalSolution_Lun_MultiprotocolType_MultiprotocolTypeUnspecified
 *        Server has no OS specified. (Value: "MULTIPROTOCOL_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *multiprotocolType;

/** Output only. The name of the LUN. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Display if this LUN can be shared between multiple physical servers.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *shareable;

/**
 *  The size of this LUN, in gigabytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeGb;

/**
 *  The state of this storage volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Lun_State_CoolOff The LUN is in cool off
 *        state. It will be deleted after `expire_time`. (Value: "COOL_OFF")
 *    @arg @c kGTLRBareMetalSolution_Lun_State_Creating The LUN is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRBareMetalSolution_Lun_State_Deleting The LUN has been
 *        requested to be deleted. (Value: "DELETING")
 *    @arg @c kGTLRBareMetalSolution_Lun_State_Ready The LUN is ready for use.
 *        (Value: "READY")
 *    @arg @c kGTLRBareMetalSolution_Lun_State_StateUnspecified The LUN is in an
 *        unknown state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_Lun_State_Updating The LUN is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The storage type for this LUN.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Lun_StorageType_Hdd This storage type for
 *        this LUN is HDD. (Value: "HDD")
 *    @arg @c kGTLRBareMetalSolution_Lun_StorageType_Ssd This storage type for
 *        this LUN is SSD. (Value: "SSD")
 *    @arg @c kGTLRBareMetalSolution_Lun_StorageType_StorageTypeUnspecified The
 *        storage type for this LUN is unknown. (Value:
 *        "STORAGE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *storageType;

/** Display the storage volume for this LUN. */
@property(nonatomic, copy, nullable) NSString *storageVolume;

/** The WWID for this LUN. */
@property(nonatomic, copy, nullable) NSString *wwid;

@end


/**
 *  A LUN(Logical Unit Number) range.
 */
@interface GTLRBareMetalSolution_LunRange : GTLRObject

/**
 *  Number of LUNs to create.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *quantity;

/**
 *  The requested size of each LUN, in GB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeGb;

@end


/**
 *  A Network.
 */
@interface GTLRBareMetalSolution_Network : GTLRObject

/** The cidr of the Network. */
@property(nonatomic, copy, nullable) NSString *cidr;

/** Output only. Gateway ip address. */
@property(nonatomic, copy, nullable) NSString *gatewayIp;

/**
 *  An identifier for the `Network`, generated by the backend.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** IP address configured. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/**
 *  Whether network uses standard frames or jumbo ones.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *jumboFramesEnabled;

/** Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Network_Labels *labels;

/** List of physical interfaces. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *macAddress;

/** Input only. List of mount points to attach the network to. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_NetworkMountPoint *> *mountPoints;

/**
 *  Output only. The resource name of this `Network`. Resource names are
 *  schemeless URIs that follow the conventions in
 *  https://cloud.google.com/apis/design/resource_names. Format:
 *  `projects/{project}/locations/{location}/networks/{network}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. Pod name. */
@property(nonatomic, copy, nullable) NSString *pod;

/**
 *  List of IP address reservations in this network. When updating this field,
 *  an error will be generated if a reservation conflicts with an IP address
 *  already allocated to a physical server.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_NetworkAddressReservation *> *reservations;

/** IP range for reserved for services (e.g. NFS). */
@property(nonatomic, copy, nullable) NSString *servicesCidr;

/**
 *  The Network state.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Network_State_Deprovisioning The Network is
 *        being deprovisioned. (Value: "DEPROVISIONING")
 *    @arg @c kGTLRBareMetalSolution_Network_State_Provisioned The Network has
 *        been provisioned. (Value: "PROVISIONED")
 *    @arg @c kGTLRBareMetalSolution_Network_State_Provisioning The Network is
 *        provisioning. (Value: "PROVISIONING")
 *    @arg @c kGTLRBareMetalSolution_Network_State_StateUnspecified The Network
 *        is in an unknown state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_Network_State_Updating The Network is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The type of this network.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Network_Type_Client Client network, a
 *        network peered to a Google Cloud VPC. (Value: "CLIENT")
 *    @arg @c kGTLRBareMetalSolution_Network_Type_Private Private network, a
 *        network local to the Bare Metal Solution environment. (Value:
 *        "PRIVATE")
 *    @arg @c kGTLRBareMetalSolution_Network_Type_TypeUnspecified Unspecified
 *        value. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

/** The vlan id of the Network. */
@property(nonatomic, copy, nullable) NSString *vlanId;

/** The vrf for the Network. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_VRF *vrf;

@end


/**
 *  Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBareMetalSolution_Network_Labels : GTLRObject
@end


/**
 *  A network.
 */
@interface GTLRBareMetalSolution_NetworkAddress : GTLRObject

/** IPv4 address to be assigned to the server. */
@property(nonatomic, copy, nullable) NSString *address;

/** Name of the existing network to use. */
@property(nonatomic, copy, nullable) NSString *existingNetworkId;

/** Id of the network to use, within the same ProvisioningConfig request. */
@property(nonatomic, copy, nullable) NSString *networkId;

@end


/**
 *  A reservation of one or more addresses in a network.
 */
@interface GTLRBareMetalSolution_NetworkAddressReservation : GTLRObject

/**
 *  The last address of this reservation block, inclusive. I.e., for cases when
 *  reservations are only single addresses, end_address and start_address will
 *  be the same. Must be specified as a single IPv4 address, e.g. 10.1.2.2.
 */
@property(nonatomic, copy, nullable) NSString *endAddress;

/** A note about this reservation, intended for human consumption. */
@property(nonatomic, copy, nullable) NSString *note;

/**
 *  The first address of this reservation block. Must be specified as a single
 *  IPv4 address, e.g. 10.1.2.2.
 */
@property(nonatomic, copy, nullable) NSString *startAddress;

@end


/**
 *  Configuration parameters for a new network.
 */
@interface GTLRBareMetalSolution_NetworkConfig : GTLRObject

/**
 *  Interconnect bandwidth. Set only when type is CLIENT.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Bandwidth_BandwidthUnspecified
 *        Unspecified value. (Value: "BANDWIDTH_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw10Gbps 10 Gbps.
 *        (Value: "BW_10_GBPS")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw1Gbps 1 Gbps.
 *        (Value: "BW_1_GBPS")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw2Gbps 2 Gbps.
 *        (Value: "BW_2_GBPS")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Bandwidth_Bw5Gbps 5 Gbps.
 *        (Value: "BW_5_GBPS")
 */
@property(nonatomic, copy, nullable) NSString *bandwidth;

/** CIDR range of the network. */
@property(nonatomic, copy, nullable) NSString *cidr;

/**
 *  The GCP service of the network. Available gcp_service are in
 *  https://cloud.google.com/bare-metal/docs/bms-planning.
 */
@property(nonatomic, copy, nullable) NSString *gcpService;

/**
 *  A transient unique identifier to identify a volume within an
 *  ProvisioningConfig request.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  The JumboFramesEnabled option for customer to set.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *jumboFramesEnabled;

/** Output only. The name of the network config. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Service CIDR, if any.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_Disabled Services
 *        are disabled for the given network. (Value: "DISABLED")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_High26 Use the
 *        highest /26 block of the network to host services. (Value: "HIGH_26")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_High27 Use the
 *        highest /27 block of the network to host services. (Value: "HIGH_27")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_High28 Use the
 *        highest /28 block of the network to host services. (Value: "HIGH_28")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_ServiceCidr_ServiceCidrUnspecified
 *        Unspecified value. (Value: "SERVICE_CIDR_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *serviceCidr;

/**
 *  The type of this network, either Client or Private.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Type_Client Client network,
 *        that is a network peered to a GCP VPC. (Value: "CLIENT")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Type_Private Private network,
 *        that is a network local to the BMS POD. (Value: "PRIVATE")
 *    @arg @c kGTLRBareMetalSolution_NetworkConfig_Type_TypeUnspecified
 *        Unspecified value. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  User note field, it can be used by customers to add additional information
 *  for the BMS Ops team .
 */
@property(nonatomic, copy, nullable) NSString *userNote;

/**
 *  List of VLAN attachments. As of now there are always 2 attachments, but it
 *  is going to change in the future (multi vlan).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_IntakeVlanAttachment *> *vlanAttachments;

/**
 *  Whether the VLAN attachment pair is located in the same project.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vlanSameProject;

@end


/**
 *  Mount point for a network.
 */
@interface GTLRBareMetalSolution_NetworkMountPoint : GTLRObject

/**
 *  Network should be a default gateway.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultGateway;

/** Instance to attach network to. */
@property(nonatomic, copy, nullable) NSString *instance;

/** Ip address of the server. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/** Logical interface to detach from. */
@property(nonatomic, copy, nullable) NSString *logicalInterface;

@end


/**
 *  Network with all used IP addresses.
 */
@interface GTLRBareMetalSolution_NetworkUsage : GTLRObject

/** Network. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Network *network;

/** All used IP addresses in this network. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *usedIps;

@end


/**
 *  A NFS export entry.
 */
@interface GTLRBareMetalSolution_NfsExport : GTLRObject

/**
 *  Allow dev flag in NfsShare AllowedClientsRequest.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowDev;

/**
 *  Allow the setuid flag.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowSuid;

/** A CIDR range. */
@property(nonatomic, copy, nullable) NSString *cidr;

/**
 *  Either a single machine, identified by an ID, or a comma-separated list of
 *  machine IDs.
 */
@property(nonatomic, copy, nullable) NSString *machineId;

/** Network to use to publish the export. */
@property(nonatomic, copy, nullable) NSString *networkId;

/**
 *  Disable root squashing, which is a feature of NFS. Root squash is a special
 *  mapping of the remote superuser (root) identity when using identity
 *  authentication.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *noRootSquash;

/**
 *  Export permissions.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_NfsExport_Permissions_PermissionsUnspecified
 *        Unspecified value. (Value: "PERMISSIONS_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_NfsExport_Permissions_ReadOnly Read-only
 *        permission. (Value: "READ_ONLY")
 *    @arg @c kGTLRBareMetalSolution_NfsExport_Permissions_ReadWrite Read-write
 *        permission. (Value: "READ_WRITE")
 */
@property(nonatomic, copy, nullable) NSString *permissions;

@end


/**
 *  An NFS share.
 */
@interface GTLRBareMetalSolution_NfsShare : GTLRObject

/** List of allowed access points. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_AllowedClient *> *allowedClients;

/**
 *  Output only. An identifier for the NFS share, generated by the backend. This
 *  is the same value as nfs_share_id and will replace it in the future.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_NfsShare_Labels *labels;

/** Immutable. The name of the NFS share. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. An identifier for the NFS share, generated by the backend. This
 *  field will be deprecated in the future, use `id` instead.
 */
@property(nonatomic, copy, nullable) NSString *nfsShareId;

/**
 *  The requested size, in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedSizeGib;

/**
 *  Output only. The state of the NFS share.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_NfsShare_State_Creating The NFS Share is
 *        being created. (Value: "CREATING")
 *    @arg @c kGTLRBareMetalSolution_NfsShare_State_Deleting The NFS Share has
 *        been requested to be deleted. (Value: "DELETING")
 *    @arg @c kGTLRBareMetalSolution_NfsShare_State_Provisioned The share has
 *        been provisioned. (Value: "PROVISIONED")
 *    @arg @c kGTLRBareMetalSolution_NfsShare_State_StateUnspecified The share
 *        is in an unknown state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_NfsShare_State_Updating The NFS Share is
 *        being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Immutable. The storage type of the underlying volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_NfsShare_StorageType_Hdd This storage type
 *        for this volume is HDD. (Value: "HDD")
 *    @arg @c kGTLRBareMetalSolution_NfsShare_StorageType_Ssd The storage type
 *        for this volume is SSD. (Value: "SSD")
 *    @arg @c kGTLRBareMetalSolution_NfsShare_StorageType_StorageTypeUnspecified
 *        The storage type for this volume is unknown. (Value:
 *        "STORAGE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *storageType;

/**
 *  Output only. The underlying volume of the share. Created automatically
 *  during provisioning.
 */
@property(nonatomic, copy, nullable) NSString *volume;

@end


/**
 *  Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBareMetalSolution_NfsShare_Labels : GTLRObject
@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRBareMetalSolution_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBareMetalSolution_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBareMetalSolution_Operation_Response : GTLRObject
@end


/**
 *  Operation System image.
 */
@interface GTLRBareMetalSolution_OSImage : GTLRObject

/**
 *  Instance types this image is applicable to. [Available
 *  types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *applicableInstanceTypes;

/** OS Image code. */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  OS Image description.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Output only. OS Image's unique name. */
@property(nonatomic, copy, nullable) NSString *name;

/** Network templates that can be used with this OS Image. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *supportedNetworkTemplates;

@end


/**
 *  A provisioning configuration.
 */
@interface GTLRBareMetalSolution_ProvisioningConfig : GTLRObject

/** Output only. URI to Cloud Console UI view of this provisioning config. */
@property(nonatomic, copy, nullable) NSString *cloudConsoleUri;

/** Optional. The user-defined identifier of the provisioning config. */
@property(nonatomic, copy, nullable) NSString *customId;

/**
 *  Email provided to send a confirmation with provisioning config to.
 *  Deprecated in favour of email field in request messages.
 */
@property(nonatomic, copy, nullable) NSString *email GTLR_DEPRECATED;

/**
 *  A service account to enable customers to access instance credentials upon
 *  handover.
 */
@property(nonatomic, copy, nullable) NSString *handoverServiceAccount;

/** Instances to be created. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_InstanceConfig *> *instances;

/**
 *  Optional. Location name of this ProvisioningConfig. It is optional only for
 *  Intake UI transition period.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Output only. The system-generated name of the provisioning config. This
 *  follows the UUID format.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Networks to be created. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_NetworkConfig *> *networks;

/**
 *  Output only. State of ProvisioningConfig.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Cancelled
 *        ProvisioningConfig was canceled. (Value: "CANCELLED")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Draft
 *        ProvisioningConfig is a draft and can be freely modified. (Value:
 *        "DRAFT")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Failed The request
 *        is submitted for provisioning, with error return. (Value: "FAILED")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Provisioned
 *        ProvisioningConfig was provisioned, meaning the resources exist.
 *        (Value: "PROVISIONED")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Provisioning
 *        ProvisioningConfig was in the provisioning state. Initially this state
 *        comes from the work order table in big query when SNOW is used. Later
 *        this field can be set by the work order API. (Value: "PROVISIONING")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_StateUnspecified
 *        State wasn't specified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Submitted
 *        ProvisioningConfig was already submitted and cannot be modified.
 *        (Value: "SUBMITTED")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningConfig_State_Validated
 *        ProvisioningConfig was validated. A validation tool will be run to set
 *        this state. (Value: "VALIDATED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Optional status messages associated with the FAILED state. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/** A generated ticket id to track provisioning request. */
@property(nonatomic, copy, nullable) NSString *ticketId;

/** Output only. Last update timestamp. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Volumes to be created. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_VolumeConfig *> *volumes;

/**
 *  If true, VPC SC is enabled for the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vpcScEnabled;

@end


/**
 *  A provisioning quota for a given project.
 */
@interface GTLRBareMetalSolution_ProvisioningQuota : GTLRObject

/**
 *  The asset type of this provisioning quota.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeNetwork
 *        The network asset type. (Value: "ASSET_TYPE_NETWORK")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeServer
 *        The server asset type. (Value: "ASSET_TYPE_SERVER")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeStorage
 *        The storage asset type. (Value: "ASSET_TYPE_STORAGE")
 *    @arg @c kGTLRBareMetalSolution_ProvisioningQuota_AssetType_AssetTypeUnspecified
 *        The unspecified type. (Value: "ASSET_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *assetType;

/**
 *  The available count of the provisioning quota.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *availableCount;

/** The gcp service of the provisioning quota. */
@property(nonatomic, copy, nullable) NSString *gcpService;

/** Instance quota. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_InstanceQuota *instanceQuota;

/** The specific location of the provisioining quota. */
@property(nonatomic, copy, nullable) NSString *location;

/** Output only. The name of the provisioning quota. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Network bandwidth, Gbps
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkBandwidth;

/**
 *  Server count.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *serverCount;

/**
 *  Storage size (GB).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *storageGib;

@end


/**
 *  QOS policy parameters.
 */
@interface GTLRBareMetalSolution_QosPolicy : GTLRObject

/**
 *  The bandwidth permitted by the QOS policy, in gbps.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bandwidthGbps;

@end


/**
 *  Message requesting rename of a server.
 */
@interface GTLRBareMetalSolution_RenameInstanceRequest : GTLRObject

/** Required. The new `id` of the instance. */
@property(nonatomic, copy, nullable) NSString *newInstanceId NS_RETURNS_NOT_RETAINED;

@end


/**
 *  Message requesting rename of a server.
 */
@interface GTLRBareMetalSolution_RenameNetworkRequest : GTLRObject

/** Required. The new `id` of the network. */
@property(nonatomic, copy, nullable) NSString *newNetworkId NS_RETURNS_NOT_RETAINED;

@end


/**
 *  Message requesting rename of a server.
 */
@interface GTLRBareMetalSolution_RenameNfsShareRequest : GTLRObject

/** Required. The new `id` of the nfsshare. */
@property(nonatomic, copy, nullable) NSString *newNfsshareId NS_RETURNS_NOT_RETAINED;

@end


/**
 *  Message requesting rename of a server.
 */
@interface GTLRBareMetalSolution_RenameVolumeRequest : GTLRObject

/** Required. The new `id` of the volume. */
@property(nonatomic, copy, nullable) NSString *newVolumeId NS_RETURNS_NOT_RETAINED;

@end


/**
 *  Message requesting to reset a server.
 */
@interface GTLRBareMetalSolution_ResetInstanceRequest : GTLRObject
@end


/**
 *  Response message from resetting a server.
 */
@interface GTLRBareMetalSolution_ResetInstanceResponse : GTLRObject
@end


/**
 *  Request for emergency resize Volume.
 */
@interface GTLRBareMetalSolution_ResizeVolumeRequest : GTLRObject

/**
 *  New Volume size, in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeGib;

@end


/**
 *  Message for restoring a volume snapshot.
 */
@interface GTLRBareMetalSolution_RestoreVolumeSnapshotRequest : GTLRObject
@end


/**
 *  Network template.
 */
@interface GTLRBareMetalSolution_ServerNetworkTemplate : GTLRObject

/** Instance types this template is applicable to. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *applicableInstanceTypes;

/** Logical interfaces. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_GoogleCloudBaremetalsolutionV2ServerNetworkTemplateLogicalInterface *> *logicalInterfaces;

/**
 *  Output only. Template's unique name. The full resource name follows the
 *  pattern:
 *  `projects/{project}/locations/{location}/serverNetworkTemplate/{server_network_template}`
 *  Generally, the {server_network_template} follows the syntax of "bond" or
 *  "nic".
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Details about snapshot space reservation and usage on the storage volume.
 */
@interface GTLRBareMetalSolution_SnapshotReservationDetail : GTLRObject

/**
 *  The space on this storage volume reserved for snapshots, shown in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reservedSpaceGib;

/**
 *  Percent of the total Volume size reserved for snapshot copies. Enabling
 *  snapshots requires reserving 20% or more of the storage volume space for
 *  snapshots. Maximum reserved space for snapshots is 40%. Setting this field
 *  will effectively set snapshot_enabled to true.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reservedSpacePercent;

/**
 *  The amount, in GiB, of available space in this storage volume's reserved
 *  snapshot space.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reservedSpaceRemainingGib;

/**
 *  The percent of snapshot space on this storage volume actually being used by
 *  the snapshot copies. This value might be higher than 100% if the snapshot
 *  copies have overflowed into the data portion of the storage volume.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reservedSpaceUsedPercent;

@end


/**
 *  An SSH key, used for authorizing with the interactive serial console
 *  feature.
 */
@interface GTLRBareMetalSolution_SSHKey : GTLRObject

/**
 *  Output only. The name of this SSH key. Currently, the only valid value for
 *  the location is "global".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The public SSH key. This must be in OpenSSH .authorized_keys format. */
@property(nonatomic, copy, nullable) NSString *publicKey;

@end


/**
 *  Message requesting to start a server.
 */
@interface GTLRBareMetalSolution_StartInstanceRequest : GTLRObject
@end


/**
 *  Response message from starting a server.
 */
@interface GTLRBareMetalSolution_StartInstanceResponse : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRBareMetalSolution_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRBareMetalSolution_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBareMetalSolution_Status_Details_Item : GTLRObject
@end


/**
 *  Message requesting to stop a server.
 */
@interface GTLRBareMetalSolution_StopInstanceRequest : GTLRObject
@end


/**
 *  Response message from stopping a server.
 */
@interface GTLRBareMetalSolution_StopInstanceResponse : GTLRObject
@end


/**
 *  Request for SubmitProvisioningConfig.
 */
@interface GTLRBareMetalSolution_SubmitProvisioningConfigRequest : GTLRObject

/**
 *  Optional. Email provided to send a confirmation with provisioning config to.
 */
@property(nonatomic, copy, nullable) NSString *email;

/** Required. The ProvisioningConfig to create. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_ProvisioningConfig *provisioningConfig;

@end


/**
 *  Response for SubmitProvisioningConfig.
 */
@interface GTLRBareMetalSolution_SubmitProvisioningConfigResponse : GTLRObject

/** The submitted provisioning config. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_ProvisioningConfig *provisioningConfig;

@end


/**
 *  VLAN attachment details.
 */
@interface GTLRBareMetalSolution_VlanAttachment : GTLRObject

/**
 *  Immutable. The identifier of the attachment within vrf.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Optional. The name of the vlan attachment within vrf. This is of the form
 *  projects/{project_number}/regions/{region}/interconnectAttachments/{interconnect_attachment}
 */
@property(nonatomic, copy, nullable) NSString *interconnectAttachment;

/** Input only. Pairing key. */
@property(nonatomic, copy, nullable) NSString *pairingKey;

/** The peer IP of the attachment. */
@property(nonatomic, copy, nullable) NSString *peerIp;

/**
 *  The peer vlan ID of the attachment.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *peerVlanId;

/**
 *  The QOS policy applied to this VLAN attachment. This value should be
 *  preferred to using qos at vrf level.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_QosPolicy *qosPolicy;

/** The router IP of the attachment. */
@property(nonatomic, copy, nullable) NSString *routerIp;

@end


/**
 *  A storage volume.
 */
@interface GTLRBareMetalSolution_Volume : GTLRObject

/**
 *  Output only. Is the Volume attached at at least one instance. This field is
 *  a lightweight counterpart of `instances` field. It is filled in List
 *  responses as well.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *attached;

/**
 *  The size, in GiB, that this storage volume has expanded as a result of an
 *  auto grow policy. In the absence of auto-grow, the value is 0.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoGrownSizeGib;

/**
 *  Output only. Whether this volume is a boot volume. A boot volume is one
 *  which contains a boot LUN.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bootVolume;

/**
 *  The current size of this storage volume, in GiB, including space reserved
 *  for snapshots. This size might be different than the requested size if the
 *  storage volume has been configured with auto grow or auto shrink.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *currentSizeGib;

/**
 *  Additional emergency size that was requested for this Volume, in GiB.
 *  current_size_gib includes this value.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *emergencySizeGib;

/**
 *  Output only. Time after which volume will be fully deleted. It is filled
 *  only for volumes in COOLOFF state.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  An identifier for the `Volume`, generated by the backend.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Output only. Instances this Volume is attached to. This field is set only in
 *  Get requests.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instances;

/** Labels as key value pairs. */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_Volume_Labels *labels;

/**
 *  Maximum size volume can be expanded to in case of evergency, in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxSizeGib;

/**
 *  Output only. The resource name of this `Volume`. Resource names are
 *  schemeless URIs that follow the conventions in
 *  https://cloud.google.com/apis/design/resource_names. Format:
 *  `projects/{project}/locations/{location}/volumes/{volume}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Input only. User-specified notes for new Volume. Used to provision Volumes
 *  that require manual intervention.
 */
@property(nonatomic, copy, nullable) NSString *notes;

/**
 *  Originally requested size, in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *originallyRequestedSizeGib;

/**
 *  Immutable. Performance tier of the Volume. Default is SHARED.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierAssigned
 *        Assigned aggregates. (Value: "VOLUME_PERFORMANCE_TIER_ASSIGNED")
 *    @arg @c kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierHt
 *        High throughput aggregates. (Value: "VOLUME_PERFORMANCE_TIER_HT")
 *    @arg @c kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierShared
 *        Regular volumes, shared aggregates. (Value:
 *        "VOLUME_PERFORMANCE_TIER_SHARED")
 *    @arg @c kGTLRBareMetalSolution_Volume_PerformanceTier_VolumePerformanceTierUnspecified
 *        Value is not specified. (Value: "VOLUME_PERFORMANCE_TIER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *performanceTier;

/** Immutable. Pod name. */
@property(nonatomic, copy, nullable) NSString *pod;

/**
 *  Output only. Storage protocol for the Volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Volume_Protocol_FibreChannel Fibre Channel
 *        protocol. (Value: "FIBRE_CHANNEL")
 *    @arg @c kGTLRBareMetalSolution_Volume_Protocol_Nfs NFS protocol means
 *        Volume is a NFS Share volume. Such volumes cannot be manipulated via
 *        Volumes API. (Value: "NFS")
 *    @arg @c kGTLRBareMetalSolution_Volume_Protocol_ProtocolUnspecified Value
 *        is not specified. (Value: "PROTOCOL_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *protocol;

/**
 *  The space remaining in the storage volume for new LUNs, in GiB, excluding
 *  space reserved for snapshots.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *remainingSpaceGib;

/**
 *  The requested size of this storage volume, in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedSizeGib;

/**
 *  The behavior to use when snapshot reserved space is full.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_Disabled
 *        Don't delete any snapshots. This disables new snapshot creation, as
 *        long as the snapshot reserved space is full. (Value: "DISABLED")
 *    @arg @c kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_NewestFirst
 *        Delete the newest snapshots first. (Value: "NEWEST_FIRST")
 *    @arg @c kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_OldestFirst
 *        Delete the oldest snapshots first. (Value: "OLDEST_FIRST")
 *    @arg @c kGTLRBareMetalSolution_Volume_SnapshotAutoDeleteBehavior_SnapshotAutoDeleteBehaviorUnspecified
 *        The unspecified behavior. (Value:
 *        "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *snapshotAutoDeleteBehavior;

/**
 *  Whether snapshots are enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotEnabled;

/**
 *  Details about snapshot space reservation and usage on the storage volume.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_SnapshotReservationDetail *snapshotReservationDetail;

/**
 *  The state of this storage volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Volume_State_CoolOff The storage volume is
 *        in cool off state. It will be deleted after `expire_time`. (Value:
 *        "COOL_OFF")
 *    @arg @c kGTLRBareMetalSolution_Volume_State_Creating The storage volume is
 *        being created. (Value: "CREATING")
 *    @arg @c kGTLRBareMetalSolution_Volume_State_Deleting The storage volume
 *        has been requested to be deleted. (Value: "DELETING")
 *    @arg @c kGTLRBareMetalSolution_Volume_State_Ready The storage volume is
 *        ready for use. (Value: "READY")
 *    @arg @c kGTLRBareMetalSolution_Volume_State_StateUnspecified The storage
 *        volume is in an unknown state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBareMetalSolution_Volume_State_Updating The storage volume is
 *        being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The storage type for this volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Volume_StorageType_Hdd This storage type
 *        for this volume is HDD. (Value: "HDD")
 *    @arg @c kGTLRBareMetalSolution_Volume_StorageType_Ssd The storage type for
 *        this volume is SSD. (Value: "SSD")
 *    @arg @c kGTLRBareMetalSolution_Volume_StorageType_StorageTypeUnspecified
 *        The storage type for this volume is unknown. (Value:
 *        "STORAGE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *storageType;

/**
 *  The workload profile for the volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_Volume_WorkloadProfile_Generic The workload
 *        profile is generic. (Value: "GENERIC")
 *    @arg @c kGTLRBareMetalSolution_Volume_WorkloadProfile_Hana The workload
 *        profile is hana. (Value: "HANA")
 *    @arg @c kGTLRBareMetalSolution_Volume_WorkloadProfile_WorkloadProfileUnspecified
 *        The workload profile is in an unknown state. (Value:
 *        "WORKLOAD_PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *workloadProfile;

@end


/**
 *  Labels as key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBareMetalSolution_Volume_Labels : GTLRObject
@end


/**
 *  Configuration parameters for a new volume.
 */
@interface GTLRBareMetalSolution_VolumeConfig : GTLRObject

/**
 *  The GCP service of the storage volume. Available gcp_service are in
 *  https://cloud.google.com/bare-metal/docs/bms-planning.
 */
@property(nonatomic, copy, nullable) NSString *gcpService;

/**
 *  A transient unique identifier to identify a volume within an
 *  ProvisioningConfig request.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** LUN ranges to be configured. Set only when protocol is PROTOCOL_FC. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_LunRange *> *lunRanges;

/**
 *  Machine ids connected to this volume. Set only when protocol is PROTOCOL_FC.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *machineIds;

/** Output only. The name of the volume config. */
@property(nonatomic, copy, nullable) NSString *name;

/** NFS exports. Set only when protocol is PROTOCOL_NFS. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_NfsExport *> *nfsExports;

/**
 *  Performance tier of the Volume. Default is SHARED.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierAssigned
 *        Assigned aggregates. (Value: "VOLUME_PERFORMANCE_TIER_ASSIGNED")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierHt
 *        High throughput aggregates. (Value: "VOLUME_PERFORMANCE_TIER_HT")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierShared
 *        Regular volumes, shared aggregates. (Value:
 *        "VOLUME_PERFORMANCE_TIER_SHARED")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_PerformanceTier_VolumePerformanceTierUnspecified
 *        Value is not specified. (Value: "VOLUME_PERFORMANCE_TIER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *performanceTier;

/**
 *  Volume protocol.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_Protocol_ProtocolFc Fibre
 *        channel. (Value: "PROTOCOL_FC")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_Protocol_ProtocolNfs Network
 *        file system. (Value: "PROTOCOL_NFS")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_Protocol_ProtocolUnspecified
 *        Unspecified value. (Value: "PROTOCOL_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *protocol;

/**
 *  The requested size of this volume, in GB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeGb;

/**
 *  Whether snapshots should be enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotsEnabled;

/**
 *  The type of this Volume.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_Type_Disk This Volume is on
 *        disk. (Value: "DISK")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_Type_Flash This Volume is on
 *        flash. (Value: "FLASH")
 *    @arg @c kGTLRBareMetalSolution_VolumeConfig_Type_TypeUnspecified The
 *        unspecified type. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  User note field, it can be used by customers to add additional information
 *  for the BMS Ops team .
 */
@property(nonatomic, copy, nullable) NSString *userNote;

@end


/**
 *  A snapshot of a volume. Only boot volumes can have snapshots.
 */
@interface GTLRBareMetalSolution_VolumeSnapshot : GTLRObject

/** Output only. The creation time of the snapshot. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The description of the snapshot.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. An identifier for the snapshot, generated by the backend.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** The name of the snapshot. */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. The name of the volume which this snapshot belongs to. */
@property(nonatomic, copy, nullable) NSString *storageVolume;

/**
 *  Output only. The type of the snapshot which indicates whether it was
 *  scheduled or manual/ad-hoc.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_VolumeSnapshot_Type_AdHoc Snapshot was
 *        taken manually by user. (Value: "AD_HOC")
 *    @arg @c kGTLRBareMetalSolution_VolumeSnapshot_Type_Scheduled Snapshot was
 *        taken automatically as a part of a snapshot schedule. (Value:
 *        "SCHEDULED")
 *    @arg @c kGTLRBareMetalSolution_VolumeSnapshot_Type_SnapshotTypeUnspecified
 *        Type is not specified. (Value: "SNAPSHOT_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A network VRF.
 */
@interface GTLRBareMetalSolution_VRF : GTLRObject

/** The name of the VRF. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The QOS policy applied to this VRF. The value is only meaningful when all
 *  the vlan attachments have the same QoS. This field should not be used for
 *  new integrations, use vlan attachment level qos instead. The field is left
 *  for backward-compatibility.
 */
@property(nonatomic, strong, nullable) GTLRBareMetalSolution_QosPolicy *qosPolicy;

/**
 *  The possible state of VRF.
 *
 *  Likely values:
 *    @arg @c kGTLRBareMetalSolution_VRF_State_Provisioned The vrf is
 *        provisioned. (Value: "PROVISIONED")
 *    @arg @c kGTLRBareMetalSolution_VRF_State_Provisioning The vrf is
 *        provisioning. (Value: "PROVISIONING")
 *    @arg @c kGTLRBareMetalSolution_VRF_State_StateUnspecified The unspecified
 *        state. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** The list of VLAN attachments for the VRF. */
@property(nonatomic, strong, nullable) NSArray<GTLRBareMetalSolution_VlanAttachment *> *vlanAttachments;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
