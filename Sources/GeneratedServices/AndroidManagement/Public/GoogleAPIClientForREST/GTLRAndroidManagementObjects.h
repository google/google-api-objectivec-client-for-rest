// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Android Management API (androidmanagement/v1)
// Description:
//   The Android Management API provides remote enterprise management of Android
//   devices and apps.
// Documentation:
//   https://developers.google.com/android/management

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAndroidManagement_AdbShellCommandEvent;
@class GTLRAndroidManagement_AdbShellInteractiveEvent;
@class GTLRAndroidManagement_AdvancedSecurityOverrides;
@class GTLRAndroidManagement_AlwaysOnVpnPackage;
@class GTLRAndroidManagement_ApiLevelCondition;
@class GTLRAndroidManagement_ApplicationEvent;
@class GTLRAndroidManagement_ApplicationPermission;
@class GTLRAndroidManagement_ApplicationPolicy;
@class GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration;
@class GTLRAndroidManagement_ApplicationReport;
@class GTLRAndroidManagement_ApplicationReportingSettings;
@class GTLRAndroidManagement_AppProcessInfo;
@class GTLRAndroidManagement_AppProcessStartEvent;
@class GTLRAndroidManagement_AppTrackInfo;
@class GTLRAndroidManagement_AppVersion;
@class GTLRAndroidManagement_BlockAction;
@class GTLRAndroidManagement_CertAuthorityInstalledEvent;
@class GTLRAndroidManagement_CertAuthorityRemovedEvent;
@class GTLRAndroidManagement_CertValidationFailureEvent;
@class GTLRAndroidManagement_ChoosePrivateKeyRule;
@class GTLRAndroidManagement_ClearAppsDataParams;
@class GTLRAndroidManagement_ClearAppsDataStatus;
@class GTLRAndroidManagement_ClearAppsDataStatus_Results;
@class GTLRAndroidManagement_CommonCriteriaModeInfo;
@class GTLRAndroidManagement_ComplianceRule;
@class GTLRAndroidManagement_ConnectEvent;
@class GTLRAndroidManagement_ContactInfo;
@class GTLRAndroidManagement_ContentProviderEndpoint;
@class GTLRAndroidManagement_CrossProfilePolicies;
@class GTLRAndroidManagement_CryptoSelfTestCompletedEvent;
@class GTLRAndroidManagement_Date;
@class GTLRAndroidManagement_Device;
@class GTLRAndroidManagement_Device_SystemProperties;
@class GTLRAndroidManagement_DeviceConnectivityManagement;
@class GTLRAndroidManagement_DeviceRadioState;
@class GTLRAndroidManagement_DeviceSettings;
@class GTLRAndroidManagement_Display;
@class GTLRAndroidManagement_DisplaySettings;
@class GTLRAndroidManagement_DnsEvent;
@class GTLRAndroidManagement_DpcMigrationInfo;
@class GTLRAndroidManagement_EnrollmentCompleteEvent;
@class GTLRAndroidManagement_EnrollmentToken;
@class GTLRAndroidManagement_Enterprise;
@class GTLRAndroidManagement_ExtensionConfig;
@class GTLRAndroidManagement_ExternalData;
@class GTLRAndroidManagement_FilePulledEvent;
@class GTLRAndroidManagement_FilePushedEvent;
@class GTLRAndroidManagement_FreezePeriod;
@class GTLRAndroidManagement_GoogleAuthenticationSettings;
@class GTLRAndroidManagement_HardwareInfo;
@class GTLRAndroidManagement_HardwareStatus;
@class GTLRAndroidManagement_InstallConstraint;
@class GTLRAndroidManagement_KeyDestructionEvent;
@class GTLRAndroidManagement_KeyedAppState;
@class GTLRAndroidManagement_KeyGeneratedEvent;
@class GTLRAndroidManagement_KeyguardDismissAuthAttemptEvent;
@class GTLRAndroidManagement_KeyguardDismissedEvent;
@class GTLRAndroidManagement_KeyguardSecuredEvent;
@class GTLRAndroidManagement_KeyImportEvent;
@class GTLRAndroidManagement_KeyIntegrityViolationEvent;
@class GTLRAndroidManagement_KioskCustomization;
@class GTLRAndroidManagement_LaunchAppAction;
@class GTLRAndroidManagement_Location;
@class GTLRAndroidManagement_LogBufferSizeCriticalEvent;
@class GTLRAndroidManagement_LoggingStartedEvent;
@class GTLRAndroidManagement_LoggingStoppedEvent;
@class GTLRAndroidManagement_LostModeLocationEvent;
@class GTLRAndroidManagement_LostModeOutgoingPhoneCallEvent;
@class GTLRAndroidManagement_ManagedConfigurationTemplate;
@class GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables;
@class GTLRAndroidManagement_ManagedProperty;
@class GTLRAndroidManagement_ManagedPropertyEntry;
@class GTLRAndroidManagement_MediaMountEvent;
@class GTLRAndroidManagement_MediaUnmountEvent;
@class GTLRAndroidManagement_MemoryEvent;
@class GTLRAndroidManagement_MemoryInfo;
@class GTLRAndroidManagement_MigrationToken;
@class GTLRAndroidManagement_NetworkInfo;
@class GTLRAndroidManagement_NonComplianceDetail;
@class GTLRAndroidManagement_NonComplianceDetailCondition;
@class GTLRAndroidManagement_OncCertificateProvider;
@class GTLRAndroidManagement_OncWifiContext;
@class GTLRAndroidManagement_Operation;
@class GTLRAndroidManagement_Operation_Metadata;
@class GTLRAndroidManagement_Operation_Response;
@class GTLRAndroidManagement_OsShutdownEvent;
@class GTLRAndroidManagement_OsStartupEvent;
@class GTLRAndroidManagement_PackageNameList;
@class GTLRAndroidManagement_PasswordPoliciesContext;
@class GTLRAndroidManagement_PasswordRequirements;
@class GTLRAndroidManagement_PerAppResult;
@class GTLRAndroidManagement_PermissionGrant;
@class GTLRAndroidManagement_PersistentPreferredActivity;
@class GTLRAndroidManagement_PersonalApplicationPolicy;
@class GTLRAndroidManagement_PersonalUsagePolicies;
@class GTLRAndroidManagement_Policy;
@class GTLRAndroidManagement_Policy_OpenNetworkConfiguration;
@class GTLRAndroidManagement_PolicyEnforcementRule;
@class GTLRAndroidManagement_PostureDetail;
@class GTLRAndroidManagement_PowerManagementEvent;
@class GTLRAndroidManagement_ProxyInfo;
@class GTLRAndroidManagement_RemoteLockEvent;
@class GTLRAndroidManagement_ScreenBrightnessSettings;
@class GTLRAndroidManagement_ScreenTimeoutSettings;
@class GTLRAndroidManagement_SecurityPosture;
@class GTLRAndroidManagement_SetupAction;
@class GTLRAndroidManagement_SigninDetail;
@class GTLRAndroidManagement_SoftwareInfo;
@class GTLRAndroidManagement_SpecificNonComplianceContext;
@class GTLRAndroidManagement_StartLostModeParams;
@class GTLRAndroidManagement_StartLostModeStatus;
@class GTLRAndroidManagement_Status;
@class GTLRAndroidManagement_Status_Details_Item;
@class GTLRAndroidManagement_StatusReportingSettings;
@class GTLRAndroidManagement_StopLostModeParams;
@class GTLRAndroidManagement_StopLostModeStatus;
@class GTLRAndroidManagement_StopLostModeUserAttemptEvent;
@class GTLRAndroidManagement_SystemUpdate;
@class GTLRAndroidManagement_SystemUpdateInfo;
@class GTLRAndroidManagement_TelephonyInfo;
@class GTLRAndroidManagement_TermsAndConditions;
@class GTLRAndroidManagement_UsageLog;
@class GTLRAndroidManagement_UsageLogEvent;
@class GTLRAndroidManagement_User;
@class GTLRAndroidManagement_UserFacingMessage;
@class GTLRAndroidManagement_UserFacingMessage_LocalizedMessages;
@class GTLRAndroidManagement_WebApp;
@class GTLRAndroidManagement_WebAppIcon;
@class GTLRAndroidManagement_WifiSsid;
@class GTLRAndroidManagement_WifiSsidPolicy;
@class GTLRAndroidManagement_WipeAction;
@class GTLRAndroidManagement_WipeFailureEvent;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.commonCriteriaMode

/**
 *  Default. Disables Common Criteria Mode.
 *
 *  Value: "COMMON_CRITERIA_MODE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeDisabled;
/**
 *  Enables Common Criteria Mode.
 *
 *  Value: "COMMON_CRITERIA_MODE_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeEnabled;
/**
 *  Unspecified. Defaults to COMMON_CRITERIA_MODE_DISABLED.
 *
 *  Value: "COMMON_CRITERIA_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.developerSettings

/**
 *  Allows all developer settings. The user can access and optionally configure
 *  the settings.
 *
 *  Value: "DEVELOPER_SETTINGS_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsAllowed;
/**
 *  Default. Disables all developer settings and prevents the user from
 *  accessing them.
 *
 *  Value: "DEVELOPER_SETTINGS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsDisabled;
/**
 *  Unspecified. Defaults to DEVELOPER_SETTINGS_DISABLED.
 *
 *  Value: "DEVELOPER_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.googlePlayProtectVerifyApps

/**
 *  Unspecified. Defaults to VERIFY_APPS_ENFORCED.
 *
 *  Value: "GOOGLE_PLAY_PROTECT_VERIFY_APPS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_GooglePlayProtectVerifyAppsUnspecified;
/**
 *  Default. Force-enables app verification.
 *
 *  Value: "VERIFY_APPS_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsEnforced;
/**
 *  Allows the user to choose whether to enable app verification.
 *
 *  Value: "VERIFY_APPS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.mtePolicy

/**
 *  MTE is disabled on the device and the user is not allowed to change this
 *  setting. This applies only on fully managed devices. In other cases, a
 *  nonComplianceDetail with MANAGEMENT_MODE is reported. A nonComplianceDetail
 *  with DEVICE_INCOMPATIBLE is reported if the device does not support
 *  MTE.Supported on Android 14 and above. A nonComplianceDetail with API_LEVEL
 *  is reported if the Android version is less than 14.
 *
 *  Value: "MTE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MteDisabled;
/**
 *  MTE is enabled on the device and the user is not allowed to change this
 *  setting. This can be set on fully managed devices and work profiles on
 *  company-owned devices. A nonComplianceDetail with MANAGEMENT_MODE is
 *  reported for other management modes. A nonComplianceDetail with
 *  DEVICE_INCOMPATIBLE is reported if the device does not support MTE.Supported
 *  on Android 14 and above. A nonComplianceDetail with API_LEVEL is reported if
 *  the Android version is less than 14.
 *
 *  Value: "MTE_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MteEnforced;
/**
 *  Unspecified. Defaults to MTE_USER_CHOICE.
 *
 *  Value: "MTE_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MtePolicyUnspecified;
/**
 *  The user can choose to enable or disable MTE on the device if the device
 *  supports this.
 *
 *  Value: "MTE_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MteUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.untrustedAppsPolicy

/**
 *  Allow untrusted app installs on entire device.
 *
 *  Value: "ALLOW_INSTALL_DEVICE_WIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallDeviceWide;
/**
 *  For devices with work profiles, allow untrusted app installs in the device's
 *  personal profile only.
 *
 *  Value: "ALLOW_INSTALL_IN_PERSONAL_PROFILE_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallInPersonalProfileOnly;
/**
 *  Default. Disallow untrusted app installs on entire device.
 *
 *  Value: "DISALLOW_INSTALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_DisallowInstall;
/**
 *  Unspecified. Defaults to DISALLOW_INSTALL.
 *
 *  Value: "UNTRUSTED_APPS_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_UntrustedAppsPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.appPricing

/**
 *  Unknown pricing, used to denote an approved app that is not generally
 *  available.
 *
 *  Value: "APP_PRICING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_AppPricingUnspecified;
/**
 *  The app is free.
 *
 *  Value: "FREE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_Free;
/**
 *  The app is free, but offers in-app purchases.
 *
 *  Value: "FREE_WITH_IN_APP_PURCHASE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_FreeWithInAppPurchase;
/**
 *  The app is paid.
 *
 *  Value: "PAID"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_Paid;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.contentRating

/**
 *  Unspecified.
 *
 *  Value: "CONTENT_RATING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_ContentRatingUnspecified;
/**
 *  Content suitable for ages 18 and above only.
 *
 *  Value: "EIGHTEEN_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_EighteenYears;
/**
 *  Content suitable for ages 7 and above only.
 *
 *  Value: "SEVEN_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_SevenYears;
/**
 *  Content suitable for ages 16 and above only.
 *
 *  Value: "SIXTEEN_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_SixteenYears;
/**
 *  Content suitable for ages 3 and above only.
 *
 *  Value: "THREE_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_ThreeYears;
/**
 *  Content suitable for ages 12 and above only.
 *
 *  Value: "TWELVE_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_TwelveYears;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.distributionChannel

/**
 *  Unspecified.
 *
 *  Value: "DISTRIBUTION_CHANNEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_DistributionChannelUnspecified;
/**
 *  Package is a private app (restricted to an enterprise) but hosted by Google.
 *
 *  Value: "PRIVATE_GOOGLE_HOSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_PrivateGoogleHosted;
/**
 *  Private app (restricted to an enterprise) and is privately hosted.
 *
 *  Value: "PRIVATE_SELF_HOSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_PrivateSelfHosted;
/**
 *  Package is available through the Play store and not restricted to a specific
 *  enterprise.
 *
 *  Value: "PUBLIC_GOOGLE_HOSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_PublicGoogleHosted;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.features

/**
 *  Unspecified.
 *
 *  Value: "APP_FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_Features_AppFeatureUnspecified;
/**
 *  The app is a VPN.
 *
 *  Value: "VPN_APP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_Features_VpnApp;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationEvent.eventType

/**
 *  This value is disallowed.
 *
 *  Value: "APPLICATION_EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_ApplicationEventTypeUnspecified;
/**
 *  The app was changed, for example, a component was enabled or disabled.
 *
 *  Value: "CHANGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Changed;
/**
 *  The app data was cleared.
 *
 *  Value: "DATA_CLEARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_DataCleared;
/**
 *  The app was installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Installed;
/**
 *  The app was pinned to the foreground.
 *
 *  Value: "PINNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Pinned;
/**
 *  The app was removed.
 *
 *  Value: "REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Removed;
/**
 *  A new version of the app has been installed, replacing the old version.
 *
 *  Value: "REPLACED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Replaced;
/**
 *  The app was restarted.
 *
 *  Value: "RESTARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Restarted;
/**
 *  The app was unpinned.
 *
 *  Value: "UNPINNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Unpinned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.alwaysOnVpnLockdownExemption

/**
 *  Unspecified. Defaults to VPN_LOCKDOWN_ENFORCED.
 *
 *  Value: "ALWAYS_ON_VPN_LOCKDOWN_EXEMPTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_AlwaysOnVpnLockdownExemptionUnspecified;
/**
 *  The app respects the always-on VPN lockdown setting.
 *
 *  Value: "VPN_LOCKDOWN_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownEnforced;
/**
 *  The app is exempt from the always-on VPN lockdown setting.
 *
 *  Value: "VPN_LOCKDOWN_EXEMPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownExemption;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.autoUpdateMode

/**
 *  The default update mode.The app is automatically updated with low priority
 *  to minimize the impact on the user.The app is updated when all of the
 *  following constraints are met: The device is not actively used. The device
 *  is connected to an unmetered network. The device is charging. The app to be
 *  updated is not running in the foreground.The device is notified about a new
 *  update within 24 hours after it is published by the developer, after which
 *  the app is updated the next time the constraints above are met.
 *
 *  Value: "AUTO_UPDATE_DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateDefault;
/**
 *  The app is updated as soon as possible. No constraints are applied.The
 *  device is notified as soon as possible about a new update after it becomes
 *  available.*NOTE:* Updates to apps with larger deployments across Android's
 *  ecosystem can take up to 24h.
 *
 *  Value: "AUTO_UPDATE_HIGH_PRIORITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateHighPriority;
/**
 *  Unspecified. Defaults to AUTO_UPDATE_DEFAULT.
 *
 *  Value: "AUTO_UPDATE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateModeUnspecified;
/**
 *  The app is not automatically updated for a maximum of 90 days after the app
 *  becomes out of date.90 days after the app becomes out of date, the latest
 *  available version is installed automatically with low priority (see
 *  AUTO_UPDATE_DEFAULT). After the app is updated it is not automatically
 *  updated again until 90 days after it becomes out of date again.The user can
 *  still manually update the app from the Play Store at any time.
 *
 *  Value: "AUTO_UPDATE_POSTPONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdatePostponed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.connectedWorkAndPersonalApp

/**
 *  Allows the app to communicate across profiles after receiving user consent.
 *
 *  Value: "CONNECTED_WORK_AND_PERSONAL_APP_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppAllowed;
/**
 *  Default. Prevents the app from communicating cross-profile.
 *
 *  Value: "CONNECTED_WORK_AND_PERSONAL_APP_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppDisallowed;
/**
 *  Unspecified. Defaults to CONNECTED_WORK_AND_PERSONAL_APPS_DISALLOWED.
 *
 *  Value: "CONNECTED_WORK_AND_PERSONAL_APP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.credentialProviderPolicy

/**
 *  App is allowed to act as a credential provider.
 *
 *  Value: "CREDENTIAL_PROVIDER_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_CredentialProviderPolicy_CredentialProviderAllowed;
/**
 *  Unspecified. The behaviour is governed by credentialProviderPolicyDefault.
 *
 *  Value: "CREDENTIAL_PROVIDER_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_CredentialProviderPolicy_CredentialProviderPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.On Android 12 and above,
 *  Manifest.permission.READ_SMS
 *  (https://developer.android.com/reference/android/Manifest.permission#READ_SMS)
 *  and following sensor-related permissions can only be granted on fully
 *  managed devices: Manifest.permission.ACCESS_FINE_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_FINE_LOCATION)
 *  Manifest.permission.ACCESS_BACKGROUND_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_BACKGROUND_LOCATION)
 *  Manifest.permission.ACCESS_COARSE_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_COARSE_LOCATION)
 *  Manifest.permission.CAMERA
 *  (https://developer.android.com/reference/android/Manifest.permission#CAMERA)
 *  Manifest.permission.RECORD_AUDIO
 *  (https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO)
 *  Manifest.permission.ACTIVITY_RECOGNITION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACTIVITY_RECOGNITION)
 *  Manifest.permission.BODY_SENSORS
 *  (https://developer.android.com/reference/android/Manifest.permission#BODY_SENSORS)
 *
 *  Value: "GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.delegatedScopes

/**
 *  Grants access to blocking uninstallation.
 *
 *  Value: "BLOCK_UNINSTALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_BlockUninstall;
/**
 *  Grants access to certificate installation and management.
 *
 *  Value: "CERT_INSTALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_CertInstall;
/**
 *  Grants access to selection of KeyChain certificates on behalf of requesting
 *  apps. Once granted, the delegated application will start receiving
 *  DelegatedAdminReceiver#onChoosePrivateKeyAlias
 *  (https://developer.android.com/reference/android/app/admin/DelegatedAdminReceiver#onChoosePrivateKeyAlias%28android.content.Context,%20android.content.Intent,%20int,%20android.net.Uri,%20java.lang.String%29).
 *  Allows the delegated application to call grantKeyPairToApp
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#grantKeyPairToApp%28android.content.ComponentName,%20java.lang.String,%20java.lang.String%29)
 *  and revokeKeyPairFromApp
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#revokeKeyPairFromApp%28android.content.ComponentName,%20java.lang.String,%20java.lang.String%29)
 *  methods. There can be at most one app that has this delegation.
 *  choosePrivateKeyRules must be empty and privateKeySelectionEnabled has no
 *  effect if certificate selection is delegated to an application.
 *
 *  Value: "CERT_SELECTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_CertSelection;
/**
 *  No delegation scope specified.
 *
 *  Value: "DELEGATED_SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_DelegatedScopeUnspecified;
/**
 *  Grants access for enabling system apps.
 *
 *  Value: "ENABLE_SYSTEM_APP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_EnableSystemApp;
/**
 *  Grants access to managed configurations management.
 *
 *  Value: "MANAGED_CONFIGURATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_ManagedConfigurations;
/**
 *  Grants access to network activity logs. Allows the delegated application to
 *  call setNetworkLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#setNetworkLoggingEnabled%28android.content.ComponentName,%20boolean%29),
 *  isNetworkLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#isNetworkLoggingEnabled%28android.content.ComponentName%29)
 *  and retrieveNetworkLogs
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#retrieveNetworkLogs%28android.content.ComponentName,%20long%29)
 *  methods. This scope can be delegated to at most one application. Supported
 *  for fully managed devices on Android 10 and above. Supported for a work
 *  profile on Android 12 and above. When delegation is supported and set,
 *  NETWORK_ACTIVITY_LOGS is ignored.
 *
 *  Value: "NETWORK_ACTIVITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_NetworkActivityLogs;
/**
 *  Grants access to package access state.
 *
 *  Value: "PACKAGE_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_PackageAccess;
/**
 *  Grants access to permission policy and permission grant state.
 *
 *  Value: "PERMISSION_GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_PermissionGrant;
/**
 *  Grants access to security logs. Allows the delegated application to call
 *  setSecurityLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#setSecurityLoggingEnabled%28android.content.ComponentName,%20boolean%29),
 *  isSecurityLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#isSecurityLoggingEnabled%28android.content.ComponentName%29),
 *  retrieveSecurityLogs
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#retrieveSecurityLogs%28android.content.ComponentName%29)
 *  and retrievePreRebootSecurityLogs
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#retrievePreRebootSecurityLogs%28android.content.ComponentName%29)
 *  methods. This scope can be delegated to at most one application. Supported
 *  for fully managed devices and company-owned devices with a work profile on
 *  Android 12 and above. When delegation is supported and set, SECURITY_LOGS is
 *  ignored.
 *
 *  Value: "SECURITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_SecurityLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.installType

/**
 *  The app is available to install.
 *
 *  Value: "AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Available;
/**
 *  The app is blocked and can't be installed. If the app was installed under a
 *  previous policy, it will be uninstalled. This also blocks its instant app
 *  functionality.
 *
 *  Value: "BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Blocked;
/**
 *  The app is automatically installed regardless of a set maintenance window
 *  and can't be removed by the user.
 *
 *  Value: "FORCE_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled;
/**
 *  Unspecified. Defaults to AVAILABLE.
 *
 *  Value: "INSTALL_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified;
/**
 *  The app is automatically installed in kiosk mode: it's set as the preferred
 *  home intent and whitelisted for lock task mode. Device setup won't complete
 *  until the app is installed. After installation, users won't be able to
 *  remove the app. You can only set this installType for one app per policy.
 *  When this is present in the policy, status bar will be automatically
 *  disabled.
 *
 *  Value: "KIOSK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Kiosk;
/**
 *  The app is automatically installed and can be removed by the user.
 *
 *  Value: "PREINSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled;
/**
 *  The app is automatically installed and can't be removed by the user and will
 *  prevent setup from completion until installation is complete.
 *
 *  Value: "REQUIRED_FOR_SETUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_RequiredForSetup;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.userControlSettings

/**
 *  User control is allowed for the app. Kiosk apps can use this to allow user
 *  control.
 *
 *  Value: "USER_CONTROL_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_UserControlSettings_UserControlAllowed;
/**
 *  User control is disallowed for the app. API_LEVEL is reported if the Android
 *  version is less than 11.
 *
 *  Value: "USER_CONTROL_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_UserControlSettings_UserControlDisallowed;
/**
 *  Uses the default behaviour of the app to determine if user control is
 *  allowed or disallowed. For most apps, user control is allowed by default,
 *  but for some critical apps such as companion apps (extensionConfig set to
 *  true), kiosk apps and other critical system apps, user control is
 *  disallowed.
 *
 *  Value: "USER_CONTROL_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_UserControlSettings_UserControlSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.workProfileWidgets

/**
 *  Work profile widgets are allowed. This means the application will be able to
 *  add widgets to the home screen.
 *
 *  Value: "WORK_PROFILE_WIDGETS_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_WorkProfileWidgets_WorkProfileWidgetsAllowed;
/**
 *  Work profile widgets are disallowed. This means the application will not be
 *  able to add widgets to the home screen.
 *
 *  Value: "WORK_PROFILE_WIDGETS_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_WorkProfileWidgets_WorkProfileWidgetsDisallowed;
/**
 *  Unspecified. Defaults to work_profile_widgets_default
 *
 *  Value: "WORK_PROFILE_WIDGETS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_WorkProfileWidgets_WorkProfileWidgetsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.applicationSource

/**
 *  The app was sideloaded from an unspecified source.
 *
 *  Value: "APPLICATION_SOURCE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_ApplicationSourceUnspecified;
/**
 *  The app was installed from the Google Play Store.
 *
 *  Value: "INSTALLED_FROM_PLAY_STORE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_InstalledFromPlayStore;
/**
 *  This is a system app from the device's factory image.
 *
 *  Value: "SYSTEM_APP_FACTORY_VERSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppFactoryVersion;
/**
 *  This is an updated system app.
 *
 *  Value: "SYSTEM_APP_UPDATED_VERSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppUpdatedVersion;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.state

/**
 *  App state is unspecified
 *
 *  Value: "APPLICATION_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_ApplicationStateUnspecified;
/**
 *  App is installed on the device
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_Installed;
/**
 *  App was removed from the device
 *
 *  Value: "REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_Removed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.userFacingType

/**
 *  App is not user facing.
 *
 *  Value: "NOT_USER_FACING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_UserFacingType_NotUserFacing;
/**
 *  App is user facing.
 *
 *  Value: "USER_FACING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_UserFacingType_UserFacing;
/**
 *  App user facing type is unspecified.
 *
 *  Value: "USER_FACING_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_UserFacingType_UserFacingTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_BlockAction.blockScope

/**
 *  Block action is applied to the entire device, including apps in the personal
 *  profile.
 *
 *  Value: "BLOCK_SCOPE_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeDevice;
/**
 *  Unspecified. Defaults to BLOCK_SCOPE_WORK_PROFILE.
 *
 *  Value: "BLOCK_SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeUnspecified;
/**
 *  Block action is only applied to apps in the work profile. Apps in the
 *  personal profile are unaffected.
 *
 *  Value: "BLOCK_SCOPE_WORK_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeWorkProfile;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.errorCode

/**
 *  The API level of the device does not support this command.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_ApiLevel;
/**
 *  There was no error.
 *
 *  Value: "COMMAND_ERROR_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_CommandErrorCodeUnspecified;
/**
 *  The command has an invalid parameter value.
 *
 *  Value: "INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) does not support the
 *  command.
 *
 *  Value: "MANAGEMENT_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_ManagementMode;
/**
 *  An unknown error occurred.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_Unknown;
/**
 *  The device doesn't support the command. Updating Android Device Policy to
 *  the latest version may resolve the issue.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_Unsupported;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.resetPasswordFlags

/**
 *  Don't ask for user credentials on device boot.
 *
 *  Value: "DO_NOT_ASK_CREDENTIALS_ON_BOOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_DoNotAskCredentialsOnBoot;
/**
 *  Lock the device after password reset.
 *
 *  Value: "LOCK_NOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_LockNow;
/**
 *  Don't allow other admins to change the password again until the user has
 *  entered it.
 *
 *  Value: "REQUIRE_ENTRY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_RequireEntry;
/**
 *  This value is ignored.
 *
 *  Value: "RESET_PASSWORD_FLAG_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_ResetPasswordFlagUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.type

/**
 *  Clears the application data of specified apps. This is supported on Android
 *  9 and above. Note that an application can store data outside of its
 *  application data, for example in external storage or in a user dictionary.
 *  See also clear_apps_data_params.
 *
 *  Value: "CLEAR_APP_DATA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_ClearAppData;
/**
 *  This value is disallowed.
 *
 *  Value: "COMMAND_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified;
/**
 *  Lock the device, as if the lock screen timeout had expired.
 *
 *  Value: "LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Lock;
/**
 *  Reboot the device. Only supported on fully managed devices running Android
 *  7.0 (API level 24) or higher.
 *
 *  Value: "REBOOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Reboot;
/**
 *  Removes the work profile and all policies from a company-owned Android 8.0+
 *  device, relinquishing the device for personal use. Apps and data associated
 *  with the personal profile(s) are preserved. The device will be deleted from
 *  the server after it acknowledges the command.
 *
 *  Value: "RELINQUISH_OWNERSHIP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_RelinquishOwnership;
/**
 *  Reset the user's password.
 *
 *  Value: "RESET_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_ResetPassword;
/**
 *  Puts the device into lost mode. Only supported on fully managed devices or
 *  organization-owned devices with a managed profile. See also
 *  start_lost_mode_params.
 *
 *  Value: "START_LOST_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_StartLostMode;
/**
 *  Takes the device out of lost mode. Only supported on fully managed devices
 *  or organization-owned devices with a managed profile. See also
 *  stop_lost_mode_params.
 *
 *  Value: "STOP_LOST_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_StopLostMode;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CommonCriteriaModeInfo.commonCriteriaModeStatus

/**
 *  Common Criteria Mode is currently disabled.
 *
 *  Value: "COMMON_CRITERIA_MODE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeDisabled;
/**
 *  Common Criteria Mode is currently enabled.
 *
 *  Value: "COMMON_CRITERIA_MODE_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeEnabled;
/**
 *  Unknown status.
 *
 *  Value: "COMMON_CRITERIA_MODE_STATUS_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeStatusUnknown;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.crossProfileCopyPaste

/**
 *  Default. Prevents users from pasting into the personal profile text copied
 *  from the work profile. Text copied from the personal profile can be pasted
 *  into the work profile, and text copied from the work profile can be pasted
 *  into the work profile.
 *
 *  Value: "COPY_FROM_WORK_TO_PERSONAL_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CopyFromWorkToPersonalDisallowed;
/**
 *  Text copied in either profile can be pasted in the other profile.
 *
 *  Value: "CROSS_PROFILE_COPY_PASTE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteAllowed;
/**
 *  Unspecified. Defaults to COPY_FROM_WORK_TO_PERSONAL_DISALLOWED
 *
 *  Value: "CROSS_PROFILE_COPY_PASTE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.crossProfileDataSharing

/**
 *  Data from either profile can be shared with the other profile.
 *
 *  Value: "CROSS_PROFILE_DATA_SHARING_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingAllowed;
/**
 *  Prevents data from being shared from both the personal profile to the work
 *  profile and the work profile to the personal profile.
 *
 *  Value: "CROSS_PROFILE_DATA_SHARING_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingDisallowed;
/**
 *  Unspecified. Defaults to DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED.
 *
 *  Value: "CROSS_PROFILE_DATA_SHARING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingUnspecified;
/**
 *  Default. Prevents users from sharing data from the work profile to apps in
 *  the personal profile. Personal data can be shared with work apps.
 *
 *  Value: "DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_DataSharingFromWorkToPersonalDisallowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.showWorkContactsInPersonalProfile

/**
 *  Default. Allows apps in the personal profile to access work profile contacts
 *  including contact searches and incoming calls.When this is set, personal
 *  apps specified in exemptions_to_show_work_contacts_in_personal_profile are
 *  blocklisted and can not access work profile contacts directly.Supported on
 *  Android 7.0 and above. A nonComplianceDetail with API_LEVEL is reported if
 *  the Android version is less than 7.0.
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileAllowed;
/**
 *  Prevents personal apps from accessing work profile contacts and looking up
 *  work contacts.When this is set, personal apps specified in
 *  exemptions_to_show_work_contacts_in_personal_profile are allowlisted and can
 *  access work profile contacts directly.Supported on Android 7.0 and above. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 7.0.
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileDisallowed;
/**
 *  Prevents most personal apps from accessing work profile contacts including
 *  contact searches and incoming calls, except for the OEM default Dialer,
 *  Messages, and Contacts apps. Neither user-configured Dialer, Messages, and
 *  Contacts apps, nor any other system or play installed apps, will be able to
 *  query work contacts directly.When this is set, personal apps specified in
 *  exemptions_to_show_work_contacts_in_personal_profile are allowlisted and can
 *  access work profile contacts.Supported on Android 14 and above. If this is
 *  set on a device with Android version less than 14, the behaviour falls back
 *  to SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED and a
 *  nonComplianceDetail with API_LEVEL is reported.
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED_EXCEPT_SYSTEM"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileDisallowedExceptSystem;
/**
 *  Unspecified. Defaults to SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED.When
 *  this is set, exemptions_to_show_work_contacts_in_personal_profile must not
 *  be set.
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.workProfileWidgetsDefault

/**
 *  Work profile widgets are allowed by default. This means that if the policy
 *  does not specify work_profile_widgets as WORK_PROFILE_WIDGETS_DISALLOWED for
 *  the application, it will be able to add widgets to the home screen.
 *
 *  Value: "WORK_PROFILE_WIDGETS_DEFAULT_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_WorkProfileWidgetsDefault_WorkProfileWidgetsDefaultAllowed;
/**
 *  Work profile widgets are disallowed by default. This means that if the
 *  policy does not specify work_profile_widgets as WORK_PROFILE_WIDGETS_ALLOWED
 *  for the application, it will be unable to add widgets to the home screen.
 *
 *  Value: "WORK_PROFILE_WIDGETS_DEFAULT_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_WorkProfileWidgetsDefault_WorkProfileWidgetsDefaultDisallowed;
/**
 *  Unspecified. Defaults to WORK_PROFILE_WIDGETS_DEFAULT_DISALLOWED.
 *
 *  Value: "WORK_PROFILE_WIDGETS_DEFAULT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_WorkProfileWidgetsDefault_WorkProfileWidgetsDefaultUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.appliedState

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Active;
/**
 *  This is a financed device that has been "locked" by the financing agent.
 *  This means certain policy settings have been applied which limit device
 *  functionality until the device has been "unlocked" by the financing agent.
 *  The device will continue to apply policy settings excluding those overridden
 *  by the financing agent. When the device is "locked", the state is reported
 *  in appliedState as DEACTIVATED_BY_DEVICE_FINANCE.
 *
 *  Value: "DEACTIVATED_BY_DEVICE_FINANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_DeactivatedByDeviceFinance;
/**
 *  The device was deleted. This state is never returned by an API call, but is
 *  used in the final status report when the device acknowledges the deletion.
 *  If the device is deleted via the API call, this state is published to
 *  Pub/Sub. If the user deletes the work profile or resets the device, the
 *  device state will remain unknown to the server.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Disabled;
/**
 *  The device is lost. This state is only possible on organization-owned
 *  devices.
 *
 *  Value: "LOST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Lost;
/**
 *  The device is preparing for migrating to Android Management API. No further
 *  action is needed for the migration to continue.
 *
 *  Value: "PREPARING_FOR_MIGRATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_PreparingForMigration;
/**
 *  The device is being provisioned. Newly enrolled devices are in this state
 *  until they have a policy applied.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.managementMode

/**
 *  Device owner. Android Device Policy has full control over the device.
 *
 *  Value: "DEVICE_OWNER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_DeviceOwner;
/**
 *  This value is disallowed.
 *
 *  Value: "MANAGEMENT_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_ManagementModeUnspecified;
/**
 *  Profile owner. Android Device Policy has control over a managed profile on
 *  the device.
 *
 *  Value: "PROFILE_OWNER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_ProfileOwner;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.ownership

/**
 *  Device is company-owned.
 *
 *  Value: "COMPANY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_Ownership_CompanyOwned;
/**
 *  Ownership is unspecified.
 *
 *  Value: "OWNERSHIP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_Ownership_OwnershipUnspecified;
/**
 *  Device is personally-owned.
 *
 *  Value: "PERSONALLY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_Ownership_PersonallyOwned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.state

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Active;
/**
 *  This is a financed device that has been "locked" by the financing agent.
 *  This means certain policy settings have been applied which limit device
 *  functionality until the device has been "unlocked" by the financing agent.
 *  The device will continue to apply policy settings excluding those overridden
 *  by the financing agent. When the device is "locked", the state is reported
 *  in appliedState as DEACTIVATED_BY_DEVICE_FINANCE.
 *
 *  Value: "DEACTIVATED_BY_DEVICE_FINANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_DeactivatedByDeviceFinance;
/**
 *  The device was deleted. This state is never returned by an API call, but is
 *  used in the final status report when the device acknowledges the deletion.
 *  If the device is deleted via the API call, this state is published to
 *  Pub/Sub. If the user deletes the work profile or resets the device, the
 *  device state will remain unknown to the server.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Disabled;
/**
 *  The device is lost. This state is only possible on organization-owned
 *  devices.
 *
 *  Value: "LOST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Lost;
/**
 *  The device is preparing for migrating to Android Management API. No further
 *  action is needed for the migration to continue.
 *
 *  Value: "PREPARING_FOR_MIGRATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_PreparingForMigration;
/**
 *  The device is being provisioned. Newly enrolled devices are in this state
 *  until they have a policy applied.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceConnectivityManagement.configureWifi

/**
 *  The user is allowed to configure Wi-Fi. wifiConfigDisabled is ignored.
 *
 *  Value: "ALLOW_CONFIGURING_WIFI"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_AllowConfiguringWifi;
/**
 *  Unspecified. Defaults to ALLOW_CONFIGURING_WIFI unless wifiConfigDisabled is
 *  set to true. If wifiConfigDisabled is set to true, this is equivalent to
 *  DISALLOW_CONFIGURING_WIFI.
 *
 *  Value: "CONFIGURE_WIFI_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_ConfigureWifiUnspecified;
/**
 *  Adding new Wi-Fi configurations is disallowed. The user is only able to
 *  switch between already configured networks. Supported on Android 13 and
 *  above, on fully managed devices and work profiles on company-owned devices.
 *  If the setting is not supported, ALLOW_CONFIGURING_WIFI is set. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 13. wifiConfigDisabled is ignored.
 *
 *  Value: "DISALLOW_ADD_WIFI_CONFIG"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_DisallowAddWifiConfig;
/**
 *  Disallows configuring Wi-Fi networks. The setting wifiConfigDisabled is
 *  ignored when this value is set. Supported on fully managed devices and work
 *  profile on company-owned devices, on all supported API levels. For fully
 *  managed devices, setting this removes all configured networks and retains
 *  only the networks configured using openNetworkConfiguration policy. For work
 *  profiles on company-owned devices, existing configured networks are not
 *  affected and the user is not allowed to add, remove, or modify Wi-Fi
 *  networks. Note: If a network connection can't be made at boot time and
 *  configuring Wi-Fi is disabled then network escape hatch will be shown in
 *  order to refresh the device policy (see networkEscapeHatchEnabled).
 *
 *  Value: "DISALLOW_CONFIGURING_WIFI"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_DisallowConfiguringWifi;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceConnectivityManagement.tetheringSettings

/**
 *  Allows configuration and use of all forms of tethering.
 *  tetheringConfigDisabled is ignored.
 *
 *  Value: "ALLOW_ALL_TETHERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_AllowAllTethering;
/**
 *  Disallows all forms of tethering. Supported on fully managed devices and
 *  work profile on company-owned devices, on all supported android versions.
 *  The setting tetheringConfigDisabled is ignored.
 *
 *  Value: "DISALLOW_ALL_TETHERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_DisallowAllTethering;
/**
 *  Disallows the user from using Wi-Fi tethering. Supported on company owned
 *  devices running Android 13 and above. If the setting is not supported,
 *  ALLOW_ALL_TETHERING will be set. A nonComplianceDetail with API_LEVEL is
 *  reported if the Android version is less than 13. tetheringConfigDisabled is
 *  ignored.
 *
 *  Value: "DISALLOW_WIFI_TETHERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_DisallowWifiTethering;
/**
 *  Unspecified. Defaults to ALLOW_ALL_TETHERING unless tetheringConfigDisabled
 *  is set to true. If tetheringConfigDisabled is set to true, this is
 *  equivalent to DISALLOW_ALL_TETHERING.
 *
 *  Value: "TETHERING_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_TetheringSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceConnectivityManagement.usbDataAccess

/**
 *  All types of USB data transfers are allowed. usbFileTransferDisabled is
 *  ignored.
 *
 *  Value: "ALLOW_USB_DATA_TRANSFER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_AllowUsbDataTransfer;
/**
 *  When set, all types of USB data transfers are prohibited. Supported for
 *  devices running Android 12 or above with USB HAL 1.3 or above. If the
 *  setting is not supported, DISALLOW_USB_FILE_TRANSFER will be set. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 12. A nonComplianceDetail with DEVICE_INCOMPATIBLE is reported if
 *  the device does not have USB HAL 1.3 or above. usbFileTransferDisabled is
 *  ignored.
 *
 *  Value: "DISALLOW_USB_DATA_TRANSFER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_DisallowUsbDataTransfer;
/**
 *  Transferring files over USB is disallowed. Other types of USB data
 *  connections, such as mouse and keyboard connection, are allowed.
 *  usbFileTransferDisabled is ignored.
 *
 *  Value: "DISALLOW_USB_FILE_TRANSFER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_DisallowUsbFileTransfer;
/**
 *  Unspecified. Defaults to DISALLOW_USB_FILE_TRANSFER.
 *
 *  Value: "USB_DATA_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_UsbDataAccessUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceConnectivityManagement.wifiDirectSettings

/**
 *  The user is allowed to use Wi-Fi direct.
 *
 *  Value: "ALLOW_WIFI_DIRECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_WifiDirectSettings_AllowWifiDirect;
/**
 *  The user is not allowed to use Wi-Fi direct. A nonComplianceDetail with
 *  API_LEVEL is reported if the Android version is less than 13.
 *
 *  Value: "DISALLOW_WIFI_DIRECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_WifiDirectSettings_DisallowWifiDirect;
/**
 *  Unspecified. Defaults to ALLOW_WIFI_DIRECT
 *
 *  Value: "WIFI_DIRECT_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceConnectivityManagement_WifiDirectSettings_WifiDirectSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceRadioState.airplaneModeState

/**
 *  Airplane mode is disabled. The user is not allowed to toggle airplane mode
 *  on. A nonComplianceDetail with API_LEVEL is reported if the Android version
 *  is less than 9.
 *
 *  Value: "AIRPLANE_MODE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_AirplaneModeState_AirplaneModeDisabled;
/**
 *  Unspecified. Defaults to AIRPLANE_MODE_USER_CHOICE.
 *
 *  Value: "AIRPLANE_MODE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_AirplaneModeState_AirplaneModeStateUnspecified;
/**
 *  The user is allowed to toggle airplane mode on or off.
 *
 *  Value: "AIRPLANE_MODE_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_AirplaneModeState_AirplaneModeUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceRadioState.cellularTwoGState

/**
 *  Cellular 2G is disabled. The user is not allowed to toggle cellular 2G on
 *  via settings. A nonComplianceDetail with API_LEVEL is reported if the
 *  Android version is less than 14.
 *
 *  Value: "CELLULAR_TWO_G_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_CellularTwoGState_CellularTwoGDisabled;
/**
 *  Unspecified. Defaults to CELLULAR_TWO_G_USER_CHOICE.
 *
 *  Value: "CELLULAR_TWO_G_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_CellularTwoGState_CellularTwoGStateUnspecified;
/**
 *  The user is allowed to toggle cellular 2G on or off.
 *
 *  Value: "CELLULAR_TWO_G_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_CellularTwoGState_CellularTwoGUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceRadioState.minimumWifiSecurityLevel

/**
 *  A 192-bit enterprise network is the minimum required security level. The
 *  device will not be able to connect to Wi-Fi network below this security
 *  level. This is stricter than ENTERPRISE_NETWORK_SECURITY. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 13.
 *
 *  Value: "ENTERPRISE_BIT192_NETWORK_SECURITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_EnterpriseBit192NetworkSecurity;
/**
 *  An enterprise EAP network is the minimum required security level. The device
 *  will not be able to connect to Wi-Fi network below this security level. This
 *  is stricter than PERSONAL_NETWORK_SECURITY. A nonComplianceDetail with
 *  API_LEVEL is reported if the Android version is less than 13.
 *
 *  Value: "ENTERPRISE_NETWORK_SECURITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_EnterpriseNetworkSecurity;
/**
 *  Defaults to OPEN_NETWORK_SECURITY, which means the device will be able to
 *  connect to all types of Wi-Fi networks.
 *
 *  Value: "MINIMUM_WIFI_SECURITY_LEVEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_MinimumWifiSecurityLevelUnspecified;
/**
 *  The device will be able to connect to all types of Wi-Fi networks.
 *
 *  Value: "OPEN_NETWORK_SECURITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_OpenNetworkSecurity;
/**
 *  A personal network such as WEP, WPA2-PSK is the minimum required security.
 *  The device will not be able to connect to open wifi networks. This is
 *  stricter than OPEN_NETWORK_SECURITY. A nonComplianceDetail with API_LEVEL is
 *  reported if the Android version is less than 13.
 *
 *  Value: "PERSONAL_NETWORK_SECURITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_PersonalNetworkSecurity;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceRadioState.ultraWidebandState

/**
 *  Ultra wideband is disabled. The user is not allowed to toggle ultra wideband
 *  on via settings. A nonComplianceDetail with API_LEVEL is reported if the
 *  Android version is less than 14.
 *
 *  Value: "ULTRA_WIDEBAND_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_UltraWidebandState_UltraWidebandDisabled;
/**
 *  Unspecified. Defaults to ULTRA_WIDEBAND_USER_CHOICE.
 *
 *  Value: "ULTRA_WIDEBAND_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_UltraWidebandState_UltraWidebandStateUnspecified;
/**
 *  The user is allowed to toggle ultra wideband on or off.
 *
 *  Value: "ULTRA_WIDEBAND_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_UltraWidebandState_UltraWidebandUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceRadioState.wifiState

/**
 *  Wi-Fi is off and the user is not allowed to turn it on. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 13.
 *
 *  Value: "WIFI_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiDisabled;
/**
 *  Wi-Fi is on and the user is not allowed to turn it off. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 13.
 *
 *  Value: "WIFI_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiEnabled;
/**
 *  Unspecified. Defaults to WIFI_STATE_USER_CHOICE
 *
 *  Value: "WIFI_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiStateUnspecified;
/**
 *  User is allowed to enable/disable Wi-Fi.
 *
 *  Value: "WIFI_STATE_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiStateUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceSettings.encryptionStatus

/**
 *  Encryption is not currently active, but is currently being activated.
 *
 *  Value: "ACTIVATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Activating;
/**
 *  Encryption is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Active;
/**
 *  Encryption is active, but an encryption key is not set by the user.
 *
 *  Value: "ACTIVE_DEFAULT_KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActiveDefaultKey;
/**
 *  Encryption is active, and the encryption key is tied to the user profile.
 *
 *  Value: "ACTIVE_PER_USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActivePerUser;
/**
 *  Unspecified. No device should have this type.
 *
 *  Value: "ENCRYPTION_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_EncryptionStatusUnspecified;
/**
 *  Encryption is supported by the device, but is not currently active.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Inactive;
/**
 *  Encryption is not supported by the device.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Unsupported;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Display.state

/**
 *  This value is disallowed.
 *
 *  Value: "DISPLAY_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_DisplayStateUnspecified;
/**
 *  Display is dozing in a low power state
 *
 *  Value: "DOZE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Doze;
/**
 *  Display is off.
 *
 *  Value: "OFF"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Off;
/**
 *  Display is on.
 *
 *  Value: "ON"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_On;
/**
 *  Display is dozing in a suspended low power state.
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Suspended;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_EnrollmentToken.allowPersonalUsage

/**
 *  Personal usage restriction is not specified
 *
 *  Value: "ALLOW_PERSONAL_USAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_AllowPersonalUsageUnspecified;
/**
 *  Personal usage is allowed
 *
 *  Value: "PERSONAL_USAGE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageAllowed;
/**
 *  Personal usage is disallowed
 *
 *  Value: "PERSONAL_USAGE_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageDisallowed;
/**
 *  Device is not associated with a single user, and thus both personal usage
 *  and corporate identity authentication are not expected.
 *
 *  Value: "PERSONAL_USAGE_DISALLOWED_USERLESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageDisallowedUserless;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Enterprise.enabledNotificationTypes

/**
 *  A notification sent when a device command has completed.
 *
 *  Value: "COMMAND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Command;
/**
 *  Deprecated.
 *
 *  Value: "COMPLIANCE_REPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_ComplianceReport GTLR_DEPRECATED;
/**
 *  A notification sent when a device enrolls.
 *
 *  Value: "ENROLLMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Enrollment;
/**
 *  This value is ignored.
 *
 *  Value: "NOTIFICATION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_NotificationTypeUnspecified;
/**
 *  A notification sent when a device issues a status report.
 *
 *  Value: "STATUS_REPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_StatusReport;
/**
 *  A notification sent when device sends BatchUsageLogEvents.
 *
 *  Value: "USAGE_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_UsageLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_GoogleAuthenticationSettings.googleAuthenticationRequired

/**
 *  This value is not used.
 *
 *  Value: "GOOGLE_AUTHENTICATION_REQUIRED_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_GoogleAuthenticationSettings_GoogleAuthenticationRequired_GoogleAuthenticationRequiredUnspecified;
/**
 *  Google authentication is not required.
 *
 *  Value: "NOT_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_GoogleAuthenticationSettings_GoogleAuthenticationRequired_NotRequired;
/**
 *  User is required to be successfully authenticated by Google.
 *
 *  Value: "REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_GoogleAuthenticationSettings_GoogleAuthenticationRequired_Required;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_InstallConstraint.chargingConstraint

/**
 *  Unspecified. Default to CHARGING_NOT_REQUIRED.
 *
 *  Value: "CHARGING_CONSTRAINT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_ChargingConstraint_ChargingConstraintUnspecified;
/**
 *  Device doesn't have to be charging.
 *
 *  Value: "CHARGING_NOT_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_ChargingConstraint_ChargingNotRequired;
/**
 *  Device has to be charging.
 *
 *  Value: "INSTALL_ONLY_WHEN_CHARGING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_ChargingConstraint_InstallOnlyWhenCharging;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_InstallConstraint.deviceIdleConstraint

/**
 *  Unspecified. Default to DEVICE_IDLE_NOT_REQUIRED.
 *
 *  Value: "DEVICE_IDLE_CONSTRAINT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_DeviceIdleConstraint_DeviceIdleConstraintUnspecified;
/**
 *  Device doesn't have to be idle, app can be installed while the user is
 *  interacting with the device.
 *
 *  Value: "DEVICE_IDLE_NOT_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_DeviceIdleConstraint_DeviceIdleNotRequired;
/**
 *  Device has to be idle.
 *
 *  Value: "INSTALL_ONLY_WHEN_DEVICE_IDLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_DeviceIdleConstraint_InstallOnlyWhenDeviceIdle;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_InstallConstraint.networkTypeConstraint

/**
 *  Any active networks (Wi-Fi, cellular, etc.).
 *
 *  Value: "INSTALL_ON_ANY_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_NetworkTypeConstraint_InstallOnAnyNetwork;
/**
 *  Any unmetered network (e.g. Wi-FI).
 *
 *  Value: "INSTALL_ONLY_ON_UNMETERED_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_NetworkTypeConstraint_InstallOnlyOnUnmeteredNetwork;
/**
 *  Unspecified. Default to INSTALL_ON_ANY_NETWORK.
 *
 *  Value: "NETWORK_TYPE_CONSTRAINT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_InstallConstraint_NetworkTypeConstraint_NetworkTypeConstraintUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KeyedAppState.severity

/**
 *  Error severity level. This should only be set for genuine error conditions
 *  that a management organization needs to take action to fix.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KeyedAppState_Severity_Error;
/**
 *  Information severity level.
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KeyedAppState_Severity_Info;
/**
 *  Unspecified severity level.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KeyedAppState_Severity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.deviceSettings

/**
 *  Unspecified, defaults to SETTINGS_ACCESS_ALLOWED.
 *
 *  Value: "DEVICE_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_DeviceSettings_DeviceSettingsUnspecified;
/**
 *  Access to the Settings app is allowed in kiosk mode.
 *
 *  Value: "SETTINGS_ACCESS_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessAllowed;
/**
 *  Access to the Settings app is not allowed in kiosk mode.
 *
 *  Value: "SETTINGS_ACCESS_BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessBlocked;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.powerButtonActions

/**
 *  Unspecified, defaults to POWER_BUTTON_AVAILABLE.
 *
 *  Value: "POWER_BUTTON_ACTIONS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonActionsUnspecified;
/**
 *  The power menu (e.g. Power off, Restart) is shown when a user long-presses
 *  the Power button of a device in kiosk mode.
 *
 *  Value: "POWER_BUTTON_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonAvailable;
/**
 *  The power menu (e.g. Power off, Restart) is not shown when a user
 *  long-presses the Power button of a device in kiosk mode. Note: this may
 *  prevent users from turning off the device.
 *
 *  Value: "POWER_BUTTON_BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonBlocked;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.statusBar

/**
 *  System info and notifications are disabled in kiosk mode.
 *
 *  Value: "NOTIFICATIONS_AND_SYSTEM_INFO_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoDisabled;
/**
 *  System info and notifications are shown on the status bar in kiosk
 *  mode.Note: For this policy to take effect, the device's home button must be
 *  enabled using kioskCustomization.systemNavigation.
 *
 *  Value: "NOTIFICATIONS_AND_SYSTEM_INFO_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoEnabled;
/**
 *  Unspecified, defaults to INFO_AND_NOTIFICATIONS_DISABLED.
 *
 *  Value: "STATUS_BAR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_StatusBarUnspecified;
/**
 *  Only system info is shown on the status bar.
 *
 *  Value: "SYSTEM_INFO_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_SystemInfoOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.systemErrorWarnings

/**
 *  All system error dialogs such as crash and app not responding (ANR) are
 *  displayed.
 *
 *  Value: "ERROR_AND_WARNINGS_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsEnabled;
/**
 *  All system error dialogs, such as crash and app not responding (ANR) are
 *  blocked. When blocked, the system force-stops the app as if the user closes
 *  the app from the UI.
 *
 *  Value: "ERROR_AND_WARNINGS_MUTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsMuted;
/**
 *  Unspecified, defaults to ERROR_AND_WARNINGS_MUTED.
 *
 *  Value: "SYSTEM_ERROR_WARNINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_SystemErrorWarningsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.systemNavigation

/**
 *  Only the home button is enabled.
 *
 *  Value: "HOME_BUTTON_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_HomeButtonOnly;
/**
 *  The home and Overview buttons are not accessible.
 *
 *  Value: "NAVIGATION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationDisabled;
/**
 *  Home and overview buttons are enabled.
 *
 *  Value: "NAVIGATION_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationEnabled;
/**
 *  Unspecified, defaults to NAVIGATION_DISABLED.
 *
 *  Value: "SYSTEM_NAVIGATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_SystemNavigationUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ManagedProperty.type

/**
 *  A property of boolean type.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Bool;
/**
 *  A bundle of properties
 *
 *  Value: "BUNDLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Bundle;
/**
 *  An array of property bundles.
 *
 *  Value: "BUNDLE_ARRAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_BundleArray;
/**
 *  A choice of one item from a set.
 *
 *  Value: "CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Choice;
/**
 *  A hidden restriction of string type (the default value can be used to pass
 *  along information that can't be modified, such as a version code).
 *
 *  Value: "HIDDEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Hidden;
/**
 *  A property of integer type.
 *
 *  Value: "INTEGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Integer;
/**
 *  Not used.
 *
 *  Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified;
/**
 *  A choice of multiple items from a set.
 *
 *  Value: "MULTISELECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Multiselect;
/**
 *  A property of string type.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_String;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_MemoryEvent.eventType

/**
 *  A new external storage medium was detected. The reported byte count is the
 *  total capacity of the storage medium.
 *
 *  Value: "EXTERNAL_STORAGE_DETECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected;
/**
 *  Free space in an external storage medium was measured.
 *
 *  Value: "EXTERNAL_STORAGE_MEASURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured;
/**
 *  An external storage medium was removed. The reported byte count is zero.
 *
 *  Value: "EXTERNAL_STORAGE_REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved;
/**
 *  Free space in internal storage was measured.
 *
 *  Value: "INTERNAL_STORAGE_MEASURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "MEMORY_EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified;
/**
 *  Free space in RAM was measured.
 *
 *  Value: "RAM_MEASURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_MigrationToken.managementMode

/**
 *  A fully-managed device. Supported only on devices running Android 9 and
 *  above.
 *
 *  Value: "FULLY_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MigrationToken_ManagementMode_FullyManaged;
/**
 *  This value must not be used.
 *
 *  Value: "MANAGEMENT_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MigrationToken_ManagementMode_ManagementModeUnspecified;
/**
 *  A work profile on a company-owned device. Supported only on devices running
 *  Android 11 and above.
 *
 *  Value: "WORK_PROFILE_COMPANY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MigrationToken_ManagementMode_WorkProfileCompanyOwned;
/**
 *  A work profile on a personally owned device. Supported only on devices
 *  running Android 9 and above.
 *
 *  Value: "WORK_PROFILE_PERSONALLY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MigrationToken_ManagementMode_WorkProfilePersonallyOwned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.installationFailureReason

/**
 *  The installation is still in progress.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress;
/**
 *  An unknown condition is preventing the app from being installed. Some
 *  potential reasons are that the device doesn't have enough storage, the
 *  device network connection is unreliable, or the installation is taking
 *  longer than expected. The installation will be retried automatically.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown;
/**
 *  This value is disallowed.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified;
/**
 *  The user's device does not have sufficient storage space to install the app.
 *  This can be resolved by clearing up storage space on the device. App install
 *  or update will automatically resume once the device has sufficient storage.
 *
 *  Value: "INSUFFICIENT_STORAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InsufficientStorage;
/**
 *  A network error on the user's device has prevented the install from
 *  succeeding. This usually happens when the device's internet connectivity is
 *  degraded, unavailable or there's a network configuration issue. Please
 *  ensure the device has access to full internet connectivity on a network that
 *  meets Android Enterprise Network Requirements
 *  (https://support.google.com/work/android/answer/10513641). App install or
 *  update will automatically resume once this is the case.
 *
 *  Value: "NETWORK_ERROR_UNRELIABLE_CONNECTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NetworkErrorUnreliableConnection;
/**
 *  There are no licenses available to assign to the user.
 *
 *  Value: "NO_LICENSES_REMAINING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining;
/**
 *  The app has not been approved by the admin.
 *
 *  Value: "NOT_APPROVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved;
/**
 *  The app is not available in the user's country.
 *
 *  Value: "NOT_AVAILABLE_IN_COUNTRY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry;
/**
 *  The app is incompatible with the device.
 *
 *  Value: "NOT_COMPATIBLE_WITH_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice;
/**
 *  The enterprise is no longer enrolled with Managed Google Play or the admin
 *  has not accepted the latest Managed Google Play Terms of Service.
 *
 *  Value: "NOT_ENROLLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled;
/**
 *  The app was not found in Play.
 *
 *  Value: "NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound;
/**
 *  The app has new permissions that have not been accepted by the admin.
 *
 *  Value: "PERMISSIONS_NOT_ACCEPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted;
/**
 *  The user is no longer valid. The user may have been deleted or disabled.
 *
 *  Value: "USER_INVALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.nonComplianceReason

/**
 *  The setting is not supported in the API level of the Android version running
 *  on the device.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel;
/**
 *  The setting can't be applied to the app because the app doesn't support it,
 *  for example because its target SDK version is not high enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible;
/**
 *  A blocked app is installed.
 *
 *  Value: "APP_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled;
/**
 *  The app required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled;
/**
 *  The app is installed, but it hasn't been updated to the minimum version code
 *  specified by policy.
 *
 *  Value: "APP_NOT_UPDATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated;
/**
 *  The device is incompatible with the policy requirements.
 *
 *  Value: "DEVICE_INCOMPATIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_DeviceIncompatible;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue;
/**
 *  The management mode (such as fully managed or work profile) doesn't support
 *  the setting.
 *
 *  Value: "MANAGEMENT_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ManagementMode;
/**
 *  This value is not used.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting hasn't been applied at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.specificNonComplianceReason

/**
 *  The ONC Wi-Fi setting is not supported in the API level of the Android
 *  version running on the device. fieldPath specifies which field value is not
 *  supported. oncWifiContext is set. nonComplianceReason is set to API_LEVEL.
 *
 *  Value: "ONC_WIFI_API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiApiLevel;
/**
 *  The enterprise Wi-Fi network is missing either the root CA or domain name.
 *  nonComplianceReason is set to INVALID_VALUE.
 *
 *  Value: "ONC_WIFI_INVALID_ENTERPRISE_CONFIG"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiInvalidEnterpriseConfig;
/**
 *  There is an incorrect value in ONC Wi-Fi configuration. fieldPath specifies
 *  which field value is incorrect. oncWifiContext is set. nonComplianceReason
 *  is set to INVALID_VALUE.
 *
 *  Value: "ONC_WIFI_INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiInvalidValue;
/**
 *  Key pair alias specified via ClientCertKeyPairAlias
 *  (https://chromium.googlesource.com/chromium/src/+/main/components/onc/docs/onc_spec.md#eap-type)
 *  field in openNetworkConfiguration does not correspond to an existing key
 *  installed on the device. nonComplianceReason is set to INVALID_VALUE.
 *
 *  Value: "ONC_WIFI_KEY_PAIR_ALIAS_NOT_CORRESPONDING_TO_EXISTING_KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiKeyPairAliasNotCorrespondingToExistingKey;
/**
 *  User needs to remove the configured Wi-Fi network manually. This is
 *  applicable only on work profiles on personally-owned devices.
 *  nonComplianceReason is set to USER_ACTION.
 *
 *  Value: "ONC_WIFI_USER_SHOULD_REMOVE_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiUserShouldRemoveNetwork;
/**
 *  The device or profile password has expired. passwordPoliciesContext is set.
 *  nonComplianceReason is set to USER_ACTION.
 *
 *  Value: "PASSWORD_POLICIES_PASSWORD_EXPIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordExpired;
/**
 *  The device password does not satisfy password requirements.
 *  passwordPoliciesContext is set. nonComplianceReason is set to USER_ACTION.
 *
 *  Value: "PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordNotSufficient;
/**
 *  User needs to confirm credentials by entering the screen lock. Fields in
 *  specific_non_compliance_context are not set. nonComplianceReason is set to
 *  USER_ACTION.
 *
 *  Value: "PASSWORD_POLICIES_USER_CREDENTIALS_CONFIRMATION_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesUserCredentialsConfirmationRequired;
/**
 *  Specific non-compliance reason is not specified. Fields in
 *  specific_non_compliance_context are not set.
 *
 *  Value: "SPECIFIC_NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_SpecificNonComplianceReasonUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetailCondition.nonComplianceReason

/**
 *  The setting is not supported in the API level of the Android version running
 *  on the device.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel;
/**
 *  The setting can't be applied to the app because the app doesn't support it,
 *  for example because its target SDK version is not high enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible;
/**
 *  A blocked app is installed.
 *
 *  Value: "APP_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled;
/**
 *  The app required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled;
/**
 *  The app is installed, but it hasn't been updated to the minimum version code
 *  specified by policy.
 *
 *  Value: "APP_NOT_UPDATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated;
/**
 *  The device is incompatible with the policy requirements.
 *
 *  Value: "DEVICE_INCOMPATIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_DeviceIncompatible;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue;
/**
 *  The management mode (such as fully managed or work profile) doesn't support
 *  the setting.
 *
 *  Value: "MANAGEMENT_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ManagementMode;
/**
 *  This value is not used.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting hasn't been applied at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_OsStartupEvent.verifiedBootState

/**
 *  Indicates that there is a full chain of trust extending from the bootloader
 *  to verified partitions including the bootloader, boot partition, and all
 *  verified partitions.
 *
 *  Value: "GREEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Green;
/**
 *  Indicates that the device may be freely modified. Device integrity is left
 *  to the user to verify out-of-band.
 *
 *  Value: "ORANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Orange;
/**
 *  Unknown value.
 *
 *  Value: "VERIFIED_BOOT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_VerifiedBootStateUnspecified;
/**
 *  Indicates that the boot partition has been verified using the embedded
 *  certificate and the signature is valid.
 *
 *  Value: "YELLOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Yellow;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_OsStartupEvent.verityMode

/**
 *  Indicates that dm-verity is disabled on device.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_Disabled;
/**
 *  Unknown value.
 *
 *  Value: "DM_VERITY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_DmVerityModeUnspecified;
/**
 *  Indicates that the device will be restarted when corruption is detected.
 *
 *  Value: "ENFORCING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_Enforcing;
/**
 *  Indicates that an I/O error will be returned for an attempt to read
 *  corrupted data blocks (also known as eio boot state).
 *
 *  Value: "IO_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_IoError;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordPoliciesContext.passwordPolicyScope

/**
 *  The password requirements are only applied to the device.
 *
 *  Value: "SCOPE_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeDevice;
/**
 *  The password requirements are only applied to the work profile.
 *
 *  Value: "SCOPE_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeProfile;
/**
 *  The scope is unspecified. The password requirements are applied to the work
 *  profile for work profile devices and the whole device for fully managed or
 *  dedicated devices.
 *
 *  Value: "SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordQuality

/**
 *  The password must contain alphabetic (or symbol) characters.This, when
 *  applied on personally owned work profile devices on Android 12
 *  device-scoped, will be treated as COMPLEXITY_HIGH for application. See
 *  PasswordQuality for details.
 *
 *  Value: "ALPHABETIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic;
/**
 *  The password must contain both numeric and alphabetic (or symbol)
 *  characters.This, when applied on personally owned work profile devices on
 *  Android 12 device-scoped, will be treated as COMPLEXITY_HIGH for
 *  application. See PasswordQuality for details.
 *
 *  Value: "ALPHANUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric;
/**
 *  The device must be secured with a low-security biometric recognition
 *  technology, at minimum. This includes technologies that can recognize the
 *  identity of an individual that are roughly equivalent to a 3-digit PIN
 *  (false detection is less than 1 in 1,000).This, when applied on personally
 *  owned work profile devices on Android 12 device-scoped, will be treated as
 *  COMPLEXITY_LOW for application. See PasswordQuality for details.
 *
 *  Value: "BIOMETRIC_WEAK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak;
/**
 *  The password must meet the minimum requirements specified in
 *  passwordMinimumLength, passwordMinimumLetters, passwordMinimumSymbols, etc.
 *  For example, if passwordMinimumSymbols is 2, the password must contain at
 *  least two symbols.This, when applied on personally owned work profile
 *  devices on Android 12 device-scoped, will be treated as COMPLEXITY_HIGH for
 *  application. In this case, the requirements in passwordMinimumLength,
 *  passwordMinimumLetters, passwordMinimumSymbols, etc are not applied. See
 *  PasswordQuality for details.
 *
 *  Value: "COMPLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex;
/**
 *  Define the high password complexity band as:On Android 12 and above: PIN
 *  with no repeating (4444) or ordered (1234, 4321, 2468) sequences, length at
 *  least 8 alphabetic, length at least 6 alphanumeric, length at least 6This
 *  sets the minimum complexity band which the password must meet.Enforcement
 *  varies among different Android versions, management modes and password
 *  scopes. See PasswordQuality for details.
 *
 *  Value: "COMPLEXITY_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityHigh;
/**
 *  Define the low password complexity band as: pattern PIN with repeating
 *  (4444) or ordered (1234, 4321, 2468) sequencesThis sets the minimum
 *  complexity band which the password must meet.Enforcement varies among
 *  different Android versions, management modes and password scopes. See
 *  PasswordQuality for details.
 *
 *  Value: "COMPLEXITY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityLow;
/**
 *  Define the medium password complexity band as: PIN with no repeating (4444)
 *  or ordered (1234, 4321, 2468) sequences, length at least 4 alphabetic,
 *  length at least 4 alphanumeric, length at least 4This sets the minimum
 *  complexity band which the password must meet.Enforcement varies among
 *  different Android versions, management modes and password scopes. See
 *  PasswordQuality for details.
 *
 *  Value: "COMPLEXITY_MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityMedium;
/**
 *  The password must contain numeric characters.This, when applied on
 *  personally owned work profile devices on Android 12 device-scoped, will be
 *  treated as COMPLEXITY_MEDIUM for application. See PasswordQuality for
 *  details.
 *
 *  Value: "NUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric;
/**
 *  The password must contain numeric characters with no repeating (4444) or
 *  ordered (1234, 4321, 2468) sequences.This, when applied on personally owned
 *  work profile devices on Android 12 device-scoped, will be treated as
 *  COMPLEXITY_MEDIUM for application. See PasswordQuality for details.
 *
 *  Value: "NUMERIC_COMPLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex;
/**
 *  There are no password requirements.
 *
 *  Value: "PASSWORD_QUALITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified;
/**
 *  A password is required, but there are no restrictions on what the password
 *  must contain.This, when applied on personally owned work profile devices on
 *  Android 12 device-scoped, will be treated as COMPLEXITY_LOW for application.
 *  See PasswordQuality for details.
 *
 *  Value: "SOMETHING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordScope

/**
 *  The password requirements are only applied to the device.
 *
 *  Value: "SCOPE_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeDevice;
/**
 *  The password requirements are only applied to the work profile.
 *
 *  Value: "SCOPE_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeProfile;
/**
 *  The scope is unspecified. The password requirements are applied to the work
 *  profile for work profile devices and the whole device for fully managed or
 *  dedicated devices.
 *
 *  Value: "SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.requirePasswordUnlock

/**
 *  The timeout period is set to 24 hours.
 *
 *  Value: "REQUIRE_EVERY_DAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequireEveryDay;
/**
 *  Unspecified. Defaults to USE_DEFAULT_DEVICE_TIMEOUT.
 *
 *  Value: "REQUIRE_PASSWORD_UNLOCK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequirePasswordUnlockUnspecified;
/**
 *  The timeout period is set to the devices default.
 *
 *  Value: "USE_DEFAULT_DEVICE_TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_UseDefaultDeviceTimeout;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.unifiedLockSettings

/**
 *  A common lock for the device and the work profile is allowed.
 *
 *  Value: "ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_AllowUnifiedWorkAndPersonalLock;
/**
 *  A separate lock for the work profile is required.
 *
 *  Value: "REQUIRE_SEPARATE_WORK_LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_RequireSeparateWorkLock;
/**
 *  Unspecified. Defaults to ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK.
 *
 *  Value: "UNIFIED_LOCK_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_UnifiedLockSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PerAppResult.clearingResult

/**
 *  This apps data could not be cleared because the device API level does not
 *  support this command.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_ApiLevel;
/**
 *  This apps data could not be cleared because the app was not found.
 *
 *  Value: "APP_NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_AppNotFound;
/**
 *  This apps data could not be cleared because the app is protected. For
 *  example, this may apply to apps critical to the functioning of the device,
 *  such as Google Play Store.
 *
 *  Value: "APP_PROTECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_AppProtected;
/**
 *  Unspecified result.
 *
 *  Value: "CLEARING_RESULT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_ClearingResultUnspecified;
/**
 *  This apps data was successfully cleared.
 *
 *  Value: "SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_Success;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PermissionGrant.policy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Deny;
/**
 *  Automatically grant a permission.On Android 12 and above,
 *  Manifest.permission.READ_SMS
 *  (https://developer.android.com/reference/android/Manifest.permission#READ_SMS)
 *  and following sensor-related permissions can only be granted on fully
 *  managed devices: Manifest.permission.ACCESS_FINE_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_FINE_LOCATION)
 *  Manifest.permission.ACCESS_BACKGROUND_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_BACKGROUND_LOCATION)
 *  Manifest.permission.ACCESS_COARSE_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_COARSE_LOCATION)
 *  Manifest.permission.CAMERA
 *  (https://developer.android.com/reference/android/Manifest.permission#CAMERA)
 *  Manifest.permission.RECORD_AUDIO
 *  (https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO)
 *  Manifest.permission.ACTIVITY_RECOGNITION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACTIVITY_RECOGNITION)
 *  Manifest.permission.BODY_SENSORS
 *  (https://developer.android.com/reference/android/Manifest.permission#BODY_SENSORS)
 *
 *  Value: "GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PersonalApplicationPolicy.installType

/**
 *  The app is available to install in the personal profile.
 *
 *  Value: "AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Available;
/**
 *  The app is blocked and can't be installed in the personal profile. If the
 *  app was previously installed in the device, it will be uninstalled.
 *
 *  Value: "BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Blocked;
/**
 *  Unspecified. Defaults to AVAILABLE.
 *
 *  Value: "INSTALL_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_InstallTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PersonalUsagePolicies.personalPlayStoreMode

/**
 *  Only apps explicitly specified in personalApplications with installType set
 *  to AVAILABLE are allowed to be installed in the personal profile.
 *
 *  Value: "ALLOWLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Allowlist;
/**
 *  All Play Store apps are available for installation in the personal profile,
 *  except those whose installType is BLOCKED in personalApplications.
 *
 *  Value: "BLACKLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blacklist GTLR_DEPRECATED;
/**
 *  All Play Store apps are available for installation in the personal profile,
 *  except those whose installType is BLOCKED in personalApplications.
 *
 *  Value: "BLOCKLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blocklist;
/**
 *  Unspecified. Defaults to BLOCKLIST.
 *
 *  Value: "PLAY_STORE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_PlayStoreModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.androidDevicePolicyTracks

/**
 *  This value is ignored.
 *
 *  Value: "APP_TRACK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_AppTrackUnspecified;
/**
 *  The beta track, which provides the latest beta release.
 *
 *  Value: "BETA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_Beta;
/**
 *  The production track, which provides the latest stable release.
 *
 *  Value: "PRODUCTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_Production;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.appAutoUpdatePolicy

/**
 *  Apps are auto-updated at any time. Data charges may apply.
 *
 *  Value: "ALWAYS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Always;
/**
 *  The auto-update policy is not set. Equivalent to CHOICE_TO_THE_USER.
 *
 *  Value: "APP_AUTO_UPDATE_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_AppAutoUpdatePolicyUnspecified;
/**
 *  The user can control auto-updates.
 *
 *  Value: "CHOICE_TO_THE_USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_ChoiceToTheUser;
/**
 *  Apps are never auto-updated.
 *
 *  Value: "NEVER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Never;
/**
 *  Apps are auto-updated over Wi-Fi only.
 *
 *  Value: "WIFI_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_WifiOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.assistContentPolicy

/**
 *  Assist content is allowed to be sent to a privileged app.Supported on
 *  Android 15 and above.
 *
 *  Value: "ASSIST_CONTENT_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AssistContentPolicy_AssistContentAllowed;
/**
 *  Assist content is blocked from being sent to a privileged app.Supported on
 *  Android 15 and above. A nonComplianceDetail with API_LEVEL is reported if
 *  the Android version is less than 15.
 *
 *  Value: "ASSIST_CONTENT_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AssistContentPolicy_AssistContentDisallowed;
/**
 *  Unspecified. Defaults to ASSIST_CONTENT_ALLOWED.
 *
 *  Value: "ASSIST_CONTENT_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AssistContentPolicy_AssistContentPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.autoDateAndTimeZone

/**
 *  Enforce auto date, time, and time zone on the device.
 *
 *  Value: "AUTO_DATE_AND_TIME_ZONE_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneEnforced;
/**
 *  Unspecified. Defaults to AUTO_DATE_AND_TIME_ZONE_USER_CHOICE.
 *
 *  Value: "AUTO_DATE_AND_TIME_ZONE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUnspecified;
/**
 *  Auto date, time, and time zone are left to user's choice.
 *
 *  Value: "AUTO_DATE_AND_TIME_ZONE_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.cameraAccess

/**
 *  The field camera_disabled is ignored. All cameras on the device are disabled
 *  (for fully managed devices, this applies device-wide and for work profiles
 *  this applies only to the work profile).There are no explicit restrictions
 *  placed on the camera access toggle on Android 12 and above: on fully managed
 *  devices, the camera access toggle has no effect as all cameras are disabled.
 *  On devices with a work profile, this toggle has no effect on apps in the
 *  work profile, but it affects apps outside the work profile.
 *
 *  Value: "CAMERA_ACCESS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessDisabled;
/**
 *  The field camera_disabled is ignored. All cameras on the device are
 *  available. On fully managed devices running Android 12 and above, the user
 *  is unable to use the camera access toggle. On devices which are not fully
 *  managed or which run Android 11 or below, this is equivalent to
 *  CAMERA_ACCESS_USER_CHOICE.
 *
 *  Value: "CAMERA_ACCESS_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessEnforced;
/**
 *  If camera_disabled is true, this is equivalent to CAMERA_ACCESS_DISABLED.
 *  Otherwise, this is equivalent to CAMERA_ACCESS_USER_CHOICE.
 *
 *  Value: "CAMERA_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUnspecified;
/**
 *  The field camera_disabled is ignored. This is the default device behaviour:
 *  all cameras on the device are available. On Android 12 and above, the user
 *  can use the camera access toggle.
 *
 *  Value: "CAMERA_ACCESS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.credentialProviderPolicyDefault

/**
 *  Apps with credentialProviderPolicy unspecified are not allowed to act as a
 *  credential provider.
 *
 *  Value: "CREDENTIAL_PROVIDER_DEFAULT_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CredentialProviderPolicyDefault_CredentialProviderDefaultDisallowed;
/**
 *  Apps with credentialProviderPolicy unspecified are not allowed to act as a
 *  credential provider except for the OEM default credential providers. OEM
 *  default credential providers are always allowed to act as credential
 *  providers.
 *
 *  Value: "CREDENTIAL_PROVIDER_DEFAULT_DISALLOWED_EXCEPT_SYSTEM"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CredentialProviderPolicyDefault_CredentialProviderDefaultDisallowedExceptSystem;
/**
 *  Unspecified. Defaults to CREDENTIAL_PROVIDER_DEFAULT_DISALLOWED.
 *
 *  Value: "CREDENTIAL_PROVIDER_POLICY_DEFAULT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CredentialProviderPolicyDefault_CredentialProviderPolicyDefaultUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.On Android 12 and above,
 *  Manifest.permission.READ_SMS
 *  (https://developer.android.com/reference/android/Manifest.permission#READ_SMS)
 *  and following sensor-related permissions can only be granted on fully
 *  managed devices: Manifest.permission.ACCESS_FINE_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_FINE_LOCATION)
 *  Manifest.permission.ACCESS_BACKGROUND_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_BACKGROUND_LOCATION)
 *  Manifest.permission.ACCESS_COARSE_LOCATION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACCESS_COARSE_LOCATION)
 *  Manifest.permission.CAMERA
 *  (https://developer.android.com/reference/android/Manifest.permission#CAMERA)
 *  Manifest.permission.RECORD_AUDIO
 *  (https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO)
 *  Manifest.permission.ACTIVITY_RECOGNITION
 *  (https://developer.android.com/reference/android/Manifest.permission#ACTIVITY_RECOGNITION)
 *  Manifest.permission.BODY_SENSORS
 *  (https://developer.android.com/reference/android/Manifest.permission#BODY_SENSORS)
 *
 *  Value: "GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.encryptionPolicy

/**
 *  Encryption required but no password required to boot
 *
 *  Value: "ENABLED_WITHOUT_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithoutPassword;
/**
 *  Encryption required with password required to boot
 *
 *  Value: "ENABLED_WITH_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithPassword;
/**
 *  This value is ignored, i.e. no encryption required
 *
 *  Value: "ENCRYPTION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EncryptionPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.keyguardDisabledFeatures

/**
 *  Disable all current and future keyguard customizations.
 *
 *  Value: "ALL_FEATURES"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_AllFeatures;
/**
 *  Disable all biometric authentication on secure keyguard screens.
 *
 *  Value: "BIOMETRICS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Biometrics;
/**
 *  Disable the camera on secure keyguard screens (e.g. PIN).
 *
 *  Value: "CAMERA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Camera;
/**
 *  Disable fingerprint sensor on secure keyguard screens.
 *
 *  Value: "DISABLE_FINGERPRINT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_DisableFingerprint;
/**
 *  On devices running Android 6 and below, disables text entry into
 *  notifications on secure keyguard screens. Has no effect on Android 7 and
 *  above.
 *
 *  Value: "DISABLE_REMOTE_INPUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_DisableRemoteInput;
/**
 *  Disable face authentication on secure keyguard screens.
 *
 *  Value: "FACE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Face;
/**
 *  Disable iris authentication on secure keyguard screens.
 *
 *  Value: "IRIS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Iris;
/**
 *  This value is ignored.
 *
 *  Value: "KEYGUARD_DISABLED_FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_KeyguardDisabledFeatureUnspecified;
/**
 *  Disable showing all notifications on secure keyguard screens.
 *
 *  Value: "NOTIFICATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Notifications;
/**
 *  Disable all shortcuts on secure keyguard screen on Android 14 and above.
 *
 *  Value: "SHORTCUTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Shortcuts;
/**
 *  Ignore trust agent state on secure keyguard screens.
 *
 *  Value: "TRUST_AGENTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_TrustAgents;
/**
 *  Disable unredacted notifications on secure keyguard screens.
 *
 *  Value: "UNREDACTED_NOTIFICATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_UnredactedNotifications;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.locationMode

/**
 *  On Android 8 and below, only the network location provider is enabled. On
 *  Android 9 and above, this is equivalent to LOCATION_ENFORCED.
 *
 *  Value: "BATTERY_SAVING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_BatterySaving GTLR_DEPRECATED;
/**
 *  On Android 8 and below, all location detection methods are enabled,
 *  including GPS, networks, and other sensors. On Android 9 and above, this is
 *  equivalent to LOCATION_ENFORCED.
 *
 *  Value: "HIGH_ACCURACY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_HighAccuracy GTLR_DEPRECATED;
/**
 *  Disable location setting on the device.
 *
 *  Value: "LOCATION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationDisabled;
/**
 *  Enable location setting on the device.
 *
 *  Value: "LOCATION_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationEnforced;
/**
 *  Defaults to LOCATION_USER_CHOICE.
 *
 *  Value: "LOCATION_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationModeUnspecified;
/**
 *  Location setting is not restricted on the device. No specific behavior is
 *  set or enforced.
 *
 *  Value: "LOCATION_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationUserChoice;
/**
 *  On Android 8 and below, location setting and accuracy are disabled. On
 *  Android 9 and above, this is equivalent to LOCATION_DISABLED.
 *
 *  Value: "OFF"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_Off GTLR_DEPRECATED;
/**
 *  On Android 8 and below, only GPS and other sensors are enabled. On Android 9
 *  and above, this is equivalent to LOCATION_ENFORCED.
 *
 *  Value: "SENSORS_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_SensorsOnly GTLR_DEPRECATED;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.microphoneAccess

/**
 *  The field unmute_microphone_disabled is ignored. The microphone on the
 *  device is disabled (for fully managed devices, this applies device-wide).The
 *  microphone access toggle has no effect as the microphone is disabled.
 *
 *  Value: "MICROPHONE_ACCESS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessDisabled;
/**
 *  The field unmute_microphone_disabled is ignored. The microphone on the
 *  device is available. On devices running Android 12 and above, the user is
 *  unable to use the microphone access toggle. On devices which run Android 11
 *  or below, this is equivalent to MICROPHONE_ACCESS_USER_CHOICE.
 *
 *  Value: "MICROPHONE_ACCESS_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessEnforced;
/**
 *  If unmute_microphone_disabled is true, this is equivalent to
 *  MICROPHONE_ACCESS_DISABLED. Otherwise, this is equivalent to
 *  MICROPHONE_ACCESS_USER_CHOICE.
 *
 *  Value: "MICROPHONE_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUnspecified;
/**
 *  The field unmute_microphone_disabled is ignored. This is the default device
 *  behaviour: the microphone on the device is available. On Android 12 and
 *  above, the user can use the microphone access toggle.
 *
 *  Value: "MICROPHONE_ACCESS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.playStoreMode

/**
 *  All apps are available and any app that should not be on the device should
 *  be explicitly marked as 'BLOCKED' in the applications policy.
 *
 *  Value: "BLACKLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_Blacklist;
/**
 *  Unspecified. Defaults to WHITELIST.
 *
 *  Value: "PLAY_STORE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_PlayStoreModeUnspecified;
/**
 *  Only apps that are in the policy are available and any app not in the policy
 *  will be automatically uninstalled from the device.
 *
 *  Value: "WHITELIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_Whitelist;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.preferentialNetworkService

/**
 *  Preferential network service is disabled on the work profile.
 *
 *  Value: "PREFERENTIAL_NETWORK_SERVICE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceDisabled;
/**
 *  Preferential network service is enabled on the work profile.
 *
 *  Value: "PREFERENTIAL_NETWORK_SERVICE_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceEnabled;
/**
 *  Unspecified. Defaults to PREFERENTIAL_NETWORK_SERVICES_DISABLED.
 *
 *  Value: "PREFERENTIAL_NETWORK_SERVICE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.printingPolicy

/**
 *  Printing is allowed.
 *
 *  Value: "PRINTING_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PrintingPolicy_PrintingAllowed;
/**
 *  Printing is disallowed. A nonComplianceDetail with API_LEVEL is reported if
 *  the Android version is less than 9.
 *
 *  Value: "PRINTING_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PrintingPolicy_PrintingDisallowed;
/**
 *  Unspecified. Defaults to PRINTING_ALLOWED.
 *
 *  Value: "PRINTING_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PrintingPolicy_PrintingPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.stayOnPluggedModes

/**
 *  Power source is an AC charger.
 *
 *  Value: "AC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Ac;
/**
 *  This value is ignored.
 *
 *  Value: "BATTERY_PLUGGED_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_BatteryPluggedModeUnspecified;
/**
 *  Power source is a USB port.
 *
 *  Value: "USB"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Usb;
/**
 *  Power source is wireless.
 *
 *  Value: "WIRELESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Wireless;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PostureDetail.securityRisk

/**
 *  Play Integrity API detects that the device is running a compromised OS
 *  (basicIntegrity check fails).
 *
 *  Value: "COMPROMISED_OS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_CompromisedOs;
/**
 *  Play Integrity API detects that the device does not have a strong guarantee
 *  of system integrity, if the MEETS_STRONG_INTEGRITY label doesn't show in the
 *  device integrity field
 *  (https://developer.android.com/google/play/integrity/verdicts#device-integrity-field).
 *
 *  Value: "HARDWARE_BACKED_EVALUATION_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_HardwareBackedEvaluationFailed;
/**
 *  Unspecified.
 *
 *  Value: "SECURITY_RISK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_SecurityRiskUnspecified;
/**
 *  Play Integrity API detects that the device is running an unknown OS
 *  (basicIntegrity check succeeds but ctsProfileMatch fails).
 *
 *  Value: "UNKNOWN_OS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_UnknownOs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PowerManagementEvent.eventType

/**
 *  Battery level was measured.
 *
 *  Value: "BATTERY_LEVEL_COLLECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected;
/**
 *  The device entered low-power mode.
 *
 *  Value: "BATTERY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow;
/**
 *  The device exited low-power mode.
 *
 *  Value: "BATTERY_OKAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay;
/**
 *  The device booted.
 *
 *  Value: "BOOT_COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted;
/**
 *  The device started charging.
 *
 *  Value: "POWER_CONNECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected;
/**
 *  The device stopped charging.
 *
 *  Value: "POWER_DISCONNECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified;
/**
 *  The device shut down.
 *
 *  Value: "SHUTDOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ProvisioningInfo.managementMode

/**
 *  Device owner. Android Device Policy has full control over the device.
 *
 *  Value: "DEVICE_OWNER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ProvisioningInfo_ManagementMode_DeviceOwner;
/**
 *  This value is disallowed.
 *
 *  Value: "MANAGEMENT_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ProvisioningInfo_ManagementMode_ManagementModeUnspecified;
/**
 *  Profile owner. Android Device Policy has control over a managed profile on
 *  the device.
 *
 *  Value: "PROFILE_OWNER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ProvisioningInfo_ManagementMode_ProfileOwner;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ProvisioningInfo.ownership

/**
 *  Device is company-owned.
 *
 *  Value: "COMPANY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ProvisioningInfo_Ownership_CompanyOwned;
/**
 *  Ownership is unspecified.
 *
 *  Value: "OWNERSHIP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ProvisioningInfo_Ownership_OwnershipUnspecified;
/**
 *  Device is personally-owned.
 *
 *  Value: "PERSONALLY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ProvisioningInfo_Ownership_PersonallyOwned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ScreenBrightnessSettings.screenBrightnessMode

/**
 *  The screen brightness mode is automatic in which the brightness is
 *  automatically adjusted and the user is not allowed to configure the screen
 *  brightness. screenBrightness can still be set and it is taken into account
 *  while the brightness is automatically adjusted. Supported on Android 9 and
 *  above on fully managed devices. A NonComplianceDetail with API_LEVEL is
 *  reported if the Android version is less than 9.
 *
 *  Value: "BRIGHTNESS_AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_BrightnessAutomatic;
/**
 *  The screen brightness mode is fixed in which the brightness is set to
 *  screenBrightness and the user is not allowed to configure the screen
 *  brightness. screenBrightness must be set. Supported on Android 9 and above
 *  on fully managed devices. A NonComplianceDetail with API_LEVEL is reported
 *  if the Android version is less than 9.
 *
 *  Value: "BRIGHTNESS_FIXED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_BrightnessFixed;
/**
 *  The user is allowed to configure the screen brightness. screenBrightness
 *  must not be set.
 *
 *  Value: "BRIGHTNESS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_BrightnessUserChoice;
/**
 *  Unspecified. Defaults to BRIGHTNESS_USER_CHOICE.
 *
 *  Value: "SCREEN_BRIGHTNESS_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_ScreenBrightnessModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ScreenTimeoutSettings.screenTimeoutMode

/**
 *  The screen timeout is set to screenTimeout and the user is not allowed to
 *  configure the timeout. screenTimeout must be set. Supported on Android 9 and
 *  above on fully managed devices. A NonComplianceDetail with API_LEVEL is
 *  reported if the Android version is less than 9.
 *
 *  Value: "SCREEN_TIMEOUT_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenTimeoutSettings_ScreenTimeoutMode_ScreenTimeoutEnforced;
/**
 *  Unspecified. Defaults to SCREEN_TIMEOUT_USER_CHOICE.
 *
 *  Value: "SCREEN_TIMEOUT_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenTimeoutSettings_ScreenTimeoutMode_ScreenTimeoutModeUnspecified;
/**
 *  The user is allowed to configure the screen timeout. screenTimeout must not
 *  be set.
 *
 *  Value: "SCREEN_TIMEOUT_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ScreenTimeoutSettings_ScreenTimeoutMode_ScreenTimeoutUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SecurityPosture.devicePosture

/**
 *  This device may be more vulnerable to malicious actors than is recommended
 *  for use with corporate data.
 *
 *  Value: "AT_RISK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_AtRisk;
/**
 *  Unspecified. There is no posture detail for this posture value.
 *
 *  Value: "POSTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_PostureUnspecified;
/**
 *  This device may be compromised and corporate data may be accessible to
 *  unauthorized actors.
 *
 *  Value: "POTENTIALLY_COMPROMISED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_PotentiallyCompromised;
/**
 *  This device is secure.
 *
 *  Value: "SECURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_Secure;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SigninDetail.allowPersonalUsage

/**
 *  Personal usage restriction is not specified
 *
 *  Value: "ALLOW_PERSONAL_USAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_AllowPersonalUsageUnspecified;
/**
 *  Personal usage is allowed
 *
 *  Value: "PERSONAL_USAGE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageAllowed;
/**
 *  Personal usage is disallowed
 *
 *  Value: "PERSONAL_USAGE_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageDisallowed;
/**
 *  Device is not associated with a single user, and thus both personal usage
 *  and corporate identity authentication are not expected.
 *
 *  Value: "PERSONAL_USAGE_DISALLOWED_USERLESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageDisallowedUserless;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SigninDetail.defaultStatus

/**
 *  Equivalent to SIGNIN_DETAIL_IS_NOT_DEFAULT.
 *
 *  Value: "SIGNIN_DETAIL_DEFAULT_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_DefaultStatus_SigninDetailDefaultStatusUnspecified;
/**
 *  The sign-in URL will be used by default for the enterprise.
 *
 *  Value: "SIGNIN_DETAIL_IS_DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_DefaultStatus_SigninDetailIsDefault;
/**
 *  The sign-in URL will not be used by default for the enterprise.
 *
 *  Value: "SIGNIN_DETAIL_IS_NOT_DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_DefaultStatus_SigninDetailIsNotDefault;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_StartLostModeStatus.status

/**
 *  The device is already in lost mode.
 *
 *  Value: "ALREADY_IN_LOST_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StartLostModeStatus_Status_AlreadyInLostMode;
/**
 *  The device could not be put into lost mode because the admin reset the
 *  device's password recently.
 *
 *  Value: "RESET_PASSWORD_RECENTLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StartLostModeStatus_Status_ResetPasswordRecently;
/**
 *  Unspecified. This value is not used.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StartLostModeStatus_Status_StatusUnspecified;
/**
 *  The device was put into lost mode.
 *
 *  Value: "SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StartLostModeStatus_Status_Success;
/**
 *  The device could not be put into lost mode because the user exited lost mode
 *  recently.
 *
 *  Value: "USER_EXIT_LOST_MODE_RECENTLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StartLostModeStatus_Status_UserExitLostModeRecently;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_StopLostModeStatus.status

/**
 *  The device is not in lost mode.
 *
 *  Value: "NOT_IN_LOST_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StopLostModeStatus_Status_NotInLostMode;
/**
 *  Unspecified. This value is not used.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StopLostModeStatus_Status_StatusUnspecified;
/**
 *  The device was taken out of lost mode.
 *
 *  Value: "SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StopLostModeStatus_Status_Success;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_StopLostModeUserAttemptEvent.status

/**
 *  Indicates that the user's attempt to stop lost mode failed.
 *
 *  Value: "ATTEMPT_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StopLostModeUserAttemptEvent_Status_AttemptFailed;
/**
 *  Indicates that the user successfully stopped lost mode.
 *
 *  Value: "ATTEMPT_SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StopLostModeUserAttemptEvent_Status_AttemptSucceeded;
/**
 *  This value is not used.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_StopLostModeUserAttemptEvent_Status_StatusUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SystemUpdate.type

/**
 *  Install automatically as soon as an update is available.
 *
 *  Value: "AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Automatic;
/**
 *  Postpone automatic install up to a maximum of 30 days. This policy does not
 *  affect security updates (e.g. monthly security patches).
 *
 *  Value: "POSTPONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Postpone;
/**
 *  Follow the default update behavior for the device, which typically requires
 *  the user to accept system updates.
 *
 *  Value: "SYSTEM_UPDATE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified;
/**
 *  Install automatically within a daily maintenance window. This also
 *  configures Play apps to be updated within the window. This is strongly
 *  recommended for kiosk devices because this is the only way apps persistently
 *  pinned to the foreground can be updated by Play.If autoUpdateMode is set to
 *  AUTO_UPDATE_HIGH_PRIORITY for an app, then the maintenance window is ignored
 *  for that app and it is updated as soon as possible even outside of the
 *  maintenance window.
 *
 *  Value: "WINDOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Windowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SystemUpdateInfo.updateStatus

/**
 *  There is a pending OS update available.
 *
 *  Value: "OS_UPDATE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_OsUpdateAvailable;
/**
 *  There is a pending security update available.
 *
 *  Value: "SECURITY_UPDATE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_SecurityUpdateAvailable;
/**
 *  There is a pending system update available, but its type is not known.
 *
 *  Value: "UNKNOWN_UPDATE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UnknownUpdateAvailable;
/**
 *  It is unknown whether there is a pending system update. This happens when,
 *  for example, the device API level is less than 26, or if the version of
 *  Android Device Policy is outdated.
 *
 *  Value: "UPDATE_STATUS_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpdateStatusUnknown;
/**
 *  There is no pending system update available on the device.
 *
 *  Value: "UP_TO_DATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpToDate;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_UsageLog.enabledLogTypes

/**
 *  This value is not used.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_EnabledLogTypes_LogTypeUnspecified;
/**
 *  Enable logging of on-device network events, like DNS lookups and TCP
 *  connections. See UsageLogEvent for a complete description of the logged
 *  network events. Supported for fully managed devices on Android 8 and above.
 *  Supported for company-owned devices with a work profile on Android 12 and
 *  above, on which only network events from the work profile are logged. Can be
 *  overridden by the application delegated scope NETWORK_ACTIVITY_LOGS
 *
 *  Value: "NETWORK_ACTIVITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_EnabledLogTypes_NetworkActivityLogs;
/**
 *  Enable logging of on-device security events, like when the device password
 *  is incorrectly entered or removable storage is mounted. See UsageLogEvent
 *  for a complete description of the logged security events. Supported for
 *  fully managed devices on Android 7 and above. Supported for company-owned
 *  devices with a work profile on Android 12 and above, on which only security
 *  events from the work profile are logged. Can be overridden by the
 *  application delegated scope SECURITY_LOGS
 *
 *  Value: "SECURITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_EnabledLogTypes_SecurityLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_UsageLog.uploadOnCellularAllowed

/**
 *  This value is not used.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_UploadOnCellularAllowed_LogTypeUnspecified;
/**
 *  Enable logging of on-device network events, like DNS lookups and TCP
 *  connections. See UsageLogEvent for a complete description of the logged
 *  network events. Supported for fully managed devices on Android 8 and above.
 *  Supported for company-owned devices with a work profile on Android 12 and
 *  above, on which only network events from the work profile are logged. Can be
 *  overridden by the application delegated scope NETWORK_ACTIVITY_LOGS
 *
 *  Value: "NETWORK_ACTIVITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_UploadOnCellularAllowed_NetworkActivityLogs;
/**
 *  Enable logging of on-device security events, like when the device password
 *  is incorrectly entered or removable storage is mounted. See UsageLogEvent
 *  for a complete description of the logged security events. Supported for
 *  fully managed devices on Android 7 and above. Supported for company-owned
 *  devices with a work profile on Android 12 and above, on which only security
 *  events from the work profile are logged. Can be overridden by the
 *  application delegated scope SECURITY_LOGS
 *
 *  Value: "SECURITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_UploadOnCellularAllowed_SecurityLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_UsageLogEvent.eventType

/**
 *  Indicates adb_shell_command_event has been set.
 *
 *  Value: "ADB_SHELL_COMMAND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellCommand;
/**
 *  Indicates adb_shell_interactive_event has been set.
 *
 *  Value: "ADB_SHELL_INTERACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellInteractive;
/**
 *  Indicates app_process_start_event has been set.
 *
 *  Value: "APP_PROCESS_START"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_AppProcessStart;
/**
 *  Indicates cert_authority_installed_event has been set.
 *
 *  Value: "CERT_AUTHORITY_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityInstalled;
/**
 *  Indicates cert_authority_removed_event has been set.
 *
 *  Value: "CERT_AUTHORITY_REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityRemoved;
/**
 *  Indicates cert_validation_failure_event has been set.
 *
 *  Value: "CERT_VALIDATION_FAILURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CertValidationFailure;
/**
 *  Indicates connect_event has been set.
 *
 *  Value: "CONNECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_Connect;
/**
 *  Indicates crypto_self_test_completed_event has been set.
 *
 *  Value: "CRYPTO_SELF_TEST_COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CryptoSelfTestCompleted;
/**
 *  Indicates dns_event has been set.
 *
 *  Value: "DNS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_Dns;
/**
 *  Indicates enrollment_complete_event has been set.
 *
 *  Value: "ENROLLMENT_COMPLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_EnrollmentComplete;
/**
 *  This value is not used
 *
 *  Value: "EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_EventTypeUnspecified;
/**
 *  Indicates file_pulled_event has been set.
 *
 *  Value: "FILE_PULLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_FilePulled;
/**
 *  Indicates file_pushed_event has been set.
 *
 *  Value: "FILE_PUSHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_FilePushed;
/**
 *  Indicates key_destruction_event has been set.
 *
 *  Value: "KEY_DESTRUCTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyDestruction;
/**
 *  Indicates key_generated_event has been set.
 *
 *  Value: "KEY_GENERATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyGenerated;
/**
 *  Indicates keyguard_dismiss_auth_attempt_event has been set.
 *
 *  Value: "KEYGUARD_DISMISS_AUTH_ATTEMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissAuthAttempt;
/**
 *  Indicates keyguard_dismissed_event has been set.
 *
 *  Value: "KEYGUARD_DISMISSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissed;
/**
 *  Indicates keyguard_secured_event has been set.
 *
 *  Value: "KEYGUARD_SECURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardSecured;
/**
 *  Indicates key_import_event has been set.
 *
 *  Value: "KEY_IMPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyImport;
/**
 *  Indicates key_integrity_violation_event has been set.
 *
 *  Value: "KEY_INTEGRITY_VIOLATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyIntegrityViolation;
/**
 *  Indicates log_buffer_size_critical_event has been set.
 *
 *  Value: "LOG_BUFFER_SIZE_CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LogBufferSizeCritical;
/**
 *  Indicates logging_started_event has been set.
 *
 *  Value: "LOGGING_STARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStarted;
/**
 *  Indicates logging_stopped_event has been set.
 *
 *  Value: "LOGGING_STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStopped;
/**
 *  Indicates lostModeLocationEvent has been set.
 *
 *  Value: "LOST_MODE_LOCATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LostModeLocation;
/**
 *  Indicates lostModeOutgoingPhoneCallEvent has been set.
 *
 *  Value: "LOST_MODE_OUTGOING_PHONE_CALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LostModeOutgoingPhoneCall;
/**
 *  Indicates media_mount_event has been set.
 *
 *  Value: "MEDIA_MOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_MediaMount;
/**
 *  Indicates media_unmount_event has been set.
 *
 *  Value: "MEDIA_UNMOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_MediaUnmount;
/**
 *  Indicates os_shutdown_event has been set.
 *
 *  Value: "OS_SHUTDOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_OsShutdown;
/**
 *  Indicates os_startup_event has been set.
 *
 *  Value: "OS_STARTUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_OsStartup;
/**
 *  Indicates remote_lock_event has been set.
 *
 *  Value: "REMOTE_LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_RemoteLock;
/**
 *  Indicates stopLostModeUserAttemptEvent has been set.
 *
 *  Value: "STOP_LOST_MODE_USER_ATTEMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_StopLostModeUserAttempt;
/**
 *  Indicates wipe_failure_event has been set.
 *
 *  Value: "WIPE_FAILURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_WipeFailure;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebApp.displayMode

/**
 *  Not used.
 *
 *  Value: "DISPLAY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_DisplayModeUnspecified;
/**
 *  Opens the web app in full screen without any visible controls. The browser
 *  UI elements, page URL, system status bar and back button are not visible,
 *  and the web app takes up the entirety of the available display area.
 *
 *  Value: "FULL_SCREEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_FullScreen;
/**
 *  Opens the web app with a minimal set of browser UI elements for controlling
 *  navigation and viewing the page URL.
 *
 *  Value: "MINIMAL_UI"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_MinimalUi;
/**
 *  Opens the web app to look and feel like a standalone native application. The
 *  browser UI elements and page URL are not visible, however the system status
 *  bar and back button are visible.
 *
 *  Value: "STANDALONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_Standalone;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebToken.enabledFeatures

/**
 *  Unspecified feature.
 *
 *  Value: "FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_FeatureUnspecified;
/**
 *  The managed configurations page
 *  (https://developers.google.com/android/management/managed-configurations-iframe).
 *
 *  Value: "MANAGED_CONFIGURATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_ManagedConfigurations;
/**
 *  The Managed Play search apps page
 *  (https://developers.google.com/android/management/apps#search-apps).
 *
 *  Value: "PLAY_SEARCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_PlaySearch;
/**
 *  The private apps page
 *  (https://developers.google.com/android/management/apps#private-apps).
 *
 *  Value: "PRIVATE_APPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_PrivateApps;
/**
 *  The organize apps page
 *  (https://developers.google.com/android/management/apps#organize-apps).
 *
 *  Value: "STORE_BUILDER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_StoreBuilder;
/**
 *  The Web Apps page
 *  (https://developers.google.com/android/management/apps#web-apps).
 *
 *  Value: "WEB_APPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_WebApps;
/**
 *  The zero-touch iframe
 *  (https://developers.google.com/android/management/zero-touch-iframe).
 *
 *  Value: "ZERO_TOUCH_CUSTOMER_MANAGEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_ZeroTouchCustomerManagement;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebToken.permissions

/**
 *  The permission to approve apps for the enterprise.
 *
 *  Value: "APPROVE_APPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_ApproveApps;
/**
 *  This value is ignored.
 *
 *  Value: "WEB_TOKEN_PERMISSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_WebTokenPermissionUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WifiSsidPolicy.wifiSsidPolicyType

/**
 *  The device can make Wi-Fi connections only to the SSIDs in wifiSsids.
 *  wifiSsids must not be empty. The device will not be able to connect to any
 *  other Wi-Fi network.
 *
 *  Value: "WIFI_SSID_ALLOWLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WifiSsidPolicy_WifiSsidPolicyType_WifiSsidAllowlist;
/**
 *  The device cannot connect to any Wi-Fi network whose SSID is in wifiSsids,
 *  but can connect to other networks.
 *
 *  Value: "WIFI_SSID_DENYLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WifiSsidPolicy_WifiSsidPolicyType_WifiSsidDenylist;
/**
 *  Defaults to WIFI_SSID_DENYLIST. wifiSsids must not be set. There are no
 *  restrictions on which SSID the device can connect to.
 *
 *  Value: "WIFI_SSID_POLICY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WifiSsidPolicy_WifiSsidPolicyType_WifiSsidPolicyTypeUnspecified;

/**
 *  A shell command was issued over ADB via adb shell command.
 */
@interface GTLRAndroidManagement_AdbShellCommandEvent : GTLRObject

/**
 *  Shell command that was issued over ADB via "adb shell command". Redacted to
 *  empty string on organization-owned managed profile devices.
 */
@property(nonatomic, copy, nullable) NSString *shellCmd;

@end


/**
 *  An ADB interactive shell was opened via adb shell. Intentionally empty.
 */
@interface GTLRAndroidManagement_AdbShellInteractiveEvent : GTLRObject
@end


/**
 *  Advanced security settings. In most cases, setting these is not needed.
 */
@interface GTLRAndroidManagement_AdvancedSecurityOverrides : GTLRObject

/**
 *  Controls Common Criteria Modesecurity standards defined in the Common
 *  Criteria for Information Technology Security Evaluation
 *  (https://www.commoncriteriaportal.org/) (CC). Enabling Common Criteria Mode
 *  increases certain security components on a device, including AES-GCM
 *  encryption of Bluetooth Long Term Keys, and Wi-Fi configuration
 *  stores.Common Criteria Mode is only supported on company-owned devices
 *  running Android 11 or above.Warning: Common Criteria Mode enforces a strict
 *  security model typically only required for IT products used in national
 *  security systems and other highly sensitive organizations. Standard device
 *  use may be affected. Only enabled if required.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeDisabled
 *        Default. Disables Common Criteria Mode. (Value:
 *        "COMMON_CRITERIA_MODE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeEnabled
 *        Enables Common Criteria Mode. (Value: "COMMON_CRITERIA_MODE_ENABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeUnspecified
 *        Unspecified. Defaults to COMMON_CRITERIA_MODE_DISABLED. (Value:
 *        "COMMON_CRITERIA_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *commonCriteriaMode;

/**
 *  Controls access to developer settings: developer options and safe boot.
 *  Replaces safeBootDisabled (deprecated) and debuggingFeaturesAllowed
 *  (deprecated).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsAllowed
 *        Allows all developer settings. The user can access and optionally
 *        configure the settings. (Value: "DEVELOPER_SETTINGS_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsDisabled
 *        Default. Disables all developer settings and prevents the user from
 *        accessing them. (Value: "DEVELOPER_SETTINGS_DISABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsUnspecified
 *        Unspecified. Defaults to DEVELOPER_SETTINGS_DISABLED. (Value:
 *        "DEVELOPER_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *developerSettings;

/**
 *  Whether Google Play Protect verification
 *  (https://support.google.com/accounts/answer/2812853) is enforced. Replaces
 *  ensureVerifyAppsEnabled (deprecated).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_GooglePlayProtectVerifyAppsUnspecified
 *        Unspecified. Defaults to VERIFY_APPS_ENFORCED. (Value:
 *        "GOOGLE_PLAY_PROTECT_VERIFY_APPS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsEnforced
 *        Default. Force-enables app verification. (Value:
 *        "VERIFY_APPS_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsUserChoice
 *        Allows the user to choose whether to enable app verification. (Value:
 *        "VERIFY_APPS_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *googlePlayProtectVerifyApps;

/**
 *  Optional. Controls Memory Tagging Extension (MTE)
 *  (https://source.android.com/docs/security/test/memory-safety/arm-mte) on the
 *  device. The device needs to be rebooted to apply changes to the MTE policy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MteDisabled
 *        MTE is disabled on the device and the user is not allowed to change
 *        this setting. This applies only on fully managed devices. In other
 *        cases, a nonComplianceDetail with MANAGEMENT_MODE is reported. A
 *        nonComplianceDetail with DEVICE_INCOMPATIBLE is reported if the device
 *        does not support MTE.Supported on Android 14 and above. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 14. (Value: "MTE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MteEnforced
 *        MTE is enabled on the device and the user is not allowed to change
 *        this setting. This can be set on fully managed devices and work
 *        profiles on company-owned devices. A nonComplianceDetail with
 *        MANAGEMENT_MODE is reported for other management modes. A
 *        nonComplianceDetail with DEVICE_INCOMPATIBLE is reported if the device
 *        does not support MTE.Supported on Android 14 and above. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 14. (Value: "MTE_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MtePolicyUnspecified
 *        Unspecified. Defaults to MTE_USER_CHOICE. (Value:
 *        "MTE_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_MtePolicy_MteUserChoice
 *        The user can choose to enable or disable MTE on the device if the
 *        device supports this. (Value: "MTE_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *mtePolicy;

/**
 *  Personal apps that can read work profile notifications using a
 *  NotificationListenerService
 *  (https://developer.android.com/reference/android/service/notification/NotificationListenerService).
 *  By default, no personal apps (aside from system apps) can read work
 *  notifications. Each value in the list must be a package name.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *personalAppsThatCanReadWorkNotifications;

/**
 *  The policy for untrusted apps (apps from unknown sources) enforced on the
 *  device. Replaces install_unknown_sources_allowed (deprecated).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallDeviceWide
 *        Allow untrusted app installs on entire device. (Value:
 *        "ALLOW_INSTALL_DEVICE_WIDE")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallInPersonalProfileOnly
 *        For devices with work profiles, allow untrusted app installs in the
 *        device's personal profile only. (Value:
 *        "ALLOW_INSTALL_IN_PERSONAL_PROFILE_ONLY")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_DisallowInstall
 *        Default. Disallow untrusted app installs on entire device. (Value:
 *        "DISALLOW_INSTALL")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_UntrustedAppsPolicyUnspecified
 *        Unspecified. Defaults to DISALLOW_INSTALL. (Value:
 *        "UNTRUSTED_APPS_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *untrustedAppsPolicy;

@end


/**
 *  Configuration for an always-on VPN connection.
 */
@interface GTLRAndroidManagement_AlwaysOnVpnPackage : GTLRObject

/**
 *  Disallows networking when the VPN is not connected.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockdownEnabled;

/** The package name of the VPN app. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  A compliance rule condition which is satisfied if the Android Framework API
 *  level on the device doesn't meet a minimum requirement. There can only be
 *  one rule with this type of condition per policy.
 */
GTLR_DEPRECATED
@interface GTLRAndroidManagement_ApiLevelCondition : GTLRObject

/**
 *  The minimum desired Android Framework API level. If the device doesn't meet
 *  the minimum requirement, this condition is satisfied. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minApiLevel;

@end


/**
 *  Information about an app.
 */
@interface GTLRAndroidManagement_Application : GTLRObject

/**
 *  Whether this app is free, free with in-app purchases, or paid. If the
 *  pricing is unspecified, this means the app is not generally available
 *  anymore (even though it might still be available to people who own it).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_AppPricingUnspecified
 *        Unknown pricing, used to denote an approved app that is not generally
 *        available. (Value: "APP_PRICING_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_Free The app is
 *        free. (Value: "FREE")
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_FreeWithInAppPurchase
 *        The app is free, but offers in-app purchases. (Value:
 *        "FREE_WITH_IN_APP_PURCHASE")
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_Paid The app is
 *        paid. (Value: "PAID")
 */
@property(nonatomic, copy, nullable) NSString *appPricing;

/** Application tracks visible to the enterprise. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_AppTrackInfo *> *appTracks;

/** Versions currently available for this app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_AppVersion *> *appVersions;

/** The name of the author of the apps (for example, the app developer). */
@property(nonatomic, copy, nullable) NSString *author;

/** The countries which this app is available in as per ISO 3166-1 alpha-2. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *availableCountries;

/** The app category (e.g. RACING, SOCIAL, etc.) */
@property(nonatomic, copy, nullable) NSString *category;

/**
 *  The content rating for this app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_ContentRatingUnspecified
 *        Unspecified. (Value: "CONTENT_RATING_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_EighteenYears
 *        Content suitable for ages 18 and above only. (Value: "EIGHTEEN_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_SevenYears
 *        Content suitable for ages 7 and above only. (Value: "SEVEN_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_SixteenYears
 *        Content suitable for ages 16 and above only. (Value: "SIXTEEN_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_ThreeYears
 *        Content suitable for ages 3 and above only. (Value: "THREE_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_TwelveYears
 *        Content suitable for ages 12 and above only. (Value: "TWELVE_YEARS")
 */
@property(nonatomic, copy, nullable) NSString *contentRating;

/**
 *  The localized promotional description, if available.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  How and to whom the package is made available.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_DistributionChannelUnspecified
 *        Unspecified. (Value: "DISTRIBUTION_CHANNEL_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_PrivateGoogleHosted
 *        Package is a private app (restricted to an enterprise) but hosted by
 *        Google. (Value: "PRIVATE_GOOGLE_HOSTED")
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_PrivateSelfHosted
 *        Private app (restricted to an enterprise) and is privately hosted.
 *        (Value: "PRIVATE_SELF_HOSTED")
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_PublicGoogleHosted
 *        Package is available through the Play store and not restricted to a
 *        specific enterprise. (Value: "PUBLIC_GOOGLE_HOSTED")
 */
@property(nonatomic, copy, nullable) NSString *distributionChannel;

/** Noteworthy features (if any) of this app. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *features;

/** Full app description, if available. */
@property(nonatomic, copy, nullable) NSString *fullDescription;

/**
 *  A link to an image that can be used as an icon for the app. This image is
 *  suitable for use up to a pixel size of 512 x 512.
 */
@property(nonatomic, copy, nullable) NSString *iconUrl;

/**
 *  The set of managed properties available to be pre-configured for the app.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *managedProperties;

/**
 *  The minimum Android SDK necessary to run the app.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minAndroidSdkVersion;

/**
 *  The name of the app in the form
 *  enterprises/{enterprise}/applications/{package_name}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The permissions required by the app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPermission *> *permissions;

/** A link to the (consumer) Google Play details page for the app. */
@property(nonatomic, copy, nullable) NSString *playStoreUrl;

/** A localised description of the recent changes made to the app. */
@property(nonatomic, copy, nullable) NSString *recentChanges;

/** A list of screenshot links representing the app. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *screenshotUrls;

/**
 *  A link to a smaller image that can be used as an icon for the app. This
 *  image is suitable for use up to a pixel size of 128 x 128.
 */
@property(nonatomic, copy, nullable) NSString *smallIconUrl;

/** The title of the app. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  Output only. The approximate time (within 7 days) the app was last
 *  published.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  An app-related event.
 */
@interface GTLRAndroidManagement_ApplicationEvent : GTLRObject

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  App event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_ApplicationEventTypeUnspecified
 *        This value is disallowed. (Value:
 *        "APPLICATION_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Changed The app
 *        was changed, for example, a component was enabled or disabled. (Value:
 *        "CHANGED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_DataCleared The
 *        app data was cleared. (Value: "DATA_CLEARED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Installed The
 *        app was installed. (Value: "INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Pinned The app
 *        was pinned to the foreground. (Value: "PINNED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Removed The app
 *        was removed. (Value: "REMOVED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Replaced A new
 *        version of the app has been installed, replacing the old version.
 *        (Value: "REPLACED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Restarted The
 *        app was restarted. (Value: "RESTARTED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Unpinned The app
 *        was unpinned. (Value: "UNPINNED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  A permission required by the app.
 */
@interface GTLRAndroidManagement_ApplicationPermission : GTLRObject

/**
 *  A longer description of the permission, providing more detail on what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The name of the permission. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/** An opaque string uniquely identifying the permission. Not localized. */
@property(nonatomic, copy, nullable) NSString *permissionId;

@end


/**
 *  Policy for an individual app. Note: Application availability on a given
 *  device cannot be changed using this policy if installAppsDisabled is
 *  enabled. The maximum number of applications that you can specify per policy
 *  is 3,000.
 */
@interface GTLRAndroidManagement_ApplicationPolicy : GTLRObject

/**
 *  List of the apps track IDs that a device belonging to the enterprise can
 *  access. If the list contains multiple track IDs, devices receive the latest
 *  version among all accessible tracks. If the list contains no track IDs,
 *  devices only have access to the apps production track. More details about
 *  each track are available in AppTrackInfo.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accessibleTrackIds;

/**
 *  Specifies whether the app is allowed networking when the VPN is not
 *  connected and alwaysOnVpnPackage.lockdownEnabled is enabled. If set to
 *  VPN_LOCKDOWN_ENFORCED, the app is not allowed networking, and if set to
 *  VPN_LOCKDOWN_EXEMPTION, the app is allowed networking. Only supported on
 *  devices running Android 10 and above. If this is not supported by the
 *  device, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to API_LEVEL and a fieldPath. If this is not
 *  applicable to the app, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to UNSUPPORTED and a fieldPath. The fieldPath is
 *  set to applications[i].alwaysOnVpnLockdownExemption, where i is the index of
 *  the package in the applications policy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_AlwaysOnVpnLockdownExemptionUnspecified
 *        Unspecified. Defaults to VPN_LOCKDOWN_ENFORCED. (Value:
 *        "ALWAYS_ON_VPN_LOCKDOWN_EXEMPTION_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownEnforced
 *        The app respects the always-on VPN lockdown setting. (Value:
 *        "VPN_LOCKDOWN_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownExemption
 *        The app is exempt from the always-on VPN lockdown setting. (Value:
 *        "VPN_LOCKDOWN_EXEMPTION")
 */
@property(nonatomic, copy, nullable) NSString *alwaysOnVpnLockdownExemption;

/**
 *  Controls the auto-update mode for the app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateDefault
 *        The default update mode.The app is automatically updated with low
 *        priority to minimize the impact on the user.The app is updated when
 *        all of the following constraints are met: The device is not actively
 *        used. The device is connected to an unmetered network. The device is
 *        charging. The app to be updated is not running in the foreground.The
 *        device is notified about a new update within 24 hours after it is
 *        published by the developer, after which the app is updated the next
 *        time the constraints above are met. (Value: "AUTO_UPDATE_DEFAULT")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateHighPriority
 *        The app is updated as soon as possible. No constraints are applied.The
 *        device is notified as soon as possible about a new update after it
 *        becomes available.*NOTE:* Updates to apps with larger deployments
 *        across Android's ecosystem can take up to 24h. (Value:
 *        "AUTO_UPDATE_HIGH_PRIORITY")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateModeUnspecified
 *        Unspecified. Defaults to AUTO_UPDATE_DEFAULT. (Value:
 *        "AUTO_UPDATE_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdatePostponed
 *        The app is not automatically updated for a maximum of 90 days after
 *        the app becomes out of date.90 days after the app becomes out of date,
 *        the latest available version is installed automatically with low
 *        priority (see AUTO_UPDATE_DEFAULT). After the app is updated it is not
 *        automatically updated again until 90 days after it becomes out of date
 *        again.The user can still manually update the app from the Play Store
 *        at any time. (Value: "AUTO_UPDATE_POSTPONED")
 */
@property(nonatomic, copy, nullable) NSString *autoUpdateMode;

/**
 *  Controls whether the app can communicate with itself across a devices work
 *  and personal profiles, subject to user consent.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppAllowed
 *        Allows the app to communicate across profiles after receiving user
 *        consent. (Value: "CONNECTED_WORK_AND_PERSONAL_APP_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppDisallowed
 *        Default. Prevents the app from communicating cross-profile. (Value:
 *        "CONNECTED_WORK_AND_PERSONAL_APP_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppUnspecified
 *        Unspecified. Defaults to CONNECTED_WORK_AND_PERSONAL_APPS_DISALLOWED.
 *        (Value: "CONNECTED_WORK_AND_PERSONAL_APP_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *connectedWorkAndPersonalApp;

/**
 *  Optional. Whether the app is allowed to act as a credential provider on
 *  Android 14 and above.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_CredentialProviderPolicy_CredentialProviderAllowed
 *        App is allowed to act as a credential provider. (Value:
 *        "CREDENTIAL_PROVIDER_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_CredentialProviderPolicy_CredentialProviderPolicyUnspecified
 *        Unspecified. The behaviour is governed by
 *        credentialProviderPolicyDefault. (Value:
 *        "CREDENTIAL_PROVIDER_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *credentialProviderPolicy;

/**
 *  The default policy for all permissions requested by the app. If specified,
 *  this overrides the policy-level default_permission_policy which applies to
 *  all apps. It does not override the permission_grants which applies to all
 *  apps.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission.On Android 12 and above,
 *        Manifest.permission.READ_SMS
 *        (https://developer.android.com/reference/android/Manifest.permission#READ_SMS)
 *        and following sensor-related permissions can only be granted on fully
 *        managed devices: Manifest.permission.ACCESS_FINE_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_FINE_LOCATION)
 *        Manifest.permission.ACCESS_BACKGROUND_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_BACKGROUND_LOCATION)
 *        Manifest.permission.ACCESS_COARSE_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_COARSE_LOCATION)
 *        Manifest.permission.CAMERA
 *        (https://developer.android.com/reference/android/Manifest.permission#CAMERA)
 *        Manifest.permission.RECORD_AUDIO
 *        (https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO)
 *        Manifest.permission.ACTIVITY_RECOGNITION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACTIVITY_RECOGNITION)
 *        Manifest.permission.BODY_SENSORS
 *        (https://developer.android.com/reference/android/Manifest.permission#BODY_SENSORS)
 *        (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/**
 *  The scopes delegated to the app from Android Device Policy. These provide
 *  additional privileges for the applications they are applied to.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *delegatedScopes;

/**
 *  Whether the app is disabled. When disabled, the app data is still preserved.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

/**
 *  Configuration to enable this app as an extension app, with the capability of
 *  interacting with Android Device Policy offline.This field can be set for at
 *  most one app.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ExtensionConfig *extensionConfig;

/**
 *  Optional. The constraints for installing the app. You can specify a maximum
 *  of one InstallConstraint. Multiple constraints are rejected.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_InstallConstraint *> *installConstraint;

/**
 *  Optional. Amongst apps with installType set to: FORCE_INSTALLED
 *  PREINSTALLEDthis controls the relative priority of installation. A value of
 *  0 (default) means this app has no priority over other apps. For values
 *  between 1 and 10,000, a lower value means a higher priority. Values outside
 *  of the range 0 to 10,000 inclusive are rejected.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installPriority;

/**
 *  The type of installation to perform.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Available The
 *        app is available to install. (Value: "AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Blocked The
 *        app is blocked and can't be installed. If the app was installed under
 *        a previous policy, it will be uninstalled. This also blocks its
 *        instant app functionality. (Value: "BLOCKED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled
 *        The app is automatically installed regardless of a set maintenance
 *        window and can't be removed by the user. (Value: "FORCE_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified
 *        Unspecified. Defaults to AVAILABLE. (Value:
 *        "INSTALL_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Kiosk The app
 *        is automatically installed in kiosk mode: it's set as the preferred
 *        home intent and whitelisted for lock task mode. Device setup won't
 *        complete until the app is installed. After installation, users won't
 *        be able to remove the app. You can only set this installType for one
 *        app per policy. When this is present in the policy, status bar will be
 *        automatically disabled. (Value: "KIOSK")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled
 *        The app is automatically installed and can be removed by the user.
 *        (Value: "PREINSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_RequiredForSetup
 *        The app is automatically installed and can't be removed by the user
 *        and will prevent setup from completion until installation is complete.
 *        (Value: "REQUIRED_FOR_SETUP")
 */
@property(nonatomic, copy, nullable) NSString *installType;

/**
 *  Whether the app is allowed to lock itself in full-screen mode. DEPRECATED.
 *  Use InstallType KIOSK or kioskCustomLauncherEnabled to configure a dedicated
 *  device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockTaskAllowed GTLR_DEPRECATED;

/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: *type* *JSON value* BOOL true or false STRING string
 *  INTEGER number CHOICE string MULTISELECT array of strings HIDDEN string
 *  BUNDLE_ARRAY array of objects
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration *managedConfiguration;

/**
 *  The managed configurations template for the app, saved from the managed
 *  configurations iframe. This field is ignored if managed_configuration is
 *  set.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ManagedConfigurationTemplate *managedConfigurationTemplate;

/**
 *  The minimum version of the app that runs on the device. If set, the device
 *  attempts to update the app to at least this version code. If the app is not
 *  up-to-date, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to APP_NOT_UPDATED. The app must already be
 *  published to Google Play with a version code greater than or equal to this
 *  value. At most 20 apps may specify a minimum version code per policy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimumVersionCode;

/**
 *  The package name of the app. For example, com.google.android.youtube for the
 *  YouTube app.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  Explicit permission grants or denials for the app. These values override the
 *  default_permission_policy and permission_grants which apply to all apps.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

/**
 *  Optional. Specifies whether user control is permitted for the app. User
 *  control includes user actions like force-stopping and clearing app data.
 *  Supported on Android 11 and above.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_UserControlSettings_UserControlAllowed
 *        User control is allowed for the app. Kiosk apps can use this to allow
 *        user control. (Value: "USER_CONTROL_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_UserControlSettings_UserControlDisallowed
 *        User control is disallowed for the app. API_LEVEL is reported if the
 *        Android version is less than 11. (Value: "USER_CONTROL_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_UserControlSettings_UserControlSettingsUnspecified
 *        Uses the default behaviour of the app to determine if user control is
 *        allowed or disallowed. For most apps, user control is allowed by
 *        default, but for some critical apps such as companion apps
 *        (extensionConfig set to true), kiosk apps and other critical system
 *        apps, user control is disallowed. (Value:
 *        "USER_CONTROL_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *userControlSettings;

/**
 *  Specifies whether the app installed in the work profile is allowed to add
 *  widgets to the home screen.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_WorkProfileWidgets_WorkProfileWidgetsAllowed
 *        Work profile widgets are allowed. This means the application will be
 *        able to add widgets to the home screen. (Value:
 *        "WORK_PROFILE_WIDGETS_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_WorkProfileWidgets_WorkProfileWidgetsDisallowed
 *        Work profile widgets are disallowed. This means the application will
 *        not be able to add widgets to the home screen. (Value:
 *        "WORK_PROFILE_WIDGETS_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_WorkProfileWidgets_WorkProfileWidgetsUnspecified
 *        Unspecified. Defaults to work_profile_widgets_default (Value:
 *        "WORK_PROFILE_WIDGETS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *workProfileWidgets;

@end


/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: *type* *JSON value* BOOL true or false STRING string
 *  INTEGER number CHOICE string MULTISELECT array of strings HIDDEN string
 *  BUNDLE_ARRAY array of objects
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration : GTLRObject
@end


/**
 *  Information reported about an installed app.
 */
@interface GTLRAndroidManagement_ApplicationReport : GTLRObject

/**
 *  The source of the package.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_ApplicationSourceUnspecified
 *        The app was sideloaded from an unspecified source. (Value:
 *        "APPLICATION_SOURCE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_InstalledFromPlayStore
 *        The app was installed from the Google Play Store. (Value:
 *        "INSTALLED_FROM_PLAY_STORE")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppFactoryVersion
 *        This is a system app from the device's factory image. (Value:
 *        "SYSTEM_APP_FACTORY_VERSION")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppUpdatedVersion
 *        This is an updated system app. (Value: "SYSTEM_APP_UPDATED_VERSION")
 */
@property(nonatomic, copy, nullable) NSString *applicationSource;

/** The display name of the app. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** The list of app events which have occurred in the last 30 hours. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationEvent *> *events;

/** The package name of the app that installed this app. */
@property(nonatomic, copy, nullable) NSString *installerPackageName;

/** List of keyed app states reported by the app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_KeyedAppState *> *keyedAppStates;

/** Package name of the app. */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The SHA-256 hash of the app's APK file, which can be used to verify the app
 *  hasn't been modified. Each byte of the hash value is represented as a
 *  two-digit hexadecimal number.
 */
@property(nonatomic, copy, nullable) NSString *packageSha256Hash;

/**
 *  The SHA-1 hash of each android.content.pm.Signature
 *  (https://developer.android.com/reference/android/content/pm/Signature.html)
 *  associated with the app package. Each byte of each hash value is represented
 *  as a two-digit hexadecimal number.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingKeyCertFingerprints;

/**
 *  Application state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_ApplicationStateUnspecified
 *        App state is unspecified (Value: "APPLICATION_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_Installed App is
 *        installed on the device (Value: "INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_Removed App was
 *        removed from the device (Value: "REMOVED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Whether the app is user facing.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_UserFacingType_NotUserFacing
 *        App is not user facing. (Value: "NOT_USER_FACING")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_UserFacingType_UserFacing
 *        App is user facing. (Value: "USER_FACING")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_UserFacingType_UserFacingTypeUnspecified
 *        App user facing type is unspecified. (Value:
 *        "USER_FACING_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *userFacingType;

/**
 *  The app version code, which can be used to determine whether one version is
 *  more recent than another.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

/** The app version as displayed to the user. */
@property(nonatomic, copy, nullable) NSString *versionName;

@end


/**
 *  Settings controlling the behavior of application reports.
 */
@interface GTLRAndroidManagement_ApplicationReportingSettings : GTLRObject

/**
 *  Whether removed apps are included in application reports.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *includeRemovedApps;

@end


/**
 *  Information about a process. It contains process name, start time, app Uid,
 *  app Pid, seinfo tag, hash of the base APK.
 */
@interface GTLRAndroidManagement_AppProcessInfo : GTLRObject

/** SHA-256 hash of the base APK, in hexadecimal format. */
@property(nonatomic, copy, nullable) NSString *apkSha256Hash;

/**
 *  Package names of all packages that are associated with the particular user
 *  ID. In most cases, this will be a single package name, the package that has
 *  been assigned that user ID. If multiple application share a UID then all
 *  packages sharing UID will be included.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

/**
 *  Process ID.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pid;

/** Process name. */
@property(nonatomic, copy, nullable) NSString *processName;

/** SELinux policy info. */
@property(nonatomic, copy, nullable) NSString *seinfo;

/** Process start time. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  UID of the package.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *uid;

@end


/**
 *  An app process was started. This is available device-wide on fully managed
 *  devices and within the work profile on organization-owned devices with a
 *  work profile.
 */
@interface GTLRAndroidManagement_AppProcessStartEvent : GTLRObject

/** Information about a process. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AppProcessInfo *processInfo;

@end


/**
 *  Id to name association of a app track.
 */
@interface GTLRAndroidManagement_AppTrackInfo : GTLRObject

/**
 *  The track name associated with the trackId, set in the Play Console. The
 *  name is modifiable from Play Console.
 */
@property(nonatomic, copy, nullable) NSString *trackAlias;

/**
 *  The unmodifiable unique track identifier, taken from the releaseTrackId in
 *  the URL of the Play Console page that displays the apps track information.
 */
@property(nonatomic, copy, nullable) NSString *trackId;

@end


/**
 *  This represents a single version of the app.
 */
@interface GTLRAndroidManagement_AppVersion : GTLRObject

/**
 *  If the value is True, it indicates that this version is a production track.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *production;

/**
 *  Track identifiers that the app version is published in. This does not
 *  include the production track (see production instead).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *trackIds;

/**
 *  Unique increasing identifier for the app version.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

/**
 *  The string used in the Play store by the app developer to identify the
 *  version. The string is not necessarily unique or localized (for example, the
 *  string could be "1.4").
 */
@property(nonatomic, copy, nullable) NSString *versionString;

@end


/**
 *  Batched event logs of events from the device.
 */
@interface GTLRAndroidManagement_BatchUsageLogEvents : GTLRObject

/**
 *  If present, the name of the device in the form
 *  enterprises/{enterpriseId}/devices/{deviceId}
 */
@property(nonatomic, copy, nullable) NSString *device;

/**
 *  The device timestamp when the batch of events were collected from the
 *  device.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *retrievalTime;

/**
 *  The list of UsageLogEvent that were reported by the device, sorted
 *  chronologically by the event time.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_UsageLogEvent *> *usageLogEvents;

/**
 *  If present, the resource name of the user that owns this device in the form
 *  enterprises/{enterpriseId}/users/{userId}.
 */
@property(nonatomic, copy, nullable) NSString *user;

@end


/**
 *  An action to block access to apps and data on a fully managed device or in a
 *  work profile. This action also triggers a device or work profile to displays
 *  a user-facing notification with information (where possible) on how to
 *  correct the compliance issue. Note: wipeAction must also be specified.
 */
@interface GTLRAndroidManagement_BlockAction : GTLRObject

/**
 *  Number of days the policy is non-compliant before the device or work profile
 *  is blocked. To block access immediately, set to 0. blockAfterDays must be
 *  less than wipeAfterDays.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockAfterDays;

/**
 *  Specifies the scope of this BlockAction. Only applicable to devices that are
 *  company-owned.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeDevice
 *        Block action is applied to the entire device, including apps in the
 *        personal profile. (Value: "BLOCK_SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeUnspecified
 *        Unspecified. Defaults to BLOCK_SCOPE_WORK_PROFILE. (Value:
 *        "BLOCK_SCOPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeWorkProfile
 *        Block action is only applied to apps in the work profile. Apps in the
 *        personal profile are unaffected. (Value: "BLOCK_SCOPE_WORK_PROFILE")
 */
@property(nonatomic, copy, nullable) NSString *blockScope;

@end


/**
 *  A new root certificate was installed into the system's trusted credential
 *  storage. This is available device-wide on fully managed devices and within
 *  the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_CertAuthorityInstalledEvent : GTLRObject

/** Subject of the certificate. */
@property(nonatomic, copy, nullable) NSString *certificate;

/**
 *  Whether the installation event succeeded.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

/**
 *  The user in which the certificate install event happened. Only available for
 *  devices running Android 11 and above.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *userId;

@end


/**
 *  A root certificate was removed from the system's trusted credential storage.
 *  This is available device-wide on fully managed devices and within the work
 *  profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_CertAuthorityRemovedEvent : GTLRObject

/** Subject of the certificate. */
@property(nonatomic, copy, nullable) NSString *certificate;

/**
 *  Whether the removal succeeded.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

/**
 *  The user in which the certificate removal event occurred. Only available for
 *  devices running Android 11 and above.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *userId;

@end


/**
 *  An X.509v3 certificate failed to validate, currently this validation is
 *  performed on the Wi-FI access point and failure may be due to a mismatch
 *  upon server certificate validation. However it may in the future include
 *  other validation events of an X.509v3 certificate.
 */
@interface GTLRAndroidManagement_CertValidationFailureEvent : GTLRObject

/** The reason why certification validation failed. */
@property(nonatomic, copy, nullable) NSString *failureReason;

@end


/**
 *  Controls apps' access to private keys. The rule determines which private
 *  key, if any, Android Device Policy grants to the specified app. Access is
 *  granted either when the app calls KeyChain.choosePrivateKeyAlias
 *  (https://developer.android.com/reference/android/security/KeyChain#choosePrivateKeyAlias%28android.app.Activity,%20android.security.KeyChainAliasCallback,%20java.lang.String[],%20java.security.Principal[],%20java.lang.String,%20int,%20java.lang.String%29)
 *  (or any overloads) to request a private key alias for a given URL, or for
 *  rules that are not URL-specific (that is, if urlPattern is not set, or set
 *  to the empty string or .*) on Android 11 and above, directly so that the app
 *  can call KeyChain.getPrivateKey
 *  (https://developer.android.com/reference/android/security/KeyChain#getPrivateKey%28android.content.Context,%20java.lang.String%29),
 *  without first having to call KeyChain.choosePrivateKeyAlias.When an app
 *  calls KeyChain.choosePrivateKeyAlias if more than one choosePrivateKeyRules
 *  matches, the last matching rule defines which key alias to return.
 */
@interface GTLRAndroidManagement_ChoosePrivateKeyRule : GTLRObject

/**
 *  The package names to which this rule applies. The hash of the signing
 *  certificate for each app is verified against the hash provided by Play. If
 *  no package names are specified, then the alias is provided to all apps that
 *  call KeyChain.choosePrivateKeyAlias
 *  (https://developer.android.com/reference/android/security/KeyChain#choosePrivateKeyAlias%28android.app.Activity,%20android.security.KeyChainAliasCallback,%20java.lang.String[],%20java.security.Principal[],%20java.lang.String,%20int,%20java.lang.String%29)
 *  or any overloads (but not without calling KeyChain.choosePrivateKeyAlias,
 *  even on Android 11 and above). Any app with the same Android UID as a
 *  package specified here will have access when they call
 *  KeyChain.choosePrivateKeyAlias.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

/** The alias of the private key to be used. */
@property(nonatomic, copy, nullable) NSString *privateKeyAlias;

/**
 *  The URL pattern to match against the URL of the request. If not set or
 *  empty, it matches all URLs. This uses the regular expression syntax of
 *  java.util.regex.Pattern.
 */
@property(nonatomic, copy, nullable) NSString *urlPattern;

@end


/**
 *  Parameters associated with the CLEAR_APP_DATA command to clear the data of
 *  specified apps from the device.
 */
@interface GTLRAndroidManagement_ClearAppsDataParams : GTLRObject

/**
 *  The package names of the apps whose data will be cleared when the command is
 *  executed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

@end


/**
 *  Status of the CLEAR_APP_DATA command to clear the data of specified apps
 *  from the device.
 */
@interface GTLRAndroidManagement_ClearAppsDataStatus : GTLRObject

/**
 *  The per-app results, a mapping from package names to the respective clearing
 *  result.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ClearAppsDataStatus_Results *results;

@end


/**
 *  The per-app results, a mapping from package names to the respective clearing
 *  result.
 *
 *  @note This class is documented as having more properties of
 *        GTLRAndroidManagement_PerAppResult. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_ClearAppsDataStatus_Results : GTLRObject
@end


/**
 *  A command.
 */
@interface GTLRAndroidManagement_Command : GTLRObject

/**
 *  Parameters for the CLEAR_APP_DATA command to clear the data of specified
 *  apps from the device. See ClearAppsDataParams. If this is set, then it is
 *  suggested that type should not be set. In this case, the server
 *  automatically sets it to CLEAR_APP_DATA. It is also acceptable to explicitly
 *  set type to CLEAR_APP_DATA.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ClearAppsDataParams *clearAppsDataParams;

/**
 *  Output only. Status of the CLEAR_APP_DATA command to clear the data of
 *  specified apps from the device. See ClearAppsDataStatus.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ClearAppsDataStatus *clearAppsDataStatus;

/**
 *  The timestamp at which the command was created. The timestamp is
 *  automatically generated by the server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The duration for which the command is valid. The command will expire if not
 *  executed by the device during this time. The default duration if unspecified
 *  is ten minutes. There is no maximum duration.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  If the command failed, an error code explaining the failure. This is not set
 *  when the command is cancelled by the caller.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_ApiLevel The API level of
 *        the device does not support this command. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_CommandErrorCodeUnspecified
 *        There was no error. (Value: "COMMAND_ERROR_CODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_InvalidValue The command
 *        has an invalid parameter value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_ManagementMode The
 *        management mode (profile owner, device owner, etc.) does not support
 *        the command. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_Unknown An unknown error
 *        occurred. (Value: "UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_Unsupported The device
 *        doesn't support the command. Updating Android Device Policy to the
 *        latest version may resolve the issue. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *errorCode;

/**
 *  For commands of type RESET_PASSWORD, optionally specifies the new password.
 *  Note: The new password must be at least 6 characters long if it is numeric
 *  in case of Android 14 devices. Else the command will fail with
 *  INVALID_VALUE.
 */
@property(nonatomic, copy, nullable) NSString *newPassword NS_RETURNS_NOT_RETAINED;

/** For commands of type RESET_PASSWORD, optionally specifies flags. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resetPasswordFlags;

/**
 *  Parameters for the START_LOST_MODE command to put the device into lost mode.
 *  See StartLostModeParams. If this is set, then it is suggested that type
 *  should not be set. In this case, the server automatically sets it to
 *  START_LOST_MODE. It is also acceptable to explicitly set type to
 *  START_LOST_MODE.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StartLostModeParams *startLostModeParams;

/**
 *  Output only. Status of the START_LOST_MODE command to put the device into
 *  lost mode. See StartLostModeStatus.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StartLostModeStatus *startLostModeStatus;

/**
 *  Parameters for the STOP_LOST_MODE command to take the device out of lost
 *  mode. See StopLostModeParams. If this is set, then it is suggested that type
 *  should not be set. In this case, the server automatically sets it to
 *  STOP_LOST_MODE. It is also acceptable to explicitly set type to
 *  STOP_LOST_MODE.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StopLostModeParams *stopLostModeParams;

/**
 *  Output only. Status of the STOP_LOST_MODE command to take the device out of
 *  lost mode. See StopLostModeStatus.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StopLostModeStatus *stopLostModeStatus;

/**
 *  The type of the command.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_Type_ClearAppData Clears the
 *        application data of specified apps. This is supported on Android 9 and
 *        above. Note that an application can store data outside of its
 *        application data, for example in external storage or in a user
 *        dictionary. See also clear_apps_data_params. (Value: "CLEAR_APP_DATA")
 *    @arg @c kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified This
 *        value is disallowed. (Value: "COMMAND_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Lock Lock the device, as if
 *        the lock screen timeout had expired. (Value: "LOCK")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Reboot Reboot the device. Only
 *        supported on fully managed devices running Android 7.0 (API level 24)
 *        or higher. (Value: "REBOOT")
 *    @arg @c kGTLRAndroidManagement_Command_Type_RelinquishOwnership Removes
 *        the work profile and all policies from a company-owned Android 8.0+
 *        device, relinquishing the device for personal use. Apps and data
 *        associated with the personal profile(s) are preserved. The device will
 *        be deleted from the server after it acknowledges the command. (Value:
 *        "RELINQUISH_OWNERSHIP")
 *    @arg @c kGTLRAndroidManagement_Command_Type_ResetPassword Reset the user's
 *        password. (Value: "RESET_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Command_Type_StartLostMode Puts the device
 *        into lost mode. Only supported on fully managed devices or
 *        organization-owned devices with a managed profile. See also
 *        start_lost_mode_params. (Value: "START_LOST_MODE")
 *    @arg @c kGTLRAndroidManagement_Command_Type_StopLostMode Takes the device
 *        out of lost mode. Only supported on fully managed devices or
 *        organization-owned devices with a managed profile. See also
 *        stop_lost_mode_params. (Value: "STOP_LOST_MODE")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The resource name of the user that owns the device in the form
 *  enterprises/{enterpriseId}/users/{userId}. This is automatically generated
 *  by the server based on the device the command is sent to.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Information about Common Criteria Modesecurity standards defined in the
 *  Common Criteria for Information Technology Security Evaluation
 *  (https://www.commoncriteriaportal.org/) (CC).This information is only
 *  available if statusReportingSettings.commonCriteriaModeEnabled is true in
 *  the device's policy.
 */
@interface GTLRAndroidManagement_CommonCriteriaModeInfo : GTLRObject

/**
 *  Whether Common Criteria Mode is enabled.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeDisabled
 *        Common Criteria Mode is currently disabled. (Value:
 *        "COMMON_CRITERIA_MODE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeEnabled
 *        Common Criteria Mode is currently enabled. (Value:
 *        "COMMON_CRITERIA_MODE_ENABLED")
 *    @arg @c kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeStatusUnknown
 *        Unknown status. (Value: "COMMON_CRITERIA_MODE_STATUS_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *commonCriteriaModeStatus;

@end


/**
 *  A rule declaring which mitigating actions to take when a device is not
 *  compliant with its policy. For every rule, there is always an implicit
 *  mitigating action to set policy_compliant to false for the Device resource,
 *  and display a message on the device indicating that the device is not
 *  compliant with its policy. Other mitigating actions may optionally be taken
 *  as well, depending on the field values in the rule.
 */
GTLR_DEPRECATED
@interface GTLRAndroidManagement_ComplianceRule : GTLRObject

/**
 *  A condition which is satisfied if the Android Framework API level on the
 *  device doesn't meet a minimum requirement.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApiLevelCondition *apiLevelCondition;

/**
 *  If set to true, the rule includes a mitigating action to disable apps so
 *  that the device is effectively disabled, but app data is preserved. If the
 *  device is running an app in locked task mode, the app will be closed and a
 *  UI showing the reason for non-compliance will be displayed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableApps;

/**
 *  A condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NonComplianceDetailCondition *nonComplianceDetailCondition;

/**
 *  If set, the rule includes a mitigating action to disable apps specified in
 *  the list, but app data is preserved.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNamesToDisable;

@end


/**
 *  A TCP connect event was initiated through the standard network stack.
 */
@interface GTLRAndroidManagement_ConnectEvent : GTLRObject

/** The destination IP address of the connect call. */
@property(nonatomic, copy, nullable) NSString *destinationIpAddress;

/**
 *  The destination port of the connect call.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *destinationPort;

/** The package name of the UID that performed the connect call. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  Contact details for managed Google Play enterprises.
 */
@interface GTLRAndroidManagement_ContactInfo : GTLRObject

/**
 *  Email address for a point of contact, which will be used to send important
 *  announcements related to managed Google Play.
 */
@property(nonatomic, copy, nullable) NSString *contactEmail;

/**
 *  The email of the data protection officer. The email is validated but not
 *  verified.
 */
@property(nonatomic, copy, nullable) NSString *dataProtectionOfficerEmail;

/** The name of the data protection officer. */
@property(nonatomic, copy, nullable) NSString *dataProtectionOfficerName;

/**
 *  The phone number of the data protection officer The phone number is
 *  validated but not verified.
 */
@property(nonatomic, copy, nullable) NSString *dataProtectionOfficerPhone;

/**
 *  The email of the EU representative. The email is validated but not verified.
 */
@property(nonatomic, copy, nullable) NSString *euRepresentativeEmail;

/** The name of the EU representative. */
@property(nonatomic, copy, nullable) NSString *euRepresentativeName;

/**
 *  The phone number of the EU representative. The phone number is validated but
 *  not verified.
 */
@property(nonatomic, copy, nullable) NSString *euRepresentativePhone;

@end


/**
 *  This feature is not generally available.
 */
@interface GTLRAndroidManagement_ContentProviderEndpoint : GTLRObject

/** This feature is not generally available. */
@property(nonatomic, copy, nullable) NSString *packageName;

/** Required. This feature is not generally available. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingCertsSha256;

/** This feature is not generally available. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Controls the data from the work profile that can be accessed from the
 *  personal profile and vice versa. A nonComplianceDetail with MANAGEMENT_MODE
 *  is reported if the device does not have a work profile.
 */
@interface GTLRAndroidManagement_CrossProfilePolicies : GTLRObject

/**
 *  Whether text copied from one profile (personal or work) can be pasted in the
 *  other profile.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CopyFromWorkToPersonalDisallowed
 *        Default. Prevents users from pasting into the personal profile text
 *        copied from the work profile. Text copied from the personal profile
 *        can be pasted into the work profile, and text copied from the work
 *        profile can be pasted into the work profile. (Value:
 *        "COPY_FROM_WORK_TO_PERSONAL_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteAllowed
 *        Text copied in either profile can be pasted in the other profile.
 *        (Value: "CROSS_PROFILE_COPY_PASTE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteUnspecified
 *        Unspecified. Defaults to COPY_FROM_WORK_TO_PERSONAL_DISALLOWED (Value:
 *        "CROSS_PROFILE_COPY_PASTE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *crossProfileCopyPaste;

/**
 *  Whether data from one profile (personal or work) can be shared with apps in
 *  the other profile. Specifically controls simple data sharing via intents.
 *  Management of other cross-profile communication channels, such as contact
 *  search, copy/paste, or connected work & personal apps, are configured
 *  separately.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingAllowed
 *        Data from either profile can be shared with the other profile. (Value:
 *        "CROSS_PROFILE_DATA_SHARING_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingDisallowed
 *        Prevents data from being shared from both the personal profile to the
 *        work profile and the work profile to the personal profile. (Value:
 *        "CROSS_PROFILE_DATA_SHARING_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingUnspecified
 *        Unspecified. Defaults to
 *        DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED. (Value:
 *        "CROSS_PROFILE_DATA_SHARING_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_DataSharingFromWorkToPersonalDisallowed
 *        Default. Prevents users from sharing data from the work profile to
 *        apps in the personal profile. Personal data can be shared with work
 *        apps. (Value: "DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED")
 */
@property(nonatomic, copy, nullable) NSString *crossProfileDataSharing;

/**
 *  List of apps which are excluded from the ShowWorkContactsInPersonalProfile
 *  setting. For this to be set, ShowWorkContactsInPersonalProfile must be set
 *  to one of the following values:
 *  SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED. In this case, these
 *  exemptions act as a blocklist.
 *  SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED. In this case, these
 *  exemptions act as an allowlist.
 *  SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED_EXCEPT_SYSTEM. In this
 *  case, these exemptions act as an allowlist, in addition to the already
 *  allowlisted system apps.Supported on Android 14 and above. A
 *  nonComplianceDetail with API_LEVEL is reported if the Android version is
 *  less than 14.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PackageNameList *exemptionsToShowWorkContactsInPersonalProfile;

/**
 *  Whether personal apps can access contacts stored in the work profile.See
 *  also exemptions_to_show_work_contacts_in_personal_profile.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileAllowed
 *        Default. Allows apps in the personal profile to access work profile
 *        contacts including contact searches and incoming calls.When this is
 *        set, personal apps specified in
 *        exemptions_to_show_work_contacts_in_personal_profile are blocklisted
 *        and can not access work profile contacts directly.Supported on Android
 *        7.0 and above. A nonComplianceDetail with API_LEVEL is reported if the
 *        Android version is less than 7.0. (Value:
 *        "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileDisallowed
 *        Prevents personal apps from accessing work profile contacts and
 *        looking up work contacts.When this is set, personal apps specified in
 *        exemptions_to_show_work_contacts_in_personal_profile are allowlisted
 *        and can access work profile contacts directly.Supported on Android 7.0
 *        and above. A nonComplianceDetail with API_LEVEL is reported if the
 *        Android version is less than 7.0. (Value:
 *        "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileDisallowedExceptSystem
 *        Prevents most personal apps from accessing work profile contacts
 *        including contact searches and incoming calls, except for the OEM
 *        default Dialer, Messages, and Contacts apps. Neither user-configured
 *        Dialer, Messages, and Contacts apps, nor any other system or play
 *        installed apps, will be able to query work contacts directly.When this
 *        is set, personal apps specified in
 *        exemptions_to_show_work_contacts_in_personal_profile are allowlisted
 *        and can access work profile contacts.Supported on Android 14 and
 *        above. If this is set on a device with Android version less than 14,
 *        the behaviour falls back to
 *        SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED and a
 *        nonComplianceDetail with API_LEVEL is reported. (Value:
 *        "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED_EXCEPT_SYSTEM")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileUnspecified
 *        Unspecified. Defaults to
 *        SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED.When this is set,
 *        exemptions_to_show_work_contacts_in_personal_profile must not be set.
 *        (Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *showWorkContactsInPersonalProfile;

/**
 *  Specifies the default behaviour for work profile widgets. If the policy does
 *  not specify work_profile_widgets for a specific application, it will behave
 *  according to the value specified here.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_WorkProfileWidgetsDefault_WorkProfileWidgetsDefaultAllowed
 *        Work profile widgets are allowed by default. This means that if the
 *        policy does not specify work_profile_widgets as
 *        WORK_PROFILE_WIDGETS_DISALLOWED for the application, it will be able
 *        to add widgets to the home screen. (Value:
 *        "WORK_PROFILE_WIDGETS_DEFAULT_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_WorkProfileWidgetsDefault_WorkProfileWidgetsDefaultDisallowed
 *        Work profile widgets are disallowed by default. This means that if the
 *        policy does not specify work_profile_widgets as
 *        WORK_PROFILE_WIDGETS_ALLOWED for the application, it will be unable to
 *        add widgets to the home screen. (Value:
 *        "WORK_PROFILE_WIDGETS_DEFAULT_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_WorkProfileWidgetsDefault_WorkProfileWidgetsDefaultUnspecified
 *        Unspecified. Defaults to WORK_PROFILE_WIDGETS_DEFAULT_DISALLOWED.
 *        (Value: "WORK_PROFILE_WIDGETS_DEFAULT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *workProfileWidgetsDefault;

@end


/**
 *  Validates whether Androids built-in cryptographic library (BoringSSL) is
 *  valid. Should always succeed on device boot, if it fails, the device should
 *  be considered untrusted.
 */
@interface GTLRAndroidManagement_CryptoSelfTestCompletedEvent : GTLRObject

/**
 *  Whether the test succeeded.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  Represents a whole or partial calendar date, such as a birthday. The time of
 *  day and time zone are either specified elsewhere or are insignificant. The
 *  date is relative to the Gregorian Calendar. This can represent one of the
 *  following: A full date, with non-zero year, month, and day values. A month
 *  and day, with a zero year (for example, an anniversary). A year on its own,
 *  with a zero month and a zero day. A year and month, with a zero day (for
 *  example, a credit card expiration date).Related types: google.type.TimeOfDay
 *  google.type.DateTime google.protobuf.Timestamp
 */
@interface GTLRAndroidManagement_Date : GTLRObject

/**
 *  Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
 *  to specify a year by itself or a year and month where the day isn't
 *  significant.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *day;

/**
 *  Month of a year. Must be from 1 to 12, or 0 to specify a year without a
 *  month and day.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *month;

/**
 *  Year of the date. Must be from 1 to 9999, or 0 to specify a date without a
 *  year.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *year;

@end


/**
 *  A device owned by an enterprise. Unless otherwise noted, all fields are
 *  read-only and can't be modified by enterprises.devices.patch.
 */
@interface GTLRAndroidManagement_Device : GTLRObject

/**
 *  The API level of the Android platform version running on the device.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *apiLevel;

/**
 *  Reports for apps installed on the device. This information is only available
 *  when application_reports_enabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationReport *> *applicationReports;

/**
 *  The password requirements currently applied to the device. The applied
 *  requirements may be slightly different from those specified in
 *  passwordPolicies in some cases. fieldPath is set based on passwordPolicies.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PasswordRequirements *> *appliedPasswordPolicies;

/** The name of the policy currently applied to the device. */
@property(nonatomic, copy, nullable) NSString *appliedPolicyName;

/**
 *  The version of the policy currently applied to the device.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appliedPolicyVersion;

/**
 *  The state currently applied to the device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Active The device is
 *        active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_DeactivatedByDeviceFinance
 *        This is a financed device that has been "locked" by the financing
 *        agent. This means certain policy settings have been applied which
 *        limit device functionality until the device has been "unlocked" by the
 *        financing agent. The device will continue to apply policy settings
 *        excluding those overridden by the financing agent. When the device is
 *        "locked", the state is reported in appliedState as
 *        DEACTIVATED_BY_DEVICE_FINANCE. (Value:
 *        "DEACTIVATED_BY_DEVICE_FINANCE")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Deleted The device was
 *        deleted. This state is never returned by an API call, but is used in
 *        the final status report when the device acknowledges the deletion. If
 *        the device is deleted via the API call, this state is published to
 *        Pub/Sub. If the user deletes the work profile or resets the device,
 *        the device state will remain unknown to the server. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified
 *        This value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Lost The device is
 *        lost. This state is only possible on organization-owned devices.
 *        (Value: "LOST")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_PreparingForMigration
 *        The device is preparing for migrating to Android Management API. No
 *        further action is needed for the migration to continue. (Value:
 *        "PREPARING_FOR_MIGRATION")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Provisioning The device
 *        is being provisioned. Newly enrolled devices are in this state until
 *        they have a policy applied. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *appliedState;

/**
 *  Information about Common Criteria Modesecurity standards defined in the
 *  Common Criteria for Information Technology Security Evaluation
 *  (https://www.commoncriteriaportal.org/) (CC).This information is only
 *  available if statusReportingSettings.commonCriteriaModeEnabled is true in
 *  the device's policy the device is company-owned.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CommonCriteriaModeInfo *commonCriteriaModeInfo;

/**
 *  Device settings information. This information is only available if
 *  deviceSettingsEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DeviceSettings *deviceSettings;

/**
 *  If the device state is DISABLED, an optional message that is displayed on
 *  the device indicating the reason the device is disabled. This field can be
 *  modified by a patch request.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *disabledReason;

/**
 *  Detailed information about displays on the device. This information is only
 *  available if displayInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Display *> *displays;

/**
 *  Output only. Information related to whether this device was migrated from
 *  being managed by another Device Policy Controller (DPC).
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DpcMigrationInfo *dpcMigrationInfo;

/** The time of device enrollment. */
@property(nonatomic, strong, nullable) GTLRDateTime *enrollmentTime;

/**
 *  If the device was enrolled with an enrollment token with additional data
 *  provided, this field contains that data.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenData;

/**
 *  If the device was enrolled with an enrollment token, this field contains the
 *  name of the token.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenName;

/** Detailed information about the device hardware. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_HardwareInfo *hardwareInfo;

/**
 *  Hardware status samples in chronological order. This information is only
 *  available if hardwareStatusEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_HardwareStatus *> *hardwareStatusSamples;

/** Deprecated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicyComplianceReportTime GTLR_DEPRECATED;

/** The last time the device fetched its policy. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicySyncTime;

/** The last time the device sent a status report. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastStatusReportTime;

/**
 *  The type of management mode Android Device Policy takes on the device. This
 *  influences which policy settings are supported.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_DeviceOwner Device
 *        owner. Android Device Policy has full control over the device. (Value:
 *        "DEVICE_OWNER")
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_ManagementModeUnspecified
 *        This value is disallowed. (Value: "MANAGEMENT_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_ProfileOwner Profile
 *        owner. Android Device Policy has control over a managed profile on the
 *        device. (Value: "PROFILE_OWNER")
 */
@property(nonatomic, copy, nullable) NSString *managementMode;

/**
 *  Events related to memory and storage measurements in chronological order.
 *  This information is only available if memoryInfoEnabled is true in the
 *  device's policy.Events are retained for a certain period of time and old
 *  events are deleted.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_MemoryEvent *> *memoryEvents;

/**
 *  Memory information: contains information about device memory and storage.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MemoryInfo *memoryInfo;

/**
 *  The name of the device in the form
 *  enterprises/{enterpriseId}/devices/{deviceId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Device network information. This information is only available if
 *  networkInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NetworkInfo *networkInfo;

/** Details about policy settings that the device is not compliant with. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_NonComplianceDetail *> *nonComplianceDetails;

/**
 *  Ownership of the managed device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_Ownership_CompanyOwned Device is
 *        company-owned. (Value: "COMPANY_OWNED")
 *    @arg @c kGTLRAndroidManagement_Device_Ownership_OwnershipUnspecified
 *        Ownership is unspecified. (Value: "OWNERSHIP_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_Ownership_PersonallyOwned Device is
 *        personally-owned. (Value: "PERSONALLY_OWNED")
 */
@property(nonatomic, copy, nullable) NSString *ownership;

/**
 *  Whether the device is compliant with its policy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *policyCompliant;

/**
 *  The name of the policy applied to the device, in the form
 *  enterprises/{enterpriseId}/policies/{policyId}. If not specified, the
 *  policy_name for the device's user is applied. This field can be modified by
 *  a patch request. You can specify only the policyId when calling
 *  enterprises.devices.patch, as long as the policyId doesnt contain any
 *  slashes. The rest of the policy name is inferred.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  Power management events on the device in chronological order. This
 *  information is only available if powerManagementEventsEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PowerManagementEvent *> *powerManagementEvents;

/**
 *  If the same physical device has been enrolled multiple times, this field
 *  contains its previous device names. The serial number is used as the unique
 *  identifier to determine if the same physical device has enrolled previously.
 *  The names are in chronological order.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *previousDeviceNames;

/** Device's security posture value that reflects how secure the device is. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SecurityPosture *securityPosture;

/**
 *  Detailed information about the device software. This information is only
 *  available if softwareInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SoftwareInfo *softwareInfo;

/**
 *  The state to be applied to the device. This field can be modified by a patch
 *  request. Note that when calling enterprises.devices.patch, ACTIVE and
 *  DISABLED are the only allowable values. To enter the device into a DELETED
 *  state, call enterprises.devices.delete.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_State_Active The device is active.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_State_DeactivatedByDeviceFinance
 *        This is a financed device that has been "locked" by the financing
 *        agent. This means certain policy settings have been applied which
 *        limit device functionality until the device has been "unlocked" by the
 *        financing agent. The device will continue to apply policy settings
 *        excluding those overridden by the financing agent. When the device is
 *        "locked", the state is reported in appliedState as
 *        DEACTIVATED_BY_DEVICE_FINANCE. (Value:
 *        "DEACTIVATED_BY_DEVICE_FINANCE")
 *    @arg @c kGTLRAndroidManagement_Device_State_Deleted The device was
 *        deleted. This state is never returned by an API call, but is used in
 *        the final status report when the device acknowledges the deletion. If
 *        the device is deleted via the API call, this state is published to
 *        Pub/Sub. If the user deletes the work profile or resets the device,
 *        the device state will remain unknown to the server. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_State_DeviceStateUnspecified This
 *        value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Lost The device is lost. This
 *        state is only possible on organization-owned devices. (Value: "LOST")
 *    @arg @c kGTLRAndroidManagement_Device_State_PreparingForMigration The
 *        device is preparing for migrating to Android Management API. No
 *        further action is needed for the migration to continue. (Value:
 *        "PREPARING_FOR_MIGRATION")
 *    @arg @c kGTLRAndroidManagement_Device_State_Provisioning The device is
 *        being provisioned. Newly enrolled devices are in this state until they
 *        have a policy applied. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Map of selected system properties name and value related to the device. This
 *  information is only available if systemPropertiesEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Device_SystemProperties *systemProperties;

/** The user who owns the device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_User *user;

/**
 *  The resource name of the user that owns this device in the form
 *  enterprises/{enterpriseId}/users/{userId}.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Map of selected system properties name and value related to the device. This
 *  information is only available if systemPropertiesEnabled is true in the
 *  device's policy.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_Device_SystemProperties : GTLRObject
@end


/**
 *  Covers controls for device connectivity such as Wi-Fi, USB data access,
 *  keyboard/mouse connections, and more.
 */
@interface GTLRAndroidManagement_DeviceConnectivityManagement : GTLRObject

/**
 *  Controls Wi-Fi configuring privileges. Based on the option set, user will
 *  have either full or limited or no control in configuring Wi-Fi networks.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_AllowConfiguringWifi
 *        The user is allowed to configure Wi-Fi. wifiConfigDisabled is ignored.
 *        (Value: "ALLOW_CONFIGURING_WIFI")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_ConfigureWifiUnspecified
 *        Unspecified. Defaults to ALLOW_CONFIGURING_WIFI unless
 *        wifiConfigDisabled is set to true. If wifiConfigDisabled is set to
 *        true, this is equivalent to DISALLOW_CONFIGURING_WIFI. (Value:
 *        "CONFIGURE_WIFI_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_DisallowAddWifiConfig
 *        Adding new Wi-Fi configurations is disallowed. The user is only able
 *        to switch between already configured networks. Supported on Android 13
 *        and above, on fully managed devices and work profiles on company-owned
 *        devices. If the setting is not supported, ALLOW_CONFIGURING_WIFI is
 *        set. A nonComplianceDetail with API_LEVEL is reported if the Android
 *        version is less than 13. wifiConfigDisabled is ignored. (Value:
 *        "DISALLOW_ADD_WIFI_CONFIG")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_ConfigureWifi_DisallowConfiguringWifi
 *        Disallows configuring Wi-Fi networks. The setting wifiConfigDisabled
 *        is ignored when this value is set. Supported on fully managed devices
 *        and work profile on company-owned devices, on all supported API
 *        levels. For fully managed devices, setting this removes all configured
 *        networks and retains only the networks configured using
 *        openNetworkConfiguration policy. For work profiles on company-owned
 *        devices, existing configured networks are not affected and the user is
 *        not allowed to add, remove, or modify Wi-Fi networks. Note: If a
 *        network connection can't be made at boot time and configuring Wi-Fi is
 *        disabled then network escape hatch will be shown in order to refresh
 *        the device policy (see networkEscapeHatchEnabled). (Value:
 *        "DISALLOW_CONFIGURING_WIFI")
 */
@property(nonatomic, copy, nullable) NSString *configureWifi;

/**
 *  Controls tethering settings. Based on the value set, the user is partially
 *  or fully disallowed from using different forms of tethering.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_AllowAllTethering
 *        Allows configuration and use of all forms of tethering.
 *        tetheringConfigDisabled is ignored. (Value: "ALLOW_ALL_TETHERING")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_DisallowAllTethering
 *        Disallows all forms of tethering. Supported on fully managed devices
 *        and work profile on company-owned devices, on all supported android
 *        versions. The setting tetheringConfigDisabled is ignored. (Value:
 *        "DISALLOW_ALL_TETHERING")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_DisallowWifiTethering
 *        Disallows the user from using Wi-Fi tethering. Supported on company
 *        owned devices running Android 13 and above. If the setting is not
 *        supported, ALLOW_ALL_TETHERING will be set. A nonComplianceDetail with
 *        API_LEVEL is reported if the Android version is less than 13.
 *        tetheringConfigDisabled is ignored. (Value: "DISALLOW_WIFI_TETHERING")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_TetheringSettings_TetheringSettingsUnspecified
 *        Unspecified. Defaults to ALLOW_ALL_TETHERING unless
 *        tetheringConfigDisabled is set to true. If tetheringConfigDisabled is
 *        set to true, this is equivalent to DISALLOW_ALL_TETHERING. (Value:
 *        "TETHERING_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *tetheringSettings;

/**
 *  Controls what files and/or data can be transferred via USB. Supported only
 *  on company-owned devices.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_AllowUsbDataTransfer
 *        All types of USB data transfers are allowed. usbFileTransferDisabled
 *        is ignored. (Value: "ALLOW_USB_DATA_TRANSFER")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_DisallowUsbDataTransfer
 *        When set, all types of USB data transfers are prohibited. Supported
 *        for devices running Android 12 or above with USB HAL 1.3 or above. If
 *        the setting is not supported, DISALLOW_USB_FILE_TRANSFER will be set.
 *        A nonComplianceDetail with API_LEVEL is reported if the Android
 *        version is less than 12. A nonComplianceDetail with
 *        DEVICE_INCOMPATIBLE is reported if the device does not have USB HAL
 *        1.3 or above. usbFileTransferDisabled is ignored. (Value:
 *        "DISALLOW_USB_DATA_TRANSFER")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_DisallowUsbFileTransfer
 *        Transferring files over USB is disallowed. Other types of USB data
 *        connections, such as mouse and keyboard connection, are allowed.
 *        usbFileTransferDisabled is ignored. (Value:
 *        "DISALLOW_USB_FILE_TRANSFER")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_UsbDataAccess_UsbDataAccessUnspecified
 *        Unspecified. Defaults to DISALLOW_USB_FILE_TRANSFER. (Value:
 *        "USB_DATA_ACCESS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *usbDataAccess;

/**
 *  Controls configuring and using Wi-Fi direct settings. Supported on
 *  company-owned devices running Android 13 and above.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_WifiDirectSettings_AllowWifiDirect
 *        The user is allowed to use Wi-Fi direct. (Value: "ALLOW_WIFI_DIRECT")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_WifiDirectSettings_DisallowWifiDirect
 *        The user is not allowed to use Wi-Fi direct. A nonComplianceDetail
 *        with API_LEVEL is reported if the Android version is less than 13.
 *        (Value: "DISALLOW_WIFI_DIRECT")
 *    @arg @c kGTLRAndroidManagement_DeviceConnectivityManagement_WifiDirectSettings_WifiDirectSettingsUnspecified
 *        Unspecified. Defaults to ALLOW_WIFI_DIRECT (Value:
 *        "WIFI_DIRECT_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *wifiDirectSettings;

/**
 *  Restrictions on which Wi-Fi SSIDs the device can connect to. Note that this
 *  does not affect which networks can be configured on the device. Supported on
 *  company-owned devices running Android 13 and above.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_WifiSsidPolicy *wifiSsidPolicy;

@end


/**
 *  Controls for device radio settings.
 */
@interface GTLRAndroidManagement_DeviceRadioState : GTLRObject

/**
 *  Controls whether airplane mode can be toggled by the user or not.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_AirplaneModeState_AirplaneModeDisabled
 *        Airplane mode is disabled. The user is not allowed to toggle airplane
 *        mode on. A nonComplianceDetail with API_LEVEL is reported if the
 *        Android version is less than 9. (Value: "AIRPLANE_MODE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_AirplaneModeState_AirplaneModeStateUnspecified
 *        Unspecified. Defaults to AIRPLANE_MODE_USER_CHOICE. (Value:
 *        "AIRPLANE_MODE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_AirplaneModeState_AirplaneModeUserChoice
 *        The user is allowed to toggle airplane mode on or off. (Value:
 *        "AIRPLANE_MODE_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *airplaneModeState;

/**
 *  Controls whether cellular 2G setting can be toggled by the user or not.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_CellularTwoGState_CellularTwoGDisabled
 *        Cellular 2G is disabled. The user is not allowed to toggle cellular 2G
 *        on via settings. A nonComplianceDetail with API_LEVEL is reported if
 *        the Android version is less than 14. (Value:
 *        "CELLULAR_TWO_G_DISABLED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_CellularTwoGState_CellularTwoGStateUnspecified
 *        Unspecified. Defaults to CELLULAR_TWO_G_USER_CHOICE. (Value:
 *        "CELLULAR_TWO_G_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_CellularTwoGState_CellularTwoGUserChoice
 *        The user is allowed to toggle cellular 2G on or off. (Value:
 *        "CELLULAR_TWO_G_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *cellularTwoGState;

/**
 *  The minimum required security level of Wi-Fi networks that the device can
 *  connect to.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_EnterpriseBit192NetworkSecurity
 *        A 192-bit enterprise network is the minimum required security level.
 *        The device will not be able to connect to Wi-Fi network below this
 *        security level. This is stricter than ENTERPRISE_NETWORK_SECURITY. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 13. (Value: "ENTERPRISE_BIT192_NETWORK_SECURITY")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_EnterpriseNetworkSecurity
 *        An enterprise EAP network is the minimum required security level. The
 *        device will not be able to connect to Wi-Fi network below this
 *        security level. This is stricter than PERSONAL_NETWORK_SECURITY. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 13. (Value: "ENTERPRISE_NETWORK_SECURITY")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_MinimumWifiSecurityLevelUnspecified
 *        Defaults to OPEN_NETWORK_SECURITY, which means the device will be able
 *        to connect to all types of Wi-Fi networks. (Value:
 *        "MINIMUM_WIFI_SECURITY_LEVEL_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_OpenNetworkSecurity
 *        The device will be able to connect to all types of Wi-Fi networks.
 *        (Value: "OPEN_NETWORK_SECURITY")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_MinimumWifiSecurityLevel_PersonalNetworkSecurity
 *        A personal network such as WEP, WPA2-PSK is the minimum required
 *        security. The device will not be able to connect to open wifi
 *        networks. This is stricter than OPEN_NETWORK_SECURITY. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 13. (Value: "PERSONAL_NETWORK_SECURITY")
 */
@property(nonatomic, copy, nullable) NSString *minimumWifiSecurityLevel;

/**
 *  Controls the state of the ultra wideband setting and whether the user can
 *  toggle it on or off.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_UltraWidebandState_UltraWidebandDisabled
 *        Ultra wideband is disabled. The user is not allowed to toggle ultra
 *        wideband on via settings. A nonComplianceDetail with API_LEVEL is
 *        reported if the Android version is less than 14. (Value:
 *        "ULTRA_WIDEBAND_DISABLED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_UltraWidebandState_UltraWidebandStateUnspecified
 *        Unspecified. Defaults to ULTRA_WIDEBAND_USER_CHOICE. (Value:
 *        "ULTRA_WIDEBAND_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_UltraWidebandState_UltraWidebandUserChoice
 *        The user is allowed to toggle ultra wideband on or off. (Value:
 *        "ULTRA_WIDEBAND_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *ultraWidebandState;

/**
 *  Controls current state of Wi-Fi and if user can change its state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiDisabled
 *        Wi-Fi is off and the user is not allowed to turn it on. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 13. (Value: "WIFI_DISABLED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiEnabled
 *        Wi-Fi is on and the user is not allowed to turn it off. A
 *        nonComplianceDetail with API_LEVEL is reported if the Android version
 *        is less than 13. (Value: "WIFI_ENABLED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiStateUnspecified
 *        Unspecified. Defaults to WIFI_STATE_USER_CHOICE (Value:
 *        "WIFI_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceRadioState_WifiState_WifiStateUserChoice
 *        User is allowed to enable/disable Wi-Fi. (Value:
 *        "WIFI_STATE_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *wifiState;

@end


/**
 *  Information about security related device settings on device.
 */
@interface GTLRAndroidManagement_DeviceSettings : GTLRObject

/**
 *  Whether ADB (https://developer.android.com/studio/command-line/adb.html) is
 *  enabled on the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adbEnabled;

/**
 *  Whether developer mode is enabled on the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *developmentSettingsEnabled;

/**
 *  Encryption status from DevicePolicyManager.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Activating
 *        Encryption is not currently active, but is currently being activated.
 *        (Value: "ACTIVATING")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Active
 *        Encryption is active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActiveDefaultKey
 *        Encryption is active, but an encryption key is not set by the user.
 *        (Value: "ACTIVE_DEFAULT_KEY")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActivePerUser
 *        Encryption is active, and the encryption key is tied to the user
 *        profile. (Value: "ACTIVE_PER_USER")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_EncryptionStatusUnspecified
 *        Unspecified. No device should have this type. (Value:
 *        "ENCRYPTION_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Inactive
 *        Encryption is supported by the device, but is not currently active.
 *        (Value: "INACTIVE")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Unsupported
 *        Encryption is not supported by the device. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionStatus;

/**
 *  Whether the device is secured with PIN/password.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isDeviceSecure;

/**
 *  Whether the storage encryption is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isEncrypted;

/**
 *  Whether installing apps from unknown sources is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unknownSourcesEnabled;

/**
 *  Whether Google Play Protect verification
 *  (https://support.google.com/accounts/answer/2812853) is enforced on the
 *  device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *verifyAppsEnabled;

@end


/**
 *  Device display information.
 */
@interface GTLRAndroidManagement_Display : GTLRObject

/**
 *  Display density expressed as dots-per-inch.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *density;

/**
 *  Unique display id.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayId;

/**
 *  Display height in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *height;

/** Name of the display. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Refresh rate of the display in frames per second.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *refreshRate;

/**
 *  State of the display.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Display_State_DisplayStateUnspecified This
 *        value is disallowed. (Value: "DISPLAY_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Display_State_Doze Display is dozing in a
 *        low power state (Value: "DOZE")
 *    @arg @c kGTLRAndroidManagement_Display_State_Off Display is off. (Value:
 *        "OFF")
 *    @arg @c kGTLRAndroidManagement_Display_State_On Display is on. (Value:
 *        "ON")
 *    @arg @c kGTLRAndroidManagement_Display_State_Suspended Display is dozing
 *        in a suspended low power state. (Value: "SUSPENDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Display width in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  Controls for the display settings.
 */
@interface GTLRAndroidManagement_DisplaySettings : GTLRObject

/** Optional. Controls the screen brightness settings. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ScreenBrightnessSettings *screenBrightnessSettings;

/** Optional. Controls the screen timeout settings. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ScreenTimeoutSettings *screenTimeoutSettings;

@end


/**
 *  A DNS lookup event was initiated through the standard network stack.
 */
@interface GTLRAndroidManagement_DnsEvent : GTLRObject

/** The hostname that was looked up. */
@property(nonatomic, copy, nullable) NSString *hostname;

/**
 *  The (possibly truncated) list of the IP addresses returned for DNS lookup
 *  (max 10 IPv4 or IPv6 addresses).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ipAddresses;

/** The package name of the UID that performed the DNS lookup. */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The number of IP addresses returned from the DNS lookup event. May be higher
 *  than the amount of ip_addresses if there were too many addresses to log.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalIpAddressesReturned;

@end


/**
 *  Information related to whether this device was migrated from being managed
 *  by another Device Policy Controller (DPC).
 */
@interface GTLRAndroidManagement_DpcMigrationInfo : GTLRObject

/**
 *  Output only. If this device was migrated from another DPC, the
 *  additionalData field of the migration token is populated here.
 */
@property(nonatomic, copy, nullable) NSString *additionalData;

/**
 *  Output only. If this device was migrated from another DPC, this is its
 *  package name. Not populated otherwise.
 */
@property(nonatomic, copy, nullable) NSString *previousDpc;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRAndroidManagement_Empty : GTLRObject
@end


/**
 *  Represents that the device has completed enrollment. User should be in the
 *  launcher at this point, device at this point will be compliant and all setup
 *  steps have been completed. Intentionally empty.
 */
@interface GTLRAndroidManagement_EnrollmentCompleteEvent : GTLRObject
@end


/**
 *  An enrollment token.
 */
@interface GTLRAndroidManagement_EnrollmentToken : GTLRObject

/**
 *  Optional, arbitrary data associated with the enrollment token. This could
 *  contain, for example, the ID of an org unit the device is assigned to after
 *  enrollment. After a device enrolls with the token, this data will be exposed
 *  in the enrollment_token_data field of the Device resource. The data must be
 *  1024 characters or less; otherwise, the creation request will fail.
 */
@property(nonatomic, copy, nullable) NSString *additionalData;

/**
 *  Controls whether personal usage is allowed on a device provisioned with this
 *  enrollment token.For company-owned devices: Enabling personal usage allows
 *  the user to set up a work profile on the device. Disabling personal usage
 *  requires the user provision the device as a fully managed device.For
 *  personally-owned devices: Enabling personal usage allows the user to set up
 *  a work profile on the device. Disabling personal usage will prevent the
 *  device from provisioning. Personal usage cannot be disabled on
 *  personally-owned device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_AllowPersonalUsageUnspecified
 *        Personal usage restriction is not specified (Value:
 *        "ALLOW_PERSONAL_USAGE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageAllowed
 *        Personal usage is allowed (Value: "PERSONAL_USAGE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageDisallowed
 *        Personal usage is disallowed (Value: "PERSONAL_USAGE_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageDisallowedUserless
 *        Device is not associated with a single user, and thus both personal
 *        usage and corporate identity authentication are not expected. (Value:
 *        "PERSONAL_USAGE_DISALLOWED_USERLESS")
 */
@property(nonatomic, copy, nullable) NSString *allowPersonalUsage;

/**
 *  The length of time the enrollment token is valid, ranging from 1 minute to
 *  Durations.MAX_VALUE
 *  (https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/Durations.html#MAX_VALUE),
 *  approximately 10,000 years. If not specified, the default duration is 1
 *  hour. Please note that if requested duration causes the resulting
 *  expiration_timestamp to exceed Timestamps.MAX_VALUE
 *  (https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/Timestamps.html#MAX_VALUE),
 *  then expiration_timestamp is coerced to Timestamps.MAX_VALUE.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  The expiration time of the token. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTimestamp;

/**
 *  The name of the enrollment token, which is generated by the server during
 *  creation, in the form
 *  enterprises/{enterpriseId}/enrollmentTokens/{enrollmentTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the enrollment token is for one time use only. If the flag is set to
 *  true, only one device can use it for registration.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneTimeOnly;

/**
 *  The name of the policy initially applied to the enrolled device, in the form
 *  enterprises/{enterpriseId}/policies/{policyId}. If not specified, the
 *  policy_name for the devices user is applied. If user_name is also not
 *  specified, enterprises/{enterpriseId}/policies/default is applied by
 *  default. When updating this field, you can specify only the policyId as long
 *  as the policyId doesnt contain any slashes. The rest of the policy name
 *  will be inferred.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/** This field is deprecated and the value is ignored. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_User *user GTLR_DEPRECATED;

/**
 *  The token value that's passed to the device and authorizes the device to
 *  enroll. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  The configuration applied to an enterprise.
 */
@interface GTLRAndroidManagement_Enterprise : GTLRObject

/**
 *  Deprecated and unused.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appAutoApprovalEnabled GTLR_DEPRECATED;

/** The enterprise contact info of an EMM-managed enterprise. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ContactInfo *contactInfo;

/** The types of Google Pub/Sub notifications enabled for the enterprise. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledNotificationTypes;

/**
 *  The name of the enterprise displayed to users. This field has a maximum
 *  length of 100 characters.
 */
@property(nonatomic, copy, nullable) NSString *enterpriseDisplayName;

/** Settings for Google-provided user authentication. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_GoogleAuthenticationSettings *googleAuthenticationSettings;

/**
 *  An image displayed as a logo during device provisioning. Supported types
 *  are: image/bmp, image/gif, image/x-ico, image/jpeg, image/png, image/webp,
 *  image/vnd.wap.wbmp, image/x-adobe-dng.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ExternalData *logo;

/**
 *  The name of the enterprise which is generated by the server during creation,
 *  in the form enterprises/{enterpriseId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A color in RGB format that indicates the predominant color to display in the
 *  device management app UI. The color components are stored as follows: (red
 *  << 16) | (green << 8) | blue, where the value of each component is between 0
 *  and 255, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *primaryColor;

/**
 *  The topic which Pub/Sub notifications are published to, in the form
 *  projects/{project}/topics/{topic}. This field is only required if Pub/Sub
 *  notifications are enabled.
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

/** Sign-in details of the enterprise. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_SigninDetail *> *signinDetails;

/**
 *  Terms and conditions that must be accepted when provisioning a device for
 *  this enterprise. A page of terms is generated for each value in this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_TermsAndConditions *> *termsAndConditions;

@end


/**
 *  Configuration to enable an app as an extension app, with the capability of
 *  interacting with Android Device Policy offline. For Android versions 13 and
 *  above, extension apps are exempt from battery restrictions so will not be
 *  placed into the restricted App Standby Bucket
 *  (https://developer.android.com/topic/performance/appstandby#restricted-bucket).
 *  Extensions apps are also protected against users clearing their data or
 *  force-closing the application, although admins can continue to use the clear
 *  app data command on extension apps if needed for Android 13 and above.
 */
@interface GTLRAndroidManagement_ExtensionConfig : GTLRObject

/**
 *  Fully qualified class name of the receiver service class for Android Device
 *  Policy to notify the extension app of any local command status updates.
 */
@property(nonatomic, copy, nullable) NSString *notificationReceiver;

/**
 *  Hex-encoded SHA-256 hash of the signing certificate of the extension app.
 *  Only hexadecimal string representations of 64 characters are valid.If not
 *  specified, the signature for the corresponding package name is obtained from
 *  the Play Store instead.If this list is empty, the signature of the extension
 *  app on the device must match the signature obtained from the Play Store for
 *  the app to be able to communicate with Android Device Policy.If this list is
 *  not empty, the signature of the extension app on the device must match one
 *  of the entries in this list for the app to be able to communicate with
 *  Android Device Policy.In production use cases, it is recommended to leave
 *  this empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingKeyFingerprintsSha256;

@end


/**
 *  Data hosted at an external location. The data is to be downloaded by Android
 *  Device Policy and verified against the hash.
 */
@interface GTLRAndroidManagement_ExternalData : GTLRObject

/**
 *  The base-64 encoded SHA-256 hash of the content hosted at url. If the
 *  content doesn't match this hash, Android Device Policy won't use the data.
 */
@property(nonatomic, copy, nullable) NSString *sha256Hash;

/**
 *  The absolute URL to the data, which must use either the http or https
 *  scheme. Android Device Policy doesn't provide any credentials in the GET
 *  request, so the URL must be publicly accessible. Including a long, random
 *  component in the URL may be used to prevent attackers from discovering the
 *  URL.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  A file was downloaded from the device.
 */
@interface GTLRAndroidManagement_FilePulledEvent : GTLRObject

/** The path of the file being pulled. */
@property(nonatomic, copy, nullable) NSString *filePath;

@end


/**
 *  A file was uploaded onto the device.
 */
@interface GTLRAndroidManagement_FilePushedEvent : GTLRObject

/** The path of the file being pushed. */
@property(nonatomic, copy, nullable) NSString *filePath;

@end


/**
 *  A system freeze period. When a devices clock is within the freeze period,
 *  all incoming system updates (including security patches) are blocked and
 *  wont be installed.When the device is outside any set freeze periods, the
 *  normal policy behavior (automatic, windowed, or postponed) applies.Leap
 *  years are ignored in freeze period calculations, in particular: If Feb. 29th
 *  is set as the start or end date of a freeze period, the freeze period will
 *  start or end on Feb. 28th instead. When a devices system clock reads Feb.
 *  29th, its treated as Feb. 28th. When calculating the number of days in a
 *  freeze period or the time between two freeze periods, Feb. 29th is ignored
 *  and not counted as a day.Note: For Freeze Periods to take effect,
 *  SystemUpdateType cannot be specified as SYSTEM_UPDATE_TYPE_UNSPECIFIED,
 *  because freeze periods require a defined policy to be specified.
 */
@interface GTLRAndroidManagement_FreezePeriod : GTLRObject

/**
 *  The end date (inclusive) of the freeze period. Must be no later than 90 days
 *  from the start date. If the end date is earlier than the start date, the
 *  freeze period is considered wrapping year-end. Note: year must not be set.
 *  For example, {"month": 1,"date": 30}.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Date *endDate;

/**
 *  The start date (inclusive) of the freeze period. Note: year must not be set.
 *  For example, {"month": 1,"date": 30}.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Date *startDate;

@end


/**
 *  Contains settings for Google-provided user authentication.
 */
@interface GTLRAndroidManagement_GoogleAuthenticationSettings : GTLRObject

/**
 *  Output only. Whether users need to be authenticated by Google during the
 *  enrollment process. IT admin can specify if Google authentication is enabled
 *  for the enterprise for knowledge worker devices. This value can be set only
 *  via the Google Admin Console. Google authentication can be used with
 *  signin_url In the case where Google authentication is required and a
 *  signin_url is specified, Google authentication will be launched before
 *  signin_url.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_GoogleAuthenticationSettings_GoogleAuthenticationRequired_GoogleAuthenticationRequiredUnspecified
 *        This value is not used. (Value:
 *        "GOOGLE_AUTHENTICATION_REQUIRED_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_GoogleAuthenticationSettings_GoogleAuthenticationRequired_NotRequired
 *        Google authentication is not required. (Value: "NOT_REQUIRED")
 *    @arg @c kGTLRAndroidManagement_GoogleAuthenticationSettings_GoogleAuthenticationRequired_Required
 *        User is required to be successfully authenticated by Google. (Value:
 *        "REQUIRED")
 */
@property(nonatomic, copy, nullable) NSString *googleAuthenticationRequired;

@end


/**
 *  Information about device hardware. The fields related to temperature
 *  thresholds are only available if hardwareStatusEnabled is true in the
 *  device's policy.
 */
@interface GTLRAndroidManagement_HardwareInfo : GTLRObject

/**
 *  Battery shutdown temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryShutdownTemperatures;

/**
 *  Battery throttling temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryThrottlingTemperatures;

/** Brand of the device. For example, Google. */
@property(nonatomic, copy, nullable) NSString *brand;

/**
 *  CPU shutdown temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuShutdownTemperatures;

/**
 *  CPU throttling temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuThrottlingTemperatures;

/** Baseband version. For example, MDM9625_104662.22.05.34p. */
@property(nonatomic, copy, nullable) NSString *deviceBasebandVersion;

/**
 *  Output only. ID that uniquely identifies a personally-owned device in a
 *  particular organization. On the same physical device when enrolled with the
 *  same organization, this ID persists across setups and even factory resets.
 *  This ID is available on personally-owned devices with a work profile on
 *  devices running Android 12 and above.
 */
@property(nonatomic, copy, nullable) NSString *enterpriseSpecificId;

/**
 *  GPU shutdown temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuShutdownTemperatures;

/**
 *  GPU throttling temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuThrottlingTemperatures;

/** Name of the hardware. For example, Angler. */
@property(nonatomic, copy, nullable) NSString *hardware;

/** Manufacturer. For example, Motorola. */
@property(nonatomic, copy, nullable) NSString *manufacturer;

/** The model of the device. For example, Asus Nexus 7. */
@property(nonatomic, copy, nullable) NSString *model;

/** The device serial number. */
@property(nonatomic, copy, nullable) NSString *serialNumber;

/**
 *  Device skin shutdown temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinShutdownTemperatures;

/**
 *  Device skin throttling temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinThrottlingTemperatures;

@end


/**
 *  Hardware status. Temperatures may be compared to the temperature thresholds
 *  available in hardwareInfo to determine hardware health.
 */
@interface GTLRAndroidManagement_HardwareStatus : GTLRObject

/**
 *  Current battery temperatures in Celsius for each battery on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryTemperatures;

/**
 *  Current CPU temperatures in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuTemperatures;

/**
 *  CPU usages in percentage for each core available on the device. Usage is 0
 *  for each unplugged core. Empty array implies that CPU usage is not supported
 *  in the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuUsages;

/** The time the measurements were taken. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Fan speeds in RPM for each fan on the device. Empty array means that there
 *  are no fans or fan speed is not supported on the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *fanSpeeds;

/**
 *  Current GPU temperatures in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuTemperatures;

/**
 *  Current device skin temperatures in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinTemperatures;

@end


/**
 *  Amongst apps with InstallType set to: FORCE_INSTALLED PREINSTALLEDthis
 *  defines a set of restrictions for the app installation. At least one of the
 *  fields must be set. When multiple fields are set, then all the constraints
 *  need to be satisfied for the app to be installed.
 */
@interface GTLRAndroidManagement_InstallConstraint : GTLRObject

/**
 *  Optional. Charging constraint.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_ChargingConstraint_ChargingConstraintUnspecified
 *        Unspecified. Default to CHARGING_NOT_REQUIRED. (Value:
 *        "CHARGING_CONSTRAINT_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_ChargingConstraint_ChargingNotRequired
 *        Device doesn't have to be charging. (Value: "CHARGING_NOT_REQUIRED")
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_ChargingConstraint_InstallOnlyWhenCharging
 *        Device has to be charging. (Value: "INSTALL_ONLY_WHEN_CHARGING")
 */
@property(nonatomic, copy, nullable) NSString *chargingConstraint;

/**
 *  Optional. Device idle constraint.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_DeviceIdleConstraint_DeviceIdleConstraintUnspecified
 *        Unspecified. Default to DEVICE_IDLE_NOT_REQUIRED. (Value:
 *        "DEVICE_IDLE_CONSTRAINT_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_DeviceIdleConstraint_DeviceIdleNotRequired
 *        Device doesn't have to be idle, app can be installed while the user is
 *        interacting with the device. (Value: "DEVICE_IDLE_NOT_REQUIRED")
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_DeviceIdleConstraint_InstallOnlyWhenDeviceIdle
 *        Device has to be idle. (Value: "INSTALL_ONLY_WHEN_DEVICE_IDLE")
 */
@property(nonatomic, copy, nullable) NSString *deviceIdleConstraint;

/**
 *  Optional. Network type constraint.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_NetworkTypeConstraint_InstallOnAnyNetwork
 *        Any active networks (Wi-Fi, cellular, etc.). (Value:
 *        "INSTALL_ON_ANY_NETWORK")
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_NetworkTypeConstraint_InstallOnlyOnUnmeteredNetwork
 *        Any unmetered network (e.g. Wi-FI). (Value:
 *        "INSTALL_ONLY_ON_UNMETERED_NETWORK")
 *    @arg @c kGTLRAndroidManagement_InstallConstraint_NetworkTypeConstraint_NetworkTypeConstraintUnspecified
 *        Unspecified. Default to INSTALL_ON_ANY_NETWORK. (Value:
 *        "NETWORK_TYPE_CONSTRAINT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *networkTypeConstraint;

@end


/**
 *  Response on issuing a command. This is currently empty as a placeholder.
 */
@interface GTLRAndroidManagement_IssueCommandResponse : GTLRObject
@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is removed from the device either by the user or
 *  management. This is available device-wide on fully managed devices and
 *  within the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyDestructionEvent : GTLRObject

/**
 *  UID of the application which owns the key.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

/**
 *  Whether the operation was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  Keyed app state reported by the app.
 */
@interface GTLRAndroidManagement_KeyedAppState : GTLRObject

/** The creation time of the app state on the device. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optionally, a machine-readable value to be read by the EMM. For example,
 *  setting values that the admin can choose to query against in the EMM console
 *  (e.g. notify me if the battery_warning data < 10).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  The key for the app state. Acts as a point of reference for what the app is
 *  providing state for. For example, when providing managed configuration
 *  feedback, this key could be the managed configuration key.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** The time the app state was most recently updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdateTime;

/**
 *  Optionally, a free-form message string to explain the app state. If the
 *  state was triggered by a particular value (e.g. a managed configuration
 *  value), it should be included in the message.
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  The severity of the app state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KeyedAppState_Severity_Error Error severity
 *        level. This should only be set for genuine error conditions that a
 *        management organization needs to take action to fix. (Value: "ERROR")
 *    @arg @c kGTLRAndroidManagement_KeyedAppState_Severity_Info Information
 *        severity level. (Value: "INFO")
 *    @arg @c kGTLRAndroidManagement_KeyedAppState_Severity_SeverityUnspecified
 *        Unspecified severity level. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is installed on the device either by the user or
 *  management.This is available device-wide on fully managed devices and within
 *  the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyGeneratedEvent : GTLRObject

/**
 *  UID of the application which generated the key.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

/**
 *  Whether the operation was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  An attempt was made to unlock the device.
 */
@interface GTLRAndroidManagement_KeyguardDismissAuthAttemptEvent : GTLRObject

/**
 *  Whether a strong form of authentication (password, PIN, or pattern) was used
 *  to unlock device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strongAuthMethodUsed;

/**
 *  Whether the unlock attempt was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  The keyguard was dismissed. Intentionally empty.
 */
@interface GTLRAndroidManagement_KeyguardDismissedEvent : GTLRObject
@end


/**
 *  The device was locked either by user or timeout. Intentionally empty.
 */
@interface GTLRAndroidManagement_KeyguardSecuredEvent : GTLRObject
@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is imported on the device either by the user or
 *  management. This is available device-wide on fully managed devices and
 *  within the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyImportEvent : GTLRObject

/**
 *  UID of the application which imported the key
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

/**
 *  Whether the operation was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is determined to be corrupted due to storage
 *  corruption, hardware failure or some OS issue. This is available device-wide
 *  on fully managed devices and within the work profile on organization-owned
 *  devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyIntegrityViolationEvent : GTLRObject

/**
 *  UID of the application which owns the key
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

@end


/**
 *  Settings controlling the behavior of a device in kiosk mode. To enable kiosk
 *  mode, set kioskCustomLauncherEnabled to true or specify an app in the policy
 *  with installType KIOSK.
 */
@interface GTLRAndroidManagement_KioskCustomization : GTLRObject

/**
 *  Specifies whether the Settings app is allowed in kiosk mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_DeviceSettings_DeviceSettingsUnspecified
 *        Unspecified, defaults to SETTINGS_ACCESS_ALLOWED. (Value:
 *        "DEVICE_SETTINGS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessAllowed
 *        Access to the Settings app is allowed in kiosk mode. (Value:
 *        "SETTINGS_ACCESS_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessBlocked
 *        Access to the Settings app is not allowed in kiosk mode. (Value:
 *        "SETTINGS_ACCESS_BLOCKED")
 */
@property(nonatomic, copy, nullable) NSString *deviceSettings;

/**
 *  Sets the behavior of a device in kiosk mode when a user presses and holds
 *  (long-presses) the Power button.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonActionsUnspecified
 *        Unspecified, defaults to POWER_BUTTON_AVAILABLE. (Value:
 *        "POWER_BUTTON_ACTIONS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonAvailable
 *        The power menu (e.g. Power off, Restart) is shown when a user
 *        long-presses the Power button of a device in kiosk mode. (Value:
 *        "POWER_BUTTON_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonBlocked
 *        The power menu (e.g. Power off, Restart) is not shown when a user
 *        long-presses the Power button of a device in kiosk mode. Note: this
 *        may prevent users from turning off the device. (Value:
 *        "POWER_BUTTON_BLOCKED")
 */
@property(nonatomic, copy, nullable) NSString *powerButtonActions;

/**
 *  Specifies whether system info and notifications are disabled in kiosk mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoDisabled
 *        System info and notifications are disabled in kiosk mode. (Value:
 *        "NOTIFICATIONS_AND_SYSTEM_INFO_DISABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoEnabled
 *        System info and notifications are shown on the status bar in kiosk
 *        mode.Note: For this policy to take effect, the device's home button
 *        must be enabled using kioskCustomization.systemNavigation. (Value:
 *        "NOTIFICATIONS_AND_SYSTEM_INFO_ENABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_StatusBarUnspecified
 *        Unspecified, defaults to INFO_AND_NOTIFICATIONS_DISABLED. (Value:
 *        "STATUS_BAR_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_SystemInfoOnly
 *        Only system info is shown on the status bar. (Value:
 *        "SYSTEM_INFO_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *statusBar;

/**
 *  Specifies whether system error dialogs for crashed or unresponsive apps are
 *  blocked in kiosk mode. When blocked, the system will force-stop the app as
 *  if the user chooses the "close app" option on the UI.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsEnabled
 *        All system error dialogs such as crash and app not responding (ANR)
 *        are displayed. (Value: "ERROR_AND_WARNINGS_ENABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsMuted
 *        All system error dialogs, such as crash and app not responding (ANR)
 *        are blocked. When blocked, the system force-stops the app as if the
 *        user closes the app from the UI. (Value: "ERROR_AND_WARNINGS_MUTED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_SystemErrorWarningsUnspecified
 *        Unspecified, defaults to ERROR_AND_WARNINGS_MUTED. (Value:
 *        "SYSTEM_ERROR_WARNINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *systemErrorWarnings;

/**
 *  Specifies which navigation features are enabled (e.g. Home, Overview
 *  buttons) in kiosk mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_HomeButtonOnly
 *        Only the home button is enabled. (Value: "HOME_BUTTON_ONLY")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationDisabled
 *        The home and Overview buttons are not accessible. (Value:
 *        "NAVIGATION_DISABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationEnabled
 *        Home and overview buttons are enabled. (Value: "NAVIGATION_ENABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_SystemNavigationUnspecified
 *        Unspecified, defaults to NAVIGATION_DISABLED. (Value:
 *        "SYSTEM_NAVIGATION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *systemNavigation;

@end


/**
 *  An action to launch an app.
 */
@interface GTLRAndroidManagement_LaunchAppAction : GTLRObject

/** Package name of app to be launched */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  Response to a request to list devices for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "devices" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListDevicesResponse : GTLRCollectionObject

/**
 *  The list of devices.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Device *> *devices;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list enrollment tokens for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "enrollmentTokens" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRAndroidManagement_ListEnrollmentTokensResponse : GTLRCollectionObject

/**
 *  The list of enrollment tokens.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_EnrollmentToken *> *enrollmentTokens;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list enterprises.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "enterprises" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListEnterprisesResponse : GTLRCollectionObject

/**
 *  The list of enterprises.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Enterprise *> *enterprises;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list migration tokens for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "migrationTokens" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRAndroidManagement_ListMigrationTokensResponse : GTLRCollectionObject

/**
 *  The migration tokens from the specified enterprise.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_MigrationToken *> *migrationTokens;

/**
 *  A token, which can be sent as page_token to retrieve the next page. If this
 *  field is omitted, there are no subsequent pages.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Operation *> *operations;

@end


/**
 *  Response to a request to list policies for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "policies" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListPoliciesResponse : GTLRCollectionObject

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Policy *> *policies;

@end


/**
 *  Response to a request to list web apps for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "webApps" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListWebAppsResponse : GTLRCollectionObject

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of web apps.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_WebApp *> *webApps;

@end


/**
 *  The device location containing the latitude and longitude.
 */
@interface GTLRAndroidManagement_Location : GTLRObject

/**
 *  The latitude position of the location
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *latitude;

/**
 *  The longitude position of the location
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *longitude;

@end


/**
 *  The usageLog buffer on the device has reached 90% of its capacity, therefore
 *  older events may be dropped. Intentionally empty.
 */
@interface GTLRAndroidManagement_LogBufferSizeCriticalEvent : GTLRObject
@end


/**
 *  usageLog policy has been enabled. Intentionally empty.
 */
@interface GTLRAndroidManagement_LoggingStartedEvent : GTLRObject
@end


/**
 *  usageLog policy has been disabled. Intentionally empty.
 */
@interface GTLRAndroidManagement_LoggingStoppedEvent : GTLRObject
@end


/**
 *  A lost mode event containing the device location and battery level as a
 *  percentage.
 */
@interface GTLRAndroidManagement_LostModeLocationEvent : GTLRObject

/**
 *  The battery level as a number between 0 and 100 inclusive
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batteryLevel;

/** The device location */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Location *location;

@end


/**
 *  An event indicating an outgoing phone call has been made when a device is in
 *  lost mode. Intentionally empty.
 */
@interface GTLRAndroidManagement_LostModeOutgoingPhoneCallEvent : GTLRObject
@end


/**
 *  The managed configurations template for the app, saved from the managed
 *  configurations iframe.
 */
@interface GTLRAndroidManagement_ManagedConfigurationTemplate : GTLRObject

/**
 *  Optional, a map containing configuration variables defined for the
 *  configuration.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables *configurationVariables;

/** The ID of the managed configurations template. */
@property(nonatomic, copy, nullable) NSString *templateId;

@end


/**
 *  Optional, a map containing configuration variables defined for the
 *  configuration.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables : GTLRObject
@end


/**
 *  Managed property.
 */
@interface GTLRAndroidManagement_ManagedProperty : GTLRObject

/**
 *  The default value of the property. BUNDLE_ARRAY properties don't have a
 *  default value.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id defaultValue;

/**
 *  A longer description of the property, providing more detail of what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** For CHOICE or MULTISELECT properties, the list of possible entries. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedPropertyEntry *> *entries;

/**
 *  The unique key that the app uses to identify the property, e.g.
 *  "com.google.android.gm.fieldname".
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  For BUNDLE_ARRAY properties, the list of nested properties. A BUNDLE_ARRAY
 *  property is at most two levels deep.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *nestedProperties;

/** The name of the property. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  The type of the property.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Bool A property of
 *        boolean type. (Value: "BOOL")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Bundle A bundle of
 *        properties (Value: "BUNDLE")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_BundleArray An array
 *        of property bundles. (Value: "BUNDLE_ARRAY")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Choice A choice of one
 *        item from a set. (Value: "CHOICE")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Hidden A hidden
 *        restriction of string type (the default value can be used to pass
 *        along information that can't be modified, such as a version code).
 *        (Value: "HIDDEN")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Integer A property of
 *        integer type. (Value: "INTEGER")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified
 *        Not used. (Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Multiselect A choice
 *        of multiple items from a set. (Value: "MULTISELECT")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_String A property of
 *        string type. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  An entry of a managed property.
 */
@interface GTLRAndroidManagement_ManagedPropertyEntry : GTLRObject

/** The human-readable name of the value. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The machine-readable value of the entry, which should be used in the
 *  configuration. Not localized.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Removable media was mounted.
 */
@interface GTLRAndroidManagement_MediaMountEvent : GTLRObject

/** Mount point. */
@property(nonatomic, copy, nullable) NSString *mountPoint;

/**
 *  Volume label. Redacted to empty string on organization-owned managed profile
 *  devices.
 */
@property(nonatomic, copy, nullable) NSString *volumeLabel;

@end


/**
 *  Removable media was unmounted.
 */
@interface GTLRAndroidManagement_MediaUnmountEvent : GTLRObject

/** Mount point. */
@property(nonatomic, copy, nullable) NSString *mountPoint;

/**
 *  Volume label. Redacted to empty string on organization-owned managed profile
 *  devices.
 */
@property(nonatomic, copy, nullable) NSString *volumeLabel;

@end


/**
 *  An event related to memory and storage measurements.To distinguish between
 *  new and old events, we recommend using the createTime field.
 */
@interface GTLRAndroidManagement_MemoryEvent : GTLRObject

/**
 *  The number of free bytes in the medium, or for EXTERNAL_STORAGE_DETECTED,
 *  the total capacity in bytes of the storage medium.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *byteCount;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected
 *        A new external storage medium was detected. The reported byte count is
 *        the total capacity of the storage medium. (Value:
 *        "EXTERNAL_STORAGE_DETECTED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured
 *        Free space in an external storage medium was measured. (Value:
 *        "EXTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved
 *        An external storage medium was removed. The reported byte count is
 *        zero. (Value: "EXTERNAL_STORAGE_REMOVED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured
 *        Free space in internal storage was measured. (Value:
 *        "INTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "MEMORY_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured Free
 *        space in RAM was measured. (Value: "RAM_MEASURED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Information about device memory and storage.
 */
@interface GTLRAndroidManagement_MemoryInfo : GTLRObject

/**
 *  Total internal storage on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalInternalStorage;

/**
 *  Total RAM on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalRam;

@end


/**
 *  A token to initiate the migration of a device from being managed by a
 *  third-party DPC to being managed by Android Management API. A migration
 *  token is valid only for a single device. See the guide
 *  (https://developers.google.com/android/management/dpc-migration) for more
 *  details.
 */
@interface GTLRAndroidManagement_MigrationToken : GTLRObject

/**
 *  Immutable. Optional EMM-specified additional data. Once the device is
 *  migrated this will be populated in the migrationAdditionalData field of the
 *  Device resource. This must be at most 1024 characters.
 */
@property(nonatomic, copy, nullable) NSString *additionalData;

/** Output only. Time when this migration token was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. Once this migration token is used to migrate a device, the name
 *  of the resulting Device resource will be populated here, in the form
 *  enterprises/{enterprise}/devices/{device}.
 */
@property(nonatomic, copy, nullable) NSString *device;

/**
 *  Required. Immutable. The id of the device, as in the Play EMM API. This
 *  corresponds to the deviceId parameter in Play EMM API's Devices.get
 *  (https://developers.google.com/android/work/play/emm-api/v1/devices/get#parameters)
 *  call.
 */
@property(nonatomic, copy, nullable) NSString *deviceId;

/**
 *  Immutable. The time when this migration token expires. This can be at most
 *  seven days from the time of creation. The migration token is deleted seven
 *  days after it expires.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Required. Immutable. The management mode of the device or profile being
 *  migrated.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_MigrationToken_ManagementMode_FullyManaged
 *        A fully-managed device. Supported only on devices running Android 9
 *        and above. (Value: "FULLY_MANAGED")
 *    @arg @c kGTLRAndroidManagement_MigrationToken_ManagementMode_ManagementModeUnspecified
 *        This value must not be used. (Value: "MANAGEMENT_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_MigrationToken_ManagementMode_WorkProfileCompanyOwned
 *        A work profile on a company-owned device. Supported only on devices
 *        running Android 11 and above. (Value: "WORK_PROFILE_COMPANY_OWNED")
 *    @arg @c kGTLRAndroidManagement_MigrationToken_ManagementMode_WorkProfilePersonallyOwned
 *        A work profile on a personally owned device. Supported only on devices
 *        running Android 9 and above. (Value: "WORK_PROFILE_PERSONALLY_OWNED")
 */
@property(nonatomic, copy, nullable) NSString *managementMode;

/**
 *  Output only. The name of the migration token, which is generated by the
 *  server during creation, in the form
 *  enterprises/{enterprise}/migrationTokens/{migration_token}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Immutable. The name of the policy initially applied to the
 *  enrolled device, in the form enterprises/{enterprise}/policies/{policy}.
 */
@property(nonatomic, copy, nullable) NSString *policy;

/**
 *  Input only. The time that this migration token is valid for. This is
 *  input-only, and for returning a migration token the server will populate the
 *  expireTime field. This can be at most seven days. The default is seven days.
 */
@property(nonatomic, strong, nullable) GTLRDuration *ttl;

/**
 *  Required. Immutable. The user id of the Managed Google Play account on the
 *  device, as in the Play EMM API. This corresponds to the userId parameter in
 *  Play EMM API's Devices.get
 *  (https://developers.google.com/android/work/play/emm-api/v1/devices/get#parameters)
 *  call.
 */
@property(nonatomic, copy, nullable) NSString *userId;

/** Output only. The value of the migration token. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Device network info.
 */
@interface GTLRAndroidManagement_NetworkInfo : GTLRObject

/** IMEI number of the GSM device. For example, A1000031212. */
@property(nonatomic, copy, nullable) NSString *imei;

/** MEID number of the CDMA device. For example, A00000292788E1. */
@property(nonatomic, copy, nullable) NSString *meid;

/** Alphabetic name of current registered operator. For example, Vodafone. */
@property(nonatomic, copy, nullable) NSString *networkOperatorName GTLR_DEPRECATED;

/**
 *  Provides telephony information associated with each SIM card on the device.
 *  Only supported on fully managed devices starting from Android API level 23.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_TelephonyInfo *> *telephonyInfos;

/** Wi-Fi MAC address of the device. For example, 7c:11:11:11:11:11. */
@property(nonatomic, copy, nullable) NSString *wifiMacAddress;

@end


/**
 *  Provides detail about non-compliance with a policy setting.
 */
@interface GTLRAndroidManagement_NonComplianceDetail : GTLRObject

/**
 *  If the policy setting could not be applied, the current value of the setting
 *  on the device.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id currentValue;

/**
 *  For settings with nested fields, if a particular nested field is out of
 *  compliance, this specifies the full path to the offending field. The path is
 *  formatted in the same way the policy JSON field would be referenced in
 *  JavaScript, that is: 1) For object-typed fields, the field name is followed
 *  by a dot then by a subfield name. 2) For array-typed fields, the field name
 *  is followed by the array index enclosed in brackets. For example, to
 *  indicate a problem with the url field in the externalData field in the 3rd
 *  application, the path would be applications[2].externalData.url
 */
@property(nonatomic, copy, nullable) NSString *fieldPath;

/**
 *  If package_name is set and the non-compliance reason is APP_NOT_INSTALLED or
 *  APP_NOT_UPDATED, the detailed reason the app can't be installed or updated.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress
 *        The installation is still in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown
 *        An unknown condition is preventing the app from being installed. Some
 *        potential reasons are that the device doesn't have enough storage, the
 *        device network connection is unreliable, or the installation is taking
 *        longer than expected. The installation will be retried automatically.
 *        (Value: "INSTALLATION_FAILURE_REASON_UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified
 *        This value is disallowed. (Value:
 *        "INSTALLATION_FAILURE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InsufficientStorage
 *        The user's device does not have sufficient storage space to install
 *        the app. This can be resolved by clearing up storage space on the
 *        device. App install or update will automatically resume once the
 *        device has sufficient storage. (Value: "INSUFFICIENT_STORAGE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NetworkErrorUnreliableConnection
 *        A network error on the user's device has prevented the install from
 *        succeeding. This usually happens when the device's internet
 *        connectivity is degraded, unavailable or there's a network
 *        configuration issue. Please ensure the device has access to full
 *        internet connectivity on a network that meets Android Enterprise
 *        Network Requirements
 *        (https://support.google.com/work/android/answer/10513641). App install
 *        or update will automatically resume once this is the case. (Value:
 *        "NETWORK_ERROR_UNRELIABLE_CONNECTION")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining
 *        There are no licenses available to assign to the user. (Value:
 *        "NO_LICENSES_REMAINING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved
 *        The app has not been approved by the admin. (Value: "NOT_APPROVED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry
 *        The app is not available in the user's country. (Value:
 *        "NOT_AVAILABLE_IN_COUNTRY")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice
 *        The app is incompatible with the device. (Value:
 *        "NOT_COMPATIBLE_WITH_DEVICE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled
 *        The enterprise is no longer enrolled with Managed Google Play or the
 *        admin has not accepted the latest Managed Google Play Terms of
 *        Service. (Value: "NOT_ENROLLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound
 *        The app was not found in Play. (Value: "NOT_FOUND")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted
 *        The app has new permissions that have not been accepted by the admin.
 *        (Value: "PERMISSIONS_NOT_ACCEPTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid
 *        The user is no longer valid. The user may have been deleted or
 *        disabled. (Value: "USER_INVALID")
 */
@property(nonatomic, copy, nullable) NSString *installationFailureReason;

/**
 *  The reason the device is not in compliance with the setting.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of the Android version
 *        running on the device. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible
 *        The setting can't be applied to the app because the app doesn't
 *        support it, for example because its target SDK version is not high
 *        enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled
 *        A blocked app is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled
 *        The app required to implement the policy is not installed. (Value:
 *        "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated
 *        The app is installed, but it hasn't been updated to the minimum
 *        version code specified by policy. (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_DeviceIncompatible
 *        The device is incompatible with the policy requirements. (Value:
 *        "DEVICE_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ManagementMode
 *        The management mode (such as fully managed or work profile) doesn't
 *        support the setting. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is not used. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending
 *        The setting hasn't been applied at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name indicating which app is out of compliance, if applicable.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

/** Additional context for specific_non_compliance_reason. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SpecificNonComplianceContext *specificNonComplianceContext;

/**
 *  The policy-specific reason the device is not in compliance with the setting.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiApiLevel
 *        The ONC Wi-Fi setting is not supported in the API level of the Android
 *        version running on the device. fieldPath specifies which field value
 *        is not supported. oncWifiContext is set. nonComplianceReason is set to
 *        API_LEVEL. (Value: "ONC_WIFI_API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiInvalidEnterpriseConfig
 *        The enterprise Wi-Fi network is missing either the root CA or domain
 *        name. nonComplianceReason is set to INVALID_VALUE. (Value:
 *        "ONC_WIFI_INVALID_ENTERPRISE_CONFIG")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiInvalidValue
 *        There is an incorrect value in ONC Wi-Fi configuration. fieldPath
 *        specifies which field value is incorrect. oncWifiContext is set.
 *        nonComplianceReason is set to INVALID_VALUE. (Value:
 *        "ONC_WIFI_INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiKeyPairAliasNotCorrespondingToExistingKey
 *        Key pair alias specified via ClientCertKeyPairAlias
 *        (https://chromium.googlesource.com/chromium/src/+/main/components/onc/docs/onc_spec.md#eap-type)
 *        field in openNetworkConfiguration does not correspond to an existing
 *        key installed on the device. nonComplianceReason is set to
 *        INVALID_VALUE. (Value:
 *        "ONC_WIFI_KEY_PAIR_ALIAS_NOT_CORRESPONDING_TO_EXISTING_KEY")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiUserShouldRemoveNetwork
 *        User needs to remove the configured Wi-Fi network manually. This is
 *        applicable only on work profiles on personally-owned devices.
 *        nonComplianceReason is set to USER_ACTION. (Value:
 *        "ONC_WIFI_USER_SHOULD_REMOVE_NETWORK")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordExpired
 *        The device or profile password has expired. passwordPoliciesContext is
 *        set. nonComplianceReason is set to USER_ACTION. (Value:
 *        "PASSWORD_POLICIES_PASSWORD_EXPIRED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordNotSufficient
 *        The device password does not satisfy password requirements.
 *        passwordPoliciesContext is set. nonComplianceReason is set to
 *        USER_ACTION. (Value: "PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesUserCredentialsConfirmationRequired
 *        User needs to confirm credentials by entering the screen lock. Fields
 *        in specific_non_compliance_context are not set. nonComplianceReason is
 *        set to USER_ACTION. (Value:
 *        "PASSWORD_POLICIES_USER_CREDENTIALS_CONFIRMATION_REQUIRED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_SpecificNonComplianceReasonUnspecified
 *        Specific non-compliance reason is not specified. Fields in
 *        specific_non_compliance_context are not set. (Value:
 *        "SPECIFIC_NON_COMPLIANCE_REASON_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *specificNonComplianceReason;

@end


/**
 *  A compliance rule condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device. A NonComplianceDetail matches a
 *  NonComplianceDetailCondition if all the fields which are set within the
 *  NonComplianceDetailCondition match the corresponding NonComplianceDetail
 *  fields.
 */
GTLR_DEPRECATED
@interface GTLRAndroidManagement_NonComplianceDetailCondition : GTLRObject

/**
 *  The reason the device is not in compliance with the setting. If not set,
 *  then this condition matches any reason.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of the Android version
 *        running on the device. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible
 *        The setting can't be applied to the app because the app doesn't
 *        support it, for example because its target SDK version is not high
 *        enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled
 *        A blocked app is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled
 *        The app required to implement the policy is not installed. (Value:
 *        "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated
 *        The app is installed, but it hasn't been updated to the minimum
 *        version code specified by policy. (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_DeviceIncompatible
 *        The device is incompatible with the policy requirements. (Value:
 *        "DEVICE_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ManagementMode
 *        The management mode (such as fully managed or work profile) doesn't
 *        support the setting. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is not used. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending
 *        The setting hasn't been applied at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name of the app that's out of compliance. If not set, then this
 *  condition matches any package name.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field. If not set, then this condition matches any setting name.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

@end


/**
 *  This feature is not generally available.
 */
@interface GTLRAndroidManagement_OncCertificateProvider : GTLRObject

/** This feature is not generally available. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *certificateReferences;

/** This feature is not generally available. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ContentProviderEndpoint *contentProviderEndpoint;

@end


/**
 *  Additional context for non-compliance related to Wi-Fi configuration.
 */
@interface GTLRAndroidManagement_OncWifiContext : GTLRObject

/** The GUID of non-compliant Wi-Fi configuration. */
@property(nonatomic, copy, nullable) NSString *wifiGuid;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRAndroidManagement_Operation : GTLRObject

/**
 *  If the value is false, it means the operation is still in progress. If true,
 *  the operation is completed, and either error or response is available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the name should
 *  be a resource name ending with operations/{unique_id}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Response : GTLRObject
@end


/**
 *  Device was shutdown. Intentionally empty.
 */
@interface GTLRAndroidManagement_OsShutdownEvent : GTLRObject
@end


/**
 *  Device was started.
 */
@interface GTLRAndroidManagement_OsStartupEvent : GTLRObject

/**
 *  Verified Boot state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Green
 *        Indicates that there is a full chain of trust extending from the
 *        bootloader to verified partitions including the bootloader, boot
 *        partition, and all verified partitions. (Value: "GREEN")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Orange
 *        Indicates that the device may be freely modified. Device integrity is
 *        left to the user to verify out-of-band. (Value: "ORANGE")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_VerifiedBootStateUnspecified
 *        Unknown value. (Value: "VERIFIED_BOOT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Yellow
 *        Indicates that the boot partition has been verified using the embedded
 *        certificate and the signature is valid. (Value: "YELLOW")
 */
@property(nonatomic, copy, nullable) NSString *verifiedBootState;

/**
 *  dm-verity mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_Disabled
 *        Indicates that dm-verity is disabled on device. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_DmVerityModeUnspecified
 *        Unknown value. (Value: "DM_VERITY_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_Enforcing
 *        Indicates that the device will be restarted when corruption is
 *        detected. (Value: "ENFORCING")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_IoError Indicates
 *        that an I/O error will be returned for an attempt to read corrupted
 *        data blocks (also known as eio boot state). (Value: "IO_ERROR")
 */
@property(nonatomic, copy, nullable) NSString *verityMode;

@end


/**
 *  A list of package names.
 */
@interface GTLRAndroidManagement_PackageNameList : GTLRObject

/** A list of package names. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

@end


/**
 *  Additional context for non-compliance related to password policies.
 */
@interface GTLRAndroidManagement_PasswordPoliciesContext : GTLRObject

/**
 *  The scope of non-compliant password.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeDevice
 *        The password requirements are only applied to the device. (Value:
 *        "SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeProfile
 *        The password requirements are only applied to the work profile.
 *        (Value: "SCOPE_PROFILE")
 *    @arg @c kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeUnspecified
 *        The scope is unspecified. The password requirements are applied to the
 *        work profile for work profile devices and the whole device for fully
 *        managed or dedicated devices. (Value: "SCOPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *passwordPolicyScope;

@end


/**
 *  Requirements for the password used to unlock a device.
 */
@interface GTLRAndroidManagement_PasswordRequirements : GTLRObject

/**
 *  Number of incorrect device-unlock passwords that can be entered before a
 *  device is wiped. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumFailedPasswordsForWipe;

/** Password expiration timeout. */
@property(nonatomic, strong, nullable) GTLRDuration *passwordExpirationTimeout;

/**
 *  The length of the password history. After setting this field, the user won't
 *  be able to enter a new password that is the same as any password in the
 *  history. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordHistoryLength;

/**
 *  The minimum allowed password length. A value of 0 means there is no
 *  restriction. Only enforced when password_quality is NUMERIC,
 *  NUMERIC_COMPLEX, ALPHABETIC, ALPHANUMERIC, or COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLength;

/**
 *  Minimum number of letters required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLetters;

/**
 *  Minimum number of lower case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLowerCase;

/**
 *  Minimum number of non-letter characters (numerical digits or symbols)
 *  required in the password. Only enforced when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNonLetter;

/**
 *  Minimum number of numerical digits required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNumeric;

/**
 *  Minimum number of symbols required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumSymbols;

/**
 *  Minimum number of upper case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumUpperCase;

/**
 *  The required password quality.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic
 *        The password must contain alphabetic (or symbol) characters.This, when
 *        applied on personally owned work profile devices on Android 12
 *        device-scoped, will be treated as COMPLEXITY_HIGH for application. See
 *        PasswordQuality for details. (Value: "ALPHABETIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric
 *        The password must contain both numeric and alphabetic (or symbol)
 *        characters.This, when applied on personally owned work profile devices
 *        on Android 12 device-scoped, will be treated as COMPLEXITY_HIGH for
 *        application. See PasswordQuality for details. (Value: "ALPHANUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak
 *        The device must be secured with a low-security biometric recognition
 *        technology, at minimum. This includes technologies that can recognize
 *        the identity of an individual that are roughly equivalent to a 3-digit
 *        PIN (false detection is less than 1 in 1,000).This, when applied on
 *        personally owned work profile devices on Android 12 device-scoped,
 *        will be treated as COMPLEXITY_LOW for application. See PasswordQuality
 *        for details. (Value: "BIOMETRIC_WEAK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex
 *        The password must meet the minimum requirements specified in
 *        passwordMinimumLength, passwordMinimumLetters, passwordMinimumSymbols,
 *        etc. For example, if passwordMinimumSymbols is 2, the password must
 *        contain at least two symbols.This, when applied on personally owned
 *        work profile devices on Android 12 device-scoped, will be treated as
 *        COMPLEXITY_HIGH for application. In this case, the requirements in
 *        passwordMinimumLength, passwordMinimumLetters, passwordMinimumSymbols,
 *        etc are not applied. See PasswordQuality for details. (Value:
 *        "COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityHigh
 *        Define the high password complexity band as:On Android 12 and above:
 *        PIN with no repeating (4444) or ordered (1234, 4321, 2468) sequences,
 *        length at least 8 alphabetic, length at least 6 alphanumeric, length
 *        at least 6This sets the minimum complexity band which the password
 *        must meet.Enforcement varies among different Android versions,
 *        management modes and password scopes. See PasswordQuality for details.
 *        (Value: "COMPLEXITY_HIGH")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityLow
 *        Define the low password complexity band as: pattern PIN with repeating
 *        (4444) or ordered (1234, 4321, 2468) sequencesThis sets the minimum
 *        complexity band which the password must meet.Enforcement varies among
 *        different Android versions, management modes and password scopes. See
 *        PasswordQuality for details. (Value: "COMPLEXITY_LOW")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityMedium
 *        Define the medium password complexity band as: PIN with no repeating
 *        (4444) or ordered (1234, 4321, 2468) sequences, length at least 4
 *        alphabetic, length at least 4 alphanumeric, length at least 4This sets
 *        the minimum complexity band which the password must meet.Enforcement
 *        varies among different Android versions, management modes and password
 *        scopes. See PasswordQuality for details. (Value: "COMPLEXITY_MEDIUM")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric
 *        The password must contain numeric characters.This, when applied on
 *        personally owned work profile devices on Android 12 device-scoped,
 *        will be treated as COMPLEXITY_MEDIUM for application. See
 *        PasswordQuality for details. (Value: "NUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex
 *        The password must contain numeric characters with no repeating (4444)
 *        or ordered (1234, 4321, 2468) sequences.This, when applied on
 *        personally owned work profile devices on Android 12 device-scoped,
 *        will be treated as COMPLEXITY_MEDIUM for application. See
 *        PasswordQuality for details. (Value: "NUMERIC_COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified
 *        There are no password requirements. (Value:
 *        "PASSWORD_QUALITY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something
 *        A password is required, but there are no restrictions on what the
 *        password must contain.This, when applied on personally owned work
 *        profile devices on Android 12 device-scoped, will be treated as
 *        COMPLEXITY_LOW for application. See PasswordQuality for details.
 *        (Value: "SOMETHING")
 */
@property(nonatomic, copy, nullable) NSString *passwordQuality;

/**
 *  The scope that the password requirement applies to.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeDevice
 *        The password requirements are only applied to the device. (Value:
 *        "SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeProfile
 *        The password requirements are only applied to the work profile.
 *        (Value: "SCOPE_PROFILE")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeUnspecified
 *        The scope is unspecified. The password requirements are applied to the
 *        work profile for work profile devices and the whole device for fully
 *        managed or dedicated devices. (Value: "SCOPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *passwordScope;

/**
 *  The length of time after a device or work profile is unlocked using a strong
 *  form of authentication (password, PIN, pattern) that it can be unlocked
 *  using any other authentication method (e.g. fingerprint, trust agents,
 *  face). After the specified time period elapses, only strong forms of
 *  authentication can be used to unlock the device or work profile.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequireEveryDay
 *        The timeout period is set to 24 hours. (Value: "REQUIRE_EVERY_DAY")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequirePasswordUnlockUnspecified
 *        Unspecified. Defaults to USE_DEFAULT_DEVICE_TIMEOUT. (Value:
 *        "REQUIRE_PASSWORD_UNLOCK_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_UseDefaultDeviceTimeout
 *        The timeout period is set to the devices default. (Value:
 *        "USE_DEFAULT_DEVICE_TIMEOUT")
 */
@property(nonatomic, copy, nullable) NSString *requirePasswordUnlock;

/**
 *  Controls whether a unified lock is allowed for the device and the work
 *  profile, on devices running Android 9 and above with a work profile. This
 *  can be set only if password_scope is set to SCOPE_PROFILE, the policy will
 *  be rejected otherwise. If user has not set a separate work lock and this
 *  field is set to REQUIRE_SEPARATE_WORK_LOCK, a NonComplianceDetail is
 *  reported with nonComplianceReason set to USER_ACTION.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_AllowUnifiedWorkAndPersonalLock
 *        A common lock for the device and the work profile is allowed. (Value:
 *        "ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_RequireSeparateWorkLock
 *        A separate lock for the work profile is required. (Value:
 *        "REQUIRE_SEPARATE_WORK_LOCK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_UnifiedLockSettingsUnspecified
 *        Unspecified. Defaults to ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK. (Value:
 *        "UNIFIED_LOCK_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *unifiedLockSettings;

@end


/**
 *  The result of an attempt to clear the data of a single app.
 */
@interface GTLRAndroidManagement_PerAppResult : GTLRObject

/**
 *  The result of an attempt to clear the data of a single app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_ApiLevel This
 *        apps data could not be cleared because the device API level does not
 *        support this command. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_AppNotFound
 *        This apps data could not be cleared because the app was not found.
 *        (Value: "APP_NOT_FOUND")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_AppProtected
 *        This apps data could not be cleared because the app is protected. For
 *        example, this may apply to apps critical to the functioning of the
 *        device, such as Google Play Store. (Value: "APP_PROTECTED")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_ClearingResultUnspecified
 *        Unspecified result. (Value: "CLEARING_RESULT_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_Success This
 *        apps data was successfully cleared. (Value: "SUCCESS")
 */
@property(nonatomic, copy, nullable) NSString *clearingResult;

@end


/**
 *  Configuration for an Android permission and its grant state.
 */
@interface GTLRAndroidManagement_PermissionGrant : GTLRObject

/**
 *  The Android permission or group, e.g. android.permission.READ_CALENDAR or
 *  android.permission_group.CALENDAR.
 */
@property(nonatomic, copy, nullable) NSString *permission;

/**
 *  The policy for granting the permission.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Deny Automatically
 *        deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Grant Automatically
 *        grant a permission.On Android 12 and above,
 *        Manifest.permission.READ_SMS
 *        (https://developer.android.com/reference/android/Manifest.permission#READ_SMS)
 *        and following sensor-related permissions can only be granted on fully
 *        managed devices: Manifest.permission.ACCESS_FINE_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_FINE_LOCATION)
 *        Manifest.permission.ACCESS_BACKGROUND_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_BACKGROUND_LOCATION)
 *        Manifest.permission.ACCESS_COARSE_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_COARSE_LOCATION)
 *        Manifest.permission.CAMERA
 *        (https://developer.android.com/reference/android/Manifest.permission#CAMERA)
 *        Manifest.permission.RECORD_AUDIO
 *        (https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO)
 *        Manifest.permission.ACTIVITY_RECOGNITION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACTIVITY_RECOGNITION)
 *        Manifest.permission.BODY_SENSORS
 *        (https://developer.android.com/reference/android/Manifest.permission#BODY_SENSORS)
 *        (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Prompt Prompt the
 *        user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *policy;

@end


/**
 *  A default activity for handling intents that match a particular intent
 *  filter. Note: To set up a kiosk, use InstallType to KIOSK rather than use
 *  persistent preferred activities.
 */
@interface GTLRAndroidManagement_PersistentPreferredActivity : GTLRObject

/**
 *  The intent actions to match in the filter. If any actions are included in
 *  the filter, then an intent's action must be one of those values for it to
 *  match. If no actions are included, the intent action is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *actions;

/**
 *  The intent categories to match in the filter. An intent includes the
 *  categories that it requires, all of which must be included in the filter in
 *  order to match. In other words, adding a category to the filter has no
 *  impact on matching unless that category is specified in the intent.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *categories;

/**
 *  The activity that should be the default intent handler. This should be an
 *  Android component name, e.g. com.android.enterprise.app/.MainActivity.
 *  Alternatively, the value may be the package name of an app, which causes
 *  Android Device Policy to choose an appropriate activity from the app to
 *  handle the intent.
 */
@property(nonatomic, copy, nullable) NSString *receiverActivity;

@end


/**
 *  Policies for apps in the personal profile of a company-owned device with a
 *  work profile.
 */
@interface GTLRAndroidManagement_PersonalApplicationPolicy : GTLRObject

/**
 *  The type of installation to perform.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Available
 *        The app is available to install in the personal profile. (Value:
 *        "AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Blocked
 *        The app is blocked and can't be installed in the personal profile. If
 *        the app was previously installed in the device, it will be
 *        uninstalled. (Value: "BLOCKED")
 *    @arg @c kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_InstallTypeUnspecified
 *        Unspecified. Defaults to AVAILABLE. (Value:
 *        "INSTALL_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *installType;

/** The package name of the application. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  Policies controlling personal usage on a company-owned device with a work
 *  profile.
 */
@interface GTLRAndroidManagement_PersonalUsagePolicies : GTLRObject

/** Account types that can't be managed by the user. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accountTypesWithManagementDisabled;

/**
 *  If true, the camera is disabled on the personal profile.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cameraDisabled;

/**
 *  Controls how long the work profile can stay off. The minimum duration must
 *  be at least 3 days. Other details are as follows: - If the duration is set
 *  to 0, the feature is turned off. - If the duration is set to a value smaller
 *  than the minimum duration, the feature returns an error. *Note:* If you want
 *  to avoid personal profiles being suspended during long periods of off-time,
 *  you can temporarily set a large value for this parameter.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxDaysWithWorkOff;

/** Policy applied to applications in the personal profile. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PersonalApplicationPolicy *> *personalApplications;

/**
 *  Used together with personalApplications to control how apps in the personal
 *  profile are allowed or blocked.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Allowlist
 *        Only apps explicitly specified in personalApplications with
 *        installType set to AVAILABLE are allowed to be installed in the
 *        personal profile. (Value: "ALLOWLIST")
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blacklist
 *        All Play Store apps are available for installation in the personal
 *        profile, except those whose installType is BLOCKED in
 *        personalApplications. (Value: "BLACKLIST")
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blocklist
 *        All Play Store apps are available for installation in the personal
 *        profile, except those whose installType is BLOCKED in
 *        personalApplications. (Value: "BLOCKLIST")
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_PlayStoreModeUnspecified
 *        Unspecified. Defaults to BLOCKLIST. (Value:
 *        "PLAY_STORE_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *personalPlayStoreMode;

/**
 *  If true, screen capture is disabled for all users.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenCaptureDisabled;

@end


/**
 *  A policy resource represents a group of settings that govern the behavior of
 *  a managed device and the apps installed on it.
 */
@interface GTLRAndroidManagement_Policy : GTLRObject

/** Account types that can't be managed by the user. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accountTypesWithManagementDisabled;

/**
 *  Whether adding new users and profiles is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *addUserDisabled;

/**
 *  Whether adjusting the master volume is disabled. Also mutes the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adjustVolumeDisabled;

/** Advanced security settings. In most cases, setting these is not needed. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AdvancedSecurityOverrides *advancedSecurityOverrides;

/**
 *  Configuration for an always-on VPN connection. Use with vpn_config_disabled
 *  to prevent modification of this setting.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AlwaysOnVpnPackage *alwaysOnVpnPackage;

/** This setting is not supported. Any value is ignored. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *androidDevicePolicyTracks GTLR_DEPRECATED;

/**
 *  Recommended alternative: autoUpdateMode which is set per app, provides
 *  greater flexibility around update frequency.When autoUpdateMode is set to
 *  AUTO_UPDATE_POSTPONED or AUTO_UPDATE_HIGH_PRIORITY, this field has no
 *  effect.The app auto update policy, which controls when automatic app updates
 *  can be applied.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Always Apps are
 *        auto-updated at any time. Data charges may apply. (Value: "ALWAYS")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_AppAutoUpdatePolicyUnspecified
 *        The auto-update policy is not set. Equivalent to CHOICE_TO_THE_USER.
 *        (Value: "APP_AUTO_UPDATE_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_ChoiceToTheUser
 *        The user can control auto-updates. (Value: "CHOICE_TO_THE_USER")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Never Apps are
 *        never auto-updated. (Value: "NEVER")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_WifiOnly Apps
 *        are auto-updated over Wi-Fi only. (Value: "WIFI_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *appAutoUpdatePolicy;

/** Policy applied to apps. This can have at most 3,000 elements. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPolicy *> *applications;

/**
 *  Optional. Controls whether AssistContent
 *  (https://developer.android.com/reference/android/app/assist/AssistContent)
 *  is allowed to be sent to a privileged app such as an assistant app.
 *  AssistContent includes screenshots and information about an app, such as
 *  package name. This is supported on Android 15 and above.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_AssistContentPolicy_AssistContentAllowed
 *        Assist content is allowed to be sent to a privileged app.Supported on
 *        Android 15 and above. (Value: "ASSIST_CONTENT_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_Policy_AssistContentPolicy_AssistContentDisallowed
 *        Assist content is blocked from being sent to a privileged
 *        app.Supported on Android 15 and above. A nonComplianceDetail with
 *        API_LEVEL is reported if the Android version is less than 15. (Value:
 *        "ASSIST_CONTENT_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_Policy_AssistContentPolicy_AssistContentPolicyUnspecified
 *        Unspecified. Defaults to ASSIST_CONTENT_ALLOWED. (Value:
 *        "ASSIST_CONTENT_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *assistContentPolicy;

/**
 *  Whether auto date, time, and time zone are enabled on a company-owned
 *  device. If this is set, then autoTimeRequired is ignored.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneEnforced
 *        Enforce auto date, time, and time zone on the device. (Value:
 *        "AUTO_DATE_AND_TIME_ZONE_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUnspecified
 *        Unspecified. Defaults to AUTO_DATE_AND_TIME_ZONE_USER_CHOICE. (Value:
 *        "AUTO_DATE_AND_TIME_ZONE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUserChoice
 *        Auto date, time, and time zone are left to user's choice. (Value:
 *        "AUTO_DATE_AND_TIME_ZONE_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *autoDateAndTimeZone;

/**
 *  Whether auto time is required, which prevents the user from manually setting
 *  the date and time. If autoDateAndTimeZone is set, this field is ignored.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoTimeRequired GTLR_DEPRECATED;

/**
 *  Whether applications other than the ones configured in applications are
 *  blocked from being installed. When set, applications that were installed
 *  under a previous policy but no longer appear in the policy are automatically
 *  uninstalled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockApplicationsEnabled GTLR_DEPRECATED;

/**
 *  Whether configuring bluetooth is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothConfigDisabled;

/**
 *  Whether bluetooth contact sharing is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothContactSharingDisabled;

/**
 *  Whether bluetooth is disabled. Prefer this setting over
 *  bluetooth_config_disabled because bluetooth_config_disabled can be bypassed
 *  by the user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothDisabled;

/**
 *  Controls the use of the camera and whether the user has access to the camera
 *  access toggle.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessDisabled
 *        The field camera_disabled is ignored. All cameras on the device are
 *        disabled (for fully managed devices, this applies device-wide and for
 *        work profiles this applies only to the work profile).There are no
 *        explicit restrictions placed on the camera access toggle on Android 12
 *        and above: on fully managed devices, the camera access toggle has no
 *        effect as all cameras are disabled. On devices with a work profile,
 *        this toggle has no effect on apps in the work profile, but it affects
 *        apps outside the work profile. (Value: "CAMERA_ACCESS_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessEnforced
 *        The field camera_disabled is ignored. All cameras on the device are
 *        available. On fully managed devices running Android 12 and above, the
 *        user is unable to use the camera access toggle. On devices which are
 *        not fully managed or which run Android 11 or below, this is equivalent
 *        to CAMERA_ACCESS_USER_CHOICE. (Value: "CAMERA_ACCESS_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUnspecified
 *        If camera_disabled is true, this is equivalent to
 *        CAMERA_ACCESS_DISABLED. Otherwise, this is equivalent to
 *        CAMERA_ACCESS_USER_CHOICE. (Value: "CAMERA_ACCESS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUserChoice
 *        The field camera_disabled is ignored. This is the default device
 *        behaviour: all cameras on the device are available. On Android 12 and
 *        above, the user can use the camera access toggle. (Value:
 *        "CAMERA_ACCESS_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *cameraAccess;

/**
 *  If camera_access is set to any value other than CAMERA_ACCESS_UNSPECIFIED,
 *  this has no effect. Otherwise this field controls whether cameras are
 *  disabled: If true, all cameras are disabled, otherwise they are available.
 *  For fully managed devices this field applies for all apps on the device. For
 *  work profiles, this field applies only to apps in the work profile, and the
 *  camera access of apps outside the work profile is unaffected.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cameraDisabled GTLR_DEPRECATED;

/**
 *  Whether configuring cell broadcast is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cellBroadcastsConfigDisabled;

/**
 *  Rules for determining apps' access to private keys. See ChoosePrivateKeyRule
 *  for details. This must be empty if any application has CERT_SELECTION
 *  delegation scope.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ChoosePrivateKeyRule *> *choosePrivateKeyRules;

/**
 *  Rules declaring which mitigating actions to take when a device is not
 *  compliant with its policy. When the conditions for multiple rules are
 *  satisfied, all of the mitigating actions for the rules are taken. There is a
 *  maximum limit of 100 rules. Use policy enforcement rules instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ComplianceRule *> *complianceRules GTLR_DEPRECATED;

/**
 *  Whether creating windows besides app windows is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *createWindowsDisabled;

/**
 *  Controls which apps are allowed to act as credential providers on Android 14
 *  and above. These apps store credentials, see this
 *  (https://developer.android.com/training/sign-in/passkeys) and this
 *  (https://developer.android.com/reference/androidx/credentials/CredentialManager)
 *  for details. See also credentialProviderPolicy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_CredentialProviderPolicyDefault_CredentialProviderDefaultDisallowed
 *        Apps with credentialProviderPolicy unspecified are not allowed to act
 *        as a credential provider. (Value:
 *        "CREDENTIAL_PROVIDER_DEFAULT_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_Policy_CredentialProviderPolicyDefault_CredentialProviderDefaultDisallowedExceptSystem
 *        Apps with credentialProviderPolicy unspecified are not allowed to act
 *        as a credential provider except for the OEM default credential
 *        providers. OEM default credential providers are always allowed to act
 *        as credential providers. (Value:
 *        "CREDENTIAL_PROVIDER_DEFAULT_DISALLOWED_EXCEPT_SYSTEM")
 *    @arg @c kGTLRAndroidManagement_Policy_CredentialProviderPolicyDefault_CredentialProviderPolicyDefaultUnspecified
 *        Unspecified. Defaults to CREDENTIAL_PROVIDER_DEFAULT_DISALLOWED.
 *        (Value: "CREDENTIAL_PROVIDER_POLICY_DEFAULT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *credentialProviderPolicyDefault;

/**
 *  Whether configuring user credentials is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *credentialsConfigDisabled;

/** Cross-profile policies applied on the device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CrossProfilePolicies *crossProfilePolicies;

/**
 *  Whether roaming data services are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataRoamingDisabled;

/**
 *  Whether the user is allowed to enable debugging features.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *debuggingFeaturesAllowed GTLR_DEPRECATED;

/**
 *  The default permission policy for runtime permission requests.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission.On Android 12 and above,
 *        Manifest.permission.READ_SMS
 *        (https://developer.android.com/reference/android/Manifest.permission#READ_SMS)
 *        and following sensor-related permissions can only be granted on fully
 *        managed devices: Manifest.permission.ACCESS_FINE_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_FINE_LOCATION)
 *        Manifest.permission.ACCESS_BACKGROUND_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_BACKGROUND_LOCATION)
 *        Manifest.permission.ACCESS_COARSE_LOCATION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACCESS_COARSE_LOCATION)
 *        Manifest.permission.CAMERA
 *        (https://developer.android.com/reference/android/Manifest.permission#CAMERA)
 *        Manifest.permission.RECORD_AUDIO
 *        (https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO)
 *        Manifest.permission.ACTIVITY_RECOGNITION
 *        (https://developer.android.com/reference/android/Manifest.permission#ACTIVITY_RECOGNITION)
 *        Manifest.permission.BODY_SENSORS
 *        (https://developer.android.com/reference/android/Manifest.permission#BODY_SENSORS)
 *        (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/**
 *  Covers controls for device connectivity such as Wi-Fi, USB data access,
 *  keyboard/mouse connections, and more.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DeviceConnectivityManagement *deviceConnectivityManagement;

/** The device owner information to be shown on the lock screen. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *deviceOwnerLockScreenInfo;

/** Covers controls for radio state such as Wi-Fi, bluetooth, and more. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DeviceRadioState *deviceRadioState;

/** Optional. Controls for the display settings. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DisplaySettings *displaySettings;

/**
 *  Whether encryption is enabled
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithoutPassword
 *        Encryption required but no password required to boot (Value:
 *        "ENABLED_WITHOUT_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithPassword
 *        Encryption required with password required to boot (Value:
 *        "ENABLED_WITH_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EncryptionPolicyUnspecified
 *        This value is ignored, i.e. no encryption required (Value:
 *        "ENCRYPTION_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionPolicy;

/**
 *  Whether app verification is force-enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ensureVerifyAppsEnabled GTLR_DEPRECATED;

/**
 *  Whether factory resetting from settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *factoryResetDisabled;

/**
 *  Email addresses of device administrators for factory reset protection. When
 *  the device is factory reset, it will require one of these admins to log in
 *  with the Google account email and password to unlock the device. If no
 *  admins are specified, the device won't provide factory reset protection.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *frpAdminEmails;

/**
 *  Whether the user is allowed to have fun. Controls whether the Easter egg
 *  game in Settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *funDisabled;

/**
 *  Whether user installation of apps is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installAppsDisabled;

/**
 *  This field has no effect.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installUnknownSourcesAllowed GTLR_DEPRECATED;

/**
 *  If true, this disables the Lock Screen
 *  (https://source.android.com/docs/core/display/multi_display/lock-screen) for
 *  primary and/or secondary displays.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *keyguardDisabled;

/** Disabled keyguard customizations, such as widgets. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *keyguardDisabledFeatures;

/**
 *  Settings controlling the behavior of a device in kiosk mode. To enable kiosk
 *  mode, set kioskCustomLauncherEnabled to true or specify an app in the policy
 *  with installType KIOSK.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KioskCustomization *kioskCustomization;

/**
 *  Whether the kiosk custom launcher is enabled. This replaces the home screen
 *  with a launcher that locks down the device to the apps installed via the
 *  applications setting. Apps appear on a single page in alphabetical order.
 *  Use kioskCustomization to further configure the kiosk device behavior.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kioskCustomLauncherEnabled;

/**
 *  The degree of location detection enabled.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_BatterySaving On
 *        Android 8 and below, only the network location provider is enabled. On
 *        Android 9 and above, this is equivalent to LOCATION_ENFORCED. (Value:
 *        "BATTERY_SAVING")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_HighAccuracy On Android
 *        8 and below, all location detection methods are enabled, including
 *        GPS, networks, and other sensors. On Android 9 and above, this is
 *        equivalent to LOCATION_ENFORCED. (Value: "HIGH_ACCURACY")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationDisabled
 *        Disable location setting on the device. (Value: "LOCATION_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationEnforced Enable
 *        location setting on the device. (Value: "LOCATION_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationModeUnspecified
 *        Defaults to LOCATION_USER_CHOICE. (Value: "LOCATION_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationUserChoice
 *        Location setting is not restricted on the device. No specific behavior
 *        is set or enforced. (Value: "LOCATION_USER_CHOICE")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_Off On Android 8 and
 *        below, location setting and accuracy are disabled. On Android 9 and
 *        above, this is equivalent to LOCATION_DISABLED. (Value: "OFF")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_SensorsOnly On Android
 *        8 and below, only GPS and other sensors are enabled. On Android 9 and
 *        above, this is equivalent to LOCATION_ENFORCED. (Value:
 *        "SENSORS_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *locationMode;

/**
 *  A message displayed to the user in the device administators settings screen.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *longSupportMessage;

/**
 *  Maximum time in milliseconds for user activity until the device locks. A
 *  value of 0 means there is no restriction.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumTimeToLock;

/**
 *  Controls the use of the microphone and whether the user has access to the
 *  microphone access toggle. This applies only on fully managed devices.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessDisabled
 *        The field unmute_microphone_disabled is ignored. The microphone on the
 *        device is disabled (for fully managed devices, this applies
 *        device-wide).The microphone access toggle has no effect as the
 *        microphone is disabled. (Value: "MICROPHONE_ACCESS_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessEnforced
 *        The field unmute_microphone_disabled is ignored. The microphone on the
 *        device is available. On devices running Android 12 and above, the user
 *        is unable to use the microphone access toggle. On devices which run
 *        Android 11 or below, this is equivalent to
 *        MICROPHONE_ACCESS_USER_CHOICE. (Value: "MICROPHONE_ACCESS_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUnspecified
 *        If unmute_microphone_disabled is true, this is equivalent to
 *        MICROPHONE_ACCESS_DISABLED. Otherwise, this is equivalent to
 *        MICROPHONE_ACCESS_USER_CHOICE. (Value:
 *        "MICROPHONE_ACCESS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUserChoice
 *        The field unmute_microphone_disabled is ignored. This is the default
 *        device behaviour: the microphone on the device is available. On
 *        Android 12 and above, the user can use the microphone access toggle.
 *        (Value: "MICROPHONE_ACCESS_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *microphoneAccess;

/**
 *  The minimum allowed Android API level.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimumApiLevel;

/**
 *  Whether configuring mobile networks is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mobileNetworksConfigDisabled;

/**
 *  Whether adding or removing accounts is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *modifyAccountsDisabled;

/**
 *  Whether the user mounting physical external media is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mountPhysicalMediaDisabled;

/**
 *  The name of the policy in the form
 *  enterprises/{enterpriseId}/policies/{policyId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the network escape hatch is enabled. If a network connection can't
 *  be made at boot time, the escape hatch prompts the user to temporarily
 *  connect to a network in order to refresh the device policy. After applying
 *  policy, the temporary network will be forgotten and the device will continue
 *  booting. This prevents being unable to connect to a network if there is no
 *  suitable network in the last policy and the device boots into an app in lock
 *  task mode, or the user is otherwise unable to reach device settings.Note:
 *  Setting wifiConfigDisabled to true will override this setting under specific
 *  circumstances. Please see wifiConfigDisabled for further details. Setting
 *  configureWifi to DISALLOW_CONFIGURING_WIFI will override this setting under
 *  specific circumstances. Please see DISALLOW_CONFIGURING_WIFI for further
 *  details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkEscapeHatchEnabled;

/**
 *  Whether resetting network settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkResetDisabled;

/** This feature is not generally available. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_OncCertificateProvider *> *oncCertificateProviders;

/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Policy_OpenNetworkConfiguration *openNetworkConfiguration;

/**
 *  Whether using NFC to beam data from apps is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outgoingBeamDisabled;

/**
 *  Whether outgoing calls are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outgoingCallsDisabled;

/**
 *  Password requirement policies. Different policies can be set for work
 *  profile or fully managed devices by setting the password_scope field in the
 *  policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PasswordRequirements *> *passwordPolicies;

/**
 *  Password requirements. The field
 *  password_requirements.require_password_unlock must not be set. DEPRECATED -
 *  Use passwordPolicies.Note:Complexity-based values of PasswordQuality, that
 *  is, COMPLEXITY_LOW, COMPLEXITY_MEDIUM, and COMPLEXITY_HIGH, cannot be used
 *  here. unified_lock_settings cannot be used here.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PasswordRequirements *passwordRequirements GTLR_DEPRECATED;

/**
 *  Explicit permission or group grants or denials for all apps. These values
 *  override the default_permission_policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

/**
 *  Specifies permitted accessibility services. If the field is not set, any
 *  accessibility service can be used. If the field is set, only the
 *  accessibility services in this list and the system's built-in accessibility
 *  service can be used. In particular, if the field is set to empty, only the
 *  system's built-in accessibility servicess can be used. This can be set on
 *  fully managed devices and on work profiles. When applied to a work profile,
 *  this affects both the personal profile and the work profile.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PackageNameList *permittedAccessibilityServices;

/**
 *  If present, only the input methods provided by packages in this list are
 *  permitted. If this field is present, but the list is empty, then only system
 *  input methods are permitted.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PackageNameList *permittedInputMethods;

/** Default intent handler activities. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PersistentPreferredActivity *> *persistentPreferredActivities;

/** Policies managing personal usage on a company-owned device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PersonalUsagePolicies *personalUsagePolicies;

/**
 *  This mode controls which apps are available to the user in the Play Store
 *  and the behavior on the device when apps are removed from the policy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_Blacklist All apps are
 *        available and any app that should not be on the device should be
 *        explicitly marked as 'BLOCKED' in the applications policy. (Value:
 *        "BLACKLIST")
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_PlayStoreModeUnspecified
 *        Unspecified. Defaults to WHITELIST. (Value:
 *        "PLAY_STORE_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_Whitelist Only apps
 *        that are in the policy are available and any app not in the policy
 *        will be automatically uninstalled from the device. (Value:
 *        "WHITELIST")
 */
@property(nonatomic, copy, nullable) NSString *playStoreMode;

/**
 *  Rules that define the behavior when a particular policy can not be applied
 *  on device
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PolicyEnforcementRule *> *policyEnforcementRules;

/**
 *  Controls whether preferential network service is enabled on the work
 *  profile. For example, an organization may have an agreement with a carrier
 *  that all of the work data from its employees' devices will be sent via a
 *  network service dedicated for enterprise use. An example of a supported
 *  preferential network service is the enterprise slice on 5G networks. This
 *  has no effect on fully managed devices.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceDisabled
 *        Preferential network service is disabled on the work profile. (Value:
 *        "PREFERENTIAL_NETWORK_SERVICE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceEnabled
 *        Preferential network service is enabled on the work profile. (Value:
 *        "PREFERENTIAL_NETWORK_SERVICE_ENABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceUnspecified
 *        Unspecified. Defaults to PREFERENTIAL_NETWORK_SERVICES_DISABLED.
 *        (Value: "PREFERENTIAL_NETWORK_SERVICE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *preferentialNetworkService;

/**
 *  Optional. Controls whether printing is allowed. This is supported on devices
 *  running Android 9 and above. .
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_PrintingPolicy_PrintingAllowed
 *        Printing is allowed. (Value: "PRINTING_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_Policy_PrintingPolicy_PrintingDisallowed
 *        Printing is disallowed. A nonComplianceDetail with API_LEVEL is
 *        reported if the Android version is less than 9. (Value:
 *        "PRINTING_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_Policy_PrintingPolicy_PrintingPolicyUnspecified
 *        Unspecified. Defaults to PRINTING_ALLOWED. (Value:
 *        "PRINTING_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *printingPolicy;

/**
 *  Allows showing UI on a device for a user to choose a private key alias if
 *  there are no matching rules in ChoosePrivateKeyRules. For devices below
 *  Android P, setting this may leave enterprise keys vulnerable. This value
 *  will have no effect if any application has CERT_SELECTION delegation scope.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *privateKeySelectionEnabled;

/**
 *  The network-independent global HTTP proxy. Typically proxies should be
 *  configured per-network in open_network_configuration. However for unusual
 *  configurations like general internal filtering a global HTTP proxy may be
 *  useful. If the proxy is not accessible, network access may break. The global
 *  proxy is only a recommendation and some apps may ignore it.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ProxyInfo *recommendedGlobalProxy;

/**
 *  Whether removing other users is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *removeUserDisabled;

/**
 *  Whether rebooting the device into safe boot is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *safeBootDisabled GTLR_DEPRECATED;

/**
 *  Whether screen capture is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenCaptureDisabled;

/**
 *  Action to take during the setup process. At most one action may be
 *  specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_SetupAction *> *setupActions;

/**
 *  Whether changing the user icon is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *setUserIconDisabled;

/**
 *  Whether changing the wallpaper is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *setWallpaperDisabled;

/**
 *  Whether location sharing is disabled. share_location_disabled is supported
 *  for both fully managed devices and personally owned work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *shareLocationDisabled;

/**
 *  A message displayed to the user in the settings screen wherever
 *  functionality has been disabled by the admin. If the message is longer than
 *  200 characters it may be truncated.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *shortSupportMessage;

/**
 *  Flag to skip hints on the first use. Enterprise admin can enable the system
 *  recommendation for apps to skip their user tutorial and other introductory
 *  hints on first start-up.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipFirstUseHintsEnabled;

/**
 *  Whether sending and receiving SMS messages is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *smsDisabled;

/**
 *  Whether the status bar is disabled. This disables notifications, quick
 *  settings, and other screen overlays that allow escape from full-screen mode.
 *  DEPRECATED. To disable the status bar on a kiosk device, use InstallType
 *  KIOSK or kioskCustomLauncherEnabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *statusBarDisabled GTLR_DEPRECATED;

/** Status reporting settings */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StatusReportingSettings *statusReportingSettings;

/**
 *  The battery plugged in modes for which the device stays on. When using this
 *  setting, it is recommended to clear maximum_time_to_lock so that the device
 *  doesn't lock itself while it stays on.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *stayOnPluggedModes;

/**
 *  The system update policy, which controls how OS updates are applied. If the
 *  update type is WINDOWED, the update window will automatically apply to Play
 *  app updates as well.Note: Google Play system updates
 *  (https://source.android.com/docs/core/ota/modular-system) (also called
 *  Mainline updates) are automatically downloaded and require a device reboot
 *  to be installed. Refer to the mainline section in Manage system updates
 *  (https://developer.android.com/work/dpc/system-updates#mainline) for further
 *  details.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SystemUpdate *systemUpdate;

/**
 *  Whether configuring tethering and portable hotspots is disabled. If
 *  tetheringSettings is set to anything other than
 *  TETHERING_SETTINGS_UNSPECIFIED, this setting is ignored.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *tetheringConfigDisabled GTLR_DEPRECATED;

/**
 *  Whether user uninstallation of applications is disabled. This prevents apps
 *  from being uninstalled, even those removed using applications
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *uninstallAppsDisabled;

/**
 *  If microphone_access is set to any value other than
 *  MICROPHONE_ACCESS_UNSPECIFIED, this has no effect. Otherwise this field
 *  controls whether microphones are disabled: If true, all microphones are
 *  disabled, otherwise they are available. This is available only on fully
 *  managed devices.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unmuteMicrophoneDisabled GTLR_DEPRECATED;

/** Configuration of device activity logging. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UsageLog *usageLog;

/**
 *  Whether transferring files over USB is disabled. This is supported only on
 *  company-owned devices.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usbFileTransferDisabled GTLR_DEPRECATED;

/**
 *  Whether USB storage is enabled. Deprecated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usbMassStorageEnabled GTLR_DEPRECATED;

/**
 *  The version of the policy. This is a read-only field. The version is
 *  incremented each time the policy is updated.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

/**
 *  Whether configuring VPN is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vpnConfigDisabled;

/**
 *  Whether configuring Wi-Fi networks is disabled. Supported on fully managed
 *  devices and work profiles on company-owned devices. For fully managed
 *  devices, setting this to true removes all configured networks and retains
 *  only the networks configured using openNetworkConfiguration. For work
 *  profiles on company-owned devices, existing configured networks are not
 *  affected and the user is not allowed to add, remove, or modify Wi-Fi
 *  networks. If configureWifi is set to anything other than
 *  CONFIGURE_WIFI_UNSPECIFIED, this setting is ignored. Note: If a network
 *  connection can't be made at boot time and configuring Wi-Fi is disabled then
 *  network escape hatch will be shown in order to refresh the device policy
 *  (see networkEscapeHatchEnabled).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigDisabled GTLR_DEPRECATED;

/**
 *  This is deprecated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigsLockdownEnabled GTLR_DEPRECATED;

@end


/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Policy_OpenNetworkConfiguration : GTLRObject
@end


/**
 *  A rule that defines the actions to take if a device or work profile is not
 *  compliant with the policy specified in settingName. In the case of multiple
 *  matching or multiple triggered enforcement rules, a merge will occur with
 *  the most severe action being taken. However, all triggered rules are still
 *  kept track of: this includes initial trigger time and all associated
 *  non-compliance details. In the situation where the most severe enforcement
 *  rule is satisfied, the next most appropriate action is applied.
 */
@interface GTLRAndroidManagement_PolicyEnforcementRule : GTLRObject

/**
 *  An action to block access to apps and data on a company owned device or in a
 *  work profile. This action also triggers a user-facing notification with
 *  information (where possible) on how to correct the compliance issue. Note:
 *  wipeAction must also be specified.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_BlockAction *blockAction;

/**
 *  The top-level policy to enforce. For example, applications or
 *  passwordPolicies.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

/**
 *  An action to reset a company owned device or delete a work profile. Note:
 *  blockAction must also be specified.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_WipeAction *wipeAction;

@end


/**
 *  Additional details regarding the security posture of the device.
 */
@interface GTLRAndroidManagement_PostureDetail : GTLRObject

/**
 *  Corresponding admin-facing advice to mitigate this security risk and improve
 *  the security posture of the device.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_UserFacingMessage *> *advice;

/**
 *  A specific security risk that negatively affects the security posture of the
 *  device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_CompromisedOs
 *        Play Integrity API detects that the device is running a compromised OS
 *        (basicIntegrity check fails). (Value: "COMPROMISED_OS")
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_HardwareBackedEvaluationFailed
 *        Play Integrity API detects that the device does not have a strong
 *        guarantee of system integrity, if the MEETS_STRONG_INTEGRITY label
 *        doesn't show in the device integrity field
 *        (https://developer.android.com/google/play/integrity/verdicts#device-integrity-field).
 *        (Value: "HARDWARE_BACKED_EVALUATION_FAILED")
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_SecurityRiskUnspecified
 *        Unspecified. (Value: "SECURITY_RISK_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_UnknownOs Play
 *        Integrity API detects that the device is running an unknown OS
 *        (basicIntegrity check succeeds but ctsProfileMatch fails). (Value:
 *        "UNKNOWN_OS")
 */
@property(nonatomic, copy, nullable) NSString *securityRisk;

@end


/**
 *  A power management event.
 */
@interface GTLRAndroidManagement_PowerManagementEvent : GTLRObject

/**
 *  For BATTERY_LEVEL_COLLECTED events, the battery level as a percentage.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batteryLevel;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected
 *        Battery level was measured. (Value: "BATTERY_LEVEL_COLLECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow
 *        The device entered low-power mode. (Value: "BATTERY_LOW")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay
 *        The device exited low-power mode. (Value: "BATTERY_OKAY")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted
 *        The device booted. (Value: "BOOT_COMPLETED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected
 *        The device started charging. (Value: "POWER_CONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected
 *        The device stopped charging. (Value: "POWER_DISCONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown The
 *        device shut down. (Value: "SHUTDOWN")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Information about a device that is available during setup.
 */
@interface GTLRAndroidManagement_ProvisioningInfo : GTLRObject

/**
 *  The API level of the Android platform version running on the device.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *apiLevel;

/**
 *  The email address of the authenticated user (only present for Google Account
 *  provisioning method).
 */
@property(nonatomic, copy, nullable) NSString *authenticatedUserEmail;

/** The brand of the device. For example, Google. */
@property(nonatomic, copy, nullable) NSString *brand;

/** The name of the enterprise in the form enterprises/{enterprise}. */
@property(nonatomic, copy, nullable) NSString *enterprise;

/**
 *  For corporate-owned devices, IMEI number of the GSM device. For example,
 *  A1000031212.
 */
@property(nonatomic, copy, nullable) NSString *imei;

/**
 *  The management mode of the device or profile.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ProvisioningInfo_ManagementMode_DeviceOwner
 *        Device owner. Android Device Policy has full control over the device.
 *        (Value: "DEVICE_OWNER")
 *    @arg @c kGTLRAndroidManagement_ProvisioningInfo_ManagementMode_ManagementModeUnspecified
 *        This value is disallowed. (Value: "MANAGEMENT_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ProvisioningInfo_ManagementMode_ProfileOwner
 *        Profile owner. Android Device Policy has control over a managed
 *        profile on the device. (Value: "PROFILE_OWNER")
 */
@property(nonatomic, copy, nullable) NSString *managementMode;

/**
 *  For corporate-owned devices, MEID number of the CDMA device. For example,
 *  A00000292788E1.
 */
@property(nonatomic, copy, nullable) NSString *meid;

/** The model of the device. For example, Asus Nexus 7. */
@property(nonatomic, copy, nullable) NSString *model;

/**
 *  The name of this resource in the form provisioningInfo/{provisioning_info}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Ownership of the managed device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ProvisioningInfo_Ownership_CompanyOwned
 *        Device is company-owned. (Value: "COMPANY_OWNED")
 *    @arg @c kGTLRAndroidManagement_ProvisioningInfo_Ownership_OwnershipUnspecified
 *        Ownership is unspecified. (Value: "OWNERSHIP_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ProvisioningInfo_Ownership_PersonallyOwned
 *        Device is personally-owned. (Value: "PERSONALLY_OWNED")
 */
@property(nonatomic, copy, nullable) NSString *ownership;

/** For corporate-owned devices, The device serial number. */
@property(nonatomic, copy, nullable) NSString *serialNumber;

@end


/**
 *  Configuration info for an HTTP proxy. For a direct proxy, set the host,
 *  port, and excluded_hosts fields. For a PAC script proxy, set the pac_uri
 *  field.
 */
@interface GTLRAndroidManagement_ProxyInfo : GTLRObject

/**
 *  For a direct proxy, the hosts for which the proxy is bypassed. The host
 *  names may contain wildcards such as *.example.com.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludedHosts;

/** The host of the direct proxy. */
@property(nonatomic, copy, nullable) NSString *host;

/** The URI of the PAC script used to configure the proxy. */
@property(nonatomic, copy, nullable) NSString *pacUri;

/**
 *  The port of the direct proxy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

@end


/**
 *  The device or profile has been remotely locked via the LOCK command.
 */
@interface GTLRAndroidManagement_RemoteLockEvent : GTLRObject

/** Package name of the admin app requesting the change. */
@property(nonatomic, copy, nullable) NSString *adminPackageName;

/**
 *  User ID of the admin app from the which the change was requested.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adminUserId;

/**
 *  User ID in which the change was requested in.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *targetUserId;

@end


/**
 *  Controls for the screen brightness settings.
 */
@interface GTLRAndroidManagement_ScreenBrightnessSettings : GTLRObject

/**
 *  Optional. The screen brightness between 1 and 255 where 1 is the lowest and
 *  255 is the highest brightness. A value of 0 (default) means no screen
 *  brightness set. Any other value is rejected. screenBrightnessMode must be
 *  either BRIGHTNESS_AUTOMATIC or BRIGHTNESS_FIXED to set this. Supported on
 *  Android 9 and above on fully managed devices. A NonComplianceDetail with
 *  API_LEVEL is reported if the Android version is less than 9.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenBrightness;

/**
 *  Optional. Controls the screen brightness mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_BrightnessAutomatic
 *        The screen brightness mode is automatic in which the brightness is
 *        automatically adjusted and the user is not allowed to configure the
 *        screen brightness. screenBrightness can still be set and it is taken
 *        into account while the brightness is automatically adjusted. Supported
 *        on Android 9 and above on fully managed devices. A NonComplianceDetail
 *        with API_LEVEL is reported if the Android version is less than 9.
 *        (Value: "BRIGHTNESS_AUTOMATIC")
 *    @arg @c kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_BrightnessFixed
 *        The screen brightness mode is fixed in which the brightness is set to
 *        screenBrightness and the user is not allowed to configure the screen
 *        brightness. screenBrightness must be set. Supported on Android 9 and
 *        above on fully managed devices. A NonComplianceDetail with API_LEVEL
 *        is reported if the Android version is less than 9. (Value:
 *        "BRIGHTNESS_FIXED")
 *    @arg @c kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_BrightnessUserChoice
 *        The user is allowed to configure the screen brightness.
 *        screenBrightness must not be set. (Value: "BRIGHTNESS_USER_CHOICE")
 *    @arg @c kGTLRAndroidManagement_ScreenBrightnessSettings_ScreenBrightnessMode_ScreenBrightnessModeUnspecified
 *        Unspecified. Defaults to BRIGHTNESS_USER_CHOICE. (Value:
 *        "SCREEN_BRIGHTNESS_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *screenBrightnessMode;

@end


/**
 *  Controls the screen timeout settings.
 */
@interface GTLRAndroidManagement_ScreenTimeoutSettings : GTLRObject

/**
 *  Optional. Controls the screen timeout duration. The screen timeout duration
 *  must be greater than 0, otherwise it is rejected. Additionally, it should
 *  not be greater than maximumTimeToLock, otherwise the screen timeout is set
 *  to maximumTimeToLock and a NonComplianceDetail with INVALID_VALUE reason and
 *  SCREEN_TIMEOUT_GREATER_THAN_MAXIMUM_TIME_TO_LOCK specific reason is
 *  reported. If the screen timeout is less than a certain lower bound, it is
 *  set to the lower bound. The lower bound may vary across devices. If this is
 *  set, screenTimeoutMode must be SCREEN_TIMEOUT_ENFORCED. Supported on Android
 *  9 and above on fully managed devices. A NonComplianceDetail with API_LEVEL
 *  is reported if the Android version is less than 9.
 */
@property(nonatomic, strong, nullable) GTLRDuration *screenTimeout;

/**
 *  Optional. Controls whether the user is allowed to configure the screen
 *  timeout.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ScreenTimeoutSettings_ScreenTimeoutMode_ScreenTimeoutEnforced
 *        The screen timeout is set to screenTimeout and the user is not allowed
 *        to configure the timeout. screenTimeout must be set. Supported on
 *        Android 9 and above on fully managed devices. A NonComplianceDetail
 *        with API_LEVEL is reported if the Android version is less than 9.
 *        (Value: "SCREEN_TIMEOUT_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_ScreenTimeoutSettings_ScreenTimeoutMode_ScreenTimeoutModeUnspecified
 *        Unspecified. Defaults to SCREEN_TIMEOUT_USER_CHOICE. (Value:
 *        "SCREEN_TIMEOUT_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ScreenTimeoutSettings_ScreenTimeoutMode_ScreenTimeoutUserChoice
 *        The user is allowed to configure the screen timeout. screenTimeout
 *        must not be set. (Value: "SCREEN_TIMEOUT_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *screenTimeoutMode;

@end


/**
 *  The security posture of the device, as determined by the current device
 *  state and the policies applied.
 */
@interface GTLRAndroidManagement_SecurityPosture : GTLRObject

/**
 *  Device's security posture value.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_AtRisk This
 *        device may be more vulnerable to malicious actors than is recommended
 *        for use with corporate data. (Value: "AT_RISK")
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_PostureUnspecified
 *        Unspecified. There is no posture detail for this posture value.
 *        (Value: "POSTURE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_PotentiallyCompromised
 *        This device may be compromised and corporate data may be accessible to
 *        unauthorized actors. (Value: "POTENTIALLY_COMPROMISED")
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_Secure This
 *        device is secure. (Value: "SECURE")
 */
@property(nonatomic, copy, nullable) NSString *devicePosture;

/** Additional details regarding the security posture of the device. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PostureDetail *> *postureDetails;

@end


/**
 *  An action executed during setup.
 */
@interface GTLRAndroidManagement_SetupAction : GTLRObject

/**
 *  Description of this action.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *descriptionProperty;

/**
 *  An action to launch an app. The app will be launched with an intent
 *  containing an extra with key
 *  com.google.android.apps.work.clouddpc.EXTRA_LAUNCHED_AS_SETUP_ACTION set to
 *  the boolean value true to indicate that this is a setup action flow. If
 *  SetupAction references an app, the corresponding installType in the
 *  application policy must be set as REQUIRED_FOR_SETUP or said setup will
 *  fail.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LaunchAppAction *launchApp;

/** Title of this action. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *title;

@end


/**
 *  A resource containing sign in details for an enterprise. Use enterprises to
 *  manage SigninDetails for a given enterprise.For an enterprise, we can have
 *  any number of SigninDetails that is uniquely identified by combination of
 *  the following three fields (signin_url, allow_personal_usage, token_tag).
 *  One cannot create two SigninDetails with the same (signin_url,
 *  allow_personal_usage, token_tag). (token_tag is an optional field).Patch:
 *  The operation updates the current list of SigninDetails with the new list of
 *  SigninDetails. If the stored SigninDetail configuration is passed, it
 *  returns the same signin_enrollment_token and qr_code. If we pass multiple
 *  identical SigninDetail configurations that are not stored, it will store the
 *  first one amongst those SigninDetail configurations. if the configuration
 *  already exists we cannot request it more than once in a particular patch API
 *  call, otherwise it will give a duplicate key error and the whole operation
 *  will fail. If we remove certain SigninDetail configuration from the request
 *  then it will get removed from the storage. We can then request another
 *  signin_enrollment_token and qr_code for the same SigninDetail configuration.
 */
@interface GTLRAndroidManagement_SigninDetail : GTLRObject

/**
 *  Controls whether personal usage is allowed on a device provisioned with this
 *  enrollment token.For company-owned devices: Enabling personal usage allows
 *  the user to set up a work profile on the device. Disabling personal usage
 *  requires the user provision the device as a fully managed device.For
 *  personally-owned devices: Enabling personal usage allows the user to set up
 *  a work profile on the device. Disabling personal usage will prevent the
 *  device from provisioning. Personal usage cannot be disabled on
 *  personally-owned device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_AllowPersonalUsageUnspecified
 *        Personal usage restriction is not specified (Value:
 *        "ALLOW_PERSONAL_USAGE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageAllowed
 *        Personal usage is allowed (Value: "PERSONAL_USAGE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageDisallowed
 *        Personal usage is disallowed (Value: "PERSONAL_USAGE_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageDisallowedUserless
 *        Device is not associated with a single user, and thus both personal
 *        usage and corporate identity authentication are not expected. (Value:
 *        "PERSONAL_USAGE_DISALLOWED_USERLESS")
 */
@property(nonatomic, copy, nullable) NSString *allowPersonalUsage;

/**
 *  Optional. Whether the sign-in URL should be used by default for the
 *  enterprise. The SigninDetail with defaultStatus set to
 *  SIGNIN_DETAIL_IS_DEFAULT is used for Google account enrollment method. Only
 *  one of an enterprise's signinDetails can have defaultStatus set to
 *  SIGNIN_DETAIL_IS_DEFAULT. If an Enterprise has at least one signinDetails
 *  and none of them have defaultStatus set to SIGNIN_DETAIL_IS_DEFAULT then the
 *  first one from the list is selected and has set defaultStatus to
 *  SIGNIN_DETAIL_IS_DEFAULT. If no signinDetails specified for the Enterprise
 *  then the Google Account device enrollment will fail.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SigninDetail_DefaultStatus_SigninDetailDefaultStatusUnspecified
 *        Equivalent to SIGNIN_DETAIL_IS_NOT_DEFAULT. (Value:
 *        "SIGNIN_DETAIL_DEFAULT_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_DefaultStatus_SigninDetailIsDefault
 *        The sign-in URL will be used by default for the enterprise. (Value:
 *        "SIGNIN_DETAIL_IS_DEFAULT")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_DefaultStatus_SigninDetailIsNotDefault
 *        The sign-in URL will not be used by default for the enterprise.
 *        (Value: "SIGNIN_DETAIL_IS_NOT_DEFAULT")
 */
@property(nonatomic, copy, nullable) NSString *defaultStatus;

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/**
 *  An enterprise wide enrollment token used to trigger custom sign-in flow.
 *  This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *signinEnrollmentToken;

/**
 *  Sign-in URL for authentication when device is provisioned with a sign-in
 *  enrollment token. The sign-in endpoint should finish authentication flow
 *  with a URL in the form of https://enterprise.google.com/android/enroll?et=
 *  for a successful login, or
 *  https://enterprise.google.com/android/enroll/invalid for a failed login.
 */
@property(nonatomic, copy, nullable) NSString *signinUrl;

/**
 *  An EMM-specified metadata to distinguish between instances of SigninDetail.
 */
@property(nonatomic, copy, nullable) NSString *tokenTag;

@end


/**
 *  An enterprise signup URL.
 */
@interface GTLRAndroidManagement_SignupUrl : GTLRObject

/**
 *  The name of the resource. Use this value in the signupUrl field when calling
 *  enterprises.create to complete the enterprise signup flow.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A URL where an enterprise admin can register their enterprise. The page
 *  can't be rendered in an iframe.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Information about device software.
 */
@interface GTLRAndroidManagement_SoftwareInfo : GTLRObject

/**
 *  Android build ID string meant for displaying to the user. For example,
 *  shamu-userdebug 6.0.1 MOB30I 2756745 dev-keys.
 */
@property(nonatomic, copy, nullable) NSString *androidBuildNumber;

/** Build time. */
@property(nonatomic, strong, nullable) GTLRDateTime *androidBuildTime;

/**
 *  The Android Device Policy app version code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *androidDevicePolicyVersionCode;

/** The Android Device Policy app version as displayed to the user. */
@property(nonatomic, copy, nullable) NSString *androidDevicePolicyVersionName;

/** The user-visible Android version string. For example, 6.0.1. */
@property(nonatomic, copy, nullable) NSString *androidVersion;

/** The system bootloader version number, e.g. 0.6.7. */
@property(nonatomic, copy, nullable) NSString *bootloaderVersion;

/**
 *  SHA-256 hash of android.content.pm.Signature
 *  (https://developer.android.com/reference/android/content/pm/Signature.html)
 *  associated with the system package, which can be used to verify that the
 *  system build hasn't been modified.
 */
@property(nonatomic, copy, nullable) NSString *deviceBuildSignature;

/** Kernel version, for example, 2.6.32.9-g103d848. */
@property(nonatomic, copy, nullable) NSString *deviceKernelVersion;

/** An IETF BCP 47 language code for the primary locale on the device. */
@property(nonatomic, copy, nullable) NSString *primaryLanguageCode;

/** Security patch level, e.g. 2016-05-01. */
@property(nonatomic, copy, nullable) NSString *securityPatchLevel;

/** Information about a potential pending system update. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SystemUpdateInfo *systemUpdateInfo;

@end


/**
 *  Additional context for SpecificNonComplianceReason.
 */
@interface GTLRAndroidManagement_SpecificNonComplianceContext : GTLRObject

/**
 *  Additional context for non-compliance related to Wi-Fi configuration. See
 *  ONC_WIFI_INVALID_VALUE and ONC_WIFI_API_LEVEL
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_OncWifiContext *oncWifiContext;

/**
 *  Additional context for non-compliance related to password policies. See
 *  PASSWORD_POLICIES_PASSWORD_EXPIRED and
 *  PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PasswordPoliciesContext *passwordPoliciesContext;

@end


/**
 *  Parameters associated with the START_LOST_MODE command to put the device
 *  into lost mode. At least one of the parameters, not including the
 *  organization name, must be provided in order for the device to be put into
 *  lost mode.
 */
@interface GTLRAndroidManagement_StartLostModeParams : GTLRObject

/**
 *  The email address displayed to the user when the device is in lost mode.
 */
@property(nonatomic, copy, nullable) NSString *lostEmailAddress;

/** The message displayed to the user when the device is in lost mode. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *lostMessage;

/**
 *  The organization name displayed to the user when the device is in lost mode.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *lostOrganization;

/**
 *  The phone number that will be called when the device is in lost mode and the
 *  call owner button is tapped.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *lostPhoneNumber;

/**
 *  The street address displayed to the user when the device is in lost mode.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *lostStreetAddress;

@end


/**
 *  Status of the START_LOST_MODE command to put the device into lost mode.
 */
@interface GTLRAndroidManagement_StartLostModeStatus : GTLRObject

/**
 *  The status. See StartLostModeStatus.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_StartLostModeStatus_Status_AlreadyInLostMode
 *        The device is already in lost mode. (Value: "ALREADY_IN_LOST_MODE")
 *    @arg @c kGTLRAndroidManagement_StartLostModeStatus_Status_ResetPasswordRecently
 *        The device could not be put into lost mode because the admin reset the
 *        device's password recently. (Value: "RESET_PASSWORD_RECENTLY")
 *    @arg @c kGTLRAndroidManagement_StartLostModeStatus_Status_StatusUnspecified
 *        Unspecified. This value is not used. (Value: "STATUS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_StartLostModeStatus_Status_Success The
 *        device was put into lost mode. (Value: "SUCCESS")
 *    @arg @c kGTLRAndroidManagement_StartLostModeStatus_Status_UserExitLostModeRecently
 *        The device could not be put into lost mode because the user exited
 *        lost mode recently. (Value: "USER_EXIT_LOST_MODE_RECENTLY")
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). Each Status message contains three pieces of
 *  data: error code, error message, and error details.You can find out more
 *  about this error model and how to work with it in the API Design Guide
 *  (https://cloud.google.com/apis/design/errors).
 */
@interface GTLRAndroidManagement_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRAndroidManagement_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Status_Details_Item : GTLRObject
@end


/**
 *  Settings controlling the behavior of status reports.
 */
@interface GTLRAndroidManagement_StatusReportingSettings : GTLRObject

/**
 *  Application reporting settings. Only applicable if
 *  application_reports_enabled is true.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApplicationReportingSettings *applicationReportingSettings;

/**
 *  Whether app reports are enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationReportsEnabled;

/**
 *  Whether Common Criteria Mode reporting is enabled. This is supported only on
 *  company-owned devices.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *commonCriteriaModeEnabled;

/**
 *  Whether device settings reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deviceSettingsEnabled;

/**
 *  Whether displays reporting is enabled. Report data is not available for
 *  personally owned devices with work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayInfoEnabled;

/**
 *  Whether hardware status reporting is enabled. Report data is not available
 *  for personally owned devices with work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hardwareStatusEnabled;

/**
 *  Whether memory event reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryInfoEnabled;

/**
 *  Whether network info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkInfoEnabled;

/**
 *  Whether power management event reporting is enabled. Report data is not
 *  available for personally owned devices with work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *powerManagementEventsEnabled;

/**
 *  Whether software info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *softwareInfoEnabled;

/**
 *  Whether system properties reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *systemPropertiesEnabled;

@end


/**
 *  Parameters associated with the STOP_LOST_MODE command to take the device out
 *  of lost mode.
 */
@interface GTLRAndroidManagement_StopLostModeParams : GTLRObject
@end


/**
 *  Status of the STOP_LOST_MODE command to take the device out of lost mode.
 */
@interface GTLRAndroidManagement_StopLostModeStatus : GTLRObject

/**
 *  The status. See StopLostModeStatus.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_StopLostModeStatus_Status_NotInLostMode The
 *        device is not in lost mode. (Value: "NOT_IN_LOST_MODE")
 *    @arg @c kGTLRAndroidManagement_StopLostModeStatus_Status_StatusUnspecified
 *        Unspecified. This value is not used. (Value: "STATUS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_StopLostModeStatus_Status_Success The
 *        device was taken out of lost mode. (Value: "SUCCESS")
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  A lost mode event indicating the user has attempted to stop lost mode.
 */
@interface GTLRAndroidManagement_StopLostModeUserAttemptEvent : GTLRObject

/**
 *  The status of the attempt to stop lost mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_StopLostModeUserAttemptEvent_Status_AttemptFailed
 *        Indicates that the user's attempt to stop lost mode failed. (Value:
 *        "ATTEMPT_FAILED")
 *    @arg @c kGTLRAndroidManagement_StopLostModeUserAttemptEvent_Status_AttemptSucceeded
 *        Indicates that the user successfully stopped lost mode. (Value:
 *        "ATTEMPT_SUCCEEDED")
 *    @arg @c kGTLRAndroidManagement_StopLostModeUserAttemptEvent_Status_StatusUnspecified
 *        This value is not used. (Value: "STATUS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  Configuration for managing system updatesNote: Google Play system updates
 *  (https://source.android.com/docs/core/ota/modular-system) (also called
 *  Mainline updates) are automatically downloaded but require a device reboot
 *  to be installed. Refer to the mainline section in Manage system updates
 *  (https://developer.android.com/work/dpc/system-updates#mainline) for further
 *  details.
 */
@interface GTLRAndroidManagement_SystemUpdate : GTLRObject

/**
 *  If the type is WINDOWED, the end of the maintenance window, measured as the
 *  number of minutes after midnight in device's local time. This value must be
 *  between 0 and 1439, inclusive. If this value is less than start_minutes,
 *  then the maintenance window spans midnight. If the maintenance window
 *  specified is smaller than 30 minutes, the actual window is extended to 30
 *  minutes beyond the start time.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endMinutes;

/**
 *  An annually repeating time period in which over-the-air (OTA) system updates
 *  are postponed to freeze the OS version running on a device. To prevent
 *  freezing the device indefinitely, each freeze period must be separated by at
 *  least 60 days.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_FreezePeriod *> *freezePeriods;

/**
 *  If the type is WINDOWED, the start of the maintenance window, measured as
 *  the number of minutes after midnight in the device's local time. This value
 *  must be between 0 and 1439, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startMinutes;

/**
 *  The type of system update to configure.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Automatic Install
 *        automatically as soon as an update is available. (Value: "AUTOMATIC")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Postpone Postpone
 *        automatic install up to a maximum of 30 days. This policy does not
 *        affect security updates (e.g. monthly security patches). (Value:
 *        "POSTPONE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified
 *        Follow the default update behavior for the device, which typically
 *        requires the user to accept system updates. (Value:
 *        "SYSTEM_UPDATE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Windowed Install
 *        automatically within a daily maintenance window. This also configures
 *        Play apps to be updated within the window. This is strongly
 *        recommended for kiosk devices because this is the only way apps
 *        persistently pinned to the foreground can be updated by Play.If
 *        autoUpdateMode is set to AUTO_UPDATE_HIGH_PRIORITY for an app, then
 *        the maintenance window is ignored for that app and it is updated as
 *        soon as possible even outside of the maintenance window. (Value:
 *        "WINDOWED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Information about a potential pending system update.
 */
@interface GTLRAndroidManagement_SystemUpdateInfo : GTLRObject

/**
 *  The time when the update was first available. A zero value indicates that
 *  this field is not set. This field is set only if an update is available
 *  (that is, updateStatus is neither UPDATE_STATUS_UNKNOWN nor UP_TO_DATE).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateReceivedTime;

/**
 *  The status of an update: whether an update exists and what type it is.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_OsUpdateAvailable
 *        There is a pending OS update available. (Value: "OS_UPDATE_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_SecurityUpdateAvailable
 *        There is a pending security update available. (Value:
 *        "SECURITY_UPDATE_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UnknownUpdateAvailable
 *        There is a pending system update available, but its type is not known.
 *        (Value: "UNKNOWN_UPDATE_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpdateStatusUnknown
 *        It is unknown whether there is a pending system update. This happens
 *        when, for example, the device API level is less than 26, or if the
 *        version of Android Device Policy is outdated. (Value:
 *        "UPDATE_STATUS_UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpToDate
 *        There is no pending system update available on the device. (Value:
 *        "UP_TO_DATE")
 */
@property(nonatomic, copy, nullable) NSString *updateStatus;

@end


/**
 *  Telephony information associated with a given SIM card on the device. Only
 *  supported on fully managed devices starting from Android API level 23.
 */
@interface GTLRAndroidManagement_TelephonyInfo : GTLRObject

/** The carrier name associated with this SIM card. */
@property(nonatomic, copy, nullable) NSString *carrierName;

/** Output only. The ICCID associated with this SIM card. */
@property(nonatomic, copy, nullable) NSString *iccId;

/** The phone number associated with this SIM card. */
@property(nonatomic, copy, nullable) NSString *phoneNumber;

@end


/**
 *  A terms and conditions page to be accepted during provisioning.
 */
@interface GTLRAndroidManagement_TermsAndConditions : GTLRObject

/**
 *  A well-formatted HTML string. It will be parsed on the client with
 *  android.text.Html#fromHtml.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *content;

/** A short header which appears above the HTML content. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *header;

@end


/**
 *  Controls types of device activity logs collected from the device and
 *  reported via Pub/Sub notification
 *  (https://developers.google.com/android/management/notifications).
 */
@interface GTLRAndroidManagement_UsageLog : GTLRObject

/**
 *  Specifies which log types are enabled. Note that users will receive
 *  on-device messaging when usage logging is enabled.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledLogTypes;

/**
 *  Specifies which of the enabled log types can be uploaded over mobile data.
 *  By default logs are queued for upload when the device connects to WiFi.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *uploadOnCellularAllowed;

@end


/**
 *  An event logged on the device.
 */
@interface GTLRAndroidManagement_UsageLogEvent : GTLRObject

/**
 *  A shell command was issued over ADB via adb shell command. Part of
 *  SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AdbShellCommandEvent *adbShellCommandEvent;

/**
 *  An ADB interactive shell was opened via adb shell. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AdbShellInteractiveEvent *adbShellInteractiveEvent;

/** An app process was started. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AppProcessStartEvent *appProcessStartEvent;

/**
 *  A new root certificate was installed into the system's trusted credential
 *  storage. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CertAuthorityInstalledEvent *certAuthorityInstalledEvent;

/**
 *  A root certificate was removed from the system's trusted credential storage.
 *  Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CertAuthorityRemovedEvent *certAuthorityRemovedEvent;

/**
 *  An X.509v3 certificate failed to validate, currently this validation is
 *  performed on the Wi-FI access point and failure may be due to a mismatch
 *  upon server certificate validation. However it may in the future include
 *  other validation events of an X.509v3 certificate. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CertValidationFailureEvent *certValidationFailureEvent;

/**
 *  A TCP connect event was initiated through the standard network stack. Part
 *  of NETWORK_ACTIVITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ConnectEvent *connectEvent;

/**
 *  Validates whether Androids built-in cryptographic library (BoringSSL) is
 *  valid. Should always succeed on device boot, if it fails, the device should
 *  be considered untrusted. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CryptoSelfTestCompletedEvent *cryptoSelfTestCompletedEvent;

/**
 *  A DNS lookup event was initiated through the standard network stack. Part of
 *  NETWORK_ACTIVITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DnsEvent *dnsEvent;

/** Device has completed enrollment. Part of AMAPI_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_EnrollmentCompleteEvent *enrollmentCompleteEvent;

/**
 *  Unique id of the event.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *eventId;

/** Device timestamp when the event was logged. */
@property(nonatomic, strong, nullable) GTLRDateTime *eventTime;

/**
 *  The particular usage log event type that was reported on the device. Use
 *  this to determine which event field to access.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellCommand
 *        Indicates adb_shell_command_event has been set. (Value:
 *        "ADB_SHELL_COMMAND")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellInteractive
 *        Indicates adb_shell_interactive_event has been set. (Value:
 *        "ADB_SHELL_INTERACTIVE")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_AppProcessStart
 *        Indicates app_process_start_event has been set. (Value:
 *        "APP_PROCESS_START")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityInstalled
 *        Indicates cert_authority_installed_event has been set. (Value:
 *        "CERT_AUTHORITY_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityRemoved
 *        Indicates cert_authority_removed_event has been set. (Value:
 *        "CERT_AUTHORITY_REMOVED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CertValidationFailure
 *        Indicates cert_validation_failure_event has been set. (Value:
 *        "CERT_VALIDATION_FAILURE")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_Connect Indicates
 *        connect_event has been set. (Value: "CONNECT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CryptoSelfTestCompleted
 *        Indicates crypto_self_test_completed_event has been set. (Value:
 *        "CRYPTO_SELF_TEST_COMPLETED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_Dns Indicates
 *        dns_event has been set. (Value: "DNS")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_EnrollmentComplete
 *        Indicates enrollment_complete_event has been set. (Value:
 *        "ENROLLMENT_COMPLETE")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_EventTypeUnspecified
 *        This value is not used (Value: "EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_FilePulled
 *        Indicates file_pulled_event has been set. (Value: "FILE_PULLED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_FilePushed
 *        Indicates file_pushed_event has been set. (Value: "FILE_PUSHED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyDestruction
 *        Indicates key_destruction_event has been set. (Value:
 *        "KEY_DESTRUCTION")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyGenerated
 *        Indicates key_generated_event has been set. (Value: "KEY_GENERATED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissAuthAttempt
 *        Indicates keyguard_dismiss_auth_attempt_event has been set. (Value:
 *        "KEYGUARD_DISMISS_AUTH_ATTEMPT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissed
 *        Indicates keyguard_dismissed_event has been set. (Value:
 *        "KEYGUARD_DISMISSED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardSecured
 *        Indicates keyguard_secured_event has been set. (Value:
 *        "KEYGUARD_SECURED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyImport Indicates
 *        key_import_event has been set. (Value: "KEY_IMPORT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyIntegrityViolation
 *        Indicates key_integrity_violation_event has been set. (Value:
 *        "KEY_INTEGRITY_VIOLATION")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LogBufferSizeCritical
 *        Indicates log_buffer_size_critical_event has been set. (Value:
 *        "LOG_BUFFER_SIZE_CRITICAL")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStarted
 *        Indicates logging_started_event has been set. (Value:
 *        "LOGGING_STARTED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStopped
 *        Indicates logging_stopped_event has been set. (Value:
 *        "LOGGING_STOPPED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LostModeLocation
 *        Indicates lostModeLocationEvent has been set. (Value:
 *        "LOST_MODE_LOCATION")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LostModeOutgoingPhoneCall
 *        Indicates lostModeOutgoingPhoneCallEvent has been set. (Value:
 *        "LOST_MODE_OUTGOING_PHONE_CALL")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_MediaMount
 *        Indicates media_mount_event has been set. (Value: "MEDIA_MOUNT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_MediaUnmount
 *        Indicates media_unmount_event has been set. (Value: "MEDIA_UNMOUNT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_OsShutdown
 *        Indicates os_shutdown_event has been set. (Value: "OS_SHUTDOWN")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_OsStartup Indicates
 *        os_startup_event has been set. (Value: "OS_STARTUP")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_RemoteLock
 *        Indicates remote_lock_event has been set. (Value: "REMOTE_LOCK")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_StopLostModeUserAttempt
 *        Indicates stopLostModeUserAttemptEvent has been set. (Value:
 *        "STOP_LOST_MODE_USER_ATTEMPT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_WipeFailure
 *        Indicates wipe_failure_event has been set. (Value: "WIPE_FAILURE")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

/** A file was downloaded from the device. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_FilePulledEvent *filePulledEvent;

/** A file was uploaded onto the device. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_FilePushedEvent *filePushedEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is removed from the device either by the user or
 *  management. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyDestructionEvent *keyDestructionEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is installed on the device either by the user or
 *  management. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyGeneratedEvent *keyGeneratedEvent;

/** An attempt was made to unlock the device. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyguardDismissAuthAttemptEvent *keyguardDismissAuthAttemptEvent;

/** The keyguard was dismissed. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyguardDismissedEvent *keyguardDismissedEvent;

/** The device was locked either by user or timeout. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyguardSecuredEvent *keyguardSecuredEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is imported on the device either by the user or
 *  management. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyImportEvent *keyImportEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is determined to be corrupted due to storage
 *  corruption, hardware failure or some OS issue. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyIntegrityViolationEvent *keyIntegrityViolationEvent;

/**
 *  The audit log buffer has reached 90% of its capacity, therefore older events
 *  may be dropped. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LogBufferSizeCriticalEvent *logBufferSizeCriticalEvent;

/** usageLog policy has been enabled. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LoggingStartedEvent *loggingStartedEvent;

/** usageLog policy has been disabled. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LoggingStoppedEvent *loggingStoppedEvent;

/** A lost mode location update when a device in lost mode. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LostModeLocationEvent *lostModeLocationEvent;

/** An outgoing phone call has been made when a device in lost mode. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LostModeOutgoingPhoneCallEvent *lostModeOutgoingPhoneCallEvent;

/** Removable media was mounted. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MediaMountEvent *mediaMountEvent;

/** Removable media was unmounted. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MediaUnmountEvent *mediaUnmountEvent;

/** Device was shutdown. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_OsShutdownEvent *osShutdownEvent;

/** Device was started. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_OsStartupEvent *osStartupEvent;

/**
 *  The device or profile has been remotely locked via the LOCK command. Part of
 *  SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_RemoteLockEvent *remoteLockEvent;

/** An attempt to take a device out of lost mode. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StopLostModeUserAttemptEvent *stopLostModeUserAttemptEvent;

/**
 *  The work profile or company-owned device failed to wipe when requested. This
 *  could be user initiated or admin initiated e.g. delete was received. Part of
 *  SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_WipeFailureEvent *wipeFailureEvent;

@end


/**
 *  A user belonging to an enterprise.
 */
@interface GTLRAndroidManagement_User : GTLRObject

/**
 *  A unique identifier you create for this user, such as user342 or
 *  asset#44418. This field must be set when the user is created and can't be
 *  updated. This field must not contain personally identifiable information
 *  (PII). This identifier must be 1024 characters or less; otherwise, the
 *  update policy request will fail.
 */
@property(nonatomic, copy, nullable) NSString *accountIdentifier;

@end


/**
 *  Provides a user-facing message with locale info. The maximum message length
 *  is 4096 characters.
 */
@interface GTLRAndroidManagement_UserFacingMessage : GTLRObject

/**
 *  The default message displayed if no localized message is specified or the
 *  user's locale doesn't match with any of the localized messages. A default
 *  message must be provided if any localized messages are provided.
 */
@property(nonatomic, copy, nullable) NSString *defaultMessage;

/**
 *  A map containing pairs, where locale is a well-formed BCP 47 language
 *  (https://www.w3.org/International/articles/language-tags/) code, such as
 *  en-US, es-ES, or fr.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage_LocalizedMessages *localizedMessages;

@end


/**
 *  A map containing pairs, where locale is a well-formed BCP 47 language
 *  (https://www.w3.org/International/articles/language-tags/) code, such as
 *  en-US, es-ES, or fr.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_UserFacingMessage_LocalizedMessages : GTLRObject
@end


/**
 *  A web app.
 */
@interface GTLRAndroidManagement_WebApp : GTLRObject

/**
 *  The display mode of the web app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_DisplayModeUnspecified
 *        Not used. (Value: "DISPLAY_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_FullScreen Opens the web
 *        app in full screen without any visible controls. The browser UI
 *        elements, page URL, system status bar and back button are not visible,
 *        and the web app takes up the entirety of the available display area.
 *        (Value: "FULL_SCREEN")
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_MinimalUi Opens the web
 *        app with a minimal set of browser UI elements for controlling
 *        navigation and viewing the page URL. (Value: "MINIMAL_UI")
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_Standalone Opens the web
 *        app to look and feel like a standalone native application. The browser
 *        UI elements and page URL are not visible, however the system status
 *        bar and back button are visible. (Value: "STANDALONE")
 */
@property(nonatomic, copy, nullable) NSString *displayMode;

/** A list of icons for the web app. Must have at least one element. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_WebAppIcon *> *icons;

/**
 *  The name of the web app, which is generated by the server during creation in
 *  the form enterprises/{enterpriseId}/webApps/{packageName}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The start URL, i.e. the URL that should load when the user opens the
 *  application.
 */
@property(nonatomic, copy, nullable) NSString *startUrl;

/**
 *  The title of the web app as displayed to the user (e.g., amongst a list of
 *  other applications, or as a label for an icon).
 */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  The current version of the app.Note that the version can automatically
 *  increase during the lifetime of the web app, while Google does internal
 *  housekeeping to keep the web app up-to-date.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

@end


/**
 *  An icon for a web app. Supported formats are: png, jpg and webp.
 */
@interface GTLRAndroidManagement_WebAppIcon : GTLRObject

/**
 *  The actual bytes of the image in a base64url encoded string (c.f. RFC4648,
 *  section 5 "Base 64 Encoding with URL and Filename Safe Alphabet"). - The
 *  image type can be png or jpg. - The image should ideally be square. - The
 *  image should ideally have a size of 512x512.
 */
@property(nonatomic, copy, nullable) NSString *imageData;

@end


/**
 *  A web token used to access the managed Google Play iframe.
 */
@interface GTLRAndroidManagement_WebToken : GTLRObject

/**
 *  The features to enable. Use this if you want to control exactly which
 *  feature(s) will be activated; leave empty to allow all features.Restrictions
 *  / things to note: - If no features are listed here, all features are enabled
 *   this is the default behavior where you give access to all features to your
 *  admins. - This must not contain any FEATURE_UNSPECIFIED values. - Repeated
 *  values are ignored
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledFeatures;

/**
 *  The name of the web token, which is generated by the server during creation
 *  in the form enterprises/{enterpriseId}/webTokens/{webTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The URL of the parent frame hosting the iframe with the embedded UI. To
 *  prevent XSS, the iframe may not be hosted at other URLs. The URL must use
 *  the https scheme.
 */
@property(nonatomic, copy, nullable) NSString *parentFrameUrl;

/**
 *  Permissions available to an admin in the embedded UI. An admin must have all
 *  of these permissions in order to view the UI. This field is deprecated.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions GTLR_DEPRECATED;

/**
 *  The token value which is used in the hosting page to generate the iframe
 *  with the embedded UI. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Represents a Wi-Fi SSID.
 */
@interface GTLRAndroidManagement_WifiSsid : GTLRObject

/** Required. Wi-Fi SSID represented as a string. */
@property(nonatomic, copy, nullable) NSString *wifiSsid;

@end


/**
 *  Restrictions on which Wi-Fi SSIDs the device can connect to. Note that this
 *  does not affect which networks can be configured on the device. Supported on
 *  company-owned devices running Android 13 and above.
 */
@interface GTLRAndroidManagement_WifiSsidPolicy : GTLRObject

/**
 *  Type of the Wi-Fi SSID policy to be applied.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_WifiSsidPolicy_WifiSsidPolicyType_WifiSsidAllowlist
 *        The device can make Wi-Fi connections only to the SSIDs in wifiSsids.
 *        wifiSsids must not be empty. The device will not be able to connect to
 *        any other Wi-Fi network. (Value: "WIFI_SSID_ALLOWLIST")
 *    @arg @c kGTLRAndroidManagement_WifiSsidPolicy_WifiSsidPolicyType_WifiSsidDenylist
 *        The device cannot connect to any Wi-Fi network whose SSID is in
 *        wifiSsids, but can connect to other networks. (Value:
 *        "WIFI_SSID_DENYLIST")
 *    @arg @c kGTLRAndroidManagement_WifiSsidPolicy_WifiSsidPolicyType_WifiSsidPolicyTypeUnspecified
 *        Defaults to WIFI_SSID_DENYLIST. wifiSsids must not be set. There are
 *        no restrictions on which SSID the device can connect to. (Value:
 *        "WIFI_SSID_POLICY_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *wifiSsidPolicyType;

/**
 *  Optional. List of Wi-Fi SSIDs that should be applied in the policy. This
 *  field must be non-empty when WifiSsidPolicyType is set to
 *  WIFI_SSID_ALLOWLIST. If this is set to a non-empty list, then a
 *  nonComplianceDetail detail with API_LEVEL is reported if the Android version
 *  is less than 13 and a nonComplianceDetail with MANAGEMENT_MODE is reported
 *  for non-company-owned devices.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_WifiSsid *> *wifiSsids;

@end


/**
 *  An action to reset a company owned device or delete a work profile. Note:
 *  blockAction must also be specified.
 */
@interface GTLRAndroidManagement_WipeAction : GTLRObject

/**
 *  Whether the factory-reset protection data is preserved on the device. This
 *  setting doesnt apply to work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preserveFrp;

/**
 *  Number of days the policy is non-compliant before the device or work profile
 *  is wiped. wipeAfterDays must be greater than blockAfterDays.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wipeAfterDays;

@end


/**
 *  The work profile or company-owned device failed to wipe when requested. This
 *  could be user initiated or admin initiated e.g. delete was received.
 *  Intentionally empty.
 */
@interface GTLRAndroidManagement_WipeFailureEvent : GTLRObject
@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
