// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Android Management API (androidmanagement/v1)
// Description:
//   The Android Management API provides remote enterprise management of Android
//   devices and apps.
// Documentation:
//   https://developers.google.com/android/management

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAndroidManagement_AdbShellCommandEvent;
@class GTLRAndroidManagement_AdbShellInteractiveEvent;
@class GTLRAndroidManagement_AdvancedSecurityOverrides;
@class GTLRAndroidManagement_AlwaysOnVpnPackage;
@class GTLRAndroidManagement_ApiLevelCondition;
@class GTLRAndroidManagement_ApplicationEvent;
@class GTLRAndroidManagement_ApplicationPermission;
@class GTLRAndroidManagement_ApplicationPolicy;
@class GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration;
@class GTLRAndroidManagement_ApplicationReport;
@class GTLRAndroidManagement_ApplicationReportingSettings;
@class GTLRAndroidManagement_AppProcessInfo;
@class GTLRAndroidManagement_AppProcessStartEvent;
@class GTLRAndroidManagement_AppTrackInfo;
@class GTLRAndroidManagement_AppVersion;
@class GTLRAndroidManagement_BlockAction;
@class GTLRAndroidManagement_CertAuthorityInstalledEvent;
@class GTLRAndroidManagement_CertAuthorityRemovedEvent;
@class GTLRAndroidManagement_CertValidationFailureEvent;
@class GTLRAndroidManagement_ChoosePrivateKeyRule;
@class GTLRAndroidManagement_ClearAppsDataParams;
@class GTLRAndroidManagement_ClearAppsDataStatus;
@class GTLRAndroidManagement_ClearAppsDataStatus_Results;
@class GTLRAndroidManagement_CommonCriteriaModeInfo;
@class GTLRAndroidManagement_ComplianceRule;
@class GTLRAndroidManagement_ConnectEvent;
@class GTLRAndroidManagement_ContactInfo;
@class GTLRAndroidManagement_ContentProviderEndpoint;
@class GTLRAndroidManagement_CrossProfilePolicies;
@class GTLRAndroidManagement_CryptoSelfTestCompletedEvent;
@class GTLRAndroidManagement_Date;
@class GTLRAndroidManagement_Device;
@class GTLRAndroidManagement_Device_SystemProperties;
@class GTLRAndroidManagement_DeviceSettings;
@class GTLRAndroidManagement_Display;
@class GTLRAndroidManagement_DnsEvent;
@class GTLRAndroidManagement_EnrollmentToken;
@class GTLRAndroidManagement_Enterprise;
@class GTLRAndroidManagement_ExtensionConfig;
@class GTLRAndroidManagement_ExternalData;
@class GTLRAndroidManagement_FilePulledEvent;
@class GTLRAndroidManagement_FilePushedEvent;
@class GTLRAndroidManagement_FreezePeriod;
@class GTLRAndroidManagement_HardwareInfo;
@class GTLRAndroidManagement_HardwareStatus;
@class GTLRAndroidManagement_KeyDestructionEvent;
@class GTLRAndroidManagement_KeyedAppState;
@class GTLRAndroidManagement_KeyGeneratedEvent;
@class GTLRAndroidManagement_KeyguardDismissAuthAttemptEvent;
@class GTLRAndroidManagement_KeyguardDismissedEvent;
@class GTLRAndroidManagement_KeyguardSecuredEvent;
@class GTLRAndroidManagement_KeyImportEvent;
@class GTLRAndroidManagement_KeyIntegrityViolationEvent;
@class GTLRAndroidManagement_KioskCustomization;
@class GTLRAndroidManagement_LaunchAppAction;
@class GTLRAndroidManagement_LogBufferSizeCriticalEvent;
@class GTLRAndroidManagement_LoggingStartedEvent;
@class GTLRAndroidManagement_LoggingStoppedEvent;
@class GTLRAndroidManagement_ManagedConfigurationTemplate;
@class GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables;
@class GTLRAndroidManagement_ManagedProperty;
@class GTLRAndroidManagement_ManagedPropertyEntry;
@class GTLRAndroidManagement_MediaMountEvent;
@class GTLRAndroidManagement_MediaUnmountEvent;
@class GTLRAndroidManagement_MemoryEvent;
@class GTLRAndroidManagement_MemoryInfo;
@class GTLRAndroidManagement_NetworkInfo;
@class GTLRAndroidManagement_NonComplianceDetail;
@class GTLRAndroidManagement_NonComplianceDetailCondition;
@class GTLRAndroidManagement_OncCertificateProvider;
@class GTLRAndroidManagement_OncWifiContext;
@class GTLRAndroidManagement_Operation;
@class GTLRAndroidManagement_Operation_Metadata;
@class GTLRAndroidManagement_Operation_Response;
@class GTLRAndroidManagement_OsShutdownEvent;
@class GTLRAndroidManagement_OsStartupEvent;
@class GTLRAndroidManagement_PackageNameList;
@class GTLRAndroidManagement_PasswordPoliciesContext;
@class GTLRAndroidManagement_PasswordRequirements;
@class GTLRAndroidManagement_PerAppResult;
@class GTLRAndroidManagement_PermissionGrant;
@class GTLRAndroidManagement_PersistentPreferredActivity;
@class GTLRAndroidManagement_PersonalApplicationPolicy;
@class GTLRAndroidManagement_PersonalUsagePolicies;
@class GTLRAndroidManagement_Policy;
@class GTLRAndroidManagement_Policy_OpenNetworkConfiguration;
@class GTLRAndroidManagement_PolicyEnforcementRule;
@class GTLRAndroidManagement_PostureDetail;
@class GTLRAndroidManagement_PowerManagementEvent;
@class GTLRAndroidManagement_ProxyInfo;
@class GTLRAndroidManagement_RemoteLockEvent;
@class GTLRAndroidManagement_SecurityPosture;
@class GTLRAndroidManagement_SetupAction;
@class GTLRAndroidManagement_SigninDetail;
@class GTLRAndroidManagement_SoftwareInfo;
@class GTLRAndroidManagement_SpecificNonComplianceContext;
@class GTLRAndroidManagement_Status;
@class GTLRAndroidManagement_Status_Details_Item;
@class GTLRAndroidManagement_StatusReportingSettings;
@class GTLRAndroidManagement_SystemUpdate;
@class GTLRAndroidManagement_SystemUpdateInfo;
@class GTLRAndroidManagement_TelephonyInfo;
@class GTLRAndroidManagement_TermsAndConditions;
@class GTLRAndroidManagement_UsageLog;
@class GTLRAndroidManagement_UsageLogEvent;
@class GTLRAndroidManagement_User;
@class GTLRAndroidManagement_UserFacingMessage;
@class GTLRAndroidManagement_UserFacingMessage_LocalizedMessages;
@class GTLRAndroidManagement_WebApp;
@class GTLRAndroidManagement_WebAppIcon;
@class GTLRAndroidManagement_WipeAction;
@class GTLRAndroidManagement_WipeFailureEvent;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.commonCriteriaMode

/**
 *  Default. Disables Common Criteria Mode.
 *
 *  Value: "COMMON_CRITERIA_MODE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeDisabled;
/**
 *  Enables Common Criteria Mode.
 *
 *  Value: "COMMON_CRITERIA_MODE_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeEnabled;
/**
 *  Unspecified. Defaults to COMMON_CRITERIA_MODE_DISABLED.
 *
 *  Value: "COMMON_CRITERIA_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.developerSettings

/**
 *  Allows all developer settings. The user can access and optionally configure
 *  the settings.
 *
 *  Value: "DEVELOPER_SETTINGS_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsAllowed;
/**
 *  Default. Disables all developer settings and prevents the user from
 *  accessing them.
 *
 *  Value: "DEVELOPER_SETTINGS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsDisabled;
/**
 *  Unspecified. Defaults to DEVELOPER_SETTINGS_DISABLED.
 *
 *  Value: "DEVELOPER_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.googlePlayProtectVerifyApps

/**
 *  Unspecified. Defaults to VERIFY_APPS_ENFORCED.
 *
 *  Value: "GOOGLE_PLAY_PROTECT_VERIFY_APPS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_GooglePlayProtectVerifyAppsUnspecified;
/**
 *  Default. Force-enables app verification.
 *
 *  Value: "VERIFY_APPS_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsEnforced;
/**
 *  Allows the user to choose whether to enable app verification.
 *
 *  Value: "VERIFY_APPS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_AdvancedSecurityOverrides.untrustedAppsPolicy

/**
 *  Allow untrusted app installs on entire device.
 *
 *  Value: "ALLOW_INSTALL_DEVICE_WIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallDeviceWide;
/**
 *  For devices with work profiles, allow untrusted app installs in the device's
 *  personal profile only.
 *
 *  Value: "ALLOW_INSTALL_IN_PERSONAL_PROFILE_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallInPersonalProfileOnly;
/**
 *  Default. Disallow untrusted app installs on entire device.
 *
 *  Value: "DISALLOW_INSTALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_DisallowInstall;
/**
 *  Unspecified. Defaults to DISALLOW_INSTALL.
 *
 *  Value: "UNTRUSTED_APPS_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_UntrustedAppsPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.appPricing

/**
 *  Unknown pricing, used to denote an approved app that is not generally
 *  available.
 *
 *  Value: "APP_PRICING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_AppPricingUnspecified;
/**
 *  The app is free.
 *
 *  Value: "FREE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_Free;
/**
 *  The app is free, but offers in-app purchases.
 *
 *  Value: "FREE_WITH_IN_APP_PURCHASE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_FreeWithInAppPurchase;
/**
 *  The app is paid.
 *
 *  Value: "PAID"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_AppPricing_Paid;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.contentRating

/**
 *  Unspecified.
 *
 *  Value: "CONTENT_RATING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_ContentRatingUnspecified;
/**
 *  Content suitable for ages 18 and above only.
 *
 *  Value: "EIGHTEEN_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_EighteenYears;
/**
 *  Content suitable for ages 7 and above only.
 *
 *  Value: "SEVEN_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_SevenYears;
/**
 *  Content suitable for ages 16 and above only.
 *
 *  Value: "SIXTEEN_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_SixteenYears;
/**
 *  Content suitable for ages 3 and above only.
 *
 *  Value: "THREE_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_ThreeYears;
/**
 *  Content suitable for ages 12 and above only.
 *
 *  Value: "TWELVE_YEARS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_ContentRating_TwelveYears;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.distributionChannel

/**
 *  Unspecified.
 *
 *  Value: "DISTRIBUTION_CHANNEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_DistributionChannelUnspecified;
/**
 *  Package is a private app (restricted to an enterprise) but hosted by Google.
 *
 *  Value: "PRIVATE_GOOGLE_HOSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_PrivateGoogleHosted;
/**
 *  Private app (restricted to an enterprise) and is privately hosted.
 *
 *  Value: "PRIVATE_SELF_HOSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_PrivateSelfHosted;
/**
 *  Package is available through the Play store and not restricted to a specific
 *  enterprise.
 *
 *  Value: "PUBLIC_GOOGLE_HOSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_DistributionChannel_PublicGoogleHosted;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Application.features

/**
 *  Unspecified.
 *
 *  Value: "APP_FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_Features_AppFeatureUnspecified;
/**
 *  The app is a VPN.
 *
 *  Value: "VPN_APP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Application_Features_VpnApp;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationEvent.eventType

/**
 *  This value is disallowed.
 *
 *  Value: "APPLICATION_EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_ApplicationEventTypeUnspecified;
/**
 *  The app was changed, for example, a component was enabled or disabled.
 *
 *  Value: "CHANGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Changed;
/**
 *  The app data was cleared.
 *
 *  Value: "DATA_CLEARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_DataCleared;
/**
 *  The app was installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Installed;
/**
 *  The app was pinned to the foreground.
 *
 *  Value: "PINNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Pinned;
/**
 *  The app was removed.
 *
 *  Value: "REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Removed;
/**
 *  A new version of the app has been installed, replacing the old version.
 *
 *  Value: "REPLACED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Replaced;
/**
 *  The app was restarted.
 *
 *  Value: "RESTARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Restarted;
/**
 *  The app was unpinned.
 *
 *  Value: "UNPINNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Unpinned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.alwaysOnVpnLockdownExemption

/**
 *  Unspecified. Defaults to VPN_LOCKDOWN_ENFORCED.
 *
 *  Value: "ALWAYS_ON_VPN_LOCKDOWN_EXEMPTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_AlwaysOnVpnLockdownExemptionUnspecified;
/**
 *  The app respects the always-on VPN lockdown setting.
 *
 *  Value: "VPN_LOCKDOWN_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownEnforced;
/**
 *  The app is exempt from the always-on VPN lockdown setting.
 *
 *  Value: "VPN_LOCKDOWN_EXEMPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownExemption;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.autoUpdateMode

/**
 *  The app is automatically updated with low priority to minimize the impact on
 *  the user.The app is updated when all of the following constraints are met:
 *  The device is not actively used. The device is connected to an unmetered
 *  network. The device is charging.The device is notified about a new update
 *  within 24 hours after it is published by the developer, after which the app
 *  is updated the next time the constraints above are met.
 *
 *  Value: "AUTO_UPDATE_DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateDefault;
/**
 *  The app is updated as soon as possible. No constraints are applied.The
 *  device is notified immediately about a new update after it becomes
 *  available.
 *
 *  Value: "AUTO_UPDATE_HIGH_PRIORITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateHighPriority;
/**
 *  Unspecified. Defaults to AUTO_UPDATE_DEFAULT.
 *
 *  Value: "AUTO_UPDATE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateModeUnspecified;
/**
 *  The app is not automatically updated for a maximum of 90 days after the app
 *  becomes out of date.90 days after the app becomes out of date, the latest
 *  available version is installed automatically with low priority (see
 *  AUTO_UPDATE_DEFAULT). After the app is updated it is not automatically
 *  updated again until 90 days after it becomes out of date again.The user can
 *  still manually update the app from the Play Store at any time.
 *
 *  Value: "AUTO_UPDATE_POSTPONED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdatePostponed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.connectedWorkAndPersonalApp

/**
 *  Allows the app to communicate across profiles after receiving user consent.
 *
 *  Value: "CONNECTED_WORK_AND_PERSONAL_APP_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppAllowed;
/**
 *  Default. Prevents the app from communicating cross-profile.
 *
 *  Value: "CONNECTED_WORK_AND_PERSONAL_APP_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppDisallowed;
/**
 *  Unspecified. Defaults to CONNECTED_WORK_AND_PERSONAL_APPS_DISALLOWED.
 *
 *  Value: "CONNECTED_WORK_AND_PERSONAL_APP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.delegatedScopes

/**
 *  Grants access to blocking uninstallation.
 *
 *  Value: "BLOCK_UNINSTALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_BlockUninstall;
/**
 *  Grants access to certificate installation and management.
 *
 *  Value: "CERT_INSTALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_CertInstall;
/**
 *  No delegation scope specified.
 *
 *  Value: "DELEGATED_SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_DelegatedScopeUnspecified;
/**
 *  Grants access for enabling system apps.
 *
 *  Value: "ENABLE_SYSTEM_APP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_EnableSystemApp;
/**
 *  Grants access to managed configurations management.
 *
 *  Value: "MANAGED_CONFIGURATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_ManagedConfigurations;
/**
 *  Grants access to network activity logs. Allows the delegated application to
 *  call setNetworkLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#setNetworkLoggingEnabled%28android.content.ComponentName,%20boolean%29),
 *  isNetworkLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#isNetworkLoggingEnabled%28android.content.ComponentName%29)
 *  and retrieveNetworkLogs
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#retrieveNetworkLogs%28android.content.ComponentName,%20long%29)
 *  methods. This scope can be delegated to at most one application. Supported
 *  for fully managed devices on Android 10 and above. Supported for a work
 *  profile on Android 12 and above. When delegation is supported and set,
 *  NETWORK_ACTIVITY_LOGS is ignored.
 *
 *  Value: "NETWORK_ACTIVITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_NetworkActivityLogs;
/**
 *  Grants access to package access state.
 *
 *  Value: "PACKAGE_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_PackageAccess;
/**
 *  Grants access to permission policy and permission grant state.
 *
 *  Value: "PERMISSION_GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_PermissionGrant;
/**
 *  Grants access to security logs. Allows the delegated application to call
 *  setSecurityLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#setSecurityLoggingEnabled%28android.content.ComponentName,%20boolean%29),
 *  isSecurityLoggingEnabled
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#isSecurityLoggingEnabled%28android.content.ComponentName%29),
 *  retrieveSecurityLogs
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#retrieveSecurityLogs%28android.content.ComponentName%29)
 *  and retrievePreRebootSecurityLogs
 *  (https://developer.android.com/reference/android/app/admin/DevicePolicyManager#retrievePreRebootSecurityLogs%28android.content.ComponentName%29)
 *  methods. This scope can be delegated to at most one application. Supported
 *  for fully managed devices and company-owned devices with a work profile on
 *  Android 12 and above. When delegation is supported and set, SECURITY_LOGS is
 *  ignored.
 *
 *  Value: "SECURITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_SecurityLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.installType

/**
 *  The app is available to install.
 *
 *  Value: "AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Available;
/**
 *  The app is blocked and can't be installed. If the app was installed under a
 *  previous policy, it will be uninstalled.
 *
 *  Value: "BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Blocked;
/**
 *  The app is automatically installed and can't be removed by the user.
 *
 *  Value: "FORCE_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled;
/**
 *  Unspecified. Defaults to AVAILABLE.
 *
 *  Value: "INSTALL_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified;
/**
 *  The app is automatically installed in kiosk mode: it's set as the preferred
 *  home intent and whitelisted for lock task mode. Device setup won't complete
 *  until the app is installed. After installation, users won't be able to
 *  remove the app. You can only set this installType for one app per policy.
 *  When this is present in the policy, status bar will be automatically
 *  disabled.
 *
 *  Value: "KIOSK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Kiosk;
/**
 *  The app is automatically installed and can be removed by the user.
 *
 *  Value: "PREINSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled;
/**
 *  The app is automatically installed and can't be removed by the user and will
 *  prevent setup from completion until installation is complete.
 *
 *  Value: "REQUIRED_FOR_SETUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_RequiredForSetup;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.applicationSource

/**
 *  The app was sideloaded from an unspecified source.
 *
 *  Value: "APPLICATION_SOURCE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_ApplicationSourceUnspecified;
/**
 *  The app was installed from the Google Play Store.
 *
 *  Value: "INSTALLED_FROM_PLAY_STORE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_InstalledFromPlayStore;
/**
 *  This is a system app from the device's factory image.
 *
 *  Value: "SYSTEM_APP_FACTORY_VERSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppFactoryVersion;
/**
 *  This is an updated system app.
 *
 *  Value: "SYSTEM_APP_UPDATED_VERSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppUpdatedVersion;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.state

/**
 *  App state is unspecified
 *
 *  Value: "APPLICATION_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_ApplicationStateUnspecified;
/**
 *  App is installed on the device
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_Installed;
/**
 *  App was removed from the device
 *
 *  Value: "REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_Removed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_BlockAction.blockScope

/**
 *  Block action is applied to the entire device, including apps in the personal
 *  profile.
 *
 *  Value: "BLOCK_SCOPE_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeDevice;
/**
 *  Unspecified. Defaults to BLOCK_SCOPE_WORK_PROFILE.
 *
 *  Value: "BLOCK_SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeUnspecified;
/**
 *  Block action is only applied to apps in the work profile. Apps in the
 *  personal profile are unaffected.
 *
 *  Value: "BLOCK_SCOPE_WORK_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeWorkProfile;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.errorCode

/**
 *  The API level of the device does not support this command.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_ApiLevel;
/**
 *  There was no error.
 *
 *  Value: "COMMAND_ERROR_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_CommandErrorCodeUnspecified;
/**
 *  The command has an invalid parameter value.
 *
 *  Value: "INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) does not support the
 *  command.
 *
 *  Value: "MANAGEMENT_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_ManagementMode;
/**
 *  An unknown error occurred.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_Unknown;
/**
 *  The device doesn't support the command. Updating Android Device Policy to
 *  the latest version may resolve the issue.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_Unsupported;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.resetPasswordFlags

/**
 *  Don't ask for user credentials on device boot.
 *
 *  Value: "DO_NOT_ASK_CREDENTIALS_ON_BOOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_DoNotAskCredentialsOnBoot;
/**
 *  Lock the device after password reset.
 *
 *  Value: "LOCK_NOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_LockNow;
/**
 *  Don't allow other admins to change the password again until the user has
 *  entered it.
 *
 *  Value: "REQUIRE_ENTRY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_RequireEntry;
/**
 *  This value is ignored.
 *
 *  Value: "RESET_PASSWORD_FLAG_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_ResetPasswordFlagUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.type

/**
 *  Clears the application data of specified apps. This is supported on Android
 *  9 and above. Note that an application can store data outside of its
 *  application data, for example in external storage or in a user dictionary.
 *  See also clear_apps_data_params.
 *
 *  Value: "CLEAR_APP_DATA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_ClearAppData;
/**
 *  This value is disallowed.
 *
 *  Value: "COMMAND_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified;
/**
 *  Lock the device, as if the lock screen timeout had expired.
 *
 *  Value: "LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Lock;
/**
 *  Reboot the device. Only supported on fully managed devices running Android
 *  7.0 (API level 24) or higher.
 *
 *  Value: "REBOOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Reboot;
/**
 *  Removes the work profile and all policies from a company-owned Android 8.0+
 *  device, relinquishing the device for personal use. Apps and data associated
 *  with the personal profile(s) are preserved. The device will be deleted from
 *  the server after it acknowledges the command.
 *
 *  Value: "RELINQUISH_OWNERSHIP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_RelinquishOwnership;
/**
 *  Reset the user's password.
 *
 *  Value: "RESET_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_ResetPassword;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CommonCriteriaModeInfo.commonCriteriaModeStatus

/**
 *  Common Criteria Mode is currently disabled.
 *
 *  Value: "COMMON_CRITERIA_MODE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeDisabled;
/**
 *  Common Criteria Mode is currently enabled.
 *
 *  Value: "COMMON_CRITERIA_MODE_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeEnabled;
/**
 *  Unknown status.
 *
 *  Value: "COMMON_CRITERIA_MODE_STATUS_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeStatusUnknown;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.crossProfileCopyPaste

/**
 *  Default. Prevents users from pasting into the personal profile text copied
 *  from the work profile. Text copied from the personal profile can be pasted
 *  into the work profile, and text copied from the work profile can be pasted
 *  into the work profile.
 *
 *  Value: "COPY_FROM_WORK_TO_PERSONAL_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CopyFromWorkToPersonalDisallowed;
/**
 *  Text copied in either profile can be pasted in the other profile.
 *
 *  Value: "CROSS_PROFILE_COPY_PASTE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteAllowed;
/**
 *  Unspecified. Defaults to COPY_FROM_WORK_TO_PERSONAL_DISALLOWED
 *
 *  Value: "CROSS_PROFILE_COPY_PASTE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.crossProfileDataSharing

/**
 *  Data from either profile can be shared with the other profile.
 *
 *  Value: "CROSS_PROFILE_DATA_SHARING_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingAllowed;
/**
 *  Prevents data from being shared from both the personal profile to the work
 *  profile and the work profile to the personal profile.
 *
 *  Value: "CROSS_PROFILE_DATA_SHARING_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingDisallowed;
/**
 *  Unspecified. Defaults to DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED.
 *
 *  Value: "CROSS_PROFILE_DATA_SHARING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingUnspecified;
/**
 *  Default. Prevents users from sharing data from the work profile to apps in
 *  the personal profile. Personal data can be shared with work apps.
 *
 *  Value: "DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_DataSharingFromWorkToPersonalDisallowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_CrossProfilePolicies.showWorkContactsInPersonalProfile

/**
 *  Default. Allows work profile contacts to appear in personal profile contact
 *  searches and incoming calls
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileAllowed;
/**
 *  Prevents work profile contacts from appearing in personal profile contact
 *  searches and incoming calls
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileDisallowed;
/**
 *  Unspecified. Defaults to SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED.
 *
 *  Value: "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.appliedState

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Active;
/**
 *  The device was deleted. This state is never returned by an API call, but is
 *  used in the final status report when the device acknowledges the deletion.
 *  If the device is deleted via the API call, this state is published to
 *  Pub/Sub. If the user deletes the work profile or resets the device, the
 *  device state will remain unknown to the server.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Disabled;
/**
 *  The device is being provisioned. Newly enrolled devices are in this state
 *  until they have a policy applied.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.managementMode

/**
 *  Device owner. Android Device Policy has full control over the device.
 *
 *  Value: "DEVICE_OWNER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_DeviceOwner;
/**
 *  This value is disallowed.
 *
 *  Value: "MANAGEMENT_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_ManagementModeUnspecified;
/**
 *  Profile owner. Android Device Policy has control over a managed profile on
 *  the device.
 *
 *  Value: "PROFILE_OWNER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_ProfileOwner;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.ownership

/**
 *  Device is company-owned.
 *
 *  Value: "COMPANY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_Ownership_CompanyOwned;
/**
 *  Ownership is unspecified.
 *
 *  Value: "OWNERSHIP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_Ownership_OwnershipUnspecified;
/**
 *  Device is personally-owned.
 *
 *  Value: "PERSONALLY_OWNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_Ownership_PersonallyOwned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.state

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Active;
/**
 *  The device was deleted. This state is never returned by an API call, but is
 *  used in the final status report when the device acknowledges the deletion.
 *  If the device is deleted via the API call, this state is published to
 *  Pub/Sub. If the user deletes the work profile or resets the device, the
 *  device state will remain unknown to the server.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Disabled;
/**
 *  The device is being provisioned. Newly enrolled devices are in this state
 *  until they have a policy applied.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceSettings.encryptionStatus

/**
 *  Encryption is not currently active, but is currently being activated.
 *
 *  Value: "ACTIVATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Activating;
/**
 *  Encryption is active.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Active;
/**
 *  Encryption is active, but an encryption key is not set by the user.
 *
 *  Value: "ACTIVE_DEFAULT_KEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActiveDefaultKey;
/**
 *  Encryption is active, and the encryption key is tied to the user profile.
 *
 *  Value: "ACTIVE_PER_USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActivePerUser;
/**
 *  Unspecified. No device should have this type.
 *
 *  Value: "ENCRYPTION_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_EncryptionStatusUnspecified;
/**
 *  Encryption is supported by the device, but is not currently active.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Inactive;
/**
 *  Encryption is not supported by the device.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Unsupported;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Display.state

/**
 *  This value is disallowed.
 *
 *  Value: "DISPLAY_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_DisplayStateUnspecified;
/**
 *  Display is dozing in a low power state
 *
 *  Value: "DOZE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Doze;
/**
 *  Display is off.
 *
 *  Value: "OFF"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Off;
/**
 *  Display is on.
 *
 *  Value: "ON"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_On;
/**
 *  Display is dozing in a suspended low power state.
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Suspended;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_EnrollmentToken.allowPersonalUsage

/**
 *  Personal usage restriction is not specified
 *
 *  Value: "ALLOW_PERSONAL_USAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_AllowPersonalUsageUnspecified;
/**
 *  Personal usage is allowed
 *
 *  Value: "PERSONAL_USAGE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageAllowed;
/**
 *  Personal usage is disallowed
 *
 *  Value: "PERSONAL_USAGE_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageDisallowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Enterprise.enabledNotificationTypes

/**
 *  A notification sent when a device command has completed.
 *
 *  Value: "COMMAND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Command;
/**
 *  Deprecated.
 *
 *  Value: "COMPLIANCE_REPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_ComplianceReport;
/**
 *  A notification sent when a device enrolls.
 *
 *  Value: "ENROLLMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Enrollment;
/**
 *  This value is ignored.
 *
 *  Value: "NOTIFICATION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_NotificationTypeUnspecified;
/**
 *  A notification sent when a device issues a status report.
 *
 *  Value: "STATUS_REPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_StatusReport;
/**
 *  A notification sent when device sends BatchUsageLogEvents.
 *
 *  Value: "USAGE_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_UsageLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KeyedAppState.severity

/**
 *  Error severity level. This should only be set for genuine error conditions
 *  that a management organization needs to take action to fix.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KeyedAppState_Severity_Error;
/**
 *  Information severity level.
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KeyedAppState_Severity_Info;
/**
 *  Unspecified severity level.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KeyedAppState_Severity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.deviceSettings

/**
 *  Unspecified, defaults to SETTINGS_ACCESS_ALLOWED.
 *
 *  Value: "DEVICE_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_DeviceSettings_DeviceSettingsUnspecified;
/**
 *  Access to the Settings app is allowed in kiosk mode.
 *
 *  Value: "SETTINGS_ACCESS_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessAllowed;
/**
 *  Access to the Settings app is not allowed in kiosk mode.
 *
 *  Value: "SETTINGS_ACCESS_BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessBlocked;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.powerButtonActions

/**
 *  Unspecified, defaults to POWER_BUTTON_AVAILABLE.
 *
 *  Value: "POWER_BUTTON_ACTIONS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonActionsUnspecified;
/**
 *  The power menu (e.g. Power off, Restart) is shown when a user long-presses
 *  the Power button of a device in kiosk mode.
 *
 *  Value: "POWER_BUTTON_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonAvailable;
/**
 *  The power menu (e.g. Power off, Restart) is not shown when a user
 *  long-presses the Power button of a device in kiosk mode. Note: this may
 *  prevent users from turning off the device.
 *
 *  Value: "POWER_BUTTON_BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonBlocked;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.statusBar

/**
 *  System info and notifications are disabled in kiosk mode.
 *
 *  Value: "NOTIFICATIONS_AND_SYSTEM_INFO_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoDisabled;
/**
 *  System info and notifications are shown on the status bar in kiosk
 *  mode.Note: For this policy to take effect, the device's home button must be
 *  enabled using kioskCustomization.systemNavigation.
 *
 *  Value: "NOTIFICATIONS_AND_SYSTEM_INFO_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoEnabled;
/**
 *  Unspecified, defaults to INFO_AND_NOTIFICATIONS_DISABLED.
 *
 *  Value: "STATUS_BAR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_StatusBarUnspecified;
/**
 *  Only system info is shown on the status bar.
 *
 *  Value: "SYSTEM_INFO_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_StatusBar_SystemInfoOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.systemErrorWarnings

/**
 *  All system error dialogs such as crash and app not responding (ANR) are
 *  displayed.
 *
 *  Value: "ERROR_AND_WARNINGS_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsEnabled;
/**
 *  All system error dialogs, such as crash and app not responding (ANR) are
 *  blocked. When blocked, the system force-stops the app as if the user closes
 *  the app from the UI.
 *
 *  Value: "ERROR_AND_WARNINGS_MUTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsMuted;
/**
 *  Unspecified, defaults to ERROR_AND_WARNINGS_MUTED.
 *
 *  Value: "SYSTEM_ERROR_WARNINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_SystemErrorWarningsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_KioskCustomization.systemNavigation

/**
 *  Only the home button is enabled.
 *
 *  Value: "HOME_BUTTON_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_HomeButtonOnly;
/**
 *  The home and Overview buttons are not accessible.
 *
 *  Value: "NAVIGATION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationDisabled;
/**
 *  Home and overview buttons are enabled.
 *
 *  Value: "NAVIGATION_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationEnabled;
/**
 *  Unspecified, defaults to NAVIGATION_DISABLED.
 *
 *  Value: "SYSTEM_NAVIGATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_KioskCustomization_SystemNavigation_SystemNavigationUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ManagedProperty.type

/**
 *  A property of boolean type.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Bool;
/**
 *  A bundle of properties
 *
 *  Value: "BUNDLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Bundle;
/**
 *  An array of property bundles.
 *
 *  Value: "BUNDLE_ARRAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_BundleArray;
/**
 *  A choice of one item from a set.
 *
 *  Value: "CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Choice;
/**
 *  A hidden restriction of string type (the default value can be used to pass
 *  along information that can't be modified, such as a version code).
 *
 *  Value: "HIDDEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Hidden;
/**
 *  A property of integer type.
 *
 *  Value: "INTEGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Integer;
/**
 *  Not used.
 *
 *  Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified;
/**
 *  A choice of multiple items from a set.
 *
 *  Value: "MULTISELECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Multiselect;
/**
 *  A property of string type.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_String;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_MemoryEvent.eventType

/**
 *  A new external storage medium was detected. The reported byte count is the
 *  total capacity of the storage medium.
 *
 *  Value: "EXTERNAL_STORAGE_DETECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected;
/**
 *  Free space in an external storage medium was measured.
 *
 *  Value: "EXTERNAL_STORAGE_MEASURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured;
/**
 *  An external storage medium was removed. The reported byte count is zero.
 *
 *  Value: "EXTERNAL_STORAGE_REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved;
/**
 *  Free space in internal storage was measured.
 *
 *  Value: "INTERNAL_STORAGE_MEASURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "MEMORY_EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified;
/**
 *  Free space in RAM was measured.
 *
 *  Value: "RAM_MEASURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.installationFailureReason

/**
 *  The installation is still in progress.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress;
/**
 *  An unknown condition is preventing the app from being installed. Some
 *  potential reasons are that the device doesn't have enough storage, the
 *  device network connection is unreliable, or the installation is taking
 *  longer than expected. The installation will be retried automatically.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown;
/**
 *  This value is disallowed.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified;
/**
 *  There are no licenses available to assign to the user.
 *
 *  Value: "NO_LICENSES_REMAINING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining;
/**
 *  The app has not been approved by the admin.
 *
 *  Value: "NOT_APPROVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved;
/**
 *  The app is not available in the user's country.
 *
 *  Value: "NOT_AVAILABLE_IN_COUNTRY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry;
/**
 *  The app is incompatible with the device.
 *
 *  Value: "NOT_COMPATIBLE_WITH_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice;
/**
 *  The enterprise is no longer enrolled with Managed Google Play or the admin
 *  has not accepted the latest Managed Google Play Terms of Service.
 *
 *  Value: "NOT_ENROLLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled;
/**
 *  The app was not found in Play.
 *
 *  Value: "NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound;
/**
 *  The app has new permissions that have not been accepted by the admin.
 *
 *  Value: "PERMISSIONS_NOT_ACCEPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted;
/**
 *  The user is no longer valid. The user may have been deleted or disabled.
 *
 *  Value: "USER_INVALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.nonComplianceReason

/**
 *  The setting is not supported in the API level of the Android version running
 *  on the device.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel;
/**
 *  The setting can't be applied to the app because the app doesn't support it,
 *  for example because its target SDK version is not high enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible;
/**
 *  A blocked app is installed.
 *
 *  Value: "APP_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled;
/**
 *  The app required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled;
/**
 *  The app is installed, but it hasn't been updated to the minimum version code
 *  specified by policy.
 *
 *  Value: "APP_NOT_UPDATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) doesn't support the
 *  setting.
 *
 *  Value: "MANAGEMENT_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ManagementMode;
/**
 *  This value is disallowed.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting hasn't been applied at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.specificNonComplianceReason

/**
 *  The ONC Wi-Fi setting is not supported in the API level of the Android
 *  version running on the device. fieldPath specifies which field value is not
 *  supported. oncWifiContext is set. nonComplianceReason is set to API_LEVEL.
 *
 *  Value: "ONC_WIFI_API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiApiLevel;
/**
 *  There is an incorrect value in ONC Wi-Fi configuration. fieldPath specifies
 *  which field value is incorrect. oncWifiContext is set. nonComplianceReason
 *  is set to INVALID_VALUE.
 *
 *  Value: "ONC_WIFI_INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiInvalidValue;
/**
 *  The device or profile password has expired. passwordPoliciesContext is set.
 *  nonComplianceReason is set to USER_ACTION.
 *
 *  Value: "PASSWORD_POLICIES_PASSWORD_EXPIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordExpired;
/**
 *  The device password does not satisfy password requirements.
 *  passwordPoliciesContext is set. nonComplianceReason is set to USER_ACTION.
 *
 *  Value: "PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordNotSufficient;
/**
 *  User needs to confirm credentials by entering the screen lock. Fields in
 *  specific_non_compliance_context are not set. nonComplianceReason is set to
 *  USER_ACTION.
 *
 *  Value: "PASSWORD_POLICIES_USER_CREDENTIALS_CONFIRMATION_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesUserCredentialsConfirmationRequired;
/**
 *  Specific non-compliance reason is not specified. Fields in
 *  specific_non_compliance_context are not set.
 *
 *  Value: "SPECIFIC_NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_SpecificNonComplianceReasonUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetailCondition.nonComplianceReason

/**
 *  The setting is not supported in the API level of the Android version running
 *  on the device.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel;
/**
 *  The setting can't be applied to the app because the app doesn't support it,
 *  for example because its target SDK version is not high enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible;
/**
 *  A blocked app is installed.
 *
 *  Value: "APP_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled;
/**
 *  The app required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled;
/**
 *  The app is installed, but it hasn't been updated to the minimum version code
 *  specified by policy.
 *
 *  Value: "APP_NOT_UPDATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) doesn't support the
 *  setting.
 *
 *  Value: "MANAGEMENT_MODE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ManagementMode;
/**
 *  This value is disallowed.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting hasn't been applied at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_OsStartupEvent.verifiedBootState

/**
 *  Indicates that there is a full chain of trust extending from the bootloader
 *  to verified partitions including the bootloader, boot partition, and all
 *  verified partitions.
 *
 *  Value: "GREEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Green;
/**
 *  Indicates that the device may be freely modified. Device integrity is left
 *  to the user to verify out-of-band.
 *
 *  Value: "ORANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Orange;
/**
 *  Unknown value.
 *
 *  Value: "VERIFIED_BOOT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_VerifiedBootStateUnspecified;
/**
 *  Indicates that the boot partition has been verified using the embedded
 *  certificate and the signature is valid.
 *
 *  Value: "YELLOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Yellow;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_OsStartupEvent.verityMode

/**
 *  Indicates that dm-verity is disabled on device.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_Disabled;
/**
 *  Unknown value.
 *
 *  Value: "DM_VERITY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_DmVerityModeUnspecified;
/**
 *  Indicates that the device will be restarted when corruption is detected.
 *
 *  Value: "ENFORCING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_Enforcing;
/**
 *  Indicates that an I/O error will be returned for an attempt to read
 *  corrupted data blocks (also known as eio boot state).
 *
 *  Value: "IO_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_OsStartupEvent_VerityMode_IoError;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordPoliciesContext.passwordPolicyScope

/**
 *  The password requirements are only applied to the device.
 *
 *  Value: "SCOPE_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeDevice;
/**
 *  The password requirements are only applied to the work profile.
 *
 *  Value: "SCOPE_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeProfile;
/**
 *  The scope is unspecified. The password requirements are applied to the work
 *  profile for work profile devices and the whole device for fully managed or
 *  dedicated devices.
 *
 *  Value: "SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordQuality

/**
 *  The password must contain alphabetic (or symbol) characters.This, when
 *  applied on personally owned work profile devices on Android 12
 *  device-scoped, will be treated as COMPLEXITY_HIGH for application. See
 *  PasswordQuality for details.
 *
 *  Value: "ALPHABETIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic;
/**
 *  The password must contain both numeric and alphabetic (or symbol)
 *  characters.This, when applied on personally owned work profile devices on
 *  Android 12 device-scoped, will be treated as COMPLEXITY_HIGH for
 *  application. See PasswordQuality for details.
 *
 *  Value: "ALPHANUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric;
/**
 *  The device must be secured with a low-security biometric recognition
 *  technology, at minimum. This includes technologies that can recognize the
 *  identity of an individual that are roughly equivalent to a 3-digit PIN
 *  (false detection is less than 1 in 1,000).This, when applied on personally
 *  owned work profile devices on Android 12 device-scoped, will be treated as
 *  COMPLEXITY_LOW for application. See PasswordQuality for details.
 *
 *  Value: "BIOMETRIC_WEAK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak;
/**
 *  The password must meet the minimum requirements specified in
 *  passwordMinimumLength, passwordMinimumLetters, passwordMinimumSymbols, etc.
 *  For example, if passwordMinimumSymbols is 2, the password must contain at
 *  least two symbols.This, when applied on personally owned work profile
 *  devices on Android 12 device-scoped, will be treated as COMPLEXITY_HIGH for
 *  application. In this case, the requirements in passwordMinimumLength,
 *  passwordMinimumLetters, passwordMinimumSymbols, etc are not applied. See
 *  PasswordQuality for details.
 *
 *  Value: "COMPLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex;
/**
 *  Define the high password complexity band as:On Android 12 and above: PIN
 *  with no repeating (4444) or ordered (1234, 4321, 2468) sequences, length at
 *  least 8 alphabetic, length at least 6 alphanumeric, length at least 6This
 *  sets the minimum complexity band which the password must meet.Enforcement
 *  varies among different Android versions, management modes and password
 *  scopes. See PasswordQuality for details.
 *
 *  Value: "COMPLEXITY_HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityHigh;
/**
 *  Define the low password complexity band as: pattern PIN with repeating
 *  (4444) or ordered (1234, 4321, 2468) sequencesThis sets the minimum
 *  complexity band which the password must meet.Enforcement varies among
 *  different Android versions, management modes and password scopes. See
 *  PasswordQuality for details.
 *
 *  Value: "COMPLEXITY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityLow;
/**
 *  Define the medium password complexity band as: PIN with no repeating (4444)
 *  or ordered (1234, 4321, 2468) sequences, length at least 4 alphabetic,
 *  length at least 4 alphanumeric, length at least 4This sets the minimum
 *  complexity band which the password must meet.Enforcement varies among
 *  different Android versions, management modes and password scopes. See
 *  PasswordQuality for details.
 *
 *  Value: "COMPLEXITY_MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityMedium;
/**
 *  The password must contain numeric characters.This, when applied on
 *  personally owned work profile devices on Android 12 device-scoped, will be
 *  treated as COMPLEXITY_MEDIUM for application. See PasswordQuality for
 *  details.
 *
 *  Value: "NUMERIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric;
/**
 *  The password must contain numeric characters with no repeating (4444) or
 *  ordered (1234, 4321, 2468) sequences.This, when applied on personally owned
 *  work profile devices on Android 12 device-scoped, will be treated as
 *  COMPLEXITY_MEDIUM for application. See PasswordQuality for details.
 *
 *  Value: "NUMERIC_COMPLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex;
/**
 *  There are no password requirements.
 *
 *  Value: "PASSWORD_QUALITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified;
/**
 *  A password is required, but there are no restrictions on what the password
 *  must contain.This, when applied on personally owned work profile devices on
 *  Android 12 device-scoped, will be treated as COMPLEXITY_LOW for application.
 *  See PasswordQuality for details.
 *
 *  Value: "SOMETHING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordScope

/**
 *  The password requirements are only applied to the device.
 *
 *  Value: "SCOPE_DEVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeDevice;
/**
 *  The password requirements are only applied to the work profile.
 *
 *  Value: "SCOPE_PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeProfile;
/**
 *  The scope is unspecified. The password requirements are applied to the work
 *  profile for work profile devices and the whole device for fully managed or
 *  dedicated devices.
 *
 *  Value: "SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.requirePasswordUnlock

/**
 *  The timeout period is set to 24 hours.
 *
 *  Value: "REQUIRE_EVERY_DAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequireEveryDay;
/**
 *  Unspecified. Defaults to USE_DEFAULT_DEVICE_TIMEOUT.
 *
 *  Value: "REQUIRE_PASSWORD_UNLOCK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequirePasswordUnlockUnspecified;
/**
 *  The timeout period is set to the device’s default.
 *
 *  Value: "USE_DEFAULT_DEVICE_TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_UseDefaultDeviceTimeout;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.unifiedLockSettings

/**
 *  A common lock for the device and the work profile is allowed.
 *
 *  Value: "ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_AllowUnifiedWorkAndPersonalLock;
/**
 *  A separate lock for the work profile is required.
 *
 *  Value: "REQUIRE_SEPARATE_WORK_LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_RequireSeparateWorkLock;
/**
 *  Unspecified. Defaults to ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK.
 *
 *  Value: "UNIFIED_LOCK_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_UnifiedLockSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PerAppResult.clearingResult

/**
 *  This app’s data could not be cleared because the device API level does not
 *  support this command.
 *
 *  Value: "API_LEVEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_ApiLevel;
/**
 *  This app’s data could not be cleared because the app was not found.
 *
 *  Value: "APP_NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_AppNotFound;
/**
 *  This app’s data could not be cleared because the app is protected. For
 *  example, this may apply to apps critical to the functioning of the device,
 *  such as Google Play Store.
 *
 *  Value: "APP_PROTECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_AppProtected;
/**
 *  Unspecified result.
 *
 *  Value: "CLEARING_RESULT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_ClearingResultUnspecified;
/**
 *  This app’s data was successfully cleared.
 *
 *  Value: "SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PerAppResult_ClearingResult_Success;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PermissionGrant.policy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PersonalApplicationPolicy.installType

/**
 *  The app is available to install in the personal profile.
 *
 *  Value: "AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Available;
/**
 *  The app is blocked and can't be installed in the personal profile.
 *
 *  Value: "BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Blocked;
/**
 *  Unspecified. Defaults to AVAILABLE.
 *
 *  Value: "INSTALL_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_InstallTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PersonalUsagePolicies.personalPlayStoreMode

/**
 *  Only apps explicitly specified in personalApplications with installType set
 *  to AVAILABLE are allowed to be installed in the personal profile.
 *
 *  Value: "ALLOWLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Allowlist;
/**
 *  All Play Store apps are available for installation in the personal profile,
 *  except those whose installType is BLOCKED in personalApplications.
 *
 *  Value: "BLACKLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blacklist;
/**
 *  All Play Store apps are available for installation in the personal profile,
 *  except those whose installType is BLOCKED in personalApplications.
 *
 *  Value: "BLOCKLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blocklist;
/**
 *  Unspecified. Defaults to BLOCKLIST.
 *
 *  Value: "PLAY_STORE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_PlayStoreModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.androidDevicePolicyTracks

/**
 *  This value is ignored.
 *
 *  Value: "APP_TRACK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_AppTrackUnspecified;
/**
 *  The beta track, which provides the latest beta release.
 *
 *  Value: "BETA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_Beta;
/**
 *  The production track, which provides the latest stable release.
 *
 *  Value: "PRODUCTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_Production;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.appAutoUpdatePolicy

/**
 *  Apps are auto-updated at any time. Data charges may apply.
 *
 *  Value: "ALWAYS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Always;
/**
 *  The auto-update policy is not set. Equivalent to CHOICE_TO_THE_USER.
 *
 *  Value: "APP_AUTO_UPDATE_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_AppAutoUpdatePolicyUnspecified;
/**
 *  The user can control auto-updates.
 *
 *  Value: "CHOICE_TO_THE_USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_ChoiceToTheUser;
/**
 *  Apps are never auto-updated.
 *
 *  Value: "NEVER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Never;
/**
 *  Apps are auto-updated over Wi-Fi only.
 *
 *  Value: "WIFI_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_WifiOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.autoDateAndTimeZone

/**
 *  Enforce auto date, time, and time zone on the device.
 *
 *  Value: "AUTO_DATE_AND_TIME_ZONE_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneEnforced;
/**
 *  Unspecified. Defaults to AUTO_DATE_AND_TIME_ZONE_USER_CHOICE.
 *
 *  Value: "AUTO_DATE_AND_TIME_ZONE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUnspecified;
/**
 *  Auto date, time, and time zone are left to user's choice.
 *
 *  Value: "AUTO_DATE_AND_TIME_ZONE_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.cameraAccess

/**
 *  The field camera_disabled is ignored. All cameras on the device are disabled
 *  (for fully managed devices, this applies device-wide and for work profiles
 *  this applies only to the work profile).There are no explicit restrictions
 *  placed on the camera access toggle on Android 12 and above: on fully managed
 *  devices, the camera access toggle has no effect as all cameras are disabled.
 *  On devices with a work profile, this toggle has no effect on apps in the
 *  work profile, but it affects apps outside the work profile.
 *
 *  Value: "CAMERA_ACCESS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessDisabled;
/**
 *  The field camera_disabled is ignored. All cameras on the device are
 *  available. On fully managed devices running Android 12 and above, the user
 *  is unable to use the camera access toggle. On devices which are not fully
 *  managed or which run Android 11 or below, this is equivalent to
 *  CAMERA_ACCESS_USER_CHOICE.
 *
 *  Value: "CAMERA_ACCESS_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessEnforced;
/**
 *  If camera_disabled is true, this is equivalent to CAMERA_ACCESS_DISABLED.
 *  Otherwise, this is equivalent to CAMERA_ACCESS_USER_CHOICE.
 *
 *  Value: "CAMERA_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUnspecified;
/**
 *  The field camera_disabled is ignored. This is the default device behaviour:
 *  all cameras on the device are available. On Android 12 and above, the user
 *  can use the camera access toggle.
 *
 *  Value: "CAMERA_ACCESS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.encryptionPolicy

/**
 *  Encryption required but no password required to boot
 *
 *  Value: "ENABLED_WITHOUT_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithoutPassword;
/**
 *  Encryption required with password required to boot
 *
 *  Value: "ENABLED_WITH_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithPassword;
/**
 *  This value is ignored, i.e. no encryption required
 *
 *  Value: "ENCRYPTION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EncryptionPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.keyguardDisabledFeatures

/**
 *  Disable all current and future keyguard customizations.
 *
 *  Value: "ALL_FEATURES"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_AllFeatures;
/**
 *  Disable all biometric authentication on secure keyguard screens.
 *
 *  Value: "BIOMETRICS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Biometrics;
/**
 *  Disable the camera on secure keyguard screens (e.g. PIN).
 *
 *  Value: "CAMERA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Camera;
/**
 *  Disable fingerprint sensor on secure keyguard screens.
 *
 *  Value: "DISABLE_FINGERPRINT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_DisableFingerprint;
/**
 *  On devices running Android 6 and below, disables text entry into
 *  notifications on secure keyguard screens. Has no effect on Android 7 and
 *  above.
 *
 *  Value: "DISABLE_REMOTE_INPUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_DisableRemoteInput;
/**
 *  Disable face authentication on secure keyguard screens.
 *
 *  Value: "FACE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Face;
/**
 *  Disable iris authentication on secure keyguard screens.
 *
 *  Value: "IRIS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Iris;
/**
 *  This value is ignored.
 *
 *  Value: "KEYGUARD_DISABLED_FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_KeyguardDisabledFeatureUnspecified;
/**
 *  Disable showing all notifications on secure keyguard screens.
 *
 *  Value: "NOTIFICATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Notifications;
/**
 *  Ignore trust agent state on secure keyguard screens.
 *
 *  Value: "TRUST_AGENTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_TrustAgents;
/**
 *  Disable unredacted notifications on secure keyguard screens.
 *
 *  Value: "UNREDACTED_NOTIFICATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_UnredactedNotifications;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.locationMode

/**
 *  On Android 8 and below, only the network location provider is enabled. On
 *  Android 9 and above, this is equivalent to LOCATION_ENFORCED.
 *
 *  Value: "BATTERY_SAVING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_BatterySaving;
/**
 *  On Android 8 and below, all location detection methods are enabled,
 *  including GPS, networks, and other sensors. On Android 9 and above, this is
 *  equivalent to LOCATION_ENFORCED.
 *
 *  Value: "HIGH_ACCURACY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_HighAccuracy;
/**
 *  Disable location setting on the device.
 *
 *  Value: "LOCATION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationDisabled;
/**
 *  Enable location setting on the device.
 *
 *  Value: "LOCATION_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationEnforced;
/**
 *  Defaults to LOCATION_USER_CHOICE.
 *
 *  Value: "LOCATION_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationModeUnspecified;
/**
 *  Location setting is not restricted on the device. No specific behavior is
 *  set or enforced.
 *
 *  Value: "LOCATION_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationUserChoice;
/**
 *  On Android 8 and below, location setting and accuracy are disabled. On
 *  Android 9 and above, this is equivalent to LOCATION_DISABLED.
 *
 *  Value: "OFF"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_Off;
/**
 *  On Android 8 and below, only GPS and other sensors are enabled. On Android 9
 *  and above, this is equivalent to LOCATION_ENFORCED.
 *
 *  Value: "SENSORS_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_SensorsOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.microphoneAccess

/**
 *  The field unmute_microphone_disabled is ignored. The microphone on the
 *  device is disabled (for fully managed devices, this applies device-wide).The
 *  microphone access toggle has no effect as the microphone is disabled.
 *
 *  Value: "MICROPHONE_ACCESS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessDisabled;
/**
 *  The field unmute_microphone_disabled is ignored. The microphone on the
 *  device is available. On devices running Android 12 and above, the user is
 *  unable to use the microphone access toggle. On devices which run Android 11
 *  or below, this is equivalent to MICROPHONE_ACCESS_USER_CHOICE.
 *
 *  Value: "MICROPHONE_ACCESS_ENFORCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessEnforced;
/**
 *  If unmute_microphone_disabled is true, this is equivalent to
 *  MICROPHONE_ACCESS_DISABLED. Otherwise, this is equivalent to
 *  MICROPHONE_ACCESS_USER_CHOICE.
 *
 *  Value: "MICROPHONE_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUnspecified;
/**
 *  The field unmute_microphone_disabled is ignored. This is the default device
 *  behaviour: the microphone on the device is available. On Android 12 and
 *  above, the user can use the microphone access toggle.
 *
 *  Value: "MICROPHONE_ACCESS_USER_CHOICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUserChoice;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.playStoreMode

/**
 *  All apps are available and any app that should not be on the device should
 *  be explicitly marked as 'BLOCKED' in the applications policy.
 *
 *  Value: "BLACKLIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_Blacklist;
/**
 *  Unspecified. Defaults to WHITELIST.
 *
 *  Value: "PLAY_STORE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_PlayStoreModeUnspecified;
/**
 *  Only apps that are in the policy are available and any app not in the policy
 *  will be automatically uninstalled from the device.
 *
 *  Value: "WHITELIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_Whitelist;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.preferentialNetworkService

/**
 *  Preferential network service is disabled on the work profile.
 *
 *  Value: "PREFERENTIAL_NETWORK_SERVICE_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceDisabled;
/**
 *  Preferential network service is enabled on the work profile.
 *
 *  Value: "PREFERENTIAL_NETWORK_SERVICE_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceEnabled;
/**
 *  Unspecified. Defaults to PREFERENTIAL_NETWORK_SERVICES_DISABLED.
 *
 *  Value: "PREFERENTIAL_NETWORK_SERVICE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.stayOnPluggedModes

/**
 *  Power source is an AC charger.
 *
 *  Value: "AC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Ac;
/**
 *  This value is ignored.
 *
 *  Value: "BATTERY_PLUGGED_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_BatteryPluggedModeUnspecified;
/**
 *  Power source is a USB port.
 *
 *  Value: "USB"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Usb;
/**
 *  Power source is wireless.
 *
 *  Value: "WIRELESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Wireless;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PostureDetail.securityRisk

/**
 *  SafetyNet detects that the device is running a compromised OS
 *  (basicIntegrity check fails).
 *
 *  Value: "COMPROMISED_OS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_CompromisedOs;
/**
 *  SafetyNet detects that the device does not have a strong guarantee of system
 *  integrity, such as a hardware-backed keystore
 *  (https://developer.android.com/training/articles/security-key-attestation).
 *
 *  Value: "HARDWARE_BACKED_EVALUATION_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_HardwareBackedEvaluationFailed;
/**
 *  Unspecified.
 *
 *  Value: "SECURITY_RISK_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_SecurityRiskUnspecified;
/**
 *  SafetyNet detects that the device is running an unknown OS (basicIntegrity
 *  check succeeds but ctsProfileMatch fails).
 *
 *  Value: "UNKNOWN_OS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PostureDetail_SecurityRisk_UnknownOs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PowerManagementEvent.eventType

/**
 *  Battery level was measured.
 *
 *  Value: "BATTERY_LEVEL_COLLECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected;
/**
 *  The device entered low-power mode.
 *
 *  Value: "BATTERY_LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow;
/**
 *  The device exited low-power mode.
 *
 *  Value: "BATTERY_OKAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay;
/**
 *  The device booted.
 *
 *  Value: "BOOT_COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted;
/**
 *  The device started charging.
 *
 *  Value: "POWER_CONNECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected;
/**
 *  The device stopped charging.
 *
 *  Value: "POWER_DISCONNECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified;
/**
 *  The device shut down.
 *
 *  Value: "SHUTDOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SecurityPosture.devicePosture

/**
 *  This device may be more vulnerable to malicious actors than is recommended
 *  for use with corporate data.
 *
 *  Value: "AT_RISK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_AtRisk;
/**
 *  Unspecified. There is no posture detail for this posture value.
 *
 *  Value: "POSTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_PostureUnspecified;
/**
 *  This device may be compromised and corporate data may be accessible to
 *  unauthorized actors.
 *
 *  Value: "POTENTIALLY_COMPROMISED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_PotentiallyCompromised;
/**
 *  This device is secure.
 *
 *  Value: "SECURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SecurityPosture_DevicePosture_Secure;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SigninDetail.allowPersonalUsage

/**
 *  Personal usage restriction is not specified
 *
 *  Value: "ALLOW_PERSONAL_USAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_AllowPersonalUsageUnspecified;
/**
 *  Personal usage is allowed
 *
 *  Value: "PERSONAL_USAGE_ALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageAllowed;
/**
 *  Personal usage is disallowed
 *
 *  Value: "PERSONAL_USAGE_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageDisallowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SystemUpdate.type

/**
 *  Install automatically as soon as an update is available.
 *
 *  Value: "AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Automatic;
/**
 *  Postpone automatic install up to a maximum of 30 days.
 *
 *  Value: "POSTPONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Postpone;
/**
 *  Follow the default update behavior for the device, which typically requires
 *  the user to accept system updates.
 *
 *  Value: "SYSTEM_UPDATE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified;
/**
 *  Install automatically within a daily maintenance window. This also
 *  configures Play apps to be updated within the window. This is strongly
 *  recommended for kiosk devices because this is the only way apps persistently
 *  pinned to the foreground can be updated by Play.If autoUpdateMode is set to
 *  AUTO_UPDATE_HIGH_PRIORITY for an app, then the maintenance window is ignored
 *  for that app and it is updated as soon as possible even outside of the
 *  maintenance window.
 *
 *  Value: "WINDOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Windowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SystemUpdateInfo.updateStatus

/**
 *  There is a pending OS update available.
 *
 *  Value: "OS_UPDATE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_OsUpdateAvailable;
/**
 *  There is a pending security update available.
 *
 *  Value: "SECURITY_UPDATE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_SecurityUpdateAvailable;
/**
 *  There is a pending system update available, but its type is not known.
 *
 *  Value: "UNKNOWN_UPDATE_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UnknownUpdateAvailable;
/**
 *  It is unknown whether there is a pending system update. This happens when,
 *  for example, the device API level is less than 26, or if the version of
 *  Android Device Policy is outdated.
 *
 *  Value: "UPDATE_STATUS_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpdateStatusUnknown;
/**
 *  There is no pending system update available on the device.
 *
 *  Value: "UP_TO_DATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpToDate;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_UsageLog.enabledLogTypes

/**
 *  This value is not used.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_EnabledLogTypes_LogTypeUnspecified;
/**
 *  Enable logging of on-device network events, like DNS lookups and TCP
 *  connections. See UsageLogEvent for a complete description of the logged
 *  network events. Supported for fully managed devices on Android 8 and above.
 *  Supported for company-owned devices with a work profile on Android 12 and
 *  above, on which only network events from the work profile are logged. Can be
 *  overridden by the application delegated scope NETWORK_ACTIVITY_LOGS
 *
 *  Value: "NETWORK_ACTIVITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_EnabledLogTypes_NetworkActivityLogs;
/**
 *  Enable logging of on-device security events, like when the device password
 *  is incorrectly entered or removable storage is mounted. See UsageLogEvent
 *  for a complete description of the logged security events. Supported for
 *  fully managed devices on Android 7 and above. Supported for company-owned
 *  devices with a work profile on Android 12 and above, on which only security
 *  events from the work profile are logged. Can be overridden by the
 *  application delegated scope SECURITY_LOGS
 *
 *  Value: "SECURITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_EnabledLogTypes_SecurityLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_UsageLog.uploadOnCellularAllowed

/**
 *  This value is not used.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_UploadOnCellularAllowed_LogTypeUnspecified;
/**
 *  Enable logging of on-device network events, like DNS lookups and TCP
 *  connections. See UsageLogEvent for a complete description of the logged
 *  network events. Supported for fully managed devices on Android 8 and above.
 *  Supported for company-owned devices with a work profile on Android 12 and
 *  above, on which only network events from the work profile are logged. Can be
 *  overridden by the application delegated scope NETWORK_ACTIVITY_LOGS
 *
 *  Value: "NETWORK_ACTIVITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_UploadOnCellularAllowed_NetworkActivityLogs;
/**
 *  Enable logging of on-device security events, like when the device password
 *  is incorrectly entered or removable storage is mounted. See UsageLogEvent
 *  for a complete description of the logged security events. Supported for
 *  fully managed devices on Android 7 and above. Supported for company-owned
 *  devices with a work profile on Android 12 and above, on which only security
 *  events from the work profile are logged. Can be overridden by the
 *  application delegated scope SECURITY_LOGS
 *
 *  Value: "SECURITY_LOGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLog_UploadOnCellularAllowed_SecurityLogs;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_UsageLogEvent.eventType

/**
 *  Indicates adb_shell_command_event has been set.
 *
 *  Value: "ADB_SHELL_COMMAND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellCommand;
/**
 *  Indicates adb_shell_interactive_event has been set.
 *
 *  Value: "ADB_SHELL_INTERACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellInteractive;
/**
 *  Indicates app_process_start_event has been set.
 *
 *  Value: "APP_PROCESS_START"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_AppProcessStart;
/**
 *  Indicates cert_authority_installed_event has been set.
 *
 *  Value: "CERT_AUTHORITY_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityInstalled;
/**
 *  Indicates cert_authority_removed_event has been set.
 *
 *  Value: "CERT_AUTHORITY_REMOVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityRemoved;
/**
 *  Indicates cert_validation_failure_event has been set.
 *
 *  Value: "CERT_VALIDATION_FAILURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CertValidationFailure;
/**
 *  Indicates connect_event has been set.
 *
 *  Value: "CONNECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_Connect;
/**
 *  Indicates crypto_self_test_completed_event has been set.
 *
 *  Value: "CRYPTO_SELF_TEST_COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_CryptoSelfTestCompleted;
/**
 *  Indicates dns_event has been set.
 *
 *  Value: "DNS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_Dns;
/**
 *  This value is not used
 *
 *  Value: "EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_EventTypeUnspecified;
/**
 *  Indicates file_pulled_event has been set.
 *
 *  Value: "FILE_PULLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_FilePulled;
/**
 *  Indicates file_pushed_event has been set.
 *
 *  Value: "FILE_PUSHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_FilePushed;
/**
 *  Indicates key_destruction_event has been set.
 *
 *  Value: "KEY_DESTRUCTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyDestruction;
/**
 *  Indicates key_generated_event has been set.
 *
 *  Value: "KEY_GENERATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyGenerated;
/**
 *  Indicates keyguard_dismiss_auth_attempt_event has been set.
 *
 *  Value: "KEYGUARD_DISMISS_AUTH_ATTEMPT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissAuthAttempt;
/**
 *  Indicates keyguard_dismissed_event has been set.
 *
 *  Value: "KEYGUARD_DISMISSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissed;
/**
 *  Indicates keyguard_secured_event has been set.
 *
 *  Value: "KEYGUARD_SECURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardSecured;
/**
 *  Indicates key_import_event has been set.
 *
 *  Value: "KEY_IMPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyImport;
/**
 *  Indicates key_integrity_violation_event has been set.
 *
 *  Value: "KEY_INTEGRITY_VIOLATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_KeyIntegrityViolation;
/**
 *  Indicates log_buffer_size_critical_event has been set.
 *
 *  Value: "LOG_BUFFER_SIZE_CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LogBufferSizeCritical;
/**
 *  Indicates logging_started_event has been set.
 *
 *  Value: "LOGGING_STARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStarted;
/**
 *  Indicates logging_stopped_event has been set.
 *
 *  Value: "LOGGING_STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStopped;
/**
 *  Indicates media_mount_event has been set.
 *
 *  Value: "MEDIA_MOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_MediaMount;
/**
 *  Indicates media_unmount_event has been set.
 *
 *  Value: "MEDIA_UNMOUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_MediaUnmount;
/**
 *  Indicates os_shutdown_event has been set.
 *
 *  Value: "OS_SHUTDOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_OsShutdown;
/**
 *  Indicates os_startup_event has been set.
 *
 *  Value: "OS_STARTUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_OsStartup;
/**
 *  Indicates remote_lock_event has been set.
 *
 *  Value: "REMOTE_LOCK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_RemoteLock;
/**
 *  Indicates wipe_failure_event has been set.
 *
 *  Value: "WIPE_FAILURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_UsageLogEvent_EventType_WipeFailure;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebApp.displayMode

/**
 *  Not used.
 *
 *  Value: "DISPLAY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_DisplayModeUnspecified;
/**
 *  Opens the web app in full screen without any visible controls. The browser
 *  UI elements, page URL, system status bar and back button are not visible,
 *  and the web app takes up the entirety of the available display area.
 *
 *  Value: "FULL_SCREEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_FullScreen;
/**
 *  Opens the web app with a minimal set of browser UI elements for controlling
 *  navigation and viewing the page URL.
 *
 *  Value: "MINIMAL_UI"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_MinimalUi;
/**
 *  Opens the web app to look and feel like a standalone native application. The
 *  browser UI elements and page URL are not visible, however the system status
 *  bar and back button are visible.
 *
 *  Value: "STANDALONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebApp_DisplayMode_Standalone;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebToken.enabledFeatures

/**
 *  Unspecified feature.
 *
 *  Value: "FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_FeatureUnspecified;
/**
 *  The managed configurations page
 *  (https://developers.google.com/android/management/managed-configurations-iframe).
 *
 *  Value: "MANAGED_CONFIGURATIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_ManagedConfigurations;
/**
 *  The Managed Play search apps page
 *  (https://developers.google.com/android/management/apps#search-apps).
 *
 *  Value: "PLAY_SEARCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_PlaySearch;
/**
 *  The private apps page
 *  (https://developers.google.com/android/management/apps#private-apps).
 *
 *  Value: "PRIVATE_APPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_PrivateApps;
/**
 *  The organize apps page
 *  (https://developers.google.com/android/management/apps#organize-apps).
 *
 *  Value: "STORE_BUILDER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_StoreBuilder;
/**
 *  The Web Apps page
 *  (https://developers.google.com/android/management/apps#web-apps).
 *
 *  Value: "WEB_APPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_WebApps;
/**
 *  The zero-touch iframe
 *  (https://developers.google.com/android/management/zero-touch-iframe).
 *
 *  Value: "ZERO_TOUCH_CUSTOMER_MANAGEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_EnabledFeatures_ZeroTouchCustomerManagement;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebToken.permissions

/**
 *  The permission to approve apps for the enterprise.
 *
 *  Value: "APPROVE_APPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_ApproveApps;
/**
 *  This value is ignored.
 *
 *  Value: "WEB_TOKEN_PERMISSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_WebTokenPermissionUnspecified;

/**
 *  A shell command was issued over ADB via “adb shell command”.
 */
@interface GTLRAndroidManagement_AdbShellCommandEvent : GTLRObject

/**
 *  Shell command that was issued over ADB via "adb shell command". Redacted to
 *  empty string on organization-owned managed profile devices.
 */
@property(nonatomic, copy, nullable) NSString *shellCmd;

@end


/**
 *  An ADB interactive shell was opened via “adb shell”. Intentionally empty.
 */
@interface GTLRAndroidManagement_AdbShellInteractiveEvent : GTLRObject
@end


/**
 *  Security policies set to secure values by default. To maintain the security
 *  posture of a device, we don't recommend overriding any of the default
 *  values.
 */
@interface GTLRAndroidManagement_AdvancedSecurityOverrides : GTLRObject

/**
 *  Controls Common Criteria Mode—security standards defined in the Common
 *  Criteria for Information Technology Security Evaluation
 *  (https://www.commoncriteriaportal.org/) (CC). Enabling Common Criteria Mode
 *  increases certain security components on a device, including AES-GCM
 *  encryption of Bluetooth Long Term Keys, and Wi-Fi configuration
 *  stores.Warning: Common Criteria Mode enforces a strict security model
 *  typically only required for IT products used in national security systems
 *  and other highly sensitive organizations. Standard device use may be
 *  affected. Only enabled if required.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeDisabled
 *        Default. Disables Common Criteria Mode. (Value:
 *        "COMMON_CRITERIA_MODE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeEnabled
 *        Enables Common Criteria Mode. (Value: "COMMON_CRITERIA_MODE_ENABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_CommonCriteriaMode_CommonCriteriaModeUnspecified
 *        Unspecified. Defaults to COMMON_CRITERIA_MODE_DISABLED. (Value:
 *        "COMMON_CRITERIA_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *commonCriteriaMode;

/**
 *  Controls access to developer settings: developer options and safe boot.
 *  Replaces safeBootDisabled (deprecated) and debuggingFeaturesAllowed
 *  (deprecated).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsAllowed
 *        Allows all developer settings. The user can access and optionally
 *        configure the settings. (Value: "DEVELOPER_SETTINGS_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsDisabled
 *        Default. Disables all developer settings and prevents the user from
 *        accessing them. (Value: "DEVELOPER_SETTINGS_DISABLED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_DeveloperSettings_DeveloperSettingsUnspecified
 *        Unspecified. Defaults to DEVELOPER_SETTINGS_DISABLED. (Value:
 *        "DEVELOPER_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *developerSettings;

/**
 *  Whether Google Play Protect verification
 *  (https://support.google.com/accounts/answer/2812853) is enforced. Replaces
 *  ensureVerifyAppsEnabled (deprecated).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_GooglePlayProtectVerifyAppsUnspecified
 *        Unspecified. Defaults to VERIFY_APPS_ENFORCED. (Value:
 *        "GOOGLE_PLAY_PROTECT_VERIFY_APPS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsEnforced
 *        Default. Force-enables app verification. (Value:
 *        "VERIFY_APPS_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_GooglePlayProtectVerifyApps_VerifyAppsUserChoice
 *        Allows the user to choose whether to enable app verification. (Value:
 *        "VERIFY_APPS_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *googlePlayProtectVerifyApps;

/**
 *  Personal apps that can read work profile notifications using a
 *  NotificationListenerService
 *  (https://developer.android.com/reference/android/service/notification/NotificationListenerService).
 *  By default, no personal apps (aside from system apps) can read work
 *  notifications. Each value in the list must be a package name.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *personalAppsThatCanReadWorkNotifications;

/**
 *  The policy for untrusted apps (apps from unknown sources) enforced on the
 *  device. Replaces install_unknown_sources_allowed (deprecated).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallDeviceWide
 *        Allow untrusted app installs on entire device. (Value:
 *        "ALLOW_INSTALL_DEVICE_WIDE")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_AllowInstallInPersonalProfileOnly
 *        For devices with work profiles, allow untrusted app installs in the
 *        device's personal profile only. (Value:
 *        "ALLOW_INSTALL_IN_PERSONAL_PROFILE_ONLY")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_DisallowInstall
 *        Default. Disallow untrusted app installs on entire device. (Value:
 *        "DISALLOW_INSTALL")
 *    @arg @c kGTLRAndroidManagement_AdvancedSecurityOverrides_UntrustedAppsPolicy_UntrustedAppsPolicyUnspecified
 *        Unspecified. Defaults to DISALLOW_INSTALL. (Value:
 *        "UNTRUSTED_APPS_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *untrustedAppsPolicy;

@end


/**
 *  Configuration for an always-on VPN connection.
 */
@interface GTLRAndroidManagement_AlwaysOnVpnPackage : GTLRObject

/**
 *  Disallows networking when the VPN is not connected.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockdownEnabled;

/** The package name of the VPN app. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  A compliance rule condition which is satisfied if the Android Framework API
 *  level on the device doesn't meet a minimum requirement. There can only be
 *  one rule with this type of condition per policy.
 */
@interface GTLRAndroidManagement_ApiLevelCondition : GTLRObject

/**
 *  The minimum desired Android Framework API level. If the device doesn't meet
 *  the minimum requirement, this condition is satisfied. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minApiLevel;

@end


/**
 *  Information about an app.
 */
@interface GTLRAndroidManagement_Application : GTLRObject

/**
 *  Whether this app is free, free with in-app purchases, or paid. If the
 *  pricing is unspecified, this means the app is not generally available
 *  anymore (even though it might still be available to people who own it).
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_AppPricingUnspecified
 *        Unknown pricing, used to denote an approved app that is not generally
 *        available. (Value: "APP_PRICING_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_Free The app is
 *        free. (Value: "FREE")
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_FreeWithInAppPurchase
 *        The app is free, but offers in-app purchases. (Value:
 *        "FREE_WITH_IN_APP_PURCHASE")
 *    @arg @c kGTLRAndroidManagement_Application_AppPricing_Paid The app is
 *        paid. (Value: "PAID")
 */
@property(nonatomic, copy, nullable) NSString *appPricing;

/** Application tracks visible to the enterprise. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_AppTrackInfo *> *appTracks;

/** Versions currently available for this app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_AppVersion *> *appVersions;

/** The name of the author of the apps (for example, the app developer). */
@property(nonatomic, copy, nullable) NSString *author;

/** The countries which this app is available in as per ISO 3166-1 alpha-2. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *availableCountries;

/** The app category (e.g. RACING, SOCIAL, etc.) */
@property(nonatomic, copy, nullable) NSString *category;

/**
 *  The content rating for this app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_ContentRatingUnspecified
 *        Unspecified. (Value: "CONTENT_RATING_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_EighteenYears
 *        Content suitable for ages 18 and above only. (Value: "EIGHTEEN_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_SevenYears
 *        Content suitable for ages 7 and above only. (Value: "SEVEN_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_SixteenYears
 *        Content suitable for ages 16 and above only. (Value: "SIXTEEN_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_ThreeYears
 *        Content suitable for ages 3 and above only. (Value: "THREE_YEARS")
 *    @arg @c kGTLRAndroidManagement_Application_ContentRating_TwelveYears
 *        Content suitable for ages 12 and above only. (Value: "TWELVE_YEARS")
 */
@property(nonatomic, copy, nullable) NSString *contentRating;

/**
 *  The localized promotional description, if available.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  How and to whom the package is made available.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_DistributionChannelUnspecified
 *        Unspecified. (Value: "DISTRIBUTION_CHANNEL_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_PrivateGoogleHosted
 *        Package is a private app (restricted to an enterprise) but hosted by
 *        Google. (Value: "PRIVATE_GOOGLE_HOSTED")
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_PrivateSelfHosted
 *        Private app (restricted to an enterprise) and is privately hosted.
 *        (Value: "PRIVATE_SELF_HOSTED")
 *    @arg @c kGTLRAndroidManagement_Application_DistributionChannel_PublicGoogleHosted
 *        Package is available through the Play store and not restricted to a
 *        specific enterprise. (Value: "PUBLIC_GOOGLE_HOSTED")
 */
@property(nonatomic, copy, nullable) NSString *distributionChannel;

/** Noteworthy features (if any) of this app. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *features;

/** Full app description, if available. */
@property(nonatomic, copy, nullable) NSString *fullDescription;

/**
 *  A link to an image that can be used as an icon for the app. This image is
 *  suitable for use up to a pixel size of 512 x 512.
 */
@property(nonatomic, copy, nullable) NSString *iconUrl;

/**
 *  The set of managed properties available to be pre-configured for the app.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *managedProperties;

/**
 *  The minimum Android SDK necessary to run the app.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minAndroidSdkVersion;

/**
 *  The name of the app in the form
 *  enterprises/{enterprise}/applications/{package_name}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The permissions required by the app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPermission *> *permissions;

/** A link to the (consumer) Google Play details page for the app. */
@property(nonatomic, copy, nullable) NSString *playStoreUrl;

/** A localised description of the recent changes made to the app. */
@property(nonatomic, copy, nullable) NSString *recentChanges;

/** A list of screenshot links representing the app. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *screenshotUrls;

/**
 *  A link to a smaller image that can be used as an icon for the app. This
 *  image is suitable for use up to a pixel size of 128 x 128.
 */
@property(nonatomic, copy, nullable) NSString *smallIconUrl;

/** The title of the app. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  Output only. The approximate time (within 7 days) the app was last
 *  published.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  An app-related event.
 */
@interface GTLRAndroidManagement_ApplicationEvent : GTLRObject

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  App event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_ApplicationEventTypeUnspecified
 *        This value is disallowed. (Value:
 *        "APPLICATION_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Changed The app
 *        was changed, for example, a component was enabled or disabled. (Value:
 *        "CHANGED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_DataCleared The
 *        app data was cleared. (Value: "DATA_CLEARED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Installed The
 *        app was installed. (Value: "INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Pinned The app
 *        was pinned to the foreground. (Value: "PINNED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Removed The app
 *        was removed. (Value: "REMOVED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Replaced A new
 *        version of the app has been installed, replacing the old version.
 *        (Value: "REPLACED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Restarted The
 *        app was restarted. (Value: "RESTARTED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Unpinned The app
 *        was unpinned. (Value: "UNPINNED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  A permission required by the app.
 */
@interface GTLRAndroidManagement_ApplicationPermission : GTLRObject

/**
 *  A longer description of the permission, providing more detail on what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The name of the permission. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/** An opaque string uniquely identifying the permission. Not localized. */
@property(nonatomic, copy, nullable) NSString *permissionId;

@end


/**
 *  Policy for an individual app.
 */
@interface GTLRAndroidManagement_ApplicationPolicy : GTLRObject

/**
 *  List of the app’s track IDs that a device belonging to the enterprise can
 *  access. If the list contains multiple track IDs, devices receive the latest
 *  version among all accessible tracks. If the list contains no track IDs,
 *  devices only have access to the app’s production track. More details about
 *  each track are available in AppTrackInfo.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accessibleTrackIds;

/**
 *  Specifies whether the app is allowed networking when the VPN is not
 *  connected and alwaysOnVpnPackage.lockdownEnabled is enabled. If set to
 *  VPN_LOCKDOWN_ENFORCED, the app is not allowed networking, and if set to
 *  VPN_LOCKDOWN_EXEMPTION, the app is allowed networking. Only supported on
 *  devices running Android 10 and above. If this is not supported by the
 *  device, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to API_LEVEL and a fieldPath. If this is not
 *  applicable to the app, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to UNSUPPORTED and a fieldPath. The fieldPath is
 *  set to applications[i].alwaysOnVpnLockdownExemption, where i is the index of
 *  the package in the applications policy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_AlwaysOnVpnLockdownExemptionUnspecified
 *        Unspecified. Defaults to VPN_LOCKDOWN_ENFORCED. (Value:
 *        "ALWAYS_ON_VPN_LOCKDOWN_EXEMPTION_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownEnforced
 *        The app respects the always-on VPN lockdown setting. (Value:
 *        "VPN_LOCKDOWN_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AlwaysOnVpnLockdownExemption_VpnLockdownExemption
 *        The app is exempt from the always-on VPN lockdown setting. (Value:
 *        "VPN_LOCKDOWN_EXEMPTION")
 */
@property(nonatomic, copy, nullable) NSString *alwaysOnVpnLockdownExemption;

/**
 *  Controls the auto-update mode for the app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateDefault
 *        The app is automatically updated with low priority to minimize the
 *        impact on the user.The app is updated when all of the following
 *        constraints are met: The device is not actively used. The device is
 *        connected to an unmetered network. The device is charging.The device
 *        is notified about a new update within 24 hours after it is published
 *        by the developer, after which the app is updated the next time the
 *        constraints above are met. (Value: "AUTO_UPDATE_DEFAULT")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateHighPriority
 *        The app is updated as soon as possible. No constraints are applied.The
 *        device is notified immediately about a new update after it becomes
 *        available. (Value: "AUTO_UPDATE_HIGH_PRIORITY")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdateModeUnspecified
 *        Unspecified. Defaults to AUTO_UPDATE_DEFAULT. (Value:
 *        "AUTO_UPDATE_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_AutoUpdateMode_AutoUpdatePostponed
 *        The app is not automatically updated for a maximum of 90 days after
 *        the app becomes out of date.90 days after the app becomes out of date,
 *        the latest available version is installed automatically with low
 *        priority (see AUTO_UPDATE_DEFAULT). After the app is updated it is not
 *        automatically updated again until 90 days after it becomes out of date
 *        again.The user can still manually update the app from the Play Store
 *        at any time. (Value: "AUTO_UPDATE_POSTPONED")
 */
@property(nonatomic, copy, nullable) NSString *autoUpdateMode;

/**
 *  Controls whether the app can communicate with itself across a device’s work
 *  and personal profiles, subject to user consent.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppAllowed
 *        Allows the app to communicate across profiles after receiving user
 *        consent. (Value: "CONNECTED_WORK_AND_PERSONAL_APP_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppDisallowed
 *        Default. Prevents the app from communicating cross-profile. (Value:
 *        "CONNECTED_WORK_AND_PERSONAL_APP_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_ConnectedWorkAndPersonalApp_ConnectedWorkAndPersonalAppUnspecified
 *        Unspecified. Defaults to CONNECTED_WORK_AND_PERSONAL_APPS_DISALLOWED.
 *        (Value: "CONNECTED_WORK_AND_PERSONAL_APP_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *connectedWorkAndPersonalApp;

/**
 *  The default policy for all permissions requested by the app. If specified,
 *  this overrides the policy-level default_permission_policy which applies to
 *  all apps. It does not override the permission_grants which applies to all
 *  apps.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/** The scopes delegated to the app from Android Device Policy. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *delegatedScopes;

/**
 *  Whether the app is disabled. When disabled, the app data is still preserved.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

/**
 *  Configuration to enable this app as an extension app, with the capability of
 *  interacting with Android Device Policy offline.This field can be set for at
 *  most one app.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ExtensionConfig *extensionConfig;

/**
 *  The type of installation to perform.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Available The
 *        app is available to install. (Value: "AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Blocked The
 *        app is blocked and can't be installed. If the app was installed under
 *        a previous policy, it will be uninstalled. (Value: "BLOCKED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled
 *        The app is automatically installed and can't be removed by the user.
 *        (Value: "FORCE_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified
 *        Unspecified. Defaults to AVAILABLE. (Value:
 *        "INSTALL_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Kiosk The app
 *        is automatically installed in kiosk mode: it's set as the preferred
 *        home intent and whitelisted for lock task mode. Device setup won't
 *        complete until the app is installed. After installation, users won't
 *        be able to remove the app. You can only set this installType for one
 *        app per policy. When this is present in the policy, status bar will be
 *        automatically disabled. (Value: "KIOSK")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled
 *        The app is automatically installed and can be removed by the user.
 *        (Value: "PREINSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_RequiredForSetup
 *        The app is automatically installed and can't be removed by the user
 *        and will prevent setup from completion until installation is complete.
 *        (Value: "REQUIRED_FOR_SETUP")
 */
@property(nonatomic, copy, nullable) NSString *installType;

/**
 *  Whether the app is allowed to lock itself in full-screen mode. DEPRECATED.
 *  Use InstallType KIOSK or kioskCustomLauncherEnabled to to configure a
 *  dedicated device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockTaskAllowed;

/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: *type* *JSON value* BOOL true or false STRING string
 *  INTEGER number CHOICE string MULTISELECT array of strings HIDDEN string
 *  BUNDLE_ARRAY array of objects
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration *managedConfiguration;

/**
 *  The managed configurations template for the app, saved from the managed
 *  configurations iframe. This field is ignored if managed_configuration is
 *  set.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ManagedConfigurationTemplate *managedConfigurationTemplate;

/**
 *  The minimum version of the app that runs on the device. If set, the device
 *  attempts to update the app to at least this version code. If the app is not
 *  up-to-date, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to APP_NOT_UPDATED. The app must already be
 *  published to Google Play with a version code greater than or equal to this
 *  value. At most 20 apps may specify a minimum version code per policy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimumVersionCode;

/**
 *  The package name of the app. For example, com.google.android.youtube for the
 *  YouTube app.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  Explicit permission grants or denials for the app. These values override the
 *  default_permission_policy and permission_grants which apply to all apps.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

@end


/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: *type* *JSON value* BOOL true or false STRING string
 *  INTEGER number CHOICE string MULTISELECT array of strings HIDDEN string
 *  BUNDLE_ARRAY array of objects
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration : GTLRObject
@end


/**
 *  Information reported about an installed app.
 */
@interface GTLRAndroidManagement_ApplicationReport : GTLRObject

/**
 *  The source of the package.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_ApplicationSourceUnspecified
 *        The app was sideloaded from an unspecified source. (Value:
 *        "APPLICATION_SOURCE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_InstalledFromPlayStore
 *        The app was installed from the Google Play Store. (Value:
 *        "INSTALLED_FROM_PLAY_STORE")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppFactoryVersion
 *        This is a system app from the device's factory image. (Value:
 *        "SYSTEM_APP_FACTORY_VERSION")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppUpdatedVersion
 *        This is an updated system app. (Value: "SYSTEM_APP_UPDATED_VERSION")
 */
@property(nonatomic, copy, nullable) NSString *applicationSource;

/** The display name of the app. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** The list of app events which have occurred in the last 30 hours. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationEvent *> *events;

/** The package name of the app that installed this app. */
@property(nonatomic, copy, nullable) NSString *installerPackageName;

/** List of keyed app states reported by the app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_KeyedAppState *> *keyedAppStates;

/** Package name of the app. */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The SHA-256 hash of the app's APK file, which can be used to verify the app
 *  hasn't been modified. Each byte of the hash value is represented as a
 *  two-digit hexadecimal number.
 */
@property(nonatomic, copy, nullable) NSString *packageSha256Hash;

/**
 *  The SHA-1 hash of each android.content.pm.Signature
 *  (https://developer.android.com/reference/android/content/pm/Signature.html)
 *  associated with the app package. Each byte of each hash value is represented
 *  as a two-digit hexadecimal number.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingKeyCertFingerprints;

/**
 *  Application state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_ApplicationStateUnspecified
 *        App state is unspecified (Value: "APPLICATION_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_Installed App is
 *        installed on the device (Value: "INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_Removed App was
 *        removed from the device (Value: "REMOVED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The app version code, which can be used to determine whether one version is
 *  more recent than another.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

/** The app version as displayed to the user. */
@property(nonatomic, copy, nullable) NSString *versionName;

@end


/**
 *  Settings controlling the behavior of application reports.
 */
@interface GTLRAndroidManagement_ApplicationReportingSettings : GTLRObject

/**
 *  Whether removed apps are included in application reports.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *includeRemovedApps;

@end


/**
 *  Information about a process. It contains process name, start time, app Uid,
 *  app Pid, seinfo tag, hash of the base APK.
 */
@interface GTLRAndroidManagement_AppProcessInfo : GTLRObject

/** SHA-256 hash of the base APK, in hexadecimal format. */
@property(nonatomic, copy, nullable) NSString *apkSha256Hash;

/**
 *  Package names of all packages that are associated with the particular user
 *  ID. In most cases, this will be a single package name, the package that has
 *  been assigned that user ID. If multiple application share a UID then all
 *  packages sharing UID will be included.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

/**
 *  Process ID.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pid;

/** Process name. */
@property(nonatomic, copy, nullable) NSString *processName;

/** SELinux policy info. */
@property(nonatomic, copy, nullable) NSString *seinfo;

/** Process start time. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  UID of the package.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *uid;

@end


/**
 *  An app process was started. This is available device-wide on fully managed
 *  devices and within the work profile on organization-owned devices with a
 *  work profile.
 */
@interface GTLRAndroidManagement_AppProcessStartEvent : GTLRObject

/** Information about a process. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AppProcessInfo *processInfo;

@end


/**
 *  Id to name association of a app track.
 */
@interface GTLRAndroidManagement_AppTrackInfo : GTLRObject

/**
 *  The track name associated with the trackId, set in the Play Console. The
 *  name is modifiable from Play Console.
 */
@property(nonatomic, copy, nullable) NSString *trackAlias;

/**
 *  The unmodifiable unique track identifier, taken from the releaseTrackId in
 *  the URL of the Play Console page that displays the app’s track information.
 */
@property(nonatomic, copy, nullable) NSString *trackId;

@end


/**
 *  This represents a single version of the app.
 */
@interface GTLRAndroidManagement_AppVersion : GTLRObject

/**
 *  If the value is True, it indicates that this version is a production track.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *production;

/**
 *  Track identifiers that the app version is published in. This does not
 *  include the production track (see production instead).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *trackIds;

/**
 *  Unique increasing identifier for the app version.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

/**
 *  The string used in the Play store by the app developer to identify the
 *  version. The string is not necessarily unique or localized (for example, the
 *  string could be "1.4").
 */
@property(nonatomic, copy, nullable) NSString *versionString;

@end


/**
 *  Batched event logs of events from the device.
 */
@interface GTLRAndroidManagement_BatchUsageLogEvents : GTLRObject

/**
 *  The name of the device in the form
 *  ‘enterprises/{enterpriseId}/devices/{deviceId}’
 */
@property(nonatomic, copy, nullable) NSString *device;

/**
 *  The device timestamp when the batch of events were collected from the
 *  device.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *retrievalTime;

/**
 *  The list of UsageLogEvent that were reported by the device, sorted
 *  chronologically by the event time.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_UsageLogEvent *> *usageLogEvents;

/**
 *  The resource name of the user that owns this device in the form
 *  ‘enterprises/{enterpriseId}/users/{userId}’.
 */
@property(nonatomic, copy, nullable) NSString *user;

@end


/**
 *  An action to block access to apps and data on a fully managed device or in a
 *  work profile. This action also triggers a device or work profile to displays
 *  a user-facing notification with information (where possible) on how to
 *  correct the compliance issue. Note: wipeAction must also be specified.
 */
@interface GTLRAndroidManagement_BlockAction : GTLRObject

/**
 *  Number of days the policy is non-compliant before the device or work profile
 *  is blocked. To block access immediately, set to 0. blockAfterDays must be
 *  less than wipeAfterDays.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockAfterDays;

/**
 *  Specifies the scope of this BlockAction. Only applicable to devices that are
 *  company-owned.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeDevice
 *        Block action is applied to the entire device, including apps in the
 *        personal profile. (Value: "BLOCK_SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeUnspecified
 *        Unspecified. Defaults to BLOCK_SCOPE_WORK_PROFILE. (Value:
 *        "BLOCK_SCOPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_BlockAction_BlockScope_BlockScopeWorkProfile
 *        Block action is only applied to apps in the work profile. Apps in the
 *        personal profile are unaffected. (Value: "BLOCK_SCOPE_WORK_PROFILE")
 */
@property(nonatomic, copy, nullable) NSString *blockScope;

@end


/**
 *  A new root certificate was installed into the system's trusted credential
 *  storage. This is available device-wide on fully managed devices and within
 *  the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_CertAuthorityInstalledEvent : GTLRObject

/** Subject of the certificate. */
@property(nonatomic, copy, nullable) NSString *certificate;

/**
 *  Whether the installation event succeeded.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

/**
 *  The user in which the certificate install event happened. Only available for
 *  devices running Android 11 and above.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *userId;

@end


/**
 *  A root certificate was removed from the system's trusted credential storage.
 *  This is available device-wide on fully managed devices and within the work
 *  profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_CertAuthorityRemovedEvent : GTLRObject

/** Subject of the certificate. */
@property(nonatomic, copy, nullable) NSString *certificate;

/**
 *  Whether the removal succeeded.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

/**
 *  The user in which the certificate removal event occurred. Only available for
 *  devices running Android 11 and above.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *userId;

@end


/**
 *  An X.509v3 certificate failed to validate, currently this validation is
 *  performed on the Wi-FI access point and failure may be due to a mismatch
 *  upon server certificate validation. However it may in the future include
 *  other validation events of an X.509v3 certificate.
 */
@interface GTLRAndroidManagement_CertValidationFailureEvent : GTLRObject

/** The reason why certification validation failed. */
@property(nonatomic, copy, nullable) NSString *failureReason;

@end


/**
 *  Controls apps' access to private keys. The rule determines which private
 *  key, if any, Android Device Policy grants to the specified app. Access is
 *  granted either when the app calls KeyChain.choosePrivateKeyAlias
 *  (https://developer.android.com/reference/android/security/KeyChain#choosePrivateKeyAlias%28android.app.Activity,%20android.security.KeyChainAliasCallback,%20java.lang.String[],%20java.security.Principal[],%20java.lang.String,%20int,%20java.lang.String%29)
 *  (or any overloads) to request a private key alias for a given URL, or for
 *  rules that are not URL-specific (that is, if urlPattern is not set, or set
 *  to the empty string or .*) on Android 11 and above, directly so that the app
 *  can call KeyChain.getPrivateKey
 *  (https://developer.android.com/reference/android/security/KeyChain#getPrivateKey%28android.content.Context,%20java.lang.String%29),
 *  without first having to call KeyChain.choosePrivateKeyAlias.When an app
 *  calls KeyChain.choosePrivateKeyAlias if more than one choosePrivateKeyRules
 *  matches, the last matching rule defines which key alias to return.
 */
@interface GTLRAndroidManagement_ChoosePrivateKeyRule : GTLRObject

/**
 *  The package names to which this rule applies. The hash of the signing
 *  certificate for each app is verified against the hash provided by Play. If
 *  no package names are specified, then the alias is provided to all apps that
 *  call KeyChain.choosePrivateKeyAlias
 *  (https://developer.android.com/reference/android/security/KeyChain#choosePrivateKeyAlias%28android.app.Activity,%20android.security.KeyChainAliasCallback,%20java.lang.String[],%20java.security.Principal[],%20java.lang.String,%20int,%20java.lang.String%29)
 *  or any overloads (but not without calling KeyChain.choosePrivateKeyAlias,
 *  even on Android 11 and above). Any app with the same Android UID as a
 *  package specified here will have access when they call
 *  KeyChain.choosePrivateKeyAlias.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

/** The alias of the private key to be used. */
@property(nonatomic, copy, nullable) NSString *privateKeyAlias;

/**
 *  The URL pattern to match against the URL of the request. If not set or
 *  empty, it matches all URLs. This uses the regular expression syntax of
 *  java.util.regex.Pattern.
 */
@property(nonatomic, copy, nullable) NSString *urlPattern;

@end


/**
 *  Parameters associated with the CLEAR_APP_DATA command to clear the data of
 *  specified apps from the device.
 */
@interface GTLRAndroidManagement_ClearAppsDataParams : GTLRObject

/**
 *  The package names of the apps whose data will be cleared when the command is
 *  executed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

@end


/**
 *  Status of the CLEAR_APP_DATA command to clear the data of specified apps
 *  from the device.
 */
@interface GTLRAndroidManagement_ClearAppsDataStatus : GTLRObject

/**
 *  The per-app results, a mapping from package names to the respective clearing
 *  result.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ClearAppsDataStatus_Results *results;

@end


/**
 *  The per-app results, a mapping from package names to the respective clearing
 *  result.
 *
 *  @note This class is documented as having more properties of
 *        GTLRAndroidManagement_PerAppResult. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_ClearAppsDataStatus_Results : GTLRObject
@end


/**
 *  A command.
 */
@interface GTLRAndroidManagement_Command : GTLRObject

/**
 *  Parameters for the CLEAR_APP_DATA command to clear the data of specified
 *  apps from the device. See ClearAppsDataParams. If this is set, then it is
 *  suggested that type should not be set. In this case, the server
 *  automatically sets it to CLEAR_APP_DATA. It is also acceptable to explicitly
 *  set type to CLEAR_APP_DATA.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ClearAppsDataParams *clearAppsDataParams;

/**
 *  Output only. Status of the CLEAR_APP_DATA command to clear the data of
 *  specified apps from the device. See ClearAppsDataStatus.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ClearAppsDataStatus *clearAppsDataStatus;

/**
 *  The timestamp at which the command was created. The timestamp is
 *  automatically generated by the server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The duration for which the command is valid. The command will expire if not
 *  executed by the device during this time. The default duration if unspecified
 *  is ten minutes. There is no maximum duration.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  If the command failed, an error code explaining the failure. This is not set
 *  when the command is cancelled by the caller.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_ApiLevel The API level of
 *        the device does not support this command. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_CommandErrorCodeUnspecified
 *        There was no error. (Value: "COMMAND_ERROR_CODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_InvalidValue The command
 *        has an invalid parameter value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_ManagementMode The
 *        management mode (profile owner, device owner, etc.) does not support
 *        the command. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_Unknown An unknown error
 *        occurred. (Value: "UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_Unsupported The device
 *        doesn't support the command. Updating Android Device Policy to the
 *        latest version may resolve the issue. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *errorCode;

/**
 *  For commands of type RESET_PASSWORD, optionally specifies the new password.
 */
@property(nonatomic, copy, nullable) NSString *newPassword NS_RETURNS_NOT_RETAINED;

/** For commands of type RESET_PASSWORD, optionally specifies flags. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resetPasswordFlags;

/**
 *  The type of the command.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_Type_ClearAppData Clears the
 *        application data of specified apps. This is supported on Android 9 and
 *        above. Note that an application can store data outside of its
 *        application data, for example in external storage or in a user
 *        dictionary. See also clear_apps_data_params. (Value: "CLEAR_APP_DATA")
 *    @arg @c kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified This
 *        value is disallowed. (Value: "COMMAND_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Lock Lock the device, as if
 *        the lock screen timeout had expired. (Value: "LOCK")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Reboot Reboot the device. Only
 *        supported on fully managed devices running Android 7.0 (API level 24)
 *        or higher. (Value: "REBOOT")
 *    @arg @c kGTLRAndroidManagement_Command_Type_RelinquishOwnership Removes
 *        the work profile and all policies from a company-owned Android 8.0+
 *        device, relinquishing the device for personal use. Apps and data
 *        associated with the personal profile(s) are preserved. The device will
 *        be deleted from the server after it acknowledges the command. (Value:
 *        "RELINQUISH_OWNERSHIP")
 *    @arg @c kGTLRAndroidManagement_Command_Type_ResetPassword Reset the user's
 *        password. (Value: "RESET_PASSWORD")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The resource name of the user that owns the device in the form
 *  enterprises/{enterpriseId}/users/{userId}. This is automatically generated
 *  by the server based on the device the command is sent to.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Information about Common Criteria Mode—security standards defined in the
 *  Common Criteria for Information Technology Security Evaluation
 *  (https://www.commoncriteriaportal.org/) (CC).This information is only
 *  available if statusReportingSettings.commonCriteriaModeEnabled is true in
 *  the device's policy.
 */
@interface GTLRAndroidManagement_CommonCriteriaModeInfo : GTLRObject

/**
 *  Whether Common Criteria Mode is enabled.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeDisabled
 *        Common Criteria Mode is currently disabled. (Value:
 *        "COMMON_CRITERIA_MODE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeEnabled
 *        Common Criteria Mode is currently enabled. (Value:
 *        "COMMON_CRITERIA_MODE_ENABLED")
 *    @arg @c kGTLRAndroidManagement_CommonCriteriaModeInfo_CommonCriteriaModeStatus_CommonCriteriaModeStatusUnknown
 *        Unknown status. (Value: "COMMON_CRITERIA_MODE_STATUS_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *commonCriteriaModeStatus;

@end


/**
 *  A rule declaring which mitigating actions to take when a device is not
 *  compliant with its policy. For every rule, there is always an implicit
 *  mitigating action to set policy_compliant to false for the Device resource,
 *  and display a message on the device indicating that the device is not
 *  compliant with its policy. Other mitigating actions may optionally be taken
 *  as well, depending on the field values in the rule.
 */
@interface GTLRAndroidManagement_ComplianceRule : GTLRObject

/**
 *  A condition which is satisfied if the Android Framework API level on the
 *  device doesn't meet a minimum requirement.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApiLevelCondition *apiLevelCondition;

/**
 *  If set to true, the rule includes a mitigating action to disable apps so
 *  that the device is effectively disabled, but app data is preserved. If the
 *  device is running an app in locked task mode, the app will be closed and a
 *  UI showing the reason for non-compliance will be displayed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableApps;

/**
 *  A condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NonComplianceDetailCondition *nonComplianceDetailCondition;

/**
 *  If set, the rule includes a mitigating action to disable apps specified in
 *  the list, but app data is preserved.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNamesToDisable;

@end


/**
 *  A TCP connect event was initiated through the standard network stack.
 */
@interface GTLRAndroidManagement_ConnectEvent : GTLRObject

/** The destination IP address of the connect call. */
@property(nonatomic, copy, nullable) NSString *destinationIpAddress;

/**
 *  The destination port of the connect call.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *destinationPort;

/** The package name of the UID that performed the connect call. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  Contact details for managed Google Play enterprises.
 */
@interface GTLRAndroidManagement_ContactInfo : GTLRObject

/**
 *  Email address for a point of contact, which will be used to send important
 *  announcements related to managed Google Play.
 */
@property(nonatomic, copy, nullable) NSString *contactEmail;

/**
 *  The email of the data protection officer. The email is validated but not
 *  verified.
 */
@property(nonatomic, copy, nullable) NSString *dataProtectionOfficerEmail;

/** The name of the data protection officer. */
@property(nonatomic, copy, nullable) NSString *dataProtectionOfficerName;

/**
 *  The phone number of the data protection officer The phone number is
 *  validated but not verified.
 */
@property(nonatomic, copy, nullable) NSString *dataProtectionOfficerPhone;

/**
 *  The email of the EU representative. The email is validated but not verified.
 */
@property(nonatomic, copy, nullable) NSString *euRepresentativeEmail;

/** The name of the EU representative. */
@property(nonatomic, copy, nullable) NSString *euRepresentativeName;

/**
 *  The phone number of the EU representative. The phone number is validated but
 *  not verified.
 */
@property(nonatomic, copy, nullable) NSString *euRepresentativePhone;

@end


/**
 *  This feature is not generally available.
 */
@interface GTLRAndroidManagement_ContentProviderEndpoint : GTLRObject

/** This feature is not generally available. */
@property(nonatomic, copy, nullable) NSString *packageName;

/** Required. This feature is not generally available. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingCertsSha256;

/** This feature is not generally available. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Cross-profile policies applied on the device.
 */
@interface GTLRAndroidManagement_CrossProfilePolicies : GTLRObject

/**
 *  Whether text copied from one profile (personal or work) can be pasted in the
 *  other profile.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CopyFromWorkToPersonalDisallowed
 *        Default. Prevents users from pasting into the personal profile text
 *        copied from the work profile. Text copied from the personal profile
 *        can be pasted into the work profile, and text copied from the work
 *        profile can be pasted into the work profile. (Value:
 *        "COPY_FROM_WORK_TO_PERSONAL_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteAllowed
 *        Text copied in either profile can be pasted in the other profile.
 *        (Value: "CROSS_PROFILE_COPY_PASTE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileCopyPaste_CrossProfileCopyPasteUnspecified
 *        Unspecified. Defaults to COPY_FROM_WORK_TO_PERSONAL_DISALLOWED (Value:
 *        "CROSS_PROFILE_COPY_PASTE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *crossProfileCopyPaste;

/**
 *  Whether data from one profile (personal or work) can be shared with apps in
 *  the other profile. Specifically controls simple data sharing via intents.
 *  Management of other cross-profile communication channels, such as contact
 *  search, copy/paste, or connected work & personal apps, are configured
 *  separately.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingAllowed
 *        Data from either profile can be shared with the other profile. (Value:
 *        "CROSS_PROFILE_DATA_SHARING_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingDisallowed
 *        Prevents data from being shared from both the personal profile to the
 *        work profile and the work profile to the personal profile. (Value:
 *        "CROSS_PROFILE_DATA_SHARING_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_CrossProfileDataSharingUnspecified
 *        Unspecified. Defaults to
 *        DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED. (Value:
 *        "CROSS_PROFILE_DATA_SHARING_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_CrossProfileDataSharing_DataSharingFromWorkToPersonalDisallowed
 *        Default. Prevents users from sharing data from the work profile to
 *        apps in the personal profile. Personal data can be shared with work
 *        apps. (Value: "DATA_SHARING_FROM_WORK_TO_PERSONAL_DISALLOWED")
 */
@property(nonatomic, copy, nullable) NSString *crossProfileDataSharing;

/**
 *  Whether contacts stored in the work profile can be shown in personal profile
 *  contact searches and incoming calls.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileAllowed
 *        Default. Allows work profile contacts to appear in personal profile
 *        contact searches and incoming calls (Value:
 *        "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileDisallowed
 *        Prevents work profile contacts from appearing in personal profile
 *        contact searches and incoming calls (Value:
 *        "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_DISALLOWED")
 *    @arg @c kGTLRAndroidManagement_CrossProfilePolicies_ShowWorkContactsInPersonalProfile_ShowWorkContactsInPersonalProfileUnspecified
 *        Unspecified. Defaults to
 *        SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_ALLOWED. (Value:
 *        "SHOW_WORK_CONTACTS_IN_PERSONAL_PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *showWorkContactsInPersonalProfile;

@end


/**
 *  Validates whether Android’s built-in cryptographic library (BoringSSL) is
 *  valid. Should always succeed on device boot, if it fails, the device should
 *  be considered untrusted.
 */
@interface GTLRAndroidManagement_CryptoSelfTestCompletedEvent : GTLRObject

/**
 *  Whether the test succeeded.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  Represents a whole or partial calendar date, such as a birthday. The time of
 *  day and time zone are either specified elsewhere or are insignificant. The
 *  date is relative to the Gregorian Calendar. This can represent one of the
 *  following: A full date, with non-zero year, month, and day values. A month
 *  and day, with a zero year (for example, an anniversary). A year on its own,
 *  with a zero month and a zero day. A year and month, with a zero day (for
 *  example, a credit card expiration date).Related types: google.type.TimeOfDay
 *  google.type.DateTime google.protobuf.Timestamp
 */
@interface GTLRAndroidManagement_Date : GTLRObject

/**
 *  Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
 *  to specify a year by itself or a year and month where the day isn't
 *  significant.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *day;

/**
 *  Month of a year. Must be from 1 to 12, or 0 to specify a year without a
 *  month and day.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *month;

/**
 *  Year of the date. Must be from 1 to 9999, or 0 to specify a date without a
 *  year.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *year;

@end


/**
 *  A device owned by an enterprise. Unless otherwise noted, all fields are
 *  read-only and can't be modified by enterprises.devices.patch.
 */
@interface GTLRAndroidManagement_Device : GTLRObject

/**
 *  The API level of the Android platform version running on the device.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *apiLevel;

/**
 *  Reports for apps installed on the device. This information is only available
 *  when application_reports_enabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationReport *> *applicationReports;

/**
 *  The password requirements currently applied to the device. The applied
 *  requirements may be slightly different from those specified in
 *  passwordPolicies in some cases. fieldPath is set based on passwordPolicies.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PasswordRequirements *> *appliedPasswordPolicies;

/** The name of the policy currently applied to the device. */
@property(nonatomic, copy, nullable) NSString *appliedPolicyName;

/**
 *  The version of the policy currently applied to the device.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appliedPolicyVersion;

/**
 *  The state currently applied to the device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Active The device is
 *        active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Deleted The device was
 *        deleted. This state is never returned by an API call, but is used in
 *        the final status report when the device acknowledges the deletion. If
 *        the device is deleted via the API call, this state is published to
 *        Pub/Sub. If the user deletes the work profile or resets the device,
 *        the device state will remain unknown to the server. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified
 *        This value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Provisioning The device
 *        is being provisioned. Newly enrolled devices are in this state until
 *        they have a policy applied. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *appliedState;

/**
 *  Information about Common Criteria Mode—security standards defined in the
 *  Common Criteria for Information Technology Security Evaluation
 *  (https://www.commoncriteriaportal.org/) (CC).This information is only
 *  available if statusReportingSettings.commonCriteriaModeEnabled is true in
 *  the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CommonCriteriaModeInfo *commonCriteriaModeInfo;

/**
 *  Device settings information. This information is only available if
 *  deviceSettingsEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DeviceSettings *deviceSettings;

/**
 *  If the device state is DISABLED, an optional message that is displayed on
 *  the device indicating the reason the device is disabled. This field can be
 *  modified by a patch request.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *disabledReason;

/**
 *  Detailed information about displays on the device. This information is only
 *  available if displayInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Display *> *displays;

/** The time of device enrollment. */
@property(nonatomic, strong, nullable) GTLRDateTime *enrollmentTime;

/**
 *  If the device was enrolled with an enrollment token with additional data
 *  provided, this field contains that data.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenData;

/**
 *  If the device was enrolled with an enrollment token, this field contains the
 *  name of the token.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenName;

/** Detailed information about the device hardware. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_HardwareInfo *hardwareInfo;

/**
 *  Hardware status samples in chronological order. This information is only
 *  available if hardwareStatusEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_HardwareStatus *> *hardwareStatusSamples;

/** Deprecated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicyComplianceReportTime;

/** The last time the device fetched its policy. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicySyncTime;

/** The last time the device sent a status report. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastStatusReportTime;

/**
 *  The type of management mode Android Device Policy takes on the device. This
 *  influences which policy settings are supported.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_DeviceOwner Device
 *        owner. Android Device Policy has full control over the device. (Value:
 *        "DEVICE_OWNER")
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_ManagementModeUnspecified
 *        This value is disallowed. (Value: "MANAGEMENT_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_ProfileOwner Profile
 *        owner. Android Device Policy has control over a managed profile on the
 *        device. (Value: "PROFILE_OWNER")
 */
@property(nonatomic, copy, nullable) NSString *managementMode;

/**
 *  Events related to memory and storage measurements in chronological order.
 *  This information is only available if memoryInfoEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_MemoryEvent *> *memoryEvents;

/**
 *  Memory information: contains information about device memory and storage.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MemoryInfo *memoryInfo;

/**
 *  The name of the device in the form
 *  enterprises/{enterpriseId}/devices/{deviceId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Device network information. This information is only available if
 *  networkInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NetworkInfo *networkInfo;

/** Details about policy settings that the device is not compliant with. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_NonComplianceDetail *> *nonComplianceDetails;

/**
 *  Ownership of the managed device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_Ownership_CompanyOwned Device is
 *        company-owned. (Value: "COMPANY_OWNED")
 *    @arg @c kGTLRAndroidManagement_Device_Ownership_OwnershipUnspecified
 *        Ownership is unspecified. (Value: "OWNERSHIP_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_Ownership_PersonallyOwned Device is
 *        personally-owned. (Value: "PERSONALLY_OWNED")
 */
@property(nonatomic, copy, nullable) NSString *ownership;

/**
 *  Whether the device is compliant with its policy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *policyCompliant;

/**
 *  The name of the policy applied to the device, in the form
 *  enterprises/{enterpriseId}/policies/{policyId}. If not specified, the
 *  policy_name for the device's user is applied. This field can be modified by
 *  a patch request. You can specify only the policyId when calling
 *  enterprises.devices.patch, as long as the policyId doesn’t contain any
 *  slashes. The rest of the policy name is inferred.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  Power management events on the device in chronological order. This
 *  information is only available if powerManagementEventsEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PowerManagementEvent *> *powerManagementEvents;

/**
 *  If the same physical device has been enrolled multiple times, this field
 *  contains its previous device names. The serial number is used as the unique
 *  identifier to determine if the same physical device has enrolled previously.
 *  The names are in chronological order.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *previousDeviceNames;

/** Device's security posture value that reflects how secure the device is. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SecurityPosture *securityPosture;

/**
 *  Detailed information about the device software. This information is only
 *  available if softwareInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SoftwareInfo *softwareInfo;

/**
 *  The state to be applied to the device. This field can be modified by a patch
 *  request. Note that when calling enterprises.devices.patch, ACTIVE and
 *  DISABLED are the only allowable values. To enter the device into a DELETED
 *  state, call enterprises.devices.delete.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_State_Active The device is active.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_State_Deleted The device was
 *        deleted. This state is never returned by an API call, but is used in
 *        the final status report when the device acknowledges the deletion. If
 *        the device is deleted via the API call, this state is published to
 *        Pub/Sub. If the user deletes the work profile or resets the device,
 *        the device state will remain unknown to the server. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_State_DeviceStateUnspecified This
 *        value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Provisioning The device is
 *        being provisioned. Newly enrolled devices are in this state until they
 *        have a policy applied. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Map of selected system properties name and value related to the device. This
 *  information is only available if systemPropertiesEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Device_SystemProperties *systemProperties;

/** The user who owns the device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_User *user;

/**
 *  The resource name of the user that owns this device in the form
 *  enterprises/{enterpriseId}/users/{userId}.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Map of selected system properties name and value related to the device. This
 *  information is only available if systemPropertiesEnabled is true in the
 *  device's policy.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_Device_SystemProperties : GTLRObject
@end


/**
 *  Information about security related device settings on device.
 */
@interface GTLRAndroidManagement_DeviceSettings : GTLRObject

/**
 *  Whether ADB (https://developer.android.com/studio/command-line/adb.html) is
 *  enabled on the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adbEnabled;

/**
 *  Whether developer mode is enabled on the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *developmentSettingsEnabled;

/**
 *  Encryption status from DevicePolicyManager.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Activating
 *        Encryption is not currently active, but is currently being activated.
 *        (Value: "ACTIVATING")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Active
 *        Encryption is active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActiveDefaultKey
 *        Encryption is active, but an encryption key is not set by the user.
 *        (Value: "ACTIVE_DEFAULT_KEY")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActivePerUser
 *        Encryption is active, and the encryption key is tied to the user
 *        profile. (Value: "ACTIVE_PER_USER")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_EncryptionStatusUnspecified
 *        Unspecified. No device should have this type. (Value:
 *        "ENCRYPTION_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Inactive
 *        Encryption is supported by the device, but is not currently active.
 *        (Value: "INACTIVE")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Unsupported
 *        Encryption is not supported by the device. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionStatus;

/**
 *  Whether the device is secured with PIN/password.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isDeviceSecure;

/**
 *  Whether the storage encryption is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isEncrypted;

/**
 *  Whether installing apps from unknown sources is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unknownSourcesEnabled;

/**
 *  Whether Google Play Protect verification
 *  (https://support.google.com/accounts/answer/2812853) is enforced on the
 *  device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *verifyAppsEnabled;

@end


/**
 *  Device display information.
 */
@interface GTLRAndroidManagement_Display : GTLRObject

/**
 *  Display density expressed as dots-per-inch.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *density;

/**
 *  Unique display id.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayId;

/**
 *  Display height in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *height;

/** Name of the display. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Refresh rate of the display in frames per second.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *refreshRate;

/**
 *  State of the display.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Display_State_DisplayStateUnspecified This
 *        value is disallowed. (Value: "DISPLAY_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Display_State_Doze Display is dozing in a
 *        low power state (Value: "DOZE")
 *    @arg @c kGTLRAndroidManagement_Display_State_Off Display is off. (Value:
 *        "OFF")
 *    @arg @c kGTLRAndroidManagement_Display_State_On Display is on. (Value:
 *        "ON")
 *    @arg @c kGTLRAndroidManagement_Display_State_Suspended Display is dozing
 *        in a suspended low power state. (Value: "SUSPENDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Display width in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  A DNS lookup event was initiated through the standard network stack.
 */
@interface GTLRAndroidManagement_DnsEvent : GTLRObject

/** The hostname that was looked up. */
@property(nonatomic, copy, nullable) NSString *hostname;

/**
 *  The (possibly truncated) list of the IP addresses returned for DNS lookup
 *  (max 10 IPv4 or IPv6 addresses).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *ipAddresses;

/** The package name of the UID that performed the DNS lookup. */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The number of IP addresses returned from the DNS lookup event. May be higher
 *  than the amount of ip_addresses if there were too many addresses to log.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalIpAddressesReturned;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRAndroidManagement_Empty : GTLRObject
@end


/**
 *  An enrollment token.
 */
@interface GTLRAndroidManagement_EnrollmentToken : GTLRObject

/**
 *  Optional, arbitrary data associated with the enrollment token. This could
 *  contain, for example, the ID of an org unit the device is assigned to after
 *  enrollment. After a device enrolls with the token, this data will be exposed
 *  in the enrollment_token_data field of the Device resource. The data must be
 *  1024 characters or less; otherwise, the creation request will fail.
 */
@property(nonatomic, copy, nullable) NSString *additionalData;

/**
 *  Controls whether personal usage is allowed on a device provisioned with this
 *  enrollment token.For company-owned devices: Enabling personal usage allows
 *  the user to set up a work profile on the device. Disabling personal usage
 *  requires the user provision the device as a fully managed device.For
 *  personally-owned devices: Enabling personal usage allows the user to set up
 *  a work profile on the device. Disabling personal usage will prevent the
 *  device from provisioning. Personal usage cannot be disabled on
 *  personally-owned device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_AllowPersonalUsageUnspecified
 *        Personal usage restriction is not specified (Value:
 *        "ALLOW_PERSONAL_USAGE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageAllowed
 *        Personal usage is allowed (Value: "PERSONAL_USAGE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_EnrollmentToken_AllowPersonalUsage_PersonalUsageDisallowed
 *        Personal usage is disallowed (Value: "PERSONAL_USAGE_DISALLOWED")
 */
@property(nonatomic, copy, nullable) NSString *allowPersonalUsage;

/**
 *  The length of time the enrollment token is valid, ranging from 1 minute to
 *  Durations.MAX_VALUE
 *  (https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/Durations.html#MAX_VALUE),
 *  approximately 10,000 years. If not specified, the default duration is 1
 *  hour. Please note that if requested duration causes the resulting
 *  expiration_timestamp to exceed Timestamps.MAX_VALUE
 *  (https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/Timestamps.html#MAX_VALUE),
 *  then expiration_timestamp is coerced to Timestamps.MAX_VALUE.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  The expiration time of the token. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTimestamp;

/**
 *  The name of the enrollment token, which is generated by the server during
 *  creation, in the form
 *  enterprises/{enterpriseId}/enrollmentTokens/{enrollmentTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the enrollment token is for one time use only. If the flag is set to
 *  true, only one device can use it for registration.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneTimeOnly;

/**
 *  The name of the policy initially applied to the enrolled device, in the form
 *  enterprises/{enterpriseId}/policies/{policyId}. If not specified, the
 *  policy_name for the device’s user is applied. If user_name is also not
 *  specified, enterprises/{enterpriseId}/policies/default is applied by
 *  default. When updating this field, you can specify only the policyId as long
 *  as the policyId doesn’t contain any slashes. The rest of the policy name
 *  will be inferred.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/**
 *  The user associated with this enrollment token. If it's specified when the
 *  enrollment token is created and the user does not exist, the user will be
 *  created. This field must not contain personally identifiable information.
 *  Only the account_identifier field needs to be set.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_User *user;

/**
 *  The token value that's passed to the device and authorizes the device to
 *  enroll. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  The configuration applied to an enterprise.
 */
@interface GTLRAndroidManagement_Enterprise : GTLRObject

/**
 *  Deprecated and unused.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appAutoApprovalEnabled;

/** The enterprise contact info of an EMM-managed enterprise. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ContactInfo *contactInfo;

/** The types of Google Pub/Sub notifications enabled for the enterprise. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledNotificationTypes;

/** The name of the enterprise displayed to users. */
@property(nonatomic, copy, nullable) NSString *enterpriseDisplayName;

/**
 *  An image displayed as a logo during device provisioning. Supported types
 *  are: image/bmp, image/gif, image/x-ico, image/jpeg, image/png, image/webp,
 *  image/vnd.wap.wbmp, image/x-adobe-dng.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ExternalData *logo;

/**
 *  The name of the enterprise which is generated by the server during creation,
 *  in the form enterprises/{enterpriseId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A color in RGB format that indicates the predominant color to display in the
 *  device management app UI. The color components are stored as follows: (red
 *  << 16) | (green << 8) | blue, where the value of each component is between 0
 *  and 255, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *primaryColor;

/**
 *  The topic which Pub/Sub notifications are published to, in the form
 *  projects/{project}/topics/{topic}. This field is only required if Pub/Sub
 *  notifications are enabled.
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

/** Sign-in details of the enterprise. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_SigninDetail *> *signinDetails;

/**
 *  Terms and conditions that must be accepted when provisioning a device for
 *  this enterprise. A page of terms is generated for each value in this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_TermsAndConditions *> *termsAndConditions;

@end


/**
 *  Configuration to enable an app as an extension app, with the capability of
 *  interacting with Android Device Policy offline.
 */
@interface GTLRAndroidManagement_ExtensionConfig : GTLRObject

/**
 *  Fully qualified class name of the receiver service class for Android Device
 *  Policy to notify the extension app of any local command status updates.
 */
@property(nonatomic, copy, nullable) NSString *notificationReceiver;

/**
 *  Hex-encoded SHA-256 hash of the signing certificate of the extension app.
 *  Only hexadecimal string representations of 64 characters are valid.If not
 *  specified, the signature for the corresponding package name is obtained from
 *  the Play Store instead.If this list is empty, the signature of the extension
 *  app on the device must match the signature obtained from the Play Store for
 *  the app to be able to communicate with Android Device Policy.If this list is
 *  not empty, the signature of the extension app on the device must match one
 *  of the entries in this list for the app to be able to communicate with
 *  Android Device Policy.In production use cases, it is recommended to leave
 *  this empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingKeyFingerprintsSha256;

@end


/**
 *  Data hosted at an external location. The data is to be downloaded by Android
 *  Device Policy and verified against the hash.
 */
@interface GTLRAndroidManagement_ExternalData : GTLRObject

/**
 *  The base-64 encoded SHA-256 hash of the content hosted at url. If the
 *  content doesn't match this hash, Android Device Policy won't use the data.
 */
@property(nonatomic, copy, nullable) NSString *sha256Hash;

/**
 *  The absolute URL to the data, which must use either the http or https
 *  scheme. Android Device Policy doesn't provide any credentials in the GET
 *  request, so the URL must be publicly accessible. Including a long, random
 *  component in the URL may be used to prevent attackers from discovering the
 *  URL.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  A file was downloaded from the device.
 */
@interface GTLRAndroidManagement_FilePulledEvent : GTLRObject

/** The path of the file being pulled. */
@property(nonatomic, copy, nullable) NSString *filePath;

@end


/**
 *  A file was uploaded onto the device.
 */
@interface GTLRAndroidManagement_FilePushedEvent : GTLRObject

/** The path of the file being pushed. */
@property(nonatomic, copy, nullable) NSString *filePath;

@end


/**
 *  A system freeze period. When a device’s clock is within the freeze period,
 *  all incoming system updates (including security patches) are blocked and
 *  won’t be installed. When a device is outside the freeze period, normal
 *  update behavior applies. Leap years are ignored in freeze period
 *  calculations, in particular: * If Feb. 29th is set as the start or end date
 *  of a freeze period, the freeze period will start or end on Feb. 28th
 *  instead. * When a device’s system clock reads Feb. 29th, it’s treated as
 *  Feb. 28th. * When calculating the number of days in a freeze period or the
 *  time between two freeze periods, Feb. 29th is ignored and not counted as a
 *  day.Note: For Freeze Periods to take effect, SystemUpdateType cannot be
 *  specified as SYSTEM_UPDATE_TYPE_UNSPECIFIED, because freeze periods require
 *  a defined policy to be specified.
 */
@interface GTLRAndroidManagement_FreezePeriod : GTLRObject

/**
 *  The end date (inclusive) of the freeze period. Must be no later than 90 days
 *  from the start date. If the end date is earlier than the start date, the
 *  freeze period is considered wrapping year-end. Note: year must not be set.
 *  For example, {"month": 1,"date": 30}.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Date *endDate;

/**
 *  The start date (inclusive) of the freeze period. Note: year must not be set.
 *  For example, {"month": 1,"date": 30}.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Date *startDate;

@end


/**
 *  Information about device hardware. The fields related to temperature
 *  thresholds are only available if hardwareStatusEnabled is true in the
 *  device's policy.
 */
@interface GTLRAndroidManagement_HardwareInfo : GTLRObject

/**
 *  Battery shutdown temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryShutdownTemperatures;

/**
 *  Battery throttling temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryThrottlingTemperatures;

/** Brand of the device. For example, Google. */
@property(nonatomic, copy, nullable) NSString *brand;

/**
 *  CPU shutdown temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuShutdownTemperatures;

/**
 *  CPU throttling temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuThrottlingTemperatures;

/** Baseband version. For example, MDM9625_104662.22.05.34p. */
@property(nonatomic, copy, nullable) NSString *deviceBasebandVersion;

/**
 *  Output only. ID that uniquely identifies a personally-owned device in a
 *  particular organization. On the same physical device when enrolled with the
 *  same organization, this ID persists across setups and even factory resets.
 *  This ID is available on personally-owned devices with a work profile on
 *  devices running Android 12 and above.
 */
@property(nonatomic, copy, nullable) NSString *enterpriseSpecificId;

/**
 *  GPU shutdown temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuShutdownTemperatures;

/**
 *  GPU throttling temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuThrottlingTemperatures;

/** Name of the hardware. For example, Angler. */
@property(nonatomic, copy, nullable) NSString *hardware;

/** Manufacturer. For example, Motorola. */
@property(nonatomic, copy, nullable) NSString *manufacturer;

/** The model of the device. For example, Asus Nexus 7. */
@property(nonatomic, copy, nullable) NSString *model;

/** The device serial number. */
@property(nonatomic, copy, nullable) NSString *serialNumber;

/**
 *  Device skin shutdown temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinShutdownTemperatures;

/**
 *  Device skin throttling temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinThrottlingTemperatures;

@end


/**
 *  Hardware status. Temperatures may be compared to the temperature thresholds
 *  available in hardwareInfo to determine hardware health.
 */
@interface GTLRAndroidManagement_HardwareStatus : GTLRObject

/**
 *  Current battery temperatures in Celsius for each battery on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryTemperatures;

/**
 *  Current CPU temperatures in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuTemperatures;

/**
 *  CPU usages in percentage for each core available on the device. Usage is 0
 *  for each unplugged core. Empty array implies that CPU usage is not supported
 *  in the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuUsages;

/** The time the measurements were taken. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Fan speeds in RPM for each fan on the device. Empty array means that there
 *  are no fans or fan speed is not supported on the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *fanSpeeds;

/**
 *  Current GPU temperatures in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuTemperatures;

/**
 *  Current device skin temperatures in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinTemperatures;

@end


/**
 *  Response on issuing a command. This is currently empty as a placeholder.
 */
@interface GTLRAndroidManagement_IssueCommandResponse : GTLRObject
@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is removed from the device either by the user or
 *  management. This is available device-wide on fully managed devices and
 *  within the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyDestructionEvent : GTLRObject

/**
 *  UID of the application which owns the key.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

/**
 *  Whether the operation was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  Keyed app state reported by the app.
 */
@interface GTLRAndroidManagement_KeyedAppState : GTLRObject

/** The creation time of the app state on the device. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optionally, a machine-readable value to be read by the EMM. For example,
 *  setting values that the admin can choose to query against in the EMM console
 *  (e.g. “notify me if the battery_warning data < 10”).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  The key for the app state. Acts as a point of reference for what the app is
 *  providing state for. For example, when providing managed configuration
 *  feedback, this key could be the managed configuration key.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** The time the app state was most recently updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastUpdateTime;

/**
 *  Optionally, a free-form message string to explain the app state. If the
 *  state was triggered by a particular value (e.g. a managed configuration
 *  value), it should be included in the message.
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  The severity of the app state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KeyedAppState_Severity_Error Error severity
 *        level. This should only be set for genuine error conditions that a
 *        management organization needs to take action to fix. (Value: "ERROR")
 *    @arg @c kGTLRAndroidManagement_KeyedAppState_Severity_Info Information
 *        severity level. (Value: "INFO")
 *    @arg @c kGTLRAndroidManagement_KeyedAppState_Severity_SeverityUnspecified
 *        Unspecified severity level. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is installed on the device either by the user or
 *  management.This is available device-wide on fully managed devices and within
 *  the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyGeneratedEvent : GTLRObject

/**
 *  UID of the application which generated the key.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

/**
 *  Whether the operation was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  An attempt was made to unlock the device.
 */
@interface GTLRAndroidManagement_KeyguardDismissAuthAttemptEvent : GTLRObject

/**
 *  Whether a strong form of authentication (password, PIN, or pattern) was used
 *  to unlock device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strongAuthMethodUsed;

/**
 *  Whether the unlock attempt was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  The keyguard was dismissed. Intentionally empty.
 */
@interface GTLRAndroidManagement_KeyguardDismissedEvent : GTLRObject
@end


/**
 *  The device was locked either by user or timeout. Intentionally empty.
 */
@interface GTLRAndroidManagement_KeyguardSecuredEvent : GTLRObject
@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is imported on the device either by the user or
 *  management. This is available device-wide on fully managed devices and
 *  within the work profile on organization-owned devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyImportEvent : GTLRObject

/**
 *  UID of the application which imported the key
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

/**
 *  Whether the operation was successful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is determined to be corrupted due to storage
 *  corruption, hardware failure or some OS issue. This is available device-wide
 *  on fully managed devices and within the work profile on organization-owned
 *  devices with a work profile.
 */
@interface GTLRAndroidManagement_KeyIntegrityViolationEvent : GTLRObject

/**
 *  UID of the application which owns the key
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationUid;

/** Alias of the key. */
@property(nonatomic, copy, nullable) NSString *keyAlias;

@end


/**
 *  Settings controlling the behavior of a device in kiosk mode. To enable kiosk
 *  mode, set kioskCustomLauncherEnabled to true or specify an app in the policy
 *  with installType KIOSK.
 */
@interface GTLRAndroidManagement_KioskCustomization : GTLRObject

/**
 *  Specifies whether the Settings app is allowed in kiosk mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_DeviceSettings_DeviceSettingsUnspecified
 *        Unspecified, defaults to SETTINGS_ACCESS_ALLOWED. (Value:
 *        "DEVICE_SETTINGS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessAllowed
 *        Access to the Settings app is allowed in kiosk mode. (Value:
 *        "SETTINGS_ACCESS_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_DeviceSettings_SettingsAccessBlocked
 *        Access to the Settings app is not allowed in kiosk mode. (Value:
 *        "SETTINGS_ACCESS_BLOCKED")
 */
@property(nonatomic, copy, nullable) NSString *deviceSettings;

/**
 *  Sets the behavior of a device in kiosk mode when a user presses and holds
 *  (long-presses) the Power button.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonActionsUnspecified
 *        Unspecified, defaults to POWER_BUTTON_AVAILABLE. (Value:
 *        "POWER_BUTTON_ACTIONS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonAvailable
 *        The power menu (e.g. Power off, Restart) is shown when a user
 *        long-presses the Power button of a device in kiosk mode. (Value:
 *        "POWER_BUTTON_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_PowerButtonActions_PowerButtonBlocked
 *        The power menu (e.g. Power off, Restart) is not shown when a user
 *        long-presses the Power button of a device in kiosk mode. Note: this
 *        may prevent users from turning off the device. (Value:
 *        "POWER_BUTTON_BLOCKED")
 */
@property(nonatomic, copy, nullable) NSString *powerButtonActions;

/**
 *  Specifies whether system info and notifications are disabled in kiosk mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoDisabled
 *        System info and notifications are disabled in kiosk mode. (Value:
 *        "NOTIFICATIONS_AND_SYSTEM_INFO_DISABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_NotificationsAndSystemInfoEnabled
 *        System info and notifications are shown on the status bar in kiosk
 *        mode.Note: For this policy to take effect, the device's home button
 *        must be enabled using kioskCustomization.systemNavigation. (Value:
 *        "NOTIFICATIONS_AND_SYSTEM_INFO_ENABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_StatusBarUnspecified
 *        Unspecified, defaults to INFO_AND_NOTIFICATIONS_DISABLED. (Value:
 *        "STATUS_BAR_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_StatusBar_SystemInfoOnly
 *        Only system info is shown on the status bar. (Value:
 *        "SYSTEM_INFO_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *statusBar;

/**
 *  Specifies whether system error dialogs for crashed or unresponsive apps are
 *  blocked in kiosk mode. When blocked, the system will force-stop the app as
 *  if the user chooses the "close app" option on the UI.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsEnabled
 *        All system error dialogs such as crash and app not responding (ANR)
 *        are displayed. (Value: "ERROR_AND_WARNINGS_ENABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_ErrorAndWarningsMuted
 *        All system error dialogs, such as crash and app not responding (ANR)
 *        are blocked. When blocked, the system force-stops the app as if the
 *        user closes the app from the UI. (Value: "ERROR_AND_WARNINGS_MUTED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemErrorWarnings_SystemErrorWarningsUnspecified
 *        Unspecified, defaults to ERROR_AND_WARNINGS_MUTED. (Value:
 *        "SYSTEM_ERROR_WARNINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *systemErrorWarnings;

/**
 *  Specifies which navigation features are enabled (e.g. Home, Overview
 *  buttons) in kiosk mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_HomeButtonOnly
 *        Only the home button is enabled. (Value: "HOME_BUTTON_ONLY")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationDisabled
 *        The home and Overview buttons are not accessible. (Value:
 *        "NAVIGATION_DISABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_NavigationEnabled
 *        Home and overview buttons are enabled. (Value: "NAVIGATION_ENABLED")
 *    @arg @c kGTLRAndroidManagement_KioskCustomization_SystemNavigation_SystemNavigationUnspecified
 *        Unspecified, defaults to NAVIGATION_DISABLED. (Value:
 *        "SYSTEM_NAVIGATION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *systemNavigation;

@end


/**
 *  An action to launch an app.
 */
@interface GTLRAndroidManagement_LaunchAppAction : GTLRObject

/** Package name of app to be launched */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  Response to a request to list devices for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "devices" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListDevicesResponse : GTLRCollectionObject

/**
 *  The list of devices.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Device *> *devices;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list enrollment tokens for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "enrollmentTokens" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRAndroidManagement_ListEnrollmentTokensResponse : GTLRCollectionObject

/**
 *  The list of enrollment tokens.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_EnrollmentToken *> *enrollmentTokens;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list enterprises.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "enterprises" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListEnterprisesResponse : GTLRCollectionObject

/**
 *  The list of enterprises.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Enterprise *> *enterprises;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Operation *> *operations;

@end


/**
 *  Response to a request to list policies for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "policies" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListPoliciesResponse : GTLRCollectionObject

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Policy *> *policies;

@end


/**
 *  Response to a request to list web apps for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "webApps" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListWebAppsResponse : GTLRCollectionObject

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of web apps.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_WebApp *> *webApps;

@end


/**
 *  The usageLog buffer on the device has reached 90% of its capacity, therefore
 *  older events may be dropped. Intentionally empty.
 */
@interface GTLRAndroidManagement_LogBufferSizeCriticalEvent : GTLRObject
@end


/**
 *  usageLog policy has been enabled. Intentionally empty.
 */
@interface GTLRAndroidManagement_LoggingStartedEvent : GTLRObject
@end


/**
 *  usageLog policy has been disabled. Intentionally empty.
 */
@interface GTLRAndroidManagement_LoggingStoppedEvent : GTLRObject
@end


/**
 *  The managed configurations template for the app, saved from the managed
 *  configurations iframe.
 */
@interface GTLRAndroidManagement_ManagedConfigurationTemplate : GTLRObject

/**
 *  Optional, a map containing configuration variables defined for the
 *  configuration.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables *configurationVariables;

/** The ID of the managed configurations template. */
@property(nonatomic, copy, nullable) NSString *templateId;

@end


/**
 *  Optional, a map containing configuration variables defined for the
 *  configuration.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables : GTLRObject
@end


/**
 *  Managed property.
 */
@interface GTLRAndroidManagement_ManagedProperty : GTLRObject

/**
 *  The default value of the property. BUNDLE_ARRAY properties don't have a
 *  default value.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id defaultValue;

/**
 *  A longer description of the property, providing more detail of what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** For CHOICE or MULTISELECT properties, the list of possible entries. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedPropertyEntry *> *entries;

/**
 *  The unique key that the app uses to identify the property, e.g.
 *  "com.google.android.gm.fieldname".
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  For BUNDLE_ARRAY properties, the list of nested properties. A BUNDLE_ARRAY
 *  property is at most two levels deep.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *nestedProperties;

/** The name of the property. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  The type of the property.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Bool A property of
 *        boolean type. (Value: "BOOL")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Bundle A bundle of
 *        properties (Value: "BUNDLE")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_BundleArray An array
 *        of property bundles. (Value: "BUNDLE_ARRAY")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Choice A choice of one
 *        item from a set. (Value: "CHOICE")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Hidden A hidden
 *        restriction of string type (the default value can be used to pass
 *        along information that can't be modified, such as a version code).
 *        (Value: "HIDDEN")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Integer A property of
 *        integer type. (Value: "INTEGER")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified
 *        Not used. (Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Multiselect A choice
 *        of multiple items from a set. (Value: "MULTISELECT")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_String A property of
 *        string type. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  An entry of a managed property.
 */
@interface GTLRAndroidManagement_ManagedPropertyEntry : GTLRObject

/** The human-readable name of the value. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The machine-readable value of the entry, which should be used in the
 *  configuration. Not localized.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Removable media was mounted.
 */
@interface GTLRAndroidManagement_MediaMountEvent : GTLRObject

/** Mount point. */
@property(nonatomic, copy, nullable) NSString *mountPoint;

/**
 *  Volume label. Redacted to empty string on organization-owned managed profile
 *  devices.
 */
@property(nonatomic, copy, nullable) NSString *volumeLabel;

@end


/**
 *  Removable media was unmounted.
 */
@interface GTLRAndroidManagement_MediaUnmountEvent : GTLRObject

/** Mount point. */
@property(nonatomic, copy, nullable) NSString *mountPoint;

/**
 *  Volume label. Redacted to empty string on organization-owned managed profile
 *  devices.
 */
@property(nonatomic, copy, nullable) NSString *volumeLabel;

@end


/**
 *  An event related to memory and storage measurements.
 */
@interface GTLRAndroidManagement_MemoryEvent : GTLRObject

/**
 *  The number of free bytes in the medium, or for EXTERNAL_STORAGE_DETECTED,
 *  the total capacity in bytes of the storage medium.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *byteCount;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected
 *        A new external storage medium was detected. The reported byte count is
 *        the total capacity of the storage medium. (Value:
 *        "EXTERNAL_STORAGE_DETECTED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured
 *        Free space in an external storage medium was measured. (Value:
 *        "EXTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved
 *        An external storage medium was removed. The reported byte count is
 *        zero. (Value: "EXTERNAL_STORAGE_REMOVED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured
 *        Free space in internal storage was measured. (Value:
 *        "INTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "MEMORY_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured Free
 *        space in RAM was measured. (Value: "RAM_MEASURED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Information about device memory and storage.
 */
@interface GTLRAndroidManagement_MemoryInfo : GTLRObject

/**
 *  Total internal storage on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalInternalStorage;

/**
 *  Total RAM on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalRam;

@end


/**
 *  Device network info.
 */
@interface GTLRAndroidManagement_NetworkInfo : GTLRObject

/** IMEI number of the GSM device. For example, A1000031212. */
@property(nonatomic, copy, nullable) NSString *imei;

/** MEID number of the CDMA device. For example, A00000292788E1. */
@property(nonatomic, copy, nullable) NSString *meid;

/** Alphabetic name of current registered operator. For example, Vodafone. */
@property(nonatomic, copy, nullable) NSString *networkOperatorName;

/**
 *  Provides telephony information associated with each SIM card on the device.
 *  Only supported on fully managed devices starting from Android API level 23.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_TelephonyInfo *> *telephonyInfos;

/** Wi-Fi MAC address of the device. For example, 7c:11:11:11:11:11. */
@property(nonatomic, copy, nullable) NSString *wifiMacAddress;

@end


/**
 *  Provides detail about non-compliance with a policy setting.
 */
@interface GTLRAndroidManagement_NonComplianceDetail : GTLRObject

/**
 *  If the policy setting could not be applied, the current value of the setting
 *  on the device.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id currentValue;

/**
 *  For settings with nested fields, if a particular nested field is out of
 *  compliance, this specifies the full path to the offending field. The path is
 *  formatted in the same way the policy JSON field would be referenced in
 *  JavaScript, that is: 1) For object-typed fields, the field name is followed
 *  by a dot then by a subfield name. 2) For array-typed fields, the field name
 *  is followed by the array index enclosed in brackets. For example, to
 *  indicate a problem with the url field in the externalData field in the 3rd
 *  application, the path would be applications[2].externalData.url
 */
@property(nonatomic, copy, nullable) NSString *fieldPath;

/**
 *  If package_name is set and the non-compliance reason is APP_NOT_INSTALLED or
 *  APP_NOT_UPDATED, the detailed reason the app can't be installed or updated.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress
 *        The installation is still in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown
 *        An unknown condition is preventing the app from being installed. Some
 *        potential reasons are that the device doesn't have enough storage, the
 *        device network connection is unreliable, or the installation is taking
 *        longer than expected. The installation will be retried automatically.
 *        (Value: "INSTALLATION_FAILURE_REASON_UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified
 *        This value is disallowed. (Value:
 *        "INSTALLATION_FAILURE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining
 *        There are no licenses available to assign to the user. (Value:
 *        "NO_LICENSES_REMAINING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved
 *        The app has not been approved by the admin. (Value: "NOT_APPROVED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry
 *        The app is not available in the user's country. (Value:
 *        "NOT_AVAILABLE_IN_COUNTRY")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice
 *        The app is incompatible with the device. (Value:
 *        "NOT_COMPATIBLE_WITH_DEVICE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled
 *        The enterprise is no longer enrolled with Managed Google Play or the
 *        admin has not accepted the latest Managed Google Play Terms of
 *        Service. (Value: "NOT_ENROLLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound
 *        The app was not found in Play. (Value: "NOT_FOUND")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted
 *        The app has new permissions that have not been accepted by the admin.
 *        (Value: "PERMISSIONS_NOT_ACCEPTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid
 *        The user is no longer valid. The user may have been deleted or
 *        disabled. (Value: "USER_INVALID")
 */
@property(nonatomic, copy, nullable) NSString *installationFailureReason;

/**
 *  The reason the device is not in compliance with the setting.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of the Android version
 *        running on the device. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible
 *        The setting can't be applied to the app because the app doesn't
 *        support it, for example because its target SDK version is not high
 *        enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled
 *        A blocked app is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled
 *        The app required to implement the policy is not installed. (Value:
 *        "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated
 *        The app is installed, but it hasn't been updated to the minimum
 *        version code specified by policy. (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ManagementMode
 *        The management mode (profile owner, device owner, etc.) doesn't
 *        support the setting. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is disallowed. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending
 *        The setting hasn't been applied at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name indicating which app is out of compliance, if applicable.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

/** Additional context for specific_non_compliance_reason. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SpecificNonComplianceContext *specificNonComplianceContext;

/**
 *  The policy-specific reason the device is not in compliance with the setting.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiApiLevel
 *        The ONC Wi-Fi setting is not supported in the API level of the Android
 *        version running on the device. fieldPath specifies which field value
 *        is not supported. oncWifiContext is set. nonComplianceReason is set to
 *        API_LEVEL. (Value: "ONC_WIFI_API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_OncWifiInvalidValue
 *        There is an incorrect value in ONC Wi-Fi configuration. fieldPath
 *        specifies which field value is incorrect. oncWifiContext is set.
 *        nonComplianceReason is set to INVALID_VALUE. (Value:
 *        "ONC_WIFI_INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordExpired
 *        The device or profile password has expired. passwordPoliciesContext is
 *        set. nonComplianceReason is set to USER_ACTION. (Value:
 *        "PASSWORD_POLICIES_PASSWORD_EXPIRED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesPasswordNotSufficient
 *        The device password does not satisfy password requirements.
 *        passwordPoliciesContext is set. nonComplianceReason is set to
 *        USER_ACTION. (Value: "PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_PasswordPoliciesUserCredentialsConfirmationRequired
 *        User needs to confirm credentials by entering the screen lock. Fields
 *        in specific_non_compliance_context are not set. nonComplianceReason is
 *        set to USER_ACTION. (Value:
 *        "PASSWORD_POLICIES_USER_CREDENTIALS_CONFIRMATION_REQUIRED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_SpecificNonComplianceReason_SpecificNonComplianceReasonUnspecified
 *        Specific non-compliance reason is not specified. Fields in
 *        specific_non_compliance_context are not set. (Value:
 *        "SPECIFIC_NON_COMPLIANCE_REASON_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *specificNonComplianceReason;

@end


/**
 *  A compliance rule condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device. A NonComplianceDetail matches a
 *  NonComplianceDetailCondition if all the fields which are set within the
 *  NonComplianceDetailCondition match the corresponding NonComplianceDetail
 *  fields.
 */
@interface GTLRAndroidManagement_NonComplianceDetailCondition : GTLRObject

/**
 *  The reason the device is not in compliance with the setting. If not set,
 *  then this condition matches any reason.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of the Android version
 *        running on the device. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible
 *        The setting can't be applied to the app because the app doesn't
 *        support it, for example because its target SDK version is not high
 *        enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled
 *        A blocked app is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled
 *        The app required to implement the policy is not installed. (Value:
 *        "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated
 *        The app is installed, but it hasn't been updated to the minimum
 *        version code specified by policy. (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ManagementMode
 *        The management mode (profile owner, device owner, etc.) doesn't
 *        support the setting. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is disallowed. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending
 *        The setting hasn't been applied at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name of the app that's out of compliance. If not set, then this
 *  condition matches any package name.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field. If not set, then this condition matches any setting name.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

@end


/**
 *  This feature is not generally available.
 */
@interface GTLRAndroidManagement_OncCertificateProvider : GTLRObject

/** This feature is not generally available. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *certificateReferences;

/** This feature is not generally available. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ContentProviderEndpoint *contentProviderEndpoint;

@end


/**
 *  Additional context for non-compliance related to Wi-Fi configuration.
 */
@interface GTLRAndroidManagement_OncWifiContext : GTLRObject

/** The GUID of non-compliant Wi-Fi configuration. */
@property(nonatomic, copy, nullable) NSString *wifiGuid;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRAndroidManagement_Operation : GTLRObject

/**
 *  If the value is false, it means the operation is still in progress. If true,
 *  the operation is completed, and either error or response is available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the name should
 *  be a resource name ending with operations/{unique_id}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Response : GTLRObject
@end


/**
 *  Device was shutdown. Intentionally empty.
 */
@interface GTLRAndroidManagement_OsShutdownEvent : GTLRObject
@end


/**
 *  Device was started.
 */
@interface GTLRAndroidManagement_OsStartupEvent : GTLRObject

/**
 *  Verified Boot state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Green
 *        Indicates that there is a full chain of trust extending from the
 *        bootloader to verified partitions including the bootloader, boot
 *        partition, and all verified partitions. (Value: "GREEN")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Orange
 *        Indicates that the device may be freely modified. Device integrity is
 *        left to the user to verify out-of-band. (Value: "ORANGE")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_VerifiedBootStateUnspecified
 *        Unknown value. (Value: "VERIFIED_BOOT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerifiedBootState_Yellow
 *        Indicates that the boot partition has been verified using the embedded
 *        certificate and the signature is valid. (Value: "YELLOW")
 */
@property(nonatomic, copy, nullable) NSString *verifiedBootState;

/**
 *  dm-verity mode.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_Disabled
 *        Indicates that dm-verity is disabled on device. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_DmVerityModeUnspecified
 *        Unknown value. (Value: "DM_VERITY_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_Enforcing
 *        Indicates that the device will be restarted when corruption is
 *        detected. (Value: "ENFORCING")
 *    @arg @c kGTLRAndroidManagement_OsStartupEvent_VerityMode_IoError Indicates
 *        that an I/O error will be returned for an attempt to read corrupted
 *        data blocks (also known as eio boot state). (Value: "IO_ERROR")
 */
@property(nonatomic, copy, nullable) NSString *verityMode;

@end


/**
 *  A list of package names.
 */
@interface GTLRAndroidManagement_PackageNameList : GTLRObject

/** A list of package names. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

@end


/**
 *  Additional context for non-compliance related to password policies.
 */
@interface GTLRAndroidManagement_PasswordPoliciesContext : GTLRObject

/**
 *  The scope of non-compliant password.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeDevice
 *        The password requirements are only applied to the device. (Value:
 *        "SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeProfile
 *        The password requirements are only applied to the work profile.
 *        (Value: "SCOPE_PROFILE")
 *    @arg @c kGTLRAndroidManagement_PasswordPoliciesContext_PasswordPolicyScope_ScopeUnspecified
 *        The scope is unspecified. The password requirements are applied to the
 *        work profile for work profile devices and the whole device for fully
 *        managed or dedicated devices. (Value: "SCOPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *passwordPolicyScope;

@end


/**
 *  Requirements for the password used to unlock a device.
 */
@interface GTLRAndroidManagement_PasswordRequirements : GTLRObject

/**
 *  Number of incorrect device-unlock passwords that can be entered before a
 *  device is wiped. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumFailedPasswordsForWipe;

/** Password expiration timeout. */
@property(nonatomic, strong, nullable) GTLRDuration *passwordExpirationTimeout;

/**
 *  The length of the password history. After setting this field, the user won't
 *  be able to enter a new password that is the same as any password in the
 *  history. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordHistoryLength;

/**
 *  The minimum allowed password length. A value of 0 means there is no
 *  restriction. Only enforced when password_quality is NUMERIC,
 *  NUMERIC_COMPLEX, ALPHABETIC, ALPHANUMERIC, or COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLength;

/**
 *  Minimum number of letters required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLetters;

/**
 *  Minimum number of lower case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLowerCase;

/**
 *  Minimum number of non-letter characters (numerical digits or symbols)
 *  required in the password. Only enforced when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNonLetter;

/**
 *  Minimum number of numerical digits required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNumeric;

/**
 *  Minimum number of symbols required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumSymbols;

/**
 *  Minimum number of upper case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumUpperCase;

/**
 *  The required password quality.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic
 *        The password must contain alphabetic (or symbol) characters.This, when
 *        applied on personally owned work profile devices on Android 12
 *        device-scoped, will be treated as COMPLEXITY_HIGH for application. See
 *        PasswordQuality for details. (Value: "ALPHABETIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric
 *        The password must contain both numeric and alphabetic (or symbol)
 *        characters.This, when applied on personally owned work profile devices
 *        on Android 12 device-scoped, will be treated as COMPLEXITY_HIGH for
 *        application. See PasswordQuality for details. (Value: "ALPHANUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak
 *        The device must be secured with a low-security biometric recognition
 *        technology, at minimum. This includes technologies that can recognize
 *        the identity of an individual that are roughly equivalent to a 3-digit
 *        PIN (false detection is less than 1 in 1,000).This, when applied on
 *        personally owned work profile devices on Android 12 device-scoped,
 *        will be treated as COMPLEXITY_LOW for application. See PasswordQuality
 *        for details. (Value: "BIOMETRIC_WEAK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex
 *        The password must meet the minimum requirements specified in
 *        passwordMinimumLength, passwordMinimumLetters, passwordMinimumSymbols,
 *        etc. For example, if passwordMinimumSymbols is 2, the password must
 *        contain at least two symbols.This, when applied on personally owned
 *        work profile devices on Android 12 device-scoped, will be treated as
 *        COMPLEXITY_HIGH for application. In this case, the requirements in
 *        passwordMinimumLength, passwordMinimumLetters, passwordMinimumSymbols,
 *        etc are not applied. See PasswordQuality for details. (Value:
 *        "COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityHigh
 *        Define the high password complexity band as:On Android 12 and above:
 *        PIN with no repeating (4444) or ordered (1234, 4321, 2468) sequences,
 *        length at least 8 alphabetic, length at least 6 alphanumeric, length
 *        at least 6This sets the minimum complexity band which the password
 *        must meet.Enforcement varies among different Android versions,
 *        management modes and password scopes. See PasswordQuality for details.
 *        (Value: "COMPLEXITY_HIGH")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityLow
 *        Define the low password complexity band as: pattern PIN with repeating
 *        (4444) or ordered (1234, 4321, 2468) sequencesThis sets the minimum
 *        complexity band which the password must meet.Enforcement varies among
 *        different Android versions, management modes and password scopes. See
 *        PasswordQuality for details. (Value: "COMPLEXITY_LOW")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_ComplexityMedium
 *        Define the medium password complexity band as: PIN with no repeating
 *        (4444) or ordered (1234, 4321, 2468) sequences, length at least 4
 *        alphabetic, length at least 4 alphanumeric, length at least 4This sets
 *        the minimum complexity band which the password must meet.Enforcement
 *        varies among different Android versions, management modes and password
 *        scopes. See PasswordQuality for details. (Value: "COMPLEXITY_MEDIUM")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric
 *        The password must contain numeric characters.This, when applied on
 *        personally owned work profile devices on Android 12 device-scoped,
 *        will be treated as COMPLEXITY_MEDIUM for application. See
 *        PasswordQuality for details. (Value: "NUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex
 *        The password must contain numeric characters with no repeating (4444)
 *        or ordered (1234, 4321, 2468) sequences.This, when applied on
 *        personally owned work profile devices on Android 12 device-scoped,
 *        will be treated as COMPLEXITY_MEDIUM for application. See
 *        PasswordQuality for details. (Value: "NUMERIC_COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified
 *        There are no password requirements. (Value:
 *        "PASSWORD_QUALITY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something
 *        A password is required, but there are no restrictions on what the
 *        password must contain.This, when applied on personally owned work
 *        profile devices on Android 12 device-scoped, will be treated as
 *        COMPLEXITY_LOW for application. See PasswordQuality for details.
 *        (Value: "SOMETHING")
 */
@property(nonatomic, copy, nullable) NSString *passwordQuality;

/**
 *  The scope that the password requirement applies to.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeDevice
 *        The password requirements are only applied to the device. (Value:
 *        "SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeProfile
 *        The password requirements are only applied to the work profile.
 *        (Value: "SCOPE_PROFILE")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeUnspecified
 *        The scope is unspecified. The password requirements are applied to the
 *        work profile for work profile devices and the whole device for fully
 *        managed or dedicated devices. (Value: "SCOPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *passwordScope;

/**
 *  The length of time after a device or work profile is unlocked using a strong
 *  form of authentication (password, PIN, pattern) that it can be unlocked
 *  using any other authentication method (e.g. fingerprint, trust agents,
 *  face). After the specified time period elapses, only strong forms of
 *  authentication can be used to unlock the device or work profile.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequireEveryDay
 *        The timeout period is set to 24 hours. (Value: "REQUIRE_EVERY_DAY")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_RequirePasswordUnlockUnspecified
 *        Unspecified. Defaults to USE_DEFAULT_DEVICE_TIMEOUT. (Value:
 *        "REQUIRE_PASSWORD_UNLOCK_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_RequirePasswordUnlock_UseDefaultDeviceTimeout
 *        The timeout period is set to the device’s default. (Value:
 *        "USE_DEFAULT_DEVICE_TIMEOUT")
 */
@property(nonatomic, copy, nullable) NSString *requirePasswordUnlock;

/**
 *  Controls whether a unified lock is allowed for the device and the work
 *  profile, on devices running Android 9 and above with a work profile. This
 *  can be set only if password_scope is set to SCOPE_PROFILE, the policy will
 *  be rejected otherwise. If user has not set a separate work lock and this
 *  field is set to REQUIRE_SEPARATE_WORK_LOCK, a NonComplianceDetail is
 *  reported with nonComplianceReason set to USER_ACTION.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_AllowUnifiedWorkAndPersonalLock
 *        A common lock for the device and the work profile is allowed. (Value:
 *        "ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_RequireSeparateWorkLock
 *        A separate lock for the work profile is required. (Value:
 *        "REQUIRE_SEPARATE_WORK_LOCK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_UnifiedLockSettings_UnifiedLockSettingsUnspecified
 *        Unspecified. Defaults to ALLOW_UNIFIED_WORK_AND_PERSONAL_LOCK. (Value:
 *        "UNIFIED_LOCK_SETTINGS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *unifiedLockSettings;

@end


/**
 *  The result of an attempt to clear the data of a single app.
 */
@interface GTLRAndroidManagement_PerAppResult : GTLRObject

/**
 *  The result of an attempt to clear the data of a single app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_ApiLevel This
 *        app’s data could not be cleared because the device API level does not
 *        support this command. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_AppNotFound
 *        This app’s data could not be cleared because the app was not found.
 *        (Value: "APP_NOT_FOUND")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_AppProtected
 *        This app’s data could not be cleared because the app is protected. For
 *        example, this may apply to apps critical to the functioning of the
 *        device, such as Google Play Store. (Value: "APP_PROTECTED")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_ClearingResultUnspecified
 *        Unspecified result. (Value: "CLEARING_RESULT_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PerAppResult_ClearingResult_Success This
 *        app’s data was successfully cleared. (Value: "SUCCESS")
 */
@property(nonatomic, copy, nullable) NSString *clearingResult;

@end


/**
 *  Configuration for an Android permission and its grant state.
 */
@interface GTLRAndroidManagement_PermissionGrant : GTLRObject

/**
 *  The Android permission or group, e.g. android.permission.READ_CALENDAR or
 *  android.permission_group.CALENDAR.
 */
@property(nonatomic, copy, nullable) NSString *permission;

/**
 *  The policy for granting the permission.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Deny Automatically
 *        deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Grant Automatically
 *        grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Prompt Prompt the
 *        user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *policy;

@end


/**
 *  A default activity for handling intents that match a particular intent
 *  filter. Note: To set up a kiosk, use InstallType to KIOSK rather than use
 *  persistent preferred activities.
 */
@interface GTLRAndroidManagement_PersistentPreferredActivity : GTLRObject

/**
 *  The intent actions to match in the filter. If any actions are included in
 *  the filter, then an intent's action must be one of those values for it to
 *  match. If no actions are included, the intent action is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *actions;

/**
 *  The intent categories to match in the filter. An intent includes the
 *  categories that it requires, all of which must be included in the filter in
 *  order to match. In other words, adding a category to the filter has no
 *  impact on matching unless that category is specified in the intent.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *categories;

/**
 *  The activity that should be the default intent handler. This should be an
 *  Android component name, e.g. com.android.enterprise.app/.MainActivity.
 *  Alternatively, the value may be the package name of an app, which causes
 *  Android Device Policy to choose an appropriate activity from the app to
 *  handle the intent.
 */
@property(nonatomic, copy, nullable) NSString *receiverActivity;

@end


/**
 *  Policies for apps in the personal profile of a company-owned device with a
 *  work profile.
 */
@interface GTLRAndroidManagement_PersonalApplicationPolicy : GTLRObject

/**
 *  The type of installation to perform.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Available
 *        The app is available to install in the personal profile. (Value:
 *        "AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_Blocked
 *        The app is blocked and can't be installed in the personal profile.
 *        (Value: "BLOCKED")
 *    @arg @c kGTLRAndroidManagement_PersonalApplicationPolicy_InstallType_InstallTypeUnspecified
 *        Unspecified. Defaults to AVAILABLE. (Value:
 *        "INSTALL_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *installType;

/** The package name of the application. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  Policies controlling personal usage on a company-owned device with a work
 *  profile.
 */
@interface GTLRAndroidManagement_PersonalUsagePolicies : GTLRObject

/** Account types that can't be managed by the user. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accountTypesWithManagementDisabled;

/**
 *  If true, the camera is disabled on the personal profile.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cameraDisabled;

/**
 *  Controls how long the work profile can stay off. The duration must be at
 *  least 3 days.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxDaysWithWorkOff;

/** Policy applied to applications in the personal profile. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PersonalApplicationPolicy *> *personalApplications;

/**
 *  Used together with personalApplications to control how apps in the personal
 *  profile are allowed or blocked.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Allowlist
 *        Only apps explicitly specified in personalApplications with
 *        installType set to AVAILABLE are allowed to be installed in the
 *        personal profile. (Value: "ALLOWLIST")
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blacklist
 *        All Play Store apps are available for installation in the personal
 *        profile, except those whose installType is BLOCKED in
 *        personalApplications. (Value: "BLACKLIST")
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_Blocklist
 *        All Play Store apps are available for installation in the personal
 *        profile, except those whose installType is BLOCKED in
 *        personalApplications. (Value: "BLOCKLIST")
 *    @arg @c kGTLRAndroidManagement_PersonalUsagePolicies_PersonalPlayStoreMode_PlayStoreModeUnspecified
 *        Unspecified. Defaults to BLOCKLIST. (Value:
 *        "PLAY_STORE_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *personalPlayStoreMode;

/**
 *  If true, screen capture is disabled for all users.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenCaptureDisabled;

@end


/**
 *  A policy resource represents a group of settings that govern the behavior of
 *  a managed device and the apps installed on it.
 */
@interface GTLRAndroidManagement_Policy : GTLRObject

/** Account types that can't be managed by the user. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accountTypesWithManagementDisabled;

/**
 *  Whether adding new users and profiles is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *addUserDisabled;

/**
 *  Whether adjusting the master volume is disabled. Also mutes the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adjustVolumeDisabled;

/**
 *  Security policies set to secure values by default. To maintain the security
 *  posture of a device, we don't recommend overriding any of the default
 *  values.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AdvancedSecurityOverrides *advancedSecurityOverrides;

/**
 *  Configuration for an always-on VPN connection. Use with vpn_config_disabled
 *  to prevent modification of this setting.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AlwaysOnVpnPackage *alwaysOnVpnPackage;

/**
 *  The app tracks for Android Device Policy the device can access. The device
 *  receives the latest version among all accessible tracks. If no tracks are
 *  specified, then the device only uses the production track.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *androidDevicePolicyTracks;

/**
 *  Deprecated. Use autoUpdateMode instead.When autoUpdateMode is set to
 *  AUTO_UPDATE_POSTPONED or AUTO_UPDATE_HIGH_PRIORITY, this field has no
 *  effect.The app auto update policy, which controls when automatic app updates
 *  can be applied.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Always Apps are
 *        auto-updated at any time. Data charges may apply. (Value: "ALWAYS")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_AppAutoUpdatePolicyUnspecified
 *        The auto-update policy is not set. Equivalent to CHOICE_TO_THE_USER.
 *        (Value: "APP_AUTO_UPDATE_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_ChoiceToTheUser
 *        The user can control auto-updates. (Value: "CHOICE_TO_THE_USER")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Never Apps are
 *        never auto-updated. (Value: "NEVER")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_WifiOnly Apps
 *        are auto-updated over Wi-Fi only. (Value: "WIFI_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *appAutoUpdatePolicy;

/** Policy applied to apps. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPolicy *> *applications;

/**
 *  Whether auto date, time, and time zone are enabled on a company-owned
 *  device. If this is set, then autoTimeRequired is ignored.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneEnforced
 *        Enforce auto date, time, and time zone on the device. (Value:
 *        "AUTO_DATE_AND_TIME_ZONE_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUnspecified
 *        Unspecified. Defaults to AUTO_DATE_AND_TIME_ZONE_USER_CHOICE. (Value:
 *        "AUTO_DATE_AND_TIME_ZONE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_AutoDateAndTimeZone_AutoDateAndTimeZoneUserChoice
 *        Auto date, time, and time zone are left to user's choice. (Value:
 *        "AUTO_DATE_AND_TIME_ZONE_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *autoDateAndTimeZone;

/**
 *  Whether auto time is required, which prevents the user from manually setting
 *  the date and time. If autoDateAndTimeZone is set, this field is ignored.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoTimeRequired;

/**
 *  Whether applications other than the ones configured in applications are
 *  blocked from being installed. When set, applications that were installed
 *  under a previous policy but no longer appear in the policy are automatically
 *  uninstalled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockApplicationsEnabled;

/**
 *  Whether configuring bluetooth is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothConfigDisabled;

/**
 *  Whether bluetooth contact sharing is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothContactSharingDisabled;

/**
 *  Whether bluetooth is disabled. Prefer this setting over
 *  bluetooth_config_disabled because bluetooth_config_disabled can be bypassed
 *  by the user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothDisabled;

/**
 *  Controls the use of the camera and whether the user has access to the camera
 *  access toggle.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessDisabled
 *        The field camera_disabled is ignored. All cameras on the device are
 *        disabled (for fully managed devices, this applies device-wide and for
 *        work profiles this applies only to the work profile).There are no
 *        explicit restrictions placed on the camera access toggle on Android 12
 *        and above: on fully managed devices, the camera access toggle has no
 *        effect as all cameras are disabled. On devices with a work profile,
 *        this toggle has no effect on apps in the work profile, but it affects
 *        apps outside the work profile. (Value: "CAMERA_ACCESS_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessEnforced
 *        The field camera_disabled is ignored. All cameras on the device are
 *        available. On fully managed devices running Android 12 and above, the
 *        user is unable to use the camera access toggle. On devices which are
 *        not fully managed or which run Android 11 or below, this is equivalent
 *        to CAMERA_ACCESS_USER_CHOICE. (Value: "CAMERA_ACCESS_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUnspecified
 *        If camera_disabled is true, this is equivalent to
 *        CAMERA_ACCESS_DISABLED. Otherwise, this is equivalent to
 *        CAMERA_ACCESS_USER_CHOICE. (Value: "CAMERA_ACCESS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_CameraAccess_CameraAccessUserChoice
 *        The field camera_disabled is ignored. This is the default device
 *        behaviour: all cameras on the device are available. On Android 12 and
 *        above, the user can use the camera access toggle. (Value:
 *        "CAMERA_ACCESS_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *cameraAccess;

/**
 *  If camera_access is set to any value other than CAMERA_ACCESS_UNSPECIFIED,
 *  this has no effect. Otherwise this field controls whether cameras are
 *  disabled: If true, all cameras are disabled, otherwise they are available.
 *  For fully managed devices this field applies for all apps on the device. For
 *  work profiles, this field applies only to apps in the work profile, and the
 *  camera access of apps outside the work profile is unaffected.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cameraDisabled;

/**
 *  Whether configuring cell broadcast is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cellBroadcastsConfigDisabled;

/**
 *  Rules for determining apps' access to private keys. See ChoosePrivateKeyRule
 *  for details.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ChoosePrivateKeyRule *> *choosePrivateKeyRules;

/**
 *  Rules declaring which mitigating actions to take when a device is not
 *  compliant with its policy. When the conditions for multiple rules are
 *  satisfied, all of the mitigating actions for the rules are taken. There is a
 *  maximum limit of 100 rules. Use policy enforcement rules instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ComplianceRule *> *complianceRules;

/**
 *  Whether creating windows besides app windows is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *createWindowsDisabled;

/**
 *  Whether configuring user credentials is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *credentialsConfigDisabled;

/** Cross-profile policies applied on the device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CrossProfilePolicies *crossProfilePolicies;

/**
 *  Whether roaming data services are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataRoamingDisabled;

/**
 *  Whether the user is allowed to enable debugging features.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *debuggingFeaturesAllowed;

/**
 *  The default permission policy for runtime permission requests.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/** The device owner information to be shown on the lock screen. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *deviceOwnerLockScreenInfo;

/**
 *  Whether encryption is enabled
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithoutPassword
 *        Encryption required but no password required to boot (Value:
 *        "ENABLED_WITHOUT_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithPassword
 *        Encryption required with password required to boot (Value:
 *        "ENABLED_WITH_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EncryptionPolicyUnspecified
 *        This value is ignored, i.e. no encryption required (Value:
 *        "ENCRYPTION_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionPolicy;

/**
 *  Whether app verification is force-enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ensureVerifyAppsEnabled;

/**
 *  Whether factory resetting from settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *factoryResetDisabled;

/**
 *  Email addresses of device administrators for factory reset protection. When
 *  the device is factory reset, it will require one of these admins to log in
 *  with the Google account email and password to unlock the device. If no
 *  admins are specified, the device won't provide factory reset protection.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *frpAdminEmails;

/**
 *  Whether the user is allowed to have fun. Controls whether the Easter egg
 *  game in Settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *funDisabled;

/**
 *  Whether user installation of apps is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installAppsDisabled;

/**
 *  This field has no effect.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installUnknownSourcesAllowed;

/**
 *  If true, this disables the Lock Screen
 *  (https://source.android.com/docs/core/display/multi_display/lock-screen) for
 *  primary and/or secondary displays.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *keyguardDisabled;

/** Disabled keyguard customizations, such as widgets. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *keyguardDisabledFeatures;

/**
 *  Settings controlling the behavior of a device in kiosk mode. To enable kiosk
 *  mode, set kioskCustomLauncherEnabled to true or specify an app in the policy
 *  with installType KIOSK.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KioskCustomization *kioskCustomization;

/**
 *  Whether the kiosk custom launcher is enabled. This replaces the home screen
 *  with a launcher that locks down the device to the apps installed via the
 *  applications setting. Apps appear on a single page in alphabetical order.
 *  Use kioskCustomization to further configure the kiosk device behavior.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kioskCustomLauncherEnabled;

/**
 *  The degree of location detection enabled.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_BatterySaving On
 *        Android 8 and below, only the network location provider is enabled. On
 *        Android 9 and above, this is equivalent to LOCATION_ENFORCED. (Value:
 *        "BATTERY_SAVING")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_HighAccuracy On Android
 *        8 and below, all location detection methods are enabled, including
 *        GPS, networks, and other sensors. On Android 9 and above, this is
 *        equivalent to LOCATION_ENFORCED. (Value: "HIGH_ACCURACY")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationDisabled
 *        Disable location setting on the device. (Value: "LOCATION_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationEnforced Enable
 *        location setting on the device. (Value: "LOCATION_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationModeUnspecified
 *        Defaults to LOCATION_USER_CHOICE. (Value: "LOCATION_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationUserChoice
 *        Location setting is not restricted on the device. No specific behavior
 *        is set or enforced. (Value: "LOCATION_USER_CHOICE")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_Off On Android 8 and
 *        below, location setting and accuracy are disabled. On Android 9 and
 *        above, this is equivalent to LOCATION_DISABLED. (Value: "OFF")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_SensorsOnly On Android
 *        8 and below, only GPS and other sensors are enabled. On Android 9 and
 *        above, this is equivalent to LOCATION_ENFORCED. (Value:
 *        "SENSORS_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *locationMode;

/**
 *  A message displayed to the user in the device administators settings screen.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *longSupportMessage;

/**
 *  Maximum time in milliseconds for user activity until the device locks. A
 *  value of 0 means there is no restriction.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumTimeToLock;

/**
 *  Controls the use of the microphone and whether the user has access to the
 *  microphone access toggle. This applies only on fully managed devices.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessDisabled
 *        The field unmute_microphone_disabled is ignored. The microphone on the
 *        device is disabled (for fully managed devices, this applies
 *        device-wide).The microphone access toggle has no effect as the
 *        microphone is disabled. (Value: "MICROPHONE_ACCESS_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessEnforced
 *        The field unmute_microphone_disabled is ignored. The microphone on the
 *        device is available. On devices running Android 12 and above, the user
 *        is unable to use the microphone access toggle. On devices which run
 *        Android 11 or below, this is equivalent to
 *        MICROPHONE_ACCESS_USER_CHOICE. (Value: "MICROPHONE_ACCESS_ENFORCED")
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUnspecified
 *        If unmute_microphone_disabled is true, this is equivalent to
 *        MICROPHONE_ACCESS_DISABLED. Otherwise, this is equivalent to
 *        MICROPHONE_ACCESS_USER_CHOICE. (Value:
 *        "MICROPHONE_ACCESS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_MicrophoneAccess_MicrophoneAccessUserChoice
 *        The field unmute_microphone_disabled is ignored. This is the default
 *        device behaviour: the microphone on the device is available. On
 *        Android 12 and above, the user can use the microphone access toggle.
 *        (Value: "MICROPHONE_ACCESS_USER_CHOICE")
 */
@property(nonatomic, copy, nullable) NSString *microphoneAccess;

/**
 *  The minimum allowed Android API level.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimumApiLevel;

/**
 *  Whether configuring mobile networks is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mobileNetworksConfigDisabled;

/**
 *  Whether adding or removing accounts is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *modifyAccountsDisabled;

/**
 *  Whether the user mounting physical external media is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mountPhysicalMediaDisabled;

/**
 *  The name of the policy in the form
 *  enterprises/{enterpriseId}/policies/{policyId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the network escape hatch is enabled. If a network connection can't
 *  be made at boot time, the escape hatch prompts the user to temporarily
 *  connect to a network in order to refresh the device policy. After applying
 *  policy, the temporary network will be forgotten and the device will continue
 *  booting. This prevents being unable to connect to a network if there is no
 *  suitable network in the last policy and the device boots into an app in lock
 *  task mode, or the user is otherwise unable to reach device settings.Note:
 *  Setting wifiConfigDisabled to true will override this setting under specific
 *  circumstances. Please see wifiConfigDisabled for further details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkEscapeHatchEnabled;

/**
 *  Whether resetting network settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkResetDisabled;

/** This feature is not generally available. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_OncCertificateProvider *> *oncCertificateProviders;

/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Policy_OpenNetworkConfiguration *openNetworkConfiguration;

/**
 *  Whether using NFC to beam data from apps is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outgoingBeamDisabled;

/**
 *  Whether outgoing calls are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outgoingCallsDisabled;

/**
 *  Password requirement policies. Different policies can be set for work
 *  profile or fully managed devices by setting the password_scope field in the
 *  policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PasswordRequirements *> *passwordPolicies;

/**
 *  Password requirements. The field
 *  password_requirements.require_password_unlock must not be set. DEPRECATED -
 *  Use passwordPolicies.Note:Complexity-based values of PasswordQuality, that
 *  is, COMPLEXITY_LOW, COMPLEXITY_MEDIUM, and COMPLEXITY_HIGH, cannot be used
 *  here. unified_lock_settings cannot be used here.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PasswordRequirements *passwordRequirements;

/**
 *  Explicit permission or group grants or denials for all apps. These values
 *  override the default_permission_policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

/**
 *  Specifies permitted accessibility services. If the field is not set, any
 *  accessibility service can be used. If the field is set, only the
 *  accessibility services in this list and the system's built-in accessibility
 *  service can be used. In particular, if the field is set to empty, only the
 *  system's built-in accessibility servicess can be used. This can be set on
 *  fully managed devices and on work profiles. When applied to a work profile,
 *  this affects both the personal profile and the work profile.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PackageNameList *permittedAccessibilityServices;

/**
 *  If present, only the input methods provided by packages in this list are
 *  permitted. If this field is present, but the list is empty, then only system
 *  input methods are permitted.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PackageNameList *permittedInputMethods;

/** Default intent handler activities. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PersistentPreferredActivity *> *persistentPreferredActivities;

/** Policies managing personal usage on a company-owned device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PersonalUsagePolicies *personalUsagePolicies;

/**
 *  This mode controls which apps are available to the user in the Play Store
 *  and the behavior on the device when apps are removed from the policy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_Blacklist All apps are
 *        available and any app that should not be on the device should be
 *        explicitly marked as 'BLOCKED' in the applications policy. (Value:
 *        "BLACKLIST")
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_PlayStoreModeUnspecified
 *        Unspecified. Defaults to WHITELIST. (Value:
 *        "PLAY_STORE_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_Whitelist Only apps
 *        that are in the policy are available and any app not in the policy
 *        will be automatically uninstalled from the device. (Value:
 *        "WHITELIST")
 */
@property(nonatomic, copy, nullable) NSString *playStoreMode;

/**
 *  Rules that define the behavior when a particular policy can not be applied
 *  on device
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PolicyEnforcementRule *> *policyEnforcementRules;

/**
 *  Controls whether preferential network service is enabled on the work
 *  profile. For example, an organization may have an agreement with a carrier
 *  that all of the work data from its employees' devices will be sent via a
 *  network service dedicated for enterprise use. An example of a supported
 *  preferential network service is the enterprise slice on 5G networks. This
 *  has no effect on fully managed devices.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceDisabled
 *        Preferential network service is disabled on the work profile. (Value:
 *        "PREFERENTIAL_NETWORK_SERVICE_DISABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceEnabled
 *        Preferential network service is enabled on the work profile. (Value:
 *        "PREFERENTIAL_NETWORK_SERVICE_ENABLED")
 *    @arg @c kGTLRAndroidManagement_Policy_PreferentialNetworkService_PreferentialNetworkServiceUnspecified
 *        Unspecified. Defaults to PREFERENTIAL_NETWORK_SERVICES_DISABLED.
 *        (Value: "PREFERENTIAL_NETWORK_SERVICE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *preferentialNetworkService;

/**
 *  Allows showing UI on a device for a user to choose a private key alias if
 *  there are no matching rules in ChoosePrivateKeyRules. For devices below
 *  Android P, setting this may leave enterprise keys vulnerable.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *privateKeySelectionEnabled;

/**
 *  The network-independent global HTTP proxy. Typically proxies should be
 *  configured per-network in open_network_configuration. However for unusual
 *  configurations like general internal filtering a global HTTP proxy may be
 *  useful. If the proxy is not accessible, network access may break. The global
 *  proxy is only a recommendation and some apps may ignore it.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ProxyInfo *recommendedGlobalProxy;

/**
 *  Whether removing other users is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *removeUserDisabled;

/**
 *  Whether rebooting the device into safe boot is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *safeBootDisabled;

/**
 *  Whether screen capture is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenCaptureDisabled;

/**
 *  Action to take during the setup process. At most one action may be
 *  specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_SetupAction *> *setupActions;

/**
 *  Whether changing the user icon is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *setUserIconDisabled;

/**
 *  Whether changing the wallpaper is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *setWallpaperDisabled;

/**
 *  Whether location sharing is disabled. share_location_disabled is supported
 *  for both fully managed devices and personally owned work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *shareLocationDisabled;

/**
 *  A message displayed to the user in the settings screen wherever
 *  functionality has been disabled by the admin. If the message is longer than
 *  200 characters it may be truncated.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *shortSupportMessage;

/**
 *  Flag to skip hints on the first use. Enterprise admin can enable the system
 *  recommendation for apps to skip their user tutorial and other introductory
 *  hints on first start-up.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipFirstUseHintsEnabled;

/**
 *  Whether sending and receiving SMS messages is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *smsDisabled;

/**
 *  Whether the status bar is disabled. This disables notifications, quick
 *  settings, and other screen overlays that allow escape from full-screen mode.
 *  DEPRECATED. To disable the status bar on a kiosk device, use InstallType
 *  KIOSK or kioskCustomLauncherEnabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *statusBarDisabled;

/** Status reporting settings */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StatusReportingSettings *statusReportingSettings;

/**
 *  The battery plugged in modes for which the device stays on. When using this
 *  setting, it is recommended to clear maximum_time_to_lock so that the device
 *  doesn't lock itself while it stays on.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *stayOnPluggedModes;

/**
 *  The system update policy, which controls how OS updates are applied. If the
 *  update type is WINDOWED, the update window will automatically apply to Play
 *  app updates as well.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SystemUpdate *systemUpdate;

/**
 *  Whether configuring tethering and portable hotspots is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *tetheringConfigDisabled;

/**
 *  Whether user uninstallation of applications is disabled. This prevents apps
 *  from being uninstalled, even those removed using applications
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *uninstallAppsDisabled;

/**
 *  If microphone_access is set to any value other than
 *  MICROPHONE_ACCESS_UNSPECIFIED, this has no effect. Otherwise this field
 *  controls whether microphones are disabled: If true, all microphones are
 *  disabled, otherwise they are available. This is available only on fully
 *  managed devices.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unmuteMicrophoneDisabled;

/** Configuration of device activity logging. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UsageLog *usageLog;

/**
 *  Whether transferring files over USB is disabled. This is supported only on
 *  company-owned devices.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usbFileTransferDisabled;

/**
 *  Whether USB storage is enabled. Deprecated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usbMassStorageEnabled;

/**
 *  The version of the policy. This is a read-only field. The version is
 *  incremented each time the policy is updated.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

/**
 *  Whether configuring VPN is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vpnConfigDisabled;

/**
 *  Whether configuring Wi-Fi access points is disabled. Note: If a network
 *  connection can't be made at boot time and configuring Wi-Fi is disabled then
 *  network escape hatch will be shown in order to refresh the device policy
 *  (see networkEscapeHatchEnabled).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigDisabled;

/**
 *  DEPRECATED - Use wifi_config_disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigsLockdownEnabled;

@end


/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Policy_OpenNetworkConfiguration : GTLRObject
@end


/**
 *  A rule that defines the actions to take if a device or work profile is not
 *  compliant with the policy specified in settingName.
 */
@interface GTLRAndroidManagement_PolicyEnforcementRule : GTLRObject

/**
 *  An action to block access to apps and data on a company owned device or in a
 *  work profile. This action also triggers a user-facing notification with
 *  information (where possible) on how to correct the compliance issue. Note:
 *  wipeAction must also be specified.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_BlockAction *blockAction;

/**
 *  The top-level policy to enforce. For example, applications or
 *  passwordPolicies.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

/**
 *  An action to reset a company owned device or delete a work profile. Note:
 *  blockAction must also be specified.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_WipeAction *wipeAction;

@end


/**
 *  Additional details regarding the security posture of the device.
 */
@interface GTLRAndroidManagement_PostureDetail : GTLRObject

/**
 *  Corresponding admin-facing advice to mitigate this security risk and improve
 *  the security posture of the device.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_UserFacingMessage *> *advice;

/**
 *  A specific security risk that negatively affects the security posture of the
 *  device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_CompromisedOs
 *        SafetyNet detects that the device is running a compromised OS
 *        (basicIntegrity check fails). (Value: "COMPROMISED_OS")
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_HardwareBackedEvaluationFailed
 *        SafetyNet detects that the device does not have a strong guarantee of
 *        system integrity, such as a hardware-backed keystore
 *        (https://developer.android.com/training/articles/security-key-attestation).
 *        (Value: "HARDWARE_BACKED_EVALUATION_FAILED")
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_SecurityRiskUnspecified
 *        Unspecified. (Value: "SECURITY_RISK_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PostureDetail_SecurityRisk_UnknownOs
 *        SafetyNet detects that the device is running an unknown OS
 *        (basicIntegrity check succeeds but ctsProfileMatch fails). (Value:
 *        "UNKNOWN_OS")
 */
@property(nonatomic, copy, nullable) NSString *securityRisk;

@end


/**
 *  A power management event.
 */
@interface GTLRAndroidManagement_PowerManagementEvent : GTLRObject

/**
 *  For BATTERY_LEVEL_COLLECTED events, the battery level as a percentage.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batteryLevel;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected
 *        Battery level was measured. (Value: "BATTERY_LEVEL_COLLECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow
 *        The device entered low-power mode. (Value: "BATTERY_LOW")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay
 *        The device exited low-power mode. (Value: "BATTERY_OKAY")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted
 *        The device booted. (Value: "BOOT_COMPLETED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected
 *        The device started charging. (Value: "POWER_CONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected
 *        The device stopped charging. (Value: "POWER_DISCONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown The
 *        device shut down. (Value: "SHUTDOWN")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Configuration info for an HTTP proxy. For a direct proxy, set the host,
 *  port, and excluded_hosts fields. For a PAC script proxy, set the pac_uri
 *  field.
 */
@interface GTLRAndroidManagement_ProxyInfo : GTLRObject

/**
 *  For a direct proxy, the hosts for which the proxy is bypassed. The host
 *  names may contain wildcards such as *.example.com.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludedHosts;

/** The host of the direct proxy. */
@property(nonatomic, copy, nullable) NSString *host;

/** The URI of the PAC script used to configure the proxy. */
@property(nonatomic, copy, nullable) NSString *pacUri;

/**
 *  The port of the direct proxy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

@end


/**
 *  The device or profile has been remotely locked via the LOCK command.
 */
@interface GTLRAndroidManagement_RemoteLockEvent : GTLRObject

/** Package name of the admin app requesting the change. */
@property(nonatomic, copy, nullable) NSString *adminPackageName;

/**
 *  User ID of the admin app from the which the change was requested.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adminUserId;

/**
 *  User ID in which the change was requested in.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *targetUserId;

@end


/**
 *  The security posture of the device, as determined by the current device
 *  state and the policies applied.
 */
@interface GTLRAndroidManagement_SecurityPosture : GTLRObject

/**
 *  Device's security posture value.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_AtRisk This
 *        device may be more vulnerable to malicious actors than is recommended
 *        for use with corporate data. (Value: "AT_RISK")
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_PostureUnspecified
 *        Unspecified. There is no posture detail for this posture value.
 *        (Value: "POSTURE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_PotentiallyCompromised
 *        This device may be compromised and corporate data may be accessible to
 *        unauthorized actors. (Value: "POTENTIALLY_COMPROMISED")
 *    @arg @c kGTLRAndroidManagement_SecurityPosture_DevicePosture_Secure This
 *        device is secure. (Value: "SECURE")
 */
@property(nonatomic, copy, nullable) NSString *devicePosture;

/** Additional details regarding the security posture of the device. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PostureDetail *> *postureDetails;

@end


/**
 *  An action executed during setup.
 */
@interface GTLRAndroidManagement_SetupAction : GTLRObject

/**
 *  Description of this action.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *descriptionProperty;

/**
 *  An action to launch an app. The app will be launched with an intent
 *  containing an extra with key
 *  com.google.android.apps.work.clouddpc.EXTRA_LAUNCHED_AS_SETUP_ACTION set to
 *  the boolean value true to indicate that this is a setup action flow.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LaunchAppAction *launchApp;

/** Title of this action. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *title;

@end


/**
 *  A resource containing sign in details for an enterprise.
 */
@interface GTLRAndroidManagement_SigninDetail : GTLRObject

/**
 *  Controls whether personal usage is allowed on a device provisioned with this
 *  enrollment token.For company-owned devices: Enabling personal usage allows
 *  the user to set up a work profile on the device. Disabling personal usage
 *  requires the user provision the device as a fully managed device.For
 *  personally-owned devices: Enabling personal usage allows the user to set up
 *  a work profile on the device. Disabling personal usage will prevent the
 *  device from provisioning. Personal usage cannot be disabled on
 *  personally-owned device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_AllowPersonalUsageUnspecified
 *        Personal usage restriction is not specified (Value:
 *        "ALLOW_PERSONAL_USAGE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageAllowed
 *        Personal usage is allowed (Value: "PERSONAL_USAGE_ALLOWED")
 *    @arg @c kGTLRAndroidManagement_SigninDetail_AllowPersonalUsage_PersonalUsageDisallowed
 *        Personal usage is disallowed (Value: "PERSONAL_USAGE_DISALLOWED")
 */
@property(nonatomic, copy, nullable) NSString *allowPersonalUsage;

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/**
 *  An enterprise wide enrollment token used to trigger custom sign-in flow.
 *  This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *signinEnrollmentToken;

/**
 *  Sign-in URL for authentication when device is provisioned with a sign-in
 *  enrollment token. The sign-in endpoint should finish authentication flow
 *  with a URL in the form of https://enterprise.google.com/android/enroll?et=
 *  for a successful login, or
 *  https://enterprise.google.com/android/enroll/invalid for a failed login.
 */
@property(nonatomic, copy, nullable) NSString *signinUrl;

@end


/**
 *  An enterprise signup URL.
 */
@interface GTLRAndroidManagement_SignupUrl : GTLRObject

/**
 *  The name of the resource. Use this value in the signupUrl field when calling
 *  enterprises.create to complete the enterprise signup flow.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A URL where an enterprise admin can register their enterprise. The page
 *  can't be rendered in an iframe.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Information about device software.
 */
@interface GTLRAndroidManagement_SoftwareInfo : GTLRObject

/**
 *  Android build ID string meant for displaying to the user. For example,
 *  shamu-userdebug 6.0.1 MOB30I 2756745 dev-keys.
 */
@property(nonatomic, copy, nullable) NSString *androidBuildNumber;

/** Build time. */
@property(nonatomic, strong, nullable) GTLRDateTime *androidBuildTime;

/**
 *  The Android Device Policy app version code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *androidDevicePolicyVersionCode;

/** The Android Device Policy app version as displayed to the user. */
@property(nonatomic, copy, nullable) NSString *androidDevicePolicyVersionName;

/** The user-visible Android version string. For example, 6.0.1. */
@property(nonatomic, copy, nullable) NSString *androidVersion;

/** The system bootloader version number, e.g. 0.6.7. */
@property(nonatomic, copy, nullable) NSString *bootloaderVersion;

/**
 *  SHA-256 hash of android.content.pm.Signature
 *  (https://developer.android.com/reference/android/content/pm/Signature.html)
 *  associated with the system package, which can be used to verify that the
 *  system build hasn't been modified.
 */
@property(nonatomic, copy, nullable) NSString *deviceBuildSignature;

/** Kernel version, for example, 2.6.32.9-g103d848. */
@property(nonatomic, copy, nullable) NSString *deviceKernelVersion;

/** An IETF BCP 47 language code for the primary locale on the device. */
@property(nonatomic, copy, nullable) NSString *primaryLanguageCode;

/** Security patch level, e.g. 2016-05-01. */
@property(nonatomic, copy, nullable) NSString *securityPatchLevel;

/** Information about a potential pending system update. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SystemUpdateInfo *systemUpdateInfo;

@end


/**
 *  Additional context for SpecificNonComplianceReason.
 */
@interface GTLRAndroidManagement_SpecificNonComplianceContext : GTLRObject

/**
 *  Additional context for non-compliance related to Wi-Fi configuration. See
 *  ONC_WIFI_INVALID_VALUE and ONC_WIFI_API_LEVEL
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_OncWifiContext *oncWifiContext;

/**
 *  Additional context for non-compliance related to password policies. See
 *  PASSWORD_POLICIES_PASSWORD_EXPIRED and
 *  PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PasswordPoliciesContext *passwordPoliciesContext;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). Each Status message contains three pieces of
 *  data: error code, error message, and error details.You can find out more
 *  about this error model and how to work with it in the API Design Guide
 *  (https://cloud.google.com/apis/design/errors).
 */
@interface GTLRAndroidManagement_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRAndroidManagement_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Status_Details_Item : GTLRObject
@end


/**
 *  Settings controlling the behavior of status reports.
 */
@interface GTLRAndroidManagement_StatusReportingSettings : GTLRObject

/**
 *  Application reporting settings. Only applicable if
 *  application_reports_enabled is true.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApplicationReportingSettings *applicationReportingSettings;

/**
 *  Whether app reports are enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationReportsEnabled;

/**
 *  Whether Common Criteria Mode reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *commonCriteriaModeEnabled;

/**
 *  Whether device settings reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deviceSettingsEnabled;

/**
 *  Whether displays reporting is enabled. Report data is not available for
 *  personally owned devices with work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayInfoEnabled;

/**
 *  Whether hardware status reporting is enabled. Report data is not available
 *  for personally owned devices with work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hardwareStatusEnabled;

/**
 *  Whether memory event reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryInfoEnabled;

/**
 *  Whether network info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkInfoEnabled;

/**
 *  Whether power management event reporting is enabled. Report data is not
 *  available for personally owned devices with work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *powerManagementEventsEnabled;

/**
 *  Whether software info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *softwareInfoEnabled;

/**
 *  Whether system properties reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *systemPropertiesEnabled;

@end


/**
 *  Configuration for managing system updates
 */
@interface GTLRAndroidManagement_SystemUpdate : GTLRObject

/**
 *  If the type is WINDOWED, the end of the maintenance window, measured as the
 *  number of minutes after midnight in device's local time. This value must be
 *  between 0 and 1439, inclusive. If this value is less than start_minutes,
 *  then the maintenance window spans midnight. If the maintenance window
 *  specified is smaller than 30 minutes, the actual window is extended to 30
 *  minutes beyond the start time.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endMinutes;

/**
 *  An annually repeating time period in which over-the-air (OTA) system updates
 *  are postponed to freeze the OS version running on a device. To prevent
 *  freezing the device indefinitely, each freeze period must be separated by at
 *  least 60 days.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_FreezePeriod *> *freezePeriods;

/**
 *  If the type is WINDOWED, the start of the maintenance window, measured as
 *  the number of minutes after midnight in the device's local time. This value
 *  must be between 0 and 1439, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startMinutes;

/**
 *  The type of system update to configure.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Automatic Install
 *        automatically as soon as an update is available. (Value: "AUTOMATIC")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Postpone Postpone
 *        automatic install up to a maximum of 30 days. (Value: "POSTPONE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified
 *        Follow the default update behavior for the device, which typically
 *        requires the user to accept system updates. (Value:
 *        "SYSTEM_UPDATE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Windowed Install
 *        automatically within a daily maintenance window. This also configures
 *        Play apps to be updated within the window. This is strongly
 *        recommended for kiosk devices because this is the only way apps
 *        persistently pinned to the foreground can be updated by Play.If
 *        autoUpdateMode is set to AUTO_UPDATE_HIGH_PRIORITY for an app, then
 *        the maintenance window is ignored for that app and it is updated as
 *        soon as possible even outside of the maintenance window. (Value:
 *        "WINDOWED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Information about a potential pending system update.
 */
@interface GTLRAndroidManagement_SystemUpdateInfo : GTLRObject

/**
 *  The time when the update was first available. A zero value indicates that
 *  this field is not set. This field is set only if an update is available
 *  (that is, updateStatus is neither UPDATE_STATUS_UNKNOWN nor UP_TO_DATE).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateReceivedTime;

/**
 *  The status of an update: whether an update exists and what type it is.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_OsUpdateAvailable
 *        There is a pending OS update available. (Value: "OS_UPDATE_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_SecurityUpdateAvailable
 *        There is a pending security update available. (Value:
 *        "SECURITY_UPDATE_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UnknownUpdateAvailable
 *        There is a pending system update available, but its type is not known.
 *        (Value: "UNKNOWN_UPDATE_AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpdateStatusUnknown
 *        It is unknown whether there is a pending system update. This happens
 *        when, for example, the device API level is less than 26, or if the
 *        version of Android Device Policy is outdated. (Value:
 *        "UPDATE_STATUS_UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_SystemUpdateInfo_UpdateStatus_UpToDate
 *        There is no pending system update available on the device. (Value:
 *        "UP_TO_DATE")
 */
@property(nonatomic, copy, nullable) NSString *updateStatus;

@end


/**
 *  Telephony information associated with a given SIM card on the device. Only
 *  supported on fully managed devices starting from Android API level 23.
 */
@interface GTLRAndroidManagement_TelephonyInfo : GTLRObject

/** The carrier name associated with this SIM card. */
@property(nonatomic, copy, nullable) NSString *carrierName;

/** The phone number associated with this SIM card. */
@property(nonatomic, copy, nullable) NSString *phoneNumber;

@end


/**
 *  A terms and conditions page to be accepted during provisioning.
 */
@interface GTLRAndroidManagement_TermsAndConditions : GTLRObject

/**
 *  A well-formatted HTML string. It will be parsed on the client with
 *  android.text.Html#fromHtml.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *content;

/** A short header which appears above the HTML content. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *header;

@end


/**
 *  Controls types of device activity logs collected from the device and
 *  reported via Pub/Sub notification
 *  (https://developers.google.com/android/management/notifications).
 */
@interface GTLRAndroidManagement_UsageLog : GTLRObject

/**
 *  Specifies which log types are enabled. Note that users will receive
 *  on-device messaging when usage logging is enabled.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledLogTypes;

/**
 *  Specifies which of the enabled log types can be uploaded over mobile data.
 *  By default logs are queued for upload when the device connects to WiFi.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *uploadOnCellularAllowed;

@end


/**
 *  An event logged on the device.
 */
@interface GTLRAndroidManagement_UsageLogEvent : GTLRObject

/**
 *  A shell command was issued over ADB via “adb shell command”. Part of
 *  SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AdbShellCommandEvent *adbShellCommandEvent;

/**
 *  An ADB interactive shell was opened via “adb shell”. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AdbShellInteractiveEvent *adbShellInteractiveEvent;

/** An app process was started. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AppProcessStartEvent *appProcessStartEvent;

/**
 *  A new root certificate was installed into the system's trusted credential
 *  storage. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CertAuthorityInstalledEvent *certAuthorityInstalledEvent;

/**
 *  A root certificate was removed from the system's trusted credential storage.
 *  Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CertAuthorityRemovedEvent *certAuthorityRemovedEvent;

/**
 *  An X.509v3 certificate failed to validate, currently this validation is
 *  performed on the Wi-FI access point and failure may be due to a mismatch
 *  upon server certificate validation. However it may in the future include
 *  other validation events of an X.509v3 certificate. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CertValidationFailureEvent *certValidationFailureEvent;

/**
 *  A TCP connect event was initiated through the standard network stack. Part
 *  of NETWORK_ACTIVITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ConnectEvent *connectEvent;

/**
 *  Validates whether Android’s built-in cryptographic library (BoringSSL) is
 *  valid. Should always succeed on device boot, if it fails, the device should
 *  be considered untrusted. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_CryptoSelfTestCompletedEvent *cryptoSelfTestCompletedEvent;

/**
 *  A DNS lookup event was initiated through the standard network stack. Part of
 *  NETWORK_ACTIVITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DnsEvent *dnsEvent;

/**
 *  Unique id of the event.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *eventId;

/** Device timestamp when the event was logged. */
@property(nonatomic, strong, nullable) GTLRDateTime *eventTime;

/**
 *  The particular usage log event type that was reported on the device. Use
 *  this to determine which event field to access.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellCommand
 *        Indicates adb_shell_command_event has been set. (Value:
 *        "ADB_SHELL_COMMAND")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_AdbShellInteractive
 *        Indicates adb_shell_interactive_event has been set. (Value:
 *        "ADB_SHELL_INTERACTIVE")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_AppProcessStart
 *        Indicates app_process_start_event has been set. (Value:
 *        "APP_PROCESS_START")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityInstalled
 *        Indicates cert_authority_installed_event has been set. (Value:
 *        "CERT_AUTHORITY_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CertAuthorityRemoved
 *        Indicates cert_authority_removed_event has been set. (Value:
 *        "CERT_AUTHORITY_REMOVED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CertValidationFailure
 *        Indicates cert_validation_failure_event has been set. (Value:
 *        "CERT_VALIDATION_FAILURE")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_Connect Indicates
 *        connect_event has been set. (Value: "CONNECT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_CryptoSelfTestCompleted
 *        Indicates crypto_self_test_completed_event has been set. (Value:
 *        "CRYPTO_SELF_TEST_COMPLETED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_Dns Indicates
 *        dns_event has been set. (Value: "DNS")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_EventTypeUnspecified
 *        This value is not used (Value: "EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_FilePulled
 *        Indicates file_pulled_event has been set. (Value: "FILE_PULLED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_FilePushed
 *        Indicates file_pushed_event has been set. (Value: "FILE_PUSHED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyDestruction
 *        Indicates key_destruction_event has been set. (Value:
 *        "KEY_DESTRUCTION")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyGenerated
 *        Indicates key_generated_event has been set. (Value: "KEY_GENERATED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissAuthAttempt
 *        Indicates keyguard_dismiss_auth_attempt_event has been set. (Value:
 *        "KEYGUARD_DISMISS_AUTH_ATTEMPT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardDismissed
 *        Indicates keyguard_dismissed_event has been set. (Value:
 *        "KEYGUARD_DISMISSED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyguardSecured
 *        Indicates keyguard_secured_event has been set. (Value:
 *        "KEYGUARD_SECURED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyImport Indicates
 *        key_import_event has been set. (Value: "KEY_IMPORT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_KeyIntegrityViolation
 *        Indicates key_integrity_violation_event has been set. (Value:
 *        "KEY_INTEGRITY_VIOLATION")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LogBufferSizeCritical
 *        Indicates log_buffer_size_critical_event has been set. (Value:
 *        "LOG_BUFFER_SIZE_CRITICAL")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStarted
 *        Indicates logging_started_event has been set. (Value:
 *        "LOGGING_STARTED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_LoggingStopped
 *        Indicates logging_stopped_event has been set. (Value:
 *        "LOGGING_STOPPED")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_MediaMount
 *        Indicates media_mount_event has been set. (Value: "MEDIA_MOUNT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_MediaUnmount
 *        Indicates media_unmount_event has been set. (Value: "MEDIA_UNMOUNT")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_OsShutdown
 *        Indicates os_shutdown_event has been set. (Value: "OS_SHUTDOWN")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_OsStartup Indicates
 *        os_startup_event has been set. (Value: "OS_STARTUP")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_RemoteLock
 *        Indicates remote_lock_event has been set. (Value: "REMOTE_LOCK")
 *    @arg @c kGTLRAndroidManagement_UsageLogEvent_EventType_WipeFailure
 *        Indicates wipe_failure_event has been set. (Value: "WIPE_FAILURE")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

/** A file was downloaded from the device. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_FilePulledEvent *filePulledEvent;

/** A file was uploaded onto the device. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_FilePushedEvent *filePushedEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is removed from the device either by the user or
 *  management. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyDestructionEvent *keyDestructionEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is installed on the device either by the user or
 *  management. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyGeneratedEvent *keyGeneratedEvent;

/** An attempt was made to unlock the device. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyguardDismissAuthAttemptEvent *keyguardDismissAuthAttemptEvent;

/** The keyguard was dismissed. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyguardDismissedEvent *keyguardDismissedEvent;

/** The device was locked either by user or timeout. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyguardSecuredEvent *keyguardSecuredEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is imported on the device either by the user or
 *  management. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyImportEvent *keyImportEvent;

/**
 *  A cryptographic key including user installed, admin installed and system
 *  maintained private key is determined to be corrupted due to storage
 *  corruption, hardware failure or some OS issue. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_KeyIntegrityViolationEvent *keyIntegrityViolationEvent;

/**
 *  The audit log buffer has reached 90% of its capacity, therefore older events
 *  may be dropped. Part of SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LogBufferSizeCriticalEvent *logBufferSizeCriticalEvent;

/** usageLog policy has been enabled. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LoggingStartedEvent *loggingStartedEvent;

/** usageLog policy has been disabled. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_LoggingStoppedEvent *loggingStoppedEvent;

/** Removable media was mounted. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MediaMountEvent *mediaMountEvent;

/** Removable media was unmounted. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MediaUnmountEvent *mediaUnmountEvent;

/** Device was shutdown. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_OsShutdownEvent *osShutdownEvent;

/** Device was started. Part of SECURITY_LOGS. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_OsStartupEvent *osStartupEvent;

/**
 *  The device or profile has been remotely locked via the LOCK command. Part of
 *  SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_RemoteLockEvent *remoteLockEvent;

/**
 *  The work profile or company-owned device failed to wipe when requested. This
 *  could be user initiated or admin initiated e.g. delete was received. Part of
 *  SECURITY_LOGS.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_WipeFailureEvent *wipeFailureEvent;

@end


/**
 *  A user belonging to an enterprise.
 */
@interface GTLRAndroidManagement_User : GTLRObject

/**
 *  A unique identifier you create for this user, such as user342 or
 *  asset#44418. This field must be set when the user is created and can't be
 *  updated. This field must not contain personally identifiable information
 *  (PII). This identifier must be 1024 characters or less; otherwise, the
 *  update policy request will fail.
 */
@property(nonatomic, copy, nullable) NSString *accountIdentifier;

@end


/**
 *  Provides a user-facing message with locale info. The maximum message length
 *  is 4096 characters.
 */
@interface GTLRAndroidManagement_UserFacingMessage : GTLRObject

/**
 *  The default message displayed if no localized message is specified or the
 *  user's locale doesn't match with any of the localized messages. A default
 *  message must be provided if any localized messages are provided.
 */
@property(nonatomic, copy, nullable) NSString *defaultMessage;

/**
 *  A map containing pairs, where locale is a well-formed BCP 47 language
 *  (https://www.w3.org/International/articles/language-tags/) code, such as
 *  en-US, es-ES, or fr.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage_LocalizedMessages *localizedMessages;

@end


/**
 *  A map containing pairs, where locale is a well-formed BCP 47 language
 *  (https://www.w3.org/International/articles/language-tags/) code, such as
 *  en-US, es-ES, or fr.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_UserFacingMessage_LocalizedMessages : GTLRObject
@end


/**
 *  A web app.
 */
@interface GTLRAndroidManagement_WebApp : GTLRObject

/**
 *  The display mode of the web app.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_DisplayModeUnspecified
 *        Not used. (Value: "DISPLAY_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_FullScreen Opens the web
 *        app in full screen without any visible controls. The browser UI
 *        elements, page URL, system status bar and back button are not visible,
 *        and the web app takes up the entirety of the available display area.
 *        (Value: "FULL_SCREEN")
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_MinimalUi Opens the web
 *        app with a minimal set of browser UI elements for controlling
 *        navigation and viewing the page URL. (Value: "MINIMAL_UI")
 *    @arg @c kGTLRAndroidManagement_WebApp_DisplayMode_Standalone Opens the web
 *        app to look and feel like a standalone native application. The browser
 *        UI elements and page URL are not visible, however the system status
 *        bar and back button are visible. (Value: "STANDALONE")
 */
@property(nonatomic, copy, nullable) NSString *displayMode;

/** A list of icons for the web app. Must have at least one element. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_WebAppIcon *> *icons;

/**
 *  The name of the web app, which is generated by the server during creation in
 *  the form enterprises/{enterpriseId}/webApps/{packageName}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The start URL, i.e. the URL that should load when the user opens the
 *  application.
 */
@property(nonatomic, copy, nullable) NSString *startUrl;

/**
 *  The title of the web app as displayed to the user (e.g., amongst a list of
 *  other applications, or as a label for an icon).
 */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  The current version of the app.Note that the version can automatically
 *  increase during the lifetime of the web app, while Google does internal
 *  housekeeping to keep the web app up-to-date.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

@end


/**
 *  An icon for a web app. Supported formats are: png, jpg and webp.
 */
@interface GTLRAndroidManagement_WebAppIcon : GTLRObject

/**
 *  The actual bytes of the image in a base64url encoded string (c.f. RFC4648,
 *  section 5 "Base 64 Encoding with URL and Filename Safe Alphabet"). - The
 *  image type can be png or jpg. - The image should ideally be square. - The
 *  image should ideally have a size of 512x512.
 */
@property(nonatomic, copy, nullable) NSString *imageData;

@end


/**
 *  A web token used to access the managed Google Play iframe.
 */
@interface GTLRAndroidManagement_WebToken : GTLRObject

/**
 *  The features to enable. Use this if you want to control exactly which
 *  feature(s) will be activated; leave empty to allow all features.Restrictions
 *  / things to note: - If no features are listed here, all features are enabled
 *  — this is the default behavior where you give access to all features to your
 *  admins. - This must not contain any FEATURE_UNSPECIFIED values. - Repeated
 *  values are ignored
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledFeatures;

/**
 *  The name of the web token, which is generated by the server during creation
 *  in the form enterprises/{enterpriseId}/webTokens/{webTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The URL of the parent frame hosting the iframe with the embedded UI. To
 *  prevent XSS, the iframe may not be hosted at other URLs. The URL must use
 *  the https scheme.
 */
@property(nonatomic, copy, nullable) NSString *parentFrameUrl;

/**
 *  Permissions available to an admin in the embedded UI. An admin must have all
 *  of these permissions in order to view the UI. This field is deprecated.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

/**
 *  The token value which is used in the hosting page to generate the iframe
 *  with the embedded UI. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  An action to reset a company owned device or delete a work profile. Note:
 *  blockAction must also be specified.
 */
@interface GTLRAndroidManagement_WipeAction : GTLRObject

/**
 *  Whether the factory-reset protection data is preserved on the device. This
 *  setting doesn’t apply to work profiles.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preserveFrp;

/**
 *  Number of days the policy is non-compliant before the device or work profile
 *  is wiped. wipeAfterDays must be greater than blockAfterDays.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wipeAfterDays;

@end


/**
 *  The work profile or company-owned device failed to wipe when requested. This
 *  could be user initiated or admin initiated e.g. delete was received.
 *  Intentionally empty.
 */
@interface GTLRAndroidManagement_WipeFailureEvent : GTLRObject
@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
