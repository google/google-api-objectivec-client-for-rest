// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Network Connectivity API (networkconnectivity/v1)
// Description:
//   This API enables connectivity with and between Google Cloud resources.
// Documentation:
//   https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRNetworkconnectivity_AuditConfig;
@class GTLRNetworkconnectivity_AuditLogConfig;
@class GTLRNetworkconnectivity_AutoAccept;
@class GTLRNetworkconnectivity_Binding;
@class GTLRNetworkconnectivity_ConsumerPscConfig;
@class GTLRNetworkconnectivity_ConsumerPscConfig_ProducerInstanceMetadata;
@class GTLRNetworkconnectivity_ConsumerPscConfig_ServiceAttachmentIpAddressMap;
@class GTLRNetworkconnectivity_ConsumerPscConnection;
@class GTLRNetworkconnectivity_ConsumerPscConnection_ProducerInstanceMetadata;
@class GTLRNetworkconnectivity_Expr;
@class GTLRNetworkconnectivity_Filter;
@class GTLRNetworkconnectivity_GoogleLongrunningOperation;
@class GTLRNetworkconnectivity_GoogleLongrunningOperation_Metadata;
@class GTLRNetworkconnectivity_GoogleLongrunningOperation_Response;
@class GTLRNetworkconnectivity_GoogleRpcErrorInfo;
@class GTLRNetworkconnectivity_GoogleRpcErrorInfo_Metadata;
@class GTLRNetworkconnectivity_GoogleRpcStatus;
@class GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item;
@class GTLRNetworkconnectivity_Group;
@class GTLRNetworkconnectivity_Group_Labels;
@class GTLRNetworkconnectivity_Hub;
@class GTLRNetworkconnectivity_Hub_Labels;
@class GTLRNetworkconnectivity_InterconnectAttachment;
@class GTLRNetworkconnectivity_InternalRange;
@class GTLRNetworkconnectivity_InternalRange_Labels;
@class GTLRNetworkconnectivity_LinkedInterconnectAttachments;
@class GTLRNetworkconnectivity_LinkedRouterApplianceInstances;
@class GTLRNetworkconnectivity_LinkedVpcNetwork;
@class GTLRNetworkconnectivity_LinkedVpnTunnels;
@class GTLRNetworkconnectivity_Location;
@class GTLRNetworkconnectivity_Location_Labels;
@class GTLRNetworkconnectivity_Location_Metadata;
@class GTLRNetworkconnectivity_Migration;
@class GTLRNetworkconnectivity_NextHopInterconnectAttachment;
@class GTLRNetworkconnectivity_NextHopRouterApplianceInstance;
@class GTLRNetworkconnectivity_NextHopVpcNetwork;
@class GTLRNetworkconnectivity_NextHopVPNTunnel;
@class GTLRNetworkconnectivity_Policy;
@class GTLRNetworkconnectivity_PolicyBasedRoute;
@class GTLRNetworkconnectivity_PolicyBasedRoute_Labels;
@class GTLRNetworkconnectivity_ProducerPscConfig;
@class GTLRNetworkconnectivity_PscConfig;
@class GTLRNetworkconnectivity_PscConnection;
@class GTLRNetworkconnectivity_PscConnection_ProducerInstanceMetadata;
@class GTLRNetworkconnectivity_RegionalEndpoint;
@class GTLRNetworkconnectivity_RegionalEndpoint_Labels;
@class GTLRNetworkconnectivity_Route;
@class GTLRNetworkconnectivity_Route_Labels;
@class GTLRNetworkconnectivity_RouterApplianceInstance;
@class GTLRNetworkconnectivity_RouteTable;
@class GTLRNetworkconnectivity_RouteTable_Labels;
@class GTLRNetworkconnectivity_RoutingVPC;
@class GTLRNetworkconnectivity_ServiceClass;
@class GTLRNetworkconnectivity_ServiceClass_Labels;
@class GTLRNetworkconnectivity_ServiceConnectionMap;
@class GTLRNetworkconnectivity_ServiceConnectionMap_Labels;
@class GTLRNetworkconnectivity_ServiceConnectionPolicy;
@class GTLRNetworkconnectivity_ServiceConnectionPolicy_Labels;
@class GTLRNetworkconnectivity_ServiceConnectionToken;
@class GTLRNetworkconnectivity_ServiceConnectionToken_Labels;
@class GTLRNetworkconnectivity_Spoke;
@class GTLRNetworkconnectivity_Spoke_Labels;
@class GTLRNetworkconnectivity_SpokeStateCount;
@class GTLRNetworkconnectivity_SpokeStateReasonCount;
@class GTLRNetworkconnectivity_SpokeSummary;
@class GTLRNetworkconnectivity_SpokeTypeCount;
@class GTLRNetworkconnectivity_StateReason;
@class GTLRNetworkconnectivity_VirtualMachine;
@class GTLRNetworkconnectivity_Warnings;
@class GTLRNetworkconnectivity_Warnings_Data;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConfig.state

/**
 *  No Service Connection Policy found for this network and Service Class
 *
 *  Value: "CONNECTION_POLICY_MISSING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConnectionPolicyMissing;
/**
 *  The consumer instance project is not in
 *  AllowedGoogleProducersResourceHierarchyLevels of the matching
 *  ServiceConnectionPolicy.
 *
 *  Value: "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConsumerInstanceProjectNotAllowlisted;
/**
 *  Service Connection Policy limit reached for this network and Service Class
 *
 *  Value: "POLICY_LIMIT_REACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_PolicyLimitReached;
/**
 *  Default state, when Connection Map is created initially.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_StateUnspecified;
/**
 *  Set when policy and map configuration is valid, and their matching can lead
 *  to allowing creation of PSC Connections subject to other constraints like
 *  connections limit.
 *
 *  Value: "VALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_Valid;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConnection.errorType

/**
 *  An invalid error type as the default case.
 *
 *  Value: "CONNECTION_ERROR_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ConnectionErrorTypeUnspecified;
/**
 *  The error is due to the setup on consumer side.
 *
 *  Value: "ERROR_CONSUMER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorConsumerSide;
/**
 *  The error is due to Service Automation system internal.
 *
 *  Value: "ERROR_INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorInternal;
/**
 *  The error is due to the setup on producer side.
 *
 *  Value: "ERROR_PRODUCER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorProducerSide;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConnection.state

/**
 *  The connection has been created successfully. However, for the up-to-date
 *  connection status, please use the service attachment's
 *  "ConnectedEndpoint.status" as the source of truth.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Active;
/**
 *  The connection is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Creating;
/**
 *  The connection is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Deleting;
/**
 *  The connection is not functional since some resources on the connection fail
 *  to be created.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Failed;
/**
 *  An invalid state as the default case.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Filter.protocolVersion

/**
 *  The PBR is for IPv4 internet protocol traffic.
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Filter_ProtocolVersion_Ipv4;
/**
 *  Default value.
 *
 *  Value: "PROTOCOL_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Filter_ProtocolVersion_ProtocolVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Group.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Deleting;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Hub.policyMode

/**
 *  Policy mode is unspecified. It defaults to PRESET with preset_topology =
 *  MESH.
 *
 *  Value: "POLICY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PolicyMode_PolicyModeUnspecified;
/**
 *  Hub uses one of the preset topologies.
 *
 *  Value: "PRESET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PolicyMode_Preset;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Hub.presetTopology

/**
 *  Mesh topology is implemented. Group `default` is automatically created. All
 *  spokes in the hub are added to group `default`.
 *
 *  Value: "MESH"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PresetTopology_Mesh;
/**
 *  Preset topology is unspecified. When policy_mode = PRESET, it defaults to
 *  MESH.
 *
 *  Value: "PRESET_TOPOLOGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PresetTopology_PresetTopologyUnspecified;
/**
 *  Star topology is implemented. Two groups, `center` and `edge`, are
 *  automatically created along with hub creation. Spokes have to join one of
 *  the groups during creation.
 *
 *  Value: "STAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PresetTopology_Star;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Hub.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Deleting;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_InternalRange.overlaps

/**
 *  Allow creation of internal ranges that overlap with existing subnets.
 *
 *  Value: "OVERLAP_EXISTING_SUBNET_RANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Overlaps_OverlapExistingSubnetRange;
/**
 *  Allow creation of static routes more specific that the current internal
 *  range.
 *
 *  Value: "OVERLAP_ROUTE_RANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Overlaps_OverlapRouteRange;
/**
 *  No overlap overrides.
 *
 *  Value: "OVERLAP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Overlaps_OverlapUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_InternalRange.peering

/**
 *  This behavior can be set when the internal range is being reserved for usage
 *  by peers. This means that no resource within the VPC in which it is being
 *  created can use this to associate with a VPC resource, but one of the peers
 *  can. This represents donating a range for peers to use.
 *
 *  Value: "FOR_PEER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_ForPeer;
/**
 *  This is the default behavior and represents the case that this internal
 *  range is intended to be used in the VPC in which it is created and is
 *  accessible from its peers. This implies that peers or peers-of-peers cannot
 *  use this range.
 *
 *  Value: "FOR_SELF"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_ForSelf;
/**
 *  This behavior can be set when the internal range is being reserved for usage
 *  by the VPC in which it is created, but not shared with peers. In a sense, it
 *  is local to the VPC. This can be used to create internal ranges for various
 *  purposes like HTTP_INTERNAL_LOAD_BALANCER or for Interconnect routes that
 *  are not shared with peers. This also implies that peers cannot use this
 *  range in a way that is visible to this VPC, but can re-use this range as
 *  long as it is NOT_SHARED from the peer VPC, too.
 *
 *  Value: "NOT_SHARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_NotShared;
/**
 *  If Peering is left unspecified in CreateInternalRange or
 *  UpdateInternalRange, it will be defaulted to FOR_SELF.
 *
 *  Value: "PEERING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_PeeringUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_InternalRange.usage

/**
 *  Ranges created with EXTERNAL_TO_VPC cannot be associated with VPC resources
 *  and are meant to block out address ranges for various use cases, like for
 *  example, usage on-prem, with dynamic route announcements via interconnect.
 *
 *  Value: "EXTERNAL_TO_VPC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_ExternalToVpc;
/**
 *  Ranges created FOR_MIGRATION can be used to lock a CIDR range between a
 *  source and target subnet. If usage is set to FOR_MIGRATION the peering value
 *  has to be set to FOR_SELF or default to FOR_SELF when unset.
 *
 *  Value: "FOR_MIGRATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_ForMigration;
/**
 *  A VPC resource can use the reserved CIDR block by associating it with the
 *  internal range resource if usage is set to FOR_VPC.
 *
 *  Value: "FOR_VPC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_ForVpc;
/**
 *  Unspecified usage is allowed in calls which identify the resource by other
 *  fields and do not need Usage set to complete. These are, i.e.:
 *  GetInternalRange and DeleteInternalRange. Usage needs to be specified
 *  explicitly in CreateInternalRange or UpdateInternalRange calls.
 *
 *  Value: "USAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_UsageUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_LocationMetadata.locationFeatures

/**
 *  No publicly supported feature in this location
 *
 *  Value: "LOCATION_FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_LocationFeatureUnspecified;
/**
 *  Site-to-cloud spokes are supported in this location
 *
 *  Value: "SITE_TO_CLOUD_SPOKES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_SiteToCloudSpokes;
/**
 *  Site-to-site spokes are supported in this location
 *
 *  Value: "SITE_TO_SITE_SPOKES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_SiteToSiteSpokes;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PolicyBasedRoute.nextHopOtherRoutes

/**
 *  Use the routes from the default routing tables (system-generated routes,
 *  custom routes, peering route) to determine the next hop. This effectively
 *  excludes matching packets being applied on other PBRs with a lower priority.
 *
 *  Value: "DEFAULT_ROUTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_DefaultRouting;
/**
 *  Default value.
 *
 *  Value: "OTHER_ROUTES_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_OtherRoutesUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConfig.producerInstanceLocation

/**
 *  Producer instance must be within one of the values provided in
 *  allowed_google_producers_resource_hierarchy_level.
 *
 *  Value: "CUSTOM_RESOURCE_HIERARCHY_LEVELS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_CustomResourceHierarchyLevels;
/**
 *  Producer instance location is not specified. When this option is chosen,
 *  then the PSC connections created by this ServiceConnectionPolicy must be
 *  within the same project as the Producer instance. This is the default
 *  ProducerInstanceLocation value. To allow for PSC connections from this
 *  network to other networks, use the CUSTOM_RESOURCE_HIERARCHY_LEVELS option.
 *
 *  Value: "PRODUCER_INSTANCE_LOCATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_ProducerInstanceLocationUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConnection.errorType

/**
 *  An invalid error type as the default case.
 *
 *  Value: "CONNECTION_ERROR_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ConnectionErrorTypeUnspecified;
/**
 *  The error is due to the setup on consumer side.
 *
 *  Value: "ERROR_CONSUMER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorConsumerSide;
/**
 *  The error is due to Service Automation system internal.
 *
 *  Value: "ERROR_INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorInternal;
/**
 *  The error is due to the setup on producer side.
 *
 *  Value: "ERROR_PRODUCER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorProducerSide;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConnection.state

/**
 *  The connection has been created successfully. However, for the up-to-date
 *  connection status, please use the created forwarding rule's
 *  "PscConnectionStatus" as the source of truth.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Active;
/**
 *  The connection is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Creating;
/**
 *  The connection is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Deleting;
/**
 *  The connection is not functional since some resources on the connection fail
 *  to be created.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Failed;
/**
 *  An invalid state as the default case.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_RegionalEndpoint.accessType

/**
 *  An invalid type as the default case.
 *
 *  Value: "ACCESS_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_AccessTypeUnspecified;
/**
 *  This regional endpoint is accessible from all regions.
 *
 *  Value: "GLOBAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Global;
/**
 *  This regional endpoint is only accessible from the same region where it
 *  resides.
 *
 *  Value: "REGIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Regional;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Route.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Deleting;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Route.type

/**
 *  The route leads to a destination in a dynamic route. Dynamic routes are
 *  derived from Border Gateway Protocol (BGP) advertisements received from an
 *  NCC hybrid spoke.
 *
 *  Value: "DYNAMIC_ROUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_DynamicRoute;
/**
 *  No route type information specified
 *
 *  Value: "ROUTE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_RouteTypeUnspecified;
/**
 *  The route leads to a destination within the primary address range of the VPC
 *  network's subnet.
 *
 *  Value: "VPC_PRIMARY_SUBNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_VpcPrimarySubnet;
/**
 *  The route leads to a destination within the secondary address range of the
 *  VPC network's subnet.
 *
 *  Value: "VPC_SECONDARY_SUBNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_VpcSecondarySubnet;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_RouteTable.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Deleting;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ServiceConnectionMap.infrastructure

/**
 *  An invalid infrastructure as the default case.
 *
 *  Value: "INFRASTRUCTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_InfrastructureUnspecified;
/**
 *  Private Service Connect is used for connections.
 *
 *  Value: "PSC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_Psc;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ServiceConnectionPolicy.infrastructure

/**
 *  An invalid infrastructure as the default case.
 *
 *  Value: "INFRASTRUCTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_InfrastructureUnspecified;
/**
 *  Private Service Connect is used for connections.
 *
 *  Value: "PSC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_Psc;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Spoke.spokeType

/**
 *  Spokes associated with VLAN attachments.
 *
 *  Value: "INTERCONNECT_ATTACHMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_InterconnectAttachment;
/**
 *  Spokes associated with router appliance instances.
 *
 *  Value: "ROUTER_APPLIANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_RouterAppliance;
/**
 *  Unspecified spoke type.
 *
 *  Value: "SPOKE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_SpokeTypeUnspecified;
/**
 *  Spokes associated with VPC networks.
 *
 *  Value: "VPC_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_VpcNetwork;
/**
 *  Spokes associated with VPN tunnels.
 *
 *  Value: "VPN_TUNNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_VpnTunnel;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Spoke.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Deleting;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_SpokeStateCount.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Deleting;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_SpokeStateReasonCount.stateReasonCode

/**
 *  No information available.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_CodeUnspecified;
/**
 *  Network Connectivity Center encountered errors while accepting the spoke.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Failed;
/**
 *  The spoke has been deactivated internally.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Paused;
/**
 *  The proposed spoke is pending review.
 *
 *  Value: "PENDING_REVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_PendingReview;
/**
 *  The proposed spoke has been rejected by the hub administrator.
 *
 *  Value: "REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Rejected;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_SpokeTypeCount.spokeType

/**
 *  Spokes associated with VLAN attachments.
 *
 *  Value: "INTERCONNECT_ATTACHMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_InterconnectAttachment;
/**
 *  Spokes associated with router appliance instances.
 *
 *  Value: "ROUTER_APPLIANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_RouterAppliance;
/**
 *  Unspecified spoke type.
 *
 *  Value: "SPOKE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_SpokeTypeUnspecified;
/**
 *  Spokes associated with VPC networks.
 *
 *  Value: "VPC_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpcNetwork;
/**
 *  Spokes associated with VPN tunnels.
 *
 *  Value: "VPN_TUNNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpnTunnel;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_StateReason.code

/**
 *  No information available.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_CodeUnspecified;
/**
 *  Network Connectivity Center encountered errors while accepting the spoke.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_Failed;
/**
 *  The spoke has been deactivated internally.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_Paused;
/**
 *  The proposed spoke is pending review.
 *
 *  Value: "PENDING_REVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_PendingReview;
/**
 *  The proposed spoke has been rejected by the hub administrator.
 *
 *  Value: "REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_Rejected;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Warnings.code

/**
 *  The policy-based route is being modified (e.g. created/deleted) at this
 *  time.
 *
 *  Value: "RESOURCE_BEING_MODIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Warnings_Code_ResourceBeingModified;
/**
 *  The policy-based route is not active and functioning. Common causes are that
 *  the dependent network was deleted or the resource project was turned off.
 *
 *  Value: "RESOURCE_NOT_ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Warnings_Code_ResourceNotActive;
/**
 *  Default value.
 *
 *  Value: "WARNING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Warnings_Code_WarningUnspecified;

/**
 *  The request for HubService.AcceptHubSpoke.
 */
@interface GTLRNetworkconnectivity_AcceptHubSpokeRequest : GTLRObject

/**
 *  Optional. A request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server knows to ignore the request
 *  if it has already been completed. The server guarantees that a request
 *  doesn't result in creation of duplicate commitments for at least 60 minutes.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check to see whether the original operation was received. If
 *  it was, the server ignores the second request. This behavior prevents
 *  clients from mistakenly creating duplicate commitments. The request ID must
 *  be a valid UUID, with the exception that zero UUID is not supported
 *  (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Required. The URI of the spoke to accept into the hub. */
@property(nonatomic, copy, nullable) NSString *spokeUri;

@end


/**
 *  The response for HubService.AcceptHubSpoke.
 */
@interface GTLRNetworkconnectivity_AcceptHubSpokeResponse : GTLRObject

/** The spoke that was operated on. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Spoke *spoke;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRNetworkconnectivity_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRNetworkconnectivity_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_AdminRead Admin
 *        reads. Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataRead Data
 *        reads. Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataWrite Data
 *        writes. Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  The auto-accept setting for a group controls whether proposed spokes are
 *  automatically attached to the hub. If auto-accept is enabled, the spoke
 *  immediately is attached to the hub and becomes part of the group. In this
 *  case, the new spoke is in the ACTIVE state. If auto-accept is disabled, the
 *  spoke goes to the INACTIVE state, and it must be reviewed and accepted by a
 *  hub administrator.
 */
@interface GTLRNetworkconnectivity_AutoAccept : GTLRObject

/**
 *  A list of project ids or project numbers for which you want to enable
 *  auto-accept. The auto-accept setting is applied to spokes being created or
 *  updated in these projects.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *autoAcceptProjects;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRNetworkconnectivity_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `domain:{domain}`: The G Suite domain
 *  (primary) that represents all the users of that domain. For example,
 *  `google.com` or `example.com`. *
 *  `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workforce identity pool. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
 *  All workforce identities in a group. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All workforce identities with a specific attribute value. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/
 *  *`: All identities in a workforce identity pool. *
 *  `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workload identity pool. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
 *  A workload identity pool group. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All identities in a workload identity pool with a certain attribute. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/
 *  *`: All identities in a workload identity pool. *
 *  `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. *
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  Deleted single identity in a workforce identity pool. For example,
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM
 *  roles and permissions, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/roles-overview). For a list
 *  of the available pre-defined roles, see
 *  [here](https://cloud.google.com/iam/docs/understanding-roles).
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Allow the producer to specify which consumers can connect to it.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConfig : GTLRObject

/**
 *  Required. The project ID or project number of the consumer project. This
 *  project is the one that the consumer uses to interact with the producer
 *  instance. From the perspective of a consumer who's created a producer
 *  instance, this is the project of the producer instance. Format: 'projects/'
 *  Eg. 'projects/consumer-project' or 'projects/1234'
 */
@property(nonatomic, copy, nullable) NSString *consumerInstanceProject;

/**
 *  This is used in PSC consumer ForwardingRule to control whether the PSC
 *  endpoint can be accessed from another region.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableGlobalAccess;

/**
 *  The resource path of the consumer network where PSC connections are allowed
 *  to be created in. Note, this network does not need be in the
 *  ConsumerPscConfig.project in the case of SharedVPC. Example:
 *  projects/{projectNumOrId}/global/networks/{networkId}.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Immutable. Deprecated. Use producer_instance_metadata instead. An immutable
 *  identifier for the producer instance.
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceId GTLR_DEPRECATED;

/** Immutable. An immutable map for the producer instance metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ConsumerPscConfig_ProducerInstanceMetadata *producerInstanceMetadata;

/**
 *  The consumer project where PSC connections are allowed to be created in.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Output only. A map to store mapping between customer vip and target service
 *  attachment. Only service attachment with producer specified ip addresses are
 *  stored here.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ConsumerPscConfig_ServiceAttachmentIpAddressMap *serviceAttachmentIpAddressMap;

/**
 *  Output only. Overall state of PSC Connections management for this consumer
 *  psc config.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConnectionPolicyMissing
 *        No Service Connection Policy found for this network and Service Class
 *        (Value: "CONNECTION_POLICY_MISSING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConsumerInstanceProjectNotAllowlisted
 *        The consumer instance project is not in
 *        AllowedGoogleProducersResourceHierarchyLevels of the matching
 *        ServiceConnectionPolicy. (Value:
 *        "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_PolicyLimitReached
 *        Service Connection Policy limit reached for this network and Service
 *        Class (Value: "POLICY_LIMIT_REACHED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_StateUnspecified
 *        Default state, when Connection Map is created initially. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_Valid Set when
 *        policy and map configuration is valid, and their matching can lead to
 *        allowing creation of PSC Connections subject to other constraints like
 *        connections limit. (Value: "VALID")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Immutable. An immutable map for the producer instance metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConfig_ProducerInstanceMetadata : GTLRObject
@end


/**
 *  Output only. A map to store mapping between customer vip and target service
 *  attachment. Only service attachment with producer specified ip addresses are
 *  stored here.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConfig_ServiceAttachmentIpAddressMap : GTLRObject
@end


/**
 *  PSC connection details on consumer side.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConnection : GTLRObject

/** The most recent error during operating this connection. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcStatus *error GTLR_DEPRECATED;

/**
 *  Output only. The error info for the latest error during operating this
 *  connection.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcErrorInfo *errorInfo;

/**
 *  The error type indicates whether the error is consumer facing, producer
 *  facing or system internal.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ConnectionErrorTypeUnspecified
 *        An invalid error type as the default case. (Value:
 *        "CONNECTION_ERROR_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorConsumerSide
 *        The error is due to the setup on consumer side. (Value:
 *        "ERROR_CONSUMER_SIDE")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorInternal
 *        The error is due to Service Automation system internal. (Value:
 *        "ERROR_INTERNAL")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorProducerSide
 *        The error is due to the setup on producer side. (Value:
 *        "ERROR_PRODUCER_SIDE")
 */
@property(nonatomic, copy, nullable) NSString *errorType GTLR_DEPRECATED;

/**
 *  The URI of the consumer forwarding rule created. Example:
 *  projects/{projectNumOrId}/regions/us-east1/networks/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** The last Compute Engine operation to setup PSC connection. */
@property(nonatomic, copy, nullable) NSString *gceOperation;

/**
 *  The IP literal allocated on the consumer network for the PSC forwarding rule
 *  that is created to connect to the producer service attachment in this
 *  service connection map.
 */
@property(nonatomic, copy, nullable) NSString *ip;

/**
 *  The consumer network whose PSC forwarding rule is connected to the service
 *  attachments in this service connection map. Note that the network could be
 *  on a different project (shared VPC).
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Immutable. Deprecated. Use producer_instance_metadata instead. An immutable
 *  identifier for the producer instance.
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceId GTLR_DEPRECATED;

/** Immutable. An immutable map for the producer instance metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ConsumerPscConnection_ProducerInstanceMetadata *producerInstanceMetadata;

/**
 *  The consumer project whose PSC forwarding rule is connected to the service
 *  attachments in this service connection map.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The PSC connection id of the PSC forwarding rule connected to the service
 *  attachments in this service connection map.
 */
@property(nonatomic, copy, nullable) NSString *pscConnectionId;

/**
 *  Output only. The URI of the selected subnetwork selected to allocate IP
 *  address for this connection.
 */
@property(nonatomic, copy, nullable) NSString *selectedSubnetwork;

/**
 *  The URI of a service attachment which is the target of the PSC connection.
 */
@property(nonatomic, copy, nullable) NSString *serviceAttachmentUri;

/**
 *  The state of the PSC connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Active The
 *        connection has been created successfully. However, for the up-to-date
 *        connection status, please use the service attachment's
 *        "ConnectedEndpoint.status" as the source of truth. (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Creating The
 *        connection is being created. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Deleting The
 *        connection is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Failed The
 *        connection is not functional since some resources on the connection
 *        fail to be created. (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_StateUnspecified
 *        An invalid state as the default case. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Immutable. An immutable map for the producer instance metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConnection_ProducerInstanceMetadata : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRNetworkconnectivity_Empty : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRNetworkconnectivity_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Filter matches L4 traffic.
 */
@interface GTLRNetworkconnectivity_Filter : GTLRObject

/**
 *  Optional. The destination IP range of outgoing packets that this
 *  policy-based route applies to. Default is "0.0.0.0/0" if protocol version is
 *  IPv4.
 */
@property(nonatomic, copy, nullable) NSString *destRange;

/**
 *  Optional. The IP protocol that this policy-based route applies to. Valid
 *  values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
 */
@property(nonatomic, copy, nullable) NSString *ipProtocol;

/**
 *  Required. Internet protocol versions this policy-based route applies to. For
 *  this version, only IPV4 is supported. IPV6 is supported in preview.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Filter_ProtocolVersion_Ipv4 The PBR is
 *        for IPv4 internet protocol traffic. (Value: "IPV4")
 *    @arg @c kGTLRNetworkconnectivity_Filter_ProtocolVersion_ProtocolVersionUnspecified
 *        Default value. (Value: "PROTOCOL_VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *protocolVersion;

/**
 *  Optional. The source IP range of outgoing packets that this policy-based
 *  route applies to. Default is "0.0.0.0/0" if protocol version is IPv4.
 */
@property(nonatomic, copy, nullable) NSString *srcRange;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningCancelOperationRequest : GTLRObject
@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_GoogleLongrunningOperation *> *operations;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningOperation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcStatus *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleLongrunningOperation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleLongrunningOperation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningOperation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningOperation_Response : GTLRObject
@end


/**
 *  Describes the cause of the error with structured details. Example of an
 *  error when contacting the "pubsub.googleapis.com" API when it is not
 *  enabled: { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": {
 *  "resource": "projects/123", "service": "pubsub.googleapis.com" } } This
 *  response indicates that the pubsub.googleapis.com API is not enabled.
 *  Example of an error that is returned when attempting to create a Spanner
 *  instance in a region that is out of stock: { "reason": "STOCKOUT" "domain":
 *  "spanner.googleapis.com", "metadata": { "availableRegions":
 *  "us-central1,us-east2" } }
 */
@interface GTLRNetworkconnectivity_GoogleRpcErrorInfo : GTLRObject

/**
 *  The logical grouping to which the "reason" belongs. The error domain is
 *  typically the registered service name of the tool or product that generates
 *  the error. Example: "pubsub.googleapis.com". If the error is generated by
 *  some common infrastructure, the error domain must be a globally unique value
 *  that identifies the infrastructure. For Google API infrastructure, the error
 *  domain is "googleapis.com".
 */
@property(nonatomic, copy, nullable) NSString *domain;

/**
 *  Additional structured details about this error. Keys must match /a-z+/ but
 *  should ideally be lowerCamelCase. Also they must be limited to 64 characters
 *  in length. When identifying the current value of an exceeded limit, the
 *  units should be contained in the key, not the value. For example, rather
 *  than {"instanceLimit": "100/request"}, should be returned as,
 *  {"instanceLimitPerRequest": "100"}, if the client exceeds the number of
 *  instances that can be created in a single (batch) request.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcErrorInfo_Metadata *metadata;

/**
 *  The reason of the error. This is a constant value that identifies the
 *  proximate cause of the error. Error reasons are unique within a particular
 *  domain of errors. This should be at most 63 characters and match a regular
 *  expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
 */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  Additional structured details about this error. Keys must match /a-z+/ but
 *  should ideally be lowerCamelCase. Also they must be limited to 64 characters
 *  in length. When identifying the current value of an exceeded limit, the
 *  units should be contained in the key, not the value. For example, rather
 *  than {"instanceLimit": "100/request"}, should be returned as,
 *  {"instanceLimitPerRequest": "100"}, if the client exceeds the number of
 *  instances that can be created in a single (batch) request.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleRpcErrorInfo_Metadata : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRNetworkconnectivity_GoogleRpcStatus : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item : GTLRObject
@end


/**
 *  A group represents a subset of spokes attached to a hub.
 */
@interface GTLRNetworkconnectivity_Group : GTLRObject

/** Optional. The auto-accept setting for this group. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_AutoAccept *autoAccept;

/** Output only. The time the group was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. The description of the group.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. Labels in key-value pair format. For more information about
 *  labels, see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Group_Labels *labels;

/**
 *  Immutable. The name of the group. Group names must be unique. They use the
 *  following form:
 *  `projects/{project_number}/locations/global/hubs/{hub}/groups/{group_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The name of the route table that corresponds to this group.
 *  They use the following form:
 *  `projects/{project_number}/locations/global/hubs/{hub_id}/routeTables/{route_table_id}`
 */
@property(nonatomic, copy, nullable) NSString *routeTable;

/**
 *  Output only. The current lifecycle state of this group.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the group. This value is unique
 *  across all group resources. If a group is deleted and another with the same
 *  name is created, the new route table is assigned a different unique_id.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time the group was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels in key-value pair format. For more information about
 *  labels, see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Group_Labels : GTLRObject
@end


/**
 *  A Network Connectivity Center hub is a global management resource to which
 *  you attach spokes. A single hub can contain spokes from multiple regions.
 *  However, if any of a hub's spokes use the site-to-site data transfer
 *  feature, the resources associated with those spokes must all be in the same
 *  VPC network. Spokes that do not use site-to-site data transfer can be
 *  associated with any VPC network in your project.
 */
@interface GTLRNetworkconnectivity_Hub : GTLRObject

/** Output only. The time the hub was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  An optional description of the hub.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. Whether Private Service Connect transitivity is enabled for the
 *  hub. If true, Private Service Connect endpoints in VPC spokes attached to
 *  the hub are made accessible to other VPC spokes attached to the hub. The
 *  default value is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exportPsc;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Hub_Labels *labels;

/**
 *  Immutable. The name of the hub. Hub names must be unique. They use the
 *  following form: `projects/{project_number}/locations/global/hubs/{hub_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. The policy mode of this hub. This field can be either PRESET or
 *  CUSTOM. If unspecified, the policy_mode defaults to PRESET.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Hub_PolicyMode_PolicyModeUnspecified
 *        Policy mode is unspecified. It defaults to PRESET with preset_topology
 *        = MESH. (Value: "POLICY_MODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_PolicyMode_Preset Hub uses one of the
 *        preset topologies. (Value: "PRESET")
 */
@property(nonatomic, copy, nullable) NSString *policyMode;

/**
 *  Optional. The topology implemented in this hub. Currently, this field is
 *  only used when policy_mode = PRESET. The available preset topologies are
 *  MESH and STAR. If preset_topology is unspecified and policy_mode = PRESET,
 *  the preset_topology defaults to MESH. When policy_mode = CUSTOM, the
 *  preset_topology is set to PRESET_TOPOLOGY_UNSPECIFIED.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Hub_PresetTopology_Mesh Mesh topology is
 *        implemented. Group `default` is automatically created. All spokes in
 *        the hub are added to group `default`. (Value: "MESH")
 *    @arg @c kGTLRNetworkconnectivity_Hub_PresetTopology_PresetTopologyUnspecified
 *        Preset topology is unspecified. When policy_mode = PRESET, it defaults
 *        to MESH. (Value: "PRESET_TOPOLOGY_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_PresetTopology_Star Star topology is
 *        implemented. Two groups, `center` and `edge`, are automatically
 *        created along with hub creation. Spokes have to join one of the groups
 *        during creation. (Value: "STAR")
 */
@property(nonatomic, copy, nullable) NSString *presetTopology;

/**
 *  Output only. The route tables that belong to this hub. They use the
 *  following form:
 *  `projects/{project_number}/locations/global/hubs/{hub_id}/routeTables/{route_table_id}`
 *  This field is read-only. Network Connectivity Center automatically populates
 *  it based on the route tables nested under the hub.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *routeTables;

/**
 *  The VPC networks associated with this hub's spokes. This field is read-only.
 *  Network Connectivity Center automatically populates it based on the set of
 *  spokes attached to the hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RoutingVPC *> *routingVpcs;

/**
 *  Output only. A summary of the spokes associated with a hub. The summary
 *  includes a count of spokes according to type and according to state. If any
 *  spokes are inactive, the summary also lists the reasons they are inactive,
 *  including a count for each reason.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_SpokeSummary *spokeSummary;

/**
 *  Output only. The current lifecycle state of this hub.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Accepting The resource's accept
 *        operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Creating The resource's create
 *        operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Deleting The resource's delete
 *        operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Rejecting The resource's reject
 *        operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Updating The resource's update
 *        operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the hub. This value is unique
 *  across all hub resources. If a hub is deleted and another with the same name
 *  is created, the new hub is assigned a different unique_id.
 */
@property(nonatomic, copy, nullable) NSString *uniqueId;

/** Output only. The time the hub was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Hub_Labels : GTLRObject
@end


/**
 *  InterconnectAttachment that this route applies to.
 */
@interface GTLRNetworkconnectivity_InterconnectAttachment : GTLRObject

/**
 *  Optional. Cloud region to install this policy-based route on interconnect
 *  attachment. Use `all` to install it on all interconnect attachments.
 */
@property(nonatomic, copy, nullable) NSString *region;

@end


/**
 *  The internal range resource for IPAM operations within a VPC network. Used
 *  to represent a private address range along with behavioral characterstics of
 *  that range (its usage and peering behavior). Networking resources can link
 *  to this range if they are created as belonging to it.
 */
@interface GTLRNetworkconnectivity_InternalRange : GTLRObject

/** Time when the internal range was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The IP range that this internal range defines. NOTE: IPv6 ranges are limited
 *  to usage=EXTERNAL_TO_VPC and peering=FOR_SELF. NOTE: For IPv6 Ranges this
 *  field is compulsory, i.e. the address range must be specified explicitly.
 */
@property(nonatomic, copy, nullable) NSString *ipCidrRange;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_InternalRange_Labels *labels;

/** Optional. Should be present if usage is set to FOR_MIGRATION. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Migration *migration;

/**
 *  Immutable. The name of an internal range. Format:
 *  projects/{project}/locations/{location}/internalRanges/{internal_range} See:
 *  https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The URL or resource ID of the network in which to reserve the internal
 *  range. The network cannot be deleted if there are any reserved internal
 *  ranges referring to it. Legacy networks are not supported. For example:
 *  https://www.googleapis.com/compute/v1/projects/{project}/locations/global/networks/{network}
 *  projects/{project}/locations/global/networks/{network} {network}
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Optional. Types of resources that are allowed to overlap with the current
 *  internal range.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *overlaps;

/**
 *  The type of peering set for this internal range.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_ForPeer This
 *        behavior can be set when the internal range is being reserved for
 *        usage by peers. This means that no resource within the VPC in which it
 *        is being created can use this to associate with a VPC resource, but
 *        one of the peers can. This represents donating a range for peers to
 *        use. (Value: "FOR_PEER")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_ForSelf This is the
 *        default behavior and represents the case that this internal range is
 *        intended to be used in the VPC in which it is created and is
 *        accessible from its peers. This implies that peers or peers-of-peers
 *        cannot use this range. (Value: "FOR_SELF")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_NotShared This
 *        behavior can be set when the internal range is being reserved for
 *        usage by the VPC in which it is created, but not shared with peers. In
 *        a sense, it is local to the VPC. This can be used to create internal
 *        ranges for various purposes like HTTP_INTERNAL_LOAD_BALANCER or for
 *        Interconnect routes that are not shared with peers. This also implies
 *        that peers cannot use this range in a way that is visible to this VPC,
 *        but can re-use this range as long as it is NOT_SHARED from the peer
 *        VPC, too. (Value: "NOT_SHARED")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_PeeringUnspecified
 *        If Peering is left unspecified in CreateInternalRange or
 *        UpdateInternalRange, it will be defaulted to FOR_SELF. (Value:
 *        "PEERING_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *peering;

/**
 *  An alternate to ip_cidr_range. Can be set when trying to create an IPv4
 *  reservation that automatically finds a free range of the given size. If both
 *  ip_cidr_range and prefix_length are set, there is an error if the range
 *  sizes do not match. Can also be used during updates to change the range
 *  size. NOTE: For IPv6 this field only works if ip_cidr_range is set as well,
 *  and both fields must match. In other words, with IPv6 this field only works
 *  as a redundant parameter.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *prefixLength;

/**
 *  Optional. Can be set to narrow down or pick a different address space while
 *  searching for a free range. If not set, defaults to the "10.0.0.0/8" address
 *  space. This can be used to search in other rfc-1918 address spaces like
 *  "172.16.0.0/12" and "192.168.0.0/16" or non-rfc-1918 address spaces used in
 *  the VPC.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *targetCidrRange;

/** Time when the internal range was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  The type of usage set for this InternalRange.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_ExternalToVpc Ranges
 *        created with EXTERNAL_TO_VPC cannot be associated with VPC resources
 *        and are meant to block out address ranges for various use cases, like
 *        for example, usage on-prem, with dynamic route announcements via
 *        interconnect. (Value: "EXTERNAL_TO_VPC")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_ForMigration Ranges
 *        created FOR_MIGRATION can be used to lock a CIDR range between a
 *        source and target subnet. If usage is set to FOR_MIGRATION the peering
 *        value has to be set to FOR_SELF or default to FOR_SELF when unset.
 *        (Value: "FOR_MIGRATION")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_ForVpc A VPC resource
 *        can use the reserved CIDR block by associating it with the internal
 *        range resource if usage is set to FOR_VPC. (Value: "FOR_VPC")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_UsageUnspecified
 *        Unspecified usage is allowed in calls which identify the resource by
 *        other fields and do not need Usage set to complete. These are, i.e.:
 *        GetInternalRange and DeleteInternalRange. Usage needs to be specified
 *        explicitly in CreateInternalRange or UpdateInternalRange calls.
 *        (Value: "USAGE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *usage;

/**
 *  Output only. The list of resources that refer to this internal range.
 *  Resources that use the internal range for their range allocation are
 *  referred to as users of the range. Other resources mark themselves as users
 *  while doing so by creating a reference to this internal range. Having a
 *  user, based on this reference, prevents deletion of the internal range
 *  referred to. Can be empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *users;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_InternalRange_Labels : GTLRObject
@end


/**
 *  A collection of VLAN attachment resources. These resources should be
 *  redundant attachments that all advertise the same prefixes to Google Cloud.
 *  Alternatively, in active/passive configurations, all attachments should be
 *  capable of advertising the same prefixes.
 */
@interface GTLRNetworkconnectivity_LinkedInterconnectAttachments : GTLRObject

/**
 *  Optional. IP ranges allowed to be included during import from hub.(does not
 *  control transit connectivity) The only allowed value for now is
 *  "ALL_IPV4_RANGES".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeImportRanges;

/**
 *  A value that controls whether site-to-site data transfer is enabled for
 *  these resources. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URIs of linked interconnect attachment resources */
@property(nonatomic, strong, nullable) NSArray<NSString *> *uris;

/** Output only. The VPC network where these VLAN attachments are located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  A collection of router appliance instances. If you configure multiple router
 *  appliance instances to receive data from the same set of sites outside of
 *  Google Cloud, we recommend that you associate those instances with the same
 *  spoke.
 */
@interface GTLRNetworkconnectivity_LinkedRouterApplianceInstances : GTLRObject

/**
 *  Optional. IP ranges allowed to be included during import from hub.(does not
 *  control transit connectivity) The only allowed value for now is
 *  "ALL_IPV4_RANGES".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeImportRanges;

/** The list of router appliance instances. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RouterApplianceInstance *> *instances;

/**
 *  A value that controls whether site-to-site data transfer is enabled for
 *  these resources. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/**
 *  Output only. The VPC network where these router appliance instances are
 *  located.
 */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  An existing VPC network.
 */
@interface GTLRNetworkconnectivity_LinkedVpcNetwork : GTLRObject

/**
 *  Optional. IP ranges encompassing the subnets to be excluded from peering.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludeExportRanges;

/** Optional. IP ranges allowed to be included from peering. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeExportRanges;

/**
 *  Output only. The list of Producer VPC spokes that this VPC spoke is a
 *  service consumer VPC spoke for. These producer VPCs are connected through
 *  VPC peering to this spoke's backing VPC network.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *producerVpcSpokes;

/** Required. The URI of the VPC network resource. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A collection of Cloud VPN tunnel resources. These resources should be
 *  redundant HA VPN tunnels that all advertise the same prefixes to Google
 *  Cloud. Alternatively, in a passive/active configuration, all tunnels should
 *  be capable of advertising the same prefixes.
 */
@interface GTLRNetworkconnectivity_LinkedVpnTunnels : GTLRObject

/**
 *  Optional. IP ranges allowed to be included during import from hub.(does not
 *  control transit connectivity) The only allowed value for now is
 *  "ALL_IPV4_RANGES".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeImportRanges;

/**
 *  A value that controls whether site-to-site data transfer is enabled for
 *  these resources. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URIs of linked VPN tunnel resources. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *uris;

/** Output only. The VPC network where these VPN tunnels are located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  Response for HubService.ListGroups method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "groups" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListGroupsResponse : GTLRCollectionObject

/**
 *  The requested groups.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Group *> *groups;

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Hubs that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response for HubService.ListHubSpokes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "spokes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListHubSpokesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested spokes. The spoke fields can be partially populated based on
 *  the `view` field in the request message.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Spoke *> *spokes;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListHubs method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hubs" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListHubsResponse : GTLRCollectionObject

/**
 *  The requested hubs.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Hub *> *hubs;

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for InternalRange.ListInternalRanges
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "internalRanges" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRNetworkconnectivity_ListInternalRangesResponse : GTLRCollectionObject

/**
 *  Internal ranges to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_InternalRange *> *internalRanges;

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response for PolicyBasedRouting.ListPolicyBasedRoutes method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "policyBasedRoutes" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListPolicyBasedRoutesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Policy-based routes to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_PolicyBasedRoute *> *policyBasedRoutes;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListRegionalEndpoints.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "regionalEndpoints" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListRegionalEndpointsResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Regional endpoints to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RegionalEndpoint *> *regionalEndpoints;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListRoutes method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "routes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListRoutesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested routes.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Route *> *routes;

/** RouteTables that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListRouteTables method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "routeTables" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListRouteTablesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested route tables.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RouteTable *> *routeTables;

/** Hubs that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceClasses.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceClasses" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceClassesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceClasses to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceClass *> *serviceClasses;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceConnectionMaps.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceConnectionMaps" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceConnectionMapsResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceConnectionMaps to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConnectionMap *> *serviceConnectionMaps;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceConnectionPolicies.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceConnectionPolicies" property. If returned as the result of
 *        a query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceConnectionPoliciesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceConnectionPolicies to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConnectionPolicy *> *serviceConnectionPolicies;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceConnectionTokens.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceConnectionTokens" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceConnectionTokensResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceConnectionTokens to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConnectionToken *> *serviceConnectionTokens;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response for HubService.ListSpokes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "spokes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListSpokesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested spokes.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Spoke *> *spokes;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRNetworkconnectivity_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Location_Metadata : GTLRObject
@end


/**
 *  Metadata about locations
 */
@interface GTLRNetworkconnectivity_LocationMetadata : GTLRObject

/** List of supported features */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locationFeatures;

@end


/**
 *  Specification for migration with source and target resource names.
 */
@interface GTLRNetworkconnectivity_Migration : GTLRObject

/**
 *  Immutable. Resource path as an URI of the source resource, for example a
 *  subnet. The project for the source resource should match the project for the
 *  InternalRange. An example:
 *  /projects/{project}/regions/{region}/subnetworks/{subnet}
 */
@property(nonatomic, copy, nullable) NSString *source;

/**
 *  Immutable. Resource path of the target resource. The target project can be
 *  different, as in the cases when migrating to peer networks. The resource For
 *  example: /projects/{project}/regions/{region}/subnetworks/{subnet}
 */
@property(nonatomic, copy, nullable) NSString *target;

@end


/**
 *  A route next hop that leads to an interconnect attachment resource.
 */
@interface GTLRNetworkconnectivity_NextHopInterconnectAttachment : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this
 *  interconnect attachment resource. Data transfer is available only in
 *  [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the interconnect attachment resource. */
@property(nonatomic, copy, nullable) NSString *uri;

/** The VPC network where this interconnect attachment is located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  A route next hop that leads to a Router appliance instance.
 */
@interface GTLRNetworkconnectivity_NextHopRouterApplianceInstance : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this Router
 *  appliance instance resource. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the Router appliance instance. */
@property(nonatomic, copy, nullable) NSString *uri;

/** The VPC network where this VM is located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  GTLRNetworkconnectivity_NextHopVpcNetwork
 */
@interface GTLRNetworkconnectivity_NextHopVpcNetwork : GTLRObject

/** The URI of the VPC network resource */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A route next hop that leads to a VPN tunnel resource.
 */
@interface GTLRNetworkconnectivity_NextHopVPNTunnel : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this VPN tunnel
 *  resource. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the VPN tunnel resource. */
@property(nonatomic, copy, nullable) NSString *uri;

/** The VPC network where this VPN tunnel is located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRNetworkconnectivity_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have been cancelled successfully have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** ``` { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
 *  members: - user:mike\@example.com - group:admins\@example.com -
 *  domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 ``` For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRNetworkconnectivity_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Policy-based routes route L4 network traffic based on not just destination
 *  IP address, but also source IP address, protocol, and more. If a
 *  policy-based route conflicts with other types of routes, the policy-based
 *  route always takes precedence.
 */
@interface GTLRNetworkconnectivity_PolicyBasedRoute : GTLRObject

/** Output only. Time when the policy-based route was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. An optional description of this resource. Provide this field when
 *  you create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Required. The filter to match L4 traffic. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Filter *filter;

/**
 *  Optional. The interconnect attachments that this policy-based route applies
 *  to.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_InterconnectAttachment *interconnectAttachment;

/**
 *  Output only. Type of this resource. Always
 *  networkconnectivity#policyBasedRoute for policy-based Route resources.
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PolicyBasedRoute_Labels *labels;

/**
 *  Immutable. A unique name of the resource in the form of
 *  `projects/{project_number}/locations/global/PolicyBasedRoutes/{policy_based_route_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Fully-qualified URL of the network that this route applies to, for
 *  example: projects/my-project/global/networks/my-network.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Optional. The IP address of a global-access-enabled L4 ILB that is the next
 *  hop for matching packets. For this version, only nextHopIlbIp is supported.
 */
@property(nonatomic, copy, nullable) NSString *nextHopIlbIp;

/**
 *  Optional. Other routes that will be referenced to determine the next hop of
 *  the packet.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_DefaultRouting
 *        Use the routes from the default routing tables (system-generated
 *        routes, custom routes, peering route) to determine the next hop. This
 *        effectively excludes matching packets being applied on other PBRs with
 *        a lower priority. (Value: "DEFAULT_ROUTING")
 *    @arg @c kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_OtherRoutesUnspecified
 *        Default value. (Value: "OTHER_ROUTES_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *nextHopOtherRoutes;

/**
 *  Optional. The priority of this policy-based route. Priority is used to break
 *  ties in cases where there are more than one matching policy-based routes
 *  found. In cases where multiple policy-based routes are matched, the one with
 *  the lowest-numbered priority value wins. The default value is 1000. The
 *  priority value must be from 1 to 65535, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/** Output only. Server-defined fully-qualified URL for this resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/** Output only. Time when the policy-based route was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Optional. VM instances that this policy-based route applies to. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_VirtualMachine *virtualMachine;

/**
 *  Output only. If potential misconfigurations are detected for this route,
 *  this field will be populated with warning messages.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Warnings *> *warnings;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_PolicyBasedRoute_Labels : GTLRObject
@end


/**
 *  The PSC configurations on producer side.
 */
@interface GTLRNetworkconnectivity_ProducerPscConfig : GTLRObject

/**
 *  The resource path of a service attachment. Example:
 *  projects/{projectNumOrId}/regions/{region}/serviceAttachments/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *serviceAttachmentUri;

@end


/**
 *  Configuration used for Private Service Connect connections. Used when
 *  Infrastructure is PSC.
 */
@interface GTLRNetworkconnectivity_PscConfig : GTLRObject

/**
 *  Optional. List of Projects, Folders, or Organizations from where the
 *  Producer instance can be within. For example, a network administrator can
 *  provide both 'organizations/foo' and 'projects/bar' as
 *  allowed_google_producers_resource_hierarchy_levels. This allowlists this
 *  network to connect with any Producer instance within the 'foo' organization
 *  or the 'bar' project. By default,
 *  allowed_google_producers_resource_hierarchy_level is empty. The format for
 *  each allowed_google_producers_resource_hierarchy_level is / where is one of
 *  'projects', 'folders', or 'organizations' and is either the ID or the number
 *  of the resource type. Format for each
 *  allowed_google_producers_resource_hierarchy_level value: 'projects/' or
 *  'folders/' or 'organizations/' Eg. [projects/my-project-id, projects/567,
 *  folders/891, organizations/123]
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedGoogleProducersResourceHierarchyLevel;

/**
 *  Optional. Max number of PSC connections for this policy.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *limit;

/**
 *  Required. ProducerInstanceLocation is used to specify which authorization
 *  mechanism to use to determine which projects the Producer instance can be
 *  within.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_CustomResourceHierarchyLevels
 *        Producer instance must be within one of the values provided in
 *        allowed_google_producers_resource_hierarchy_level. (Value:
 *        "CUSTOM_RESOURCE_HIERARCHY_LEVELS")
 *    @arg @c kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_ProducerInstanceLocationUnspecified
 *        Producer instance location is not specified. When this option is
 *        chosen, then the PSC connections created by this
 *        ServiceConnectionPolicy must be within the same project as the
 *        Producer instance. This is the default ProducerInstanceLocation value.
 *        To allow for PSC connections from this network to other networks, use
 *        the CUSTOM_RESOURCE_HIERARCHY_LEVELS option. (Value:
 *        "PRODUCER_INSTANCE_LOCATION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceLocation;

/**
 *  The resource paths of subnetworks to use for IP address management. Example:
 *  projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *subnetworks;

@end


/**
 *  Information about a specific Private Service Connect connection.
 */
@interface GTLRNetworkconnectivity_PscConnection : GTLRObject

/** The resource reference of the consumer address. */
@property(nonatomic, copy, nullable) NSString *consumerAddress;

/**
 *  The resource reference of the PSC Forwarding Rule within the consumer VPC.
 */
@property(nonatomic, copy, nullable) NSString *consumerForwardingRule;

/** The project where the PSC connection is created. */
@property(nonatomic, copy, nullable) NSString *consumerTargetProject;

/**
 *  The most recent error during operating this connection. Deprecated, please
 *  use error_info instead.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcStatus *error GTLR_DEPRECATED;

/**
 *  Output only. The error info for the latest error during operating this
 *  connection.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcErrorInfo *errorInfo;

/**
 *  The error type indicates whether the error is consumer facing, producer
 *  facing or system internal.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ConnectionErrorTypeUnspecified
 *        An invalid error type as the default case. (Value:
 *        "CONNECTION_ERROR_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorConsumerSide
 *        The error is due to the setup on consumer side. (Value:
 *        "ERROR_CONSUMER_SIDE")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorInternal The
 *        error is due to Service Automation system internal. (Value:
 *        "ERROR_INTERNAL")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorProducerSide
 *        The error is due to the setup on producer side. (Value:
 *        "ERROR_PRODUCER_SIDE")
 */
@property(nonatomic, copy, nullable) NSString *errorType GTLR_DEPRECATED;

/** The last Compute Engine operation to setup PSC connection. */
@property(nonatomic, copy, nullable) NSString *gceOperation;

/**
 *  Immutable. Deprecated. Use producer_instance_metadata instead. An immutable
 *  identifier for the producer instance.
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceId GTLR_DEPRECATED;

/** Immutable. An immutable map for the producer instance metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PscConnection_ProducerInstanceMetadata *producerInstanceMetadata;

/** The PSC connection id of the PSC forwarding rule. */
@property(nonatomic, copy, nullable) NSString *pscConnectionId;

/**
 *  Output only. The URI of the subnetwork selected to allocate IP address for
 *  this connection.
 */
@property(nonatomic, copy, nullable) NSString *selectedSubnetwork;

/**
 *  Output only. [Output only] The service class associated with this PSC
 *  Connection. The value is derived from the SCPolicy and matches the service
 *  class name provided by the customer.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/**
 *  State of the PSC Connection
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Active The connection
 *        has been created successfully. However, for the up-to-date connection
 *        status, please use the created forwarding rule's "PscConnectionStatus"
 *        as the source of truth. (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Creating The
 *        connection is being created. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Deleting The
 *        connection is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Failed The connection
 *        is not functional since some resources on the connection fail to be
 *        created. (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_StateUnspecified An
 *        invalid state as the default case. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Immutable. An immutable map for the producer instance metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_PscConnection_ProducerInstanceMetadata : GTLRObject
@end


/**
 *  The RegionalEndpoint resource.
 */
@interface GTLRNetworkconnectivity_RegionalEndpoint : GTLRObject

/**
 *  Required. The access type of this regional endpoint. This field is reflected
 *  in the PSC Forwarding Rule configuration to enable global access.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_AccessTypeUnspecified
 *        An invalid type as the default case. (Value:
 *        "ACCESS_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Global This
 *        regional endpoint is accessible from all regions. (Value: "GLOBAL")
 *    @arg @c kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Regional This
 *        regional endpoint is only accessible from the same region where it
 *        resides. (Value: "REGIONAL")
 */
@property(nonatomic, copy, nullable) NSString *accessType;

/**
 *  Optional. The IP Address of the Regional Endpoint. When no address is
 *  provided, an IP from the subnetwork is allocated. Use one of the following
 *  formats: * IPv4 address as in `10.0.0.1` * Address resource URI as in
 *  `projects/{project}/regions/{region}/addresses/{address_name}`
 */
@property(nonatomic, copy, nullable) NSString *address;

/** Output only. Time when the RegionalEndpoint was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The literal IP address of the PSC Forwarding Rule created on
 *  behalf of the customer. This field is deprecated. Use address instead.
 */
@property(nonatomic, copy, nullable) NSString *ipAddress GTLR_DEPRECATED;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_RegionalEndpoint_Labels *labels;

/**
 *  Output only. The name of a RegionalEndpoint. Format:
 *  `projects/{project}/locations/{location}/regionalEndpoints/{regional_endpoint}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the VPC network for this private regional endpoint. Format:
 *  `projects/{project}/global/networks/{network}`
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Output only. The resource reference of the PSC Forwarding Rule created on
 *  behalf of the customer. Format:
 *  `//compute.googleapis.com/projects/{project}/regions/{region}/forwardingRules/{forwarding_rule_name}`
 */
@property(nonatomic, copy, nullable) NSString *pscForwardingRule;

/**
 *  The name of the subnetwork from which the IP address will be allocated.
 *  Format: `projects/{project}/regions/{region}/subnetworks/{subnetwork}`
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Required. The service endpoint this private regional endpoint connects to.
 *  Format: `{apiname}.{region}.p.rep.googleapis.com` Example:
 *  "cloudkms.us-central1.p.rep.googleapis.com".
 */
@property(nonatomic, copy, nullable) NSString *targetGoogleApi;

/** Output only. Time when the RegionalEndpoint was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_RegionalEndpoint_Labels : GTLRObject
@end


/**
 *  The request for HubService.RejectHubSpoke.
 */
@interface GTLRNetworkconnectivity_RejectHubSpokeRequest : GTLRObject

/** Optional. Additional information provided by the hub administrator. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  Optional. A request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server knows to ignore the request
 *  if it has already been completed. The server guarantees that a request
 *  doesn't result in creation of duplicate commitments for at least 60 minutes.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check to see whether the original operation was received. If
 *  it was, the server ignores the second request. This behavior prevents
 *  clients from mistakenly creating duplicate commitments. The request ID must
 *  be a valid UUID, with the exception that zero UUID is not supported
 *  (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Required. The URI of the spoke to reject from the hub. */
@property(nonatomic, copy, nullable) NSString *spokeUri;

@end


/**
 *  The response for HubService.RejectHubSpoke.
 */
@interface GTLRNetworkconnectivity_RejectHubSpokeResponse : GTLRObject

/** The spoke that was operated on. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Spoke *spoke;

@end


/**
 *  A route defines a path from VM instances within a spoke to a specific
 *  destination resource. Only VPC spokes have routes.
 */
@interface GTLRNetworkconnectivity_Route : GTLRObject

/** Output only. The time the route was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  An optional description of the route.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The destination IP address range. */
@property(nonatomic, copy, nullable) NSString *ipCidrRange;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Route_Labels *labels;

/**
 *  Output only. The origin location of the route. Uses the following form:
 *  "projects/{project}/locations/{location}" Example:
 *  projects/1234/locations/us-central1
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Immutable. The name of the route. Route names must be unique. Route names
 *  use the following form:
 *  `projects/{project_number}/locations/global/hubs/{hub}/routeTables/{route_table_id}/routes/{route_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Immutable. The next-hop VLAN attachment for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopInterconnectAttachment *nextHopInterconnectAttachment;

/**
 *  Immutable. The next-hop Router appliance instance for packets on this route.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopRouterApplianceInstance *nextHopRouterApplianceInstance;

/** Immutable. The destination VPC network for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopVpcNetwork *nextHopVpcNetwork;

/** Immutable. The next-hop VPN tunnel for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopVPNTunnel *nextHopVpnTunnel;

/**
 *  Output only. The priority of this route. Priority is used to break ties in
 *  cases where a destination matches more than one route. In these cases the
 *  route with the lowest-numbered priority value wins.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/**
 *  Immutable. The spoke that this route leads to. Example:
 *  projects/12345/locations/global/spokes/SPOKE
 */
@property(nonatomic, copy, nullable) NSString *spoke;

/**
 *  Output only. The current lifecycle state of the route.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The route's type. Its type is determined by the properties of
 *  its IP address range.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_DynamicRoute The route leads
 *        to a destination in a dynamic route. Dynamic routes are derived from
 *        Border Gateway Protocol (BGP) advertisements received from an NCC
 *        hybrid spoke. (Value: "DYNAMIC_ROUTE")
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_RouteTypeUnspecified No route
 *        type information specified (Value: "ROUTE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_VpcPrimarySubnet The route
 *        leads to a destination within the primary address range of the VPC
 *        network's subnet. (Value: "VPC_PRIMARY_SUBNET")
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_VpcSecondarySubnet The route
 *        leads to a destination within the secondary address range of the VPC
 *        network's subnet. (Value: "VPC_SECONDARY_SUBNET")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Output only. The Google-generated UUID for the route. This value is unique
 *  across all Network Connectivity Center route resources. If a route is
 *  deleted and another with the same name is created, the new route is assigned
 *  a different `uid`.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time the route was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Route_Labels : GTLRObject
@end


/**
 *  A router appliance instance is a Compute Engine virtual machine (VM)
 *  instance that acts as a BGP speaker. A router appliance instance is
 *  specified by the URI of the VM and the internal IP address of one of the
 *  VM's network interfaces.
 */
@interface GTLRNetworkconnectivity_RouterApplianceInstance : GTLRObject

/** The IP address on the VM to use for peering. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/** The URI of the VM. */
@property(nonatomic, copy, nullable) NSString *virtualMachine;

@end


/**
 *  GTLRNetworkconnectivity_RouteTable
 */
@interface GTLRNetworkconnectivity_RouteTable : GTLRObject

/** Output only. The time the route table was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  An optional description of the route table.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_RouteTable_Labels *labels;

/**
 *  Immutable. The name of the route table. Route table names must be unique.
 *  They use the following form:
 *  `projects/{project_number}/locations/global/hubs/{hub}/routeTables/{route_table_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current lifecycle state of this route table.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Active The resource is
 *        active (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Obsolete The hub
 *        associated with this spoke resource has been deleted. This state
 *        applies to spoke resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_StateUnspecified No
 *        state information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the route table. This value is
 *  unique across all route table resources. If a route table is deleted and
 *  another with the same name is created, the new route table is assigned a
 *  different `uid`.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time the route table was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_RouteTable_Labels : GTLRObject
@end


/**
 *  RoutingVPC contains information about the VPC networks associated with the
 *  spokes of a Network Connectivity Center hub.
 */
@interface GTLRNetworkconnectivity_RoutingVPC : GTLRObject

/**
 *  Output only. If true, indicates that this VPC network is currently
 *  associated with spokes that use the data transfer feature (spokes where the
 *  site_to_site_data_transfer field is set to true). If you create new spokes
 *  that use data transfer, they must be associated with this VPC network. At
 *  most, one VPC network will have this field set to true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requiredForNewSiteToSiteDataTransferSpokes;

/** The URI of the VPC network. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  The ServiceClass resource. Next id: 9
 */
@interface GTLRNetworkconnectivity_ServiceClass : GTLRObject

/** Output only. Time when the ServiceClass was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceClass_Labels *labels;

/**
 *  Immutable. The name of a ServiceClass resource. Format:
 *  projects/{project}/locations/{location}/serviceClasses/{service_class} See:
 *  https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The generated service class name. Use this name to refer to the
 *  Service class in Service Connection Maps and Service Connection Policies.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/** Output only. Time when the ServiceClass was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceClass_Labels : GTLRObject
@end


/**
 *  The ServiceConnectionMap resource. Next id: 15
 */
@interface GTLRNetworkconnectivity_ServiceConnectionMap : GTLRObject

/** The PSC configurations on consumer side. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ConsumerPscConfig *> *consumerPscConfigs;

/** Output only. PSC connection details on consumer side. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ConsumerPscConnection *> *consumerPscConnections;

/** Output only. Time when the ServiceConnectionMap was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. The infrastructure used for connections between
 *  consumers/producers.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_InfrastructureUnspecified
 *        An invalid infrastructure as the default case. (Value:
 *        "INFRASTRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_Psc
 *        Private Service Connect is used for connections. (Value: "PSC")
 */
@property(nonatomic, copy, nullable) NSString *infrastructure;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceConnectionMap_Labels *labels;

/**
 *  Immutable. The name of a ServiceConnectionMap. Format:
 *  projects/{project}/locations/{location}/serviceConnectionMaps/{service_connection_map}
 *  See: https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The PSC configurations on producer side. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ProducerPscConfig *> *producerPscConfigs;

/**
 *  The service class identifier this ServiceConnectionMap is for. The user of
 *  ServiceConnectionMap create API needs to have
 *  networkconnecitivty.serviceclasses.use iam permission for the service class.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/** Output only. The service class uri this ServiceConnectionMap is for. */
@property(nonatomic, copy, nullable) NSString *serviceClassUri;

/**
 *  The token provided by the consumer. This token authenticates that the
 *  consumer can create a connecton within the specified project and network.
 */
@property(nonatomic, copy, nullable) NSString *token;

/** Output only. Time when the ServiceConnectionMap was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionMap_Labels : GTLRObject
@end


/**
 *  The ServiceConnectionPolicy resource. Next id: 12
 */
@interface GTLRNetworkconnectivity_ServiceConnectionPolicy : GTLRObject

/** Output only. Time when the ServiceConnectionPolicy was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. The type of underlying resources used to create the connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_InfrastructureUnspecified
 *        An invalid infrastructure as the default case. (Value:
 *        "INFRASTRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_Psc
 *        Private Service Connect is used for connections. (Value: "PSC")
 */
@property(nonatomic, copy, nullable) NSString *infrastructure;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceConnectionPolicy_Labels *labels;

/**
 *  Immutable. The name of a ServiceConnectionPolicy. Format:
 *  projects/{project}/locations/{location}/serviceConnectionPolicies/{service_connection_policy}
 *  See: https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The resource path of the consumer network. Example: -
 *  projects/{projectNumOrId}/global/networks/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Configuration used for Private Service Connect connections. Used when
 *  Infrastructure is PSC.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PscConfig *pscConfig;

/**
 *  Output only. [Output only] Information about each Private Service Connect
 *  connection.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_PscConnection *> *pscConnections;

/**
 *  The service class identifier for which this ServiceConnectionPolicy is for.
 *  The service class identifier is a unique, symbolic representation of a
 *  ServiceClass. It is provided by the Service Producer. Google services have a
 *  prefix of gcp or google-cloud. For example, gcp-memorystore-redis or
 *  google-cloud-sql. 3rd party services do not. For example,
 *  test-service-a3dfcx.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/** Output only. Time when the ServiceConnectionPolicy was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionPolicy_Labels : GTLRObject
@end


/**
 *  The ServiceConnectionToken resource. Next id: 10
 */
@interface GTLRNetworkconnectivity_ServiceConnectionToken : GTLRObject

/** Output only. Time when the ServiceConnectionToken was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Output only. The time to which this token is valid. */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceConnectionToken_Labels *labels;

/**
 *  Immutable. The name of a ServiceConnectionToken. Format:
 *  projects/{project}/locations/{location}/ServiceConnectionTokens/{service_connection_token}
 *  See: https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The resource path of the network associated with this token. Example:
 *  projects/{projectNumOrId}/global/networks/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *network;

/** Output only. The token generated by Automation. */
@property(nonatomic, copy, nullable) NSString *token;

/** Output only. Time when the ServiceConnectionToken was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionToken_Labels : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRNetworkconnectivity_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  A Network Connectivity Center spoke represents one or more network
 *  connectivity resources. When you create a spoke, you associate it with a
 *  hub. You must also identify a value for exactly one of the following fields:
 *  * linked_vpn_tunnels * linked_interconnect_attachments *
 *  linked_router_appliance_instances * linked_vpc_network
 */
@interface GTLRNetworkconnectivity_Spoke : GTLRObject

/** Output only. The time the spoke was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  An optional description of the spoke.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Optional. The name of the group that this spoke is associated with. */
@property(nonatomic, copy, nullable) NSString *group;

/** Immutable. The name of the hub that this spoke is attached to. */
@property(nonatomic, copy, nullable) NSString *hub;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Spoke_Labels *labels;

/** VLAN attachments that are associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedInterconnectAttachments *linkedInterconnectAttachments;

/** Router appliance instances that are associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedRouterApplianceInstances *linkedRouterApplianceInstances;

/** Optional. VPC network that is associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedVpcNetwork *linkedVpcNetwork;

/** VPN tunnels that are associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedVpnTunnels *linkedVpnTunnels;

/**
 *  Immutable. The name of the spoke. Spoke names must be unique. They use the
 *  following form:
 *  `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The reasons for current state of the spoke. Only present when
 *  the spoke is in the `INACTIVE` state.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_StateReason *> *reasons;

/**
 *  Output only. The type of resource associated with the spoke.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_InterconnectAttachment
 *        Spokes associated with VLAN attachments. (Value:
 *        "INTERCONNECT_ATTACHMENT")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_RouterAppliance Spokes
 *        associated with router appliance instances. (Value:
 *        "ROUTER_APPLIANCE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_SpokeTypeUnspecified
 *        Unspecified spoke type. (Value: "SPOKE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_VpcNetwork Spokes
 *        associated with VPC networks. (Value: "VPC_NETWORK")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_VpnTunnel Spokes
 *        associated with VPN tunnels. (Value: "VPN_TUNNEL")
 */
@property(nonatomic, copy, nullable) NSString *spokeType;

/**
 *  Output only. The current lifecycle state of this spoke.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the spoke. This value is unique
 *  across all spoke resources. If a spoke is deleted and another with the same
 *  name is created, the new spoke is assigned a different `unique_id`.
 */
@property(nonatomic, copy, nullable) NSString *uniqueId;

/** Output only. The time the spoke was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Spoke_Labels : GTLRObject
@end


/**
 *  The number of spokes that are in a particular state and associated with a
 *  given hub.
 */
@interface GTLRNetworkconnectivity_SpokeStateCount : GTLRObject

/**
 *  Output only. The total number of spokes that are in this state and
 *  associated with a given hub.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Output only. The state of the spokes.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Accepting The
 *        resource's accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Active The resource
 *        is active (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Creating The
 *        resource's create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Deleting The
 *        resource's delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Inactive The
 *        resource is inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Obsolete The hub
 *        associated with this spoke resource has been deleted. This state
 *        applies to spoke resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Rejecting The
 *        resource's reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_StateUnspecified No
 *        state information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Updating The
 *        resource's update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  The number of spokes in the hub that are inactive for this reason.
 */
@interface GTLRNetworkconnectivity_SpokeStateReasonCount : GTLRObject

/**
 *  Output only. The total number of spokes that are inactive for a particular
 *  reason and associated with a given hub.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Output only. The reason that a spoke is inactive.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_CodeUnspecified
 *        No information available. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Failed
 *        Network Connectivity Center encountered errors while accepting the
 *        spoke. (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Paused
 *        The spoke has been deactivated internally. (Value: "PAUSED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_PendingReview
 *        The proposed spoke is pending review. (Value: "PENDING_REVIEW")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Rejected
 *        The proposed spoke has been rejected by the hub administrator. (Value:
 *        "REJECTED")
 */
@property(nonatomic, copy, nullable) NSString *stateReasonCode;

@end


/**
 *  Summarizes information about the spokes associated with a hub. The summary
 *  includes a count of spokes according to type and according to state. If any
 *  spokes are inactive, the summary also lists the reasons they are inactive,
 *  including a count for each reason.
 */
@interface GTLRNetworkconnectivity_SpokeSummary : GTLRObject

/**
 *  Output only. Counts the number of spokes that are in each state and
 *  associated with a given hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_SpokeStateCount *> *spokeStateCounts;

/**
 *  Output only. Counts the number of spokes that are inactive for each possible
 *  reason and associated with a given hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_SpokeStateReasonCount *> *spokeStateReasonCounts;

/**
 *  Output only. Counts the number of spokes of each type that are associated
 *  with a specific hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_SpokeTypeCount *> *spokeTypeCounts;

@end


/**
 *  The number of spokes of a given type that are associated with a specific
 *  hub. The type indicates what kind of resource is associated with the spoke.
 */
@interface GTLRNetworkconnectivity_SpokeTypeCount : GTLRObject

/**
 *  Output only. The total number of spokes of this type that are associated
 *  with the hub.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Output only. The type of the spokes.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_InterconnectAttachment
 *        Spokes associated with VLAN attachments. (Value:
 *        "INTERCONNECT_ATTACHMENT")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_RouterAppliance
 *        Spokes associated with router appliance instances. (Value:
 *        "ROUTER_APPLIANCE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_SpokeTypeUnspecified
 *        Unspecified spoke type. (Value: "SPOKE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpcNetwork
 *        Spokes associated with VPC networks. (Value: "VPC_NETWORK")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpnTunnel Spokes
 *        associated with VPN tunnels. (Value: "VPN_TUNNEL")
 */
@property(nonatomic, copy, nullable) NSString *spokeType;

@end


/**
 *  The reason a spoke is inactive.
 */
@interface GTLRNetworkconnectivity_StateReason : GTLRObject

/**
 *  The code associated with this reason.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_CodeUnspecified No
 *        information available. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_Failed Network
 *        Connectivity Center encountered errors while accepting the spoke.
 *        (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_Paused The spoke has
 *        been deactivated internally. (Value: "PAUSED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_PendingReview The
 *        proposed spoke is pending review. (Value: "PENDING_REVIEW")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_Rejected The proposed
 *        spoke has been rejected by the hub administrator. (Value: "REJECTED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** Human-readable details about this reason. */
@property(nonatomic, copy, nullable) NSString *message;

/** Additional information provided by the user in the RejectSpoke call. */
@property(nonatomic, copy, nullable) NSString *userDetails;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRNetworkconnectivity_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRNetworkconnectivity_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  VM instances that this policy-based route applies to.
 */
@interface GTLRNetworkconnectivity_VirtualMachine : GTLRObject

/**
 *  Optional. A list of VM instance tags that this policy-based route applies
 *  to. VM instances that have ANY of tags specified here installs this PBR.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  Informational warning message.
 */
@interface GTLRNetworkconnectivity_Warnings : GTLRObject

/**
 *  Output only. A warning code, if applicable.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Warnings_Code_ResourceBeingModified The
 *        policy-based route is being modified (e.g. created/deleted) at this
 *        time. (Value: "RESOURCE_BEING_MODIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Warnings_Code_ResourceNotActive The
 *        policy-based route is not active and functioning. Common causes are
 *        that the dependent network was deleted or the resource project was
 *        turned off. (Value: "RESOURCE_NOT_ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Warnings_Code_WarningUnspecified Default
 *        value. (Value: "WARNING_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Output only. Metadata about this warning in key: value format. The key
 *  should provides more detail on the warning being returned. For example, for
 *  warnings where there are no results in a list request for a particular zone,
 *  this key might be scope and the key value might be the zone name. Other
 *  examples might be a key indicating a deprecated resource and a suggested
 *  replacement.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Warnings_Data *data;

/** Output only. A human-readable description of the warning code. */
@property(nonatomic, copy, nullable) NSString *warningMessage;

@end


/**
 *  Output only. Metadata about this warning in key: value format. The key
 *  should provides more detail on the warning being returned. For example, for
 *  warnings where there are no results in a list request for a particular zone,
 *  this key might be scope and the key value might be the zone name. Other
 *  examples might be a key indicating a deprecated resource and a suggested
 *  replacement.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Warnings_Data : GTLRObject
@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
