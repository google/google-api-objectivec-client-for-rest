// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Network Connectivity API (networkconnectivity/v1)
// Description:
//   This API enables connectivity with and between Google Cloud resources.
// Documentation:
//   https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRNetworkconnectivity_AllocationOptions;
@class GTLRNetworkconnectivity_AuditConfig;
@class GTLRNetworkconnectivity_AuditLogConfig;
@class GTLRNetworkconnectivity_AutoAccept;
@class GTLRNetworkconnectivity_AutoCreatedSubnetworkInfo;
@class GTLRNetworkconnectivity_Binding;
@class GTLRNetworkconnectivity_ConsumerPscConfig;
@class GTLRNetworkconnectivity_ConsumerPscConfig_ProducerInstanceMetadata;
@class GTLRNetworkconnectivity_ConsumerPscConfig_ServiceAttachmentIpAddressMap;
@class GTLRNetworkconnectivity_ConsumerPscConnection;
@class GTLRNetworkconnectivity_ConsumerPscConnection_ProducerInstanceMetadata;
@class GTLRNetworkconnectivity_Destination;
@class GTLRNetworkconnectivity_Destination_Labels;
@class GTLRNetworkconnectivity_DestinationEndpoint;
@class GTLRNetworkconnectivity_Expr;
@class GTLRNetworkconnectivity_Filter;
@class GTLRNetworkconnectivity_GoogleLongrunningOperation;
@class GTLRNetworkconnectivity_GoogleLongrunningOperation_Metadata;
@class GTLRNetworkconnectivity_GoogleLongrunningOperation_Response;
@class GTLRNetworkconnectivity_GoogleRpcErrorInfo;
@class GTLRNetworkconnectivity_GoogleRpcErrorInfo_Metadata;
@class GTLRNetworkconnectivity_GoogleRpcStatus;
@class GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item;
@class GTLRNetworkconnectivity_Group;
@class GTLRNetworkconnectivity_Group_Labels;
@class GTLRNetworkconnectivity_Hub;
@class GTLRNetworkconnectivity_Hub_Labels;
@class GTLRNetworkconnectivity_HubStatusEntry;
@class GTLRNetworkconnectivity_InterconnectAttachment;
@class GTLRNetworkconnectivity_InternalRange;
@class GTLRNetworkconnectivity_InternalRange_Labels;
@class GTLRNetworkconnectivity_LinkedInterconnectAttachments;
@class GTLRNetworkconnectivity_LinkedProducerVpcNetwork;
@class GTLRNetworkconnectivity_LinkedRouterApplianceInstances;
@class GTLRNetworkconnectivity_LinkedVpcNetwork;
@class GTLRNetworkconnectivity_LinkedVpnTunnels;
@class GTLRNetworkconnectivity_Location;
@class GTLRNetworkconnectivity_Location_Labels;
@class GTLRNetworkconnectivity_Location_Metadata;
@class GTLRNetworkconnectivity_Migration;
@class GTLRNetworkconnectivity_MulticloudDataTransferConfig;
@class GTLRNetworkconnectivity_MulticloudDataTransferConfig_Labels;
@class GTLRNetworkconnectivity_MulticloudDataTransferConfig_Services;
@class GTLRNetworkconnectivity_MulticloudDataTransferSupportedService;
@class GTLRNetworkconnectivity_NextHopInterconnectAttachment;
@class GTLRNetworkconnectivity_NextHopRouterApplianceInstance;
@class GTLRNetworkconnectivity_NextHopSpoke;
@class GTLRNetworkconnectivity_NextHopVpcNetwork;
@class GTLRNetworkconnectivity_NextHopVPNTunnel;
@class GTLRNetworkconnectivity_Policy;
@class GTLRNetworkconnectivity_PolicyBasedRoute;
@class GTLRNetworkconnectivity_PolicyBasedRoute_Labels;
@class GTLRNetworkconnectivity_ProducerPscConfig;
@class GTLRNetworkconnectivity_PscConfig;
@class GTLRNetworkconnectivity_PscConnection;
@class GTLRNetworkconnectivity_PscConnection_ProducerInstanceMetadata;
@class GTLRNetworkconnectivity_PscPropagationStatus;
@class GTLRNetworkconnectivity_RegionalEndpoint;
@class GTLRNetworkconnectivity_RegionalEndpoint_Labels;
@class GTLRNetworkconnectivity_RemoteTransportProfile;
@class GTLRNetworkconnectivity_RemoteTransportProfile_Labels;
@class GTLRNetworkconnectivity_Route;
@class GTLRNetworkconnectivity_Route_Labels;
@class GTLRNetworkconnectivity_RouterApplianceInstance;
@class GTLRNetworkconnectivity_RouteTable;
@class GTLRNetworkconnectivity_RouteTable_Labels;
@class GTLRNetworkconnectivity_RoutingVPC;
@class GTLRNetworkconnectivity_ServiceClass;
@class GTLRNetworkconnectivity_ServiceClass_Labels;
@class GTLRNetworkconnectivity_ServiceConfig;
@class GTLRNetworkconnectivity_ServiceConnectionMap;
@class GTLRNetworkconnectivity_ServiceConnectionMap_Labels;
@class GTLRNetworkconnectivity_ServiceConnectionPolicy;
@class GTLRNetworkconnectivity_ServiceConnectionPolicy_Labels;
@class GTLRNetworkconnectivity_ServiceConnectionToken;
@class GTLRNetworkconnectivity_ServiceConnectionToken_Labels;
@class GTLRNetworkconnectivity_Spoke;
@class GTLRNetworkconnectivity_Spoke_Labels;
@class GTLRNetworkconnectivity_SpokeStateCount;
@class GTLRNetworkconnectivity_SpokeStateReasonCount;
@class GTLRNetworkconnectivity_SpokeSummary;
@class GTLRNetworkconnectivity_SpokeTypeCount;
@class GTLRNetworkconnectivity_StateMetadata;
@class GTLRNetworkconnectivity_StateReason;
@class GTLRNetworkconnectivity_StateTimeline;
@class GTLRNetworkconnectivity_Transport;
@class GTLRNetworkconnectivity_Transport_Labels;
@class GTLRNetworkconnectivity_VirtualMachine;
@class GTLRNetworkconnectivity_Warnings;
@class GTLRNetworkconnectivity_Warnings_Data;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_AllocationOptions.allocationStrategy

/**
 *  Unspecified is the only valid option when the range is specified explicitly
 *  by ip_cidr_range field. Otherwise unspefified means using the default
 *  strategy.
 *
 *  Value: "ALLOCATION_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_AllocationStrategyUnspecified;
/**
 *  Pick the first available address range. This strategy is deterministic and
 *  the result is easy to predict.
 *
 *  Value: "FIRST_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_FirstAvailable;
/**
 *  Pick the smallest but fitting available range. This deterministic strategy
 *  minimizes fragmentation of the address space.
 *
 *  Value: "FIRST_SMALLEST_FITTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_FirstSmallestFitting;
/**
 *  Random strategy, the legacy algorithm, used for backwards compatibility.
 *  This allocation strategy remains efficient in the case of concurrent
 *  allocation requests in the same peered network space and doesn't require
 *  providing the level of concurrency in an explicit parameter, but it is prone
 *  to fragmenting available address space.
 *
 *  Value: "RANDOM"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_Random;
/**
 *  Pick an arbitrary range out of the first N available ones. The N will be set
 *  in the first_available_ranges_lookup_size field. This strategy should be
 *  used when concurrent allocation requests are made in the same space of
 *  peered networks while the fragmentation of the addrress space is reduced.
 *
 *  Value: "RANDOM_FIRST_N_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_RandomFirstNAvailable;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConfig.ipVersion

/**
 *  Will use IPv4 only.
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_IpVersion_Ipv4;
/**
 *  Will use IPv6 only.
 *
 *  Value: "IPV6"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_IpVersion_Ipv6;
/**
 *  Default value. We will use IPv4 or IPv6 depending on the IP version of first
 *  available subnetwork.
 *
 *  Value: "IP_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_IpVersion_IpVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConfig.state

/**
 *  No Service Connection Policy found for this network and Service Class
 *
 *  Value: "CONNECTION_POLICY_MISSING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConnectionPolicyMissing;
/**
 *  The consumer instance project is not in
 *  AllowedGoogleProducersResourceHierarchyLevels of the matching
 *  ServiceConnectionPolicy.
 *
 *  Value: "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConsumerInstanceProjectNotAllowlisted;
/**
 *  Service Connection Policy limit reached for this network and Service Class
 *
 *  Value: "POLICY_LIMIT_REACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_PolicyLimitReached;
/**
 *  Default state, when Connection Map is created initially.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_StateUnspecified;
/**
 *  Set when policy and map configuration is valid, and their matching can lead
 *  to allowing creation of PSC Connections subject to other constraints like
 *  connections limit.
 *
 *  Value: "VALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConfig_State_Valid;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConnection.errorType

/**
 *  An invalid error type as the default case.
 *
 *  Value: "CONNECTION_ERROR_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ConnectionErrorTypeUnspecified;
/**
 *  The error is due to the setup on consumer side.
 *
 *  Value: "ERROR_CONSUMER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorConsumerSide;
/**
 *  The error is due to Service Automation system internal.
 *
 *  Value: "ERROR_INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorInternal;
/**
 *  The error is due to the setup on producer side.
 *
 *  Value: "ERROR_PRODUCER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorProducerSide;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConnection.ipVersion

/**
 *  Will use IPv4 only.
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_IpVersion_Ipv4;
/**
 *  Will use IPv6 only.
 *
 *  Value: "IPV6"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_IpVersion_Ipv6;
/**
 *  Default value. We will use IPv4 or IPv6 depending on the IP version of first
 *  available subnetwork.
 *
 *  Value: "IP_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_IpVersion_IpVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ConsumerPscConnection.state

/**
 *  The connection has been created successfully. However, for the up-to-date
 *  connection status, please use the service attachment's
 *  "ConnectedEndpoint.status" as the source of truth.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Active;
/**
 *  The connection is being repaired to complete creation.
 *
 *  Value: "CREATE_REPAIRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_CreateRepairing;
/**
 *  The connection is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Creating;
/**
 *  The connection is being repaired to complete deletion.
 *
 *  Value: "DELETE_REPAIRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_DeleteRepairing;
/**
 *  The connection is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Deleting;
/**
 *  The connection is not functional since some resources on the connection fail
 *  to be created.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_Failed;
/**
 *  An invalid state as the default case.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ConsumerPscConnection_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_DestinationEndpoint.state

/**
 *  The `DestinationEndpoint` resource is invalid.
 *
 *  Value: "INVALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_DestinationEndpoint_State_Invalid;
/**
 *  An invalid state, which is the default case.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_DestinationEndpoint_State_StateUnspecified;
/**
 *  The `DestinationEndpoint` resource is valid.
 *
 *  Value: "VALID"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_DestinationEndpoint_State_Valid;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Filter.protocolVersion

/**
 *  The PBR is for IPv4 internet protocol traffic.
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Filter_ProtocolVersion_Ipv4;
/**
 *  The PBR is for IPv6 internet protocol traffic.
 *
 *  Value: "IPV6"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Filter_ProtocolVersion_Ipv6;
/**
 *  Default value.
 *
 *  Value: "PROTOCOL_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Filter_ProtocolVersion_ProtocolVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Group.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Deleting;
/**
 *  The resource is in an undefined state due to resource creation or deletion
 *  failure. You can try to delete the resource later or contact support for
 *  help.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Failed;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Group_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Hub.policyMode

/**
 *  Policy mode is unspecified. It defaults to PRESET with preset_topology =
 *  MESH.
 *
 *  Value: "POLICY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PolicyMode_PolicyModeUnspecified;
/**
 *  Hub uses one of the preset topologies.
 *
 *  Value: "PRESET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PolicyMode_Preset;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Hub.presetTopology

/**
 *  Mesh topology is implemented. Group `default` is automatically created. All
 *  spokes in the hub are added to group `default`.
 *
 *  Value: "MESH"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PresetTopology_Mesh;
/**
 *  Preset topology is unspecified. When policy_mode = PRESET, it defaults to
 *  MESH.
 *
 *  Value: "PRESET_TOPOLOGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PresetTopology_PresetTopologyUnspecified;
/**
 *  Star topology is implemented. Two groups, `center` and `edge`, are
 *  automatically created along with hub creation. Spokes have to join one of
 *  the groups during creation.
 *
 *  Value: "STAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_PresetTopology_Star;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Hub.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Deleting;
/**
 *  The resource is in an undefined state due to resource creation or deletion
 *  failure. You can try to delete the resource later or contact support for
 *  help.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Failed;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Hub_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_InternalRange.overlaps

/**
 *  Allow creation of internal ranges that overlap with existing subnets.
 *
 *  Value: "OVERLAP_EXISTING_SUBNET_RANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Overlaps_OverlapExistingSubnetRange;
/**
 *  Allow creation of static routes more specific that the current internal
 *  range.
 *
 *  Value: "OVERLAP_ROUTE_RANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Overlaps_OverlapRouteRange;
/**
 *  No overlap overrides.
 *
 *  Value: "OVERLAP_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Overlaps_OverlapUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_InternalRange.peering

/**
 *  This behavior can be set when the internal range is being reserved for usage
 *  by peers. This means that no resource within the VPC in which it is being
 *  created can use this to associate with a VPC resource, but one of the peers
 *  can. This represents donating a range for peers to use.
 *
 *  Value: "FOR_PEER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_ForPeer;
/**
 *  This is the default behavior and represents the case that this internal
 *  range is intended to be used in the VPC in which it is created and is
 *  accessible from its peers. This implies that peers or peers-of-peers cannot
 *  use this range.
 *
 *  Value: "FOR_SELF"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_ForSelf;
/**
 *  This behavior can be set when the internal range is being reserved for usage
 *  by the VPC in which it is created, but not shared with peers. In a sense, it
 *  is local to the VPC. This can be used to create internal ranges for various
 *  purposes like HTTP_INTERNAL_LOAD_BALANCER or for Interconnect routes that
 *  are not shared with peers. This also implies that peers cannot use this
 *  range in a way that is visible to this VPC, but can re-use this range as
 *  long as it is NOT_SHARED from the peer VPC, too.
 *
 *  Value: "NOT_SHARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_NotShared;
/**
 *  If Peering is left unspecified in CreateInternalRange or
 *  UpdateInternalRange, it will be defaulted to FOR_SELF.
 *
 *  Value: "PEERING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Peering_PeeringUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_InternalRange.usage

/**
 *  Ranges created with EXTERNAL_TO_VPC cannot be associated with VPC resources
 *  and are meant to block out address ranges for various use cases, like for
 *  example, usage on-prem, with dynamic route announcements via interconnect.
 *
 *  Value: "EXTERNAL_TO_VPC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_ExternalToVpc;
/**
 *  Ranges created FOR_MIGRATION can be used to lock a CIDR range between a
 *  source and target subnet. If usage is set to FOR_MIGRATION, the peering
 *  value has to be set to FOR_SELF or default to FOR_SELF when unset.
 *
 *  Value: "FOR_MIGRATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_ForMigration;
/**
 *  A VPC resource can use the reserved CIDR block by associating it with the
 *  internal range resource if usage is set to FOR_VPC.
 *
 *  Value: "FOR_VPC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_ForVpc;
/**
 *  Unspecified usage is allowed in calls which identify the resource by other
 *  fields and do not need Usage set to complete. These are, i.e.:
 *  GetInternalRange and DeleteInternalRange. Usage needs to be specified
 *  explicitly in CreateInternalRange or UpdateInternalRange calls.
 *
 *  Value: "USAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_InternalRange_Usage_UsageUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_LocationMetadata.locationFeatures

/**
 *  Gateway spokes are supported in this location.
 *
 *  Value: "GATEWAY_SPOKES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_GatewaySpokes;
/**
 *  No publicly supported feature in this location
 *
 *  Value: "LOCATION_FEATURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_LocationFeatureUnspecified;
/**
 *  Site-to-cloud spokes are supported in this location
 *
 *  Value: "SITE_TO_CLOUD_SPOKES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_SiteToCloudSpokes;
/**
 *  Site-to-site spokes are supported in this location
 *
 *  Value: "SITE_TO_SITE_SPOKES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_LocationMetadata_LocationFeatures_SiteToSiteSpokes;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PolicyBasedRoute.nextHopOtherRoutes

/**
 *  Use the routes from the default routing tables (system-generated routes,
 *  custom routes, peering route) to determine the next hop. This effectively
 *  excludes matching packets being applied on other PBRs with a lower priority.
 *
 *  Value: "DEFAULT_ROUTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_DefaultRouting;
/**
 *  Default value.
 *
 *  Value: "OTHER_ROUTES_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_OtherRoutesUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConfig.producerInstanceLocation

/**
 *  Producer instance must be within one of the values provided in
 *  allowed_google_producers_resource_hierarchy_level.
 *
 *  Value: "CUSTOM_RESOURCE_HIERARCHY_LEVELS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_CustomResourceHierarchyLevels;
/**
 *  Producer instance location is not specified. When this option is chosen,
 *  then the PSC connections created by this ServiceConnectionPolicy must be
 *  within the same project as the Producer instance. This is the default
 *  ProducerInstanceLocation value. To allow for PSC connections from this
 *  network to other networks, use the CUSTOM_RESOURCE_HIERARCHY_LEVELS option.
 *
 *  Value: "PRODUCER_INSTANCE_LOCATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_ProducerInstanceLocationUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConnection.errorType

/**
 *  An invalid error type as the default case.
 *
 *  Value: "CONNECTION_ERROR_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ConnectionErrorTypeUnspecified;
/**
 *  The error is due to the setup on consumer side.
 *
 *  Value: "ERROR_CONSUMER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorConsumerSide;
/**
 *  The error is due to Service Automation system internal.
 *
 *  Value: "ERROR_INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorInternal;
/**
 *  The error is due to the setup on producer side.
 *
 *  Value: "ERROR_PRODUCER_SIDE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorProducerSide;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConnection.ipVersion

/**
 *  Will use IPv4 only.
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_IpVersion_Ipv4;
/**
 *  Will use IPv6 only.
 *
 *  Value: "IPV6"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_IpVersion_Ipv6;
/**
 *  Default value. We will use IPv4 or IPv6 depending on the IP version of first
 *  available subnetwork.
 *
 *  Value: "IP_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_IpVersion_IpVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscConnection.state

/**
 *  The connection has been created successfully. However, for the up-to-date
 *  connection status, please use the created forwarding rule's
 *  "PscConnectionStatus" as the source of truth.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Active;
/**
 *  The connection is being repaired to complete creation.
 *
 *  Value: "CREATE_REPAIRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_CreateRepairing;
/**
 *  The connection is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Creating;
/**
 *  The connection is being repaired to complete deletion.
 *
 *  Value: "DELETE_REPAIRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_DeleteRepairing;
/**
 *  The connection is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Deleting;
/**
 *  The connection is not functional since some resources on the connection fail
 *  to be created.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_Failed;
/**
 *  An invalid state as the default case.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscConnection_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_PscPropagationStatus.code

/**
 *  The code is unspecified.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_CodeUnspecified;
/**
 *  The Private Service Connect connection propagation failed because the
 *  `PSC_PROPAGATED_CONNECTIONS_PER_VPC_NETWORK` quota in the consumer VPC
 *  network has been exceeded.
 *
 *  Value: "ERROR_CONSUMER_QUOTA_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorConsumerQuotaExceeded;
/**
 *  The Private Service Connect connection propagation failed because the NAT IP
 *  subnet space has been exhausted. It is equivalent to the `Needs attention`
 *  status of the Private Service Connect connection. See
 *  https://cloud.google.com/vpc/docs/about-accessing-vpc-hosted-services-endpoints#connection-statuses.
 *
 *  Value: "ERROR_PRODUCER_NAT_IP_SPACE_EXHAUSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorProducerNatIpSpaceExhausted;
/**
 *  The Private Service Connect connection propagation failed because the VPC
 *  network or the project of the target spoke has exceeded the connection limit
 *  set by the producer.
 *
 *  Value: "ERROR_PRODUCER_PROPAGATED_CONNECTION_LIMIT_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorProducerPropagatedConnectionLimitExceeded;
/**
 *  The Private Service Connect connection propagation failed because the
 *  `PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK` quota in the
 *  producer VPC network has been exceeded.
 *
 *  Value: "ERROR_PRODUCER_QUOTA_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorProducerQuotaExceeded;
/**
 *  The Private Service Connect connection is propagating. This is a transient
 *  state.
 *
 *  Value: "PROPAGATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_Propagating;
/**
 *  The propagated Private Service Connect connection is ready.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_PscPropagationStatus_Code_Ready;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_RegionalEndpoint.accessType

/**
 *  An invalid type as the default case.
 *
 *  Value: "ACCESS_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_AccessTypeUnspecified;
/**
 *  This regional endpoint is accessible from all regions.
 *
 *  Value: "GLOBAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Global;
/**
 *  This regional endpoint is only accessible from the same region where it
 *  resides.
 *
 *  Value: "REGIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Regional;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Route.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Deleting;
/**
 *  The resource is in an undefined state due to resource creation or deletion
 *  failure. You can try to delete the resource later or contact support for
 *  help.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Failed;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Route.type

/**
 *  The route leads to a destination in a dynamic route. Dynamic routes are
 *  derived from Border Gateway Protocol (BGP) advertisements received from an
 *  NCC hybrid spoke.
 *
 *  Value: "DYNAMIC_ROUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_DynamicRoute;
/**
 *  No route type information specified
 *
 *  Value: "ROUTE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_RouteTypeUnspecified;
/**
 *  The route leads to a destination within the primary address range of the VPC
 *  network's subnet.
 *
 *  Value: "VPC_PRIMARY_SUBNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_VpcPrimarySubnet;
/**
 *  The route leads to a destination within the secondary address range of the
 *  VPC network's subnet.
 *
 *  Value: "VPC_SECONDARY_SUBNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Route_Type_VpcSecondarySubnet;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_RouteTable.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Deleting;
/**
 *  The resource is in an undefined state due to resource creation or deletion
 *  failure. You can try to delete the resource later or contact support for
 *  help.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Failed;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_RouteTable_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ServiceConfig.eligibilityCriteria

/**
 *  The service is not eligible for Data Transfer Essentials configuration. This
 *  is the default case.
 *
 *  Value: "ELIGIBILITY_CRITERIA_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_EligibilityCriteriaUnspecified;
/**
 *  The service is eligible for Data Transfer Essentials configuration only for
 *  Premium Tier.
 *
 *  Value: "NETWORK_SERVICE_TIER_PREMIUM_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_NetworkServiceTierPremiumOnly;
/**
 *  The service is eligible for Data Transfer Essentials configuration only for
 *  Standard Tier.
 *
 *  Value: "NETWORK_SERVICE_TIER_STANDARD_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_NetworkServiceTierStandardOnly;
/**
 *  The service is eligible for Data Transfer Essentials configuration only for
 *  the regional endpoint.
 *
 *  Value: "REQUEST_ENDPOINT_REGIONAL_ENDPOINT_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_RequestEndpointRegionalEndpointOnly;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ServiceConnectionMap.infrastructure

/**
 *  An invalid infrastructure as the default case.
 *
 *  Value: "INFRASTRUCTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_InfrastructureUnspecified;
/**
 *  Private Service Connect is used for connections.
 *
 *  Value: "PSC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_Psc;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_ServiceConnectionPolicy.infrastructure

/**
 *  An invalid infrastructure as the default case.
 *
 *  Value: "INFRASTRUCTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_InfrastructureUnspecified;
/**
 *  Private Service Connect is used for connections.
 *
 *  Value: "PSC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_Psc;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Spoke.spokeType

/**
 *  Spokes associated with VLAN attachments.
 *
 *  Value: "INTERCONNECT_ATTACHMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_InterconnectAttachment;
/**
 *  Spokes that are backed by a producer VPC network.
 *
 *  Value: "PRODUCER_VPC_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_ProducerVpcNetwork;
/**
 *  Spokes associated with router appliance instances.
 *
 *  Value: "ROUTER_APPLIANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_RouterAppliance;
/**
 *  Unspecified spoke type.
 *
 *  Value: "SPOKE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_SpokeTypeUnspecified;
/**
 *  Spokes associated with VPC networks.
 *
 *  Value: "VPC_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_VpcNetwork;
/**
 *  Spokes associated with VPN tunnels.
 *
 *  Value: "VPN_TUNNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_SpokeType_VpnTunnel;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Spoke.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Deleting;
/**
 *  The resource is in an undefined state due to resource creation or deletion
 *  failure. You can try to delete the resource later or contact support for
 *  help.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Failed;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Spoke_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_SpokeStateCount.state

/**
 *  The resource's accept operation is in progress.
 *
 *  Value: "ACCEPTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Accepting;
/**
 *  The resource is active
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Active;
/**
 *  The resource's create operation is in progress.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Creating;
/**
 *  The resource's delete operation is in progress.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Deleting;
/**
 *  The resource is in an undefined state due to resource creation or deletion
 *  failure. You can try to delete the resource later or contact support for
 *  help.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Failed;
/**
 *  The resource is inactive.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Inactive;
/**
 *  The hub associated with this spoke resource has been deleted. This state
 *  applies to spoke resources only.
 *
 *  Value: "OBSOLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Obsolete;
/**
 *  The resource's reject operation is in progress.
 *
 *  Value: "REJECTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Rejecting;
/**
 *  No state information available
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_StateUnspecified;
/**
 *  The resource's update operation is in progress.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateCount_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_SpokeStateReasonCount.stateReasonCode

/**
 *  No information available.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_CodeUnspecified;
/**
 *  Network Connectivity Center encountered errors while accepting the spoke.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Failed;
/**
 *  The spoke has been deactivated internally.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Paused;
/**
 *  The proposed spoke is pending review.
 *
 *  Value: "PENDING_REVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_PendingReview;
/**
 *  The proposed spoke has been rejected by the hub administrator.
 *
 *  Value: "REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Rejected;
/**
 *  Network Connectivity Center encountered errors while accepting the spoke
 *  update.
 *
 *  Value: "UPDATE_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_UpdateFailed;
/**
 *  The proposed spoke update is pending review.
 *
 *  Value: "UPDATE_PENDING_REVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_UpdatePendingReview;
/**
 *  The proposed spoke update has been rejected by the hub administrator.
 *
 *  Value: "UPDATE_REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_UpdateRejected;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_SpokeTypeCount.spokeType

/**
 *  Spokes associated with VLAN attachments.
 *
 *  Value: "INTERCONNECT_ATTACHMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_InterconnectAttachment;
/**
 *  Spokes that are backed by a producer VPC network.
 *
 *  Value: "PRODUCER_VPC_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_ProducerVpcNetwork;
/**
 *  Spokes associated with router appliance instances.
 *
 *  Value: "ROUTER_APPLIANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_RouterAppliance;
/**
 *  Unspecified spoke type.
 *
 *  Value: "SPOKE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_SpokeTypeUnspecified;
/**
 *  Spokes associated with VPC networks.
 *
 *  Value: "VPC_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpcNetwork;
/**
 *  Spokes associated with VPN tunnels.
 *
 *  Value: "VPN_TUNNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpnTunnel;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_StateMetadata.state

/**
 *  The resource is in use.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateMetadata_State_Active;
/**
 *  The resource is being added.
 *
 *  Value: "ADDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateMetadata_State_Adding;
/**
 *  The resource is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateMetadata_State_Deleting;
/**
 *  An invalid state, which is the default case.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateMetadata_State_StateUnspecified;
/**
 *  The resource is suspended and not in use.
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateMetadata_State_Suspended;
/**
 *  The resource is being suspended.
 *
 *  Value: "SUSPENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateMetadata_State_Suspending;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_StateReason.code

/**
 *  No information available.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_CodeUnspecified;
/**
 *  Network Connectivity Center encountered errors while accepting the spoke.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_Failed;
/**
 *  The spoke has been deactivated internally.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_Paused;
/**
 *  The proposed spoke is pending review.
 *
 *  Value: "PENDING_REVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_PendingReview;
/**
 *  The proposed spoke has been rejected by the hub administrator.
 *
 *  Value: "REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_Rejected;
/**
 *  Network Connectivity Center encountered errors while accepting the spoke
 *  update.
 *
 *  Value: "UPDATE_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_UpdateFailed;
/**
 *  The proposed spoke update is pending review.
 *
 *  Value: "UPDATE_PENDING_REVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_UpdatePendingReview;
/**
 *  The proposed spoke update has been rejected by the hub administrator.
 *
 *  Value: "UPDATE_REJECTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_StateReason_Code_UpdateRejected;

// ----------------------------------------------------------------------------
// GTLRNetworkconnectivity_Warnings.code

/**
 *  The policy-based route is being modified (e.g. created/deleted) at this
 *  time.
 *
 *  Value: "RESOURCE_BEING_MODIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Warnings_Code_ResourceBeingModified;
/**
 *  The policy-based route is not active and functioning. Common causes are that
 *  the dependent network was deleted or the resource project was turned off.
 *
 *  Value: "RESOURCE_NOT_ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Warnings_Code_ResourceNotActive;
/**
 *  Default value.
 *
 *  Value: "WARNING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkconnectivity_Warnings_Code_WarningUnspecified;

/**
 *  The request for HubService.AcceptHubSpoke.
 */
@interface GTLRNetworkconnectivity_AcceptHubSpokeRequest : GTLRObject

/**
 *  Optional. A request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server knows to ignore the request
 *  if it has already been completed. The server guarantees that a request
 *  doesn't result in creation of duplicate commitments for at least 60 minutes.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check to see whether the original operation was received. If
 *  it was, the server ignores the second request. This behavior prevents
 *  clients from mistakenly creating duplicate commitments. The request ID must
 *  be a valid UUID, with the exception that zero UUID is not supported
 *  (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Required. The URI of the spoke to accept into the hub. */
@property(nonatomic, copy, nullable) NSString *spokeUri;

@end


/**
 *  The response for HubService.AcceptHubSpoke.
 */
@interface GTLRNetworkconnectivity_AcceptHubSpokeResponse : GTLRObject

/** The spoke that was operated on. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Spoke *spoke;

@end


/**
 *  The request for HubService.AcceptSpokeUpdate.
 */
@interface GTLRNetworkconnectivity_AcceptSpokeUpdateRequest : GTLRObject

/**
 *  Optional. A request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server knows to ignore the request
 *  if it has already been completed. The server guarantees that a request
 *  doesn't result in creation of duplicate commitments for at least 60 minutes.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check to see whether the original operation was received. If
 *  it was, the server ignores the second request. This behavior prevents
 *  clients from mistakenly creating duplicate commitments. The request ID must
 *  be a valid UUID, with the exception that zero UUID is not supported
 *  (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Required. The etag of the spoke to accept update. */
@property(nonatomic, copy, nullable) NSString *spokeEtag;

/** Required. The URI of the spoke to accept update. */
@property(nonatomic, copy, nullable) NSString *spokeUri;

@end


/**
 *  Range auto-allocation options, to be optionally used when CIDR block is not
 *  explicitly set.
 */
@interface GTLRNetworkconnectivity_AllocationOptions : GTLRObject

/**
 *  Optional. Allocation strategy Not setting this field when the allocation is
 *  requested means an implementation defined strategy is used.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_AllocationStrategyUnspecified
 *        Unspecified is the only valid option when the range is specified
 *        explicitly by ip_cidr_range field. Otherwise unspefified means using
 *        the default strategy. (Value: "ALLOCATION_STRATEGY_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_FirstAvailable
 *        Pick the first available address range. This strategy is deterministic
 *        and the result is easy to predict. (Value: "FIRST_AVAILABLE")
 *    @arg @c kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_FirstSmallestFitting
 *        Pick the smallest but fitting available range. This deterministic
 *        strategy minimizes fragmentation of the address space. (Value:
 *        "FIRST_SMALLEST_FITTING")
 *    @arg @c kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_Random
 *        Random strategy, the legacy algorithm, used for backwards
 *        compatibility. This allocation strategy remains efficient in the case
 *        of concurrent allocation requests in the same peered network space and
 *        doesn't require providing the level of concurrency in an explicit
 *        parameter, but it is prone to fragmenting available address space.
 *        (Value: "RANDOM")
 *    @arg @c kGTLRNetworkconnectivity_AllocationOptions_AllocationStrategy_RandomFirstNAvailable
 *        Pick an arbitrary range out of the first N available ones. The N will
 *        be set in the first_available_ranges_lookup_size field. This strategy
 *        should be used when concurrent allocation requests are made in the
 *        same space of peered networks while the fragmentation of the addrress
 *        space is reduced. (Value: "RANDOM_FIRST_N_AVAILABLE")
 */
@property(nonatomic, copy, nullable) NSString *allocationStrategy;

/**
 *  Optional. This field must be set only when allocation_strategy is set to
 *  RANDOM_FIRST_N_AVAILABLE. The value should be the maximum expected
 *  parallelism of range creation requests issued to the same space of peered
 *  netwroks.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *firstAvailableRangesLookupSize;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRNetworkconnectivity_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRNetworkconnectivity_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_AdminRead Admin
 *        reads. Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataRead Data
 *        reads. Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_DataWrite Data
 *        writes. Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRNetworkconnectivity_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  The auto-accept setting for a group controls whether proposed spokes are
 *  automatically attached to the hub. If auto-accept is enabled, the spoke
 *  immediately is attached to the hub and becomes part of the group. In this
 *  case, the new spoke is in the ACTIVE state. If auto-accept is disabled, the
 *  spoke goes to the INACTIVE state, and it must be reviewed and accepted by a
 *  hub administrator.
 */
@interface GTLRNetworkconnectivity_AutoAccept : GTLRObject

/**
 *  Optional. A list of project ids or project numbers for which you want to
 *  enable auto-accept. The auto-accept setting is applied to spokes being
 *  created or updated in these projects.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *autoAcceptProjects;

@end


/**
 *  Information for the automatically created subnetwork and its associated IR.
 */
@interface GTLRNetworkconnectivity_AutoCreatedSubnetworkInfo : GTLRObject

/**
 *  Output only. URI of the automatically created Internal Range. Only set if
 *  the subnetwork mode is AUTO_CREATED during creation.
 */
@property(nonatomic, copy, nullable) NSString *internalRange;

/**
 *  Output only. URI of the automatically created Internal Range reference. Only
 *  set if the subnetwork mode is AUTO_CREATED during creation.
 */
@property(nonatomic, copy, nullable) NSString *internalRangeRef;

/**
 *  Output only. URI of the automatically created subnetwork. Only set if the
 *  subnetwork mode is AUTO_CREATED during creation.
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Output only. URI of the automatically created subnetwork reference. Only set
 *  if the subnetwork mode is AUTO_CREATED during creation.
 */
@property(nonatomic, copy, nullable) NSString *subnetworkRef;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRNetworkconnectivity_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `domain:{domain}`: The G Suite domain
 *  (primary) that represents all the users of that domain. For example,
 *  `google.com` or `example.com`. *
 *  `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workforce identity pool. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
 *  All workforce identities in a group. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All workforce identities with a specific attribute value. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/
 *  *`: All identities in a workforce identity pool. *
 *  `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workload identity pool. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
 *  A workload identity pool group. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All identities in a workload identity pool with a certain attribute. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/
 *  *`: All identities in a workload identity pool. *
 *  `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. *
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  Deleted single identity in a workforce identity pool. For example,
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM
 *  roles and permissions, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/roles-overview). For a list
 *  of the available pre-defined roles, see
 *  [here](https://cloud.google.com/iam/docs/understanding-roles).
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Allow the producer to specify which consumers can connect to it.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConfig : GTLRObject

/**
 *  Required. The project ID or project number of the consumer project. This
 *  project is the one that the consumer uses to interact with the producer
 *  instance. From the perspective of a consumer who's created a producer
 *  instance, this is the project of the producer instance. Format: 'projects/'
 *  Eg. 'projects/consumer-project' or 'projects/1234'
 */
@property(nonatomic, copy, nullable) NSString *consumerInstanceProject;

/**
 *  This is used in PSC consumer ForwardingRule to control whether the PSC
 *  endpoint can be accessed from another region.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableGlobalAccess;

/**
 *  The requested IP version for the PSC connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_IpVersion_Ipv4 Will use
 *        IPv4 only. (Value: "IPV4")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_IpVersion_Ipv6 Will use
 *        IPv6 only. (Value: "IPV6")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_IpVersion_IpVersionUnspecified
 *        Default value. We will use IPv4 or IPv6 depending on the IP version of
 *        first available subnetwork. (Value: "IP_VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *ipVersion;

/**
 *  The resource path of the consumer network where PSC connections are allowed
 *  to be created in. Note, this network does not need be in the
 *  ConsumerPscConfig.project in the case of SharedVPC. Example:
 *  projects/{projectNumOrId}/global/networks/{networkId}.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Immutable. Deprecated. Use producer_instance_metadata instead. An immutable
 *  identifier for the producer instance.
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceId GTLR_DEPRECATED;

/** Immutable. An immutable map for the producer instance metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ConsumerPscConfig_ProducerInstanceMetadata *producerInstanceMetadata;

/**
 *  The consumer project where PSC connections are allowed to be created in.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  Output only. A map to store mapping between customer vip and target service
 *  attachment. Only service attachment with producer specified ip addresses are
 *  stored here.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ConsumerPscConfig_ServiceAttachmentIpAddressMap *serviceAttachmentIpAddressMap;

/**
 *  Output only. Overall state of PSC Connections management for this consumer
 *  psc config.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConnectionPolicyMissing
 *        No Service Connection Policy found for this network and Service Class
 *        (Value: "CONNECTION_POLICY_MISSING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_ConsumerInstanceProjectNotAllowlisted
 *        The consumer instance project is not in
 *        AllowedGoogleProducersResourceHierarchyLevels of the matching
 *        ServiceConnectionPolicy. (Value:
 *        "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_PolicyLimitReached
 *        Service Connection Policy limit reached for this network and Service
 *        Class (Value: "POLICY_LIMIT_REACHED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_StateUnspecified
 *        Default state, when Connection Map is created initially. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConfig_State_Valid Set when
 *        policy and map configuration is valid, and their matching can lead to
 *        allowing creation of PSC Connections subject to other constraints like
 *        connections limit. (Value: "VALID")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Immutable. An immutable map for the producer instance metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConfig_ProducerInstanceMetadata : GTLRObject
@end


/**
 *  Output only. A map to store mapping between customer vip and target service
 *  attachment. Only service attachment with producer specified ip addresses are
 *  stored here.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConfig_ServiceAttachmentIpAddressMap : GTLRObject
@end


/**
 *  PSC connection details on consumer side.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConnection : GTLRObject

/** The most recent error during operating this connection. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcStatus *error GTLR_DEPRECATED;

/**
 *  Output only. The error info for the latest error during operating this
 *  connection.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcErrorInfo *errorInfo;

/**
 *  The error type indicates whether the error is consumer facing, producer
 *  facing or system internal.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ConnectionErrorTypeUnspecified
 *        An invalid error type as the default case. (Value:
 *        "CONNECTION_ERROR_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorConsumerSide
 *        The error is due to the setup on consumer side. (Value:
 *        "ERROR_CONSUMER_SIDE")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorInternal
 *        The error is due to Service Automation system internal. (Value:
 *        "ERROR_INTERNAL")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_ErrorType_ErrorProducerSide
 *        The error is due to the setup on producer side. (Value:
 *        "ERROR_PRODUCER_SIDE")
 */
@property(nonatomic, copy, nullable) NSString *errorType GTLR_DEPRECATED;

/**
 *  The URI of the consumer forwarding rule created. Example:
 *  projects/{projectNumOrId}/regions/us-east1/networks/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *forwardingRule;

/** The last Compute Engine operation to setup PSC connection. */
@property(nonatomic, copy, nullable) NSString *gceOperation;

/**
 *  The IP literal allocated on the consumer network for the PSC forwarding rule
 *  that is created to connect to the producer service attachment in this
 *  service connection map.
 */
@property(nonatomic, copy, nullable) NSString *ip;

/**
 *  The requested IP version for the PSC connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_IpVersion_Ipv4 Will
 *        use IPv4 only. (Value: "IPV4")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_IpVersion_Ipv6 Will
 *        use IPv6 only. (Value: "IPV6")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_IpVersion_IpVersionUnspecified
 *        Default value. We will use IPv4 or IPv6 depending on the IP version of
 *        first available subnetwork. (Value: "IP_VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *ipVersion;

/**
 *  The consumer network whose PSC forwarding rule is connected to the service
 *  attachments in this service connection map. Note that the network could be
 *  on a different project (shared VPC).
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Immutable. Deprecated. Use producer_instance_metadata instead. An immutable
 *  identifier for the producer instance.
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceId GTLR_DEPRECATED;

/** Immutable. An immutable map for the producer instance metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ConsumerPscConnection_ProducerInstanceMetadata *producerInstanceMetadata;

/**
 *  The consumer project whose PSC forwarding rule is connected to the service
 *  attachments in this service connection map.
 */
@property(nonatomic, copy, nullable) NSString *project;

/**
 *  The PSC connection id of the PSC forwarding rule connected to the service
 *  attachments in this service connection map.
 */
@property(nonatomic, copy, nullable) NSString *pscConnectionId;

/**
 *  Output only. The URI of the selected subnetwork selected to allocate IP
 *  address for this connection.
 */
@property(nonatomic, copy, nullable) NSString *selectedSubnetwork;

/**
 *  The URI of a service attachment which is the target of the PSC connection.
 */
@property(nonatomic, copy, nullable) NSString *serviceAttachmentUri;

/**
 *  The state of the PSC connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Active The
 *        connection has been created successfully. However, for the up-to-date
 *        connection status, please use the service attachment's
 *        "ConnectedEndpoint.status" as the source of truth. (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_CreateRepairing
 *        The connection is being repaired to complete creation. (Value:
 *        "CREATE_REPAIRING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Creating The
 *        connection is being created. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_DeleteRepairing
 *        The connection is being repaired to complete deletion. (Value:
 *        "DELETE_REPAIRING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Deleting The
 *        connection is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_Failed The
 *        connection is not functional since some resources on the connection
 *        fail to be created. (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_ConsumerPscConnection_State_StateUnspecified
 *        An invalid state as the default case. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Immutable. An immutable map for the producer instance metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ConsumerPscConnection_ProducerInstanceMetadata : GTLRObject
@end


/**
 *  The `Destination` resource. It specifies the IP prefix and the associated
 *  autonomous system numbers (ASN) that you want to include in a
 *  `MulticloudDataTransferConfig` resource.
 */
@interface GTLRNetworkconnectivity_Destination : GTLRObject

/** Output only. Time when the `Destination` resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. Unordered list. The list of `DestinationEndpoint` resources
 *  configured for the IP prefix.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_DestinationEndpoint *> *endpoints;

/**
 *  The etag is computed by the server, and might be sent with update and delete
 *  requests so that the client has an up-to-date value before proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Required. Immutable. The IP prefix that represents your workload on another
 *  CSP.
 */
@property(nonatomic, copy, nullable) NSString *ipPrefix;

/** Optional. User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Destination_Labels *labels;

/**
 *  Identifier. The name of the `Destination` resource. Format:
 *  `projects/{project}/locations/{location}/multicloudDataTransferConfigs/{multicloud_data_transfer_config}/destinations/{destination}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The timeline of the expected `Destination` states or the
 *  current rest state. If a state change is expected, the value is `ADDING`,
 *  `DELETING` or `SUSPENDING`, depending on the action specified. Example:
 *  "state_timeline": { "states": [ { // The time when the `Destination`
 *  resource will be activated. "effectiveTime": "2024-12-01T08:00:00Z",
 *  "state": "ADDING" }, { // The time when the `Destination` resource will be
 *  suspended. "effectiveTime": "2024-12-01T20:00:00Z", "state": "SUSPENDING" }
 *  ] }
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_StateTimeline *stateTimeline;

/**
 *  Output only. The Google-generated unique ID for the `Destination` resource.
 *  This value is unique across all `Destination` resources. If a resource is
 *  deleted and another with the same name is created, the new resource is
 *  assigned a different and unique ID.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. Time when the `Destination` resource was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Destination_Labels : GTLRObject
@end


/**
 *  The metadata for a `DestinationEndpoint` resource.
 */
@interface GTLRNetworkconnectivity_DestinationEndpoint : GTLRObject

/**
 *  Required. The ASN of the remote IP prefix.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *asn;

/** Required. The CSP of the remote IP prefix. */
@property(nonatomic, copy, nullable) NSString *csp;

/**
 *  Output only. The state of the `DestinationEndpoint` resource.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_DestinationEndpoint_State_Invalid The
 *        `DestinationEndpoint` resource is invalid. (Value: "INVALID")
 *    @arg @c kGTLRNetworkconnectivity_DestinationEndpoint_State_StateUnspecified
 *        An invalid state, which is the default case. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_DestinationEndpoint_State_Valid The
 *        `DestinationEndpoint` resource is valid. (Value: "VALID")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. Time when the `DestinationEndpoint` resource was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRNetworkconnectivity_Empty : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRNetworkconnectivity_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Filter matches L4 traffic.
 */
@interface GTLRNetworkconnectivity_Filter : GTLRObject

/**
 *  Optional. The destination IP range of outgoing packets that this
 *  policy-based route applies to. Default is "0.0.0.0/0" if protocol version is
 *  IPv4 and "::/0" if protocol version is IPv6.
 */
@property(nonatomic, copy, nullable) NSString *destRange;

/**
 *  Optional. The IP protocol that this policy-based route applies to. Valid
 *  values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
 */
@property(nonatomic, copy, nullable) NSString *ipProtocol;

/**
 *  Required. Internet protocol versions this policy-based route applies to.
 *  IPV4 and IPV6 is supported.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Filter_ProtocolVersion_Ipv4 The PBR is
 *        for IPv4 internet protocol traffic. (Value: "IPV4")
 *    @arg @c kGTLRNetworkconnectivity_Filter_ProtocolVersion_Ipv6 The PBR is
 *        for IPv6 internet protocol traffic. (Value: "IPV6")
 *    @arg @c kGTLRNetworkconnectivity_Filter_ProtocolVersion_ProtocolVersionUnspecified
 *        Default value. (Value: "PROTOCOL_VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *protocolVersion;

/**
 *  Optional. The source IP range of outgoing packets that this policy-based
 *  route applies to. Default is "0.0.0.0/0" if protocol version is IPv4 and
 *  "::/0" if protocol version is IPv6.
 */
@property(nonatomic, copy, nullable) NSString *srcRange;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningCancelOperationRequest : GTLRObject
@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_GoogleLongrunningOperation *> *operations;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningOperation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcStatus *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleLongrunningOperation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleLongrunningOperation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningOperation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleLongrunningOperation_Response : GTLRObject
@end


/**
 *  Describes the cause of the error with structured details. Example of an
 *  error when contacting the "pubsub.googleapis.com" API when it is not
 *  enabled: { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": {
 *  "resource": "projects/123", "service": "pubsub.googleapis.com" } } This
 *  response indicates that the pubsub.googleapis.com API is not enabled.
 *  Example of an error that is returned when attempting to create a Spanner
 *  instance in a region that is out of stock: { "reason": "STOCKOUT" "domain":
 *  "spanner.googleapis.com", "metadata": { "availableRegions":
 *  "us-central1,us-east2" } }
 */
@interface GTLRNetworkconnectivity_GoogleRpcErrorInfo : GTLRObject

/**
 *  The logical grouping to which the "reason" belongs. The error domain is
 *  typically the registered service name of the tool or product that generates
 *  the error. Example: "pubsub.googleapis.com". If the error is generated by
 *  some common infrastructure, the error domain must be a globally unique value
 *  that identifies the infrastructure. For Google API infrastructure, the error
 *  domain is "googleapis.com".
 */
@property(nonatomic, copy, nullable) NSString *domain;

/**
 *  Additional structured details about this error. Keys must match a regular
 *  expression of `a-z+` but should ideally be lowerCamelCase. Also, they must
 *  be limited to 64 characters in length. When identifying the current value of
 *  an exceeded limit, the units should be contained in the key, not the value.
 *  For example, rather than `{"instanceLimit": "100/request"}`, should be
 *  returned as, `{"instanceLimitPerRequest": "100"}`, if the client exceeds the
 *  number of instances that can be created in a single (batch) request.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcErrorInfo_Metadata *metadata;

/**
 *  The reason of the error. This is a constant value that identifies the
 *  proximate cause of the error. Error reasons are unique within a particular
 *  domain of errors. This should be at most 63 characters and match a regular
 *  expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
 */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  Additional structured details about this error. Keys must match a regular
 *  expression of `a-z+` but should ideally be lowerCamelCase. Also, they must
 *  be limited to 64 characters in length. When identifying the current value of
 *  an exceeded limit, the units should be contained in the key, not the value.
 *  For example, rather than `{"instanceLimit": "100/request"}`, should be
 *  returned as, `{"instanceLimitPerRequest": "100"}`, if the client exceeds the
 *  number of instances that can be created in a single (batch) request.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleRpcErrorInfo_Metadata : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRNetworkconnectivity_GoogleRpcStatus : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_GoogleRpcStatus_Details_Item : GTLRObject
@end


/**
 *  A group represents a subset of spokes attached to a hub.
 */
@interface GTLRNetworkconnectivity_Group : GTLRObject

/** Optional. The auto-accept setting for this group. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_AutoAccept *autoAccept;

/** Output only. The time the group was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. The description of the group.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. Labels in key-value pair format. For more information about
 *  labels, see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Group_Labels *labels;

/**
 *  Immutable. The name of the group. Group names must be unique. They use the
 *  following form:
 *  `projects/{project_number}/locations/global/hubs/{hub}/groups/{group_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The name of the route table that corresponds to this group.
 *  They use the following form:
 *  `projects/{project_number}/locations/global/hubs/{hub_id}/routeTables/{route_table_id}`
 */
@property(nonatomic, copy, nullable) NSString *routeTable;

/**
 *  Output only. The current lifecycle state of this group.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Failed The resource is in an
 *        undefined state due to resource creation or deletion failure. You can
 *        try to delete the resource later or contact support for help. (Value:
 *        "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Group_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the group. This value is unique
 *  across all group resources. If a group is deleted and another with the same
 *  name is created, the new route table is assigned a different unique_id.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time the group was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels in key-value pair format. For more information about
 *  labels, see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Group_Labels : GTLRObject
@end


/**
 *  A Network Connectivity Center hub is a global management resource to which
 *  you attach spokes. A single hub can contain spokes from multiple regions.
 *  However, if any of a hub's spokes use the site-to-site data transfer
 *  feature, the resources associated with those spokes must all be in the same
 *  VPC network. Spokes that do not use site-to-site data transfer can be
 *  associated with any VPC network in your project.
 */
@interface GTLRNetworkconnectivity_Hub : GTLRObject

/** Output only. The time the hub was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. An optional description of the hub.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. Whether Private Service Connect connection propagation is enabled
 *  for the hub. If true, Private Service Connect endpoints in VPC spokes
 *  attached to the hub are made accessible to other VPC spokes attached to the
 *  hub. The default value is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exportPsc;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Hub_Labels *labels;

/**
 *  Immutable. The name of the hub. Hub names must be unique. They use the
 *  following form: `projects/{project_number}/locations/global/hubs/{hub_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. The policy mode of this hub. This field can be either PRESET or
 *  CUSTOM. If unspecified, the policy_mode defaults to PRESET.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Hub_PolicyMode_PolicyModeUnspecified
 *        Policy mode is unspecified. It defaults to PRESET with preset_topology
 *        = MESH. (Value: "POLICY_MODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_PolicyMode_Preset Hub uses one of the
 *        preset topologies. (Value: "PRESET")
 */
@property(nonatomic, copy, nullable) NSString *policyMode;

/**
 *  Optional. The topology implemented in this hub. Currently, this field is
 *  only used when policy_mode = PRESET. The available preset topologies are
 *  MESH and STAR. If preset_topology is unspecified and policy_mode = PRESET,
 *  the preset_topology defaults to MESH. When policy_mode = CUSTOM, the
 *  preset_topology is set to PRESET_TOPOLOGY_UNSPECIFIED.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Hub_PresetTopology_Mesh Mesh topology is
 *        implemented. Group `default` is automatically created. All spokes in
 *        the hub are added to group `default`. (Value: "MESH")
 *    @arg @c kGTLRNetworkconnectivity_Hub_PresetTopology_PresetTopologyUnspecified
 *        Preset topology is unspecified. When policy_mode = PRESET, it defaults
 *        to MESH. (Value: "PRESET_TOPOLOGY_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_PresetTopology_Star Star topology is
 *        implemented. Two groups, `center` and `edge`, are automatically
 *        created along with hub creation. Spokes have to join one of the groups
 *        during creation. (Value: "STAR")
 */
@property(nonatomic, copy, nullable) NSString *presetTopology;

/**
 *  Output only. The route tables that belong to this hub. They use the
 *  following form:
 *  `projects/{project_number}/locations/global/hubs/{hub_id}/routeTables/{route_table_id}`
 *  This field is read-only. Network Connectivity Center automatically populates
 *  it based on the route tables nested under the hub.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *routeTables;

/**
 *  Output only. The VPC networks associated with this hub's spokes. This field
 *  is read-only. Network Connectivity Center automatically populates it based
 *  on the set of spokes attached to the hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RoutingVPC *> *routingVpcs;

/**
 *  Output only. A summary of the spokes associated with a hub. The summary
 *  includes a count of spokes according to type and according to state. If any
 *  spokes are inactive, the summary also lists the reasons they are inactive,
 *  including a count for each reason.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_SpokeSummary *spokeSummary;

/**
 *  Output only. The current lifecycle state of this hub.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Accepting The resource's accept
 *        operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Creating The resource's create
 *        operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Deleting The resource's delete
 *        operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Failed The resource is in an
 *        undefined state due to resource creation or deletion failure. You can
 *        try to delete the resource later or contact support for help. (Value:
 *        "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Rejecting The resource's reject
 *        operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Hub_State_Updating The resource's update
 *        operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the hub. This value is unique
 *  across all hub resources. If a hub is deleted and another with the same name
 *  is created, the new hub is assigned a different unique_id.
 */
@property(nonatomic, copy, nullable) NSString *uniqueId;

/** Output only. The time the hub was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Hub_Labels : GTLRObject
@end


/**
 *  A hub status entry represents the status of a set of propagated Private
 *  Service Connect connections grouped by certain fields.
 */
@interface GTLRNetworkconnectivity_HubStatusEntry : GTLRObject

/**
 *  The number of propagated Private Service Connect connections with this
 *  status. If the `group_by` field was not set in the request message, the
 *  value of this field is 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The fields that this entry is grouped by. This has the same value as the
 *  `group_by` field in the request message.
 */
@property(nonatomic, copy, nullable) NSString *groupBy;

/** The Private Service Connect propagation status. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PscPropagationStatus *pscPropagationStatus;

@end


/**
 *  InterconnectAttachment that this route applies to.
 */
@interface GTLRNetworkconnectivity_InterconnectAttachment : GTLRObject

/**
 *  Optional. Cloud region to install this policy-based route on interconnect
 *  attachment. Use `all` to install it on all interconnect attachments.
 */
@property(nonatomic, copy, nullable) NSString *region;

@end


/**
 *  The internal range resource for IPAM operations within a VPC network. Used
 *  to represent a private address range along with behavioral characteristics
 *  of that range (its usage and peering behavior). Networking resources can
 *  link to this range if they are created as belonging to it.
 */
@interface GTLRNetworkconnectivity_InternalRange : GTLRObject

/**
 *  Optional. Range auto-allocation options, may be set only when
 *  auto-allocation is selected by not setting ip_cidr_range (and setting
 *  prefix_length).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_AllocationOptions *allocationOptions;

/** Time when the internal range was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. ExcludeCidrRanges flag. Specifies a set of CIDR blocks that allows
 *  exclusion of particular CIDR ranges from the auto-allocation process,
 *  without having to reserve these blocks
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludeCidrRanges;

/**
 *  Optional. Immutable ranges cannot have their fields modified, except for
 *  labels and description.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *immutable;

/**
 *  Optional. The IP range that this internal range defines. NOTE: IPv6 ranges
 *  are limited to usage=EXTERNAL_TO_VPC and peering=FOR_SELF. NOTE: For IPv6
 *  Ranges this field is compulsory, i.e. the address range must be specified
 *  explicitly.
 */
@property(nonatomic, copy, nullable) NSString *ipCidrRange;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_InternalRange_Labels *labels;

/** Optional. Must be present if usage is set to FOR_MIGRATION. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Migration *migration;

/**
 *  Identifier. The name of an internal range. Format:
 *  projects/{project}/locations/{location}/internalRanges/{internal_range} See:
 *  https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Immutable. The URL or resource ID of the network in which to reserve the
 *  internal range. The network cannot be deleted if there are any reserved
 *  internal ranges referring to it. Legacy networks are not supported. For
 *  example:
 *  https://www.googleapis.com/compute/v1/projects/{project}/locations/global/networks/{network}
 *  projects/{project}/locations/global/networks/{network} {network}
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Optional. Types of resources that are allowed to overlap with the current
 *  internal range.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *overlaps;

/**
 *  Optional. The type of peering set for this internal range.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_ForPeer This
 *        behavior can be set when the internal range is being reserved for
 *        usage by peers. This means that no resource within the VPC in which it
 *        is being created can use this to associate with a VPC resource, but
 *        one of the peers can. This represents donating a range for peers to
 *        use. (Value: "FOR_PEER")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_ForSelf This is the
 *        default behavior and represents the case that this internal range is
 *        intended to be used in the VPC in which it is created and is
 *        accessible from its peers. This implies that peers or peers-of-peers
 *        cannot use this range. (Value: "FOR_SELF")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_NotShared This
 *        behavior can be set when the internal range is being reserved for
 *        usage by the VPC in which it is created, but not shared with peers. In
 *        a sense, it is local to the VPC. This can be used to create internal
 *        ranges for various purposes like HTTP_INTERNAL_LOAD_BALANCER or for
 *        Interconnect routes that are not shared with peers. This also implies
 *        that peers cannot use this range in a way that is visible to this VPC,
 *        but can re-use this range as long as it is NOT_SHARED from the peer
 *        VPC, too. (Value: "NOT_SHARED")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Peering_PeeringUnspecified
 *        If Peering is left unspecified in CreateInternalRange or
 *        UpdateInternalRange, it will be defaulted to FOR_SELF. (Value:
 *        "PEERING_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *peering;

/**
 *  Optional. An alternate to ip_cidr_range. Can be set when trying to create an
 *  IPv4 reservation that automatically finds a free range of the given size. If
 *  both ip_cidr_range and prefix_length are set, there is an error if the range
 *  sizes do not match. Can also be used during updates to change the range
 *  size. NOTE: For IPv6 this field only works if ip_cidr_range is set as well,
 *  and both fields must match. In other words, with IPv6 this field only works
 *  as a redundant parameter.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *prefixLength;

/**
 *  Optional. Can be set to narrow down or pick a different address space while
 *  searching for a free range. If not set, defaults to the ["10.0.0.0/8",
 *  "172.16.0.0/12", "192.168.0.0/16"] address space (for auto-mode networks,
 *  the "10.0.0.0/9" range is used instead of "10.0.0.0/8"). This can be used to
 *  target the search in other rfc-1918 address spaces like "172.16.0.0/12" and
 *  "192.168.0.0/16" or non-rfc-1918 address spaces used in the VPC.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *targetCidrRange;

/** Time when the internal range was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Optional. The type of usage set for this InternalRange.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_ExternalToVpc Ranges
 *        created with EXTERNAL_TO_VPC cannot be associated with VPC resources
 *        and are meant to block out address ranges for various use cases, like
 *        for example, usage on-prem, with dynamic route announcements via
 *        interconnect. (Value: "EXTERNAL_TO_VPC")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_ForMigration Ranges
 *        created FOR_MIGRATION can be used to lock a CIDR range between a
 *        source and target subnet. If usage is set to FOR_MIGRATION, the
 *        peering value has to be set to FOR_SELF or default to FOR_SELF when
 *        unset. (Value: "FOR_MIGRATION")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_ForVpc A VPC resource
 *        can use the reserved CIDR block by associating it with the internal
 *        range resource if usage is set to FOR_VPC. (Value: "FOR_VPC")
 *    @arg @c kGTLRNetworkconnectivity_InternalRange_Usage_UsageUnspecified
 *        Unspecified usage is allowed in calls which identify the resource by
 *        other fields and do not need Usage set to complete. These are, i.e.:
 *        GetInternalRange and DeleteInternalRange. Usage needs to be specified
 *        explicitly in CreateInternalRange or UpdateInternalRange calls.
 *        (Value: "USAGE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *usage;

/**
 *  Output only. The list of resources that refer to this internal range.
 *  Resources that use the internal range for their range allocation are
 *  referred to as users of the range. Other resources mark themselves as users
 *  while doing so by creating a reference to this internal range. Having a
 *  user, based on this reference, prevents deletion of the internal range
 *  referred to. Can be empty.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *users;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_InternalRange_Labels : GTLRObject
@end


/**
 *  A collection of VLAN attachment resources. These resources should be
 *  redundant attachments that all advertise the same prefixes to Google Cloud.
 *  Alternatively, in active/passive configurations, all attachments should be
 *  capable of advertising the same prefixes.
 */
@interface GTLRNetworkconnectivity_LinkedInterconnectAttachments : GTLRObject

/**
 *  Optional. Hub routes fully encompassed by include import ranges are included
 *  during import from hub.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeImportRanges;

/**
 *  A value that controls whether site-to-site data transfer is enabled for
 *  these resources. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URIs of linked interconnect attachment resources */
@property(nonatomic, strong, nullable) NSArray<NSString *> *uris;

/** Output only. The VPC network where these VLAN attachments are located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  GTLRNetworkconnectivity_LinkedProducerVpcNetwork
 */
@interface GTLRNetworkconnectivity_LinkedProducerVpcNetwork : GTLRObject

/**
 *  Optional. IP ranges encompassing the subnets to be excluded from peering.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludeExportRanges;

/** Optional. IP ranges allowed to be included from peering. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeExportRanges;

/**
 *  Immutable. The URI of the Service Consumer VPC that the Producer VPC is
 *  peered with.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Immutable. The name of the VPC peering between the Service Consumer VPC and
 *  the Producer VPC (defined in the Tenant project) which is added to the NCC
 *  hub. This peering must be in ACTIVE state.
 */
@property(nonatomic, copy, nullable) NSString *peering;

/** Output only. The URI of the Producer VPC. */
@property(nonatomic, copy, nullable) NSString *producerNetwork;

/**
 *  Output only. The proposed exclude export IP ranges waiting for hub
 *  administration's approval.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *proposedExcludeExportRanges;

/**
 *  Output only. The proposed include export IP ranges waiting for hub
 *  administration's approval.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *proposedIncludeExportRanges;

/** Output only. The Service Consumer Network spoke. */
@property(nonatomic, copy, nullable) NSString *serviceConsumerVpcSpoke;

@end


/**
 *  A collection of router appliance instances. If you configure multiple router
 *  appliance instances to receive data from the same set of sites outside of
 *  Google Cloud, we recommend that you associate those instances with the same
 *  spoke.
 */
@interface GTLRNetworkconnectivity_LinkedRouterApplianceInstances : GTLRObject

/**
 *  Optional. Hub routes fully encompassed by include import ranges are included
 *  during import from hub.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeImportRanges;

/** The list of router appliance instances. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RouterApplianceInstance *> *instances;

/**
 *  A value that controls whether site-to-site data transfer is enabled for
 *  these resources. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/**
 *  Output only. The VPC network where these router appliance instances are
 *  located.
 */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  An existing VPC network.
 */
@interface GTLRNetworkconnectivity_LinkedVpcNetwork : GTLRObject

/**
 *  Optional. IP ranges encompassing the subnets to be excluded from peering.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludeExportRanges;

/** Optional. IP ranges allowed to be included from peering. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeExportRanges;

/**
 *  Output only. The list of Producer VPC spokes that this VPC spoke is a
 *  service consumer VPC spoke for. These producer VPCs are connected through
 *  VPC peering to this spoke's backing VPC network. Because they are directly
 *  connected through VPC peering, NCC export filters do not apply between the
 *  service consumer VPC spoke and any of its producer VPC spokes. This VPC
 *  spoke cannot be deleted as long as any of these producer VPC spokes are
 *  connected to the NCC Hub.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *producerVpcSpokes;

/**
 *  Output only. The proposed exclude export IP ranges waiting for hub
 *  administration's approval.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *proposedExcludeExportRanges;

/**
 *  Output only. The proposed include export IP ranges waiting for hub
 *  administration's approval.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *proposedIncludeExportRanges;

/** Required. The URI of the VPC network resource. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A collection of Cloud VPN tunnel resources. These resources should be
 *  redundant HA VPN tunnels that all advertise the same prefixes to Google
 *  Cloud. Alternatively, in a passive/active configuration, all tunnels should
 *  be capable of advertising the same prefixes.
 */
@interface GTLRNetworkconnectivity_LinkedVpnTunnels : GTLRObject

/**
 *  Optional. Hub routes fully encompassed by include import ranges are included
 *  during import from hub.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includeImportRanges;

/**
 *  A value that controls whether site-to-site data transfer is enabled for
 *  these resources. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URIs of linked VPN tunnel resources. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *uris;

/** Output only. The VPC network where these VPN tunnels are located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  Response message to list `Destination` resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "destinations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListDestinationsResponse : GTLRCollectionObject

/**
 *  The list of `Destination` resources to be listed.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Destination *> *destinations;

/** The next page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListGroups method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "groups" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListGroupsResponse : GTLRCollectionObject

/**
 *  The requested groups.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Group *> *groups;

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Hubs that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response for HubService.ListHubSpokes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "spokes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListHubSpokesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested spokes. The spoke fields can be partially populated based on
 *  the `view` field in the request message.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Spoke *> *spokes;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListHubs method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hubs" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListHubsResponse : GTLRCollectionObject

/**
 *  The requested hubs.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Hub *> *hubs;

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for InternalRange.ListInternalRanges
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "internalRanges" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRNetworkconnectivity_ListInternalRangesResponse : GTLRCollectionObject

/**
 *  Internal ranges to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_InternalRange *> *internalRanges;

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message to list `MulticloudDataTransferConfig` resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "multicloudDataTransferConfigs" property. If returned as the
 *        result of a query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListMulticloudDataTransferConfigsResponse : GTLRCollectionObject

/**
 *  The list of `MulticloudDataTransferConfig` resources to be listed.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_MulticloudDataTransferConfig *> *multicloudDataTransferConfigs;

/** The next page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message to list the services in your project in regions that are
 *  eligible for Data Transfer Essentials configuration.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "multicloudDataTransferSupportedServices" property. If returned as
 *        the result of a query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListMulticloudDataTransferSupportedServicesResponse : GTLRCollectionObject

/**
 *  The list of supported services.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_MulticloudDataTransferSupportedService *> *multicloudDataTransferSupportedServices;

/** The next page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response for PolicyBasedRoutingService.ListPolicyBasedRoutes method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "policyBasedRoutes" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListPolicyBasedRoutesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Policy-based routes to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_PolicyBasedRoute *> *policyBasedRoutes;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListRegionalEndpoints.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "regionalEndpoints" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListRegionalEndpointsResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Regional endpoints to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RegionalEndpoint *> *regionalEndpoints;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Message for response to listing RemoteTransportProfiles
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "remoteTransportProfiles" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListRemoteTransportProfilesResponse : GTLRCollectionObject

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of RemoteTransportProfiles
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RemoteTransportProfile *> *remoteTransportProfiles;

/** Unordered list. Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListRoutes method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "routes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListRoutesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested routes.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Route *> *routes;

/** RouteTables that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for HubService.ListRouteTables method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "routeTables" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListRouteTablesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested route tables.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_RouteTable *> *routeTables;

/** Hubs that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceClasses.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceClasses" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceClassesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceClasses to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceClass *> *serviceClasses;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceConnectionMaps.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceConnectionMaps" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceConnectionMapsResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceConnectionMaps to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConnectionMap *> *serviceConnectionMaps;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceConnectionPolicies.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceConnectionPolicies" property. If returned as the result of
 *        a query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceConnectionPoliciesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceConnectionPolicies to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConnectionPolicy *> *serviceConnectionPolicies;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response for ListServiceConnectionTokens.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceConnectionTokens" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetworkconnectivity_ListServiceConnectionTokensResponse : GTLRCollectionObject

/**
 *  The next pagination token in the List response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  ServiceConnectionTokens to be returned.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConnectionToken *> *serviceConnectionTokens;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response for HubService.ListSpokes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "spokes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListSpokesResponse : GTLRCollectionObject

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The requested spokes.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Spoke *> *spokes;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Message for response to listing Transports
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "transports" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkconnectivity_ListTransportsResponse : GTLRCollectionObject

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of Transport
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Transport *> *transports;

/** Unordered list. Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRNetworkconnectivity_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Location_Metadata : GTLRObject
@end


/**
 *  Metadata about locations
 */
@interface GTLRNetworkconnectivity_LocationMetadata : GTLRObject

/** List of supported features */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locationFeatures;

@end


/**
 *  Specification for migration with source and target resource names.
 */
@interface GTLRNetworkconnectivity_Migration : GTLRObject

/**
 *  Immutable. Resource path as an URI of the source resource, for example a
 *  subnet. The project for the source resource should match the project for the
 *  InternalRange. An example:
 *  /projects/{project}/regions/{region}/subnetworks/{subnet}
 */
@property(nonatomic, copy, nullable) NSString *source;

/**
 *  Immutable. Resource path of the target resource. The target project can be
 *  different, as in the cases when migrating to peer networks. For example:
 *  /projects/{project}/regions/{region}/subnetworks/{subnet}
 */
@property(nonatomic, copy, nullable) NSString *target;

@end


/**
 *  The `MulticloudDataTransferConfig` resource. It lists the services that you
 *  configure for Data Transfer Essentials billing and metering.
 */
@interface GTLRNetworkconnectivity_MulticloudDataTransferConfig : GTLRObject

/**
 *  Output only. Time when the `MulticloudDataTransferConfig` resource was
 *  created.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The number of `Destination` resources in use with the
 *  `MulticloudDataTransferConfig` resource.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *destinationsActiveCount;

/**
 *  Output only. The number of `Destination` resources configured for the
 *  `MulticloudDataTransferConfig` resource.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *destinationsCount;

/**
 *  The etag is computed by the server, and might be sent with update and delete
 *  requests so that the client has an up-to-date value before proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Optional. User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_MulticloudDataTransferConfig_Labels *labels;

/**
 *  Identifier. The name of the `MulticloudDataTransferConfig` resource. Format:
 *  `projects/{project}/locations/{location}/multicloudDataTransferConfigs/{multicloud_data_transfer_config}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Maps services to their current or planned states. Service names
 *  are keys, and the associated values describe the state of the service. If a
 *  state change is expected, the value is either `ADDING` or `DELETING`,
 *  depending on the actions taken. Sample output: "services": { "big-query": {
 *  "states": [ { "effectiveTime": "2024-12-12T08:00:00Z" "state": "ADDING", },
 *  ] }, "cloud-storage": { "states": [ { "state": "ACTIVE", } ] } }
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_MulticloudDataTransferConfig_Services *services;

/**
 *  Output only. The Google-generated unique ID for the
 *  `MulticloudDataTransferConfig` resource. This value is unique across all
 *  `MulticloudDataTransferConfig` resources. If a resource is deleted and
 *  another with the same name is created, the new resource is assigned a
 *  different and unique ID.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. Time when the `MulticloudDataTransferConfig` resource was
 *  updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_MulticloudDataTransferConfig_Labels : GTLRObject
@end


/**
 *  Optional. Maps services to their current or planned states. Service names
 *  are keys, and the associated values describe the state of the service. If a
 *  state change is expected, the value is either `ADDING` or `DELETING`,
 *  depending on the actions taken. Sample output: "services": { "big-query": {
 *  "states": [ { "effectiveTime": "2024-12-12T08:00:00Z" "state": "ADDING", },
 *  ] }, "cloud-storage": { "states": [ { "state": "ACTIVE", } ] } }
 *
 *  @note This class is documented as having more properties of
 *        GTLRNetworkconnectivity_StateTimeline. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkconnectivity_MulticloudDataTransferConfig_Services : GTLRObject
@end


/**
 *  A service in your project in a region that is eligible for Data Transfer
 *  Essentials configuration.
 */
@interface GTLRNetworkconnectivity_MulticloudDataTransferSupportedService : GTLRObject

/** Identifier. The name of the service. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The network service tier or regional endpoint supported for the
 *  service.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ServiceConfig *> *serviceConfigs;

@end


/**
 *  A route next hop that leads to an interconnect attachment resource.
 */
@interface GTLRNetworkconnectivity_NextHopInterconnectAttachment : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this
 *  interconnect attachment resource. Data transfer is available only in
 *  [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the interconnect attachment resource. */
@property(nonatomic, copy, nullable) NSString *uri;

/** The VPC network where this interconnect attachment is located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  A route next hop that leads to a Router appliance instance.
 */
@interface GTLRNetworkconnectivity_NextHopRouterApplianceInstance : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this Router
 *  appliance instance resource. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the Router appliance instance. */
@property(nonatomic, copy, nullable) NSString *uri;

/** The VPC network where this VM is located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  A route next hop that leads to a spoke resource.
 */
@interface GTLRNetworkconnectivity_NextHopSpoke : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this spoke
 *  resource. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *  Whether this route is accessible to other hybrid spokes with site-to-site
 *  data transfer enabled. If this is false, the route is only accessible to VPC
 *  spokes of the connected Hub.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the spoke resource. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  GTLRNetworkconnectivity_NextHopVpcNetwork
 */
@interface GTLRNetworkconnectivity_NextHopVpcNetwork : GTLRObject

/** The URI of the VPC network resource */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A route next hop that leads to a VPN tunnel resource.
 */
@interface GTLRNetworkconnectivity_NextHopVPNTunnel : GTLRObject

/**
 *  Indicates whether site-to-site data transfer is allowed for this VPN tunnel
 *  resource. Data transfer is available only in [supported
 *  locations](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *siteToSiteDataTransfer;

/** The URI of the VPN tunnel resource. */
@property(nonatomic, copy, nullable) NSString *uri;

/** The VPC network where this VPN tunnel is located. */
@property(nonatomic, copy, nullable) NSString *vpcNetwork;

@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRNetworkconnectivity_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have been cancelled successfully have
 *  google.longrunning.Operation.error value with a google.rpc.Status.code of 1,
 *  corresponding to `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** ``` { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
 *  members: - user:mike\@example.com - group:admins\@example.com -
 *  domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 ``` For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRNetworkconnectivity_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Policy-based routes route L4 network traffic based on not just destination
 *  IP address, but also source IP address, protocol, and more. If a
 *  policy-based route conflicts with other types of routes, the policy-based
 *  route always takes precedence.
 */
@interface GTLRNetworkconnectivity_PolicyBasedRoute : GTLRObject

/** Output only. Time when the policy-based route was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. An optional description of this resource. Provide this field when
 *  you create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Required. The filter to match L4 traffic. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Filter *filter;

/**
 *  Optional. The interconnect attachments that this policy-based route applies
 *  to.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_InterconnectAttachment *interconnectAttachment;

/**
 *  Output only. Type of this resource. Always
 *  networkconnectivity#policyBasedRoute for policy-based Route resources.
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PolicyBasedRoute_Labels *labels;

/**
 *  Immutable. A unique name of the resource in the form of
 *  `projects/{project_number}/locations/global/PolicyBasedRoutes/{policy_based_route_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Fully-qualified URL of the network that this route applies to, for
 *  example: projects/my-project/global/networks/my-network.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Optional. The IP address of a global-access-enabled L4 ILB that is the next
 *  hop for matching packets. For this version, only nextHopIlbIp is supported.
 */
@property(nonatomic, copy, nullable) NSString *nextHopIlbIp;

/**
 *  Optional. Other routes that will be referenced to determine the next hop of
 *  the packet.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_DefaultRouting
 *        Use the routes from the default routing tables (system-generated
 *        routes, custom routes, peering route) to determine the next hop. This
 *        effectively excludes matching packets being applied on other PBRs with
 *        a lower priority. (Value: "DEFAULT_ROUTING")
 *    @arg @c kGTLRNetworkconnectivity_PolicyBasedRoute_NextHopOtherRoutes_OtherRoutesUnspecified
 *        Default value. (Value: "OTHER_ROUTES_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *nextHopOtherRoutes;

/**
 *  Optional. The priority of this policy-based route. Priority is used to break
 *  ties in cases where there are more than one matching policy-based routes
 *  found. In cases where multiple policy-based routes are matched, the one with
 *  the lowest-numbered priority value wins. The default value is 1000. The
 *  priority value must be from 1 to 65535, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/** Output only. Server-defined fully-qualified URL for this resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/** Output only. Time when the policy-based route was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Optional. VM instances that this policy-based route applies to. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_VirtualMachine *virtualMachine;

/**
 *  Output only. If potential misconfigurations are detected for this route,
 *  this field will be populated with warning messages.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_Warnings *> *warnings;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_PolicyBasedRoute_Labels : GTLRObject
@end


/**
 *  The PSC configurations on producer side.
 */
@interface GTLRNetworkconnectivity_ProducerPscConfig : GTLRObject

/**
 *  The resource path of a service attachment. Example:
 *  projects/{projectNumOrId}/regions/{region}/serviceAttachments/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *serviceAttachmentUri;

@end


/**
 *  Configuration used for Private Service Connect connections. Used when
 *  Infrastructure is PSC.
 */
@interface GTLRNetworkconnectivity_PscConfig : GTLRObject

/**
 *  Optional. List of Projects, Folders, or Organizations from where the
 *  Producer instance can be within. For example, a network administrator can
 *  provide both 'organizations/foo' and 'projects/bar' as
 *  allowed_google_producers_resource_hierarchy_levels. This allowlists this
 *  network to connect with any Producer instance within the 'foo' organization
 *  or the 'bar' project. By default,
 *  allowed_google_producers_resource_hierarchy_level is empty. The format for
 *  each allowed_google_producers_resource_hierarchy_level is / where is one of
 *  'projects', 'folders', or 'organizations' and is either the ID or the number
 *  of the resource type. Format for each
 *  allowed_google_producers_resource_hierarchy_level value: 'projects/' or
 *  'folders/' or 'organizations/' Eg. [projects/my-project-id, projects/567,
 *  folders/891, organizations/123]
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedGoogleProducersResourceHierarchyLevel;

/**
 *  Optional. Max number of PSC connections for this policy.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *limit;

/**
 *  Optional. ProducerInstanceLocation is used to specify which authorization
 *  mechanism to use to determine which projects the Producer instance can be
 *  within.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_CustomResourceHierarchyLevels
 *        Producer instance must be within one of the values provided in
 *        allowed_google_producers_resource_hierarchy_level. (Value:
 *        "CUSTOM_RESOURCE_HIERARCHY_LEVELS")
 *    @arg @c kGTLRNetworkconnectivity_PscConfig_ProducerInstanceLocation_ProducerInstanceLocationUnspecified
 *        Producer instance location is not specified. When this option is
 *        chosen, then the PSC connections created by this
 *        ServiceConnectionPolicy must be within the same project as the
 *        Producer instance. This is the default ProducerInstanceLocation value.
 *        To allow for PSC connections from this network to other networks, use
 *        the CUSTOM_RESOURCE_HIERARCHY_LEVELS option. (Value:
 *        "PRODUCER_INSTANCE_LOCATION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceLocation;

/**
 *  The resource paths of subnetworks to use for IP address management. Example:
 *  projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *subnetworks;

@end


/**
 *  Information about a specific Private Service Connect connection.
 */
@interface GTLRNetworkconnectivity_PscConnection : GTLRObject

/** The resource reference of the consumer address. */
@property(nonatomic, copy, nullable) NSString *consumerAddress;

/**
 *  The resource reference of the PSC Forwarding Rule within the consumer VPC.
 */
@property(nonatomic, copy, nullable) NSString *consumerForwardingRule;

/** The project where the PSC connection is created. */
@property(nonatomic, copy, nullable) NSString *consumerTargetProject;

/**
 *  The most recent error during operating this connection. Deprecated, please
 *  use error_info instead.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcStatus *error GTLR_DEPRECATED;

/**
 *  Output only. The error info for the latest error during operating this
 *  connection.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_GoogleRpcErrorInfo *errorInfo;

/**
 *  The error type indicates whether the error is consumer facing, producer
 *  facing or system internal.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ConnectionErrorTypeUnspecified
 *        An invalid error type as the default case. (Value:
 *        "CONNECTION_ERROR_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorConsumerSide
 *        The error is due to the setup on consumer side. (Value:
 *        "ERROR_CONSUMER_SIDE")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorInternal The
 *        error is due to Service Automation system internal. (Value:
 *        "ERROR_INTERNAL")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_ErrorType_ErrorProducerSide
 *        The error is due to the setup on producer side. (Value:
 *        "ERROR_PRODUCER_SIDE")
 */
@property(nonatomic, copy, nullable) NSString *errorType GTLR_DEPRECATED;

/** The last Compute Engine operation to setup PSC connection. */
@property(nonatomic, copy, nullable) NSString *gceOperation;

/**
 *  The requested IP version for the PSC connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_IpVersion_Ipv4 Will use
 *        IPv4 only. (Value: "IPV4")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_IpVersion_Ipv6 Will use
 *        IPv6 only. (Value: "IPV6")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_IpVersion_IpVersionUnspecified
 *        Default value. We will use IPv4 or IPv6 depending on the IP version of
 *        first available subnetwork. (Value: "IP_VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *ipVersion;

/**
 *  Immutable. Deprecated. Use producer_instance_metadata instead. An immutable
 *  identifier for the producer instance.
 */
@property(nonatomic, copy, nullable) NSString *producerInstanceId GTLR_DEPRECATED;

/** Immutable. An immutable map for the producer instance metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PscConnection_ProducerInstanceMetadata *producerInstanceMetadata;

/** The PSC connection id of the PSC forwarding rule. */
@property(nonatomic, copy, nullable) NSString *pscConnectionId;

/**
 *  Output only. The URI of the subnetwork selected to allocate IP address for
 *  this connection.
 */
@property(nonatomic, copy, nullable) NSString *selectedSubnetwork;

/**
 *  Output only. [Output only] The service class associated with this PSC
 *  Connection. The value is derived from the SCPolicy and matches the service
 *  class name provided by the customer.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/**
 *  State of the PSC Connection
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Active The connection
 *        has been created successfully. However, for the up-to-date connection
 *        status, please use the created forwarding rule's "PscConnectionStatus"
 *        as the source of truth. (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_CreateRepairing The
 *        connection is being repaired to complete creation. (Value:
 *        "CREATE_REPAIRING")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Creating The
 *        connection is being created. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_DeleteRepairing The
 *        connection is being repaired to complete deletion. (Value:
 *        "DELETE_REPAIRING")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Deleting The
 *        connection is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_Failed The connection
 *        is not functional since some resources on the connection fail to be
 *        created. (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_PscConnection_State_StateUnspecified An
 *        invalid state as the default case. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Immutable. An immutable map for the producer instance metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_PscConnection_ProducerInstanceMetadata : GTLRObject
@end


/**
 *  The status of one or more propagated Private Service Connect connections in
 *  a hub.
 */
@interface GTLRNetworkconnectivity_PscPropagationStatus : GTLRObject

/**
 *  The propagation status.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_CodeUnspecified
 *        The code is unspecified. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorConsumerQuotaExceeded
 *        The Private Service Connect connection propagation failed because the
 *        `PSC_PROPAGATED_CONNECTIONS_PER_VPC_NETWORK` quota in the consumer VPC
 *        network has been exceeded. (Value: "ERROR_CONSUMER_QUOTA_EXCEEDED")
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorProducerNatIpSpaceExhausted
 *        The Private Service Connect connection propagation failed because the
 *        NAT IP subnet space has been exhausted. It is equivalent to the `Needs
 *        attention` status of the Private Service Connect connection. See
 *        https://cloud.google.com/vpc/docs/about-accessing-vpc-hosted-services-endpoints#connection-statuses.
 *        (Value: "ERROR_PRODUCER_NAT_IP_SPACE_EXHAUSTED")
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorProducerPropagatedConnectionLimitExceeded
 *        The Private Service Connect connection propagation failed because the
 *        VPC network or the project of the target spoke has exceeded the
 *        connection limit set by the producer. (Value:
 *        "ERROR_PRODUCER_PROPAGATED_CONNECTION_LIMIT_EXCEEDED")
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_ErrorProducerQuotaExceeded
 *        The Private Service Connect connection propagation failed because the
 *        `PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK` quota in the
 *        producer VPC network has been exceeded. (Value:
 *        "ERROR_PRODUCER_QUOTA_EXCEEDED")
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_Propagating The
 *        Private Service Connect connection is propagating. This is a transient
 *        state. (Value: "PROPAGATING")
 *    @arg @c kGTLRNetworkconnectivity_PscPropagationStatus_Code_Ready The
 *        propagated Private Service Connect connection is ready. (Value:
 *        "READY")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  The human-readable summary of the Private Service Connect connection
 *  propagation status.
 */
@property(nonatomic, copy, nullable) NSString *message;

/** The name of the forwarding rule exported to the hub. */
@property(nonatomic, copy, nullable) NSString *sourceForwardingRule;

/** The name of the group that the source spoke belongs to. */
@property(nonatomic, copy, nullable) NSString *sourceGroup;

/** The name of the spoke that the source forwarding rule belongs to. */
@property(nonatomic, copy, nullable) NSString *sourceSpoke;

/** The name of the group that the target spoke belongs to. */
@property(nonatomic, copy, nullable) NSString *targetGroup;

/** The name of the spoke that the source forwarding rule propagates to. */
@property(nonatomic, copy, nullable) NSString *targetSpoke;

@end


/**
 *  The response for HubService.QueryHubStatus.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hubStatusEntries" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRNetworkconnectivity_QueryHubStatusResponse : GTLRCollectionObject

/**
 *  The list of hub status.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_HubStatusEntry *> *hubStatusEntries;

/**
 *  The token for the next page of the response. To see more results, use this
 *  value as the page_token for your next request. If this value is empty, there
 *  are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The RegionalEndpoint resource.
 */
@interface GTLRNetworkconnectivity_RegionalEndpoint : GTLRObject

/**
 *  Required. The access type of this regional endpoint. This field is reflected
 *  in the PSC Forwarding Rule configuration to enable global access.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_AccessTypeUnspecified
 *        An invalid type as the default case. (Value:
 *        "ACCESS_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Global This
 *        regional endpoint is accessible from all regions. (Value: "GLOBAL")
 *    @arg @c kGTLRNetworkconnectivity_RegionalEndpoint_AccessType_Regional This
 *        regional endpoint is only accessible from the same region where it
 *        resides. (Value: "REGIONAL")
 */
@property(nonatomic, copy, nullable) NSString *accessType;

/**
 *  Optional. The IP Address of the Regional Endpoint. When no address is
 *  provided, an IP from the subnetwork is allocated. Use one of the following
 *  formats: * IPv4 address as in `10.0.0.1` * Address resource URI as in
 *  `projects/{project}/regions/{region}/addresses/{address_name}` for an IPv4
 *  or IPv6 address.
 */
@property(nonatomic, copy, nullable) NSString *address;

/** Output only. Time when the RegionalEndpoint was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The literal IP address of the PSC Forwarding Rule created on
 *  behalf of the customer. This field is deprecated. Use address instead.
 */
@property(nonatomic, copy, nullable) NSString *ipAddress GTLR_DEPRECATED;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_RegionalEndpoint_Labels *labels;

/**
 *  Output only. The name of a RegionalEndpoint. Pattern:
 *  `projects/{project}/locations/{location}/regionalEndpoints/^[-a-z0-9](?:[-a-z0-9]{0,44})[a-z0-9]$`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the VPC network for this private regional endpoint. Format:
 *  `projects/{project}/global/networks/{network}`
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Output only. The resource reference of the PSC Forwarding Rule created on
 *  behalf of the customer. Format:
 *  `//compute.googleapis.com/projects/{project}/regions/{region}/forwardingRules/{forwarding_rule_name}`
 */
@property(nonatomic, copy, nullable) NSString *pscForwardingRule;

/**
 *  The name of the subnetwork from which the IP address will be allocated.
 *  Format: `projects/{project}/regions/{region}/subnetworks/{subnetwork}`
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Required. The service endpoint this private regional endpoint connects to.
 *  Format: `{apiname}.{region}.p.rep.googleapis.com` Example:
 *  "cloudkms.us-central1.p.rep.googleapis.com".
 */
@property(nonatomic, copy, nullable) NSString *targetGoogleApi;

/** Output only. Time when the RegionalEndpoint was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_RegionalEndpoint_Labels : GTLRObject
@end


/**
 *  The request for HubService.RejectHubSpoke.
 */
@interface GTLRNetworkconnectivity_RejectHubSpokeRequest : GTLRObject

/** Optional. Additional information provided by the hub administrator. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  Optional. A request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server knows to ignore the request
 *  if it has already been completed. The server guarantees that a request
 *  doesn't result in creation of duplicate commitments for at least 60 minutes.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check to see whether the original operation was received. If
 *  it was, the server ignores the second request. This behavior prevents
 *  clients from mistakenly creating duplicate commitments. The request ID must
 *  be a valid UUID, with the exception that zero UUID is not supported
 *  (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Required. The URI of the spoke to reject from the hub. */
@property(nonatomic, copy, nullable) NSString *spokeUri;

@end


/**
 *  The response for HubService.RejectHubSpoke.
 */
@interface GTLRNetworkconnectivity_RejectHubSpokeResponse : GTLRObject

/** The spoke that was operated on. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Spoke *spoke;

@end


/**
 *  The request for HubService.RejectSpokeUpdate.
 */
@interface GTLRNetworkconnectivity_RejectSpokeUpdateRequest : GTLRObject

/** Optional. Additional information provided by the hub administrator. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  Optional. A request ID to identify requests. Specify a unique request ID so
 *  that if you must retry your request, the server knows to ignore the request
 *  if it has already been completed. The server guarantees that a request
 *  doesn't result in creation of duplicate commitments for at least 60 minutes.
 *  For example, consider a situation where you make an initial request and the
 *  request times out. If you make the request again with the same request ID,
 *  the server can check to see whether the original operation was received. If
 *  it was, the server ignores the second request. This behavior prevents
 *  clients from mistakenly creating duplicate commitments. The request ID must
 *  be a valid UUID, with the exception that zero UUID is not supported
 *  (00000000-0000-0000-0000-000000000000).
 */
@property(nonatomic, copy, nullable) NSString *requestId;

/** Required. The etag of the spoke to reject update. */
@property(nonatomic, copy, nullable) NSString *spokeEtag;

/** Required. The URI of the spoke to reject update. */
@property(nonatomic, copy, nullable) NSString *spokeUri;

@end


/**
 *  Message describing RemoteTransportProfile object
 */
@interface GTLRNetworkconnectivity_RemoteTransportProfile : GTLRObject

/** Output only. [Output only] Create time stamp */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Optional. Labels as key value pairs */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_RemoteTransportProfile_Labels *labels;

/** Identifier. name of resource */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. [Output only] Update time stamp */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels as key value pairs
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_RemoteTransportProfile_Labels : GTLRObject
@end


/**
 *  A route defines a path from VM instances within a spoke to a specific
 *  destination resource. Only VPC spokes have routes.
 */
@interface GTLRNetworkconnectivity_Route : GTLRObject

/** Output only. The time the route was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  An optional description of the route.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The destination IP address range. */
@property(nonatomic, copy, nullable) NSString *ipCidrRange;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Route_Labels *labels;

/**
 *  Output only. The origin location of the route. Uses the following form:
 *  "projects/{project}/locations/{location}" Example:
 *  projects/1234/locations/us-central1
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Immutable. The name of the route. Route names must be unique. Route names
 *  use the following form:
 *  `projects/{project_number}/locations/global/hubs/{hub}/routeTables/{route_table_id}/routes/{route_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Immutable. The next-hop VLAN attachment for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopInterconnectAttachment *nextHopInterconnectAttachment;

/**
 *  Immutable. The next-hop Router appliance instance for packets on this route.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopRouterApplianceInstance *nextHopRouterApplianceInstance;

/** Immutable. The next-hop spoke for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopSpoke *nextHopSpoke;

/** Immutable. The destination VPC network for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopVpcNetwork *nextHopVpcNetwork;

/** Immutable. The next-hop VPN tunnel for packets on this route. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_NextHopVPNTunnel *nextHopVpnTunnel;

/**
 *  Output only. The priority of this route. Priority is used to break ties in
 *  cases where a destination matches more than one route. In these cases the
 *  route with the lowest-numbered priority value wins.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/**
 *  Immutable. The spoke that this route leads to. Example:
 *  projects/12345/locations/global/spokes/SPOKE
 */
@property(nonatomic, copy, nullable) NSString *spoke;

/**
 *  Output only. The current lifecycle state of the route.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Failed The resource is in an
 *        undefined state due to resource creation or deletion failure. You can
 *        try to delete the resource later or contact support for help. (Value:
 *        "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Route_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The route's type. Its type is determined by the properties of
 *  its IP address range.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_DynamicRoute The route leads
 *        to a destination in a dynamic route. Dynamic routes are derived from
 *        Border Gateway Protocol (BGP) advertisements received from an NCC
 *        hybrid spoke. (Value: "DYNAMIC_ROUTE")
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_RouteTypeUnspecified No route
 *        type information specified (Value: "ROUTE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_VpcPrimarySubnet The route
 *        leads to a destination within the primary address range of the VPC
 *        network's subnet. (Value: "VPC_PRIMARY_SUBNET")
 *    @arg @c kGTLRNetworkconnectivity_Route_Type_VpcSecondarySubnet The route
 *        leads to a destination within the secondary address range of the VPC
 *        network's subnet. (Value: "VPC_SECONDARY_SUBNET")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Output only. The Google-generated UUID for the route. This value is unique
 *  across all Network Connectivity Center route resources. If a route is
 *  deleted and another with the same name is created, the new route is assigned
 *  a different `uid`.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time the route was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Route_Labels : GTLRObject
@end


/**
 *  A router appliance instance is a Compute Engine virtual machine (VM)
 *  instance that acts as a BGP speaker. A router appliance instance is
 *  specified by the URI of the VM and the internal IP address of one of the
 *  VM's network interfaces.
 */
@interface GTLRNetworkconnectivity_RouterApplianceInstance : GTLRObject

/** The IP address on the VM to use for peering. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/** The URI of the VM. */
@property(nonatomic, copy, nullable) NSString *virtualMachine;

@end


/**
 *  GTLRNetworkconnectivity_RouteTable
 */
@interface GTLRNetworkconnectivity_RouteTable : GTLRObject

/** Output only. The time the route table was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  An optional description of the route table.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_RouteTable_Labels *labels;

/**
 *  Immutable. The name of the route table. Route table names must be unique.
 *  They use the following form:
 *  `projects/{project_number}/locations/global/hubs/{hub}/routeTables/{route_table_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current lifecycle state of this route table.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Active The resource is
 *        active (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Failed The resource is
 *        in an undefined state due to resource creation or deletion failure.
 *        You can try to delete the resource later or contact support for help.
 *        (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Obsolete The hub
 *        associated with this spoke resource has been deleted. This state
 *        applies to spoke resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_StateUnspecified No
 *        state information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_RouteTable_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the route table. This value is
 *  unique across all route table resources. If a route table is deleted and
 *  another with the same name is created, the new route table is assigned a
 *  different `uid`.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The time the route table was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_RouteTable_Labels : GTLRObject
@end


/**
 *  RoutingVPC contains information about the VPC networks associated with the
 *  spokes of a Network Connectivity Center hub.
 */
@interface GTLRNetworkconnectivity_RoutingVPC : GTLRObject

/**
 *  Output only. If true, indicates that this VPC network is currently
 *  associated with spokes that use the data transfer feature (spokes where the
 *  site_to_site_data_transfer field is set to true). If you create new spokes
 *  that use data transfer, they must be associated with this VPC network. At
 *  most, one VPC network will have this field set to true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requiredForNewSiteToSiteDataTransferSpokes;

/** The URI of the VPC network. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  The ServiceClass resource.
 */
@interface GTLRNetworkconnectivity_ServiceClass : GTLRObject

/** Output only. Time when the ServiceClass was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceClass_Labels *labels;

/**
 *  Immutable. The name of a ServiceClass resource. Format:
 *  projects/{project}/locations/{location}/serviceClasses/{service_class} See:
 *  https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The generated service class name. Use this name to refer to the
 *  Service class in Service Connection Maps and Service Connection Policies.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/** Output only. Time when the ServiceClass was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceClass_Labels : GTLRObject
@end


/**
 *  Specifies eligibility information for the service.
 */
@interface GTLRNetworkconnectivity_ServiceConfig : GTLRObject

/**
 *  Output only. The eligibility criteria for the service.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_EligibilityCriteriaUnspecified
 *        The service is not eligible for Data Transfer Essentials
 *        configuration. This is the default case. (Value:
 *        "ELIGIBILITY_CRITERIA_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_NetworkServiceTierPremiumOnly
 *        The service is eligible for Data Transfer Essentials configuration
 *        only for Premium Tier. (Value: "NETWORK_SERVICE_TIER_PREMIUM_ONLY")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_NetworkServiceTierStandardOnly
 *        The service is eligible for Data Transfer Essentials configuration
 *        only for Standard Tier. (Value: "NETWORK_SERVICE_TIER_STANDARD_ONLY")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConfig_EligibilityCriteria_RequestEndpointRegionalEndpointOnly
 *        The service is eligible for Data Transfer Essentials configuration
 *        only for the regional endpoint. (Value:
 *        "REQUEST_ENDPOINT_REGIONAL_ENDPOINT_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *eligibilityCriteria;

/**
 *  Output only. The end time for eligibility criteria support. If not
 *  specified, no planned end time is set.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *supportEndTime;

@end


/**
 *  The ServiceConnectionMap resource.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionMap : GTLRObject

/** The PSC configurations on consumer side. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ConsumerPscConfig *> *consumerPscConfigs;

/** Output only. PSC connection details on consumer side. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ConsumerPscConnection *> *consumerPscConnections;

/** Output only. Time when the ServiceConnectionMap was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. The infrastructure used for connections between
 *  consumers/producers.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_InfrastructureUnspecified
 *        An invalid infrastructure as the default case. (Value:
 *        "INFRASTRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionMap_Infrastructure_Psc
 *        Private Service Connect is used for connections. (Value: "PSC")
 */
@property(nonatomic, copy, nullable) NSString *infrastructure;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceConnectionMap_Labels *labels;

/**
 *  Immutable. The name of a ServiceConnectionMap. Format:
 *  projects/{project}/locations/{location}/serviceConnectionMaps/{service_connection_map}
 *  See: https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The PSC configurations on producer side. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_ProducerPscConfig *> *producerPscConfigs;

/**
 *  The service class identifier this ServiceConnectionMap is for. The user of
 *  ServiceConnectionMap create API needs to have
 *  networkconnectivity.serviceClasses.use IAM permission for the service class.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/** Output only. The service class uri this ServiceConnectionMap is for. */
@property(nonatomic, copy, nullable) NSString *serviceClassUri;

/**
 *  The token provided by the consumer. This token authenticates that the
 *  consumer can create a connection within the specified project and network.
 */
@property(nonatomic, copy, nullable) NSString *token;

/** Output only. Time when the ServiceConnectionMap was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionMap_Labels : GTLRObject
@end


/**
 *  The ServiceConnectionPolicy resource.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionPolicy : GTLRObject

/**
 *  Output only. Information for the automatically created subnetwork and its
 *  associated IR.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_AutoCreatedSubnetworkInfo *autoCreatedSubnetInfo;

/** Output only. Time when the ServiceConnectionPolicy was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. The type of underlying resources used to create the connection.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_InfrastructureUnspecified
 *        An invalid infrastructure as the default case. (Value:
 *        "INFRASTRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_ServiceConnectionPolicy_Infrastructure_Psc
 *        Private Service Connect is used for connections. (Value: "PSC")
 */
@property(nonatomic, copy, nullable) NSString *infrastructure;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceConnectionPolicy_Labels *labels;

/**
 *  Immutable. The name of a ServiceConnectionPolicy. Format:
 *  projects/{project}/locations/{location}/serviceConnectionPolicies/{service_connection_policy}
 *  See: https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The resource path of the consumer network. Example: -
 *  projects/{projectNumOrId}/global/networks/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Configuration used for Private Service Connect connections. Used when
 *  Infrastructure is PSC.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_PscConfig *pscConfig;

/**
 *  Output only. [Output only] Information about each Private Service Connect
 *  connection.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_PscConnection *> *pscConnections;

/**
 *  The service class identifier for which this ServiceConnectionPolicy is for.
 *  The service class identifier is a unique, symbolic representation of a
 *  ServiceClass. It is provided by the Service Producer. Google services have a
 *  prefix of gcp or google-cloud. For example, gcp-memorystore-redis or
 *  google-cloud-sql. 3rd party services do not. For example,
 *  test-service-a3dfcx.
 */
@property(nonatomic, copy, nullable) NSString *serviceClass;

/** Output only. Time when the ServiceConnectionPolicy was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionPolicy_Labels : GTLRObject
@end


/**
 *  The ServiceConnectionToken resource.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionToken : GTLRObject

/** Output only. Time when the ServiceConnectionToken was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. The etag is computed by the server, and may be sent on update and
 *  delete requests to ensure the client has an up-to-date value before
 *  proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Output only. The time to which this token is valid. */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/** User-defined labels. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_ServiceConnectionToken_Labels *labels;

/**
 *  Immutable. The name of a ServiceConnectionToken. Format:
 *  projects/{project}/locations/{location}/ServiceConnectionTokens/{service_connection_token}
 *  See: https://google.aip.dev/122#fields-representing-resource-names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The resource path of the network associated with this token. Example:
 *  projects/{projectNumOrId}/global/networks/{resourceId}.
 */
@property(nonatomic, copy, nullable) NSString *network;

/** Output only. The token generated by Automation. */
@property(nonatomic, copy, nullable) NSString *token;

/** Output only. Time when the ServiceConnectionToken was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  User-defined labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_ServiceConnectionToken_Labels : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRNetworkconnectivity_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  A Network Connectivity Center spoke represents one or more network
 *  connectivity resources. When you create a spoke, you associate it with a
 *  hub. You must also identify a value for exactly one of the following fields:
 *  * linked_vpn_tunnels * linked_interconnect_attachments *
 *  linked_router_appliance_instances * linked_vpc_network
 */
@interface GTLRNetworkconnectivity_Spoke : GTLRObject

/** Output only. The time the spoke was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. An optional description of the spoke.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. This checksum is computed by the server based on the value of
 *  other fields, and may be sent on update and delete requests to ensure the
 *  client has an up-to-date value before proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Optional. The list of fields waiting for hub administration's approval. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *fieldPathsPendingUpdate;

/** Optional. The name of the group that this spoke is associated with. */
@property(nonatomic, copy, nullable) NSString *group;

/** Immutable. The name of the hub that this spoke is attached to. */
@property(nonatomic, copy, nullable) NSString *hub;

/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Spoke_Labels *labels;

/** Optional. VLAN attachments that are associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedInterconnectAttachments *linkedInterconnectAttachments;

/** Optional. The linked producer VPC that is associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedProducerVpcNetwork *linkedProducerVpcNetwork;

/**
 *  Optional. Router appliance instances that are associated with the spoke.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedRouterApplianceInstances *linkedRouterApplianceInstances;

/** Optional. VPC network that is associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedVpcNetwork *linkedVpcNetwork;

/** Optional. VPN tunnels that are associated with the spoke. */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_LinkedVpnTunnels *linkedVpnTunnels;

/**
 *  Immutable. The name of the spoke. Spoke names must be unique. They use the
 *  following form:
 *  `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. The reasons for current state of the spoke. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_StateReason *> *reasons;

/**
 *  Output only. The type of resource associated with the spoke.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_InterconnectAttachment
 *        Spokes associated with VLAN attachments. (Value:
 *        "INTERCONNECT_ATTACHMENT")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_ProducerVpcNetwork Spokes
 *        that are backed by a producer VPC network. (Value:
 *        "PRODUCER_VPC_NETWORK")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_RouterAppliance Spokes
 *        associated with router appliance instances. (Value:
 *        "ROUTER_APPLIANCE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_SpokeTypeUnspecified
 *        Unspecified spoke type. (Value: "SPOKE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_VpcNetwork Spokes
 *        associated with VPC networks. (Value: "VPC_NETWORK")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_SpokeType_VpnTunnel Spokes
 *        associated with VPN tunnels. (Value: "VPN_TUNNEL")
 */
@property(nonatomic, copy, nullable) NSString *spokeType;

/**
 *  Output only. The current lifecycle state of this spoke.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Accepting The resource's
 *        accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Active The resource is active
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Creating The resource's
 *        create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Deleting The resource's
 *        delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Failed The resource is in an
 *        undefined state due to resource creation or deletion failure. You can
 *        try to delete the resource later or contact support for help. (Value:
 *        "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Inactive The resource is
 *        inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Obsolete The hub associated
 *        with this spoke resource has been deleted. This state applies to spoke
 *        resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Rejecting The resource's
 *        reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_StateUnspecified No state
 *        information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Spoke_State_Updating The resource's
 *        update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The Google-generated UUID for the spoke. This value is unique
 *  across all spoke resources. If a spoke is deleted and another with the same
 *  name is created, the new spoke is assigned a different `unique_id`.
 */
@property(nonatomic, copy, nullable) NSString *uniqueId;

/** Output only. The time the spoke was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional labels in key-value pair format. For more information about labels,
 *  see [Requirements for
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Spoke_Labels : GTLRObject
@end


/**
 *  The number of spokes that are in a particular state and associated with a
 *  given hub.
 */
@interface GTLRNetworkconnectivity_SpokeStateCount : GTLRObject

/**
 *  Output only. The total number of spokes that are in this state and
 *  associated with a given hub.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Output only. The state of the spokes.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Accepting The
 *        resource's accept operation is in progress. (Value: "ACCEPTING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Active The resource
 *        is active (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Creating The
 *        resource's create operation is in progress. (Value: "CREATING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Deleting The
 *        resource's delete operation is in progress. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Failed The resource
 *        is in an undefined state due to resource creation or deletion failure.
 *        You can try to delete the resource later or contact support for help.
 *        (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Inactive The
 *        resource is inactive. (Value: "INACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Obsolete The hub
 *        associated with this spoke resource has been deleted. This state
 *        applies to spoke resources only. (Value: "OBSOLETE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Rejecting The
 *        resource's reject operation is in progress. (Value: "REJECTING")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_StateUnspecified No
 *        state information available (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateCount_State_Updating The
 *        resource's update operation is in progress. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  The number of spokes in the hub that are inactive for this reason.
 */
@interface GTLRNetworkconnectivity_SpokeStateReasonCount : GTLRObject

/**
 *  Output only. The total number of spokes that are inactive for a particular
 *  reason and associated with a given hub.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Output only. The reason that a spoke is inactive.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_CodeUnspecified
 *        No information available. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Failed
 *        Network Connectivity Center encountered errors while accepting the
 *        spoke. (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Paused
 *        The spoke has been deactivated internally. (Value: "PAUSED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_PendingReview
 *        The proposed spoke is pending review. (Value: "PENDING_REVIEW")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_Rejected
 *        The proposed spoke has been rejected by the hub administrator. (Value:
 *        "REJECTED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_UpdateFailed
 *        Network Connectivity Center encountered errors while accepting the
 *        spoke update. (Value: "UPDATE_FAILED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_UpdatePendingReview
 *        The proposed spoke update is pending review. (Value:
 *        "UPDATE_PENDING_REVIEW")
 *    @arg @c kGTLRNetworkconnectivity_SpokeStateReasonCount_StateReasonCode_UpdateRejected
 *        The proposed spoke update has been rejected by the hub administrator.
 *        (Value: "UPDATE_REJECTED")
 */
@property(nonatomic, copy, nullable) NSString *stateReasonCode;

@end


/**
 *  Summarizes information about the spokes associated with a hub. The summary
 *  includes a count of spokes according to type and according to state. If any
 *  spokes are inactive, the summary also lists the reasons they are inactive,
 *  including a count for each reason.
 */
@interface GTLRNetworkconnectivity_SpokeSummary : GTLRObject

/**
 *  Output only. Counts the number of spokes that are in each state and
 *  associated with a given hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_SpokeStateCount *> *spokeStateCounts;

/**
 *  Output only. Counts the number of spokes that are inactive for each possible
 *  reason and associated with a given hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_SpokeStateReasonCount *> *spokeStateReasonCounts;

/**
 *  Output only. Counts the number of spokes of each type that are associated
 *  with a specific hub.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_SpokeTypeCount *> *spokeTypeCounts;

@end


/**
 *  The number of spokes of a given type that are associated with a specific
 *  hub. The type indicates what kind of resource is associated with the spoke.
 */
@interface GTLRNetworkconnectivity_SpokeTypeCount : GTLRObject

/**
 *  Output only. The total number of spokes of this type that are associated
 *  with the hub.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Output only. The type of the spokes.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_InterconnectAttachment
 *        Spokes associated with VLAN attachments. (Value:
 *        "INTERCONNECT_ATTACHMENT")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_ProducerVpcNetwork
 *        Spokes that are backed by a producer VPC network. (Value:
 *        "PRODUCER_VPC_NETWORK")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_RouterAppliance
 *        Spokes associated with router appliance instances. (Value:
 *        "ROUTER_APPLIANCE")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_SpokeTypeUnspecified
 *        Unspecified spoke type. (Value: "SPOKE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpcNetwork
 *        Spokes associated with VPC networks. (Value: "VPC_NETWORK")
 *    @arg @c kGTLRNetworkconnectivity_SpokeTypeCount_SpokeType_VpnTunnel Spokes
 *        associated with VPN tunnels. (Value: "VPN_TUNNEL")
 */
@property(nonatomic, copy, nullable) NSString *spokeType;

@end


/**
 *  The state and activation time details of the resource state.
 */
@interface GTLRNetworkconnectivity_StateMetadata : GTLRObject

/**
 *  Output only. Accompanies only the transient states, which include `ADDING`,
 *  `DELETING`, and `SUSPENDING`, to denote the time until which the transient
 *  state of the resource will be effective. For instance, if the state is
 *  `ADDING`, this field shows the time when the resource state transitions to
 *  `ACTIVE`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *effectiveTime;

/**
 *  Output only. The state of the resource.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_StateMetadata_State_Active The resource
 *        is in use. (Value: "ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_StateMetadata_State_Adding The resource
 *        is being added. (Value: "ADDING")
 *    @arg @c kGTLRNetworkconnectivity_StateMetadata_State_Deleting The resource
 *        is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetworkconnectivity_StateMetadata_State_StateUnspecified An
 *        invalid state, which is the default case. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_StateMetadata_State_Suspended The
 *        resource is suspended and not in use. (Value: "SUSPENDED")
 *    @arg @c kGTLRNetworkconnectivity_StateMetadata_State_Suspending The
 *        resource is being suspended. (Value: "SUSPENDING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  The reason a spoke is inactive.
 */
@interface GTLRNetworkconnectivity_StateReason : GTLRObject

/**
 *  The code associated with this reason.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_CodeUnspecified No
 *        information available. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_Failed Network
 *        Connectivity Center encountered errors while accepting the spoke.
 *        (Value: "FAILED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_Paused The spoke has
 *        been deactivated internally. (Value: "PAUSED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_PendingReview The
 *        proposed spoke is pending review. (Value: "PENDING_REVIEW")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_Rejected The proposed
 *        spoke has been rejected by the hub administrator. (Value: "REJECTED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_UpdateFailed Network
 *        Connectivity Center encountered errors while accepting the spoke
 *        update. (Value: "UPDATE_FAILED")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_UpdatePendingReview The
 *        proposed spoke update is pending review. (Value:
 *        "UPDATE_PENDING_REVIEW")
 *    @arg @c kGTLRNetworkconnectivity_StateReason_Code_UpdateRejected The
 *        proposed spoke update has been rejected by the hub administrator.
 *        (Value: "UPDATE_REJECTED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** Human-readable details about this reason. */
@property(nonatomic, copy, nullable) NSString *message;

/** Additional information provided by the user in the RejectSpoke call. */
@property(nonatomic, copy, nullable) NSString *userDetails;

@end


/**
 *  The timeline of the pending states for a resource.
 */
@interface GTLRNetworkconnectivity_StateTimeline : GTLRObject

/**
 *  Output only. The state and activation time details of the resource state.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkconnectivity_StateMetadata *> *states;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRNetworkconnectivity_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRNetworkconnectivity_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Message describing Transport object
 */
@interface GTLRNetworkconnectivity_Transport : GTLRObject

/** Output only. [Output only] Create time stamp */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Optional. Labels as key value pairs */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Transport_Labels *labels;

/** Identifier. name of resource */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. [Output only] Update time stamp */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels as key value pairs
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Transport_Labels : GTLRObject
@end


/**
 *  VM instances that this policy-based route applies to.
 */
@interface GTLRNetworkconnectivity_VirtualMachine : GTLRObject

/**
 *  Optional. A list of VM instance tags that this policy-based route applies
 *  to. VM instances that have ANY of tags specified here installs this PBR.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  Informational warning message.
 */
@interface GTLRNetworkconnectivity_Warnings : GTLRObject

/**
 *  Output only. A warning code, if applicable.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkconnectivity_Warnings_Code_ResourceBeingModified The
 *        policy-based route is being modified (e.g. created/deleted) at this
 *        time. (Value: "RESOURCE_BEING_MODIFIED")
 *    @arg @c kGTLRNetworkconnectivity_Warnings_Code_ResourceNotActive The
 *        policy-based route is not active and functioning. Common causes are
 *        that the dependent network was deleted or the resource project was
 *        turned off. (Value: "RESOURCE_NOT_ACTIVE")
 *    @arg @c kGTLRNetworkconnectivity_Warnings_Code_WarningUnspecified Default
 *        value. (Value: "WARNING_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Output only. Metadata about this warning in key: value format. The key
 *  should provides more detail on the warning being returned. For example, for
 *  warnings where there are no results in a list request for a particular zone,
 *  this key might be scope and the key value might be the zone name. Other
 *  examples might be a key indicating a deprecated resource and a suggested
 *  replacement.
 */
@property(nonatomic, strong, nullable) GTLRNetworkconnectivity_Warnings_Data *data;

/** Output only. A human-readable description of the warning code. */
@property(nonatomic, copy, nullable) NSString *warningMessage;

@end


/**
 *  Output only. Metadata about this warning in key: value format. The key
 *  should provides more detail on the warning being returned. For example, for
 *  warnings where there are no results in a list request for a particular zone,
 *  this key might be scope and the key value might be the zone name. Other
 *  examples might be a key indicating a deprecated resource and a suggested
 *  replacement.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkconnectivity_Warnings_Data : GTLRObject
@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
