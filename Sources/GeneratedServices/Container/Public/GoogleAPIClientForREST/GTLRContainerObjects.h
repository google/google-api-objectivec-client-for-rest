// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Kubernetes Engine API (container/v1)
// Description:
//   Builds and manages container-based applications, powered by the open source
//   Kubernetes technology.
// Documentation:
//   https://cloud.google.com/kubernetes-engine/docs/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRContainer_AcceleratorConfig;
@class GTLRContainer_AdditionalNodeNetworkConfig;
@class GTLRContainer_AdditionalPodNetworkConfig;
@class GTLRContainer_AdditionalPodRangesConfig;
@class GTLRContainer_AddonsConfig;
@class GTLRContainer_AdvancedDatapathObservabilityConfig;
@class GTLRContainer_AdvancedMachineFeatures;
@class GTLRContainer_AuthenticatorGroupsConfig;
@class GTLRContainer_Autopilot;
@class GTLRContainer_AutopilotCompatibilityIssue;
@class GTLRContainer_AutoprovisioningNodePoolDefaults;
@class GTLRContainer_AutoUpgradeOptions;
@class GTLRContainer_BestEffortProvisioning;
@class GTLRContainer_BigQueryDestination;
@class GTLRContainer_BinaryAuthorization;
@class GTLRContainer_BlueGreenInfo;
@class GTLRContainer_BlueGreenSettings;
@class GTLRContainer_CertificateAuthorityDomainConfig;
@class GTLRContainer_CidrBlock;
@class GTLRContainer_ClientCertificateConfig;
@class GTLRContainer_CloudRunConfig;
@class GTLRContainer_Cluster;
@class GTLRContainer_Cluster_ResourceLabels;
@class GTLRContainer_ClusterAutoscaling;
@class GTLRContainer_ClusterNetworkPerformanceConfig;
@class GTLRContainer_ClusterUpdate;
@class GTLRContainer_CompliancePostureConfig;
@class GTLRContainer_ComplianceStandard;
@class GTLRContainer_ConfidentialNodes;
@class GTLRContainer_ConfigConnectorConfig;
@class GTLRContainer_ConsumptionMeteringConfig;
@class GTLRContainer_CostManagementConfig;
@class GTLRContainer_DailyMaintenanceWindow;
@class GTLRContainer_DatabaseEncryption;
@class GTLRContainer_DConfig;
@class GTLRContainer_DefaultSnatStatus;
@class GTLRContainer_DnsCacheConfig;
@class GTLRContainer_DNSConfig;
@class GTLRContainer_EnterpriseConfig;
@class GTLRContainer_EphemeralStorageLocalSsdConfig;
@class GTLRContainer_FastSocket;
@class GTLRContainer_Filter;
@class GTLRContainer_Fleet;
@class GTLRContainer_GatewayAPIConfig;
@class GTLRContainer_GcePersistentDiskCsiDriverConfig;
@class GTLRContainer_GcfsConfig;
@class GTLRContainer_GcpFilestoreCsiDriverConfig;
@class GTLRContainer_GCPSecretManagerCertificateConfig;
@class GTLRContainer_GcsFuseCsiDriverConfig;
@class GTLRContainer_GkeBackupAgentConfig;
@class GTLRContainer_GPUDriverInstallationConfig;
@class GTLRContainer_GPUSharingConfig;
@class GTLRContainer_HorizontalPodAutoscaling;
@class GTLRContainer_HttpCacheControlResponseHeader;
@class GTLRContainer_HttpLoadBalancing;
@class GTLRContainer_HugepagesConfig;
@class GTLRContainer_IdentityServiceConfig;
@class GTLRContainer_ILBSubsettingConfig;
@class GTLRContainer_IntraNodeVisibilityConfig;
@class GTLRContainer_IPAllocationPolicy;
@class GTLRContainer_Jwk;
@class GTLRContainer_K8sBetaAPIConfig;
@class GTLRContainer_KubernetesDashboard;
@class GTLRContainer_LegacyAbac;
@class GTLRContainer_LinuxNodeConfig;
@class GTLRContainer_LinuxNodeConfig_Sysctls;
@class GTLRContainer_LocalNvmeSsdBlockConfig;
@class GTLRContainer_LoggingComponentConfig;
@class GTLRContainer_LoggingConfig;
@class GTLRContainer_LoggingVariantConfig;
@class GTLRContainer_MaintenanceExclusionOptions;
@class GTLRContainer_MaintenancePolicy;
@class GTLRContainer_MaintenanceWindow;
@class GTLRContainer_MaintenanceWindow_MaintenanceExclusions;
@class GTLRContainer_ManagedPrometheusConfig;
@class GTLRContainer_MasterAuth;
@class GTLRContainer_MasterAuthorizedNetworksConfig;
@class GTLRContainer_MaxPodsConstraint;
@class GTLRContainer_MeshCertificates;
@class GTLRContainer_Metric;
@class GTLRContainer_MonitoringComponentConfig;
@class GTLRContainer_MonitoringConfig;
@class GTLRContainer_NetworkConfig;
@class GTLRContainer_NetworkPerformanceConfig;
@class GTLRContainer_NetworkPolicy;
@class GTLRContainer_NetworkPolicyConfig;
@class GTLRContainer_NetworkTags;
@class GTLRContainer_NodeAffinity;
@class GTLRContainer_NodeConfig;
@class GTLRContainer_NodeConfig_Labels;
@class GTLRContainer_NodeConfig_Metadata;
@class GTLRContainer_NodeConfig_ResourceLabels;
@class GTLRContainer_NodeConfigDefaults;
@class GTLRContainer_NodeKubeletConfig;
@class GTLRContainer_NodeLabels;
@class GTLRContainer_NodeLabels_Labels;
@class GTLRContainer_NodeManagement;
@class GTLRContainer_NodeNetworkConfig;
@class GTLRContainer_NodePool;
@class GTLRContainer_NodePoolAutoConfig;
@class GTLRContainer_NodePoolAutoscaling;
@class GTLRContainer_NodePoolDefaults;
@class GTLRContainer_NodePoolLoggingConfig;
@class GTLRContainer_NodeTaint;
@class GTLRContainer_NodeTaints;
@class GTLRContainer_NotificationConfig;
@class GTLRContainer_Operation;
@class GTLRContainer_OperationError;
@class GTLRContainer_OperationProgress;
@class GTLRContainer_ParentProductConfig;
@class GTLRContainer_ParentProductConfig_Labels;
@class GTLRContainer_PlacementPolicy;
@class GTLRContainer_PodCIDROverprovisionConfig;
@class GTLRContainer_PrivateClusterConfig;
@class GTLRContainer_PrivateClusterMasterGlobalAccessConfig;
@class GTLRContainer_PrivateRegistryAccessConfig;
@class GTLRContainer_PubSub;
@class GTLRContainer_QueuedProvisioning;
@class GTLRContainer_RangeInfo;
@class GTLRContainer_RayClusterLoggingConfig;
@class GTLRContainer_RayClusterMonitoringConfig;
@class GTLRContainer_RayOperatorConfig;
@class GTLRContainer_RBACBindingConfig;
@class GTLRContainer_RecurringTimeWindow;
@class GTLRContainer_ReleaseChannel;
@class GTLRContainer_ReleaseChannelConfig;
@class GTLRContainer_ReservationAffinity;
@class GTLRContainer_ResourceLabels;
@class GTLRContainer_ResourceLabels_Labels;
@class GTLRContainer_ResourceLimit;
@class GTLRContainer_ResourceManagerTags;
@class GTLRContainer_ResourceManagerTags_Tags;
@class GTLRContainer_ResourceUsageExportConfig;
@class GTLRContainer_SandboxConfig;
@class GTLRContainer_SecondaryBootDisk;
@class GTLRContainer_SecondaryBootDiskUpdateStrategy;
@class GTLRContainer_SecretManagerConfig;
@class GTLRContainer_SecurityPostureConfig;
@class GTLRContainer_ServiceExternalIPsConfig;
@class GTLRContainer_SetLabelsRequest_ResourceLabels;
@class GTLRContainer_ShieldedInstanceConfig;
@class GTLRContainer_ShieldedNodes;
@class GTLRContainer_SoleTenantConfig;
@class GTLRContainer_StandardRolloutPolicy;
@class GTLRContainer_StatefulHAConfig;
@class GTLRContainer_Status;
@class GTLRContainer_Status_Details_Item;
@class GTLRContainer_StatusCondition;
@class GTLRContainer_TimeWindow;
@class GTLRContainer_UpdateInfo;
@class GTLRContainer_UpgradeSettings;
@class GTLRContainer_UsableSubnetwork;
@class GTLRContainer_UsableSubnetworkSecondaryRange;
@class GTLRContainer_VerticalPodAutoscaling;
@class GTLRContainer_VirtualNIC;
@class GTLRContainer_WindowsNodeConfig;
@class GTLRContainer_WorkloadIdentityConfig;
@class GTLRContainer_WorkloadMetadataConfig;
@class GTLRContainer_WorkloadPolicyConfig;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRContainer_AdvancedDatapathObservabilityConfig.relayMode

/**
 *  disabled
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_Disabled;
/**
 *  exposed via external load balancer
 *
 *  Value: "EXTERNAL_LB"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_ExternalLb;
/**
 *  exposed via internal load balancer
 *
 *  Value: "INTERNAL_VPC_LB"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_InternalVpcLb;
/**
 *  Default value. This shouldn't be used.
 *
 *  Value: "RELAY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_RelayModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_AutopilotCompatibilityIssue.incompatibilityType

/**
 *  Indicates the issue is an incompatibility if customers take no further
 *  action to resolve.
 *
 *  Value: "ADDITIONAL_CONFIG_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_AdditionalConfigRequired;
/**
 *  Indicates that the issue is a known incompatibility between the cluster and
 *  Autopilot mode.
 *
 *  Value: "INCOMPATIBILITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_Incompatibility;
/**
 *  Indicates the issue is not an incompatibility, but depending on the
 *  workloads business logic, there is a potential that they won't work on
 *  Autopilot.
 *
 *  Value: "PASSED_WITH_OPTIONAL_CONFIG"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_PassedWithOptionalConfig;
/**
 *  Default value, should not be used.
 *
 *  Value: "UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_Unspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_BinaryAuthorization.evaluationMode

/**
 *  Disable BinaryAuthorization
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BinaryAuthorization_EvaluationMode_Disabled;
/**
 *  Default value
 *
 *  Value: "EVALUATION_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BinaryAuthorization_EvaluationMode_EvaluationModeUnspecified;
/**
 *  Enforce Kubernetes admission requests with BinaryAuthorization using the
 *  project's singleton policy. This is equivalent to setting the enabled
 *  boolean to true.
 *
 *  Value: "PROJECT_SINGLETON_POLICY_ENFORCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BinaryAuthorization_EvaluationMode_ProjectSingletonPolicyEnforce;

// ----------------------------------------------------------------------------
// GTLRContainer_BlueGreenInfo.phase

/**
 *  Start cordoning blue pool nodes.
 *
 *  Value: "CORDONING_BLUE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_CordoningBluePool;
/**
 *  Start creating green pool nodes.
 *
 *  Value: "CREATING_GREEN_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_CreatingGreenPool;
/**
 *  Start deleting blue nodes.
 *
 *  Value: "DELETING_BLUE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_DeletingBluePool;
/**
 *  Start draining blue pool nodes.
 *
 *  Value: "DRAINING_BLUE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_DrainingBluePool;
/**
 *  Start soaking time after draining entire blue pool.
 *
 *  Value: "NODE_POOL_SOAKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_NodePoolSoaking;
/**
 *  Unspecified phase.
 *
 *  Value: "PHASE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_PhaseUnspecified;
/**
 *  Rollback has been initiated.
 *
 *  Value: "ROLLBACK_STARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_RollbackStarted;
/**
 *  blue-green upgrade has been initiated.
 *
 *  Value: "UPDATE_STARTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_BlueGreenInfo_Phase_UpdateStarted;

// ----------------------------------------------------------------------------
// GTLRContainer_CloudRunConfig.loadBalancerType

/**
 *  Install external load balancer for Cloud Run.
 *
 *  Value: "LOAD_BALANCER_TYPE_EXTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_CloudRunConfig_LoadBalancerType_LoadBalancerTypeExternal;
/**
 *  Install internal load balancer for Cloud Run.
 *
 *  Value: "LOAD_BALANCER_TYPE_INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_CloudRunConfig_LoadBalancerType_LoadBalancerTypeInternal;
/**
 *  Load balancer type for Cloud Run is unspecified.
 *
 *  Value: "LOAD_BALANCER_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_CloudRunConfig_LoadBalancerType_LoadBalancerTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_Cluster.status

/**
 *  The DEGRADED state indicates the cluster requires user action to restore
 *  full functionality. Details can be found in the `statusMessage` field.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_Degraded;
/**
 *  The ERROR state indicates the cluster is unusable. It will be automatically
 *  deleted. Details can be found in the `statusMessage` field.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_Error;
/**
 *  The PROVISIONING state indicates the cluster is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_Provisioning;
/**
 *  The RECONCILING state indicates that some work is actively being done on the
 *  cluster, such as upgrading the master or node software. Details can be found
 *  in the `statusMessage` field.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_Reconciling;
/**
 *  The RUNNING state indicates the cluster has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_Running;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_StatusUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Cluster_Status_Stopping;

// ----------------------------------------------------------------------------
// GTLRContainer_ClusterAutoscaling.autoscalingProfile

/**
 *  Use default (balanced) autoscaling configuration.
 *
 *  Value: "BALANCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterAutoscaling_AutoscalingProfile_Balanced;
/**
 *  Prioritize optimizing utilization of resources.
 *
 *  Value: "OPTIMIZE_UTILIZATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterAutoscaling_AutoscalingProfile_OptimizeUtilization;
/**
 *  No change to autoscaling configuration.
 *
 *  Value: "PROFILE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterAutoscaling_AutoscalingProfile_ProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_ClusterNetworkPerformanceConfig.totalEgressBandwidthTier

/**
 *  Higher bandwidth, actual values based on VM size.
 *
 *  Value: "TIER_1"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterNetworkPerformanceConfig_TotalEgressBandwidthTier_Tier1;
/**
 *  Default value
 *
 *  Value: "TIER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterNetworkPerformanceConfig_TotalEgressBandwidthTier_TierUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_ClusterUpdate.desiredDatapathProvider

/**
 *  Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE
 *  Dataplane V2
 *  documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
 *  for more.
 *
 *  Value: "ADVANCED_DATAPATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredDatapathProvider_AdvancedDatapath;
/**
 *  Default value.
 *
 *  Value: "DATAPATH_PROVIDER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredDatapathProvider_DatapathProviderUnspecified;
/**
 *  Use the IPTables implementation based on kube-proxy.
 *
 *  Value: "LEGACY_DATAPATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredDatapathProvider_LegacyDatapath;

// ----------------------------------------------------------------------------
// GTLRContainer_ClusterUpdate.desiredInTransitEncryptionConfig

/**
 *  Unspecified, will be inferred as default -
 *  IN_TRANSIT_ENCRYPTION_UNSPECIFIED.
 *
 *  Value: "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredInTransitEncryptionConfig_InTransitEncryptionConfigUnspecified;
/**
 *  In-transit encryption is disabled.
 *
 *  Value: "IN_TRANSIT_ENCRYPTION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredInTransitEncryptionConfig_InTransitEncryptionDisabled;
/**
 *  Data in-transit is encrypted using inter-node transparent encryption.
 *
 *  Value: "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredInTransitEncryptionConfig_InTransitEncryptionInterNodeTransparent;

// ----------------------------------------------------------------------------
// GTLRContainer_ClusterUpdate.desiredPrivateIpv6GoogleAccess

/**
 *  Enables private IPv6 access to and from Google Services
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessBidirectional;
/**
 *  No private access to or from Google Services
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessDisabled;
/**
 *  Enables private IPv6 access to Google Services from GKE
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessToGoogle;
/**
 *  Default value. Same as DISABLED
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_ClusterUpdate.desiredStackType

/**
 *  Cluster is IPV4 only
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredStackType_Ipv4;
/**
 *  Cluster can use both IPv4 and IPv6
 *
 *  Value: "IPV4_IPV6"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredStackType_Ipv4Ipv6;
/**
 *  Default value, will be defaulted as IPV4 only
 *
 *  Value: "STACK_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ClusterUpdate_DesiredStackType_StackTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_CompliancePostureConfig.mode

/**
 *  Disables Compliance Posture features on the cluster.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_CompliancePostureConfig_Mode_Disabled;
/**
 *  Enables Compliance Posture features on the cluster.
 *
 *  Value: "ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_CompliancePostureConfig_Mode_Enabled;
/**
 *  Default value not specified.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_CompliancePostureConfig_Mode_ModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_DatabaseEncryption.currentState

/**
 *  Secrets in etcd are stored in plain text (at etcd level) - this is unrelated
 *  to Compute Engine level full disk encryption.
 *
 *  Value: "CURRENT_STATE_DECRYPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateDecrypted;
/**
 *  De-crypting Secrets to plain text in etcd encountered an error.
 *
 *  Value: "CURRENT_STATE_DECRYPTION_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateDecryptionError;
/**
 *  De-crypting Secrets to plain text in etcd is in progress.
 *
 *  Value: "CURRENT_STATE_DECRYPTION_PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateDecryptionPending;
/**
 *  Secrets in etcd are encrypted.
 *
 *  Value: "CURRENT_STATE_ENCRYPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateEncrypted;
/**
 *  Encryption (or re-encryption with a different CloudKMS key) of Secrets in
 *  etcd encountered an error.
 *
 *  Value: "CURRENT_STATE_ENCRYPTION_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateEncryptionError;
/**
 *  Encryption (or re-encryption with a different CloudKMS key) of Secrets is in
 *  progress.
 *
 *  Value: "CURRENT_STATE_ENCRYPTION_PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateEncryptionPending;
/**
 *  Should never be set
 *
 *  Value: "CURRENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_DatabaseEncryption.state

/**
 *  Secrets in etcd are stored in plain text (at etcd level) - this is unrelated
 *  to Compute Engine level full disk encryption.
 *
 *  Value: "DECRYPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_State_Decrypted;
/**
 *  Secrets in etcd are encrypted.
 *
 *  Value: "ENCRYPTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_State_Encrypted;
/**
 *  Should never be set
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DatabaseEncryption_State_Unknown;

// ----------------------------------------------------------------------------
// GTLRContainer_DNSConfig.clusterDns

/**
 *  Use CloudDNS for DNS resolution.
 *
 *  Value: "CLOUD_DNS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDns_CloudDns;
/**
 *  Use KubeDNS for DNS resolution.
 *
 *  Value: "KUBE_DNS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDns_KubeDns;
/**
 *  Use GKE default DNS provider(kube-dns) for DNS resolution.
 *
 *  Value: "PLATFORM_DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDns_PlatformDefault;
/**
 *  Default value
 *
 *  Value: "PROVIDER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDns_ProviderUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_DNSConfig.clusterDnsScope

/**
 *  DNS records are accessible from within the cluster.
 *
 *  Value: "CLUSTER_SCOPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDnsScope_ClusterScope;
/**
 *  Default value, will be inferred as cluster scope.
 *
 *  Value: "DNS_SCOPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDnsScope_DnsScopeUnspecified;
/**
 *  DNS records are accessible from within the VPC.
 *
 *  Value: "VPC_SCOPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_DNSConfig_ClusterDnsScope_VpcScope;

// ----------------------------------------------------------------------------
// GTLRContainer_EnterpriseConfig.clusterTier

/**
 *  CLUSTER_TIER_UNSPECIFIED is when cluster_tier is not set.
 *
 *  Value: "CLUSTER_TIER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_EnterpriseConfig_ClusterTier_ClusterTierUnspecified;
/**
 *  ENTERPRISE indicates a GKE Enterprise cluster.
 *
 *  Value: "ENTERPRISE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_EnterpriseConfig_ClusterTier_Enterprise;
/**
 *  STANDARD indicates a standard GKE cluster.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_EnterpriseConfig_ClusterTier_Standard;

// ----------------------------------------------------------------------------
// GTLRContainer_Filter.eventType

/**
 *  Not set, will be ignored.
 *
 *  Value: "EVENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Filter_EventType_EventTypeUnspecified;
/**
 *  Corresponds with SecurityBulletinEvent.
 *
 *  Value: "SECURITY_BULLETIN_EVENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Filter_EventType_SecurityBulletinEvent;
/**
 *  Corresponds with UpgradeAvailableEvent.
 *
 *  Value: "UPGRADE_AVAILABLE_EVENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Filter_EventType_UpgradeAvailableEvent;
/**
 *  Corresponds with UpgradeEvent.
 *
 *  Value: "UPGRADE_EVENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Filter_EventType_UpgradeEvent;

// ----------------------------------------------------------------------------
// GTLRContainer_GatewayAPIConfig.channel

/**
 *  Gateway API support is disabled
 *
 *  Value: "CHANNEL_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GatewayAPIConfig_Channel_ChannelDisabled;
/**
 *  Deprecated: use CHANNEL_STANDARD instead. Gateway API support is enabled,
 *  experimental CRDs are installed
 *
 *  Value: "CHANNEL_EXPERIMENTAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GatewayAPIConfig_Channel_ChannelExperimental GTLR_DEPRECATED;
/**
 *  Gateway API support is enabled, standard CRDs are installed
 *
 *  Value: "CHANNEL_STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GatewayAPIConfig_Channel_ChannelStandard;
/**
 *  Default value.
 *
 *  Value: "CHANNEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GatewayAPIConfig_Channel_ChannelUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_GPUDriverInstallationConfig.gpuDriverVersion

/**
 *  "Default" GPU driver in COS and Ubuntu.
 *
 *  Value: "DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_Default;
/**
 *  Default value is to not install any GPU driver.
 *
 *  Value: "GPU_DRIVER_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_GpuDriverVersionUnspecified;
/**
 *  Disable GPU driver auto installation and needs manual installation
 *
 *  Value: "INSTALLATION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_InstallationDisabled;
/**
 *  "Latest" GPU driver in COS.
 *
 *  Value: "LATEST"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_Latest;

// ----------------------------------------------------------------------------
// GTLRContainer_GPUSharingConfig.gpuSharingStrategy

/**
 *  Default value.
 *
 *  Value: "GPU_SHARING_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUSharingConfig_GpuSharingStrategy_GpuSharingStrategyUnspecified;
/**
 *  GPUs are shared between containers with NVIDIA MPS.
 *
 *  Value: "MPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUSharingConfig_GpuSharingStrategy_Mps;
/**
 *  GPUs are time-shared between containers.
 *
 *  Value: "TIME_SHARING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_GPUSharingConfig_GpuSharingStrategy_TimeSharing;

// ----------------------------------------------------------------------------
// GTLRContainer_IPAllocationPolicy.ipv6AccessType

/**
 *  Access type external (all v6 addresses are external IPs)
 *
 *  Value: "EXTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_IPAllocationPolicy_Ipv6AccessType_External;
/**
 *  Access type internal (all v6 addresses are internal IPs)
 *
 *  Value: "INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_IPAllocationPolicy_Ipv6AccessType_Internal;
/**
 *  Default value, will be defaulted as type external.
 *
 *  Value: "IPV6_ACCESS_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_IPAllocationPolicy_Ipv6AccessType_Ipv6AccessTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_IPAllocationPolicy.stackType

/**
 *  Cluster is IPV4 only
 *
 *  Value: "IPV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_IPAllocationPolicy_StackType_Ipv4;
/**
 *  Cluster can use both IPv4 and IPv6
 *
 *  Value: "IPV4_IPV6"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_IPAllocationPolicy_StackType_Ipv4Ipv6;
/**
 *  Default value, will be defaulted as IPV4 only
 *
 *  Value: "STACK_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_IPAllocationPolicy_StackType_StackTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_LinuxNodeConfig.cgroupMode

/**
 *  CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
 *  The default for the GKE node OS image will be used.
 *
 *  Value: "CGROUP_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LinuxNodeConfig_CgroupMode_CgroupModeUnspecified;
/**
 *  CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on the
 *  node image.
 *
 *  Value: "CGROUP_MODE_V1"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LinuxNodeConfig_CgroupMode_CgroupModeV1;
/**
 *  CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on the
 *  node image.
 *
 *  Value: "CGROUP_MODE_V2"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LinuxNodeConfig_CgroupMode_CgroupModeV2;

// ----------------------------------------------------------------------------
// GTLRContainer_LoggingComponentConfig.enableComponents

/**
 *  kube-apiserver
 *
 *  Value: "APISERVER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingComponentConfig_EnableComponents_Apiserver;
/**
 *  Default value. This shouldn't be used.
 *
 *  Value: "COMPONENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingComponentConfig_EnableComponents_ComponentUnspecified;
/**
 *  kube-controller-manager
 *
 *  Value: "CONTROLLER_MANAGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingComponentConfig_EnableComponents_ControllerManager;
/**
 *  kube-scheduler
 *
 *  Value: "SCHEDULER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingComponentConfig_EnableComponents_Scheduler;
/**
 *  system components
 *
 *  Value: "SYSTEM_COMPONENTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingComponentConfig_EnableComponents_SystemComponents;
/**
 *  workloads
 *
 *  Value: "WORKLOADS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingComponentConfig_EnableComponents_Workloads;

// ----------------------------------------------------------------------------
// GTLRContainer_LoggingVariantConfig.variant

/**
 *  default logging variant.
 *
 *  Value: "DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingVariantConfig_Variant_Default;
/**
 *  maximum logging throughput variant.
 *
 *  Value: "MAX_THROUGHPUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingVariantConfig_Variant_MaxThroughput;
/**
 *  Default value. This shouldn't be used.
 *
 *  Value: "VARIANT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_LoggingVariantConfig_Variant_VariantUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_MaintenanceExclusionOptions.scope

/**
 *  NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster, and
 *  also exclude all node pool upgrades. Only control plane patches are allowed.
 *
 *  Value: "NO_MINOR_OR_NODE_UPGRADES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MaintenanceExclusionOptions_Scope_NoMinorOrNodeUpgrades;
/**
 *  NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only patches
 *  are allowed.
 *
 *  Value: "NO_MINOR_UPGRADES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MaintenanceExclusionOptions_Scope_NoMinorUpgrades;
/**
 *  NO_UPGRADES excludes all upgrades, including patch upgrades and minor
 *  upgrades across control planes and nodes. This is the default exclusion
 *  behavior.
 *
 *  Value: "NO_UPGRADES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MaintenanceExclusionOptions_Scope_NoUpgrades;

// ----------------------------------------------------------------------------
// GTLRContainer_MonitoringComponentConfig.enableComponents

/**
 *  kube-apiserver
 *
 *  Value: "APISERVER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Apiserver;
/**
 *  CADVISOR
 *
 *  Value: "CADVISOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Cadvisor;
/**
 *  Default value. This shouldn't be used.
 *
 *  Value: "COMPONENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_ComponentUnspecified;
/**
 *  kube-controller-manager
 *
 *  Value: "CONTROLLER_MANAGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_ControllerManager;
/**
 *  DaemonSet
 *
 *  Value: "DAEMONSET"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Daemonset;
/**
 *  NVIDIA Data Center GPU Manager (DCGM)
 *
 *  Value: "DCGM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Dcgm;
/**
 *  Deployment
 *
 *  Value: "DEPLOYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Deployment;
/**
 *  Horizontal Pod Autoscaling
 *
 *  Value: "HPA"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Hpa;
/**
 *  KUBELET
 *
 *  Value: "KUBELET"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Kubelet;
/**
 *  Pod
 *
 *  Value: "POD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Pod;
/**
 *  kube-scheduler
 *
 *  Value: "SCHEDULER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Scheduler;
/**
 *  Statefulset
 *
 *  Value: "STATEFULSET"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Statefulset;
/**
 *  Storage
 *
 *  Value: "STORAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_Storage;
/**
 *  system components
 *
 *  Value: "SYSTEM_COMPONENTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_MonitoringComponentConfig_EnableComponents_SystemComponents;

// ----------------------------------------------------------------------------
// GTLRContainer_NetworkConfig.datapathProvider

/**
 *  Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE
 *  Dataplane V2
 *  documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
 *  for more.
 *
 *  Value: "ADVANCED_DATAPATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_DatapathProvider_AdvancedDatapath;
/**
 *  Default value.
 *
 *  Value: "DATAPATH_PROVIDER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_DatapathProvider_DatapathProviderUnspecified;
/**
 *  Use the IPTables implementation based on kube-proxy.
 *
 *  Value: "LEGACY_DATAPATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_DatapathProvider_LegacyDatapath;

// ----------------------------------------------------------------------------
// GTLRContainer_NetworkConfig.inTransitEncryptionConfig

/**
 *  Unspecified, will be inferred as default -
 *  IN_TRANSIT_ENCRYPTION_UNSPECIFIED.
 *
 *  Value: "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_InTransitEncryptionConfig_InTransitEncryptionConfigUnspecified;
/**
 *  In-transit encryption is disabled.
 *
 *  Value: "IN_TRANSIT_ENCRYPTION_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_InTransitEncryptionConfig_InTransitEncryptionDisabled;
/**
 *  Data in-transit is encrypted using inter-node transparent encryption.
 *
 *  Value: "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_InTransitEncryptionConfig_InTransitEncryptionInterNodeTransparent;

// ----------------------------------------------------------------------------
// GTLRContainer_NetworkConfig.privateIpv6GoogleAccess

/**
 *  Enables private IPv6 access to and from Google Services
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessBidirectional;
/**
 *  No private access to or from Google Services
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessDisabled;
/**
 *  Enables private IPv6 access to Google Services from GKE
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessToGoogle;
/**
 *  Default value. Same as DISABLED
 *
 *  Value: "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_NetworkPerformanceConfig.totalEgressBandwidthTier

/**
 *  Higher bandwidth, actual values based on VM size.
 *
 *  Value: "TIER_1"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkPerformanceConfig_TotalEgressBandwidthTier_Tier1;
/**
 *  Default value
 *
 *  Value: "TIER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkPerformanceConfig_TotalEgressBandwidthTier_TierUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_NetworkPolicy.provider

/**
 *  Tigera (Calico Felix).
 *
 *  Value: "CALICO"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkPolicy_Provider_Calico;
/**
 *  Not set
 *
 *  Value: "PROVIDER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NetworkPolicy_Provider_ProviderUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_NodeAffinity.operatorProperty

/**
 *  Affinity operator.
 *
 *  Value: "IN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeAffinity_OperatorProperty_In;
/**
 *  Anti-affinity operator.
 *
 *  Value: "NOT_IN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeAffinity_OperatorProperty_NotIn;
/**
 *  Invalid or unspecified affinity operator.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeAffinity_OperatorProperty_OperatorUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_NodePool.status

/**
 *  The ERROR state indicates the node pool may be unusable. Details can be
 *  found in the `statusMessage` field.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_Error;
/**
 *  The PROVISIONING state indicates the node pool is being created.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_Provisioning;
/**
 *  The RECONCILING state indicates that some work is actively being done on the
 *  node pool, such as upgrading node software. Details can be found in the
 *  `statusMessage` field.
 *
 *  Value: "RECONCILING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_Reconciling;
/**
 *  The RUNNING state indicates the node pool has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_Running;
/**
 *  The RUNNING_WITH_ERROR state indicates the node pool has been created and is
 *  partially usable. Some error state has occurred and some functionality may
 *  be impaired. Customer may need to reissue a request or trigger a new update.
 *
 *  Value: "RUNNING_WITH_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_RunningWithError;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_StatusUnspecified;
/**
 *  The STOPPING state indicates the node pool is being deleted.
 *
 *  Value: "STOPPING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePool_Status_Stopping;

// ----------------------------------------------------------------------------
// GTLRContainer_NodePoolAutoscaling.locationPolicy

/**
 *  ANY policy picks zones that have the highest capacity available.
 *
 *  Value: "ANY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePoolAutoscaling_LocationPolicy_Any;
/**
 *  BALANCED is a best effort policy that aims to balance the sizes of different
 *  zones.
 *
 *  Value: "BALANCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePoolAutoscaling_LocationPolicy_Balanced;
/**
 *  Not set.
 *
 *  Value: "LOCATION_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodePoolAutoscaling_LocationPolicy_LocationPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_NodeTaint.effect

/**
 *  Not set
 *
 *  Value: "EFFECT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeTaint_Effect_EffectUnspecified;
/**
 *  NoExecute
 *
 *  Value: "NO_EXECUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeTaint_Effect_NoExecute;
/**
 *  NoSchedule
 *
 *  Value: "NO_SCHEDULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeTaint_Effect_NoSchedule;
/**
 *  PreferNoSchedule
 *
 *  Value: "PREFER_NO_SCHEDULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_NodeTaint_Effect_PreferNoSchedule;

// ----------------------------------------------------------------------------
// GTLRContainer_Operation.operationType

/**
 *  A problem has been detected with nodes and [they are being
 *  repaired](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair).
 *  This operation type is initiated by GKE, typically automatically. This
 *  operation may be concurrent with other operations and there may be multiple
 *  repairs occurring on the same node pool.
 *
 *  Value: "AUTO_REPAIR_NODES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_AutoRepairNodes;
/**
 *  Unused. Automatic node upgrade uses UPGRADE_NODES.
 *
 *  Value: "AUTO_UPGRADE_NODES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_AutoUpgradeNodes GTLR_DEPRECATED;
/**
 *  The cluster is being created. The cluster should be assumed to be unusable
 *  until the operation finishes. In the event of the operation failing, the
 *  cluster will enter the ERROR state and eventually be deleted.
 *
 *  Value: "CREATE_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_CreateCluster;
/**
 *  A node pool is being created. The node pool should be assumed to be unusable
 *  until this operation finishes. In the event of an error, the node pool may
 *  be partially created. If enabled, [node
 *  autoprovisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
 *  may have automatically initiated such operations.
 *
 *  Value: "CREATE_NODE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_CreateNodePool;
/**
 *  The cluster is being deleted. The cluster should be assumed to be unusable
 *  as soon as this operation starts. In the event of the operation failing, the
 *  cluster will enter the ERROR state and the deletion will be automatically
 *  retried until completed.
 *
 *  Value: "DELETE_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_DeleteCluster;
/**
 *  The node pool is being deleted. The node pool should be assumed to be
 *  unusable as soon as this operation starts.
 *
 *  Value: "DELETE_NODE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_DeleteNodePool;
/**
 *  Fleet features of GKE Enterprise are being upgraded. The cluster should be
 *  assumed to be blocked for other upgrades until the operation finishes.
 *
 *  Value: "FLEET_FEATURE_UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_FleetFeatureUpgrade;
/**
 *  A problem has been detected with the control plane and is being repaired.
 *  This operation type is initiated by GKE. For more details, see
 *  [documentation on
 *  repairs](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
 *
 *  Value: "REPAIR_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_RepairCluster;
/**
 *  The control plane is being resized. This operation type is initiated by GKE.
 *  These operations are often performed preemptively to ensure that the control
 *  plane has sufficient resources and is not typically an indication of issues.
 *  For more details, see [documentation on
 *  resizes](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
 *
 *  Value: "RESIZE_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_ResizeCluster;
/**
 *  Unused. Updating labels uses UPDATE_CLUSTER.
 *
 *  Value: "SET_LABELS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetLabels GTLR_DEPRECATED;
/**
 *  Unused. Updating maintenance policy uses UPDATE_CLUSTER.
 *
 *  Value: "SET_MAINTENANCE_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetMaintenancePolicy GTLR_DEPRECATED;
/**
 *  Unused. Updating master auth uses UPDATE_CLUSTER.
 *
 *  Value: "SET_MASTER_AUTH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetMasterAuth GTLR_DEPRECATED;
/**
 *  Unused. Updating network policy uses UPDATE_CLUSTER.
 *
 *  Value: "SET_NETWORK_POLICY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetNetworkPolicy GTLR_DEPRECATED;
/**
 *  The node pool's manamagent field is being updated. These operations only
 *  update metadata and may be concurrent with most other operations.
 *
 *  Value: "SET_NODE_POOL_MANAGEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetNodePoolManagement;
/**
 *  The node pool is being resized. With the exception of resizing to or from
 *  size zero, the node pool is generally usable during this operation.
 *
 *  Value: "SET_NODE_POOL_SIZE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetNodePoolSize;
/**
 *  Not set.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_TypeUnspecified;
/**
 *  The cluster is being updated. This is a broad category of operations and
 *  includes operations that only change metadata as well as those that must
 *  recreate the entire cluster. If the control plane must be recreated, this
 *  will cause temporary downtime for zonal clusters. Some features require
 *  recreating the nodes as well. Those will be recreated as separate operations
 *  and the update may not be completely functional until the node pools
 *  recreations finish. Node recreations will generally follow [maintenance
 *  policies](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions).
 *  Some GKE-initiated operations use this type. This includes certain types of
 *  auto-upgrades and incident mitigations.
 *
 *  Value: "UPDATE_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_UpdateCluster;
/**
 *  The cluster version is being updated. Note that this includes "upgrades" to
 *  the same version, which are simply a recreation. This also includes
 *  [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#upgrading_automatically).
 *  For more details, see [documentation on cluster
 *  upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#cluster_upgrades).
 *
 *  Value: "UPGRADE_MASTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_UpgradeMaster;
/**
 *  A node pool is being updated. Despite calling this an "upgrade", this
 *  includes most forms of updates to node pools. This also includes
 *  [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades).
 *  This operation sets the progress field and may be canceled. The upgrade
 *  strategy depends on [node pool
 *  configuration](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies).
 *  The nodes are generally still usable during this operation.
 *
 *  Value: "UPGRADE_NODES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_OperationType_UpgradeNodes;

// ----------------------------------------------------------------------------
// GTLRContainer_Operation.status

/**
 *  The operation is aborting.
 *
 *  Value: "ABORTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_Status_Aborting;
/**
 *  The operation is done, either cancelled or completed.
 *
 *  Value: "DONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_Status_Done;
/**
 *  The operation has been created.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_Status_Pending;
/**
 *  The operation is currently running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_Status_Running;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_Operation_Status_StatusUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_OperationProgress.status

/**
 *  The operation is aborting.
 *
 *  Value: "ABORTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_OperationProgress_Status_Aborting;
/**
 *  The operation is done, either cancelled or completed.
 *
 *  Value: "DONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_OperationProgress_Status_Done;
/**
 *  The operation has been created.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_OperationProgress_Status_Pending;
/**
 *  The operation is currently running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_OperationProgress_Status_Running;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_OperationProgress_Status_StatusUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_PlacementPolicy.type

/**
 *  COMPACT specifies node placement in the same availability domain to ensure
 *  low communication latency.
 *
 *  Value: "COMPACT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_PlacementPolicy_Type_Compact;
/**
 *  TYPE_UNSPECIFIED specifies no requirements on nodes placement.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_PlacementPolicy_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_ReleaseChannel.channel

/**
 *  Clusters subscribed to EXTENDED receive extended support and availability
 *  for versions which are known to be stable and reliable in production.
 *
 *  Value: "EXTENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannel_Channel_Extended;
/**
 *  RAPID channel is offered on an early access basis for customers who want to
 *  test new releases. WARNING: Versions available in the RAPID Channel may be
 *  subject to unresolved issues with no known workaround and are not subject to
 *  any SLAs.
 *
 *  Value: "RAPID"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannel_Channel_Rapid;
/**
 *  Clusters subscribed to REGULAR receive versions that are considered GA
 *  quality. REGULAR is intended for production users who want to take advantage
 *  of new features.
 *
 *  Value: "REGULAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannel_Channel_Regular;
/**
 *  Clusters subscribed to STABLE receive versions that are known to be stable
 *  and reliable in production.
 *
 *  Value: "STABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannel_Channel_Stable;
/**
 *  No channel specified.
 *
 *  Value: "UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannel_Channel_Unspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_ReleaseChannelConfig.channel

/**
 *  Clusters subscribed to EXTENDED receive extended support and availability
 *  for versions which are known to be stable and reliable in production.
 *
 *  Value: "EXTENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannelConfig_Channel_Extended;
/**
 *  RAPID channel is offered on an early access basis for customers who want to
 *  test new releases. WARNING: Versions available in the RAPID Channel may be
 *  subject to unresolved issues with no known workaround and are not subject to
 *  any SLAs.
 *
 *  Value: "RAPID"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannelConfig_Channel_Rapid;
/**
 *  Clusters subscribed to REGULAR receive versions that are considered GA
 *  quality. REGULAR is intended for production users who want to take advantage
 *  of new features.
 *
 *  Value: "REGULAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannelConfig_Channel_Regular;
/**
 *  Clusters subscribed to STABLE receive versions that are known to be stable
 *  and reliable in production.
 *
 *  Value: "STABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannelConfig_Channel_Stable;
/**
 *  No channel specified.
 *
 *  Value: "UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReleaseChannelConfig_Channel_Unspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_ReservationAffinity.consumeReservationType

/**
 *  Consume any reservation available.
 *
 *  Value: "ANY_RESERVATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReservationAffinity_ConsumeReservationType_AnyReservation;
/**
 *  Do not consume from any reserved capacity.
 *
 *  Value: "NO_RESERVATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReservationAffinity_ConsumeReservationType_NoReservation;
/**
 *  Must consume from a specific reservation. Must specify key value fields for
 *  specifying the reservations.
 *
 *  Value: "SPECIFIC_RESERVATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReservationAffinity_ConsumeReservationType_SpecificReservation;
/**
 *  Default value. This should not be used.
 *
 *  Value: "UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_ReservationAffinity_ConsumeReservationType_Unspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_SandboxConfig.type

/**
 *  Run sandbox using gvisor.
 *
 *  Value: "GVISOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SandboxConfig_Type_Gvisor;
/**
 *  Default value. This should not be used.
 *
 *  Value: "UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SandboxConfig_Type_Unspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_SecondaryBootDisk.mode

/**
 *  CONTAINER_IMAGE_CACHE is for using the secondary boot disk as a container
 *  image cache.
 *
 *  Value: "CONTAINER_IMAGE_CACHE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecondaryBootDisk_Mode_ContainerImageCache;
/**
 *  MODE_UNSPECIFIED is when mode is not set.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecondaryBootDisk_Mode_ModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_SecurityPostureConfig.mode

/**
 *  Applies Security Posture features on the cluster.
 *
 *  Value: "BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_Mode_Basic;
/**
 *  Disables Security Posture features on the cluster.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_Mode_Disabled;
/**
 *  Applies the Security Posture off cluster Enterprise level features.
 *
 *  Value: "ENTERPRISE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_Mode_Enterprise;
/**
 *  Default value not specified.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_Mode_ModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_SecurityPostureConfig.vulnerabilityMode

/**
 *  Applies basic vulnerability scanning on the cluster.
 *
 *  Value: "VULNERABILITY_BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityBasic;
/**
 *  Disables vulnerability scanning on the cluster.
 *
 *  Value: "VULNERABILITY_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityDisabled;
/**
 *  Applies the Security Posture's vulnerability on cluster Enterprise level
 *  features.
 *
 *  Value: "VULNERABILITY_ENTERPRISE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityEnterprise;
/**
 *  Default value not specified.
 *
 *  Value: "VULNERABILITY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_SetMasterAuthRequest.action

/**
 *  Generate a new password and set it to that.
 *
 *  Value: "GENERATE_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_GeneratePassword;
/**
 *  Set the password to a user generated value.
 *
 *  Value: "SET_PASSWORD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_SetPassword;
/**
 *  Set the username. If an empty username is provided, basic authentication is
 *  disabled for the cluster. If a non-empty username is provided, basic
 *  authentication is enabled, with either a provided password or a generated
 *  one.
 *
 *  Value: "SET_USERNAME"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_SetUsername;
/**
 *  Operation is unknown and will error out.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_Unknown;

// ----------------------------------------------------------------------------
// GTLRContainer_StatusCondition.canonicalCode

/**
 *  The operation was aborted, typically due to a concurrency issue such as a
 *  sequencer check failure or transaction abort. See the guidelines above for
 *  deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP
 *  Mapping: 409 Conflict
 *
 *  Value: "ABORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Aborted;
/**
 *  The entity that a client attempted to create (e.g., file or directory)
 *  already exists. HTTP Mapping: 409 Conflict
 *
 *  Value: "ALREADY_EXISTS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_AlreadyExists;
/**
 *  The operation was cancelled, typically by the caller. HTTP Mapping: 499
 *  Client Closed Request
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Cancelled;
/**
 *  Unrecoverable data loss or corruption. HTTP Mapping: 500 Internal Server
 *  Error
 *
 *  Value: "DATA_LOSS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_DataLoss;
/**
 *  The deadline expired before the operation could complete. For operations
 *  that change the state of the system, this error may be returned even if the
 *  operation has completed successfully. For example, a successful response
 *  from a server could have been delayed long enough for the deadline to
 *  expire. HTTP Mapping: 504 Gateway Timeout
 *
 *  Value: "DEADLINE_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_DeadlineExceeded;
/**
 *  The operation was rejected because the system is not in a state required for
 *  the operation's execution. For example, the directory to be deleted is
 *  non-empty, an rmdir operation is applied to a non-directory, etc. Service
 *  implementors can use the following guidelines to decide between
 *  `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE`
 *  if the client can retry just the failing call. (b) Use `ABORTED` if the
 *  client should retry at a higher level. For example, when a client-specified
 *  test-and-set fails, indicating the client should restart a read-modify-write
 *  sequence. (c) Use `FAILED_PRECONDITION` if the client should not retry until
 *  the system state has been explicitly fixed. For example, if an "rmdir" fails
 *  because the directory is non-empty, `FAILED_PRECONDITION` should be returned
 *  since the client should not retry unless the files are deleted from the
 *  directory. HTTP Mapping: 400 Bad Request
 *
 *  Value: "FAILED_PRECONDITION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_FailedPrecondition;
/**
 *  Internal errors. This means that some invariants expected by the underlying
 *  system have been broken. This error code is reserved for serious errors.
 *  HTTP Mapping: 500 Internal Server Error
 *
 *  Value: "INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Internal;
/**
 *  The client specified an invalid argument. Note that this differs from
 *  `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are
 *  problematic regardless of the state of the system (e.g., a malformed file
 *  name). HTTP Mapping: 400 Bad Request
 *
 *  Value: "INVALID_ARGUMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_InvalidArgument;
/**
 *  Some requested entity (e.g., file or directory) was not found. Note to
 *  server developers: if a request is denied for an entire class of users, such
 *  as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be
 *  used. If a request is denied for some users within a class of users, such as
 *  user-based access control, `PERMISSION_DENIED` must be used. HTTP Mapping:
 *  404 Not Found
 *
 *  Value: "NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_NotFound;
/**
 *  Not an error; returned on success. HTTP Mapping: 200 OK
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Ok;
/**
 *  The operation was attempted past the valid range. E.g., seeking or reading
 *  past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem
 *  that may be fixed if the system state changes. For example, a 32-bit file
 *  system will generate `INVALID_ARGUMENT` if asked to read at an offset that
 *  is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked
 *  to read from an offset past the current file size. There is a fair bit of
 *  overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using
 *  `OUT_OF_RANGE` (the more specific error) when it applies so that callers who
 *  are iterating through a space can easily look for an `OUT_OF_RANGE` error to
 *  detect when they are done. HTTP Mapping: 400 Bad Request
 *
 *  Value: "OUT_OF_RANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_OutOfRange;
/**
 *  The caller does not have permission to execute the specified operation.
 *  `PERMISSION_DENIED` must not be used for rejections caused by exhausting
 *  some resource (use `RESOURCE_EXHAUSTED` instead for those errors).
 *  `PERMISSION_DENIED` must not be used if the caller can not be identified
 *  (use `UNAUTHENTICATED` instead for those errors). This error code does not
 *  imply the request is valid or the requested entity exists or satisfies other
 *  pre-conditions. HTTP Mapping: 403 Forbidden
 *
 *  Value: "PERMISSION_DENIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_PermissionDenied;
/**
 *  Some resource has been exhausted, perhaps a per-user quota, or perhaps the
 *  entire file system is out of space. HTTP Mapping: 429 Too Many Requests
 *
 *  Value: "RESOURCE_EXHAUSTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_ResourceExhausted;
/**
 *  The request does not have valid authentication credentials for the
 *  operation. HTTP Mapping: 401 Unauthorized
 *
 *  Value: "UNAUTHENTICATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Unauthenticated;
/**
 *  The service is currently unavailable. This is most likely a transient
 *  condition, which can be corrected by retrying with a backoff. Note that it
 *  is not always safe to retry non-idempotent operations. See the guidelines
 *  above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and
 *  `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
 *
 *  Value: "UNAVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Unavailable;
/**
 *  The operation is not implemented or is not supported/enabled in this
 *  service. HTTP Mapping: 501 Not Implemented
 *
 *  Value: "UNIMPLEMENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Unimplemented;
/**
 *  Unknown error. For example, this error may be returned when a `Status` value
 *  received from another address space belongs to an error space that is not
 *  known in this address space. Also errors raised by APIs that do not return
 *  enough error information may be converted to this error. HTTP Mapping: 500
 *  Internal Server Error
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_CanonicalCode_Unknown;

// ----------------------------------------------------------------------------
// GTLRContainer_StatusCondition.code

/**
 *  Cluster CA is expiring soon.
 *
 *  Value: "CA_EXPIRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_CaExpiring;
/**
 *  Unable to perform an encrypt operation against the CloudKMS key used for
 *  etcd level encryption.
 *
 *  Value: "CLOUD_KMS_KEY_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_CloudKmsKeyError;
/**
 *  Google Compute Engine quota was exceeded.
 *
 *  Value: "GCE_QUOTA_EXCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_GceQuotaExceeded;
/**
 *  GCE_STOCKOUT indicates that Google Compute Engine resources are temporarily
 *  unavailable.
 *
 *  Value: "GCE_STOCKOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_GceStockout;
/**
 *  GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
 *  service account.
 *
 *  Value: "GKE_SERVICE_ACCOUNT_DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_GkeServiceAccountDeleted;
/**
 *  Cluster state was manually changed by an SRE due to a system logic error.
 *
 *  Value: "SET_BY_OPERATOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_SetByOperator;
/**
 *  UNKNOWN indicates a generic condition.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_StatusCondition_Code_Unknown;

// ----------------------------------------------------------------------------
// GTLRContainer_UpgradeAvailableEvent.resourceType

/**
 *  Master / control plane
 *
 *  Value: "MASTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeAvailableEvent_ResourceType_Master;
/**
 *  Node pool
 *
 *  Value: "NODE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeAvailableEvent_ResourceType_NodePool;
/**
 *  Default value. This shouldn't be used.
 *
 *  Value: "UPGRADE_RESOURCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeAvailableEvent_ResourceType_UpgradeResourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_UpgradeEvent.resourceType

/**
 *  Master / control plane
 *
 *  Value: "MASTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeEvent_ResourceType_Master;
/**
 *  Node pool
 *
 *  Value: "NODE_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeEvent_ResourceType_NodePool;
/**
 *  Default value. This shouldn't be used.
 *
 *  Value: "UPGRADE_RESOURCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeEvent_ResourceType_UpgradeResourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_UpgradeSettings.strategy

/**
 *  blue-green upgrade.
 *
 *  Value: "BLUE_GREEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeSettings_Strategy_BlueGreen;
/**
 *  Default value if unset. GKE internally defaults the update strategy to SURGE
 *  for unspecified strategies.
 *
 *  Value: "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeSettings_Strategy_NodePoolUpdateStrategyUnspecified;
/**
 *  SURGE is the traditional way of upgrade a node pool. max_surge and
 *  max_unavailable determines the level of upgrade parallelism.
 *
 *  Value: "SURGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UpgradeSettings_Strategy_Surge;

// ----------------------------------------------------------------------------
// GTLRContainer_UsableSubnetworkSecondaryRange.status

/**
 *  IN_USE_MANAGED_POD denotes this range was created by GKE and is claimed for
 *  pods. It cannot be used for other clusters.
 *
 *  Value: "IN_USE_MANAGED_POD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UsableSubnetworkSecondaryRange_Status_InUseManagedPod;
/**
 *  IN_USE_SERVICE denotes that this range is claimed by cluster(s) for
 *  services. User-managed services range can be shared between clusters within
 *  the same subnetwork.
 *
 *  Value: "IN_USE_SERVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UsableSubnetworkSecondaryRange_Status_InUseService;
/**
 *  IN_USE_SHAREABLE_POD denotes this range was created by the network admin and
 *  is currently claimed by a cluster for pods. It can only be used by other
 *  clusters as a pod range.
 *
 *  Value: "IN_USE_SHAREABLE_POD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UsableSubnetworkSecondaryRange_Status_InUseShareablePod;
/**
 *  UNKNOWN is the zero value of the Status enum. It's not a valid status.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UsableSubnetworkSecondaryRange_Status_Unknown;
/**
 *  UNUSED denotes that this range is unclaimed by any cluster.
 *
 *  Value: "UNUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_UsableSubnetworkSecondaryRange_Status_Unused;

// ----------------------------------------------------------------------------
// GTLRContainer_WindowsNodeConfig.osVersion

/**
 *  LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base Image
 *
 *  Value: "OS_VERSION_LTSC2019"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_WindowsNodeConfig_OsVersion_OsVersionLtsc2019;
/**
 *  LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base Image
 *
 *  Value: "OS_VERSION_LTSC2022"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_WindowsNodeConfig_OsVersion_OsVersionLtsc2022;
/**
 *  When OSVersion is not specified
 *
 *  Value: "OS_VERSION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_WindowsNodeConfig_OsVersion_OsVersionUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_WorkloadMetadataConfig.mode

/**
 *  Expose all Compute Engine metadata to pods.
 *
 *  Value: "GCE_METADATA"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_WorkloadMetadataConfig_Mode_GceMetadata;
/**
 *  Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a
 *  metadata API to workloads that is compatible with the V1 Compute Metadata
 *  APIs exposed by the Compute Engine and App Engine Metadata Servers. This
 *  feature can only be enabled if Workload Identity is enabled at the cluster
 *  level.
 *
 *  Value: "GKE_METADATA"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_WorkloadMetadataConfig_Mode_GkeMetadata;
/**
 *  Not set.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainer_WorkloadMetadataConfig_Mode_ModeUnspecified;

/**
 *  AcceleratorConfig represents a Hardware Accelerator request.
 */
@interface GTLRContainer_AcceleratorConfig : GTLRObject

/**
 *  The number of the accelerator cards exposed to an instance.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *acceleratorCount;

/**
 *  The accelerator type resource name. List of supported accelerators
 *  [here](https://cloud.google.com/compute/docs/gpus)
 */
@property(nonatomic, copy, nullable) NSString *acceleratorType;

/** The configuration for auto installation of GPU driver. */
@property(nonatomic, strong, nullable) GTLRContainer_GPUDriverInstallationConfig *gpuDriverInstallationConfig;

/**
 *  Size of partitions to create on the GPU. Valid values are described in the
 *  NVIDIA [mig user
 *  guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
 */
@property(nonatomic, copy, nullable) NSString *gpuPartitionSize;

/** The configuration for GPU sharing options. */
@property(nonatomic, strong, nullable) GTLRContainer_GPUSharingConfig *gpuSharingConfig;

@end


/**
 *  AdditionalNodeNetworkConfig is the configuration for additional node
 *  networks within the NodeNetworkConfig message
 */
@interface GTLRContainer_AdditionalNodeNetworkConfig : GTLRObject

/** Name of the VPC where the additional interface belongs */
@property(nonatomic, copy, nullable) NSString *network;

/** Name of the subnetwork where the additional interface belongs */
@property(nonatomic, copy, nullable) NSString *subnetwork;

@end


/**
 *  AdditionalPodNetworkConfig is the configuration for additional pod networks
 *  within the NodeNetworkConfig message
 */
@interface GTLRContainer_AdditionalPodNetworkConfig : GTLRObject

/** The maximum number of pods per node which use this pod network. */
@property(nonatomic, strong, nullable) GTLRContainer_MaxPodsConstraint *maxPodsPerNode;

/**
 *  The name of the network attachment for pods to communicate to; cannot be
 *  specified along with subnetwork or secondary_pod_range.
 */
@property(nonatomic, copy, nullable) NSString *networkAttachment;

/**
 *  The name of the secondary range on the subnet which provides IP address for
 *  this pod range.
 */
@property(nonatomic, copy, nullable) NSString *secondaryPodRange;

/** Name of the subnetwork where the additional pod network belongs. */
@property(nonatomic, copy, nullable) NSString *subnetwork;

@end


/**
 *  AdditionalPodRangesConfig is the configuration for additional pod secondary
 *  ranges supporting the ClusterUpdate message.
 */
@interface GTLRContainer_AdditionalPodRangesConfig : GTLRObject

/** Output only. Information for additional pod range. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_RangeInfo *> *podRangeInfo;

/**
 *  Name for pod secondary ipv4 range which has the actual range defined ahead.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *podRangeNames;

@end


/**
 *  Configuration for the addons that can be automatically spun up in the
 *  cluster, enabling additional functionality.
 */
@interface GTLRContainer_AddonsConfig : GTLRObject

/**
 *  Configuration for the Cloud Run addon, which allows the user to use a
 *  managed Knative service.
 */
@property(nonatomic, strong, nullable) GTLRContainer_CloudRunConfig *cloudRunConfig;

/**
 *  Configuration for the ConfigConnector add-on, a Kubernetes extension to
 *  manage hosted GCP services through the Kubernetes API
 */
@property(nonatomic, strong, nullable) GTLRContainer_ConfigConnectorConfig *configConnectorConfig;

/** Configuration for NodeLocalDNS, a dns cache running on cluster nodes */
@property(nonatomic, strong, nullable) GTLRContainer_DnsCacheConfig *dnsCacheConfig;

/** Configuration for the Compute Engine Persistent Disk CSI driver. */
@property(nonatomic, strong, nullable) GTLRContainer_GcePersistentDiskCsiDriverConfig *gcePersistentDiskCsiDriverConfig;

/** Configuration for the GCP Filestore CSI driver. */
@property(nonatomic, strong, nullable) GTLRContainer_GcpFilestoreCsiDriverConfig *gcpFilestoreCsiDriverConfig;

/** Configuration for the Cloud Storage Fuse CSI driver. */
@property(nonatomic, strong, nullable) GTLRContainer_GcsFuseCsiDriverConfig *gcsFuseCsiDriverConfig;

/** Configuration for the Backup for GKE agent addon. */
@property(nonatomic, strong, nullable) GTLRContainer_GkeBackupAgentConfig *gkeBackupAgentConfig;

/**
 *  Configuration for the horizontal pod autoscaling feature, which increases or
 *  decreases the number of replica pods a replication controller has based on
 *  the resource usage of the existing pods.
 */
@property(nonatomic, strong, nullable) GTLRContainer_HorizontalPodAutoscaling *horizontalPodAutoscaling;

/**
 *  Configuration for the HTTP (L7) load balancing controller addon, which makes
 *  it easy to set up HTTP load balancers for services in a cluster.
 */
@property(nonatomic, strong, nullable) GTLRContainer_HttpLoadBalancing *httpLoadBalancing;

/**
 *  Configuration for the Kubernetes Dashboard. This addon is deprecated, and
 *  will be disabled in 1.15. It is recommended to use the Cloud Console to
 *  manage and monitor your Kubernetes clusters, workloads and applications. For
 *  more information, see:
 *  https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards
 */
@property(nonatomic, strong, nullable) GTLRContainer_KubernetesDashboard *kubernetesDashboard GTLR_DEPRECATED;

/**
 *  Configuration for NetworkPolicy. This only tracks whether the addon is
 *  enabled or not on the Master, it does not track whether network policy is
 *  enabled for the nodes.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPolicyConfig *networkPolicyConfig;

/** Optional. Configuration for Ray Operator addon. */
@property(nonatomic, strong, nullable) GTLRContainer_RayOperatorConfig *rayOperatorConfig;

/** Optional. Configuration for the StatefulHA add-on. */
@property(nonatomic, strong, nullable) GTLRContainer_StatefulHAConfig *statefulHaConfig;

@end


/**
 *  AdvancedDatapathObservabilityConfig specifies configuration of observability
 *  features of advanced datapath.
 */
@interface GTLRContainer_AdvancedDatapathObservabilityConfig : GTLRObject

/**
 *  Expose flow metrics on nodes
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableMetrics;

/**
 *  Enable Relay component
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableRelay;

/**
 *  Method used to make Relay available
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_Disabled
 *        disabled (Value: "DISABLED")
 *    @arg @c kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_ExternalLb
 *        exposed via external load balancer (Value: "EXTERNAL_LB")
 *    @arg @c kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_InternalVpcLb
 *        exposed via internal load balancer (Value: "INTERNAL_VPC_LB")
 *    @arg @c kGTLRContainer_AdvancedDatapathObservabilityConfig_RelayMode_RelayModeUnspecified
 *        Default value. This shouldn't be used. (Value:
 *        "RELAY_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *relayMode;

@end


/**
 *  Specifies options for controlling advanced machine features.
 */
@interface GTLRContainer_AdvancedMachineFeatures : GTLRObject

/**
 *  Whether or not to enable nested virtualization (defaults to false).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableNestedVirtualization;

/**
 *  The number of threads per physical core. To disable simultaneous
 *  multithreading (SMT) set this to 1. If unset, the maximum number of threads
 *  supported per core by the underlying processor is assumed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *threadsPerCore;

@end


/**
 *  Configuration for returning group information from authenticators.
 */
@interface GTLRContainer_AuthenticatorGroupsConfig : GTLRObject

/**
 *  Whether this cluster should return group membership lookups during
 *  authentication using a group of security groups.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  The name of the security group-of-groups to be used. Only relevant if
 *  enabled = true.
 */
@property(nonatomic, copy, nullable) NSString *securityGroup;

@end


/**
 *  Autopilot is the configuration for Autopilot settings on the cluster.
 */
@interface GTLRContainer_Autopilot : GTLRObject

/**
 *  Enable Autopilot
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/** Workload policy configuration for Autopilot. */
@property(nonatomic, strong, nullable) GTLRContainer_WorkloadPolicyConfig *workloadPolicyConfig;

@end


/**
 *  AutopilotCompatibilityIssue contains information about a specific
 *  compatibility issue with Autopilot mode.
 */
@interface GTLRContainer_AutopilotCompatibilityIssue : GTLRObject

/** The constraint type of the issue. */
@property(nonatomic, copy, nullable) NSString *constraintType;

/**
 *  The description of the issue.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** A URL to a public documnetation, which addresses resolving this issue. */
@property(nonatomic, copy, nullable) NSString *documentationUrl;

/**
 *  The incompatibility type of this issue.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_AdditionalConfigRequired
 *        Indicates the issue is an incompatibility if customers take no further
 *        action to resolve. (Value: "ADDITIONAL_CONFIG_REQUIRED")
 *    @arg @c kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_Incompatibility
 *        Indicates that the issue is a known incompatibility between the
 *        cluster and Autopilot mode. (Value: "INCOMPATIBILITY")
 *    @arg @c kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_PassedWithOptionalConfig
 *        Indicates the issue is not an incompatibility, but depending on the
 *        workloads business logic, there is a potential that they won't work on
 *        Autopilot. (Value: "PASSED_WITH_OPTIONAL_CONFIG")
 *    @arg @c kGTLRContainer_AutopilotCompatibilityIssue_IncompatibilityType_Unspecified
 *        Default value, should not be used. (Value: "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *incompatibilityType;

/** The last time when this issue was observed. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastObservation;

/** The name of the resources which are subject to this issue. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *subjects;

@end


/**
 *  AutoprovisioningNodePoolDefaults contains defaults for a node pool created
 *  by NAP.
 */
@interface GTLRContainer_AutoprovisioningNodePoolDefaults : GTLRObject

/**
 *  The Customer Managed Encryption Key used to encrypt the boot disk attached
 *  to each node in the node pool. This should be of the form
 *  projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
 *  For more information about protecting resources with Cloud KMS Keys please
 *  see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
 */
@property(nonatomic, copy, nullable) NSString *bootDiskKmsKey;

/**
 *  Size of the disk attached to each node, specified in GB. The smallest
 *  allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskSizeGb;

/**
 *  Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
 *  'pd-balanced') If unspecified, the default disk type is 'pd-standard'
 */
@property(nonatomic, copy, nullable) NSString *diskType;

/**
 *  The image type to use for NAP created node. Please see
 *  https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
 *  available image types.
 */
@property(nonatomic, copy, nullable) NSString *imageType;

/**
 *  Enable or disable Kubelet read only port.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *insecureKubeletReadonlyPortEnabled;

/** Specifies the node management options for NAP created node-pools. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeManagement *management;

/**
 *  Deprecated. Minimum CPU platform to be used for NAP created node pools. The
 *  instance may be scheduled on the specified or newer CPU platform. Applicable
 *  values are the friendly names of CPU platforms, such as minCpuPlatform:
 *  Intel Haswell or minCpuPlatform: Intel Sandy Bridge. For more information,
 *  read [how to specify min CPU
 *  platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).
 *  This field is deprecated, min_cpu_platform should be specified using
 *  `cloud.google.com/requested-min-cpu-platform` label selector on the pod. To
 *  unset the min cpu platform field pass "automatic" as field value.
 */
@property(nonatomic, copy, nullable) NSString *minCpuPlatform GTLR_DEPRECATED;

/** Scopes that are used by NAP when creating node pools. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oauthScopes;

/** The Google Cloud Platform Service Account to be used by the node VMs. */
@property(nonatomic, copy, nullable) NSString *serviceAccount;

/** Shielded Instance options. */
@property(nonatomic, strong, nullable) GTLRContainer_ShieldedInstanceConfig *shieldedInstanceConfig;

/** Specifies the upgrade settings for NAP created node pools */
@property(nonatomic, strong, nullable) GTLRContainer_UpgradeSettings *upgradeSettings;

@end


/**
 *  AutoUpgradeOptions defines the set of options for the user to control how
 *  the Auto Upgrades will proceed.
 */
@interface GTLRContainer_AutoUpgradeOptions : GTLRObject

/**
 *  Output only. This field is set when upgrades are about to commence with the
 *  approximate start time for the upgrades, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *autoUpgradeStartTime;

/**
 *  Output only. This field is set when upgrades are about to commence with the
 *  description of the upgrade.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

@end


/**
 *  Best effort provisioning.
 */
@interface GTLRContainer_BestEffortProvisioning : GTLRObject

/**
 *  When this is enabled, cluster/node pool creations will ignore non-fatal
 *  errors like stockout to best provision as many nodes as possible right now
 *  and eventually bring up all target number of nodes
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Minimum number of nodes to be provisioned to be considered as succeeded, and
 *  the rest of nodes will be provisioned gradually and eventually when stockout
 *  issue has been resolved.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minProvisionNodes;

@end


/**
 *  Parameters for using BigQuery as the destination of resource usage export.
 */
@interface GTLRContainer_BigQueryDestination : GTLRObject

/** The ID of a BigQuery Dataset. */
@property(nonatomic, copy, nullable) NSString *datasetId;

@end


/**
 *  Configuration for Binary Authorization.
 */
@interface GTLRContainer_BinaryAuthorization : GTLRObject

/**
 *  This field is deprecated. Leave this unset and instead configure
 *  BinaryAuthorization using evaluation_mode. If evaluation_mode is set to
 *  anything other than EVALUATION_MODE_UNSPECIFIED, this field is ignored.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled GTLR_DEPRECATED;

/**
 *  Mode of operation for binauthz policy evaluation. If unspecified, defaults
 *  to DISABLED.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_BinaryAuthorization_EvaluationMode_Disabled Disable
 *        BinaryAuthorization (Value: "DISABLED")
 *    @arg @c kGTLRContainer_BinaryAuthorization_EvaluationMode_EvaluationModeUnspecified
 *        Default value (Value: "EVALUATION_MODE_UNSPECIFIED")
 *    @arg @c kGTLRContainer_BinaryAuthorization_EvaluationMode_ProjectSingletonPolicyEnforce
 *        Enforce Kubernetes admission requests with BinaryAuthorization using
 *        the project's singleton policy. This is equivalent to setting the
 *        enabled boolean to true. (Value: "PROJECT_SINGLETON_POLICY_ENFORCE")
 */
@property(nonatomic, copy, nullable) NSString *evaluationMode;

@end


/**
 *  Information relevant to blue-green upgrade.
 */
@interface GTLRContainer_BlueGreenInfo : GTLRObject

/**
 *  The resource URLs of the [managed instance groups]
 *  (/compute/docs/instance-groups/creating-groups-of-managed-instances)
 *  associated with blue pool.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *blueInstanceGroupUrls;

/**
 *  Time to start deleting blue pool to complete blue-green upgrade, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *bluePoolDeletionStartTime;

/**
 *  The resource URLs of the [managed instance groups]
 *  (/compute/docs/instance-groups/creating-groups-of-managed-instances)
 *  associated with green pool.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *greenInstanceGroupUrls;

/** Version of green pool. */
@property(nonatomic, copy, nullable) NSString *greenPoolVersion;

/**
 *  Current blue-green upgrade phase.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_CordoningBluePool Start
 *        cordoning blue pool nodes. (Value: "CORDONING_BLUE_POOL")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_CreatingGreenPool Start
 *        creating green pool nodes. (Value: "CREATING_GREEN_POOL")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_DeletingBluePool Start deleting
 *        blue nodes. (Value: "DELETING_BLUE_POOL")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_DrainingBluePool Start draining
 *        blue pool nodes. (Value: "DRAINING_BLUE_POOL")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_NodePoolSoaking Start soaking
 *        time after draining entire blue pool. (Value: "NODE_POOL_SOAKING")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_PhaseUnspecified Unspecified
 *        phase. (Value: "PHASE_UNSPECIFIED")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_RollbackStarted Rollback has
 *        been initiated. (Value: "ROLLBACK_STARTED")
 *    @arg @c kGTLRContainer_BlueGreenInfo_Phase_UpdateStarted blue-green
 *        upgrade has been initiated. (Value: "UPDATE_STARTED")
 */
@property(nonatomic, copy, nullable) NSString *phase;

@end


/**
 *  Settings for blue-green upgrade.
 */
@interface GTLRContainer_BlueGreenSettings : GTLRObject

/**
 *  Time needed after draining entire blue pool. After this period, blue pool
 *  will be cleaned up.
 */
@property(nonatomic, strong, nullable) GTLRDuration *nodePoolSoakDuration;

/** Standard policy for the blue-green upgrade. */
@property(nonatomic, strong, nullable) GTLRContainer_StandardRolloutPolicy *standardRolloutPolicy;

@end


/**
 *  CancelOperationRequest cancels a single operation.
 */
@interface GTLRContainer_CancelOperationRequest : GTLRObject

/**
 *  The name (project, location, operation id) of the operation to cancel.
 *  Specified in the format `projects/ * /locations/ * /operations/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The server-assigned `name` of the operation. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *operationId GTLR_DEPRECATED;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  operation resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  CertificateAuthorityDomainConfig configures one or more fully qualified
 *  domain names (FQDN) to a specific certificate.
 */
@interface GTLRContainer_CertificateAuthorityDomainConfig : GTLRObject

/**
 *  List of fully qualified domain names (FQDN). Specifying port is supported.
 *  Wilcards are NOT supported. Examples: - my.customdomain.com - 10.0.1.2:5000
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *fqdns;

/** Google Secret Manager (GCP) certificate configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_GCPSecretManagerCertificateConfig *gcpSecretManagerCertificateConfig;

@end


/**
 *  CheckAutopilotCompatibilityResponse has a list of compatibility issues.
 */
@interface GTLRContainer_CheckAutopilotCompatibilityResponse : GTLRObject

/** The list of issues for the given operation. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_AutopilotCompatibilityIssue *> *issues;

/** The summary of the autopilot compatibility response. */
@property(nonatomic, copy, nullable) NSString *summary;

@end


/**
 *  CidrBlock contains an optional name and one CIDR block.
 */
@interface GTLRContainer_CidrBlock : GTLRObject

/** cidr_block must be specified in CIDR notation. */
@property(nonatomic, copy, nullable) NSString *cidrBlock;

/** display_name is an optional field for users to identify CIDR blocks. */
@property(nonatomic, copy, nullable) NSString *displayName;

@end


/**
 *  Configuration for client certificates on the cluster.
 */
@interface GTLRContainer_ClientCertificateConfig : GTLRObject

/**
 *  Issue a client certificate.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *issueClientCertificate;

@end


/**
 *  Configuration options for the Cloud Run feature.
 */
@interface GTLRContainer_CloudRunConfig : GTLRObject

/**
 *  Whether Cloud Run addon is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

/**
 *  Which load balancer type is installed for Cloud Run.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_CloudRunConfig_LoadBalancerType_LoadBalancerTypeExternal
 *        Install external load balancer for Cloud Run. (Value:
 *        "LOAD_BALANCER_TYPE_EXTERNAL")
 *    @arg @c kGTLRContainer_CloudRunConfig_LoadBalancerType_LoadBalancerTypeInternal
 *        Install internal load balancer for Cloud Run. (Value:
 *        "LOAD_BALANCER_TYPE_INTERNAL")
 *    @arg @c kGTLRContainer_CloudRunConfig_LoadBalancerType_LoadBalancerTypeUnspecified
 *        Load balancer type for Cloud Run is unspecified. (Value:
 *        "LOAD_BALANCER_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *loadBalancerType;

@end


/**
 *  A Google Kubernetes Engine cluster.
 */
@interface GTLRContainer_Cluster : GTLRObject

/** Configurations for the various addons available to run in the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_AddonsConfig *addonsConfig;

/** Configuration controlling RBAC group membership information. */
@property(nonatomic, strong, nullable) GTLRContainer_AuthenticatorGroupsConfig *authenticatorGroupsConfig;

/** Autopilot configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_Autopilot *autopilot;

/** Cluster-level autoscaling configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_ClusterAutoscaling *autoscaling;

/** Configuration for Binary Authorization. */
@property(nonatomic, strong, nullable) GTLRContainer_BinaryAuthorization *binaryAuthorization;

/**
 *  The IP address range of the container pods in this cluster, in
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `10.96.0.0/14`). Leave blank to have one automatically chosen or
 *  specify a `/14` block in `10.0.0.0/8`.
 */
@property(nonatomic, copy, nullable) NSString *clusterIpv4Cidr;

/** Enable/Disable Compliance Posture features for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_CompliancePostureConfig *compliancePostureConfig;

/** Which conditions caused the current cluster state. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_StatusCondition *> *conditions;

/**
 *  Configuration of Confidential Nodes. All the nodes in the cluster will be
 *  Confidential VM once enabled.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ConfidentialNodes *confidentialNodes;

/** Configuration for the fine-grained cost management feature. */
@property(nonatomic, strong, nullable) GTLRContainer_CostManagementConfig *costManagementConfig;

/**
 *  Output only. The time the cluster was created, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *createTime;

/** Output only. The current software version of the master endpoint. */
@property(nonatomic, copy, nullable) NSString *currentMasterVersion;

/**
 *  Output only. The number of nodes currently in the cluster. Deprecated. Call
 *  Kubernetes API directly to retrieve node information.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *currentNodeCount GTLR_DEPRECATED;

/**
 *  Output only. Deprecated, use
 *  [NodePools.version](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools)
 *  instead. The current version of the node software components. If they are
 *  currently at multiple versions because they're in the process of being
 *  upgraded, this reflects the minimum version of all nodes.
 */
@property(nonatomic, copy, nullable) NSString *currentNodeVersion GTLR_DEPRECATED;

/** Configuration of etcd encryption. */
@property(nonatomic, strong, nullable) GTLRContainer_DatabaseEncryption *databaseEncryption;

/**
 *  The default constraint on the maximum number of pods that can be run
 *  simultaneously on a node in the node pool of this cluster. Only honored if
 *  cluster created with IP Alias support.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MaxPodsConstraint *defaultMaxPodsConstraint;

/**
 *  An optional description of this cluster.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Beta APIs Config */
@property(nonatomic, strong, nullable) GTLRContainer_K8sBetaAPIConfig *enableK8sBetaApis;

/**
 *  Kubernetes alpha features are enabled on this cluster. This includes alpha
 *  API groups (e.g. v1alpha1) and features that may not be production ready in
 *  the kubernetes version of the master and nodes. The cluster has no SLA for
 *  uptime and master/node upgrades are disabled. Alpha enabled clusters are
 *  automatically deleted thirty days after creation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableKubernetesAlpha;

/**
 *  Enable the ability to use Cloud TPUs in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableTpu;

/**
 *  Output only. The IP address of this cluster's master endpoint. The endpoint
 *  can be accessed from the internet at `https://username:password\@endpoint/`.
 *  See the `masterAuth` property of this resource for username and password
 *  information.
 */
@property(nonatomic, copy, nullable) NSString *endpoint;

/** GKE Enterprise Configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_EnterpriseConfig *enterpriseConfig;

/**
 *  This checksum is computed by the server based on the value of cluster
 *  fields, and may be sent on update requests to ensure the client has an
 *  up-to-date value before proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. The time the cluster will be automatically deleted in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *expireTime;

/** Fleet information for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_Fleet *fleet;

/**
 *  Output only. Unique id for the cluster.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Configuration for Identity Service component. */
@property(nonatomic, strong, nullable) GTLRContainer_IdentityServiceConfig *identityServiceConfig;

/**
 *  The initial Kubernetes version for this cluster. Valid versions are those
 *  found in validMasterVersions returned by getServerConfig. The version can be
 *  upgraded over time; such upgrades are reflected in currentMasterVersion and
 *  currentNodeVersion. Users may specify either explicit versions offered by
 *  Kubernetes Engine or version aliases, which have the following behavior: -
 *  "latest": picks the highest valid Kubernetes version - "1.X": picks the
 *  highest valid patch+gke.N patch in the 1.X version - "1.X.Y": picks the
 *  highest valid gke.N patch in the 1.X.Y version - "1.X.Y-gke.N": picks an
 *  explicit Kubernetes version - "","-": picks the default Kubernetes version
 */
@property(nonatomic, copy, nullable) NSString *initialClusterVersion;

/**
 *  The number of nodes to create in this cluster. You must ensure that your
 *  Compute Engine [resource quota](https://cloud.google.com/compute/quotas) is
 *  sufficient for this number of instances. You must also have available
 *  firewall and routes quota. For requests, this field should only be used in
 *  lieu of a "node_pool" object, since this configuration (along with the
 *  "node_config") will be used to create a "NodePool" object with an
 *  auto-generated name. Do not use this and a node_pool at the same time. This
 *  field is deprecated, use node_pool.initial_node_count instead.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialNodeCount GTLR_DEPRECATED;

/** Output only. Deprecated. Use node_pools.instance_group_urls. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instanceGroupUrls GTLR_DEPRECATED;

/** Configuration for cluster IP allocation. */
@property(nonatomic, strong, nullable) GTLRContainer_IPAllocationPolicy *ipAllocationPolicy;

/** The fingerprint of the set of labels for this cluster. */
@property(nonatomic, copy, nullable) NSString *labelFingerprint;

/** Configuration for the legacy ABAC authorization mode. */
@property(nonatomic, strong, nullable) GTLRContainer_LegacyAbac *legacyAbac;

/**
 *  Output only. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
 *  or
 *  [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
 *  in which the cluster resides.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The list of Google Compute Engine
 *  [zones](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster's nodes should be located. This field provides a default value if
 *  [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
 *  are not specified during node pool creation. Warning: changing cluster
 *  locations will update the
 *  [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
 *  of all node pools and will result in nodes being added and/or removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locations;

/** Logging configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_LoggingConfig *loggingConfig;

/**
 *  The logging service the cluster should use to write logs. Currently
 *  available options: * `logging.googleapis.com/kubernetes` - The Cloud Logging
 *  service with a Kubernetes-native resource model * `logging.googleapis.com` -
 *  The legacy Cloud Logging service (no longer available as of GKE 1.15). *
 *  `none` - no logs will be exported from the cluster. If left as an empty
 *  string,`logging.googleapis.com/kubernetes` will be used for GKE 1.14+ or
 *  `logging.googleapis.com` for earlier versions.
 */
@property(nonatomic, copy, nullable) NSString *loggingService;

/** Configure the maintenance policy for this cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenancePolicy *maintenancePolicy;

/**
 *  The authentication information for accessing the master endpoint. If
 *  unspecified, the defaults are used: For clusters before v1.12, if
 *  master_auth is unspecified, `username` will be set to "admin", a random
 *  password will be generated, and a client certificate will be issued.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuth *masterAuth;

/** The configuration options for master authorized networks feature. */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuthorizedNetworksConfig *masterAuthorizedNetworksConfig;

/**
 *  Configuration for issuance of mTLS keys and certificates to Kubernetes pods.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MeshCertificates *meshCertificates;

/** Monitoring configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_MonitoringConfig *monitoringConfig;

/**
 *  The monitoring service the cluster should use to write metrics. Currently
 *  available options: * "monitoring.googleapis.com/kubernetes" - The Cloud
 *  Monitoring service with a Kubernetes-native resource model *
 *  `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no longer
 *  available as of GKE 1.15). * `none` - No metrics will be exported from the
 *  cluster. If left as an empty string,`monitoring.googleapis.com/kubernetes`
 *  will be used for GKE 1.14+ or `monitoring.googleapis.com` for earlier
 *  versions.
 */
@property(nonatomic, copy, nullable) NSString *monitoringService;

/**
 *  The name of this cluster. The name must be unique within this project and
 *  location (e.g. zone or region), and can be up to 40 characters with the
 *  following restrictions: * Lowercase letters, numbers, and hyphens only. *
 *  Must start with a letter. * Must end with a number or a letter.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the Google Compute Engine
 *  [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
 *  to which the cluster is connected. If left unspecified, the `default`
 *  network will be used.
 */
@property(nonatomic, copy, nullable) NSString *network;

/** Configuration for cluster networking. */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkConfig *networkConfig;

/** Configuration options for the NetworkPolicy feature. */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPolicy *networkPolicy;

/**
 *  Parameters used in creating the cluster's nodes. For requests, this field
 *  should only be used in lieu of a "node_pool" object, since this
 *  configuration (along with the "initial_node_count") will be used to create a
 *  "NodePool" object with an auto-generated name. Do not use this and a
 *  node_pool at the same time. For responses, this field will be populated with
 *  the node configuration of the first node pool. (For configuration of each
 *  node pool, see `node_pool.config`) If unspecified, the defaults are used.
 *  This field is deprecated, use node_pool.config instead.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig *nodeConfig GTLR_DEPRECATED;

/**
 *  Output only. The size of the address space on each node for hosting
 *  containers. This is provisioned from within the `container_ipv4_cidr` range.
 *  This field will only be set when cluster is in route-based network mode.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeIpv4CidrSize;

/**
 *  Node pool configs that apply to all auto-provisioned node pools in autopilot
 *  clusters and node auto-provisioning enabled clusters.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoConfig *nodePoolAutoConfig;

/**
 *  Default NodePool settings for the entire cluster. These settings are
 *  overridden if specified on the specific NodePool object.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolDefaults *nodePoolDefaults;

/**
 *  The node pools associated with this cluster. This field should not be set if
 *  "node_config" or "initial_node_count" are specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodePool *> *nodePools;

/** Notification configuration of the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_NotificationConfig *notificationConfig;

/**
 *  The configuration of the parent product of the cluster. This field is used
 *  by Google internal products that are built on top of the GKE cluster and
 *  take the ownership of the cluster.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ParentProductConfig *parentProductConfig;

/** Configuration for private cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_PrivateClusterConfig *privateClusterConfig;

/**
 *  RBACBindingConfig allows user to restrict ClusterRoleBindings an
 *  RoleBindings that can be created.
 */
@property(nonatomic, strong, nullable) GTLRContainer_RBACBindingConfig *rbacBindingConfig;

/**
 *  Release channel configuration. If left unspecified on cluster creation and a
 *  version is specified, the cluster is enrolled in the most mature release
 *  channel where the version is available (first checking STABLE, then REGULAR,
 *  and finally RAPID). Otherwise, if no release channel configuration and no
 *  version is specified, the cluster is enrolled in the REGULAR channel with
 *  its default version.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ReleaseChannel *releaseChannel;

/**
 *  The resource labels for the cluster to use to annotate any related Google
 *  Compute Engine resources.
 */
@property(nonatomic, strong, nullable) GTLRContainer_Cluster_ResourceLabels *resourceLabels;

/**
 *  Configuration for exporting resource usages. Resource usage export is
 *  disabled when this config is unspecified.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceUsageExportConfig *resourceUsageExportConfig;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzi;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzs;

/** Secret CSI driver configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_SecretManagerConfig *secretManagerConfig;

/** Enable/Disable Security Posture API features for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_SecurityPostureConfig *securityPostureConfig;

/** Output only. Server-defined URL for the resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  Output only. The IP address range of the Kubernetes services in this
 *  cluster, in
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `1.2.3.4/29`). Service addresses are typically put in the last `/16`
 *  from the container CIDR.
 */
@property(nonatomic, copy, nullable) NSString *servicesIpv4Cidr;

/** Shielded Nodes configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_ShieldedNodes *shieldedNodes;

/**
 *  Output only. The current status of this cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_Cluster_Status_Degraded The DEGRADED state
 *        indicates the cluster requires user action to restore full
 *        functionality. Details can be found in the `statusMessage` field.
 *        (Value: "DEGRADED")
 *    @arg @c kGTLRContainer_Cluster_Status_Error The ERROR state indicates the
 *        cluster is unusable. It will be automatically deleted. Details can be
 *        found in the `statusMessage` field. (Value: "ERROR")
 *    @arg @c kGTLRContainer_Cluster_Status_Provisioning The PROVISIONING state
 *        indicates the cluster is being created. (Value: "PROVISIONING")
 *    @arg @c kGTLRContainer_Cluster_Status_Reconciling The RECONCILING state
 *        indicates that some work is actively being done on the cluster, such
 *        as upgrading the master or node software. Details can be found in the
 *        `statusMessage` field. (Value: "RECONCILING")
 *    @arg @c kGTLRContainer_Cluster_Status_Running The RUNNING state indicates
 *        the cluster has been created and is fully usable. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_Cluster_Status_StatusUnspecified Not set. (Value:
 *        "STATUS_UNSPECIFIED")
 *    @arg @c kGTLRContainer_Cluster_Status_Stopping The STOPPING state
 *        indicates the cluster is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  Output only. Deprecated. Use conditions instead. Additional information
 *  about the current status of this cluster, if available.
 */
@property(nonatomic, copy, nullable) NSString *statusMessage GTLR_DEPRECATED;

/**
 *  The name of the Google Compute Engine
 *  [subnetwork](https://cloud.google.com/compute/docs/subnetworks) to which the
 *  cluster is connected.
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Output only. The IP address range of the Cloud TPUs in this cluster, in
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `1.2.3.4/29`).
 */
@property(nonatomic, copy, nullable) NSString *tpuIpv4CidrBlock;

/** Cluster-level Vertical Pod Autoscaling configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_VerticalPodAutoscaling *verticalPodAutoscaling;

/**
 *  Configuration for the use of Kubernetes Service Accounts in GCP IAM
 *  policies.
 */
@property(nonatomic, strong, nullable) GTLRContainer_WorkloadIdentityConfig *workloadIdentityConfig;

/**
 *  Output only. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field is deprecated, use location instead.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  The resource labels for the cluster to use to annotate any related Google
 *  Compute Engine resources.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_Cluster_ResourceLabels : GTLRObject
@end


/**
 *  ClusterAutoscaling contains global, per-cluster information required by
 *  Cluster Autoscaler to automatically adjust the size of the cluster and
 *  create/delete node pools based on the current needs.
 */
@interface GTLRContainer_ClusterAutoscaling : GTLRObject

/**
 *  The list of Google Compute Engine
 *  [zones](https://cloud.google.com/compute/docs/zones#available) in which the
 *  NodePool's nodes can be created by NAP.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *autoprovisioningLocations;

/**
 *  AutoprovisioningNodePoolDefaults contains defaults for a node pool created
 *  by NAP.
 */
@property(nonatomic, strong, nullable) GTLRContainer_AutoprovisioningNodePoolDefaults *autoprovisioningNodePoolDefaults;

/**
 *  Defines autoscaling behaviour.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ClusterAutoscaling_AutoscalingProfile_Balanced Use
 *        default (balanced) autoscaling configuration. (Value: "BALANCED")
 *    @arg @c kGTLRContainer_ClusterAutoscaling_AutoscalingProfile_OptimizeUtilization
 *        Prioritize optimizing utilization of resources. (Value:
 *        "OPTIMIZE_UTILIZATION")
 *    @arg @c kGTLRContainer_ClusterAutoscaling_AutoscalingProfile_ProfileUnspecified
 *        No change to autoscaling configuration. (Value: "PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *autoscalingProfile;

/**
 *  Enables automatic node pool creation and deletion.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableNodeAutoprovisioning;

/**
 *  Contains global constraints regarding minimum and maximum amount of
 *  resources in the cluster.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_ResourceLimit *> *resourceLimits;

@end


/**
 *  Configuration of network bandwidth tiers
 */
@interface GTLRContainer_ClusterNetworkPerformanceConfig : GTLRObject

/**
 *  Specifies the total network bandwidth tier for NodePools in the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ClusterNetworkPerformanceConfig_TotalEgressBandwidthTier_Tier1
 *        Higher bandwidth, actual values based on VM size. (Value: "TIER_1")
 *    @arg @c kGTLRContainer_ClusterNetworkPerformanceConfig_TotalEgressBandwidthTier_TierUnspecified
 *        Default value (Value: "TIER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *totalEgressBandwidthTier;

@end


/**
 *  ClusterUpdate describes an update to the cluster. Exactly one update can be
 *  applied to a cluster with each request, so at most one field can be
 *  provided.
 */
@interface GTLRContainer_ClusterUpdate : GTLRObject

/**
 *  The additional pod ranges to be added to the cluster. These pod ranges can
 *  be used by node pools to allocate pod IPs.
 */
@property(nonatomic, strong, nullable) GTLRContainer_AdditionalPodRangesConfig *additionalPodRangesConfig;

/** Configurations for the various addons available to run in the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_AddonsConfig *desiredAddonsConfig;

/** The desired authenticator groups config for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_AuthenticatorGroupsConfig *desiredAuthenticatorGroupsConfig;

/** The desired workload policy configuration for the autopilot cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_WorkloadPolicyConfig *desiredAutopilotWorkloadPolicyConfig;

/** The desired configuration options for the Binary Authorization feature. */
@property(nonatomic, strong, nullable) GTLRContainer_BinaryAuthorization *desiredBinaryAuthorization;

/** Cluster-level autoscaling configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_ClusterAutoscaling *desiredClusterAutoscaling;

/** Enable/Disable Compliance Posture features for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_CompliancePostureConfig *desiredCompliancePostureConfig;

/** The desired containerd config for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_DConfig *desiredContainerdConfig;

/** The desired configuration for the fine-grained cost management feature. */
@property(nonatomic, strong, nullable) GTLRContainer_CostManagementConfig *desiredCostManagementConfig;

/** Configuration of etcd encryption. */
@property(nonatomic, strong, nullable) GTLRContainer_DatabaseEncryption *desiredDatabaseEncryption;

/**
 *  The desired datapath provider for the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredDatapathProvider_AdvancedDatapath
 *        Use the eBPF based GKE Dataplane V2 with additional features. See the
 *        [GKE Dataplane V2
 *        documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
 *        for more. (Value: "ADVANCED_DATAPATH")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredDatapathProvider_DatapathProviderUnspecified
 *        Default value. (Value: "DATAPATH_PROVIDER_UNSPECIFIED")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredDatapathProvider_LegacyDatapath
 *        Use the IPTables implementation based on kube-proxy. (Value:
 *        "LEGACY_DATAPATH")
 */
@property(nonatomic, copy, nullable) NSString *desiredDatapathProvider;

/** The desired status of whether to disable default sNAT for this cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_DefaultSnatStatus *desiredDefaultSnatStatus;

/** DNSConfig contains clusterDNS config for this cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_DNSConfig *desiredDnsConfig;

/**
 *  Enable/Disable Cilium Clusterwide Network Policy for the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *desiredEnableCiliumClusterwideNetworkPolicy;

/**
 *  Enable/Disable FQDN Network Policy for the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *desiredEnableFqdnNetworkPolicy;

/**
 *  Enable/Disable Multi-Networking for the cluster
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *desiredEnableMultiNetworking;

/**
 *  Enable/Disable private endpoint for the cluster's master.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *desiredEnablePrivateEndpoint;

/** The desired fleet configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_Fleet *desiredFleet;

/** The desired config of Gateway API on this cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_GatewayAPIConfig *desiredGatewayApiConfig;

/** The desired GCFS config for the cluster */
@property(nonatomic, strong, nullable) GTLRContainer_GcfsConfig *desiredGcfsConfig;

/** The desired Identity Service component configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_IdentityServiceConfig *desiredIdentityServiceConfig;

/**
 *  The desired image type for the node pool. NOTE: Set the "desired_node_pool"
 *  field as well.
 */
@property(nonatomic, copy, nullable) NSString *desiredImageType;

/** The desired config of Intra-node visibility. */
@property(nonatomic, strong, nullable) GTLRContainer_IntraNodeVisibilityConfig *desiredIntraNodeVisibilityConfig;

/**
 *  Specify the details of in-transit encryption.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredInTransitEncryptionConfig_InTransitEncryptionConfigUnspecified
 *        Unspecified, will be inferred as default -
 *        IN_TRANSIT_ENCRYPTION_UNSPECIFIED. (Value:
 *        "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredInTransitEncryptionConfig_InTransitEncryptionDisabled
 *        In-transit encryption is disabled. (Value:
 *        "IN_TRANSIT_ENCRYPTION_DISABLED")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredInTransitEncryptionConfig_InTransitEncryptionInterNodeTransparent
 *        Data in-transit is encrypted using inter-node transparent encryption.
 *        (Value: "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT")
 */
@property(nonatomic, copy, nullable) NSString *desiredInTransitEncryptionConfig;

/** Desired Beta APIs to be enabled for cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_K8sBetaAPIConfig *desiredK8sBetaApis;

/** The desired L4 Internal Load Balancer Subsetting configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_ILBSubsettingConfig *desiredL4ilbSubsettingConfig;

/**
 *  The desired list of Google Compute Engine
 *  [zones](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster's nodes should be located. This list must always include the
 *  cluster's primary zone. Warning: changing cluster locations will update the
 *  locations of all node pools and will result in nodes being added and/or
 *  removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *desiredLocations;

/** The desired logging configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_LoggingConfig *desiredLoggingConfig;

/**
 *  The logging service the cluster should use to write logs. Currently
 *  available options: * `logging.googleapis.com/kubernetes` - The Cloud Logging
 *  service with a Kubernetes-native resource model * `logging.googleapis.com` -
 *  The legacy Cloud Logging service (no longer available as of GKE 1.15). *
 *  `none` - no logs will be exported from the cluster. If left as an empty
 *  string,`logging.googleapis.com/kubernetes` will be used for GKE 1.14+ or
 *  `logging.googleapis.com` for earlier versions.
 */
@property(nonatomic, copy, nullable) NSString *desiredLoggingService;

/**
 *  The desired configuration options for master authorized networks feature.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuthorizedNetworksConfig *desiredMasterAuthorizedNetworksConfig;

/**
 *  The Kubernetes version to change the master to. Users may specify either
 *  explicit versions offered by Kubernetes Engine or version aliases, which
 *  have the following behavior: - "latest": picks the highest valid Kubernetes
 *  version - "1.X": picks the highest valid patch+gke.N patch in the 1.X
 *  version - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
 *  - "1.X.Y-gke.N": picks an explicit Kubernetes version - "-": picks the
 *  default Kubernetes version
 */
@property(nonatomic, copy, nullable) NSString *desiredMasterVersion;

/**
 *  Configuration for issuance of mTLS keys and certificates to Kubernetes pods.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MeshCertificates *desiredMeshCertificates;

/** The desired monitoring configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_MonitoringConfig *desiredMonitoringConfig;

/**
 *  The monitoring service the cluster should use to write metrics. Currently
 *  available options: * "monitoring.googleapis.com/kubernetes" - The Cloud
 *  Monitoring service with a Kubernetes-native resource model *
 *  `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no longer
 *  available as of GKE 1.15). * `none` - No metrics will be exported from the
 *  cluster. If left as an empty string,`monitoring.googleapis.com/kubernetes`
 *  will be used for GKE 1.14+ or `monitoring.googleapis.com` for earlier
 *  versions.
 */
@property(nonatomic, copy, nullable) NSString *desiredMonitoringService;

/** The desired network performance config. */
@property(nonatomic, strong, nullable) GTLRContainer_ClusterNetworkPerformanceConfig *desiredNetworkPerformanceConfig;

/** The desired node kubelet config for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeKubeletConfig *desiredNodeKubeletConfig;

/**
 *  The desired node kubelet config for all auto-provisioned node pools in
 *  autopilot clusters and node auto-provisioning enabled clusters.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeKubeletConfig *desiredNodePoolAutoConfigKubeletConfig;

/**
 *  The desired network tags that apply to all auto-provisioned node pools in
 *  autopilot clusters and node auto-provisioning enabled clusters.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkTags *desiredNodePoolAutoConfigNetworkTags;

/**
 *  The desired resource manager tags that apply to all auto-provisioned node
 *  pools in autopilot clusters and node auto-provisioning enabled clusters.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceManagerTags *desiredNodePoolAutoConfigResourceManagerTags;

/**
 *  Autoscaler configuration for the node pool specified in
 *  desired_node_pool_id. If there is only one pool in the cluster and
 *  desired_node_pool_id is not provided then the change applies to that single
 *  node pool.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoscaling *desiredNodePoolAutoscaling;

/**
 *  The node pool to be upgraded. This field is mandatory if
 *  "desired_node_version", "desired_image_family" or
 *  "desired_node_pool_autoscaling" is specified and there is more than one node
 *  pool on the cluster.
 */
@property(nonatomic, copy, nullable) NSString *desiredNodePoolId;

/** The desired node pool logging configuration defaults for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolLoggingConfig *desiredNodePoolLoggingConfig;

/**
 *  The Kubernetes version to change the nodes to (typically an upgrade). Users
 *  may specify either explicit versions offered by Kubernetes Engine or version
 *  aliases, which have the following behavior: - "latest": picks the highest
 *  valid Kubernetes version - "1.X": picks the highest valid patch+gke.N patch
 *  in the 1.X version - "1.X.Y": picks the highest valid gke.N patch in the
 *  1.X.Y version - "1.X.Y-gke.N": picks an explicit Kubernetes version - "-":
 *  picks the Kubernetes master version
 */
@property(nonatomic, copy, nullable) NSString *desiredNodeVersion;

/** The desired notification configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_NotificationConfig *desiredNotificationConfig;

/** The desired parent product config for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_ParentProductConfig *desiredParentProductConfig;

/**
 *  The desired private cluster configuration. master_global_access_config is
 *  the only field that can be changed via this field. See also
 *  ClusterUpdate.desired_enable_private_endpoint for modifying other fields
 *  within PrivateClusterConfig.
 */
@property(nonatomic, strong, nullable) GTLRContainer_PrivateClusterConfig *desiredPrivateClusterConfig;

/**
 *  The desired state of IPv6 connectivity to Google Services.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessBidirectional
 *        Enables private IPv6 access to and from Google Services (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessDisabled
 *        No private access to or from Google Services (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessToGoogle
 *        Enables private IPv6 access to Google Services from GKE (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredPrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessUnspecified
 *        Default value. Same as DISABLED (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *desiredPrivateIpv6GoogleAccess;

/**
 *  RBACBindingConfig allows user to restrict ClusterRoleBindings an
 *  RoleBindings that can be created.
 */
@property(nonatomic, strong, nullable) GTLRContainer_RBACBindingConfig *desiredRbacBindingConfig;

/** The desired release channel configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_ReleaseChannel *desiredReleaseChannel;

/** The desired configuration for exporting resource usage. */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceUsageExportConfig *desiredResourceUsageExportConfig;

/** Enable/Disable Secret Manager Config. */
@property(nonatomic, strong, nullable) GTLRContainer_SecretManagerConfig *desiredSecretManagerConfig;

/** Enable/Disable Security Posture API features for the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_SecurityPostureConfig *desiredSecurityPostureConfig;

/**
 *  ServiceExternalIPsConfig specifies the config for the use of Services with
 *  ExternalIPs field.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ServiceExternalIPsConfig *desiredServiceExternalIpsConfig;

/** Configuration for Shielded Nodes. */
@property(nonatomic, strong, nullable) GTLRContainer_ShieldedNodes *desiredShieldedNodes;

/**
 *  The desired stack type of the cluster. If a stack type is provided and does
 *  not match the current stack type of the cluster, update will attempt to
 *  change the stack type to the new type.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredStackType_Ipv4 Cluster is IPV4
 *        only (Value: "IPV4")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredStackType_Ipv4Ipv6 Cluster can
 *        use both IPv4 and IPv6 (Value: "IPV4_IPV6")
 *    @arg @c kGTLRContainer_ClusterUpdate_DesiredStackType_StackTypeUnspecified
 *        Default value, will be defaulted as IPV4 only (Value:
 *        "STACK_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *desiredStackType;

/** Cluster-level Vertical Pod Autoscaling configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_VerticalPodAutoscaling *desiredVerticalPodAutoscaling;

/** Configuration for Workload Identity. */
@property(nonatomic, strong, nullable) GTLRContainer_WorkloadIdentityConfig *desiredWorkloadIdentityConfig;

/** Kubernetes open source beta apis enabled on the cluster. Only beta apis */
@property(nonatomic, strong, nullable) GTLRContainer_K8sBetaAPIConfig *enableK8sBetaApis;

/**
 *  The current etag of the cluster. If an etag is provided and does not match
 *  the current etag of the cluster, update will be blocked and an ABORTED error
 *  will be returned.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  The additional pod ranges that are to be removed from the cluster. The pod
 *  ranges specified here must have been specified earlier in the
 *  'additional_pod_ranges_config' argument.
 */
@property(nonatomic, strong, nullable) GTLRContainer_AdditionalPodRangesConfig *removedAdditionalPodRangesConfig;

@end


/**
 *  CompleteIPRotationRequest moves the cluster master back into single-IP mode.
 */
@interface GTLRContainer_CompleteIPRotationRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster. This field has been deprecated and
 *  replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster name) of the cluster to complete IP
 *  rotation. Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  CompleteNodePoolUpgradeRequest sets the name of target node pool to complete
 *  upgrade.
 */
@interface GTLRContainer_CompleteNodePoolUpgradeRequest : GTLRObject
@end


/**
 *  CompliancePostureConfig defines the settings needed to enable/disable
 *  features for the Compliance Posture.
 */
@interface GTLRContainer_CompliancePostureConfig : GTLRObject

/** List of enabled compliance standards. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_ComplianceStandard *> *complianceStandards;

/**
 *  Defines the enablement mode for Compliance Posture.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_CompliancePostureConfig_Mode_Disabled Disables
 *        Compliance Posture features on the cluster. (Value: "DISABLED")
 *    @arg @c kGTLRContainer_CompliancePostureConfig_Mode_Enabled Enables
 *        Compliance Posture features on the cluster. (Value: "ENABLED")
 *    @arg @c kGTLRContainer_CompliancePostureConfig_Mode_ModeUnspecified
 *        Default value not specified. (Value: "MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  Defines the details of a compliance standard.
 */
@interface GTLRContainer_ComplianceStandard : GTLRObject

/** Name of the compliance standard. */
@property(nonatomic, copy, nullable) NSString *standard;

@end


/**
 *  ConfidentialNodes is configuration for the confidential nodes feature, which
 *  makes nodes run on confidential VMs.
 */
@interface GTLRContainer_ConfidentialNodes : GTLRObject

/**
 *  Whether Confidential Nodes feature is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration options for the Config Connector add-on.
 */
@interface GTLRContainer_ConfigConnectorConfig : GTLRObject

/**
 *  Whether Cloud Connector is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Parameters for controlling consumption metering.
 */
@interface GTLRContainer_ConsumptionMeteringConfig : GTLRObject

/**
 *  Whether to enable consumption metering for this cluster. If enabled, a
 *  second BigQuery table will be created to hold resource consumption records.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration for fine-grained cost management feature.
 */
@interface GTLRContainer_CostManagementConfig : GTLRObject

/**
 *  Whether the feature is enabled or not.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  CreateClusterRequest creates a cluster.
 */
@interface GTLRContainer_CreateClusterRequest : GTLRObject

/**
 *  Required. A [cluster
 *  resource](https://cloud.google.com/container-engine/reference/rest/v1/projects.locations.clusters)
 */
@property(nonatomic, strong, nullable) GTLRContainer_Cluster *cluster;

/**
 *  The parent (project and location) where the cluster will be created.
 *  Specified in the format `projects/ * /locations/ *`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the parent field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the parent
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  CreateNodePoolRequest creates a node pool for a cluster.
 */
@interface GTLRContainer_CreateNodePoolRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster. This field has been deprecated and
 *  replaced by the parent field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/** Required. The node pool to create. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePool *nodePool;

/**
 *  The parent (project, location, cluster name) where the node pool will be
 *  created. Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the parent field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the parent
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  Time window specified for daily maintenance operations.
 */
@interface GTLRContainer_DailyMaintenanceWindow : GTLRObject

/**
 *  Output only. Duration of the time window, automatically chosen to be
 *  smallest possible in the given scenario. Duration will be in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format "PTnHnMnS".
 */
@property(nonatomic, copy, nullable) NSString *duration;

/**
 *  Time within the maintenance window to start the maintenance operations. Time
 *  format should be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format
 *  "HH:MM", where HH : [00-23] and MM : [00-59] GMT.
 */
@property(nonatomic, copy, nullable) NSString *startTime;

@end


/**
 *  Configuration of etcd encryption.
 */
@interface GTLRContainer_DatabaseEncryption : GTLRObject

/**
 *  Output only. The current state of etcd encryption.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateDecrypted
 *        Secrets in etcd are stored in plain text (at etcd level) - this is
 *        unrelated to Compute Engine level full disk encryption. (Value:
 *        "CURRENT_STATE_DECRYPTED")
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateDecryptionError
 *        De-crypting Secrets to plain text in etcd encountered an error.
 *        (Value: "CURRENT_STATE_DECRYPTION_ERROR")
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateDecryptionPending
 *        De-crypting Secrets to plain text in etcd is in progress. (Value:
 *        "CURRENT_STATE_DECRYPTION_PENDING")
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateEncrypted
 *        Secrets in etcd are encrypted. (Value: "CURRENT_STATE_ENCRYPTED")
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateEncryptionError
 *        Encryption (or re-encryption with a different CloudKMS key) of Secrets
 *        in etcd encountered an error. (Value:
 *        "CURRENT_STATE_ENCRYPTION_ERROR")
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateEncryptionPending
 *        Encryption (or re-encryption with a different CloudKMS key) of Secrets
 *        is in progress. (Value: "CURRENT_STATE_ENCRYPTION_PENDING")
 *    @arg @c kGTLRContainer_DatabaseEncryption_CurrentState_CurrentStateUnspecified
 *        Should never be set (Value: "CURRENT_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *currentState;

/**
 *  Output only. Keys in use by the cluster for decrypting existing objects, in
 *  addition to the key in `key_name`. Each item is a CloudKMS key resource.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *decryptionKeys;

/**
 *  Name of CloudKMS key to use for the encryption of secrets in etcd. Ex.
 *  projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key
 */
@property(nonatomic, copy, nullable) NSString *keyName;

/**
 *  Output only. Records errors seen during DatabaseEncryption update
 *  operations.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_OperationError *> *lastOperationErrors;

/**
 *  The desired state of etcd encryption.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_DatabaseEncryption_State_Decrypted Secrets in etcd
 *        are stored in plain text (at etcd level) - this is unrelated to
 *        Compute Engine level full disk encryption. (Value: "DECRYPTED")
 *    @arg @c kGTLRContainer_DatabaseEncryption_State_Encrypted Secrets in etcd
 *        are encrypted. (Value: "ENCRYPTED")
 *    @arg @c kGTLRContainer_DatabaseEncryption_State_Unknown Should never be
 *        set (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  ContainerdConfig contains configuration to customize containerd.
 */
@interface GTLRContainer_DConfig : GTLRObject

/**
 *  PrivateRegistryAccessConfig is used to configure access configuration for
 *  private container registries.
 */
@property(nonatomic, strong, nullable) GTLRContainer_PrivateRegistryAccessConfig *privateRegistryAccessConfig;

@end


/**
 *  DefaultSnatStatus contains the desired state of whether default sNAT should
 *  be disabled on the cluster.
 */
@interface GTLRContainer_DefaultSnatStatus : GTLRObject

/**
 *  Disables cluster default sNAT rules.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Configuration for NodeLocal DNSCache
 */
@interface GTLRContainer_DnsCacheConfig : GTLRObject

/**
 *  Whether NodeLocal DNSCache is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  DNSConfig contains the desired set of options for configuring clusterDNS.
 */
@interface GTLRContainer_DNSConfig : GTLRObject

/** Optional. The domain used in Additive VPC scope. */
@property(nonatomic, copy, nullable) NSString *additiveVpcScopeDnsDomain;

/**
 *  cluster_dns indicates which in-cluster DNS provider should be used.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDns_CloudDns Use CloudDNS for DNS
 *        resolution. (Value: "CLOUD_DNS")
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDns_KubeDns Use KubeDNS for DNS
 *        resolution. (Value: "KUBE_DNS")
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDns_PlatformDefault Use GKE
 *        default DNS provider(kube-dns) for DNS resolution. (Value:
 *        "PLATFORM_DEFAULT")
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDns_ProviderUnspecified Default
 *        value (Value: "PROVIDER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *clusterDns;

/** cluster_dns_domain is the suffix used for all cluster service records. */
@property(nonatomic, copy, nullable) NSString *clusterDnsDomain;

/**
 *  cluster_dns_scope indicates the scope of access to cluster DNS records.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDnsScope_ClusterScope DNS records
 *        are accessible from within the cluster. (Value: "CLUSTER_SCOPE")
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDnsScope_DnsScopeUnspecified
 *        Default value, will be inferred as cluster scope. (Value:
 *        "DNS_SCOPE_UNSPECIFIED")
 *    @arg @c kGTLRContainer_DNSConfig_ClusterDnsScope_VpcScope DNS records are
 *        accessible from within the VPC. (Value: "VPC_SCOPE")
 */
@property(nonatomic, copy, nullable) NSString *clusterDnsScope;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRContainer_Empty : GTLRObject
@end


/**
 *  EnterpriseConfig is the cluster enterprise configuration.
 */
@interface GTLRContainer_EnterpriseConfig : GTLRObject

/**
 *  Output only. cluster_tier indicates the effective tier of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_EnterpriseConfig_ClusterTier_ClusterTierUnspecified
 *        CLUSTER_TIER_UNSPECIFIED is when cluster_tier is not set. (Value:
 *        "CLUSTER_TIER_UNSPECIFIED")
 *    @arg @c kGTLRContainer_EnterpriseConfig_ClusterTier_Enterprise ENTERPRISE
 *        indicates a GKE Enterprise cluster. (Value: "ENTERPRISE")
 *    @arg @c kGTLRContainer_EnterpriseConfig_ClusterTier_Standard STANDARD
 *        indicates a standard GKE cluster. (Value: "STANDARD")
 */
@property(nonatomic, copy, nullable) NSString *clusterTier;

@end


/**
 *  EphemeralStorageLocalSsdConfig contains configuration for the node ephemeral
 *  storage using Local SSDs.
 */
@interface GTLRContainer_EphemeralStorageLocalSsdConfig : GTLRObject

/**
 *  Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces.
 *  A zero (or unset) value has different meanings depending on machine type
 *  being used: 1. For pre-Gen3 machines, which support flexible numbers of
 *  local ssds, zero (or unset) means to disable using local SSDs as ephemeral
 *  storage. The limit for this value is dependent upon the maximum number of
 *  disk available on a machine per zone. See:
 *  https://cloud.google.com/compute/docs/disks/local-ssd for more information.
 *  2. For Gen3 machines which dictate a specific number of local ssds, zero (or
 *  unset) means to use the default number of local ssds that goes with that
 *  machine type. For example, for a c3-standard-8-lssd machine, 2 local ssds
 *  would be provisioned. For c3-standard-8 (which doesn't support local ssds),
 *  0 will be provisioned. See
 *  https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds
 *  for more info.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *localSsdCount;

@end


/**
 *  Configuration of Fast Socket feature.
 */
@interface GTLRContainer_FastSocket : GTLRObject

/**
 *  Whether Fast Socket features are enabled in the node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Allows filtering to one or more specific event types. If event types are
 *  present, those and only those event types will be transmitted to the
 *  cluster. Other types will be skipped. If no filter is specified, or no event
 *  types are present, all event types will be sent
 */
@interface GTLRContainer_Filter : GTLRObject

/** Event types to allowlist. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *eventType;

@end


/**
 *  Fleet is the fleet configuration for the cluster.
 */
@interface GTLRContainer_Fleet : GTLRObject

/**
 *  Output only. The full resource name of the registered fleet membership of
 *  the cluster, in the format `//gkehub.googleapis.com/projects/ * /locations/
 *  * /memberships/ *`.
 */
@property(nonatomic, copy, nullable) NSString *membership;

/**
 *  Output only. Whether the cluster has been registered through the fleet API.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preRegistered;

/**
 *  The Fleet host project(project ID or project number) where this cluster will
 *  be registered to. This field cannot be changed after the cluster has been
 *  registered.
 */
@property(nonatomic, copy, nullable) NSString *project;

@end


/**
 *  GatewayAPIConfig contains the desired config of Gateway API on this cluster.
 */
@interface GTLRContainer_GatewayAPIConfig : GTLRObject

/**
 *  The Gateway API release channel to use for Gateway API.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_GatewayAPIConfig_Channel_ChannelDisabled Gateway
 *        API support is disabled (Value: "CHANNEL_DISABLED")
 *    @arg @c kGTLRContainer_GatewayAPIConfig_Channel_ChannelExperimental
 *        Deprecated: use CHANNEL_STANDARD instead. Gateway API support is
 *        enabled, experimental CRDs are installed (Value:
 *        "CHANNEL_EXPERIMENTAL")
 *    @arg @c kGTLRContainer_GatewayAPIConfig_Channel_ChannelStandard Gateway
 *        API support is enabled, standard CRDs are installed (Value:
 *        "CHANNEL_STANDARD")
 *    @arg @c kGTLRContainer_GatewayAPIConfig_Channel_ChannelUnspecified Default
 *        value. (Value: "CHANNEL_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *channel;

@end


/**
 *  Configuration for the Compute Engine PD CSI driver.
 */
@interface GTLRContainer_GcePersistentDiskCsiDriverConfig : GTLRObject

/**
 *  Whether the Compute Engine PD CSI driver is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  GcfsConfig contains configurations of Google Container File System (image
 *  streaming).
 */
@interface GTLRContainer_GcfsConfig : GTLRObject

/**
 *  Whether to use GCFS.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration for the GCP Filestore CSI driver.
 */
@interface GTLRContainer_GcpFilestoreCsiDriverConfig : GTLRObject

/**
 *  Whether the GCP Filestore CSI driver is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  GCPSecretManagerCertificateConfig configures a secret from [Google Secret
 *  Manager](https://cloud.google.com/secret-manager).
 */
@interface GTLRContainer_GCPSecretManagerCertificateConfig : GTLRObject

/**
 *  Secret URI, in the form
 *  "projects/$PROJECT_ID/secrets/$SECRET_NAME/versions/$VERSION". Version can
 *  be fixed (e.g. "2") or "latest"
 */
@property(nonatomic, copy, nullable) NSString *secretUri;

@end


/**
 *  Configuration for the Cloud Storage Fuse CSI driver.
 */
@interface GTLRContainer_GcsFuseCsiDriverConfig : GTLRObject

/**
 *  Whether the Cloud Storage Fuse CSI driver is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  GetJSONWebKeysResponse is a valid JSON Web Key Set as specififed in rfc 7517
 */
@interface GTLRContainer_GetJSONWebKeysResponse : GTLRObject

/**
 *  For HTTP requests, this field is automatically extracted into the
 *  Cache-Control HTTP header.
 */
@property(nonatomic, strong, nullable) GTLRContainer_HttpCacheControlResponseHeader *cacheHeader;

/**
 *  The public component of the keys used by the cluster to sign token requests.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Jwk *> *keys;

@end


/**
 *  GetOpenIDConfigResponse is an OIDC discovery document for the cluster. See
 *  the OpenID Connect Discovery 1.0 specification for details.
 */
@interface GTLRContainer_GetOpenIDConfigResponse : GTLRObject

/**
 *  For HTTP requests, this field is automatically extracted into the
 *  Cache-Control HTTP header.
 */
@property(nonatomic, strong, nullable) GTLRContainer_HttpCacheControlResponseHeader *cacheHeader;

/** Supported claims. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *claimsSupported;

/** Supported grant types. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *grantTypes;

/** supported ID Token signing Algorithms. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *idTokenSigningAlgValuesSupported;

/** OIDC Issuer. */
@property(nonatomic, copy, nullable) NSString *issuer;

/** JSON Web Key uri. */
@property(nonatomic, copy, nullable) NSString *jwksUri;

/** Supported response types. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *responseTypesSupported;

/** Supported subject types. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *subjectTypesSupported;

@end


/**
 *  Configuration for the Backup for GKE Agent.
 */
@interface GTLRContainer_GkeBackupAgentConfig : GTLRObject

/**
 *  Whether the Backup for GKE agent is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  GPUDriverInstallationConfig specifies the version of GPU driver to be auto
 *  installed.
 */
@interface GTLRContainer_GPUDriverInstallationConfig : GTLRObject

/**
 *  Mode for how the GPU driver is installed.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_Default
 *        "Default" GPU driver in COS and Ubuntu. (Value: "DEFAULT")
 *    @arg @c kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_GpuDriverVersionUnspecified
 *        Default value is to not install any GPU driver. (Value:
 *        "GPU_DRIVER_VERSION_UNSPECIFIED")
 *    @arg @c kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_InstallationDisabled
 *        Disable GPU driver auto installation and needs manual installation
 *        (Value: "INSTALLATION_DISABLED")
 *    @arg @c kGTLRContainer_GPUDriverInstallationConfig_GpuDriverVersion_Latest
 *        "Latest" GPU driver in COS. (Value: "LATEST")
 */
@property(nonatomic, copy, nullable) NSString *gpuDriverVersion;

@end


/**
 *  GPUSharingConfig represents the GPU sharing configuration for Hardware
 *  Accelerators.
 */
@interface GTLRContainer_GPUSharingConfig : GTLRObject

/**
 *  The type of GPU sharing strategy to enable on the GPU node.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_GPUSharingConfig_GpuSharingStrategy_GpuSharingStrategyUnspecified
 *        Default value. (Value: "GPU_SHARING_STRATEGY_UNSPECIFIED")
 *    @arg @c kGTLRContainer_GPUSharingConfig_GpuSharingStrategy_Mps GPUs are
 *        shared between containers with NVIDIA MPS. (Value: "MPS")
 *    @arg @c kGTLRContainer_GPUSharingConfig_GpuSharingStrategy_TimeSharing
 *        GPUs are time-shared between containers. (Value: "TIME_SHARING")
 */
@property(nonatomic, copy, nullable) NSString *gpuSharingStrategy;

/**
 *  The max number of containers that can share a physical GPU.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxSharedClientsPerGpu;

@end


/**
 *  Configuration options for the horizontal pod autoscaling feature, which
 *  increases or decreases the number of replica pods a replication controller
 *  has based on the resource usage of the existing pods.
 */
@interface GTLRContainer_HorizontalPodAutoscaling : GTLRObject

/**
 *  Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
 *  When enabled, it ensures that metrics are collected into Stackdriver
 *  Monitoring.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  RFC-2616: cache control support
 */
@interface GTLRContainer_HttpCacheControlResponseHeader : GTLRObject

/**
 *  14.6 response cache age, in seconds since the response is generated
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *age;

/** 14.9 request and response directives */
@property(nonatomic, copy, nullable) NSString *directive;

/** 14.21 response cache expires, in RFC 1123 date format */
@property(nonatomic, copy, nullable) NSString *expires;

@end


/**
 *  Configuration options for the HTTP (L7) load balancing controller addon,
 *  which makes it easy to set up HTTP load balancers for services in a cluster.
 */
@interface GTLRContainer_HttpLoadBalancing : GTLRObject

/**
 *  Whether the HTTP Load Balancing controller is enabled in the cluster. When
 *  enabled, it runs a small pod in the cluster that manages the load balancers.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Hugepages amount in both 2m and 1g size
 */
@interface GTLRContainer_HugepagesConfig : GTLRObject

/**
 *  Optional. Amount of 1G hugepages
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hugepageSize1g;

/**
 *  Optional. Amount of 2M hugepages
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hugepageSize2m;

@end


/**
 *  IdentityServiceConfig is configuration for Identity Service which allows
 *  customers to use external identity providers with the K8S API
 */
@interface GTLRContainer_IdentityServiceConfig : GTLRObject

/**
 *  Whether to enable the Identity Service component
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  ILBSubsettingConfig contains the desired config of L4 Internal LoadBalancer
 *  subsetting on this cluster.
 */
@interface GTLRContainer_ILBSubsettingConfig : GTLRObject

/**
 *  Enables l4 ILB subsetting for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  IntraNodeVisibilityConfig contains the desired config of the intra-node
 *  visibility on this cluster.
 */
@interface GTLRContainer_IntraNodeVisibilityConfig : GTLRObject

/**
 *  Enables intra node visibility for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration for controlling how IPs are allocated in the cluster.
 */
@interface GTLRContainer_IPAllocationPolicy : GTLRObject

/**
 *  Output only. The additional pod ranges that are added to the cluster. These
 *  pod ranges can be used by new node pools to allocate pod IPs automatically.
 *  Once the range is removed it will not show up in IPAllocationPolicy.
 */
@property(nonatomic, strong, nullable) GTLRContainer_AdditionalPodRangesConfig *additionalPodRangesConfig;

/** This field is deprecated, use cluster_ipv4_cidr_block. */
@property(nonatomic, copy, nullable) NSString *clusterIpv4Cidr GTLR_DEPRECATED;

/**
 *  The IP address range for the cluster pod IPs. If this field is set, then
 *  `cluster.cluster_ipv4_cidr` must be left blank. This field is only
 *  applicable when `use_ip_aliases` is true. Set to blank to have a range
 *  chosen with the default size. Set to /netmask (e.g. `/14`) to have a range
 *  chosen with a specific netmask. Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g. `10.0.0.0/8`,
 *  `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range to use.
 */
@property(nonatomic, copy, nullable) NSString *clusterIpv4CidrBlock;

/**
 *  The name of the secondary range to be used for the cluster CIDR block. The
 *  secondary range will be used for pod IP addresses. This must be an existing
 *  secondary range associated with the cluster subnetwork. This field is only
 *  applicable with use_ip_aliases is true and create_subnetwork is false.
 */
@property(nonatomic, copy, nullable) NSString *clusterSecondaryRangeName;

/**
 *  Whether a new subnetwork will be created automatically for the cluster. This
 *  field is only applicable when `use_ip_aliases` is true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *createSubnetwork;

/**
 *  Output only. The utilization of the cluster default IPv4 range for the pod.
 *  The ratio is Usage/[Total number of IPs in the secondary range],
 *  Usage=numNodes*numZones*podIPsPerNode.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultPodIpv4RangeUtilization;

/**
 *  The ipv6 access type (internal or external) when create_subnetwork is true
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_IPAllocationPolicy_Ipv6AccessType_External Access
 *        type external (all v6 addresses are external IPs) (Value: "EXTERNAL")
 *    @arg @c kGTLRContainer_IPAllocationPolicy_Ipv6AccessType_Internal Access
 *        type internal (all v6 addresses are internal IPs) (Value: "INTERNAL")
 *    @arg @c kGTLRContainer_IPAllocationPolicy_Ipv6AccessType_Ipv6AccessTypeUnspecified
 *        Default value, will be defaulted as type external. (Value:
 *        "IPV6_ACCESS_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *ipv6AccessType;

/** This field is deprecated, use node_ipv4_cidr_block. */
@property(nonatomic, copy, nullable) NSString *nodeIpv4Cidr GTLR_DEPRECATED;

/**
 *  The IP address range of the instance IPs in this cluster. This is applicable
 *  only if `create_subnetwork` is true. Set to blank to have a range chosen
 *  with the default size. Set to /netmask (e.g. `/14`) to have a range chosen
 *  with a specific netmask. Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g. `10.0.0.0/8`,
 *  `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range to use.
 */
@property(nonatomic, copy, nullable) NSString *nodeIpv4CidrBlock;

/**
 *  [PRIVATE FIELD] Pod CIDR size overprovisioning config for the cluster. Pod
 *  CIDR size per node depends on max_pods_per_node. By default, the value of
 *  max_pods_per_node is doubled and then rounded off to next power of 2 to get
 *  the size of pod CIDR block per node. Example: max_pods_per_node of 30 would
 *  result in 64 IPs (/26). This config can disable the doubling of IPs (we
 *  still round off to next power of 2) Example: max_pods_per_node of 30 will
 *  result in 32 IPs (/27) when overprovisioning is disabled.
 */
@property(nonatomic, strong, nullable) GTLRContainer_PodCIDROverprovisionConfig *podCidrOverprovisionConfig;

/** This field is deprecated, use services_ipv4_cidr_block. */
@property(nonatomic, copy, nullable) NSString *servicesIpv4Cidr GTLR_DEPRECATED;

/**
 *  The IP address range of the services IPs in this cluster. If blank, a range
 *  will be automatically chosen with the default size. This field is only
 *  applicable when `use_ip_aliases` is true. Set to blank to have a range
 *  chosen with the default size. Set to /netmask (e.g. `/14`) to have a range
 *  chosen with a specific netmask. Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g. `10.0.0.0/8`,
 *  `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range to use.
 */
@property(nonatomic, copy, nullable) NSString *servicesIpv4CidrBlock;

/** Output only. The services IPv6 CIDR block for the cluster. */
@property(nonatomic, copy, nullable) NSString *servicesIpv6CidrBlock;

/**
 *  The name of the secondary range to be used as for the services CIDR block.
 *  The secondary range will be used for service ClusterIPs. This must be an
 *  existing secondary range associated with the cluster subnetwork. This field
 *  is only applicable with use_ip_aliases is true and create_subnetwork is
 *  false.
 */
@property(nonatomic, copy, nullable) NSString *servicesSecondaryRangeName;

/**
 *  The IP stack type of the cluster
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_IPAllocationPolicy_StackType_Ipv4 Cluster is IPV4
 *        only (Value: "IPV4")
 *    @arg @c kGTLRContainer_IPAllocationPolicy_StackType_Ipv4Ipv6 Cluster can
 *        use both IPv4 and IPv6 (Value: "IPV4_IPV6")
 *    @arg @c kGTLRContainer_IPAllocationPolicy_StackType_StackTypeUnspecified
 *        Default value, will be defaulted as IPV4 only (Value:
 *        "STACK_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *stackType;

/** Output only. The subnet's IPv6 CIDR block used by nodes and pods. */
@property(nonatomic, copy, nullable) NSString *subnetIpv6CidrBlock;

/**
 *  A custom subnetwork name to be used if `create_subnetwork` is true. If this
 *  field is empty, then an automatic name will be chosen for the new
 *  subnetwork.
 */
@property(nonatomic, copy, nullable) NSString *subnetworkName;

/**
 *  The IP address range of the Cloud TPUs in this cluster. If unspecified, a
 *  range will be automatically chosen with the default size. This field is only
 *  applicable when `use_ip_aliases` is true. If unspecified, the range will use
 *  the default size. Set to /netmask (e.g. `/14`) to have a range chosen with a
 *  specific netmask. Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation
 *  (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g. `10.0.0.0/8`,
 *  `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range to use.
 */
@property(nonatomic, copy, nullable) NSString *tpuIpv4CidrBlock;

/**
 *  Whether alias IPs will be used for pod IPs in the cluster. This is used in
 *  conjunction with use_routes. It cannot be true if use_routes is true. If
 *  both use_ip_aliases and use_routes are false, then the server picks the
 *  default IP allocation mode
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useIpAliases;

/**
 *  Whether routes will be used for pod IPs in the cluster. This is used in
 *  conjunction with use_ip_aliases. It cannot be true if use_ip_aliases is
 *  true. If both use_ip_aliases and use_routes are false, then the server picks
 *  the default IP allocation mode
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useRoutes;

@end


/**
 *  Jwk is a JSON Web Key as specified in RFC 7517
 */
@interface GTLRContainer_Jwk : GTLRObject

/** Algorithm. */
@property(nonatomic, copy, nullable) NSString *alg;

/** Used for ECDSA keys. */
@property(nonatomic, copy, nullable) NSString *crv;

/** Used for RSA keys. */
@property(nonatomic, copy, nullable) NSString *e;

/** Key ID. */
@property(nonatomic, copy, nullable) NSString *kid;

/** Key Type. */
@property(nonatomic, copy, nullable) NSString *kty;

/** Used for RSA keys. */
@property(nonatomic, copy, nullable) NSString *n;

/** Permitted uses for the public keys. */
@property(nonatomic, copy, nullable) NSString *use;

/** Used for ECDSA keys. */
@property(nonatomic, copy, nullable) NSString *x;

/** Used for ECDSA keys. */
@property(nonatomic, copy, nullable) NSString *y;

@end


/**
 *  K8sBetaAPIConfig , configuration for beta APIs
 */
@interface GTLRContainer_K8sBetaAPIConfig : GTLRObject

/** Enabled k8s beta APIs. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledApis;

@end


/**
 *  Configuration for the Kubernetes Dashboard.
 */
@interface GTLRContainer_KubernetesDashboard : GTLRObject

/**
 *  Whether the Kubernetes Dashboard is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Configuration for the legacy Attribute Based Access Control authorization
 *  mode.
 */
@interface GTLRContainer_LegacyAbac : GTLRObject

/**
 *  Whether the ABAC authorizer is enabled for this cluster. When enabled,
 *  identities in the system, including service accounts, nodes, and
 *  controllers, will have statically granted permissions beyond those provided
 *  by the RBAC configuration or IAM.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Parameters that can be configured on Linux nodes.
 */
@interface GTLRContainer_LinuxNodeConfig : GTLRObject

/**
 *  cgroup_mode specifies the cgroup mode to be used on the node.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_LinuxNodeConfig_CgroupMode_CgroupModeUnspecified
 *        CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is
 *        used. The default for the GKE node OS image will be used. (Value:
 *        "CGROUP_MODE_UNSPECIFIED")
 *    @arg @c kGTLRContainer_LinuxNodeConfig_CgroupMode_CgroupModeV1
 *        CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration
 *        on the node image. (Value: "CGROUP_MODE_V1")
 *    @arg @c kGTLRContainer_LinuxNodeConfig_CgroupMode_CgroupModeV2
 *        CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration
 *        on the node image. (Value: "CGROUP_MODE_V2")
 */
@property(nonatomic, copy, nullable) NSString *cgroupMode;

/** Optional. Amounts for 2M and 1G hugepages */
@property(nonatomic, strong, nullable) GTLRContainer_HugepagesConfig *hugepages;

/**
 *  The Linux kernel parameters to be applied to the nodes and all pods running
 *  on the nodes. The following parameters are supported. net.core.busy_poll
 *  net.core.busy_read net.core.netdev_max_backlog net.core.rmem_max
 *  net.core.wmem_default net.core.wmem_max net.core.optmem_max
 *  net.core.somaxconn net.ipv4.tcp_rmem net.ipv4.tcp_wmem net.ipv4.tcp_tw_reuse
 */
@property(nonatomic, strong, nullable) GTLRContainer_LinuxNodeConfig_Sysctls *sysctls;

@end


/**
 *  The Linux kernel parameters to be applied to the nodes and all pods running
 *  on the nodes. The following parameters are supported. net.core.busy_poll
 *  net.core.busy_read net.core.netdev_max_backlog net.core.rmem_max
 *  net.core.wmem_default net.core.wmem_max net.core.optmem_max
 *  net.core.somaxconn net.ipv4.tcp_rmem net.ipv4.tcp_wmem net.ipv4.tcp_tw_reuse
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_LinuxNodeConfig_Sysctls : GTLRObject
@end


/**
 *  ListClustersResponse is the result of ListClustersRequest.
 */
@interface GTLRContainer_ListClustersResponse : GTLRObject

/**
 *  A list of clusters in the project in the specified zone, or across all ones.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Cluster *> *clusters;

/**
 *  If any zones are listed here, the list of clusters returned may be missing
 *  those zones.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *missingZones;

@end


/**
 *  ListNodePoolsResponse is the result of ListNodePoolsRequest.
 */
@interface GTLRContainer_ListNodePoolsResponse : GTLRObject

/** A list of node pools for a cluster. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodePool *> *nodePools;

@end


/**
 *  ListOperationsResponse is the result of ListOperationsRequest.
 */
@interface GTLRContainer_ListOperationsResponse : GTLRObject

/**
 *  If any zones are listed here, the list of operations returned may be missing
 *  the operations from those zones.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *missingZones;

/** A list of operations in the project in the specified zone. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Operation *> *operations;

@end


/**
 *  ListUsableSubnetworksResponse is the response of
 *  ListUsableSubnetworksRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "subnetworks" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainer_ListUsableSubnetworksResponse : GTLRCollectionObject

/**
 *  This token allows you to get the next page of results for list requests. If
 *  the number of results is larger than `page_size`, use the `next_page_token`
 *  as a value for the query parameter `page_token` in the next request. The
 *  value will become empty when there are no more pages.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of usable subnetworks in the specified network project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_UsableSubnetwork *> *subnetworks;

@end


/**
 *  LocalNvmeSsdBlockConfig contains configuration for using raw-block local
 *  NVMe SSDs
 */
@interface GTLRContainer_LocalNvmeSsdBlockConfig : GTLRObject

/**
 *  Number of local NVMe SSDs to use. The limit for this value is dependent upon
 *  the maximum number of disk available on a machine per zone. See:
 *  https://cloud.google.com/compute/docs/disks/local-ssd for more information.
 *  A zero (or unset) value has different meanings depending on machine type
 *  being used: 1. For pre-Gen3 machines, which support flexible numbers of
 *  local ssds, zero (or unset) means to disable using local SSDs as ephemeral
 *  storage. 2. For Gen3 machines which dictate a specific number of local ssds,
 *  zero (or unset) means to use the default number of local ssds that goes with
 *  that machine type. For example, for a c3-standard-8-lssd machine, 2 local
 *  ssds would be provisioned. For c3-standard-8 (which doesn't support local
 *  ssds), 0 will be provisioned. See
 *  https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds
 *  for more info.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *localSsdCount;

@end


/**
 *  LoggingComponentConfig is cluster logging component configuration.
 */
@interface GTLRContainer_LoggingComponentConfig : GTLRObject

/**
 *  Select components to collect logs. An empty set would disable all logging.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enableComponents;

@end


/**
 *  LoggingConfig is cluster logging configuration.
 */
@interface GTLRContainer_LoggingConfig : GTLRObject

/** Logging components configuration */
@property(nonatomic, strong, nullable) GTLRContainer_LoggingComponentConfig *componentConfig;

@end


/**
 *  LoggingVariantConfig specifies the behaviour of the logging component.
 */
@interface GTLRContainer_LoggingVariantConfig : GTLRObject

/**
 *  Logging variant deployed on nodes.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_LoggingVariantConfig_Variant_Default default
 *        logging variant. (Value: "DEFAULT")
 *    @arg @c kGTLRContainer_LoggingVariantConfig_Variant_MaxThroughput maximum
 *        logging throughput variant. (Value: "MAX_THROUGHPUT")
 *    @arg @c kGTLRContainer_LoggingVariantConfig_Variant_VariantUnspecified
 *        Default value. This shouldn't be used. (Value: "VARIANT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *variant;

@end


/**
 *  Represents the Maintenance exclusion option.
 */
@interface GTLRContainer_MaintenanceExclusionOptions : GTLRObject

/**
 *  Scope specifies the upgrade scope which upgrades are blocked by the
 *  exclusion.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_MaintenanceExclusionOptions_Scope_NoMinorOrNodeUpgrades
 *        NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster,
 *        and also exclude all node pool upgrades. Only control plane patches
 *        are allowed. (Value: "NO_MINOR_OR_NODE_UPGRADES")
 *    @arg @c kGTLRContainer_MaintenanceExclusionOptions_Scope_NoMinorUpgrades
 *        NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only
 *        patches are allowed. (Value: "NO_MINOR_UPGRADES")
 *    @arg @c kGTLRContainer_MaintenanceExclusionOptions_Scope_NoUpgrades
 *        NO_UPGRADES excludes all upgrades, including patch upgrades and minor
 *        upgrades across control planes and nodes. This is the default
 *        exclusion behavior. (Value: "NO_UPGRADES")
 */
@property(nonatomic, copy, nullable) NSString *scope;

@end


/**
 *  MaintenancePolicy defines the maintenance policy to be used for the cluster.
 */
@interface GTLRContainer_MaintenancePolicy : GTLRObject

/**
 *  A hash identifying the version of this policy, so that updates to fields of
 *  the policy won't accidentally undo intermediate changes (and so that users
 *  of the API unaware of some fields won't accidentally remove other fields).
 *  Make a `get()` request to the cluster to get the current resource version
 *  and include it with requests to set the policy.
 */
@property(nonatomic, copy, nullable) NSString *resourceVersion;

/** Specifies the maintenance window in which maintenance may be performed. */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenanceWindow *window;

@end


/**
 *  MaintenanceWindow defines the maintenance window to be used for the cluster.
 */
@interface GTLRContainer_MaintenanceWindow : GTLRObject

/** DailyMaintenanceWindow specifies a daily maintenance operation window. */
@property(nonatomic, strong, nullable) GTLRContainer_DailyMaintenanceWindow *dailyMaintenanceWindow;

/**
 *  Exceptions to maintenance window. Non-emergency maintenance should not occur
 *  in these windows.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenanceWindow_MaintenanceExclusions *maintenanceExclusions;

/**
 *  RecurringWindow specifies some number of recurring time periods for
 *  maintenance to occur. The time windows may be overlapping. If no maintenance
 *  windows are set, maintenance can occur at any time.
 */
@property(nonatomic, strong, nullable) GTLRContainer_RecurringTimeWindow *recurringWindow;

@end


/**
 *  Exceptions to maintenance window. Non-emergency maintenance should not occur
 *  in these windows.
 *
 *  @note This class is documented as having more properties of
 *        GTLRContainer_TimeWindow. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRContainer_MaintenanceWindow_MaintenanceExclusions : GTLRObject
@end


/**
 *  ManagedPrometheusConfig defines the configuration for Google Cloud Managed
 *  Service for Prometheus.
 */
@interface GTLRContainer_ManagedPrometheusConfig : GTLRObject

/**
 *  Enable Managed Collection.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  The authentication information for accessing the master endpoint.
 *  Authentication can be done using HTTP basic auth or using client
 *  certificates.
 */
@interface GTLRContainer_MasterAuth : GTLRObject

/**
 *  Output only. Base64-encoded public certificate used by clients to
 *  authenticate to the cluster endpoint. Issued only if
 *  client_certificate_config is set.
 */
@property(nonatomic, copy, nullable) NSString *clientCertificate;

/**
 *  Configuration for client certificate authentication on the cluster. For
 *  clusters before v1.12, if no configuration is specified, a client
 *  certificate is issued.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ClientCertificateConfig *clientCertificateConfig;

/**
 *  Output only. Base64-encoded private key used by clients to authenticate to
 *  the cluster endpoint.
 */
@property(nonatomic, copy, nullable) NSString *clientKey;

/**
 *  Output only. Base64-encoded public certificate that is the root of trust for
 *  the cluster.
 */
@property(nonatomic, copy, nullable) NSString *clusterCaCertificate;

/**
 *  The password to use for HTTP basic authentication to the master endpoint.
 *  Because the master endpoint is open to the Internet, you should create a
 *  strong password. If a password is provided for cluster creation, username
 *  must be non-empty. Warning: basic authentication is deprecated, and will be
 *  removed in GKE control plane versions 1.19 and newer. For a list of
 *  recommended authentication methods, see:
 *  https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication
 */
@property(nonatomic, copy, nullable) NSString *password GTLR_DEPRECATED;

/**
 *  The username to use for HTTP basic authentication to the master endpoint.
 *  For clusters v1.6.0 and later, basic authentication can be disabled by
 *  leaving username unspecified (or setting it to the empty string). Warning:
 *  basic authentication is deprecated, and will be removed in GKE control plane
 *  versions 1.19 and newer. For a list of recommended authentication methods,
 *  see:
 *  https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication
 */
@property(nonatomic, copy, nullable) NSString *username GTLR_DEPRECATED;

@end


/**
 *  Configuration options for the master authorized networks feature. Enabled
 *  master authorized networks will disallow all external traffic to access
 *  Kubernetes master through HTTPS except traffic from the given CIDR blocks,
 *  Google Compute Engine Public IPs and Google Prod IPs.
 */
@interface GTLRContainer_MasterAuthorizedNetworksConfig : GTLRObject

/**
 *  cidr_blocks define up to 50 external networks that could access Kubernetes
 *  master through HTTPS.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_CidrBlock *> *cidrBlocks;

/**
 *  Whether or not master authorized networks is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Whether master is accessbile via Google Compute Engine Public IP addresses.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gcpPublicCidrsAccessEnabled;

@end


/**
 *  Constraints applied to pods.
 */
@interface GTLRContainer_MaxPodsConstraint : GTLRObject

/**
 *  Constraint enforced on the max num of pods per node.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPodsPerNode;

@end


/**
 *  Configuration for issuance of mTLS keys and certificates to Kubernetes pods.
 */
@interface GTLRContainer_MeshCertificates : GTLRObject

/**
 *  enable_certificates controls issuance of workload mTLS certificates. If set,
 *  the GKE Workload Identity Certificates controller and node agent will be
 *  deployed in the cluster, which can then be configured by creating a
 *  WorkloadCertificateConfig Custom Resource. Requires Workload Identity
 *  (workload_pool must be non-empty).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableCertificates;

@end


/**
 *  Progress metric is (string, int|float|string) pair.
 */
@interface GTLRContainer_Metric : GTLRObject

/**
 *  For metrics with floating point value.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  For metrics with integer value.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *intValue;

/** Required. Metric name, e.g., "nodes total", "percent done". */
@property(nonatomic, copy, nullable) NSString *name;

/** For metrics with custom values (ratios, visual progress, etc.). */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  MonitoringComponentConfig is cluster monitoring component configuration.
 */
@interface GTLRContainer_MonitoringComponentConfig : GTLRObject

/**
 *  Select components to collect metrics. An empty set would disable all
 *  monitoring.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enableComponents;

@end


/**
 *  MonitoringConfig is cluster monitoring configuration.
 */
@interface GTLRContainer_MonitoringConfig : GTLRObject

/** Configuration of Advanced Datapath Observability features. */
@property(nonatomic, strong, nullable) GTLRContainer_AdvancedDatapathObservabilityConfig *advancedDatapathObservabilityConfig;

/** Monitoring components configuration */
@property(nonatomic, strong, nullable) GTLRContainer_MonitoringComponentConfig *componentConfig;

/** Enable Google Cloud Managed Service for Prometheus in the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_ManagedPrometheusConfig *managedPrometheusConfig;

@end


/**
 *  NetworkConfig reports the relative names of network & subnetwork.
 */
@interface GTLRContainer_NetworkConfig : GTLRObject

/**
 *  The desired datapath provider for this cluster. By default, uses the
 *  IPTables-based kube-proxy implementation.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NetworkConfig_DatapathProvider_AdvancedDatapath Use
 *        the eBPF based GKE Dataplane V2 with additional features. See the [GKE
 *        Dataplane V2
 *        documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
 *        for more. (Value: "ADVANCED_DATAPATH")
 *    @arg @c kGTLRContainer_NetworkConfig_DatapathProvider_DatapathProviderUnspecified
 *        Default value. (Value: "DATAPATH_PROVIDER_UNSPECIFIED")
 *    @arg @c kGTLRContainer_NetworkConfig_DatapathProvider_LegacyDatapath Use
 *        the IPTables implementation based on kube-proxy. (Value:
 *        "LEGACY_DATAPATH")
 */
@property(nonatomic, copy, nullable) NSString *datapathProvider;

/**
 *  Whether the cluster disables default in-node sNAT rules. In-node sNAT rules
 *  will be disabled when default_snat_status is disabled. When disabled is set
 *  to false, default IP masquerade rules will be applied to the nodes to
 *  prevent sNAT on cluster internal traffic.
 */
@property(nonatomic, strong, nullable) GTLRContainer_DefaultSnatStatus *defaultSnatStatus;

/** DNSConfig contains clusterDNS config for this cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_DNSConfig *dnsConfig;

/**
 *  Whether CiliumClusterwideNetworkPolicy is enabled on this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableCiliumClusterwideNetworkPolicy;

/**
 *  Whether FQDN Network Policy is enabled on this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableFqdnNetworkPolicy;

/**
 *  Whether Intra-node visibility is enabled for this cluster. This makes same
 *  node pod to pod traffic visible for VPC network.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableIntraNodeVisibility;

/**
 *  Whether L4ILB Subsetting is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableL4ilbSubsetting;

/**
 *  Whether multi-networking is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableMultiNetworking;

/**
 *  GatewayAPIConfig contains the desired config of Gateway API on this cluster.
 */
@property(nonatomic, strong, nullable) GTLRContainer_GatewayAPIConfig *gatewayApiConfig;

/**
 *  Specify the details of in-transit encryption. Now named inter-node
 *  transparent encryption.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NetworkConfig_InTransitEncryptionConfig_InTransitEncryptionConfigUnspecified
 *        Unspecified, will be inferred as default -
 *        IN_TRANSIT_ENCRYPTION_UNSPECIFIED. (Value:
 *        "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED")
 *    @arg @c kGTLRContainer_NetworkConfig_InTransitEncryptionConfig_InTransitEncryptionDisabled
 *        In-transit encryption is disabled. (Value:
 *        "IN_TRANSIT_ENCRYPTION_DISABLED")
 *    @arg @c kGTLRContainer_NetworkConfig_InTransitEncryptionConfig_InTransitEncryptionInterNodeTransparent
 *        Data in-transit is encrypted using inter-node transparent encryption.
 *        (Value: "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT")
 */
@property(nonatomic, copy, nullable) NSString *inTransitEncryptionConfig;

/**
 *  Output only. The relative name of the Google Compute Engine
 *  network(https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
 *  to which the cluster is connected. Example:
 *  projects/my-project/global/networks/my-network
 */
@property(nonatomic, copy, nullable) NSString *network;

/** Network bandwidth tier configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_ClusterNetworkPerformanceConfig *networkPerformanceConfig;

/**
 *  The desired state of IPv6 connectivity to Google Services. By default, no
 *  private IPv6 access to or from Google Services (all access will be via IPv4)
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessBidirectional
 *        Enables private IPv6 access to and from Google Services (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL")
 *    @arg @c kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessDisabled
 *        No private access to or from Google Services (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED")
 *    @arg @c kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessToGoogle
 *        Enables private IPv6 access to Google Services from GKE (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE")
 *    @arg @c kGTLRContainer_NetworkConfig_PrivateIpv6GoogleAccess_PrivateIpv6GoogleAccessUnspecified
 *        Default value. Same as DISABLED (Value:
 *        "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *privateIpv6GoogleAccess;

/**
 *  ServiceExternalIPsConfig specifies if services with externalIPs field are
 *  blocked or not.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ServiceExternalIPsConfig *serviceExternalIpsConfig;

/**
 *  Output only. The relative name of the Google Compute Engine
 *  [subnetwork](https://cloud.google.com/compute/docs/vpc) to which the cluster
 *  is connected. Example:
 *  projects/my-project/regions/us-central1/subnetworks/my-subnet
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

@end


/**
 *  Configuration of all network bandwidth tiers
 */
@interface GTLRContainer_NetworkPerformanceConfig : GTLRObject

/**
 *  Specifies the total network bandwidth tier for the NodePool.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NetworkPerformanceConfig_TotalEgressBandwidthTier_Tier1
 *        Higher bandwidth, actual values based on VM size. (Value: "TIER_1")
 *    @arg @c kGTLRContainer_NetworkPerformanceConfig_TotalEgressBandwidthTier_TierUnspecified
 *        Default value (Value: "TIER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *totalEgressBandwidthTier;

@end


/**
 *  Configuration options for the NetworkPolicy feature.
 *  https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
 */
@interface GTLRContainer_NetworkPolicy : GTLRObject

/**
 *  Whether network policy is enabled on the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  The selected network policy provider.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NetworkPolicy_Provider_Calico Tigera (Calico
 *        Felix). (Value: "CALICO")
 *    @arg @c kGTLRContainer_NetworkPolicy_Provider_ProviderUnspecified Not set
 *        (Value: "PROVIDER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *provider;

@end


/**
 *  Configuration for NetworkPolicy. This only tracks whether the addon is
 *  enabled or not on the Master, it does not track whether network policy is
 *  enabled for the nodes.
 */
@interface GTLRContainer_NetworkPolicyConfig : GTLRObject

/**
 *  Whether NetworkPolicy is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Collection of Compute Engine network tags that can be applied to a node's
 *  underlying VM instance.
 */
@interface GTLRContainer_NetworkTags : GTLRObject

/** List of network tags. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  Specifies the NodeAffinity key, values, and affinity operator according to
 *  [shared sole tenant node group
 *  affinities](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity).
 */
@interface GTLRContainer_NodeAffinity : GTLRObject

/** Key for NodeAffinity. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Operator for NodeAffinity.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NodeAffinity_OperatorProperty_In Affinity operator.
 *        (Value: "IN")
 *    @arg @c kGTLRContainer_NodeAffinity_OperatorProperty_NotIn Anti-affinity
 *        operator. (Value: "NOT_IN")
 *    @arg @c kGTLRContainer_NodeAffinity_OperatorProperty_OperatorUnspecified
 *        Invalid or unspecified affinity operator. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

/** Values for NodeAffinity. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  Parameters that describe the nodes in a cluster. GKE Autopilot clusters do
 *  not recognize parameters in `NodeConfig`. Use
 *  AutoprovisioningNodePoolDefaults instead.
 */
@interface GTLRContainer_NodeConfig : GTLRObject

/**
 *  A list of hardware accelerators to be attached to each node. See
 *  https://cloud.google.com/compute/docs/gpus for more information about
 *  support for GPUs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_AcceleratorConfig *> *accelerators;

/** Advanced features for the Compute Engine VM. */
@property(nonatomic, strong, nullable) GTLRContainer_AdvancedMachineFeatures *advancedMachineFeatures;

/**
 *  The Customer Managed Encryption Key used to encrypt the boot disk attached
 *  to each node in the node pool. This should be of the form
 *  projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
 *  For more information about protecting resources with Cloud KMS Keys please
 *  see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
 */
@property(nonatomic, copy, nullable) NSString *bootDiskKmsKey;

/**
 *  Confidential nodes config. All the nodes in the node pool will be
 *  Confidential VM once enabled.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ConfidentialNodes *confidentialNodes;

/** Parameters for containerd customization. */
@property(nonatomic, strong, nullable) GTLRContainer_DConfig *containerdConfig;

/**
 *  Size of the disk attached to each node, specified in GB. The smallest
 *  allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskSizeGb;

/**
 *  Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
 *  'pd-balanced') If unspecified, the default disk type is 'pd-standard'
 */
@property(nonatomic, copy, nullable) NSString *diskType;

/**
 *  Optional. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableConfidentialStorage;

/**
 *  Parameters for the node ephemeral storage using Local SSDs. If unspecified,
 *  ephemeral storage is backed by the boot disk.
 */
@property(nonatomic, strong, nullable) GTLRContainer_EphemeralStorageLocalSsdConfig *ephemeralStorageLocalSsdConfig;

/** Enable or disable NCCL fast socket for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_FastSocket *fastSocket;

/** Google Container File System (image streaming) configs. */
@property(nonatomic, strong, nullable) GTLRContainer_GcfsConfig *gcfsConfig;

/** Enable or disable gvnic in the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_VirtualNIC *gvnic;

/**
 *  The image type to use for this node. Note that for a given image type, the
 *  latest version of it will be used. Please see
 *  https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
 *  available image types.
 */
@property(nonatomic, copy, nullable) NSString *imageType;

/** Node kubelet configs. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeKubeletConfig *kubeletConfig;

/**
 *  The map of Kubernetes labels (key/value pairs) to be applied to each node.
 *  These will added in addition to any default label(s) that Kubernetes may
 *  apply to the node. In case of conflict in label keys, the applied set may
 *  differ depending on the Kubernetes version -- it's best to assume the
 *  behavior is undefined and conflicts should be avoided. For more information,
 *  including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig_Labels *labels;

/** Parameters that can be configured on Linux nodes. */
@property(nonatomic, strong, nullable) GTLRContainer_LinuxNodeConfig *linuxNodeConfig;

/** Parameters for using raw-block Local NVMe SSDs. */
@property(nonatomic, strong, nullable) GTLRContainer_LocalNvmeSsdBlockConfig *localNvmeSsdBlockConfig;

/**
 *  The number of local SSD disks to be attached to the node. The limit for this
 *  value is dependent upon the maximum number of disks available on a machine
 *  per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for
 *  more information.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *localSsdCount;

/** Logging configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolLoggingConfig *loggingConfig;

/**
 *  The name of a Google Compute Engine [machine
 *  type](https://cloud.google.com/compute/docs/machine-types) If unspecified,
 *  the default machine type is `e2-medium`.
 */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  The metadata key/value pairs assigned to instances in the cluster. Keys must
 *  conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length.
 *  These are reflected as part of a URL in the metadata server. Additionally,
 *  to avoid ambiguity, keys must not conflict with any other metadata keys for
 *  the project or be one of the reserved keys: - "cluster-location" -
 *  "cluster-name" - "cluster-uid" - "configure-sh" - "containerd-configure-sh"
 *  - "enable-os-login" - "gci-ensure-gke-docker" - "gci-metrics-enabled" -
 *  "gci-update-strategy" - "instance-template" - "kube-env" - "startup-script"
 *  - "user-data" - "disable-address-manager" - "windows-startup-script-ps1" -
 *  "common-psm1" - "k8s-node-setup-psm1" - "install-ssh-psm1" -
 *  "user-profile-psm1" Values are free-form strings, and only have meaning as
 *  interpreted by the image running in the instance. The only restriction
 *  placed on them is that each value's size must be less than or equal to 32
 *  KB. The total size of all keys and values must be less than 512 KB.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig_Metadata *metadata;

/**
 *  Minimum CPU platform to be used by this instance. The instance may be
 *  scheduled on the specified or newer CPU platform. Applicable values are the
 *  friendly names of CPU platforms, such as `minCpuPlatform: "Intel Haswell"`
 *  or `minCpuPlatform: "Intel Sandy Bridge"`. For more information, read [how
 *  to specify min CPU
 *  platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
 */
@property(nonatomic, copy, nullable) NSString *minCpuPlatform;

/**
 *  Setting this field will assign instances of this pool to run on the
 *  specified node group. This is useful for running workloads on [sole tenant
 *  nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
 */
@property(nonatomic, copy, nullable) NSString *nodeGroup;

/**
 *  The set of Google API scopes to be made available on all of the node VMs
 *  under the "default" service account. The following scopes are recommended,
 *  but not required, and by default are not included: *
 *  `https://www.googleapis.com/auth/compute` is required for mounting
 *  persistent storage on your nodes. *
 *  `https://www.googleapis.com/auth/devstorage.read_only` is required for
 *  communicating with **gcr.io** (the [Google Container
 *  Registry](https://cloud.google.com/container-registry/)). If unspecified, no
 *  scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in
 *  which case their required scopes will be added.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oauthScopes;

/**
 *  Whether the nodes are created as preemptible VM instances. See:
 *  https://cloud.google.com/compute/docs/instances/preemptible for more
 *  information about preemptible VM instances.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preemptible;

/**
 *  The optional reservation affinity. Setting this field will apply the
 *  specified [Zonal Compute
 *  Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
 *  to this node pool.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ReservationAffinity *reservationAffinity;

/**
 *  The resource labels for the node pool to use to annotate any related Google
 *  Compute Engine resources.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig_ResourceLabels *resourceLabels;

/**
 *  A map of resource manager tag keys and values to be attached to the nodes.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceManagerTags *resourceManagerTags;

/** Sandbox configuration for this node. */
@property(nonatomic, strong, nullable) GTLRContainer_SandboxConfig *sandboxConfig;

/** List of secondary boot disks attached to the nodes. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_SecondaryBootDisk *> *secondaryBootDisks;

/** Secondary boot disk update strategy. */
@property(nonatomic, strong, nullable) GTLRContainer_SecondaryBootDiskUpdateStrategy *secondaryBootDiskUpdateStrategy;

/**
 *  The Google Cloud Platform Service Account to be used by the node VMs.
 *  Specify the email address of the Service Account; otherwise, if no Service
 *  Account is specified, the "default" service account is used.
 */
@property(nonatomic, copy, nullable) NSString *serviceAccount;

/** Shielded Instance options. */
@property(nonatomic, strong, nullable) GTLRContainer_ShieldedInstanceConfig *shieldedInstanceConfig;

/**
 *  Parameters for node pools to be backed by shared sole tenant node groups.
 */
@property(nonatomic, strong, nullable) GTLRContainer_SoleTenantConfig *soleTenantConfig;

/**
 *  Spot flag for enabling Spot VM, which is a rebrand of the existing
 *  preemptible flag.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *spot;

/** List of Storage Pools where boot disks are provisioned. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *storagePools;

/**
 *  The list of instance tags applied to all nodes. Tags are used to identify
 *  valid sources or targets for network firewalls and are specified by the
 *  client during cluster or node pool creation. Each tag within the list must
 *  comply with RFC1035.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

/**
 *  List of kubernetes taints to be applied to each node. For more information,
 *  including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodeTaint *> *taints;

/** Parameters that can be configured on Windows nodes. */
@property(nonatomic, strong, nullable) GTLRContainer_WindowsNodeConfig *windowsNodeConfig;

/** The workload metadata configuration for this node. */
@property(nonatomic, strong, nullable) GTLRContainer_WorkloadMetadataConfig *workloadMetadataConfig;

@end


/**
 *  The map of Kubernetes labels (key/value pairs) to be applied to each node.
 *  These will added in addition to any default label(s) that Kubernetes may
 *  apply to the node. In case of conflict in label keys, the applied set may
 *  differ depending on the Kubernetes version -- it's best to assume the
 *  behavior is undefined and conflicts should be avoided. For more information,
 *  including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_NodeConfig_Labels : GTLRObject
@end


/**
 *  The metadata key/value pairs assigned to instances in the cluster. Keys must
 *  conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length.
 *  These are reflected as part of a URL in the metadata server. Additionally,
 *  to avoid ambiguity, keys must not conflict with any other metadata keys for
 *  the project or be one of the reserved keys: - "cluster-location" -
 *  "cluster-name" - "cluster-uid" - "configure-sh" - "containerd-configure-sh"
 *  - "enable-os-login" - "gci-ensure-gke-docker" - "gci-metrics-enabled" -
 *  "gci-update-strategy" - "instance-template" - "kube-env" - "startup-script"
 *  - "user-data" - "disable-address-manager" - "windows-startup-script-ps1" -
 *  "common-psm1" - "k8s-node-setup-psm1" - "install-ssh-psm1" -
 *  "user-profile-psm1" Values are free-form strings, and only have meaning as
 *  interpreted by the image running in the instance. The only restriction
 *  placed on them is that each value's size must be less than or equal to 32
 *  KB. The total size of all keys and values must be less than 512 KB.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_NodeConfig_Metadata : GTLRObject
@end


/**
 *  The resource labels for the node pool to use to annotate any related Google
 *  Compute Engine resources.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_NodeConfig_ResourceLabels : GTLRObject
@end


/**
 *  Subset of NodeConfig message that has defaults.
 */
@interface GTLRContainer_NodeConfigDefaults : GTLRObject

/** Parameters for containerd customization. */
@property(nonatomic, strong, nullable) GTLRContainer_DConfig *containerdConfig;

/** GCFS (Google Container File System, also known as Riptide) options. */
@property(nonatomic, strong, nullable) GTLRContainer_GcfsConfig *gcfsConfig;

/** Logging configuration for node pools. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolLoggingConfig *loggingConfig;

/**
 *  NodeKubeletConfig controls the defaults for new node-pools. Currently only
 *  `insecure_kubelet_readonly_port_enabled` can be set here.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeKubeletConfig *nodeKubeletConfig;

@end


/**
 *  Node kubelet configs.
 */
@interface GTLRContainer_NodeKubeletConfig : GTLRObject

/**
 *  Enable CPU CFS quota enforcement for containers that specify CPU limits.
 *  This option is enabled by default which makes kubelet use CFS quota
 *  (https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) to
 *  enforce container CPU limits. Otherwise, CPU limits will not be enforced at
 *  all. Disable this option to mitigate CPU throttling problems while still
 *  having your pods to be in Guaranteed QoS class by specifying the CPU limits.
 *  The default value is 'true' if unspecified.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cpuCfsQuota;

/**
 *  Set the CPU CFS quota period value 'cpu.cfs_period_us'. The string must be a
 *  sequence of decimal numbers, each with optional fraction and a unit suffix,
 *  such as "300ms". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m",
 *  "h". The value must be a positive duration.
 */
@property(nonatomic, copy, nullable) NSString *cpuCfsQuotaPeriod;

/**
 *  Control the CPU management policy on the node. See
 *  https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/
 *  The following values are allowed. * "none": the default, which represents
 *  the existing scheduling behavior. * "static": allows pods with certain
 *  resource characteristics to be granted increased CPU affinity and
 *  exclusivity on the node. The default value is 'none' if unspecified.
 */
@property(nonatomic, copy, nullable) NSString *cpuManagerPolicy;

/**
 *  Enable or disable Kubelet read only port.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *insecureKubeletReadonlyPortEnabled;

/**
 *  Set the Pod PID limits. See
 *  https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits
 *  Controls the maximum number of processes allowed to run in a pod. The value
 *  must be greater than or equal to 1024 and less than 4194304.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podPidsLimit;

@end


/**
 *  Collection of node-level [Kubernetes
 *  labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels).
 */
@interface GTLRContainer_NodeLabels : GTLRObject

/** Map of node label keys and node label values. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeLabels_Labels *labels;

@end


/**
 *  Map of node label keys and node label values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_NodeLabels_Labels : GTLRObject
@end


/**
 *  NodeManagement defines the set of node management services turned on for the
 *  node pool.
 */
@interface GTLRContainer_NodeManagement : GTLRObject

/**
 *  A flag that specifies whether the node auto-repair is enabled for the node
 *  pool. If enabled, the nodes in this node pool will be monitored and, if they
 *  fail health checks too many times, an automatic repair action will be
 *  triggered.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoRepair;

/**
 *  A flag that specifies whether node auto-upgrade is enabled for the node
 *  pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
 *  up to date with the latest release version of Kubernetes.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoUpgrade;

/** Specifies the Auto Upgrade knobs for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_AutoUpgradeOptions *upgradeOptions;

@end


/**
 *  Parameters for node pool-level network config.
 */
@interface GTLRContainer_NodeNetworkConfig : GTLRObject

/**
 *  We specify the additional node networks for this node pool using this list.
 *  Each node network corresponds to an additional interface
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_AdditionalNodeNetworkConfig *> *additionalNodeNetworkConfigs;

/**
 *  We specify the additional pod networks for this node pool using this list.
 *  Each pod network corresponds to an additional alias IP range for the node
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_AdditionalPodNetworkConfig *> *additionalPodNetworkConfigs;

/**
 *  Input only. Whether to create a new range for pod IPs in this node pool.
 *  Defaults are provided for `pod_range` and `pod_ipv4_cidr_block` if they are
 *  not specified. If neither `create_pod_range` or `pod_range` are specified,
 *  the cluster-level default (`ip_allocation_policy.cluster_ipv4_cidr_block`)
 *  is used. Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
 *  This field cannot be changed after the node pool has been created.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *createPodRange;

/**
 *  Whether nodes have internal IP addresses only. If enable_private_nodes is
 *  not specified, then the value is derived from
 *  cluster.privateClusterConfig.enablePrivateNodes
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enablePrivateNodes;

/** Network bandwidth tier configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPerformanceConfig *networkPerformanceConfig;

/**
 *  [PRIVATE FIELD] Pod CIDR size overprovisioning config for the nodepool. Pod
 *  CIDR size per node depends on max_pods_per_node. By default, the value of
 *  max_pods_per_node is rounded off to next power of 2 and we then double that
 *  to get the size of pod CIDR block per node. Example: max_pods_per_node of 30
 *  would result in 64 IPs (/26). This config can disable the doubling of IPs
 *  (we still round off to next power of 2) Example: max_pods_per_node of 30
 *  will result in 32 IPs (/27) when overprovisioning is disabled.
 */
@property(nonatomic, strong, nullable) GTLRContainer_PodCIDROverprovisionConfig *podCidrOverprovisionConfig;

/**
 *  The IP address range for pod IPs in this node pool. Only applicable if
 *  `create_pod_range` is true. Set to blank to have a range chosen with the
 *  default size. Set to /netmask (e.g. `/14`) to have a range chosen with a
 *  specific netmask. Set to a
 *  [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
 *  notation (e.g. `10.96.0.0/14`) to pick a specific range to use. Only
 *  applicable if `ip_allocation_policy.use_ip_aliases` is true. This field
 *  cannot be changed after the node pool has been created.
 */
@property(nonatomic, copy, nullable) NSString *podIpv4CidrBlock;

/**
 *  Output only. The utilization of the IPv4 range for the pod. The ratio is
 *  Usage/[Total number of IPs in the secondary range],
 *  Usage=numNodes*numZones*podIPsPerNode.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podIpv4RangeUtilization;

/**
 *  The ID of the secondary range for pod IPs. If `create_pod_range` is true,
 *  this ID is used for the new range. If `create_pod_range` is false, uses an
 *  existing secondary range with this ID. Only applicable if
 *  `ip_allocation_policy.use_ip_aliases` is true. This field cannot be changed
 *  after the node pool has been created.
 */
@property(nonatomic, copy, nullable) NSString *podRange;

@end


/**
 *  NodePool contains the name and configuration for a cluster's node pool. Node
 *  pools are a set of nodes (i.e. VM's), with a common configuration and
 *  specification, under the control of the cluster master. They may have a set
 *  of Kubernetes labels applied to them, which may be used to reference them
 *  during pod scheduling. They may also be resized up or down, to accommodate
 *  the workload.
 */
@interface GTLRContainer_NodePool : GTLRObject

/**
 *  Autoscaler configuration for this NodePool. Autoscaler is enabled only if a
 *  valid configuration is present.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoscaling *autoscaling;

/** Enable best effort provisioning for nodes */
@property(nonatomic, strong, nullable) GTLRContainer_BestEffortProvisioning *bestEffortProvisioning;

/** Which conditions caused the current node pool state. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_StatusCondition *> *conditions;

/** The node configuration of the pool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig *config;

/**
 *  This checksum is computed by the server based on the value of node pool
 *  fields, and may be sent on update requests to ensure the client has an
 *  up-to-date value before proceeding.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  The initial node count for the pool. You must ensure that your Compute
 *  Engine [resource quota](https://cloud.google.com/compute/quotas) is
 *  sufficient for this number of instances. You must also have available
 *  firewall and routes quota.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialNodeCount;

/**
 *  Output only. The resource URLs of the [managed instance
 *  groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
 *  associated with this node pool. During the node pool blue-green upgrade
 *  operation, the URLs contain both blue and green resources.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instanceGroupUrls;

/**
 *  The list of Google Compute Engine
 *  [zones](https://cloud.google.com/compute/docs/zones#available) in which the
 *  NodePool's nodes should be located. If this value is unspecified during node
 *  pool creation, the
 *  [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations)
 *  value will be used, instead. Warning: changing node pool locations will
 *  result in nodes being added and/or removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locations;

/** NodeManagement configuration for this NodePool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeManagement *management;

/**
 *  The constraint on the maximum number of pods that can be run simultaneously
 *  on a node in the node pool.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MaxPodsConstraint *maxPodsConstraint;

/** The name of the node pool. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Networking configuration for this NodePool. If specified, it overrides the
 *  cluster-level defaults.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeNetworkConfig *networkConfig;

/** Specifies the node placement policy. */
@property(nonatomic, strong, nullable) GTLRContainer_PlacementPolicy *placementPolicy;

/**
 *  Output only. The pod CIDR block size per node in this node pool.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podIpv4CidrSize;

/** Specifies the configuration of queued provisioning. */
@property(nonatomic, strong, nullable) GTLRContainer_QueuedProvisioning *queuedProvisioning;

/** Output only. Server-defined URL for the resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  Output only. The status of the nodes in this pool instance.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NodePool_Status_Error The ERROR state indicates the
 *        node pool may be unusable. Details can be found in the `statusMessage`
 *        field. (Value: "ERROR")
 *    @arg @c kGTLRContainer_NodePool_Status_Provisioning The PROVISIONING state
 *        indicates the node pool is being created. (Value: "PROVISIONING")
 *    @arg @c kGTLRContainer_NodePool_Status_Reconciling The RECONCILING state
 *        indicates that some work is actively being done on the node pool, such
 *        as upgrading node software. Details can be found in the
 *        `statusMessage` field. (Value: "RECONCILING")
 *    @arg @c kGTLRContainer_NodePool_Status_Running The RUNNING state indicates
 *        the node pool has been created and is fully usable. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_NodePool_Status_RunningWithError The
 *        RUNNING_WITH_ERROR state indicates the node pool has been created and
 *        is partially usable. Some error state has occurred and some
 *        functionality may be impaired. Customer may need to reissue a request
 *        or trigger a new update. (Value: "RUNNING_WITH_ERROR")
 *    @arg @c kGTLRContainer_NodePool_Status_StatusUnspecified Not set. (Value:
 *        "STATUS_UNSPECIFIED")
 *    @arg @c kGTLRContainer_NodePool_Status_Stopping The STOPPING state
 *        indicates the node pool is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  Output only. Deprecated. Use conditions instead. Additional information
 *  about the current status of this node pool instance, if available.
 */
@property(nonatomic, copy, nullable) NSString *statusMessage GTLR_DEPRECATED;

/**
 *  Output only. Update info contains relevant information during a node pool
 *  update.
 */
@property(nonatomic, strong, nullable) GTLRContainer_UpdateInfo *updateInfo;

/** Upgrade settings control disruption and speed of the upgrade. */
@property(nonatomic, strong, nullable) GTLRContainer_UpgradeSettings *upgradeSettings;

/**
 *  The version of Kubernetes running on this NodePool's nodes. If unspecified,
 *  it defaults as described
 *  [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version).
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Node pool configs that apply to all auto-provisioned node pools in autopilot
 *  clusters and node auto-provisioning enabled clusters.
 */
@interface GTLRContainer_NodePoolAutoConfig : GTLRObject

/**
 *  The list of instance tags applied to all nodes. Tags are used to identify
 *  valid sources or targets for network firewalls and are specified by the
 *  client during cluster creation. Each tag within the list must comply with
 *  RFC1035.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkTags *networkTags;

/**
 *  NodeKubeletConfig controls the defaults for autoprovisioned node-pools.
 *  Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeKubeletConfig *nodeKubeletConfig;

/**
 *  Resource manager tag keys and values to be attached to the nodes for
 *  managing Compute Engine firewalls using Network Firewall Policies.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceManagerTags *resourceManagerTags;

@end


/**
 *  NodePoolAutoscaling contains information required by cluster autoscaler to
 *  adjust the size of the node pool to the current cluster usage.
 */
@interface GTLRContainer_NodePoolAutoscaling : GTLRObject

/**
 *  Can this node pool be deleted automatically.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoprovisioned;

/**
 *  Is autoscaling enabled for this node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Location policy used when scaling up a nodepool.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NodePoolAutoscaling_LocationPolicy_Any ANY policy
 *        picks zones that have the highest capacity available. (Value: "ANY")
 *    @arg @c kGTLRContainer_NodePoolAutoscaling_LocationPolicy_Balanced
 *        BALANCED is a best effort policy that aims to balance the sizes of
 *        different zones. (Value: "BALANCED")
 *    @arg @c kGTLRContainer_NodePoolAutoscaling_LocationPolicy_LocationPolicyUnspecified
 *        Not set. (Value: "LOCATION_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *locationPolicy;

/**
 *  Maximum number of nodes for one location in the NodePool. Must be >=
 *  min_node_count. There has to be enough quota to scale up the cluster.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxNodeCount;

/**
 *  Minimum number of nodes for one location in the NodePool. Must be >= 1 and
 *  <= max_node_count.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minNodeCount;

/**
 *  Maximum number of nodes in the node pool. Must be greater than
 *  total_min_node_count. There has to be enough quota to scale up the cluster.
 *  The total_*_node_count fields are mutually exclusive with the *_node_count
 *  fields.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalMaxNodeCount;

/**
 *  Minimum number of nodes in the node pool. Must be greater than 1 less than
 *  total_max_node_count. The total_*_node_count fields are mutually exclusive
 *  with the *_node_count fields.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalMinNodeCount;

@end


/**
 *  Subset of Nodepool message that has defaults.
 */
@interface GTLRContainer_NodePoolDefaults : GTLRObject

/** Subset of NodeConfig message that has defaults. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfigDefaults *nodeConfigDefaults;

@end


/**
 *  NodePoolLoggingConfig specifies logging configuration for nodepools.
 */
@interface GTLRContainer_NodePoolLoggingConfig : GTLRObject

/** Logging variant configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_LoggingVariantConfig *variantConfig;

@end


/**
 *  Kubernetes taint is composed of three fields: key, value, and effect. Effect
 *  can only be one of three types: NoSchedule, PreferNoSchedule or NoExecute.
 *  See
 *  [here](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration)
 *  for more information, including usage and the valid values.
 */
@interface GTLRContainer_NodeTaint : GTLRObject

/**
 *  Effect for taint.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NodeTaint_Effect_EffectUnspecified Not set (Value:
 *        "EFFECT_UNSPECIFIED")
 *    @arg @c kGTLRContainer_NodeTaint_Effect_NoExecute NoExecute (Value:
 *        "NO_EXECUTE")
 *    @arg @c kGTLRContainer_NodeTaint_Effect_NoSchedule NoSchedule (Value:
 *        "NO_SCHEDULE")
 *    @arg @c kGTLRContainer_NodeTaint_Effect_PreferNoSchedule PreferNoSchedule
 *        (Value: "PREFER_NO_SCHEDULE")
 */
@property(nonatomic, copy, nullable) NSString *effect;

/** Key for taint. */
@property(nonatomic, copy, nullable) NSString *key;

/** Value for taint. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Collection of Kubernetes [node
 *  taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration).
 */
@interface GTLRContainer_NodeTaints : GTLRObject

/** List of node taints. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodeTaint *> *taints;

@end


/**
 *  NotificationConfig is the configuration of notifications.
 */
@interface GTLRContainer_NotificationConfig : GTLRObject

/** Notification config for Pub/Sub. */
@property(nonatomic, strong, nullable) GTLRContainer_PubSub *pubsub;

@end


/**
 *  This operation resource represents operations that may have happened or are
 *  happening on the cluster. All fields are output only.
 */
@interface GTLRContainer_Operation : GTLRObject

/**
 *  Which conditions caused the current cluster state. Deprecated. Use field
 *  error instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_StatusCondition *> *clusterConditions GTLR_DEPRECATED;

/** Output only. Detailed operation progress, if available. */
@property(nonatomic, copy, nullable) NSString *detail;

/**
 *  Output only. The time the operation completed, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *endTime;

/** The error result of the operation in case of failure. */
@property(nonatomic, strong, nullable) GTLRContainer_Status *error;

/**
 *  Output only. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
 *  or
 *  [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
 *  in which the cluster resides.
 */
@property(nonatomic, copy, nullable) NSString *location;

/** Output only. The server-assigned ID for the operation. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Which conditions caused the current node pool state. Deprecated. Use field
 *  error instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_StatusCondition *> *nodepoolConditions GTLR_DEPRECATED;

/**
 *  Output only. The operation type.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_Operation_OperationType_AutoRepairNodes A problem
 *        has been detected with nodes and [they are being
 *        repaired](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair).
 *        This operation type is initiated by GKE, typically automatically. This
 *        operation may be concurrent with other operations and there may be
 *        multiple repairs occurring on the same node pool. (Value:
 *        "AUTO_REPAIR_NODES")
 *    @arg @c kGTLRContainer_Operation_OperationType_AutoUpgradeNodes Unused.
 *        Automatic node upgrade uses UPGRADE_NODES. (Value:
 *        "AUTO_UPGRADE_NODES")
 *    @arg @c kGTLRContainer_Operation_OperationType_CreateCluster The cluster
 *        is being created. The cluster should be assumed to be unusable until
 *        the operation finishes. In the event of the operation failing, the
 *        cluster will enter the ERROR state and eventually be deleted. (Value:
 *        "CREATE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_CreateNodePool A node pool
 *        is being created. The node pool should be assumed to be unusable until
 *        this operation finishes. In the event of an error, the node pool may
 *        be partially created. If enabled, [node
 *        autoprovisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
 *        may have automatically initiated such operations. (Value:
 *        "CREATE_NODE_POOL")
 *    @arg @c kGTLRContainer_Operation_OperationType_DeleteCluster The cluster
 *        is being deleted. The cluster should be assumed to be unusable as soon
 *        as this operation starts. In the event of the operation failing, the
 *        cluster will enter the ERROR state and the deletion will be
 *        automatically retried until completed. (Value: "DELETE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_DeleteNodePool The node
 *        pool is being deleted. The node pool should be assumed to be unusable
 *        as soon as this operation starts. (Value: "DELETE_NODE_POOL")
 *    @arg @c kGTLRContainer_Operation_OperationType_FleetFeatureUpgrade Fleet
 *        features of GKE Enterprise are being upgraded. The cluster should be
 *        assumed to be blocked for other upgrades until the operation finishes.
 *        (Value: "FLEET_FEATURE_UPGRADE")
 *    @arg @c kGTLRContainer_Operation_OperationType_RepairCluster A problem has
 *        been detected with the control plane and is being repaired. This
 *        operation type is initiated by GKE. For more details, see
 *        [documentation on
 *        repairs](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
 *        (Value: "REPAIR_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_ResizeCluster The control
 *        plane is being resized. This operation type is initiated by GKE. These
 *        operations are often performed preemptively to ensure that the control
 *        plane has sufficient resources and is not typically an indication of
 *        issues. For more details, see [documentation on
 *        resizes](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
 *        (Value: "RESIZE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetLabels Unused. Updating
 *        labels uses UPDATE_CLUSTER. (Value: "SET_LABELS")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetMaintenancePolicy
 *        Unused. Updating maintenance policy uses UPDATE_CLUSTER. (Value:
 *        "SET_MAINTENANCE_POLICY")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetMasterAuth Unused.
 *        Updating master auth uses UPDATE_CLUSTER. (Value: "SET_MASTER_AUTH")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetNetworkPolicy Unused.
 *        Updating network policy uses UPDATE_CLUSTER. (Value:
 *        "SET_NETWORK_POLICY")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetNodePoolManagement The
 *        node pool's manamagent field is being updated. These operations only
 *        update metadata and may be concurrent with most other operations.
 *        (Value: "SET_NODE_POOL_MANAGEMENT")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetNodePoolSize The node
 *        pool is being resized. With the exception of resizing to or from size
 *        zero, the node pool is generally usable during this operation. (Value:
 *        "SET_NODE_POOL_SIZE")
 *    @arg @c kGTLRContainer_Operation_OperationType_TypeUnspecified Not set.
 *        (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainer_Operation_OperationType_UpdateCluster The cluster
 *        is being updated. This is a broad category of operations and includes
 *        operations that only change metadata as well as those that must
 *        recreate the entire cluster. If the control plane must be recreated,
 *        this will cause temporary downtime for zonal clusters. Some features
 *        require recreating the nodes as well. Those will be recreated as
 *        separate operations and the update may not be completely functional
 *        until the node pools recreations finish. Node recreations will
 *        generally follow [maintenance
 *        policies](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions).
 *        Some GKE-initiated operations use this type. This includes certain
 *        types of auto-upgrades and incident mitigations. (Value:
 *        "UPDATE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_UpgradeMaster The cluster
 *        version is being updated. Note that this includes "upgrades" to the
 *        same version, which are simply a recreation. This also includes
 *        [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#upgrading_automatically).
 *        For more details, see [documentation on cluster
 *        upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#cluster_upgrades).
 *        (Value: "UPGRADE_MASTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_UpgradeNodes A node pool is
 *        being updated. Despite calling this an "upgrade", this includes most
 *        forms of updates to node pools. This also includes
 *        [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades).
 *        This operation sets the progress field and may be canceled. The
 *        upgrade strategy depends on [node pool
 *        configuration](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies).
 *        The nodes are generally still usable during this operation. (Value:
 *        "UPGRADE_NODES")
 */
@property(nonatomic, copy, nullable) NSString *operationType;

/** Output only. Progress information for an operation. */
@property(nonatomic, strong, nullable) GTLRContainer_OperationProgress *progress;

/**
 *  Output only. Server-defined URI for the operation. Example:
 *  `https://container.googleapis.com/v1alpha1/projects/123/locations/us-central1/operations/operation-123`.
 */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  Output only. The time the operation started, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *startTime;

/**
 *  Output only. The current status of the operation.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_Operation_Status_Aborting The operation is
 *        aborting. (Value: "ABORTING")
 *    @arg @c kGTLRContainer_Operation_Status_Done The operation is done, either
 *        cancelled or completed. (Value: "DONE")
 *    @arg @c kGTLRContainer_Operation_Status_Pending The operation has been
 *        created. (Value: "PENDING")
 *    @arg @c kGTLRContainer_Operation_Status_Running The operation is currently
 *        running. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_Operation_Status_StatusUnspecified Not set. (Value:
 *        "STATUS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  Output only. If an error has occurred, a textual description of the error.
 *  Deprecated. Use the field error instead.
 */
@property(nonatomic, copy, nullable) NSString *statusMessage GTLR_DEPRECATED;

/**
 *  Output only. Server-defined URI for the target of the operation. The format
 *  of this is a URI to the resource being modified (such as a cluster, node
 *  pool, or node). For node pool repairs, there may be multiple nodes being
 *  repaired, but only one will be the target. Examples: - ##
 *  `https://container.googleapis.com/v1/projects/123/locations/us-central1/clusters/my-cluster`
 *  ##
 *  `https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np`
 *  `https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np/node/my-node`
 */
@property(nonatomic, copy, nullable) NSString *targetLink;

/**
 *  Output only. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  operation is taking place. This field is deprecated, use location instead.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  OperationError records errors seen from CloudKMS keys encountered during
 *  updates to DatabaseEncryption configuration.
 */
@interface GTLRContainer_OperationError : GTLRObject

/** Description of the error seen during the operation. */
@property(nonatomic, copy, nullable) NSString *errorMessage;

/** CloudKMS key resource that had the error. */
@property(nonatomic, copy, nullable) NSString *keyName;

/** Time when the CloudKMS error was seen. */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

@end


/**
 *  Information about operation (or operation stage) progress.
 */
@interface GTLRContainer_OperationProgress : GTLRObject

/**
 *  Progress metric bundle, for example: metrics: [{name: "nodes done",
 *  int_value: 15}, {name: "nodes total", int_value: 32}] or metrics: [{name:
 *  "progress", double_value: 0.56}, {name: "progress scale", double_value:
 *  1.0}]
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Metric *> *metrics;

/**
 *  A non-parameterized string describing an operation stage. Unset for
 *  single-stage operations.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Substages of an operation or a stage. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_OperationProgress *> *stages;

/**
 *  Status of an operation stage. Unset for single-stage operations.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_OperationProgress_Status_Aborting The operation is
 *        aborting. (Value: "ABORTING")
 *    @arg @c kGTLRContainer_OperationProgress_Status_Done The operation is
 *        done, either cancelled or completed. (Value: "DONE")
 *    @arg @c kGTLRContainer_OperationProgress_Status_Pending The operation has
 *        been created. (Value: "PENDING")
 *    @arg @c kGTLRContainer_OperationProgress_Status_Running The operation is
 *        currently running. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_OperationProgress_Status_StatusUnspecified Not set.
 *        (Value: "STATUS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  ParentProductConfig is the configuration of the parent product of the
 *  cluster. This field is used by Google internal products that are built on
 *  top of a GKE cluster and take the ownership of the cluster.
 */
@interface GTLRContainer_ParentProductConfig : GTLRObject

/** Labels contain the configuration of the parent product. */
@property(nonatomic, strong, nullable) GTLRContainer_ParentProductConfig_Labels *labels;

/** Name of the parent product associated with the cluster. */
@property(nonatomic, copy, nullable) NSString *productName;

@end


/**
 *  Labels contain the configuration of the parent product.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_ParentProductConfig_Labels : GTLRObject
@end


/**
 *  PlacementPolicy defines the placement policy used by the node pool.
 */
@interface GTLRContainer_PlacementPolicy : GTLRObject

/**
 *  If set, refers to the name of a custom resource policy supplied by the user.
 *  The resource policy must be in the same project and region as the node pool.
 *  If not found, InvalidArgument error is returned.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  Optional. TPU placement topology for pod slice node pool.
 *  https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies
 */
@property(nonatomic, copy, nullable) NSString *tpuTopology;

/**
 *  The type of placement.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_PlacementPolicy_Type_Compact COMPACT specifies node
 *        placement in the same availability domain to ensure low communication
 *        latency. (Value: "COMPACT")
 *    @arg @c kGTLRContainer_PlacementPolicy_Type_TypeUnspecified
 *        TYPE_UNSPECIFIED specifies no requirements on nodes placement. (Value:
 *        "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  [PRIVATE FIELD] Config for pod CIDR size overprovisioning.
 */
@interface GTLRContainer_PodCIDROverprovisionConfig : GTLRObject

/**
 *  Whether Pod CIDR overprovisioning is disabled. Note: Pod CIDR
 *  overprovisioning is enabled by default.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disable;

@end


/**
 *  Configuration options for private clusters.
 */
@interface GTLRContainer_PrivateClusterConfig : GTLRObject

/**
 *  Whether the master's internal IP address is used as the cluster endpoint.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enablePrivateEndpoint;

/**
 *  Whether nodes have internal IP addresses only. If enabled, all nodes are
 *  given only RFC 1918 private addresses and communicate with the master via
 *  private networking.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enablePrivateNodes;

/** Controls master global access settings. */
@property(nonatomic, strong, nullable) GTLRContainer_PrivateClusterMasterGlobalAccessConfig *masterGlobalAccessConfig;

/**
 *  The IP range in CIDR notation to use for the hosted master network. This
 *  range will be used for assigning internal IP addresses to the master or set
 *  of masters, as well as the ILB VIP. This range must not overlap with any
 *  other ranges in use within the cluster's network.
 */
@property(nonatomic, copy, nullable) NSString *masterIpv4CidrBlock;

/** Output only. The peering name in the customer VPC used by this cluster. */
@property(nonatomic, copy, nullable) NSString *peeringName;

/** Output only. The internal IP address of this cluster's master endpoint. */
@property(nonatomic, copy, nullable) NSString *privateEndpoint;

/**
 *  Subnet to provision the master's private endpoint during cluster creation.
 *  Specified in projects/ * /regions/ * /subnetworks/ * format.
 */
@property(nonatomic, copy, nullable) NSString *privateEndpointSubnetwork;

/** Output only. The external IP address of this cluster's master endpoint. */
@property(nonatomic, copy, nullable) NSString *publicEndpoint;

@end


/**
 *  Configuration for controlling master global access settings.
 */
@interface GTLRContainer_PrivateClusterMasterGlobalAccessConfig : GTLRObject

/**
 *  Whenever master is accessible globally or not.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  PrivateRegistryAccessConfig contains access configuration for private
 *  container registries.
 */
@interface GTLRContainer_PrivateRegistryAccessConfig : GTLRObject

/** Private registry access configuration. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_CertificateAuthorityDomainConfig *> *certificateAuthorityDomainConfig;

/**
 *  Private registry access is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Pub/Sub specific notification config.
 */
@interface GTLRContainer_PubSub : GTLRObject

/**
 *  Enable notifications for Pub/Sub.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Allows filtering to one or more specific event types. If no filter is
 *  specified, or if a filter is specified with no event types, all event types
 *  will be sent
 */
@property(nonatomic, strong, nullable) GTLRContainer_Filter *filter;

/**
 *  The desired Pub/Sub topic to which notifications will be sent by GKE. Format
 *  is `projects/{project}/topics/{topic}`.
 */
@property(nonatomic, copy, nullable) NSString *topic;

@end


/**
 *  QueuedProvisioning defines the queued provisioning used by the node pool.
 */
@interface GTLRContainer_QueuedProvisioning : GTLRObject

/**
 *  Denotes that this nodepool is QRM specific, meaning nodes can be only
 *  obtained through queuing via the Cluster Autoscaler ProvisioningRequest API.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  RangeInfo contains the range name and the range utilization by this cluster.
 */
@interface GTLRContainer_RangeInfo : GTLRObject

/** Output only. Name of a range. */
@property(nonatomic, copy, nullable) NSString *rangeName;

/**
 *  Output only. The utilization of the range.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *utilization;

@end


/**
 *  RayClusterLoggingConfig specifies configuration of Ray logging.
 */
@interface GTLRContainer_RayClusterLoggingConfig : GTLRObject

/**
 *  Enable log collection for Ray clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  RayClusterMonitoringConfig specifies monitoring configuration for Ray
 *  clusters.
 */
@interface GTLRContainer_RayClusterMonitoringConfig : GTLRObject

/**
 *  Enable metrics collection for Ray clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration options for the Ray Operator add-on.
 */
@interface GTLRContainer_RayOperatorConfig : GTLRObject

/**
 *  Whether the Ray Operator addon is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/** Optional. Logging configuration for Ray clusters. */
@property(nonatomic, strong, nullable) GTLRContainer_RayClusterLoggingConfig *rayClusterLoggingConfig;

/** Optional. Monitoring configuration for Ray clusters. */
@property(nonatomic, strong, nullable) GTLRContainer_RayClusterMonitoringConfig *rayClusterMonitoringConfig;

@end


/**
 *  RBACBindingConfig allows user to restrict ClusterRoleBindings an
 *  RoleBindings that can be created.
 */
@interface GTLRContainer_RBACBindingConfig : GTLRObject

/**
 *  Setting this to true will allow any ClusterRoleBinding and RoleBinding with
 *  subjects system:authenticated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableInsecureBindingSystemAuthenticated;

/**
 *  Setting this to true will allow any ClusterRoleBinding and RoleBinding with
 *  subjets system:anonymous or system:unauthenticated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableInsecureBindingSystemUnauthenticated;

@end


/**
 *  Represents an arbitrary window of time that recurs.
 */
@interface GTLRContainer_RecurringTimeWindow : GTLRObject

/**
 *  An RRULE (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how this
 *  window reccurs. They go on for the span of time between the start and end
 *  time. For example, to have something repeat every weekday, you'd use:
 *  `FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR` To repeat some window daily (equivalent
 *  to the DailyMaintenanceWindow): `FREQ=DAILY` For the first weekend of every
 *  month: `FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU` This specifies how frequently
 *  the window starts. Eg, if you wanted to have a 9-5 UTC-4 window every
 *  weekday, you'd use something like: ``` start time = 2019-01-01T09:00:00-0400
 *  end time = 2019-01-01T17:00:00-0400 recurrence =
 *  FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR ``` Windows can span multiple days. Eg, to
 *  make the window encompass every weekend from midnight Saturday till the last
 *  minute of Sunday UTC: ``` start time = 2019-01-05T00:00:00Z end time =
 *  2019-01-07T23:59:00Z recurrence = FREQ=WEEKLY;BYDAY=SA ``` Note the start
 *  and end time's specific dates are largely arbitrary except to specify
 *  duration of the window and when it first starts. The FREQ values of HOURLY,
 *  MINUTELY, and SECONDLY are not supported.
 */
@property(nonatomic, copy, nullable) NSString *recurrence;

/** The window of the first recurrence. */
@property(nonatomic, strong, nullable) GTLRContainer_TimeWindow *window;

@end


/**
 *  ReleaseChannel indicates which release channel a cluster is subscribed to.
 *  Release channels are arranged in order of risk. When a cluster is subscribed
 *  to a release channel, Google maintains both the master version and the node
 *  version. Node auto-upgrade defaults to true and cannot be disabled.
 */
@interface GTLRContainer_ReleaseChannel : GTLRObject

/**
 *  channel specifies which release channel the cluster is subscribed to.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ReleaseChannel_Channel_Extended Clusters subscribed
 *        to EXTENDED receive extended support and availability for versions
 *        which are known to be stable and reliable in production. (Value:
 *        "EXTENDED")
 *    @arg @c kGTLRContainer_ReleaseChannel_Channel_Rapid RAPID channel is
 *        offered on an early access basis for customers who want to test new
 *        releases. WARNING: Versions available in the RAPID Channel may be
 *        subject to unresolved issues with no known workaround and are not
 *        subject to any SLAs. (Value: "RAPID")
 *    @arg @c kGTLRContainer_ReleaseChannel_Channel_Regular Clusters subscribed
 *        to REGULAR receive versions that are considered GA quality. REGULAR is
 *        intended for production users who want to take advantage of new
 *        features. (Value: "REGULAR")
 *    @arg @c kGTLRContainer_ReleaseChannel_Channel_Stable Clusters subscribed
 *        to STABLE receive versions that are known to be stable and reliable in
 *        production. (Value: "STABLE")
 *    @arg @c kGTLRContainer_ReleaseChannel_Channel_Unspecified No channel
 *        specified. (Value: "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *channel;

@end


/**
 *  ReleaseChannelConfig exposes configuration for a release channel.
 */
@interface GTLRContainer_ReleaseChannelConfig : GTLRObject

/**
 *  The release channel this configuration applies to.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ReleaseChannelConfig_Channel_Extended Clusters
 *        subscribed to EXTENDED receive extended support and availability for
 *        versions which are known to be stable and reliable in production.
 *        (Value: "EXTENDED")
 *    @arg @c kGTLRContainer_ReleaseChannelConfig_Channel_Rapid RAPID channel is
 *        offered on an early access basis for customers who want to test new
 *        releases. WARNING: Versions available in the RAPID Channel may be
 *        subject to unresolved issues with no known workaround and are not
 *        subject to any SLAs. (Value: "RAPID")
 *    @arg @c kGTLRContainer_ReleaseChannelConfig_Channel_Regular Clusters
 *        subscribed to REGULAR receive versions that are considered GA quality.
 *        REGULAR is intended for production users who want to take advantage of
 *        new features. (Value: "REGULAR")
 *    @arg @c kGTLRContainer_ReleaseChannelConfig_Channel_Stable Clusters
 *        subscribed to STABLE receive versions that are known to be stable and
 *        reliable in production. (Value: "STABLE")
 *    @arg @c kGTLRContainer_ReleaseChannelConfig_Channel_Unspecified No channel
 *        specified. (Value: "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *channel;

/** The default version for newly created clusters on the channel. */
@property(nonatomic, copy, nullable) NSString *defaultVersion;

/** List of valid versions for the channel. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validVersions;

@end


/**
 *  [ReservationAffinity](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
 *  is the configuration of desired reservation which instances could take
 *  capacity from.
 */
@interface GTLRContainer_ReservationAffinity : GTLRObject

/**
 *  Corresponds to the type of reservation consumption.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_ReservationAffinity_ConsumeReservationType_AnyReservation
 *        Consume any reservation available. (Value: "ANY_RESERVATION")
 *    @arg @c kGTLRContainer_ReservationAffinity_ConsumeReservationType_NoReservation
 *        Do not consume from any reserved capacity. (Value: "NO_RESERVATION")
 *    @arg @c kGTLRContainer_ReservationAffinity_ConsumeReservationType_SpecificReservation
 *        Must consume from a specific reservation. Must specify key value
 *        fields for specifying the reservations. (Value:
 *        "SPECIFIC_RESERVATION")
 *    @arg @c kGTLRContainer_ReservationAffinity_ConsumeReservationType_Unspecified
 *        Default value. This should not be used. (Value: "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *consumeReservationType;

/**
 *  Corresponds to the label key of a reservation resource. To target a
 *  SPECIFIC_RESERVATION by name, specify
 *  "compute.googleapis.com/reservation-name" as the key and specify the name of
 *  your reservation as its value.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** Corresponds to the label value(s) of reservation resource(s). */
@property(nonatomic, strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  Collection of [GCP
 *  labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
 */
@interface GTLRContainer_ResourceLabels : GTLRObject

/** Map of node label keys and node label values. */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceLabels_Labels *labels;

@end


/**
 *  Map of node label keys and node label values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_ResourceLabels_Labels : GTLRObject
@end


/**
 *  Contains information about amount of some resource in the cluster. For
 *  memory, value should be in GB.
 */
@interface GTLRContainer_ResourceLimit : GTLRObject

/**
 *  Maximum amount of the resource in the cluster.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximum;

/**
 *  Minimum amount of the resource in the cluster.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimum;

/** Resource name "cpu", "memory" or gpu-specific string. */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  A map of resource manager tag keys and values to be attached to the nodes
 *  for managing Compute Engine firewalls using Network Firewall Policies. Tags
 *  must be according to specifications in
 *  https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications. A
 *  maximum of 5 tag key-value pairs can be specified. Existing tags will be
 *  replaced with new values.
 */
@interface GTLRContainer_ResourceManagerTags : GTLRObject

/**
 *  TagKeyValue must be in one of the following formats ([KEY]=[VALUE]) 1.
 *  `tagKeys/{tag_key_id}=tagValues/{tag_value_id}` 2.
 *  `{org_id}/{tag_key_name}={tag_value_name}` 3.
 *  `{project_id}/{tag_key_name}={tag_value_name}`
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceManagerTags_Tags *tags;

@end


/**
 *  TagKeyValue must be in one of the following formats ([KEY]=[VALUE]) 1.
 *  `tagKeys/{tag_key_id}=tagValues/{tag_value_id}` 2.
 *  `{org_id}/{tag_key_name}={tag_value_name}` 3.
 *  `{project_id}/{tag_key_name}={tag_value_name}`
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_ResourceManagerTags_Tags : GTLRObject
@end


/**
 *  Configuration for exporting cluster resource usages.
 */
@interface GTLRContainer_ResourceUsageExportConfig : GTLRObject

/** Configuration to use BigQuery as usage export destination. */
@property(nonatomic, strong, nullable) GTLRContainer_BigQueryDestination *bigqueryDestination;

/** Configuration to enable resource consumption metering. */
@property(nonatomic, strong, nullable) GTLRContainer_ConsumptionMeteringConfig *consumptionMeteringConfig;

/**
 *  Whether to enable network egress metering for this cluster. If enabled, a
 *  daemonset will be created in the cluster to meter network egress traffic.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableNetworkEgressMetering;

@end


/**
 *  RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
 *  NodePool upgrade. This will be an no-op if the last upgrade successfully
 *  completed.
 */
@interface GTLRContainer_RollbackNodePoolUpgradeRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to rollback. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster, node pool id) of the node poll to
 *  rollback upgrade. Specified in the format `projects/ * /locations/ *
 *  /clusters/ * /nodePools/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The name of the node pool to rollback. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *nodePoolId GTLR_DEPRECATED;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Option for rollback to ignore the PodDisruptionBudget. Default value is
 *  false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *respectPdb;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SandboxConfig contains configurations of the sandbox to use for the node.
 */
@interface GTLRContainer_SandboxConfig : GTLRObject

/**
 *  Type of the sandbox to use for the node.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_SandboxConfig_Type_Gvisor Run sandbox using gvisor.
 *        (Value: "GVISOR")
 *    @arg @c kGTLRContainer_SandboxConfig_Type_Unspecified Default value. This
 *        should not be used. (Value: "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  SecondaryBootDisk represents a persistent disk attached to a node with
 *  special configurations based on its mode.
 */
@interface GTLRContainer_SecondaryBootDisk : GTLRObject

/** Fully-qualified resource ID for an existing disk image. */
@property(nonatomic, copy, nullable) NSString *diskImage;

/**
 *  Disk mode (container image cache, etc.)
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_SecondaryBootDisk_Mode_ContainerImageCache
 *        CONTAINER_IMAGE_CACHE is for using the secondary boot disk as a
 *        container image cache. (Value: "CONTAINER_IMAGE_CACHE")
 *    @arg @c kGTLRContainer_SecondaryBootDisk_Mode_ModeUnspecified
 *        MODE_UNSPECIFIED is when mode is not set. (Value: "MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  SecondaryBootDiskUpdateStrategy is a placeholder which will be extended in
 *  the future to define different options for updating secondary boot disks.
 */
@interface GTLRContainer_SecondaryBootDiskUpdateStrategy : GTLRObject
@end


/**
 *  SecretManagerConfig is config for secret manager enablement.
 */
@interface GTLRContainer_SecretManagerConfig : GTLRObject

/**
 *  Enable/Disable Secret Manager Config.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  SecurityBulletinEvent is a notification sent to customers when a security
 *  bulletin has been posted that they are vulnerable to.
 */
@interface GTLRContainer_SecurityBulletinEvent : GTLRObject

/** The GKE minor versions affected by this vulnerability. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *affectedSupportedMinors;

/**
 *  A brief description of the bulletin. See the bulletin pointed to by the
 *  bulletin_uri field for an expanded description.
 */
@property(nonatomic, copy, nullable) NSString *briefDescription;

/** The ID of the bulletin corresponding to the vulnerability. */
@property(nonatomic, copy, nullable) NSString *bulletinId;

/** The URI link to the bulletin on the website for more information. */
@property(nonatomic, copy, nullable) NSString *bulletinUri;

/** The CVEs associated with this bulletin. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *cveIds;

/**
 *  If this field is specified, it means there are manual steps that the user
 *  must take to make their clusters safe.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *manualStepsRequired;

/** The GKE versions where this vulnerability is patched. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *patchedVersions;

/**
 *  The resource type (node/control plane) that has the vulnerability. Multiple
 *  notifications (1 notification per resource type) will be sent for a
 *  vulnerability that affects > 1 resource type.
 */
@property(nonatomic, copy, nullable) NSString *resourceTypeAffected;

/** The severity of this bulletin as it relates to GKE. */
@property(nonatomic, copy, nullable) NSString *severity;

/**
 *  This represents a version selected from the patched_versions field that the
 *  cluster receiving this notification should most likely want to upgrade to
 *  based on its current version. Note that if this notification is being
 *  received by a given cluster, it means that this version is currently
 *  available as an upgrade target in that cluster's location.
 */
@property(nonatomic, copy, nullable) NSString *suggestedUpgradeTarget;

@end


/**
 *  SecurityPostureConfig defines the flags needed to enable/disable features
 *  for the Security Posture API.
 */
@interface GTLRContainer_SecurityPostureConfig : GTLRObject

/**
 *  Sets which mode to use for Security Posture features.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_SecurityPostureConfig_Mode_Basic Applies Security
 *        Posture features on the cluster. (Value: "BASIC")
 *    @arg @c kGTLRContainer_SecurityPostureConfig_Mode_Disabled Disables
 *        Security Posture features on the cluster. (Value: "DISABLED")
 *    @arg @c kGTLRContainer_SecurityPostureConfig_Mode_Enterprise Applies the
 *        Security Posture off cluster Enterprise level features. (Value:
 *        "ENTERPRISE")
 *    @arg @c kGTLRContainer_SecurityPostureConfig_Mode_ModeUnspecified Default
 *        value not specified. (Value: "MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *mode;

/**
 *  Sets which mode to use for vulnerability scanning.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityBasic
 *        Applies basic vulnerability scanning on the cluster. (Value:
 *        "VULNERABILITY_BASIC")
 *    @arg @c kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityDisabled
 *        Disables vulnerability scanning on the cluster. (Value:
 *        "VULNERABILITY_DISABLED")
 *    @arg @c kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityEnterprise
 *        Applies the Security Posture's vulnerability on cluster Enterprise
 *        level features. (Value: "VULNERABILITY_ENTERPRISE")
 *    @arg @c kGTLRContainer_SecurityPostureConfig_VulnerabilityMode_VulnerabilityModeUnspecified
 *        Default value not specified. (Value: "VULNERABILITY_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *vulnerabilityMode;

@end


/**
 *  Kubernetes Engine service configuration.
 */
@interface GTLRContainer_ServerConfig : GTLRObject

/** List of release channel configurations. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_ReleaseChannelConfig *> *channels;

/** Version of Kubernetes the service deploys by default. */
@property(nonatomic, copy, nullable) NSString *defaultClusterVersion;

/** Default image type. */
@property(nonatomic, copy, nullable) NSString *defaultImageType;

/** List of valid image types. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validImageTypes;

/** List of valid master versions, in descending order. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validMasterVersions;

/** List of valid node upgrade target versions, in descending order. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validNodeVersions;

@end


/**
 *  Config to block services with externalIPs field.
 */
@interface GTLRContainer_ServiceExternalIPsConfig : GTLRObject

/**
 *  Whether Services with ExternalIPs field are allowed or not.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  SetAddonsConfigRequest sets the addons associated with the cluster.
 */
@interface GTLRContainer_SetAddonsConfigRequest : GTLRObject

/**
 *  Required. The desired configurations for the various addons available to run
 *  in the cluster.
 */
@property(nonatomic, strong, nullable) GTLRContainer_AddonsConfig *addonsConfig;

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster) of the cluster to set addons.
 *  Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
 *  Engine cluster, which will in turn set them for Google Compute Engine
 *  resources used by that cluster
 */
@interface GTLRContainer_SetLabelsRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster. This field has been deprecated and
 *  replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Required. The fingerprint of the previous set of labels for this resource,
 *  used to detect conflicts. The fingerprint is initially generated by
 *  Kubernetes Engine and changes after every request to modify or update
 *  labels. You must always provide an up-to-date fingerprint hash when updating
 *  or changing labels. Make a `get()` request to the resource to get the latest
 *  fingerprint.
 */
@property(nonatomic, copy, nullable) NSString *labelFingerprint;

/**
 *  The name (project, location, cluster name) of the cluster to set labels.
 *  Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/** Required. The labels to set for that cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_SetLabelsRequest_ResourceLabels *resourceLabels;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  Required. The labels to set for that cluster.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_SetLabelsRequest_ResourceLabels : GTLRObject
@end


/**
 *  SetLegacyAbacRequest enables or disables the ABAC authorization mechanism
 *  for a cluster.
 */
@interface GTLRContainer_SetLegacyAbacRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to update. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Required. Whether ABAC authorization will be enabled in the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  The name (project, location, cluster name) of the cluster to set legacy
 *  abac. Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetLocationsRequest sets the locations of the cluster.
 */
@interface GTLRContainer_SetLocationsRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Required. The desired list of Google Compute Engine
 *  [zones](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster's nodes should be located. Changing the locations a cluster is in
 *  will result in nodes being either created or removed from the cluster,
 *  depending on whether locations are being added or removed. This list must
 *  always include the cluster's primary zone.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locations;

/**
 *  The name (project, location, cluster) of the cluster to set locations.
 *  Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetLoggingServiceRequest sets the logging service of a cluster.
 */
@interface GTLRContainer_SetLoggingServiceRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Required. The logging service the cluster should use to write logs.
 *  Currently available options: * `logging.googleapis.com/kubernetes` - The
 *  Cloud Logging service with a Kubernetes-native resource model *
 *  `logging.googleapis.com` - The legacy Cloud Logging service (no longer
 *  available as of GKE 1.15). * `none` - no logs will be exported from the
 *  cluster. If left as an empty string,`logging.googleapis.com/kubernetes` will
 *  be used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
 */
@property(nonatomic, copy, nullable) NSString *loggingService;

/**
 *  The name (project, location, cluster) of the cluster to set logging.
 *  Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
 */
@interface GTLRContainer_SetMaintenancePolicyRequest : GTLRObject

/** Required. The name of the cluster to update. */
@property(nonatomic, copy, nullable) NSString *clusterId;

/**
 *  Required. The maintenance policy to be set for the cluster. An empty field
 *  clears the existing maintenance policy.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenancePolicy *maintenancePolicy;

/**
 *  The name (project, location, cluster name) of the cluster to set maintenance
 *  policy. Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 */
@property(nonatomic, copy, nullable) NSString *projectId;

/**
 *  Required. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  SetMasterAuthRequest updates the admin password of a cluster.
 */
@interface GTLRContainer_SetMasterAuthRequest : GTLRObject

/**
 *  Required. The exact form of action to be taken on the master auth.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_GeneratePassword
 *        Generate a new password and set it to that. (Value:
 *        "GENERATE_PASSWORD")
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_SetPassword Set the
 *        password to a user generated value. (Value: "SET_PASSWORD")
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_SetUsername Set the
 *        username. If an empty username is provided, basic authentication is
 *        disabled for the cluster. If a non-empty username is provided, basic
 *        authentication is enabled, with either a provided password or a
 *        generated one. (Value: "SET_USERNAME")
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_Unknown Operation is
 *        unknown and will error out. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *action;

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster) of the cluster to set auth. Specified
 *  in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/** Required. A description of the update. */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuth *update;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetMonitoringServiceRequest sets the monitoring service of a cluster.
 */
@interface GTLRContainer_SetMonitoringServiceRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Required. The monitoring service the cluster should use to write metrics.
 *  Currently available options: * "monitoring.googleapis.com/kubernetes" - The
 *  Cloud Monitoring service with a Kubernetes-native resource model *
 *  `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no longer
 *  available as of GKE 1.15). * `none` - No metrics will be exported from the
 *  cluster. If left as an empty string,`monitoring.googleapis.com/kubernetes`
 *  will be used for GKE 1.14+ or `monitoring.googleapis.com` for earlier
 *  versions.
 */
@property(nonatomic, copy, nullable) NSString *monitoringService;

/**
 *  The name (project, location, cluster) of the cluster to set monitoring.
 *  Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetNetworkPolicyRequest enables/disables network policy for a cluster.
 */
@interface GTLRContainer_SetNetworkPolicyRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster. This field has been deprecated and
 *  replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster name) of the cluster to set networking
 *  policy. Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. Configuration options for the NetworkPolicy feature. */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPolicy *networkPolicy;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
 */
@interface GTLRContainer_SetNodePoolAutoscalingRequest : GTLRObject

/** Required. Autoscaling configuration for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoscaling *autoscaling;

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster, node pool) of the node pool to set
 *  autoscaler settings. Specified in the format `projects/ * /locations/ *
 *  /clusters/ * /nodePools/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The name of the node pool to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *nodePoolId GTLR_DEPRECATED;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetNodePoolManagementRequest sets the node management properties of a node
 *  pool.
 */
@interface GTLRContainer_SetNodePoolManagementRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to update. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/** Required. NodeManagement configuration for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeManagement *management;

/**
 *  The name (project, location, cluster, node pool id) of the node pool to set
 *  management properties. Specified in the format `projects/ * /locations/ *
 *  /clusters/ * /nodePools/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The name of the node pool to update. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *nodePoolId GTLR_DEPRECATED;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  SetNodePoolSizeRequest sets the size of a node pool.
 */
@interface GTLRContainer_SetNodePoolSizeRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to update. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster, node pool id) of the node pool to set
 *  size. Specified in the format `projects/ * /locations/ * /clusters/ *
 *  /nodePools/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The desired node count for the pool.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  Deprecated. The name of the node pool to update. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *nodePoolId GTLR_DEPRECATED;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  A set of Shielded Instance options.
 */
@interface GTLRContainer_ShieldedInstanceConfig : GTLRObject

/**
 *  Defines whether the instance has integrity monitoring enabled. Enables
 *  monitoring and attestation of the boot integrity of the instance. The
 *  attestation is performed against the integrity policy baseline. This
 *  baseline is initially derived from the implicitly trusted boot image when
 *  the instance is created.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableIntegrityMonitoring;

/**
 *  Defines whether the instance has Secure Boot enabled. Secure Boot helps
 *  ensure that the system only runs authentic software by verifying the digital
 *  signature of all boot components, and halting the boot process if signature
 *  verification fails.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableSecureBoot;

@end


/**
 *  Configuration of Shielded Nodes feature.
 */
@interface GTLRContainer_ShieldedNodes : GTLRObject

/**
 *  Whether Shielded Nodes features are enabled on all nodes in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  SoleTenantConfig contains the NodeAffinities to specify what shared sole
 *  tenant node groups should back the node pool.
 */
@interface GTLRContainer_SoleTenantConfig : GTLRObject

/** NodeAffinities used to match to a shared sole tenant node group. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodeAffinity *> *nodeAffinities;

@end


/**
 *  Standard rollout policy is the default policy for blue-green.
 */
@interface GTLRContainer_StandardRolloutPolicy : GTLRObject

/**
 *  Number of blue nodes to drain in a batch.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batchNodeCount;

/**
 *  Percentage of the blue pool nodes to drain in a batch. The range of this
 *  field should be (0.0, 1.0].
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batchPercentage;

/** Soak time after each batch gets drained. Default to zero. */
@property(nonatomic, strong, nullable) GTLRDuration *batchSoakDuration;

@end


/**
 *  StartIPRotationRequest creates a new IP for the cluster and then performs a
 *  node upgrade on each node pool to point to the new IP.
 */
@interface GTLRContainer_StartIPRotationRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster. This field has been deprecated and
 *  replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster name) of the cluster to start IP
 *  rotation. Specified in the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Whether to rotate credentials during IP rotation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rotateCredentials;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  Configuration for the Stateful HA add-on.
 */
@interface GTLRContainer_StatefulHAConfig : GTLRObject

/**
 *  Whether the Stateful HA add-on is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRContainer_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRContainer_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRContainer_Status_Details_Item : GTLRObject
@end


/**
 *  StatusCondition describes why a cluster or a node pool has a certain status
 *  (e.g., ERROR or DEGRADED).
 */
@interface GTLRContainer_StatusCondition : GTLRObject

/**
 *  Canonical code of the condition.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Aborted The operation
 *        was aborted, typically due to a concurrency issue such as a sequencer
 *        check failure or transaction abort. See the guidelines above for
 *        deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`.
 *        HTTP Mapping: 409 Conflict (Value: "ABORTED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_AlreadyExists The
 *        entity that a client attempted to create (e.g., file or directory)
 *        already exists. HTTP Mapping: 409 Conflict (Value: "ALREADY_EXISTS")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Cancelled The
 *        operation was cancelled, typically by the caller. HTTP Mapping: 499
 *        Client Closed Request (Value: "CANCELLED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_DataLoss
 *        Unrecoverable data loss or corruption. HTTP Mapping: 500 Internal
 *        Server Error (Value: "DATA_LOSS")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_DeadlineExceeded The
 *        deadline expired before the operation could complete. For operations
 *        that change the state of the system, this error may be returned even
 *        if the operation has completed successfully. For example, a successful
 *        response from a server could have been delayed long enough for the
 *        deadline to expire. HTTP Mapping: 504 Gateway Timeout (Value:
 *        "DEADLINE_EXCEEDED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_FailedPrecondition
 *        The operation was rejected because the system is not in a state
 *        required for the operation's execution. For example, the directory to
 *        be deleted is non-empty, an rmdir operation is applied to a
 *        non-directory, etc. Service implementors can use the following
 *        guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and
 *        `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the
 *        failing call. (b) Use `ABORTED` if the client should retry at a higher
 *        level. For example, when a client-specified test-and-set fails,
 *        indicating the client should restart a read-modify-write sequence. (c)
 *        Use `FAILED_PRECONDITION` if the client should not retry until the
 *        system state has been explicitly fixed. For example, if an "rmdir"
 *        fails because the directory is non-empty, `FAILED_PRECONDITION` should
 *        be returned since the client should not retry unless the files are
 *        deleted from the directory. HTTP Mapping: 400 Bad Request (Value:
 *        "FAILED_PRECONDITION")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Internal Internal
 *        errors. This means that some invariants expected by the underlying
 *        system have been broken. This error code is reserved for serious
 *        errors. HTTP Mapping: 500 Internal Server Error (Value: "INTERNAL")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_InvalidArgument The
 *        client specified an invalid argument. Note that this differs from
 *        `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are
 *        problematic regardless of the state of the system (e.g., a malformed
 *        file name). HTTP Mapping: 400 Bad Request (Value: "INVALID_ARGUMENT")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_NotFound Some
 *        requested entity (e.g., file or directory) was not found. Note to
 *        server developers: if a request is denied for an entire class of
 *        users, such as gradual feature rollout or undocumented allowlist,
 *        `NOT_FOUND` may be used. If a request is denied for some users within
 *        a class of users, such as user-based access control,
 *        `PERMISSION_DENIED` must be used. HTTP Mapping: 404 Not Found (Value:
 *        "NOT_FOUND")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Ok Not an error;
 *        returned on success. HTTP Mapping: 200 OK (Value: "OK")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_OutOfRange The
 *        operation was attempted past the valid range. E.g., seeking or reading
 *        past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a
 *        problem that may be fixed if the system state changes. For example, a
 *        32-bit file system will generate `INVALID_ARGUMENT` if asked to read
 *        at an offset that is not in the range [0,2^32-1], but it will generate
 *        `OUT_OF_RANGE` if asked to read from an offset past the current file
 *        size. There is a fair bit of overlap between `FAILED_PRECONDITION` and
 *        `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific
 *        error) when it applies so that callers who are iterating through a
 *        space can easily look for an `OUT_OF_RANGE` error to detect when they
 *        are done. HTTP Mapping: 400 Bad Request (Value: "OUT_OF_RANGE")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_PermissionDenied The
 *        caller does not have permission to execute the specified operation.
 *        `PERMISSION_DENIED` must not be used for rejections caused by
 *        exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those
 *        errors). `PERMISSION_DENIED` must not be used if the caller can not be
 *        identified (use `UNAUTHENTICATED` instead for those errors). This
 *        error code does not imply the request is valid or the requested entity
 *        exists or satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
 *        (Value: "PERMISSION_DENIED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_ResourceExhausted
 *        Some resource has been exhausted, perhaps a per-user quota, or perhaps
 *        the entire file system is out of space. HTTP Mapping: 429 Too Many
 *        Requests (Value: "RESOURCE_EXHAUSTED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Unauthenticated The
 *        request does not have valid authentication credentials for the
 *        operation. HTTP Mapping: 401 Unauthorized (Value: "UNAUTHENTICATED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Unavailable The
 *        service is currently unavailable. This is most likely a transient
 *        condition, which can be corrected by retrying with a backoff. Note
 *        that it is not always safe to retry non-idempotent operations. See the
 *        guidelines above for deciding between `FAILED_PRECONDITION`,
 *        `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
 *        (Value: "UNAVAILABLE")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Unimplemented The
 *        operation is not implemented or is not supported/enabled in this
 *        service. HTTP Mapping: 501 Not Implemented (Value: "UNIMPLEMENTED")
 *    @arg @c kGTLRContainer_StatusCondition_CanonicalCode_Unknown Unknown
 *        error. For example, this error may be returned when a `Status` value
 *        received from another address space belongs to an error space that is
 *        not known in this address space. Also errors raised by APIs that do
 *        not return enough error information may be converted to this error.
 *        HTTP Mapping: 500 Internal Server Error (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *canonicalCode;

/**
 *  Machine-friendly representation of the condition Deprecated. Use
 *  canonical_code instead.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_StatusCondition_Code_CaExpiring Cluster CA is
 *        expiring soon. (Value: "CA_EXPIRING")
 *    @arg @c kGTLRContainer_StatusCondition_Code_CloudKmsKeyError Unable to
 *        perform an encrypt operation against the CloudKMS key used for etcd
 *        level encryption. (Value: "CLOUD_KMS_KEY_ERROR")
 *    @arg @c kGTLRContainer_StatusCondition_Code_GceQuotaExceeded Google
 *        Compute Engine quota was exceeded. (Value: "GCE_QUOTA_EXCEEDED")
 *    @arg @c kGTLRContainer_StatusCondition_Code_GceStockout GCE_STOCKOUT
 *        indicates that Google Compute Engine resources are temporarily
 *        unavailable. (Value: "GCE_STOCKOUT")
 *    @arg @c kGTLRContainer_StatusCondition_Code_GkeServiceAccountDeleted
 *        GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their
 *        robot service account. (Value: "GKE_SERVICE_ACCOUNT_DELETED")
 *    @arg @c kGTLRContainer_StatusCondition_Code_SetByOperator Cluster state
 *        was manually changed by an SRE due to a system logic error. (Value:
 *        "SET_BY_OPERATOR")
 *    @arg @c kGTLRContainer_StatusCondition_Code_Unknown UNKNOWN indicates a
 *        generic condition. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *code GTLR_DEPRECATED;

/** Human-friendly representation of the condition */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  Represents an arbitrary window of time.
 */
@interface GTLRContainer_TimeWindow : GTLRObject

/**
 *  The time that the window ends. The end time should take place after the
 *  start time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  MaintenanceExclusionOptions provides maintenance exclusion related options.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenanceExclusionOptions *maintenanceExclusionOptions;

/** The time that the window first starts. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  UpdateClusterRequest updates the settings of a cluster.
 */
@interface GTLRContainer_UpdateClusterRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  The name (project, location, cluster) of the cluster to update. Specified in
 *  the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/** Required. A description of the update. */
@property(nonatomic, strong, nullable) GTLRContainer_ClusterUpdate *update;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  UpdateInfo contains resource (instance groups, etc), status and other
 *  intermediate information relevant to a node pool upgrade.
 */
@interface GTLRContainer_UpdateInfo : GTLRObject

/** Information of a blue-green upgrade. */
@property(nonatomic, strong, nullable) GTLRContainer_BlueGreenInfo *blueGreenInfo;

@end


/**
 *  UpdateMasterRequest updates the master of the cluster.
 */
@interface GTLRContainer_UpdateMasterRequest : GTLRObject

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Required. The Kubernetes version to change the master to. Users may specify
 *  either explicit versions offered by Kubernetes Engine or version aliases,
 *  which have the following behavior: - "latest": picks the highest valid
 *  Kubernetes version - "1.X": picks the highest valid patch+gke.N patch in the
 *  1.X version - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y
 *  version - "1.X.Y-gke.N": picks an explicit Kubernetes version - "-": picks
 *  the default Kubernetes version
 */
@property(nonatomic, copy, nullable) NSString *masterVersion;

/**
 *  The name (project, location, cluster) of the cluster to update. Specified in
 *  the format `projects/ * /locations/ * /clusters/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  UpdateNodePoolRequests update a node pool's image and/or version.
 */
@interface GTLRContainer_UpdateNodePoolRequest : GTLRObject

/**
 *  A list of hardware accelerators to be attached to each node. See
 *  https://cloud.google.com/compute/docs/gpus for more information about
 *  support for GPUs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_AcceleratorConfig *> *accelerators;

/**
 *  Deprecated. The name of the cluster to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *clusterId GTLR_DEPRECATED;

/**
 *  Confidential nodes config. All the nodes in the node pool will be
 *  Confidential VM once enabled.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ConfidentialNodes *confidentialNodes;

/**
 *  The desired containerd config for nodes in the node pool. Initiates an
 *  upgrade operation that recreates the nodes with the new config.
 */
@property(nonatomic, strong, nullable) GTLRContainer_DConfig *containerdConfig;

/**
 *  Optional. The desired disk size for nodes in the node pool specified in GB.
 *  The smallest allowed disk size is 10GB. Initiates an upgrade operation that
 *  migrates the nodes in the node pool to the specified disk size.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskSizeGb;

/**
 *  Optional. The desired disk type (e.g. 'pd-standard', 'pd-ssd' or
 *  'pd-balanced') for nodes in the node pool. Initiates an upgrade operation
 *  that migrates the nodes in the node pool to the specified disk type.
 */
@property(nonatomic, copy, nullable) NSString *diskType;

/**
 *  The current etag of the node pool. If an etag is provided and does not match
 *  the current etag of the node pool, update will be blocked and an ABORTED
 *  error will be returned.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Enable or disable NCCL fast socket for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_FastSocket *fastSocket;

/** GCFS config. */
@property(nonatomic, strong, nullable) GTLRContainer_GcfsConfig *gcfsConfig;

/** Enable or disable gvnic on the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_VirtualNIC *gvnic;

/**
 *  Required. The desired image type for the node pool. Please see
 *  https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
 *  available image types.
 */
@property(nonatomic, copy, nullable) NSString *imageType;

/** Node kubelet configs. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeKubeletConfig *kubeletConfig;

/**
 *  The desired node labels to be applied to all nodes in the node pool. If this
 *  field is not present, the labels will not be changed. Otherwise, the
 *  existing node labels will be *replaced* with the provided labels.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeLabels *labels;

/** Parameters that can be configured on Linux nodes. */
@property(nonatomic, strong, nullable) GTLRContainer_LinuxNodeConfig *linuxNodeConfig;

/**
 *  The desired list of Google Compute Engine
 *  [zones](https://cloud.google.com/compute/docs/zones#available) in which the
 *  node pool's nodes should be located. Changing the locations for a node pool
 *  will result in nodes being either created or removed from the node pool,
 *  depending on whether locations are being added or removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locations;

/** Logging configuration. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolLoggingConfig *loggingConfig;

/**
 *  Optional. The desired [Google Compute Engine machine
 *  type](https://cloud.google.com/compute/docs/machine-types) for nodes in the
 *  node pool. Initiates an upgrade operation that migrates the nodes in the
 *  node pool to the specified machine type.
 */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  The name (project, location, cluster, node pool) of the node pool to update.
 *  Specified in the format `projects/ * /locations/ * /clusters/ * /nodePools/
 *  *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Node network config. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeNetworkConfig *nodeNetworkConfig;

/**
 *  Deprecated. The name of the node pool to upgrade. This field has been
 *  deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *nodePoolId GTLR_DEPRECATED;

/**
 *  Required. The Kubernetes version to change the nodes to (typically an
 *  upgrade). Users may specify either explicit versions offered by Kubernetes
 *  Engine or version aliases, which have the following behavior: - "latest":
 *  picks the highest valid Kubernetes version - "1.X": picks the highest valid
 *  patch+gke.N patch in the 1.X version - "1.X.Y": picks the highest valid
 *  gke.N patch in the 1.X.Y version - "1.X.Y-gke.N": picks an explicit
 *  Kubernetes version - "-": picks the Kubernetes master version
 */
@property(nonatomic, copy, nullable) NSString *nodeVersion;

/**
 *  Deprecated. The Google Developers Console [project ID or project
 *  number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
 *  This field has been deprecated and replaced by the name field.
 */
@property(nonatomic, copy, nullable) NSString *projectId GTLR_DEPRECATED;

/** Specifies the configuration of queued provisioning. */
@property(nonatomic, strong, nullable) GTLRContainer_QueuedProvisioning *queuedProvisioning;

/**
 *  The resource labels for the node pool to use to annotate any related Google
 *  Compute Engine resources.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceLabels *resourceLabels;

/**
 *  Desired resource manager tag keys and values to be attached to the nodes for
 *  managing Compute Engine firewalls using Network Firewall Policies. Existing
 *  tags will be replaced with new values.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ResourceManagerTags *resourceManagerTags;

/**
 *  List of Storage Pools where boot disks are provisioned. Existing Storage
 *  Pools will be replaced with storage-pools.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *storagePools;

/**
 *  The desired network tags to be applied to all nodes in the node pool. If
 *  this field is not present, the tags will not be changed. Otherwise, the
 *  existing network tags will be *replaced* with the provided tags.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkTags *tags;

/**
 *  The desired node taints to be applied to all nodes in the node pool. If this
 *  field is not present, the taints will not be changed. Otherwise, the
 *  existing node taints will be *replaced* with the provided taints.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeTaints *taints;

/** Upgrade settings control disruption and speed of the upgrade. */
@property(nonatomic, strong, nullable) GTLRContainer_UpgradeSettings *upgradeSettings;

/** Parameters that can be configured on Windows nodes. */
@property(nonatomic, strong, nullable) GTLRContainer_WindowsNodeConfig *windowsNodeConfig;

/** The desired workload metadata config for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_WorkloadMetadataConfig *workloadMetadataConfig;

/**
 *  Deprecated. The name of the Google Compute Engine
 *  [zone](https://cloud.google.com/compute/docs/zones#available) in which the
 *  cluster resides. This field has been deprecated and replaced by the name
 *  field.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty GTLR_DEPRECATED;

@end


/**
 *  UpgradeAvailableEvent is a notification sent to customers when a new
 *  available version is released.
 */
@interface GTLRContainer_UpgradeAvailableEvent : GTLRObject

/**
 *  The release channel of the version. If empty, it means a non-channel
 *  release.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ReleaseChannel *releaseChannel;

/**
 *  Optional relative path to the resource. For example, the relative path of
 *  the node pool.
 */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The resource type of the release version.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_UpgradeAvailableEvent_ResourceType_Master Master /
 *        control plane (Value: "MASTER")
 *    @arg @c kGTLRContainer_UpgradeAvailableEvent_ResourceType_NodePool Node
 *        pool (Value: "NODE_POOL")
 *    @arg @c kGTLRContainer_UpgradeAvailableEvent_ResourceType_UpgradeResourceTypeUnspecified
 *        Default value. This shouldn't be used. (Value:
 *        "UPGRADE_RESOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

/** The release version available for upgrade. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  UpgradeEvent is a notification sent to customers by the cluster server when
 *  a resource is upgrading.
 */
@interface GTLRContainer_UpgradeEvent : GTLRObject

/** The current version before the upgrade. */
@property(nonatomic, copy, nullable) NSString *currentVersion;

/** The operation associated with this upgrade. */
@property(nonatomic, copy, nullable) NSString *operation;

/** The time when the operation was started. */
@property(nonatomic, strong, nullable) GTLRDateTime *operationStartTime;

/**
 *  Optional relative path to the resource. For example in node pool upgrades,
 *  the relative path of the node pool.
 */
@property(nonatomic, copy, nullable) NSString *resource;

/**
 *  The resource type that is upgrading.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_UpgradeEvent_ResourceType_Master Master / control
 *        plane (Value: "MASTER")
 *    @arg @c kGTLRContainer_UpgradeEvent_ResourceType_NodePool Node pool
 *        (Value: "NODE_POOL")
 *    @arg @c kGTLRContainer_UpgradeEvent_ResourceType_UpgradeResourceTypeUnspecified
 *        Default value. This shouldn't be used. (Value:
 *        "UPGRADE_RESOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

/** The target version for the upgrade. */
@property(nonatomic, copy, nullable) NSString *targetVersion;

@end


/**
 *  These upgrade settings control the level of parallelism and the level of
 *  disruption caused by an upgrade. maxUnavailable controls the number of nodes
 *  that can be simultaneously unavailable. maxSurge controls the number of
 *  additional nodes that can be added to the node pool temporarily for the time
 *  of the upgrade to increase the number of available nodes. (maxUnavailable +
 *  maxSurge) determines the level of parallelism (how many nodes are being
 *  upgraded at the same time). Note: upgrades inevitably introduce some
 *  disruption since workloads need to be moved from old nodes to new, upgraded
 *  ones. Even if maxUnavailable=0, this holds true. (Disruption stays within
 *  the limits of PodDisruptionBudget, if it is configured.) Consider a
 *  hypothetical node pool with 5 nodes having maxSurge=2, maxUnavailable=1.
 *  This means the upgrade process upgrades 3 nodes simultaneously. It creates 2
 *  additional (upgraded) nodes, then it brings down 3 old (not yet upgraded)
 *  nodes at the same time. This ensures that there are always at least 4 nodes
 *  available. These upgrade settings configure the upgrade strategy for the
 *  node pool. Use strategy to switch between the strategies applied to the node
 *  pool. If the strategy is ROLLING, use max_surge and max_unavailable to
 *  control the level of parallelism and the level of disruption caused by
 *  upgrade. 1. maxSurge controls the number of additional nodes that can be
 *  added to the node pool temporarily for the time of the upgrade to increase
 *  the number of available nodes. 2. maxUnavailable controls the number of
 *  nodes that can be simultaneously unavailable. 3. (maxUnavailable + maxSurge)
 *  determines the level of parallelism (how many nodes are being upgraded at
 *  the same time). If the strategy is BLUE_GREEN, use blue_green_settings to
 *  configure the blue-green upgrade related settings. 1.
 *  standard_rollout_policy is the default policy. The policy is used to control
 *  the way blue pool gets drained. The draining is executed in the batch mode.
 *  The batch size could be specified as either percentage of the node pool size
 *  or the number of nodes. batch_soak_duration is the soak time after each
 *  batch gets drained. 2. node_pool_soak_duration is the soak time after all
 *  blue nodes are drained. After this period, the blue pool nodes will be
 *  deleted.
 */
@interface GTLRContainer_UpgradeSettings : GTLRObject

/** Settings for blue-green upgrade strategy. */
@property(nonatomic, strong, nullable) GTLRContainer_BlueGreenSettings *blueGreenSettings;

/**
 *  The maximum number of nodes that can be created beyond the current size of
 *  the node pool during the upgrade process.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxSurge;

/**
 *  The maximum number of nodes that can be simultaneously unavailable during
 *  the upgrade process. A node is considered available if its status is Ready.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxUnavailable;

/**
 *  Update strategy of the node pool.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_UpgradeSettings_Strategy_BlueGreen blue-green
 *        upgrade. (Value: "BLUE_GREEN")
 *    @arg @c kGTLRContainer_UpgradeSettings_Strategy_NodePoolUpdateStrategyUnspecified
 *        Default value if unset. GKE internally defaults the update strategy to
 *        SURGE for unspecified strategies. (Value:
 *        "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED")
 *    @arg @c kGTLRContainer_UpgradeSettings_Strategy_Surge SURGE is the
 *        traditional way of upgrade a node pool. max_surge and max_unavailable
 *        determines the level of upgrade parallelism. (Value: "SURGE")
 */
@property(nonatomic, copy, nullable) NSString *strategy;

@end


/**
 *  UsableSubnetwork resource returns the subnetwork name, its associated
 *  network and the primary CIDR range.
 */
@interface GTLRContainer_UsableSubnetwork : GTLRObject

/** The range of internal addresses that are owned by this subnetwork. */
@property(nonatomic, copy, nullable) NSString *ipCidrRange;

/** Network Name. Example: projects/my-project/global/networks/my-network */
@property(nonatomic, copy, nullable) NSString *network;

/** Secondary IP ranges. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_UsableSubnetworkSecondaryRange *> *secondaryIpRanges;

/**
 *  A human readable status message representing the reasons for cases where the
 *  caller cannot use the secondary ranges under the subnet. For example if the
 *  secondary_ip_ranges is empty due to a permission issue, an insufficient
 *  permission message will be given by status_message.
 */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Subnetwork Name. Example:
 *  projects/my-project/regions/us-central1/subnetworks/my-subnet
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

@end


/**
 *  Secondary IP range of a usable subnetwork.
 */
@interface GTLRContainer_UsableSubnetworkSecondaryRange : GTLRObject

/** The range of IP addresses belonging to this subnetwork secondary range. */
@property(nonatomic, copy, nullable) NSString *ipCidrRange;

/**
 *  The name associated with this subnetwork secondary range, used when adding
 *  an alias IP range to a VM instance.
 */
@property(nonatomic, copy, nullable) NSString *rangeName;

/**
 *  This field is to determine the status of the secondary range programmably.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_UsableSubnetworkSecondaryRange_Status_InUseManagedPod
 *        IN_USE_MANAGED_POD denotes this range was created by GKE and is
 *        claimed for pods. It cannot be used for other clusters. (Value:
 *        "IN_USE_MANAGED_POD")
 *    @arg @c kGTLRContainer_UsableSubnetworkSecondaryRange_Status_InUseService
 *        IN_USE_SERVICE denotes that this range is claimed by cluster(s) for
 *        services. User-managed services range can be shared between clusters
 *        within the same subnetwork. (Value: "IN_USE_SERVICE")
 *    @arg @c kGTLRContainer_UsableSubnetworkSecondaryRange_Status_InUseShareablePod
 *        IN_USE_SHAREABLE_POD denotes this range was created by the network
 *        admin and is currently claimed by a cluster for pods. It can only be
 *        used by other clusters as a pod range. (Value: "IN_USE_SHAREABLE_POD")
 *    @arg @c kGTLRContainer_UsableSubnetworkSecondaryRange_Status_Unknown
 *        UNKNOWN is the zero value of the Status enum. It's not a valid status.
 *        (Value: "UNKNOWN")
 *    @arg @c kGTLRContainer_UsableSubnetworkSecondaryRange_Status_Unused UNUSED
 *        denotes that this range is unclaimed by any cluster. (Value: "UNUSED")
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  VerticalPodAutoscaling contains global, per-cluster information required by
 *  Vertical Pod Autoscaler to automatically adjust the resources of pods
 *  controlled by it.
 */
@interface GTLRContainer_VerticalPodAutoscaling : GTLRObject

/**
 *  Enables vertical pod autoscaling.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration of gVNIC feature.
 */
@interface GTLRContainer_VirtualNIC : GTLRObject

/**
 *  Whether gVNIC features are enabled in the node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Parameters that can be configured on Windows nodes. Windows Node Config that
 *  define the parameters that will be used to configure the Windows node pool
 *  settings
 */
@interface GTLRContainer_WindowsNodeConfig : GTLRObject

/**
 *  OSVersion specifies the Windows node config to be used on the node
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_WindowsNodeConfig_OsVersion_OsVersionLtsc2019
 *        LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base
 *        Image (Value: "OS_VERSION_LTSC2019")
 *    @arg @c kGTLRContainer_WindowsNodeConfig_OsVersion_OsVersionLtsc2022
 *        LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base
 *        Image (Value: "OS_VERSION_LTSC2022")
 *    @arg @c kGTLRContainer_WindowsNodeConfig_OsVersion_OsVersionUnspecified
 *        When OSVersion is not specified (Value: "OS_VERSION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *osVersion;

@end


/**
 *  Configuration for the use of Kubernetes Service Accounts in GCP IAM
 *  policies.
 */
@interface GTLRContainer_WorkloadIdentityConfig : GTLRObject

/** The workload pool to attach all Kubernetes service accounts to. */
@property(nonatomic, copy, nullable) NSString *workloadPool;

@end


/**
 *  WorkloadMetadataConfig defines the metadata configuration to expose to
 *  workloads on the node pool.
 */
@interface GTLRContainer_WorkloadMetadataConfig : GTLRObject

/**
 *  Mode is the configuration for how to expose metadata to workloads running on
 *  the node pool.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_WorkloadMetadataConfig_Mode_GceMetadata Expose all
 *        Compute Engine metadata to pods. (Value: "GCE_METADATA")
 *    @arg @c kGTLRContainer_WorkloadMetadataConfig_Mode_GkeMetadata Run the GKE
 *        Metadata Server on this node. The GKE Metadata Server exposes a
 *        metadata API to workloads that is compatible with the V1 Compute
 *        Metadata APIs exposed by the Compute Engine and App Engine Metadata
 *        Servers. This feature can only be enabled if Workload Identity is
 *        enabled at the cluster level. (Value: "GKE_METADATA")
 *    @arg @c kGTLRContainer_WorkloadMetadataConfig_Mode_ModeUnspecified Not
 *        set. (Value: "MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  WorkloadPolicyConfig is the configuration of workload policy for autopilot
 *  clusters.
 */
@interface GTLRContainer_WorkloadPolicyConfig : GTLRObject

/**
 *  If true, workloads can use NET_ADMIN capability.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowNetAdmin;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
