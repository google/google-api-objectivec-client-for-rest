// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Backup for GKE API (gkebackup/v1)
// Description:
//   Backup for GKE is a managed Kubernetes workload backup and restore service
//   for GKE clusters.
// Documentation:
//   https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRBackupforGKE_AuditConfig;
@class GTLRBackupforGKE_AuditLogConfig;
@class GTLRBackupforGKE_Backup;
@class GTLRBackupforGKE_Backup_Labels;
@class GTLRBackupforGKE_BackupConfig;
@class GTLRBackupforGKE_BackupPlan;
@class GTLRBackupforGKE_BackupPlan_Labels;
@class GTLRBackupforGKE_Binding;
@class GTLRBackupforGKE_ClusterMetadata;
@class GTLRBackupforGKE_ClusterMetadata_BackupCrdVersions;
@class GTLRBackupforGKE_ClusterResourceRestoreScope;
@class GTLRBackupforGKE_EncryptionKey;
@class GTLRBackupforGKE_Expr;
@class GTLRBackupforGKE_GoogleLongrunningOperation;
@class GTLRBackupforGKE_GoogleLongrunningOperation_Metadata;
@class GTLRBackupforGKE_GoogleLongrunningOperation_Response;
@class GTLRBackupforGKE_GoogleRpcStatus;
@class GTLRBackupforGKE_GoogleRpcStatus_Details_Item;
@class GTLRBackupforGKE_GroupKind;
@class GTLRBackupforGKE_Location;
@class GTLRBackupforGKE_Location_Labels;
@class GTLRBackupforGKE_Location_Metadata;
@class GTLRBackupforGKE_NamespacedName;
@class GTLRBackupforGKE_NamespacedNames;
@class GTLRBackupforGKE_Namespaces;
@class GTLRBackupforGKE_Policy;
@class GTLRBackupforGKE_Restore;
@class GTLRBackupforGKE_Restore_Labels;
@class GTLRBackupforGKE_RestoreConfig;
@class GTLRBackupforGKE_RestorePlan;
@class GTLRBackupforGKE_RestorePlan_Labels;
@class GTLRBackupforGKE_RetentionPolicy;
@class GTLRBackupforGKE_Schedule;
@class GTLRBackupforGKE_SubstitutionRule;
@class GTLRBackupforGKE_VolumeBackup;
@class GTLRBackupforGKE_VolumeRestore;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_Backup.state

/**
 *  The Backup resource has been created and the associated BackupJob Kubernetes
 *  resource has been injected into the source cluster.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Backup_State_Creating;
/**
 *  This Backup resource (and its associated artifacts) is in the process of
 *  being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Backup_State_Deleting;
/**
 *  The backup operation has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Backup_State_Failed;
/**
 *  The gkebackup agent in the cluster has begun executing the backup operation.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Backup_State_InProgress;
/**
 *  The Backup resource is in the process of being created.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Backup_State_StateUnspecified;
/**
 *  The backup operation has completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Backup_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_Restore.state

/**
 *  The Restore resource has been created and the associated RestoreJob
 *  Kubernetes resource has been injected into target cluster.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Restore_State_Creating;
/**
 *  This Restore resource is in the process of being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Restore_State_Deleting;
/**
 *  The restore operation has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Restore_State_Failed;
/**
 *  The gkebackup agent in the cluster has begun executing the restore
 *  operation.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Restore_State_InProgress;
/**
 *  The Restore resource is in the process of being created.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Restore_State_StateUnspecified;
/**
 *  The restore operation has completed successfully. Restored workloads may not
 *  yet be operational.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_Restore_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_RestoreConfig.clusterResourceConflictPolicy

/**
 *  Unspecified. Only allowed if no cluster-scoped resources will be restored.
 *
 *  Value: "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_ClusterResourceConflictPolicy_ClusterResourceConflictPolicyUnspecified;
/**
 *  Delete the existing version before re-creating it from the Backup. Note that
 *  this is a dangerous option which could cause unintentional data loss if used
 *  inappropriately - for example, deleting a CRD will cause Kubernetes to
 *  delete all CRs of that type.
 *
 *  Value: "USE_BACKUP_VERSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_ClusterResourceConflictPolicy_UseBackupVersion;
/**
 *  Do not attempt to restore the conflicting resource.
 *
 *  Value: "USE_EXISTING_VERSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_ClusterResourceConflictPolicy_UseExistingVersion;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_RestoreConfig.namespacedResourceRestoreMode

/**
 *  When conflicting top-level resources (either Namespaces or
 *  ProtectedApplications, depending upon the scope) are encountered, this will
 *  first trigger a delete of the conflicting resource AND ALL OF ITS REFERENCED
 *  RESOURCES (e.g., all resources in the Namespace or all resources referenced
 *  by the ProtectedApplication) before restoring the resources from the Backup.
 *  This mode should only be used when you are intending to revert some portion
 *  of a cluster to an earlier state.
 *
 *  Value: "DELETE_AND_RESTORE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_NamespacedResourceRestoreMode_DeleteAndRestore;
/**
 *  If conflicting top-level resources (either Namespaces or
 *  ProtectedApplications, depending upon the scope) are encountered at the
 *  beginning of a restore process, the Restore will fail. If a conflict occurs
 *  during the restore process itself (e.g., because an out of band process
 *  creates conflicting resources), a conflict will be reported.
 *
 *  Value: "FAIL_ON_CONFLICT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_NamespacedResourceRestoreMode_FailOnConflict;
/**
 *  Unspecified (invalid).
 *
 *  Value: "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_NamespacedResourceRestoreMode_NamespacedResourceRestoreModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_RestoreConfig.volumeDataRestorePolicy

/**
 *  For each PVC to be restored, PVCs will be created without any particular
 *  action to restore data. In this case, the normal Kubernetes provisioning
 *  logic would kick in, and this would likely result in either dynamically
 *  provisioning blank PVs or binding to statically provisioned PVs.
 *
 *  Value: "NO_VOLUME_DATA_RESTORATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_NoVolumeDataRestoration;
/**
 *  For each PVC to be restored, will create a new underlying volume (and PV)
 *  from the corresponding VolumeBackup contained within the Backup.
 *
 *  Value: "RESTORE_VOLUME_DATA_FROM_BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_RestoreVolumeDataFromBackup;
/**
 *  For each PVC to be restored, attempt to reuse the original PV contained in
 *  the Backup (with its original underlying volume). Note that option is likely
 *  only usable when restoring a workload to its original cluster.
 *
 *  Value: "REUSE_VOLUME_HANDLE_FROM_BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_ReuseVolumeHandleFromBackup;
/**
 *  Unspecified (illegal).
 *
 *  Value: "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_VolumeDataRestorePolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_VolumeBackup.format

/**
 *  Compute Engine Persistent Disk snapshot based volume backup.
 *
 *  Value: "GCE_PERSISTENT_DISK"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_Format_GcePersistentDisk;
/**
 *  Default value, not specified.
 *
 *  Value: "VOLUME_BACKUP_FORMAT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_Format_VolumeBackupFormatUnspecified;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_VolumeBackup.state

/**
 *  A volume for the backup was identified and backup process is about to start.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_Creating;
/**
 *  This VolumeBackup resource (and its associated artifacts) is in the process
 *  of being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_Deleting;
/**
 *  The volume backup operation has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_Failed;
/**
 *  The volume backup operation has begun and is in the initial "snapshot" phase
 *  of the process. Any defined ProtectedApplication "pre" hooks will be
 *  executed before entering this state and "post" hooks will be executed upon
 *  leaving this state.
 *
 *  Value: "SNAPSHOTTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_Snapshotting;
/**
 *  This is an illegal state and should not be encountered.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_StateUnspecified;
/**
 *  The volume backup operation has completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_Succeeded;
/**
 *  The snapshot phase of the volume backup operation has completed and the
 *  snapshot is now being uploaded to backup storage.
 *
 *  Value: "UPLOADING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeBackup_State_Uploading;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_VolumeRestore.state

/**
 *  A volume for the restore was identified and restore process is about to
 *  start.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_State_Creating;
/**
 *  This VolumeRestore resource is in the process of being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_State_Deleting;
/**
 *  The volume restoration process failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_State_Failed;
/**
 *  The volume is currently being restored.
 *
 *  Value: "RESTORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_State_Restoring;
/**
 *  This is an illegal state and should not be encountered.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_State_StateUnspecified;
/**
 *  The volume has been successfully restored.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRBackupforGKE_VolumeRestore.volumeType

/**
 *  Compute Engine Persistent Disk volume
 *
 *  Value: "GCE_PERSISTENT_DISK"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_VolumeType_GcePersistentDisk;
/**
 *  Default
 *
 *  Value: "VOLUME_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBackupforGKE_VolumeRestore_VolumeType_VolumeTypeUnspecified;

/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRBackupforGKE_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRBackupforGKE_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRBackupforGKE_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRBackupforGKE_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRBackupforGKE_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Represents a request to perform a single point-in-time capture of some
 *  portion of the state of a GKE cluster, the record of the backup operation
 *  itself, and an anchor for the underlying artifacts that comprise the Backup
 *  (the config backup and VolumeBackups). Next id: 28
 */
@interface GTLRBackupforGKE_Backup : GTLRObject

/**
 *  Output only. If True, all namespaces were included in the Backup.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allNamespaces;

/**
 *  Output only. Information about the GKE cluster from which this Backup was
 *  created.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_ClusterMetadata *clusterMetadata;

/** Output only. Completion time of the Backup */
@property(nonatomic, strong, nullable) GTLRDateTime *completeTime;

/**
 *  Output only. The size of the config backup in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *configBackupSizeBytes;

/**
 *  Output only. Whether or not the Backup contains Kubernetes Secrets.
 *  Controlled by the parent BackupPlan's include_secrets value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *containsSecrets;

/**
 *  Output only. Whether or not the Backup contains volume data. Controlled by
 *  the parent BackupPlan's include_volume_data value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *containsVolumeData;

/** Output only. The timestamp when this Backup resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Minimum age for this Backup (in days). If this field is set to a non-zero
 *  value, the Backup will be "locked" against deletion (either manual or
 *  automatic deletion) for the number of days provided (measured from the
 *  creation time of the Backup). MUST be an integer value between 0-90
 *  (inclusive). Defaults to parent BackupPlan's backup_delete_lock_days setting
 *  and may only be increased (either at creation time or in a subsequent
 *  update).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deleteLockDays;

/**
 *  Output only. The time at which an existing delete lock will expire for this
 *  backup (calculated from create_time + delete_lock_days).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteLockExpireTime;

/**
 *  User specified descriptive string for this Backup.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The customer managed encryption key that was used to encrypt
 *  the Backup's artifacts. Inherited from the parent BackupPlan's
 *  encryption_key value.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_EncryptionKey *encryptionKey;

/**
 *  Output only. `etag` is used for optimistic concurrency control as a way to
 *  help prevent simultaneous updates of a backup from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform backup updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `GetBackup`, and
 *  systems are expected to put that etag in the request to `UpdateBackup` or
 *  `DeleteBackup` to ensure that their change will be applied to the same
 *  version of the resource.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** A set of custom labels supplied by user. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Backup_Labels *labels;

/**
 *  Output only. This flag indicates whether this Backup resource was created
 *  manually by a user or via a schedule in the BackupPlan. A value of True
 *  means that the Backup was created manually.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *manual;

/**
 *  Output only. The fully qualified name of the Backup. `projects/ *
 *  /locations/ * /backupPlans/ * /backups/ *`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The total number of Kubernetes Pods contained in the Backup.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podCount;

/**
 *  Output only. The total number of Kubernetes resources included in the
 *  Backup.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *resourceCount;

/**
 *  The age (in days) after which this Backup will be automatically deleted.
 *  Must be an integer value >= 0: - If 0, no automatic deletion will occur for
 *  this Backup. - If not 0, this must be >= delete_lock_days and <= 365. Once a
 *  Backup is created, this value may only be increased. Defaults to the parent
 *  BackupPlan's backup_retain_days value.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *retainDays;

/**
 *  Output only. The time at which this Backup will be automatically deleted
 *  (calculated from create_time + retain_days).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *retainExpireTime;

/**
 *  Output only. If set, the list of ProtectedApplications whose resources were
 *  included in the Backup.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_NamespacedNames *selectedApplications;

/**
 *  Output only. If set, the list of namespaces that were included in the
 *  Backup.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Namespaces *selectedNamespaces;

/**
 *  Output only. The total size of the Backup in bytes = config backup size +
 *  sum(volume backup sizes)
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeBytes;

/**
 *  Output only. Current state of the Backup
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_Backup_State_Creating The Backup resource has
 *        been created and the associated BackupJob Kubernetes resource has been
 *        injected into the source cluster. (Value: "CREATING")
 *    @arg @c kGTLRBackupforGKE_Backup_State_Deleting This Backup resource (and
 *        its associated artifacts) is in the process of being deleted. (Value:
 *        "DELETING")
 *    @arg @c kGTLRBackupforGKE_Backup_State_Failed The backup operation has
 *        failed. (Value: "FAILED")
 *    @arg @c kGTLRBackupforGKE_Backup_State_InProgress The gkebackup agent in
 *        the cluster has begun executing the backup operation. (Value:
 *        "IN_PROGRESS")
 *    @arg @c kGTLRBackupforGKE_Backup_State_StateUnspecified The Backup
 *        resource is in the process of being created. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBackupforGKE_Backup_State_Succeeded The backup operation has
 *        completed successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. Human-readable description of why the backup is in the current
 *  `state`.
 */
@property(nonatomic, copy, nullable) NSString *stateReason;

/**
 *  Output only. Server generated global unique identifier of
 *  [UUID4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The timestamp when this Backup resource was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Output only. The total number of volume backups contained in the Backup.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *volumeCount;

@end


/**
 *  A set of custom labels supplied by user.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBackupforGKE_Backup_Labels : GTLRObject
@end


/**
 *  BackupConfig defines the configuration of Backups created via this
 *  BackupPlan.
 */
@interface GTLRBackupforGKE_BackupConfig : GTLRObject

/**
 *  If True, include all namespaced resources
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allNamespaces;

/**
 *  This defines a customer managed encryption key that will be used to encrypt
 *  the "config" portion (the Kubernetes resources) of Backups created via this
 *  plan. Default (empty): Config backup artifacts will not be encrypted.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_EncryptionKey *encryptionKey;

/**
 *  This flag specifies whether Kubernetes Secret resources should be included
 *  when they fall into the scope of Backups. Default: False
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *includeSecrets;

/**
 *  This flag specifies whether volume data should be backed up when PVCs are
 *  included in the scope of a Backup. Default: False
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *includeVolumeData;

/**
 *  If set, include just the resources referenced by the listed
 *  ProtectedApplications.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_NamespacedNames *selectedApplications;

/** If set, include just the resources in the listed namespaces. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Namespaces *selectedNamespaces;

@end


/**
 *  Defines the configuration and scheduling for a "line" of Backups.
 */
@interface GTLRBackupforGKE_BackupPlan : GTLRObject

/** Defines the configuration of Backups created via this BackupPlan. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_BackupConfig *backupConfig;

/** Defines a schedule for automatic Backup creation via this BackupPlan. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Schedule *backupSchedule;

/**
 *  Required. Immutable. The source cluster from which Backups will be created
 *  via this BackupPlan. Valid formats: - `projects/ * /locations/ * /clusters/
 *  *` - `projects/ * /zones/ * /clusters/ *`
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/** Output only. The timestamp when this BackupPlan resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  This flag indicates whether this BackupPlan has been deactivated. Setting
 *  this field to True locks the BackupPlan such that no further updates will be
 *  allowed (except deletes), including the deactivated field itself. It also
 *  prevents any new Backups from being created via this BackupPlan (including
 *  scheduled Backups). Default: False
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deactivated;

/**
 *  User specified descriptive string for this BackupPlan.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. `etag` is used for optimistic concurrency control as a way to
 *  help prevent simultaneous updates of a backup plan from overwriting each
 *  other. It is strongly suggested that systems make use of the 'etag' in the
 *  read-modify-write cycle to perform BackupPlan updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `GetBackupPlan`, and
 *  systems are expected to put that etag in the request to `UpdateBackupPlan`
 *  or `DeleteBackupPlan` to ensure that their change will be applied to the
 *  same version of the resource.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** A set of custom labels supplied by user. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_BackupPlan_Labels *labels;

/**
 *  Output only. The full name of the BackupPlan resource. Format: `projects/ *
 *  /locations/ * /backupPlans/ *`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The number of Kubernetes Pods backed up in the last successful
 *  Backup created via this BackupPlan.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *protectedPodCount;

/** RetentionPolicy governs lifecycle of Backups created under this plan. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_RetentionPolicy *retentionPolicy;

/**
 *  Output only. Server generated global unique identifier of
 *  [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The timestamp when this BackupPlan resource was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  A set of custom labels supplied by user.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBackupforGKE_BackupPlan_Labels : GTLRObject
@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRBackupforGKE_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
 *  An email address (plus unique identifier) representing a user that has been
 *  recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Information about the GKE cluster from which this Backup was created.
 */
@interface GTLRBackupforGKE_ClusterMetadata : GTLRObject

/** Anthos version */
@property(nonatomic, copy, nullable) NSString *anthosVersion;

/** A list of the Backup for GKE CRD versions found in the cluster. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_ClusterMetadata_BackupCrdVersions *backupCrdVersions;

/**
 *  The source cluster from which this Backup was created. Valid formats: -
 *  `projects/ * /locations/ * /clusters/ *` - `projects/ * /zones/ * /clusters/
 *  *` This is inherited from the parent BackupPlan's cluster field.
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/** GKE version */
@property(nonatomic, copy, nullable) NSString *gkeVersion;

/** The Kubernetes server version of the source cluster. */
@property(nonatomic, copy, nullable) NSString *k8sVersion;

@end


/**
 *  A list of the Backup for GKE CRD versions found in the cluster.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBackupforGKE_ClusterMetadata_BackupCrdVersions : GTLRObject
@end


/**
 *  Identifies the cluster-scoped resources to restore from the Backup.
 */
@interface GTLRBackupforGKE_ClusterResourceRestoreScope : GTLRObject

/**
 *  A list of "types" of cluster-scoped resources to be restored from the
 *  Backup. An empty list means that NO cluster-scoped resources will be
 *  restored. Note that Namespaces and PersistentVolume restoration is handled
 *  separately and is not governed by this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_GroupKind *> *selectedGroupKinds;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRBackupforGKE_Empty : GTLRObject
@end


/**
 *  Defined a customer managed encryption key that will be used to encrypt
 *  Backup artifacts.
 */
@interface GTLRBackupforGKE_EncryptionKey : GTLRObject

/**
 *  Google Cloud KMS encryption key. Format: `projects/ * /locations/ *
 *  /keyRings/ * /cryptoKeys/ *`
 */
@property(nonatomic, copy, nullable) NSString *gcpKmsEncryptionKey;

@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRBackupforGKE_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRBackupforGKE_GoogleLongrunningCancelOperationRequest : GTLRObject
@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_GoogleLongrunningListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_GoogleLongrunningOperation *> *operations;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRBackupforGKE_GoogleLongrunningOperation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_GoogleRpcStatus *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_GoogleLongrunningOperation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_GoogleLongrunningOperation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBackupforGKE_GoogleLongrunningOperation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBackupforGKE_GoogleLongrunningOperation_Response : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRBackupforGKE_GoogleRpcStatus : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_GoogleRpcStatus_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRBackupforGKE_GoogleRpcStatus_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBackupforGKE_GoogleRpcStatus_Details_Item : GTLRObject
@end


/**
 *  This is a direct map to the Kubernetes GroupKind type
 *  [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind)
 *  and is used for identifying specific "types" of resources to restore.
 */
@interface GTLRBackupforGKE_GroupKind : GTLRObject

/**
 *  API group string of a Kubernetes resource, e.g. "apiextensions.k8s.io",
 *  "storage.k8s.io", etc. Note: use empty string for core API group
 */
@property(nonatomic, copy, nullable) NSString *resourceGroup;

/**
 *  Kind of a Kubernetes resource, e.g. "CustomResourceDefinition",
 *  "StorageClass", etc.
 */
@property(nonatomic, copy, nullable) NSString *resourceKind;

@end


/**
 *  Response message for ListBackupPlans.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backupPlans" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_ListBackupPlansResponse : GTLRCollectionObject

/**
 *  The list of BackupPlans matching the given criteria.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_BackupPlan *> *backupPlans;

/**
 *  A token which may be sent as page_token in a subsequent `ListBackupPlans`
 *  call to retrieve the next page of results. If this field is omitted or
 *  empty, then there are no more results to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for ListBackups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_ListBackupsResponse : GTLRCollectionObject

/**
 *  The list of Backups matching the given criteria.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_Backup *> *backups;

/**
 *  A token which may be sent as page_token in a subsequent `ListBackups` call
 *  to retrieve the next page of results. If this field is omitted or empty,
 *  then there are no more results to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for ListRestorePlans.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "restorePlans" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_ListRestorePlansResponse : GTLRCollectionObject

/**
 *  A token which may be sent as page_token in a subsequent `ListRestorePlans`
 *  call to retrieve the next page of results. If this field is omitted or
 *  empty, then there are no more results to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of RestorePlans matching the given criteria.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_RestorePlan *> *restorePlans;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for ListRestores.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "restores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_ListRestoresResponse : GTLRCollectionObject

/**
 *  A token which may be sent as page_token in a subsequent `ListRestores` call
 *  to retrieve the next page of results. If this field is omitted or empty,
 *  then there are no more results to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of Restores matching the given criteria.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_Restore *> *restores;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for ListVolumeBackups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "volumeBackups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBackupforGKE_ListVolumeBackupsResponse : GTLRCollectionObject

/**
 *  A token which may be sent as page_token in a subsequent `ListVolumeBackups`
 *  call to retrieve the next page of results. If this field is omitted or
 *  empty, then there are no more results to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of VolumeBackups matching the given criteria.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_VolumeBackup *> *volumeBackups;

@end


/**
 *  Response message for ListVolumeRestores.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "volumeRestores" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRBackupforGKE_ListVolumeRestoresResponse : GTLRCollectionObject

/**
 *  A token which may be sent as page_token in a subsequent `ListVolumeRestores`
 *  call to retrieve the next page of results. If this field is omitted or
 *  empty, then there are no more results to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of VolumeRestores matching the given criteria.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_VolumeRestore *> *volumeRestores;

@end


/**
 *  A resource that represents Google Cloud Platform location.
 */
@interface GTLRBackupforGKE_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBackupforGKE_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBackupforGKE_Location_Metadata : GTLRObject
@end


/**
 *  A reference to a namespaced resource in Kubernetes.
 */
@interface GTLRBackupforGKE_NamespacedName : GTLRObject

/** The name of the Kubernetes resource. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The Namespace of the Kubernetes resource.
 *
 *  Remapped to 'namespaceProperty' to avoid language reserved word 'namespace'.
 */
@property(nonatomic, copy, nullable) NSString *namespaceProperty;

@end


/**
 *  A list of namespaced Kubernetes resources.
 */
@interface GTLRBackupforGKE_NamespacedNames : GTLRObject

/** A list of namespaced Kubernetes resources. */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_NamespacedName *> *namespacedNames;

@end


/**
 *  A list of Kubernetes Namespaces
 */
@interface GTLRBackupforGKE_Namespaces : GTLRObject

/** A list of Kubernetes Namespaces */
@property(nonatomic, strong, nullable) NSArray<NSString *> *namespaces;

@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRBackupforGKE_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have successfully been cancelled have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRBackupforGKE_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Represents both a request to Restore some portion of a Backup into a target
 *  GKE cluster and a record of the restore operation itself. Next id: 18
 */
@interface GTLRBackupforGKE_Restore : GTLRObject

/**
 *  Required. Immutable. A reference to the Backup used as the source from which
 *  this Restore will restore. Note that this Backup must be a sub-resource of
 *  the RestorePlan's backup_plan. Format: `projects/ * /locations/ *
 *  /backupPlans/ * /backups/ *`.
 */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  Output only. The target cluster into which this Restore will restore data.
 *  Valid formats: - `projects/ * /locations/ * /clusters/ *` - `projects/ *
 *  /zones/ * /clusters/ *` Inherited from parent RestorePlan's cluster value.
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/** Output only. Timestamp of when the restore operation completed. */
@property(nonatomic, strong, nullable) GTLRDateTime *completeTime;

/** Output only. The timestamp when this Restore resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  User specified descriptive string for this Restore.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. `etag` is used for optimistic concurrency control as a way to
 *  help prevent simultaneous updates of a restore from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform restore updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `GetRestore`, and
 *  systems are expected to put that etag in the request to `UpdateRestore` or
 *  `DeleteRestore` to ensure that their change will be applied to the same
 *  version of the resource.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** A set of custom labels supplied by user. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Restore_Labels *labels;

/**
 *  Output only. The full name of the Restore resource. Format: `projects/ *
 *  /locations/ * /restorePlans/ * /restores/ *`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Number of resources excluded during the restore execution.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *resourcesExcludedCount;

/**
 *  Output only. Number of resources that failed to be restored during the
 *  restore execution.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *resourcesFailedCount;

/**
 *  Output only. Number of resources restored during the restore execution.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *resourcesRestoredCount;

/**
 *  Output only. Configuration of the Restore. Inherited from parent
 *  RestorePlan's restore_config.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_RestoreConfig *restoreConfig;

/**
 *  Output only. The current state of the Restore.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_Restore_State_Creating The Restore resource has
 *        been created and the associated RestoreJob Kubernetes resource has
 *        been injected into target cluster. (Value: "CREATING")
 *    @arg @c kGTLRBackupforGKE_Restore_State_Deleting This Restore resource is
 *        in the process of being deleted. (Value: "DELETING")
 *    @arg @c kGTLRBackupforGKE_Restore_State_Failed The restore operation has
 *        failed. (Value: "FAILED")
 *    @arg @c kGTLRBackupforGKE_Restore_State_InProgress The gkebackup agent in
 *        the cluster has begun executing the restore operation. (Value:
 *        "IN_PROGRESS")
 *    @arg @c kGTLRBackupforGKE_Restore_State_StateUnspecified The Restore
 *        resource is in the process of being created. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBackupforGKE_Restore_State_Succeeded The restore operation
 *        has completed successfully. Restored workloads may not yet be
 *        operational. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. Human-readable description of why the Restore is in its current
 *  state.
 */
@property(nonatomic, copy, nullable) NSString *stateReason;

/**
 *  Output only. Server generated global unique identifier of
 *  [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The timestamp when this Restore resource was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Output only. Number of volumes restored during the restore execution.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *volumesRestoredCount;

@end


/**
 *  A set of custom labels supplied by user.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBackupforGKE_Restore_Labels : GTLRObject
@end


/**
 *  Configuration of a restore. Next id: 9
 */
@interface GTLRBackupforGKE_RestoreConfig : GTLRObject

/**
 *  Restore all namespaced resources in the Backup if set to "True". Specifying
 *  this field to "False" is an error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allNamespaces;

/**
 *  Defines the behavior for handling the situation where cluster-scoped
 *  resources being restored already exist in the target cluster. This MUST be
 *  set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if
 *  cluster_resource_restore_scope is not empty.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_ClusterResourceConflictPolicy_ClusterResourceConflictPolicyUnspecified
 *        Unspecified. Only allowed if no cluster-scoped resources will be
 *        restored. (Value: "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_ClusterResourceConflictPolicy_UseBackupVersion
 *        Delete the existing version before re-creating it from the Backup.
 *        Note that this is a dangerous option which could cause unintentional
 *        data loss if used inappropriately - for example, deleting a CRD will
 *        cause Kubernetes to delete all CRs of that type. (Value:
 *        "USE_BACKUP_VERSION")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_ClusterResourceConflictPolicy_UseExistingVersion
 *        Do not attempt to restore the conflicting resource. (Value:
 *        "USE_EXISTING_VERSION")
 */
@property(nonatomic, copy, nullable) NSString *clusterResourceConflictPolicy;

/**
 *  Identifies the cluster-scoped resources to restore from the Backup. Not
 *  specifying it means NO cluster resource will be restored.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_ClusterResourceRestoreScope *clusterResourceRestoreScope;

/**
 *  Defines the behavior for handling the situation where sets of namespaced
 *  resources being restored already exist in the target cluster. This MUST be
 *  set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_NamespacedResourceRestoreMode_DeleteAndRestore
 *        When conflicting top-level resources (either Namespaces or
 *        ProtectedApplications, depending upon the scope) are encountered, this
 *        will first trigger a delete of the conflicting resource AND ALL OF ITS
 *        REFERENCED RESOURCES (e.g., all resources in the Namespace or all
 *        resources referenced by the ProtectedApplication) before restoring the
 *        resources from the Backup. This mode should only be used when you are
 *        intending to revert some portion of a cluster to an earlier state.
 *        (Value: "DELETE_AND_RESTORE")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_NamespacedResourceRestoreMode_FailOnConflict
 *        If conflicting top-level resources (either Namespaces or
 *        ProtectedApplications, depending upon the scope) are encountered at
 *        the beginning of a restore process, the Restore will fail. If a
 *        conflict occurs during the restore process itself (e.g., because an
 *        out of band process creates conflicting resources), a conflict will be
 *        reported. (Value: "FAIL_ON_CONFLICT")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_NamespacedResourceRestoreMode_NamespacedResourceRestoreModeUnspecified
 *        Unspecified (invalid). (Value:
 *        "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *namespacedResourceRestoreMode;

/**
 *  A list of selected ProtectedApplications to restore. The listed
 *  ProtectedApplications and all the resources to which they refer will be
 *  restored.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_NamespacedNames *selectedApplications;

/**
 *  A list of selected Namespaces to restore from the Backup. The listed
 *  Namespaces and all resources contained in them will be restored.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Namespaces *selectedNamespaces;

/**
 *  A list of transformation rules to be applied against Kubernetes resources as
 *  they are selected for restoration from a Backup. Rules are executed in order
 *  defined - this order matters, as changes made by a rule may impact the
 *  filtering logic of subsequent rules. An empty list means no substitution
 *  will occur.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_SubstitutionRule *> *substitutionRules;

/**
 *  Specifies the mechanism to be used to restore volume data. Default:
 *  VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as
 *  NO_VOLUME_DATA_RESTORATION).
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_NoVolumeDataRestoration
 *        For each PVC to be restored, PVCs will be created without any
 *        particular action to restore data. In this case, the normal Kubernetes
 *        provisioning logic would kick in, and this would likely result in
 *        either dynamically provisioning blank PVs or binding to statically
 *        provisioned PVs. (Value: "NO_VOLUME_DATA_RESTORATION")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_RestoreVolumeDataFromBackup
 *        For each PVC to be restored, will create a new underlying volume (and
 *        PV) from the corresponding VolumeBackup contained within the Backup.
 *        (Value: "RESTORE_VOLUME_DATA_FROM_BACKUP")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_ReuseVolumeHandleFromBackup
 *        For each PVC to be restored, attempt to reuse the original PV
 *        contained in the Backup (with its original underlying volume). Note
 *        that option is likely only usable when restoring a workload to its
 *        original cluster. (Value: "REUSE_VOLUME_HANDLE_FROM_BACKUP")
 *    @arg @c kGTLRBackupforGKE_RestoreConfig_VolumeDataRestorePolicy_VolumeDataRestorePolicyUnspecified
 *        Unspecified (illegal). (Value:
 *        "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *volumeDataRestorePolicy;

@end


/**
 *  The configuration of a potential series of Restore operations to be
 *  performed against Backups belong to a particular BackupPlan. Next id: 11
 */
@interface GTLRBackupforGKE_RestorePlan : GTLRObject

/**
 *  Required. Immutable. A reference to the BackupPlan from which Backups may be
 *  used as the source for Restores created via this RestorePlan. Format:
 *  `projects/ * /locations/ * /backupPlans/ *`.
 */
@property(nonatomic, copy, nullable) NSString *backupPlan;

/**
 *  Required. Immutable. The target cluster into which Restores created via this
 *  RestorePlan will restore data. NOTE: the cluster's region must be the same
 *  as the RestorePlan. Valid formats: - `projects/ * /locations/ * /clusters/
 *  *` - `projects/ * /zones/ * /clusters/ *`
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/** Output only. The timestamp when this RestorePlan resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  User specified descriptive string for this RestorePlan.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. `etag` is used for optimistic concurrency control as a way to
 *  help prevent simultaneous updates of a restore from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform restore updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `GetRestorePlan`, and
 *  systems are expected to put that etag in the request to `UpdateRestorePlan`
 *  or `DeleteRestorePlan` to ensure that their change will be applied to the
 *  same version of the resource.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** A set of custom labels supplied by user. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_RestorePlan_Labels *labels;

/**
 *  Output only. The full name of the RestorePlan resource. Format: `projects/ *
 *  /locations/ * /restorePlans/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. Configuration of Restores created via this RestorePlan. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_RestoreConfig *restoreConfig;

/**
 *  Output only. Server generated global unique identifier of
 *  [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The timestamp when this RestorePlan resource was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  A set of custom labels supplied by user.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBackupforGKE_RestorePlan_Labels : GTLRObject
@end


/**
 *  RetentionPolicy defines a Backup retention policy for a BackupPlan.
 */
@interface GTLRBackupforGKE_RetentionPolicy : GTLRObject

/**
 *  Minimum age for Backups created via this BackupPlan (in days). This field
 *  MUST be an integer value between 0-90 (inclusive). A Backup created under
 *  this BackupPlan will NOT be deletable until it reaches Backup's (create_time
 *  + backup_delete_lock_days). Updating this field of a BackupPlan does NOT
 *  affect existing Backups under it. Backups created AFTER a successful update
 *  will inherit the new value. Default: 0 (no delete blocking)
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *backupDeleteLockDays;

/**
 *  The default maximum age of a Backup created via this BackupPlan. This field
 *  MUST be an integer value >= 0 and <= 365. If specified, a Backup created
 *  under this BackupPlan will be automatically deleted after its age reaches
 *  (create_time + backup_retain_days). If not specified, Backups created under
 *  this BackupPlan will NOT be subject to automatic deletion. Updating this
 *  field does NOT affect existing Backups under it. Backups created AFTER a
 *  successful update will automatically pick up the new value. NOTE:
 *  backup_retain_days must be >= backup_delete_lock_days. If cron_schedule is
 *  defined, then this must be <= 360 * the creation interval. Default: 0 (no
 *  automatic deletion)
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *backupRetainDays;

/**
 *  This flag denotes whether the retention policy of this BackupPlan is locked.
 *  If set to True, no further update is allowed on this policy, including the
 *  `locked` field itself. Default: False
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *locked;

@end


/**
 *  Schedule defines scheduling parameters for automatically creating Backups
 *  via this BackupPlan.
 */
@interface GTLRBackupforGKE_Schedule : GTLRObject

/**
 *  A standard [cron](https://wikipedia.com/wiki/cron) string that defines a
 *  repeating schedule for creating Backups via this BackupPlan. If this is
 *  defined, then backup_retain_days must also be defined. Default (empty): no
 *  automatic backup creation will occur.
 */
@property(nonatomic, copy, nullable) NSString *cronSchedule;

/**
 *  This flag denotes whether automatic Backup creation is paused for this
 *  BackupPlan. Default: False
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *paused;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRBackupforGKE_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  A transformation rule to be applied against Kubernetes resources as they are
 *  selected for restoration from a Backup. A rule contains both filtering logic
 *  (which resources are subject to substitution) and substitution logic.
 */
@interface GTLRBackupforGKE_SubstitutionRule : GTLRObject

/**
 *  This is the new value to set for any fields that pass the filtering and
 *  selection criteria. To remove a value from a Kubernetes resource, either
 *  leave this field unspecified, or set it to the empty string ("").
 */
@property(nonatomic, copy, nullable) NSString *newValue NS_RETURNS_NOT_RETAINED;

/**
 *  (Filtering parameter) This is a [regular expression]
 *  (https://en.wikipedia.org/wiki/Regular_expression) that is compared against
 *  the fields matched by the target_json_path expression (and must also have
 *  passed the previous filters). Substitution will not be performed against
 *  fields whose value does not match this expression. If this field is NOT
 *  specified, then ALL fields matched by the target_json_path expression will
 *  undergo substitution. Note that an empty (e.g., "", rather than unspecified)
 *  value for for this field will only match empty fields.
 */
@property(nonatomic, copy, nullable) NSString *originalValuePattern;

/**
 *  (Filtering parameter) Any resource subject to substitution must belong to
 *  one of the listed "types". If this field is not provided, no type filtering
 *  will be performed (all resources of all types matching previous filtering
 *  parameters will be candidates for substitution).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBackupforGKE_GroupKind *> *targetGroupKinds;

/**
 *  Required. This is a [JSONPath]
 *  (https://kubernetes.io/docs/reference/kubectl/jsonpath/) expression that
 *  matches specific fields of candidate resources and it operates as both a
 *  filtering parameter (resources that are not matched with this expression
 *  will not be candidates for substitution) as well as a field identifier
 *  (identifies exactly which fields out of the candidate resources will be
 *  modified).
 */
@property(nonatomic, copy, nullable) NSString *targetJsonPath;

/**
 *  (Filtering parameter) Any resource subject to substitution must be contained
 *  within one of the listed Kubernetes Namespace in the Backup. If this field
 *  is not provided, no namespace filtering will be performed (all resources in
 *  all Namespaces, including all cluster-scoped resources, will be candidates
 *  for substitution). To mix cluster-scoped and namespaced resources in the
 *  same rule, use an empty string ("") as one of the target namespaces.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *targetNamespaces;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRBackupforGKE_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRBackupforGKE_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Represents the backup of a specific persistent volume as a component of a
 *  Backup - both the record of the operation and a pointer to the underlying
 *  storage-specific artifacts. Next id: 14
 */
@interface GTLRBackupforGKE_VolumeBackup : GTLRObject

/**
 *  Output only. The timestamp when the associated underlying volume backup
 *  operation completed.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *completeTime;

/** Output only. The timestamp when this VolumeBackup resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The minimum size of the disk to which this VolumeBackup can be
 *  restored.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskSizeBytes;

/**
 *  Output only. `etag` is used for optimistic concurrency control as a way to
 *  help prevent simultaneous updates of a volume backup from overwriting each
 *  other. It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform volume backup updates in order to avoid
 *  race conditions.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. The format used for the volume backup.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_Format_GcePersistentDisk Compute
 *        Engine Persistent Disk snapshot based volume backup. (Value:
 *        "GCE_PERSISTENT_DISK")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_Format_VolumeBackupFormatUnspecified
 *        Default value, not specified. (Value:
 *        "VOLUME_BACKUP_FORMAT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *format;

/**
 *  Output only. The full name of the VolumeBackup resource. Format: `projects/
 *  * /locations/ * /backupPlans/ * /backups/ * /volumeBackups/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. A reference to the source Kubernetes PVC from which this
 *  VolumeBackup was created.
 */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_NamespacedName *sourcePvc;

/**
 *  Output only. The current state of this VolumeBackup.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_Creating A volume for the
 *        backup was identified and backup process is about to start. (Value:
 *        "CREATING")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_Deleting This VolumeBackup
 *        resource (and its associated artifacts) is in the process of being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_Failed The volume backup
 *        operation has failed. (Value: "FAILED")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_Snapshotting The volume
 *        backup operation has begun and is in the initial "snapshot" phase of
 *        the process. Any defined ProtectedApplication "pre" hooks will be
 *        executed before entering this state and "post" hooks will be executed
 *        upon leaving this state. (Value: "SNAPSHOTTING")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_StateUnspecified This is an
 *        illegal state and should not be encountered. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_Succeeded The volume backup
 *        operation has completed successfully. (Value: "SUCCEEDED")
 *    @arg @c kGTLRBackupforGKE_VolumeBackup_State_Uploading The snapshot phase
 *        of the volume backup operation has completed and the snapshot is now
 *        being uploaded to backup storage. (Value: "UPLOADING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. A human readable message explaining why the VolumeBackup is in
 *  its current state.
 */
@property(nonatomic, copy, nullable) NSString *stateMessage;

/**
 *  Output only. The aggregate size of the underlying artifacts associated with
 *  this VolumeBackup in the backup storage. This may change over time when
 *  multiple backups of the same volume share the same backup storage location.
 *  In particular, this is likely to increase in size when the immediately
 *  preceding backup of the same volume is deleted.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *storageBytes;

/**
 *  Output only. Server generated global unique identifier of
 *  [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The timestamp when this VolumeBackup resource was last updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Output only. A storage system-specific opaque handle to the underlying
 *  volume backup.
 */
@property(nonatomic, copy, nullable) NSString *volumeBackupHandle;

@end


/**
 *  Represents the operation of restoring a volume from a VolumeBackup. Next id:
 *  13
 */
@interface GTLRBackupforGKE_VolumeRestore : GTLRObject

/**
 *  Output only. The timestamp when the associated underlying volume restoration
 *  completed.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *completeTime;

/**
 *  Output only. The timestamp when this VolumeRestore resource was created.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. `etag` is used for optimistic concurrency control as a way to
 *  help prevent simultaneous updates of a volume restore from overwriting each
 *  other. It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform volume restore updates in order to avoid
 *  race conditions.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Output only. Full name of the VolumeRestore resource. Format: `projects/ *
 *  /locations/ * /restorePlans/ * /restores/ * /volumeRestores/ *`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current state of this VolumeRestore.
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_State_Creating A volume for the
 *        restore was identified and restore process is about to start. (Value:
 *        "CREATING")
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_State_Deleting This VolumeRestore
 *        resource is in the process of being deleted. (Value: "DELETING")
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_State_Failed The volume
 *        restoration process failed. (Value: "FAILED")
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_State_Restoring The volume is
 *        currently being restored. (Value: "RESTORING")
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_State_StateUnspecified This is an
 *        illegal state and should not be encountered. (Value:
 *        "STATE_UNSPECIFIED")
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_State_Succeeded The volume has
 *        been successfully restored. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. A human readable message explaining why the VolumeRestore is in
 *  its current state.
 */
@property(nonatomic, copy, nullable) NSString *stateMessage;

/** Output only. The reference to the target Kubernetes PVC to be restored. */
@property(nonatomic, strong, nullable) GTLRBackupforGKE_NamespacedName *targetPvc;

/**
 *  Output only. Server generated global unique identifier of
 *  [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/**
 *  Output only. The timestamp when this VolumeRestore resource was last
 *  updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Output only. The full name of the VolumeBackup from which the volume will be
 *  restored. Format: `projects/ * /locations/ * /backupPlans/ * /backups/ *
 *  /volumeBackups/ *`.
 */
@property(nonatomic, copy, nullable) NSString *volumeBackup;

/**
 *  Output only. A storage system-specific opaque handler to the underlying
 *  volume created for the target PVC from the volume backup.
 */
@property(nonatomic, copy, nullable) NSString *volumeHandle;

/**
 *  Output only. The type of volume provisioned
 *
 *  Likely values:
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_VolumeType_GcePersistentDisk
 *        Compute Engine Persistent Disk volume (Value: "GCE_PERSISTENT_DISK")
 *    @arg @c kGTLRBackupforGKE_VolumeRestore_VolumeType_VolumeTypeUnspecified
 *        Default (Value: "VOLUME_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *volumeType;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
