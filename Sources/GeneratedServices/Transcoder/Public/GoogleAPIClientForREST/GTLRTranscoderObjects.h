// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Transcoder API (transcoder/v1)
// Description:
//   This API converts video files into formats suitable for consumer
//   distribution. For more information, see the Transcoder API overview.
// Documentation:
//   https://cloud.google.com/transcoder/docs/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRTranscoder_AdBreak;
@class GTLRTranscoder_Aes128Encryption;
@class GTLRTranscoder_Animation;
@class GTLRTranscoder_AnimationEnd;
@class GTLRTranscoder_AnimationFade;
@class GTLRTranscoder_AnimationStatic;
@class GTLRTranscoder_Audio;
@class GTLRTranscoder_AudioMapping;
@class GTLRTranscoder_AudioStream;
@class GTLRTranscoder_BwdifConfig;
@class GTLRTranscoder_Clearkey;
@class GTLRTranscoder_Color;
@class GTLRTranscoder_Crop;
@class GTLRTranscoder_DashConfig;
@class GTLRTranscoder_Deblock;
@class GTLRTranscoder_Deinterlace;
@class GTLRTranscoder_Denoise;
@class GTLRTranscoder_DrmSystems;
@class GTLRTranscoder_EditAtom;
@class GTLRTranscoder_ElementaryStream;
@class GTLRTranscoder_Encryption;
@class GTLRTranscoder_Fairplay;
@class GTLRTranscoder_Fmp4Config;
@class GTLRTranscoder_H264CodecSettings;
@class GTLRTranscoder_H264ColorFormatHLG;
@class GTLRTranscoder_H264ColorFormatSDR;
@class GTLRTranscoder_H265CodecSettings;
@class GTLRTranscoder_H265ColorFormatHDR10;
@class GTLRTranscoder_H265ColorFormatHLG;
@class GTLRTranscoder_H265ColorFormatSDR;
@class GTLRTranscoder_Image;
@class GTLRTranscoder_Input;
@class GTLRTranscoder_InputAttributes;
@class GTLRTranscoder_Job;
@class GTLRTranscoder_Job_Labels;
@class GTLRTranscoder_JobConfig;
@class GTLRTranscoder_JobTemplate;
@class GTLRTranscoder_JobTemplate_Labels;
@class GTLRTranscoder_Manifest;
@class GTLRTranscoder_MpegCommonEncryption;
@class GTLRTranscoder_MuxStream;
@class GTLRTranscoder_NormalizedCoordinate;
@class GTLRTranscoder_Output;
@class GTLRTranscoder_Overlay;
@class GTLRTranscoder_Pad;
@class GTLRTranscoder_Playready;
@class GTLRTranscoder_PreprocessingConfig;
@class GTLRTranscoder_PubsubDestination;
@class GTLRTranscoder_SampleAesEncryption;
@class GTLRTranscoder_SecretManagerSource;
@class GTLRTranscoder_SegmentSettings;
@class GTLRTranscoder_SpriteSheet;
@class GTLRTranscoder_Status;
@class GTLRTranscoder_Status_Details_Item;
@class GTLRTranscoder_TextMapping;
@class GTLRTranscoder_TextStream;
@class GTLRTranscoder_TrackDefinition;
@class GTLRTranscoder_VideoStream;
@class GTLRTranscoder_Vp9CodecSettings;
@class GTLRTranscoder_Vp9ColorFormatHLG;
@class GTLRTranscoder_Vp9ColorFormatSDR;
@class GTLRTranscoder_Widevine;
@class GTLRTranscoder_YadifConfig;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRTranscoder_AnimationFade.fadeType

/**
 *  Fade the overlay object into view.
 *
 *  Value: "FADE_IN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_AnimationFade_FadeType_FadeIn;
/**
 *  Fade the overlay object out of view.
 *
 *  Value: "FADE_OUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_AnimationFade_FadeType_FadeOut;
/**
 *  The fade type is not specified.
 *
 *  Value: "FADE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_AnimationFade_FadeType_FadeTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_DashConfig.segmentReferenceScheme

/**
 *  Explicitly lists the URLs of media files for each segment. For example, if
 *  SegmentSettings.individual_segments is `true`, then the manifest contains
 *  fields similar to the following: ```xml ... ```
 *
 *  Value: "SEGMENT_LIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_DashConfig_SegmentReferenceScheme_SegmentList;
/**
 *  The segment reference scheme is not specified.
 *
 *  Value: "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_DashConfig_SegmentReferenceScheme_SegmentReferenceSchemeUnspecified;
/**
 *  SegmentSettings.individual_segments must be set to `true` to use this
 *  segment reference scheme. Uses the DASH specification `` tag to determine
 *  the URLs of media files for each segment. For example: ```xml ... ```
 *
 *  Value: "SEGMENT_TEMPLATE_NUMBER"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_DashConfig_SegmentReferenceScheme_SegmentTemplateNumber;

// ----------------------------------------------------------------------------
// GTLRTranscoder_H264CodecSettings.frameRateConversionStrategy

/**
 *  Selectively retain frames to reduce the output frame rate. Every _n_ th
 *  frame is kept, where `n = ceil(input frame rate / target frame rate)`. When
 *  _n_ = 1 (that is, the target frame rate is greater than the input frame
 *  rate), the output frame rate matches the input frame rate. When _n_ > 1,
 *  frames are dropped and the output frame rate is equal to `(input frame rate
 *  / n)`. For more information, see [Calculate frame
 *  rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate).
 *
 *  Value: "DOWNSAMPLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_H264CodecSettings_FrameRateConversionStrategy_Downsample;
/**
 *  Drop or duplicate frames to match the specified frame rate.
 *
 *  Value: "DROP_DUPLICATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_H264CodecSettings_FrameRateConversionStrategy_DropDuplicate;
/**
 *  Unspecified frame rate conversion strategy.
 *
 *  Value: "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_H264CodecSettings_FrameRateConversionStrategy_FrameRateConversionStrategyUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_H265CodecSettings.frameRateConversionStrategy

/**
 *  Selectively retain frames to reduce the output frame rate. Every _n_ th
 *  frame is kept, where `n = ceil(input frame rate / target frame rate)`. When
 *  _n_ = 1 (that is, the target frame rate is greater than the input frame
 *  rate), the output frame rate matches the input frame rate. When _n_ > 1,
 *  frames are dropped and the output frame rate is equal to `(input frame rate
 *  / n)`. For more information, see [Calculate frame
 *  rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate).
 *
 *  Value: "DOWNSAMPLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_H265CodecSettings_FrameRateConversionStrategy_Downsample;
/**
 *  Drop or duplicate frames to match the specified frame rate.
 *
 *  Value: "DROP_DUPLICATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_H265CodecSettings_FrameRateConversionStrategy_DropDuplicate;
/**
 *  Unspecified frame rate conversion strategy.
 *
 *  Value: "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_H265CodecSettings_FrameRateConversionStrategy_FrameRateConversionStrategyUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Job.mode

/**
 *  The job processing mode is batch mode. Batch mode allows queuing of jobs.
 *
 *  Value: "PROCESSING_MODE_BATCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_Mode_ProcessingModeBatch;
/**
 *  The job processing mode is interactive mode. Interactive job will either be
 *  ran or rejected if quota does not allow for it.
 *
 *  Value: "PROCESSING_MODE_INTERACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_Mode_ProcessingModeInteractive;
/**
 *  The job processing mode is not specified.
 *
 *  Value: "PROCESSING_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_Mode_ProcessingModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Job.optimization

/**
 *  Prioritize job processing speed.
 *
 *  Value: "AUTODETECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_Optimization_Autodetect;
/**
 *  Disable all optimizations.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_Optimization_Disabled;
/**
 *  The optimization strategy is not specified.
 *
 *  Value: "OPTIMIZATION_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_Optimization_OptimizationStrategyUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Job.state

/**
 *  The job has failed. For additional information, see
 *  [Troubleshooting](https://cloud.google.com/transcoder/docs/troubleshooting).
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Failed;
/**
 *  The job is enqueued and will be picked up for processing soon.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Pending;
/**
 *  The processing state is not specified.
 *
 *  Value: "PROCESSING_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_ProcessingStateUnspecified;
/**
 *  The job is being processed.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Running;
/**
 *  The job has been completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Manifest.type

/**
 *  Create an MPEG-DASH manifest. The corresponding file extension is `.mpd`.
 *
 *  Value: "DASH"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Manifest_Type_Dash;
/**
 *  Create an HLS manifest. The corresponding file extension is `.m3u8`.
 *
 *  Value: "HLS"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Manifest_Type_Hls;
/**
 *  The manifest type is not specified.
 *
 *  Value: "MANIFEST_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Manifest_Type_ManifestTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Vp9CodecSettings.frameRateConversionStrategy

/**
 *  Selectively retain frames to reduce the output frame rate. Every _n_ th
 *  frame is kept, where `n = ceil(input frame rate / target frame rate)`. When
 *  _n_ = 1 (that is, the target frame rate is greater than the input frame
 *  rate), the output frame rate matches the input frame rate. When _n_ > 1,
 *  frames are dropped and the output frame rate is equal to `(input frame rate
 *  / n)`. For more information, see [Calculate frame
 *  rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate).
 *
 *  Value: "DOWNSAMPLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Vp9CodecSettings_FrameRateConversionStrategy_Downsample;
/**
 *  Drop or duplicate frames to match the specified frame rate.
 *
 *  Value: "DROP_DUPLICATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Vp9CodecSettings_FrameRateConversionStrategy_DropDuplicate;
/**
 *  Unspecified frame rate conversion strategy.
 *
 *  Value: "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Vp9CodecSettings_FrameRateConversionStrategy_FrameRateConversionStrategyUnspecified;

/**
 *  Ad break.
 */
@interface GTLRTranscoder_AdBreak : GTLRObject

/**
 *  Start time in seconds for the ad break, relative to the output file
 *  timeline. The default is `0s`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

@end


/**
 *  Configuration for AES-128 encryption.
 */
@interface GTLRTranscoder_Aes128Encryption : GTLRObject
@end


/**
 *  Animation types.
 */
@interface GTLRTranscoder_Animation : GTLRObject

/** End previous animation. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AnimationEnd *animationEnd;

/** Display overlay object with fade animation. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AnimationFade *animationFade;

/** Display static overlay object. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AnimationStatic *animationStatic;

@end


/**
 *  End previous overlay animation from the video. Without `AnimationEnd`, the
 *  overlay object will keep the state of previous animation until the end of
 *  the video.
 */
@interface GTLRTranscoder_AnimationEnd : GTLRObject

/** The time to end overlay object, in seconds. Default: 0 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

@end


/**
 *  Display overlay object with fade animation.
 */
@interface GTLRTranscoder_AnimationFade : GTLRObject

/**
 *  The time to end the fade animation, in seconds. Default: `start_time_offset`
 *  + 1s
 */
@property(nonatomic, strong, nullable) GTLRDuration *endTimeOffset;

/**
 *  Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_AnimationFade_FadeType_FadeIn Fade the overlay
 *        object into view. (Value: "FADE_IN")
 *    @arg @c kGTLRTranscoder_AnimationFade_FadeType_FadeOut Fade the overlay
 *        object out of view. (Value: "FADE_OUT")
 *    @arg @c kGTLRTranscoder_AnimationFade_FadeType_FadeTypeUnspecified The
 *        fade type is not specified. (Value: "FADE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *fadeType;

/** The time to start the fade animation, in seconds. Default: 0 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

/**
 *  Normalized coordinates based on output video resolution. Valid values:
 *  `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay object. For
 *  example, use the x and y coordinates {0,0} to position the top-left corner
 *  of the overlay animation in the top-left corner of the output video.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_NormalizedCoordinate *xy;

@end


/**
 *  Display static overlay object.
 */
@interface GTLRTranscoder_AnimationStatic : GTLRObject

/** The time to start displaying the overlay object, in seconds. Default: 0 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

/**
 *  Normalized coordinates based on output video resolution. Valid values:
 *  `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay object. For
 *  example, use the x and y coordinates {0,0} to position the top-left corner
 *  of the overlay animation in the top-left corner of the output video.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_NormalizedCoordinate *xy;

@end


/**
 *  Audio preprocessing configuration.
 */
@interface GTLRTranscoder_Audio : GTLRObject

/**
 *  Enable boosting high frequency components. The default is `false`. **Note:**
 *  This field is not supported.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *highBoost;

/**
 *  Enable boosting low frequency components. The default is `false`. **Note:**
 *  This field is not supported.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lowBoost;

/**
 *  Specify audio loudness normalization in loudness units relative to full
 *  scale (LUFS). Enter a value between -24 and 0 (the default), where: * -24 is
 *  the Advanced Television Systems Committee (ATSC A/85) standard * -23 is the
 *  EU R128 broadcast standard * -19 is the prior standard for online mono audio
 *  * -18 is the ReplayGain standard * -16 is the prior standard for stereo
 *  audio * -14 is the new online audio standard recommended by Spotify, as well
 *  as Amazon Echo * 0 disables normalization
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lufs;

@end


/**
 *  The mapping for the JobConfig.edit_list atoms with audio EditAtom.inputs.
 */
@interface GTLRTranscoder_AudioMapping : GTLRObject

/**
 *  Required. The EditAtom.key that references the atom with audio inputs in the
 *  JobConfig.edit_list.
 */
@property(nonatomic, copy, nullable) NSString *atomKey;

/**
 *  Audio volume control in dB. Negative values decrease volume, positive values
 *  increase. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gainDb;

/**
 *  Required. The zero-based index of the channel in the input audio stream.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputChannel;

/** Required. The Input.key that identifies the input file. */
@property(nonatomic, copy, nullable) NSString *inputKey;

/**
 *  Required. The zero-based index of the track in the input file.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputTrack;

/**
 *  Required. The zero-based index of the channel in the output audio stream.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outputChannel;

@end


/**
 *  Audio stream resource.
 */
@interface GTLRTranscoder_AudioStream : GTLRObject

/**
 *  Required. Audio bitrate in bits per second. Must be between 1 and
 *  10,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Number of audio channels. Must be between 1 and 6. The default is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *channelCount;

/**
 *  A list of channel names specifying layout of the audio channels. This only
 *  affects the metadata embedded in the container headers, if supported by the
 *  specified format. The default is `["fl", "fr"]`. Supported channel names: -
 *  `fl` - Front left channel - `fr` - Front right channel - `sl` - Side left
 *  channel - `sr` - Side right channel - `fc` - Front center channel - `lfe` -
 *  Low frequency
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *channelLayout;

/**
 *  The codec for this audio stream. The default is `aac`. Supported audio
 *  codecs: - `aac` - `aac-he` - `aac-he-v2` - `mp3` - `ac3` - `eac3` - `vorbis`
 */
@property(nonatomic, copy, nullable) NSString *codec;

/**
 *  The name for this particular audio stream that will be added to the HLS/DASH
 *  manifest. Not supported in MP4 files.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The BCP-47 language code, such as `en-US` or `sr-Latn`. For more
 *  information, see
 *  https://www.unicode.org/reports/tr35/#Unicode_locale_identifier. Not
 *  supported in MP4 files.
 */
@property(nonatomic, copy, nullable) NSString *languageCode;

/**
 *  The mapping for the JobConfig.edit_list atoms with audio EditAtom.inputs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_AudioMapping *> *mapping;

/**
 *  The audio sample rate in Hertz. The default is 48000 Hertz.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sampleRateHertz;

@end


/**
 *  Bob Weaver Deinterlacing Filter Configuration.
 */
@interface GTLRTranscoder_BwdifConfig : GTLRObject

/**
 *  Deinterlace all frames rather than just the frames identified as interlaced.
 *  The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deinterlaceAllFrames;

/**
 *  Specifies the deinterlacing mode to adopt. The default is `send_frame`.
 *  Supported values: - `send_frame`: Output one frame for each frame -
 *  `send_field`: Output one frame for each field
 */
@property(nonatomic, copy, nullable) NSString *mode;

/**
 *  The picture field parity assumed for the input interlaced video. The default
 *  is `auto`. Supported values: - `tff`: Assume the top field is first - `bff`:
 *  Assume the bottom field is first - `auto`: Enable automatic detection of
 *  field parity
 */
@property(nonatomic, copy, nullable) NSString *parity;

@end


/**
 *  Clearkey configuration.
 */
@interface GTLRTranscoder_Clearkey : GTLRObject
@end


/**
 *  Color preprocessing configuration. **Note:** This configuration is not
 *  supported.
 */
@interface GTLRTranscoder_Color : GTLRObject

/**
 *  Control brightness of the video. Enter a value between -1 and 1, where -1 is
 *  minimum brightness and 1 is maximum brightness. 0 is no change. The default
 *  is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *brightness;

/**
 *  Control black and white contrast of the video. Enter a value between -1 and
 *  1, where -1 is minimum contrast and 1 is maximum contrast. 0 is no change.
 *  The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *contrast;

/**
 *  Control color saturation of the video. Enter a value between -1 and 1, where
 *  -1 is fully desaturated and 1 is maximum saturation. 0 is no change. The
 *  default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *saturation;

@end


/**
 *  Video cropping configuration for the input video. The cropped input video is
 *  scaled to match the output resolution.
 */
@interface GTLRTranscoder_Crop : GTLRObject

/**
 *  The number of pixels to crop from the bottom. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bottomPixels;

/**
 *  The number of pixels to crop from the left. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *leftPixels;

/**
 *  The number of pixels to crop from the right. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rightPixels;

/**
 *  The number of pixels to crop from the top. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *topPixels;

@end


/**
 *  `DASH` manifest configuration.
 */
@interface GTLRTranscoder_DashConfig : GTLRObject

/**
 *  The segment reference scheme for a `DASH` manifest. The default is
 *  `SEGMENT_LIST`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_DashConfig_SegmentReferenceScheme_SegmentList
 *        Explicitly lists the URLs of media files for each segment. For
 *        example, if SegmentSettings.individual_segments is `true`, then the
 *        manifest contains fields similar to the following: ```xml ... ```
 *        (Value: "SEGMENT_LIST")
 *    @arg @c kGTLRTranscoder_DashConfig_SegmentReferenceScheme_SegmentReferenceSchemeUnspecified
 *        The segment reference scheme is not specified. (Value:
 *        "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED")
 *    @arg @c kGTLRTranscoder_DashConfig_SegmentReferenceScheme_SegmentTemplateNumber
 *        SegmentSettings.individual_segments must be set to `true` to use this
 *        segment reference scheme. Uses the DASH specification `` tag to
 *        determine the URLs of media files for each segment. For example:
 *        ```xml ... ``` (Value: "SEGMENT_TEMPLATE_NUMBER")
 */
@property(nonatomic, copy, nullable) NSString *segmentReferenceScheme;

@end


/**
 *  Deblock preprocessing configuration. **Note:** This configuration is not
 *  supported.
 */
@interface GTLRTranscoder_Deblock : GTLRObject

/**
 *  Enable deblocker. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Set strength of the deblocker. Enter a value between 0 and 1. The higher the
 *  value, the stronger the block removal. 0 is no deblocking. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strength;

@end


/**
 *  Deinterlace configuration for input video.
 */
@interface GTLRTranscoder_Deinterlace : GTLRObject

/** Specifies the Bob Weaver Deinterlacing Filter Configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_BwdifConfig *bwdif;

/** Specifies the Yet Another Deinterlacing Filter Configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_YadifConfig *yadif;

@end


/**
 *  Denoise preprocessing configuration. **Note:** This configuration is not
 *  supported.
 */
@interface GTLRTranscoder_Denoise : GTLRObject

/**
 *  Set strength of the denoise. Enter a value between 0 and 1. The higher the
 *  value, the smoother the image. 0 is no denoising. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strength;

/**
 *  Set the denoiser mode. The default is `standard`. Supported denoiser modes:
 *  - `standard` - `grain`
 */
@property(nonatomic, copy, nullable) NSString *tune;

@end


/**
 *  Defines configuration for DRM systems in use.
 */
@interface GTLRTranscoder_DrmSystems : GTLRObject

/** Clearkey configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Clearkey *clearkey;

/** Fairplay configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Fairplay *fairplay;

/** Playready configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Playready *playready;

/** Widevine configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Widevine *widevine;

@end


/**
 *  Edit atom.
 */
@interface GTLRTranscoder_EditAtom : GTLRObject

/**
 *  End time in seconds for the atom, relative to the input file timeline. When
 *  `end_time_offset` is not specified, the `inputs` are used until the end of
 *  the atom.
 */
@property(nonatomic, strong, nullable) GTLRDuration *endTimeOffset;

/**
 *  List of Input.key values identifying files that should be used in this atom.
 *  The listed `inputs` must have the same timeline.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *inputs;

/**
 *  A unique key for this atom. Must be specified when using advanced mapping.
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Start time in seconds for the atom, relative to the input file timeline. The
 *  default is `0s`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

@end


/**
 *  Encoding of an input file such as an audio, video, or text track. Elementary
 *  streams must be packaged before mapping and sharing between different output
 *  formats.
 */
@interface GTLRTranscoder_ElementaryStream : GTLRObject

/** Encoding of an audio stream. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AudioStream *audioStream;

/** A unique key for this elementary stream. */
@property(nonatomic, copy, nullable) NSString *key;

/** Encoding of a text stream. For example, closed captions or subtitles. */
@property(nonatomic, strong, nullable) GTLRTranscoder_TextStream *textStream;

/** Encoding of a video stream. */
@property(nonatomic, strong, nullable) GTLRTranscoder_VideoStream *videoStream;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRTranscoder_Empty : GTLRObject
@end


/**
 *  Encryption settings.
 */
@interface GTLRTranscoder_Encryption : GTLRObject

/** Configuration for AES-128 encryption. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Aes128Encryption *aes128;

/**
 *  Required. DRM system(s) to use; at least one must be specified. If a DRM
 *  system is omitted, it is considered disabled.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_DrmSystems *drmSystems;

/**
 *  Required. Identifier for this set of encryption options.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Configuration for MPEG Common Encryption (MPEG-CENC). */
@property(nonatomic, strong, nullable) GTLRTranscoder_MpegCommonEncryption *mpegCenc;

/** Configuration for SAMPLE-AES encryption. */
@property(nonatomic, strong, nullable) GTLRTranscoder_SampleAesEncryption *sampleAes;

/** Keys are stored in Google Secret Manager. */
@property(nonatomic, strong, nullable) GTLRTranscoder_SecretManagerSource *secretManagerKeySource;

@end


/**
 *  Fairplay configuration.
 */
@interface GTLRTranscoder_Fairplay : GTLRObject
@end


/**
 *  `fmp4` container configuration.
 */
@interface GTLRTranscoder_Fmp4Config : GTLRObject

/**
 *  Optional. Specify the codec tag string that will be used in the media
 *  bitstream. When not specified, the codec appropriate value is used.
 *  Supported H265 codec tags: - `hvc1` (default) - `hev1`
 */
@property(nonatomic, copy, nullable) NSString *codecTag;

@end


/**
 *  H264 codec settings.
 */
@interface GTLRTranscoder_H264CodecSettings : GTLRObject

/**
 *  Specifies whether an open Group of Pictures (GOP) structure should be
 *  allowed or not. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowOpenGop;

/**
 *  Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and
 *  1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher
 *  value equals a lower bitrate but smoother image. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aqStrength;

/**
 *  The number of consecutive B-frames. Must be greater than or equal to zero.
 *  Must be less than H264CodecSettings.gop_frame_count if set. The default is
 *  0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bFrameCount;

/**
 *  Required. The video bitrate in bits per second. The minimum value is 1,000.
 *  The maximum value is 800,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Allow B-pyramid for reference frame selection. This may not be supported on
 *  all decoders. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bPyramid;

/**
 *  Target CRF level. Must be between 10 and 36, where 10 is the highest quality
 *  and 36 is the most efficient compression. The default is 21.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crfLevel;

/**
 *  Use two-pass encoding strategy to achieve better video quality.
 *  H264CodecSettings.rate_control_mode must be `vbr`. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableTwoPass;

/**
 *  The entropy coder to use. The default is `cabac`. Supported entropy coders:
 *  - `cavlc` - `cabac`
 */
@property(nonatomic, copy, nullable) NSString *entropyCoder;

/**
 *  Required. The target video frame rate in frames per second (FPS). Must be
 *  less than or equal to 120.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *frameRate;

/**
 *  Optional. Frame rate conversion strategy for desired frame rate. The default
 *  is `DOWNSAMPLE`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_H264CodecSettings_FrameRateConversionStrategy_Downsample
 *        Selectively retain frames to reduce the output frame rate. Every _n_
 *        th frame is kept, where `n = ceil(input frame rate / target frame
 *        rate)`. When _n_ = 1 (that is, the target frame rate is greater than
 *        the input frame rate), the output frame rate matches the input frame
 *        rate. When _n_ > 1, frames are dropped and the output frame rate is
 *        equal to `(input frame rate / n)`. For more information, see
 *        [Calculate frame
 *        rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate).
 *        (Value: "DOWNSAMPLE")
 *    @arg @c kGTLRTranscoder_H264CodecSettings_FrameRateConversionStrategy_DropDuplicate
 *        Drop or duplicate frames to match the specified frame rate. (Value:
 *        "DROP_DUPLICATE")
 *    @arg @c kGTLRTranscoder_H264CodecSettings_FrameRateConversionStrategy_FrameRateConversionStrategyUnspecified
 *        Unspecified frame rate conversion strategy. (Value:
 *        "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *frameRateConversionStrategy;

/**
 *  Select the GOP size based on the specified duration. The default is `3s`.
 *  Note that `gopDuration` must be less than or equal to
 *  [`segmentDuration`](#SegmentSettings), and
 *  [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *gopDuration;

/**
 *  Select the GOP size based on the specified frame count. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gopFrameCount;

/**
 *  The height of the video in pixels. Must be an even integer. When not
 *  specified, the height is adjusted to match the specified width and input
 *  aspect ratio. If both are omitted, the input height is used. For portrait
 *  videos that contain horizontal ASR and rotation metadata, provide the
 *  height, in pixels, per the horizontal ASR. The API calculates the width per
 *  the horizontal ASR. The API detects any rotation metadata and swaps the
 *  requested height and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *heightPixels;

/** Optional. HLG color format setting for H264. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H264ColorFormatHLG *hlg;

/**
 *  Pixel format to use. The default is `yuv420p`. Supported pixel formats: -
 *  `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format -
 *  `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format -
 *  `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format -
 *  `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 */
@property(nonatomic, copy, nullable) NSString *pixelFormat;

/**
 *  Enforces the specified codec preset. The default is `veryfast`. The
 *  available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Preset). Note
 *  that certain values for this field may cause the transcoder to override
 *  other fields you set in the `H264CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *preset;

/**
 *  Enforces the specified codec profile. The following profiles are supported:
 *  * `baseline` * `main` * `high` (default) The available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune). Note
 *  that certain values for this field may cause the transcoder to override
 *  other fields you set in the `H264CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *profile;

/**
 *  Specify the mode. The default is `vbr`. Supported rate control modes: -
 *  `vbr` - variable bitrate - `crf` - constant rate factor
 */
@property(nonatomic, copy, nullable) NSString *rateControlMode;

/** Optional. SDR color format setting for H264. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H264ColorFormatSDR *sdr;

/**
 *  Enforces the specified codec tune. The available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune). Note
 *  that certain values for this field may cause the transcoder to override
 *  other fields you set in the `H264CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *tune;

/**
 *  Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must
 *  be greater than zero. The default is equal to 90% of
 *  H264CodecSettings.vbv_size_bits.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvFullnessBits;

/**
 *  Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater
 *  than zero. The default is equal to H264CodecSettings.bitrate_bps.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvSizeBits;

/**
 *  The width of the video in pixels. Must be an even integer. When not
 *  specified, the width is adjusted to match the specified height and input
 *  aspect ratio. If both are omitted, the input width is used. For portrait
 *  videos that contain horizontal ASR and rotation metadata, provide the width,
 *  in pixels, per the horizontal ASR. The API calculates the height per the
 *  horizontal ASR. The API detects any rotation metadata and swaps the
 *  requested height and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *widthPixels;

@end


/**
 *  Convert the input video to a Hybrid Log Gamma (HLG) video.
 */
@interface GTLRTranscoder_H264ColorFormatHLG : GTLRObject
@end


/**
 *  Convert the input video to a Standard Dynamic Range (SDR) video.
 */
@interface GTLRTranscoder_H264ColorFormatSDR : GTLRObject
@end


/**
 *  H265 codec settings.
 */
@interface GTLRTranscoder_H265CodecSettings : GTLRObject

/**
 *  Specifies whether an open Group of Pictures (GOP) structure should be
 *  allowed or not. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowOpenGop;

/**
 *  Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and
 *  1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher
 *  value equals a lower bitrate but smoother image. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aqStrength;

/**
 *  The number of consecutive B-frames. Must be greater than or equal to zero.
 *  Must be less than H265CodecSettings.gop_frame_count if set. The default is
 *  0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bFrameCount;

/**
 *  Required. The video bitrate in bits per second. The minimum value is 1,000.
 *  The maximum value is 800,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Allow B-pyramid for reference frame selection. This may not be supported on
 *  all decoders. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bPyramid;

/**
 *  Target CRF level. Must be between 10 and 36, where 10 is the highest quality
 *  and 36 is the most efficient compression. The default is 21.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crfLevel;

/**
 *  Use two-pass encoding strategy to achieve better video quality.
 *  H265CodecSettings.rate_control_mode must be `vbr`. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableTwoPass;

/**
 *  Required. The target video frame rate in frames per second (FPS). Must be
 *  less than or equal to 120.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *frameRate;

/**
 *  Optional. Frame rate conversion strategy for desired frame rate. The default
 *  is `DOWNSAMPLE`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_H265CodecSettings_FrameRateConversionStrategy_Downsample
 *        Selectively retain frames to reduce the output frame rate. Every _n_
 *        th frame is kept, where `n = ceil(input frame rate / target frame
 *        rate)`. When _n_ = 1 (that is, the target frame rate is greater than
 *        the input frame rate), the output frame rate matches the input frame
 *        rate. When _n_ > 1, frames are dropped and the output frame rate is
 *        equal to `(input frame rate / n)`. For more information, see
 *        [Calculate frame
 *        rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate).
 *        (Value: "DOWNSAMPLE")
 *    @arg @c kGTLRTranscoder_H265CodecSettings_FrameRateConversionStrategy_DropDuplicate
 *        Drop or duplicate frames to match the specified frame rate. (Value:
 *        "DROP_DUPLICATE")
 *    @arg @c kGTLRTranscoder_H265CodecSettings_FrameRateConversionStrategy_FrameRateConversionStrategyUnspecified
 *        Unspecified frame rate conversion strategy. (Value:
 *        "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *frameRateConversionStrategy;

/**
 *  Select the GOP size based on the specified duration. The default is `3s`.
 *  Note that `gopDuration` must be less than or equal to
 *  [`segmentDuration`](#SegmentSettings), and
 *  [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *gopDuration;

/**
 *  Select the GOP size based on the specified frame count. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gopFrameCount;

/** Optional. HDR10 color format setting for H265. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H265ColorFormatHDR10 *hdr10;

/**
 *  The height of the video in pixels. Must be an even integer. When not
 *  specified, the height is adjusted to match the specified width and input
 *  aspect ratio. If both are omitted, the input height is used. For portrait
 *  videos that contain horizontal ASR and rotation metadata, provide the
 *  height, in pixels, per the horizontal ASR. The API calculates the width per
 *  the horizontal ASR. The API detects any rotation metadata and swaps the
 *  requested height and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *heightPixels;

/** Optional. HLG color format setting for H265. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H265ColorFormatHLG *hlg;

/**
 *  Pixel format to use. The default is `yuv420p`. Supported pixel formats: -
 *  `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format -
 *  `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format -
 *  `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format -
 *  `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 */
@property(nonatomic, copy, nullable) NSString *pixelFormat;

/**
 *  Enforces the specified codec preset. The default is `veryfast`. The
 *  available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265). Note that
 *  certain values for this field may cause the transcoder to override other
 *  fields you set in the `H265CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *preset;

/**
 *  Enforces the specified codec profile. The following profiles are supported:
 *  * 8-bit profiles * `main` (default) * `main-intra` * `mainstillpicture` *
 *  10-bit profiles * `main10` (default) * `main10-intra` * `main422-10` *
 *  `main422-10-intra` * `main444-10` * `main444-10-intra` * 12-bit profiles *
 *  `main12` (default) * `main12-intra` * `main422-12` * `main422-12-intra` *
 *  `main444-12` * `main444-12-intra` The available options are
 *  [FFmpeg-compatible](https://x265.readthedocs.io/). Note that certain values
 *  for this field may cause the transcoder to override other fields you set in
 *  the `H265CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *profile;

/**
 *  Specify the mode. The default is `vbr`. Supported rate control modes: -
 *  `vbr` - variable bitrate - `crf` - constant rate factor
 */
@property(nonatomic, copy, nullable) NSString *rateControlMode;

/** Optional. SDR color format setting for H265. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H265ColorFormatSDR *sdr;

/**
 *  Enforces the specified codec tune. The available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265). Note that
 *  certain values for this field may cause the transcoder to override other
 *  fields you set in the `H265CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *tune;

/**
 *  Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must
 *  be greater than zero. The default is equal to 90% of
 *  H265CodecSettings.vbv_size_bits.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvFullnessBits;

/**
 *  Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater
 *  than zero. The default is equal to `VideoStream.bitrate_bps`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvSizeBits;

/**
 *  The width of the video in pixels. Must be an even integer. When not
 *  specified, the width is adjusted to match the specified height and input
 *  aspect ratio. If both are omitted, the input width is used. For portrait
 *  videos that contain horizontal ASR and rotation metadata, provide the width,
 *  in pixels, per the horizontal ASR. The API calculates the height per the
 *  horizontal ASR. The API detects any rotation metadata and swaps the
 *  requested height and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *widthPixels;

@end


/**
 *  Convert the input video to a High Dynamic Range 10 (HDR10) video.
 */
@interface GTLRTranscoder_H265ColorFormatHDR10 : GTLRObject
@end


/**
 *  Convert the input video to a Hybrid Log Gamma (HLG) video.
 */
@interface GTLRTranscoder_H265ColorFormatHLG : GTLRObject
@end


/**
 *  Convert the input video to a Standard Dynamic Range (SDR) video.
 */
@interface GTLRTranscoder_H265ColorFormatSDR : GTLRObject
@end


/**
 *  Overlaid image.
 */
@interface GTLRTranscoder_Image : GTLRObject

/**
 *  Target image opacity. Valid values are from `1.0` (solid, default) to `0.0`
 *  (transparent), exclusive. Set this to a value greater than `0.0`.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *alpha;

/**
 *  Normalized image resolution, based on output video resolution. Valid values:
 *  `0.0`–`1.0`. To respect the original image aspect ratio, set either `x` or
 *  `y` to `0.0`. To use the original image resolution, set both `x` and `y` to
 *  `0.0`.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_NormalizedCoordinate *resolution;

/**
 *  Required. URI of the image in Cloud Storage. For example,
 *  `gs://bucket/inputs/image.png`. Only PNG and JPEG images are supported.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Input asset.
 */
@interface GTLRTranscoder_Input : GTLRObject

/** Optional. Input Attributes. */
@property(nonatomic, strong, nullable) GTLRTranscoder_InputAttributes *attributes;

/**
 *  A unique key for this input. Must be specified when using advanced mapping
 *  and edit lists.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** Preprocessing configurations. */
@property(nonatomic, strong, nullable) GTLRTranscoder_PreprocessingConfig *preprocessingConfig;

/**
 *  URI of the media. Input files must be at least 5 seconds in duration and
 *  stored in Cloud Storage (for example, `gs://bucket/inputs/file.mp4`). If
 *  empty, the value is populated from Job.input_uri. See [Supported input and
 *  output
 *  formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Input attributes that provide additional information about the input asset.
 */
@interface GTLRTranscoder_InputAttributes : GTLRObject

/** Optional. A list of track definitions for the input asset. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_TrackDefinition *> *trackDefinitions;

@end


/**
 *  Transcoding job resource.
 */
@interface GTLRTranscoder_Job : GTLRObject

/**
 *  The processing priority of a batch job. This field can only be set for batch
 *  mode jobs. The default value is 0. This value cannot be negative. Higher
 *  values correspond to higher priorities for the job.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batchModePriority;

/** The configuration for this job. */
@property(nonatomic, strong, nullable) GTLRTranscoder_JobConfig *config;

/** Output only. The time the job was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the transcoding finished. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. An error object that describes the reason for the failure. This
 *  property is always present when ProcessingState is `FAILED`.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_Status *error;

/**
 *  Optional. Insert silence and duplicate frames when timestamp gaps are
 *  detected in a given stream.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fillContentGaps;

/**
 *  Input only. Specify the `input_uri` to populate empty `uri` fields in each
 *  element of `Job.config.inputs` or `JobTemplate.config.inputs` when using
 *  template. URI of the media. Input files must be at least 5 seconds in
 *  duration and stored in Cloud Storage (for example,
 *  `gs://bucket/inputs/file.mp4`). See [Supported input and output
 *  formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
 */
@property(nonatomic, copy, nullable) NSString *inputUri;

/**
 *  The labels associated with this job. You can use these to organize and group
 *  your jobs.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_Job_Labels *labels;

/**
 *  The processing mode of the job. The default is
 *  `PROCESSING_MODE_INTERACTIVE`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Job_Mode_ProcessingModeBatch The job processing
 *        mode is batch mode. Batch mode allows queuing of jobs. (Value:
 *        "PROCESSING_MODE_BATCH")
 *    @arg @c kGTLRTranscoder_Job_Mode_ProcessingModeInteractive The job
 *        processing mode is interactive mode. Interactive job will either be
 *        ran or rejected if quota does not allow for it. (Value:
 *        "PROCESSING_MODE_INTERACTIVE")
 *    @arg @c kGTLRTranscoder_Job_Mode_ProcessingModeUnspecified The job
 *        processing mode is not specified. (Value:
 *        "PROCESSING_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *mode;

/**
 *  The resource name of the job. Format:
 *  `projects/{project_number}/locations/{location}/jobs/{job}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. The optimization strategy of the job. The default is `AUTODETECT`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Job_Optimization_Autodetect Prioritize job
 *        processing speed. (Value: "AUTODETECT")
 *    @arg @c kGTLRTranscoder_Job_Optimization_Disabled Disable all
 *        optimizations. (Value: "DISABLED")
 *    @arg @c kGTLRTranscoder_Job_Optimization_OptimizationStrategyUnspecified
 *        The optimization strategy is not specified. (Value:
 *        "OPTIMIZATION_STRATEGY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *optimization;

/**
 *  Input only. Specify the `output_uri` to populate an empty
 *  `Job.config.output.uri` or `JobTemplate.config.output.uri` when using
 *  template. URI for the output file(s). For example,
 *  `gs://my-bucket/outputs/`. See [Supported input and output
 *  formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
 */
@property(nonatomic, copy, nullable) NSString *outputUri;

/** Output only. The time the transcoding started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Output only. The current state of the job.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Job_State_Failed The job has failed. For
 *        additional information, see
 *        [Troubleshooting](https://cloud.google.com/transcoder/docs/troubleshooting).
 *        (Value: "FAILED")
 *    @arg @c kGTLRTranscoder_Job_State_Pending The job is enqueued and will be
 *        picked up for processing soon. (Value: "PENDING")
 *    @arg @c kGTLRTranscoder_Job_State_ProcessingStateUnspecified The
 *        processing state is not specified. (Value:
 *        "PROCESSING_STATE_UNSPECIFIED")
 *    @arg @c kGTLRTranscoder_Job_State_Running The job is being processed.
 *        (Value: "RUNNING")
 *    @arg @c kGTLRTranscoder_Job_State_Succeeded The job has been completed
 *        successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Input only. Specify the `template_id` to use for populating `Job.config`.
 *  The default is `preset/web-hd`, which is the only supported preset. User
 *  defined JobTemplate: `{job_template_id}`
 */
@property(nonatomic, copy, nullable) NSString *templateId;

/**
 *  Job time to live value in days, which will be effective after job
 *  completion. Job should be deleted automatically after the given TTL. Enter a
 *  value between 1 and 90. The default is 30.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ttlAfterCompletionDays;

@end


/**
 *  The labels associated with this job. You can use these to organize and group
 *  your jobs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRTranscoder_Job_Labels : GTLRObject
@end


/**
 *  Job configuration
 */
@interface GTLRTranscoder_JobConfig : GTLRObject

/**
 *  List of ad breaks. Specifies where to insert ad break tags in the output
 *  manifests.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_AdBreak *> *adBreaks;

/**
 *  List of edit atoms. Defines the ultimate timeline of the resulting file or
 *  manifest.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_EditAtom *> *editList;

/** List of elementary streams. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_ElementaryStream *> *elementaryStreams;

/**
 *  List of encryption configurations for the content. Each configuration has an
 *  ID. Specify this ID in the MuxStream.encryption_id field to indicate the
 *  configuration to use for that `MuxStream` output.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Encryption *> *encryptions;

/** List of input assets stored in Cloud Storage. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Input *> *inputs;

/** List of output manifests. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Manifest *> *manifests;

/** List of multiplexing settings for output streams. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_MuxStream *> *muxStreams;

/** Output configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Output *output;

/** List of overlays on the output video, in descending Z-order. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Overlay *> *overlays;

/** Destination on Pub/Sub. */
@property(nonatomic, strong, nullable) GTLRTranscoder_PubsubDestination *pubsubDestination;

/**
 *  List of output sprite sheets. Spritesheets require at least one VideoStream
 *  in the Jobconfig.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_SpriteSheet *> *spriteSheets;

@end


/**
 *  Transcoding job template resource.
 */
@interface GTLRTranscoder_JobTemplate : GTLRObject

/** The configuration for this template. */
@property(nonatomic, strong, nullable) GTLRTranscoder_JobConfig *config;

/**
 *  The labels associated with this job template. You can use these to organize
 *  and group your job templates.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_JobTemplate_Labels *labels;

/**
 *  The resource name of the job template. Format:
 *  `projects/{project_number}/locations/{location}/jobTemplates/{job_template}`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The labels associated with this job template. You can use these to organize
 *  and group your job templates.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRTranscoder_JobTemplate_Labels : GTLRObject
@end


/**
 *  Response message for `TranscoderService.ListJobs`.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobs" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRTranscoder_ListJobsResponse : GTLRCollectionObject

/**
 *  List of jobs in the specified region.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Job *> *jobs;

/** The pagination token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** List of regions that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for `TranscoderService.ListJobTemplates`.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobTemplates" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRTranscoder_ListJobTemplatesResponse : GTLRCollectionObject

/**
 *  List of job templates in the specified region.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_JobTemplate *> *jobTemplates;

/** The pagination token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** List of regions that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Manifest configuration.
 */
@interface GTLRTranscoder_Manifest : GTLRObject

/** `DASH` manifest configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_DashConfig *dash;

/**
 *  The name of the generated file. The default is `manifest` with the extension
 *  suffix corresponding to the Manifest.type.
 */
@property(nonatomic, copy, nullable) NSString *fileName;

/**
 *  Required. List of user supplied MuxStream.key values that should appear in
 *  this manifest. When Manifest.type is `HLS`, a media manifest with name
 *  MuxStream.key and `.m3u8` extension is generated for each element in this
 *  list.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *muxStreams;

/**
 *  Required. Type of the manifest.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Manifest_Type_Dash Create an MPEG-DASH manifest.
 *        The corresponding file extension is `.mpd`. (Value: "DASH")
 *    @arg @c kGTLRTranscoder_Manifest_Type_Hls Create an HLS manifest. The
 *        corresponding file extension is `.m3u8`. (Value: "HLS")
 *    @arg @c kGTLRTranscoder_Manifest_Type_ManifestTypeUnspecified The manifest
 *        type is not specified. (Value: "MANIFEST_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Configuration for MPEG Common Encryption (MPEG-CENC).
 */
@interface GTLRTranscoder_MpegCommonEncryption : GTLRObject

/**
 *  Required. Specify the encryption scheme. Supported encryption schemes: -
 *  `cenc` - `cbcs`
 */
@property(nonatomic, copy, nullable) NSString *scheme;

@end


/**
 *  Multiplexing settings for output stream.
 */
@interface GTLRTranscoder_MuxStream : GTLRObject

/**
 *  The container format. The default is `mp4` Supported streaming formats: -
 *  `ts` - `fmp4`- the corresponding file extension is `.m4s` Supported
 *  standalone file formats: - `mp4` - `mp3` - `ogg` - `vtt` See also:
 *  [Supported input and output
 *  formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats)
 */
@property(nonatomic, copy, nullable) NSString *container;

/** List of ElementaryStream.key values multiplexed in this stream. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *elementaryStreams;

/**
 *  Identifier of the encryption configuration to use. If omitted, output will
 *  be unencrypted.
 */
@property(nonatomic, copy, nullable) NSString *encryptionId;

/**
 *  The name of the generated file. The default is MuxStream.key with the
 *  extension suffix corresponding to the MuxStream.container. Individual
 *  segments also have an incremental 10-digit zero-padded suffix starting from
 *  0 before the extension, such as `mux_stream0000000123.ts`.
 */
@property(nonatomic, copy, nullable) NSString *fileName;

/** Optional. `fmp4` container configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Fmp4Config *fmp4;

/** A unique key for this multiplexed stream. */
@property(nonatomic, copy, nullable) NSString *key;

/** Segment settings for `ts`, `fmp4` and `vtt`. */
@property(nonatomic, strong, nullable) GTLRTranscoder_SegmentSettings *segmentSettings;

@end


/**
 *  2D normalized coordinates. Default: `{0.0, 0.0}`
 */
@interface GTLRTranscoder_NormalizedCoordinate : GTLRObject

/**
 *  Normalized x coordinate.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *x;

/**
 *  Normalized y coordinate.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *y;

@end


/**
 *  Location of output file(s) in a Cloud Storage bucket.
 */
@interface GTLRTranscoder_Output : GTLRObject

/**
 *  URI for the output file(s). For example, `gs://my-bucket/outputs/`. Must be
 *  a directory and not a top-level bucket. If empty, the value is populated
 *  from Job.output_uri. See [Supported input and output
 *  formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Overlay configuration.
 */
@interface GTLRTranscoder_Overlay : GTLRObject

/**
 *  List of animations. The list should be chronological, without any time
 *  overlap.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Animation *> *animations;

/** Image overlay. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Image *image;

@end


/**
 *  Pad filter configuration for the input video. The padded input video is
 *  scaled after padding with black to match the output resolution.
 */
@interface GTLRTranscoder_Pad : GTLRObject

/**
 *  The number of pixels to add to the bottom. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bottomPixels;

/**
 *  The number of pixels to add to the left. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *leftPixels;

/**
 *  The number of pixels to add to the right. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rightPixels;

/**
 *  The number of pixels to add to the top. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *topPixels;

@end


/**
 *  Playready configuration.
 */
@interface GTLRTranscoder_Playready : GTLRObject
@end


/**
 *  Preprocessing configurations.
 */
@interface GTLRTranscoder_PreprocessingConfig : GTLRObject

/** Audio preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Audio *audio;

/** Color preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Color *color;

/** Specify the video cropping configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Crop *crop;

/** Deblock preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Deblock *deblock;

/** Specify the video deinterlace configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Deinterlace *deinterlace;

/** Denoise preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Denoise *denoise;

/** Specify the video pad filter configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Pad *pad;

@end


/**
 *  A Pub/Sub destination.
 */
@interface GTLRTranscoder_PubsubDestination : GTLRObject

/**
 *  The name of the Pub/Sub topic to publish job completion notification to. For
 *  example: `projects/{project}/topics/{topic}`.
 */
@property(nonatomic, copy, nullable) NSString *topic;

@end


/**
 *  Configuration for SAMPLE-AES encryption.
 */
@interface GTLRTranscoder_SampleAesEncryption : GTLRObject
@end


/**
 *  Configuration for secrets stored in Google Secret Manager.
 */
@interface GTLRTranscoder_SecretManagerSource : GTLRObject

/**
 *  Required. The name of the Secret Version containing the encryption key in
 *  the following format:
 *  `projects/{project}/secrets/{secret_id}/versions/{version_number}` Note that
 *  only numbered versions are supported. Aliases like "latest" are not
 *  supported.
 */
@property(nonatomic, copy, nullable) NSString *secretVersion;

@end


/**
 *  Segment settings for `ts`, `fmp4` and `vtt`.
 */
@interface GTLRTranscoder_SegmentSettings : GTLRObject

/**
 *  Required. Create an individual segment file. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *individualSegments;

/**
 *  Duration of the segments in seconds. The default is `6.0s`. Note that
 *  `segmentDuration` must be greater than or equal to
 *  [`gopDuration`](#videostream), and `segmentDuration` must be divisible by
 *  [`gopDuration`](#videostream).
 */
@property(nonatomic, strong, nullable) GTLRDuration *segmentDuration;

@end


/**
 *  Sprite sheet configuration.
 */
@interface GTLRTranscoder_SpriteSheet : GTLRObject

/**
 *  The maximum number of sprites per row in a sprite sheet. The default is 0,
 *  which indicates no maximum limit.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *columnCount;

/**
 *  End time in seconds, relative to the output file timeline. When
 *  `end_time_offset` is not specified, the sprites are generated until the end
 *  of the output file.
 */
@property(nonatomic, strong, nullable) GTLRDuration *endTimeOffset;

/**
 *  Required. File name prefix for the generated sprite sheets. Each sprite
 *  sheet has an incremental 10-digit zero-padded suffix starting from 0 before
 *  the extension, such as `sprite_sheet0000000123.jpeg`.
 */
@property(nonatomic, copy, nullable) NSString *filePrefix;

/** Format type. The default is `jpeg`. Supported formats: - `jpeg` */
@property(nonatomic, copy, nullable) NSString *format;

/**
 *  Starting from `0s`, create sprites at regular intervals. Specify the
 *  interval value in seconds.
 */
@property(nonatomic, strong, nullable) GTLRDuration *interval;

/**
 *  The quality of the generated sprite sheet. Enter a value between 1 and 100,
 *  where 1 is the lowest quality and 100 is the highest quality. The default is
 *  100. A high quality value corresponds to a low image data compression ratio.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *quality;

/**
 *  The maximum number of rows per sprite sheet. When the sprite sheet is full,
 *  a new sprite sheet is created. The default is 0, which indicates no maximum
 *  limit.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCount;

/**
 *  Required. The height of sprite in pixels. Must be an even integer. To
 *  preserve the source aspect ratio, set the SpriteSheet.sprite_height_pixels
 *  field or the SpriteSheet.sprite_width_pixels field, but not both (the API
 *  will automatically calculate the missing field). For portrait videos that
 *  contain horizontal ASR and rotation metadata, provide the height, in pixels,
 *  per the horizontal ASR. The API calculates the width per the horizontal ASR.
 *  The API detects any rotation metadata and swaps the requested height and
 *  width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *spriteHeightPixels;

/**
 *  Required. The width of sprite in pixels. Must be an even integer. To
 *  preserve the source aspect ratio, set the SpriteSheet.sprite_width_pixels
 *  field or the SpriteSheet.sprite_height_pixels field, but not both (the API
 *  will automatically calculate the missing field). For portrait videos that
 *  contain horizontal ASR and rotation metadata, provide the width, in pixels,
 *  per the horizontal ASR. The API calculates the height per the horizontal
 *  ASR. The API detects any rotation metadata and swaps the requested height
 *  and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *spriteWidthPixels;

/**
 *  Start time in seconds, relative to the output file timeline. Determines the
 *  first sprite to pick. The default is `0s`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

/**
 *  Total number of sprites. Create the specified number of sprites distributed
 *  evenly across the timeline of the output media. The default is 100.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalCount;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRTranscoder_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRTranscoder_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTranscoder_Status_Details_Item : GTLRObject
@end


/**
 *  The mapping for the JobConfig.edit_list atoms with text EditAtom.inputs.
 */
@interface GTLRTranscoder_TextMapping : GTLRObject

/**
 *  Required. The EditAtom.key that references atom with text inputs in the
 *  JobConfig.edit_list.
 */
@property(nonatomic, copy, nullable) NSString *atomKey;

/** Required. The Input.key that identifies the input file. */
@property(nonatomic, copy, nullable) NSString *inputKey;

/**
 *  Required. The zero-based index of the track in the input file.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputTrack;

@end


/**
 *  Encoding of a text stream. For example, closed captions or subtitles.
 */
@interface GTLRTranscoder_TextStream : GTLRObject

/**
 *  The codec for this text stream. The default is `webvtt`. Supported text
 *  codecs: - `srt` - `ttml` - `cea608` - `cea708` - `webvtt`
 */
@property(nonatomic, copy, nullable) NSString *codec;

/**
 *  The name for this particular text stream that will be added to the HLS/DASH
 *  manifest. Not supported in MP4 files.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The BCP-47 language code, such as `en-US` or `sr-Latn`. For more
 *  information, see
 *  https://www.unicode.org/reports/tr35/#Unicode_locale_identifier. Not
 *  supported in MP4 files.
 */
@property(nonatomic, copy, nullable) NSString *languageCode;

/**
 *  The mapping for the JobConfig.edit_list atoms with text EditAtom.inputs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_TextMapping *> *mapping;

@end


/**
 *  Track definition for the input asset.
 */
@interface GTLRTranscoder_TrackDefinition : GTLRObject

/**
 *  Output only. A list of languages detected in the input asset, represented by
 *  a BCP 47 language code, such as "en-US" or "sr-Latn". For more information,
 *  see https://www.unicode.org/reports/tr35/#Unicode_locale_identifier. This
 *  field is only populated if the detect_languages field is set to true.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *detectedLanguages;

/**
 *  Optional. Whether to automatically detect the languages present in the
 *  track. If true, the system will attempt to identify all the languages
 *  present in the track and populate the languages field.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *detectLanguages;

/**
 *  The input track.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputTrack;

/**
 *  Optional. A list of languages spoken in the input asset, represented by a
 *  BCP 47 language code, such as "en-US" or "sr-Latn". For more information,
 *  see https://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *languages;

@end


/**
 *  Video stream resource.
 */
@interface GTLRTranscoder_VideoStream : GTLRObject

/** H264 codec settings. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H264CodecSettings *h264;

/** H265 codec settings. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H265CodecSettings *h265;

/** VP9 codec settings. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Vp9CodecSettings *vp9;

@end


/**
 *  VP9 codec settings.
 */
@interface GTLRTranscoder_Vp9CodecSettings : GTLRObject

/**
 *  Required. The video bitrate in bits per second. The minimum value is 1,000.
 *  The maximum value is 480,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Target CRF level. Must be between 10 and 36, where 10 is the highest quality
 *  and 36 is the most efficient compression. The default is 21. **Note:** This
 *  field is not supported.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crfLevel;

/**
 *  Required. The target video frame rate in frames per second (FPS). Must be
 *  less than or equal to 120.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *frameRate;

/**
 *  Optional. Frame rate conversion strategy for desired frame rate. The default
 *  is `DOWNSAMPLE`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Vp9CodecSettings_FrameRateConversionStrategy_Downsample
 *        Selectively retain frames to reduce the output frame rate. Every _n_
 *        th frame is kept, where `n = ceil(input frame rate / target frame
 *        rate)`. When _n_ = 1 (that is, the target frame rate is greater than
 *        the input frame rate), the output frame rate matches the input frame
 *        rate. When _n_ > 1, frames are dropped and the output frame rate is
 *        equal to `(input frame rate / n)`. For more information, see
 *        [Calculate frame
 *        rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate).
 *        (Value: "DOWNSAMPLE")
 *    @arg @c kGTLRTranscoder_Vp9CodecSettings_FrameRateConversionStrategy_DropDuplicate
 *        Drop or duplicate frames to match the specified frame rate. (Value:
 *        "DROP_DUPLICATE")
 *    @arg @c kGTLRTranscoder_Vp9CodecSettings_FrameRateConversionStrategy_FrameRateConversionStrategyUnspecified
 *        Unspecified frame rate conversion strategy. (Value:
 *        "FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *frameRateConversionStrategy;

/**
 *  Select the GOP size based on the specified duration. The default is `3s`.
 *  Note that `gopDuration` must be less than or equal to
 *  [`segmentDuration`](#SegmentSettings), and
 *  [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *gopDuration;

/**
 *  Select the GOP size based on the specified frame count. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gopFrameCount;

/**
 *  The height of the video in pixels. Must be an even integer. When not
 *  specified, the height is adjusted to match the specified width and input
 *  aspect ratio. If both are omitted, the input height is used. For portrait
 *  videos that contain horizontal ASR and rotation metadata, provide the
 *  height, in pixels, per the horizontal ASR. The API calculates the width per
 *  the horizontal ASR. The API detects any rotation metadata and swaps the
 *  requested height and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *heightPixels;

/** Optional. HLG color format setting for VP9. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Vp9ColorFormatHLG *hlg;

/**
 *  Pixel format to use. The default is `yuv420p`. Supported pixel formats: -
 *  `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format -
 *  `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format -
 *  `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format -
 *  `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 */
@property(nonatomic, copy, nullable) NSString *pixelFormat;

/**
 *  Enforces the specified codec profile. The following profiles are supported:
 *  * `profile0` (default) * `profile1` * `profile2` * `profile3` The available
 *  options are [WebM-compatible](https://www.webmproject.org/vp9/profiles/).
 *  Note that certain values for this field may cause the transcoder to override
 *  other fields you set in the `Vp9CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *profile;

/**
 *  Specify the mode. The default is `vbr`. Supported rate control modes: -
 *  `vbr` - variable bitrate
 */
@property(nonatomic, copy, nullable) NSString *rateControlMode;

/** Optional. SDR color format setting for VP9. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Vp9ColorFormatSDR *sdr;

/**
 *  The width of the video in pixels. Must be an even integer. When not
 *  specified, the width is adjusted to match the specified height and input
 *  aspect ratio. If both are omitted, the input width is used. For portrait
 *  videos that contain horizontal ASR and rotation metadata, provide the width,
 *  in pixels, per the horizontal ASR. The API calculates the height per the
 *  horizontal ASR. The API detects any rotation metadata and swaps the
 *  requested height and width for the output.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *widthPixels;

@end


/**
 *  Convert the input video to a Hybrid Log Gamma (HLG) video.
 */
@interface GTLRTranscoder_Vp9ColorFormatHLG : GTLRObject
@end


/**
 *  Convert the input video to a Standard Dynamic Range (SDR) video.
 */
@interface GTLRTranscoder_Vp9ColorFormatSDR : GTLRObject
@end


/**
 *  Widevine configuration.
 */
@interface GTLRTranscoder_Widevine : GTLRObject
@end


/**
 *  Yet Another Deinterlacing Filter Configuration.
 */
@interface GTLRTranscoder_YadifConfig : GTLRObject

/**
 *  Deinterlace all frames rather than just the frames identified as interlaced.
 *  The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deinterlaceAllFrames;

/**
 *  Disable spacial interlacing. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableSpatialInterlacing;

/**
 *  Specifies the deinterlacing mode to adopt. The default is `send_frame`.
 *  Supported values: - `send_frame`: Output one frame for each frame -
 *  `send_field`: Output one frame for each field
 */
@property(nonatomic, copy, nullable) NSString *mode;

/**
 *  The picture field parity assumed for the input interlaced video. The default
 *  is `auto`. Supported values: - `tff`: Assume the top field is first - `bff`:
 *  Assume the bottom field is first - `auto`: Enable automatic detection of
 *  field parity
 */
@property(nonatomic, copy, nullable) NSString *parity;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
