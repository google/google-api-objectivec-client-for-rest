// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Bigtable Admin API (bigtableadmin/v2)
// Description:
//   Administer your Cloud Bigtable tables and instances.
// Documentation:
//   https://cloud.google.com/bigtable/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRBigtableAdmin_AppProfile;
@class GTLRBigtableAdmin_AuditConfig;
@class GTLRBigtableAdmin_AuditLogConfig;
@class GTLRBigtableAdmin_AutoscalingLimits;
@class GTLRBigtableAdmin_AutoscalingTargets;
@class GTLRBigtableAdmin_Backup;
@class GTLRBigtableAdmin_BackupInfo;
@class GTLRBigtableAdmin_Binding;
@class GTLRBigtableAdmin_Cluster;
@class GTLRBigtableAdmin_ClusterAutoscalingConfig;
@class GTLRBigtableAdmin_ClusterConfig;
@class GTLRBigtableAdmin_ClusterState;
@class GTLRBigtableAdmin_ColumnFamily;
@class GTLRBigtableAdmin_ColumnFamilyStats;
@class GTLRBigtableAdmin_CreateClusterMetadata_Tables;
@class GTLRBigtableAdmin_CreateClusterRequest;
@class GTLRBigtableAdmin_CreateInstanceRequest;
@class GTLRBigtableAdmin_CreateInstanceRequest_Clusters;
@class GTLRBigtableAdmin_EncryptionConfig;
@class GTLRBigtableAdmin_EncryptionInfo;
@class GTLRBigtableAdmin_Expr;
@class GTLRBigtableAdmin_GcRule;
@class GTLRBigtableAdmin_GetPolicyOptions;
@class GTLRBigtableAdmin_HotTablet;
@class GTLRBigtableAdmin_Instance;
@class GTLRBigtableAdmin_Instance_Labels;
@class GTLRBigtableAdmin_Intersection;
@class GTLRBigtableAdmin_Location;
@class GTLRBigtableAdmin_Location_Labels;
@class GTLRBigtableAdmin_Location_Metadata;
@class GTLRBigtableAdmin_Modification;
@class GTLRBigtableAdmin_MultiClusterRoutingUseAny;
@class GTLRBigtableAdmin_Operation;
@class GTLRBigtableAdmin_Operation_Metadata;
@class GTLRBigtableAdmin_Operation_Response;
@class GTLRBigtableAdmin_OperationProgress;
@class GTLRBigtableAdmin_PartialUpdateClusterRequest;
@class GTLRBigtableAdmin_PartialUpdateInstanceRequest;
@class GTLRBigtableAdmin_Policy;
@class GTLRBigtableAdmin_RestoreInfo;
@class GTLRBigtableAdmin_SingleClusterRouting;
@class GTLRBigtableAdmin_Split;
@class GTLRBigtableAdmin_Status;
@class GTLRBigtableAdmin_Status_Details_Item;
@class GTLRBigtableAdmin_Table;
@class GTLRBigtableAdmin_Table_ClusterStates;
@class GTLRBigtableAdmin_Table_ColumnFamilies;
@class GTLRBigtableAdmin_TableProgress;
@class GTLRBigtableAdmin_TableStats;
@class GTLRBigtableAdmin_Union;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Backup.state

/**
 *  The pending backup is still being created. Operations on the backup may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Backup_State_Creating;
/**
 *  The backup is complete and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Backup_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Backup_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Cluster.defaultStorageType

/**
 *  Magnetic drive (HDD) storage should be used.
 *
 *  Value: "HDD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_DefaultStorageType_Hdd;
/**
 *  Flash (SSD) storage should be used.
 *
 *  Value: "SSD"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_DefaultStorageType_Ssd;
/**
 *  The user did not specify a storage type.
 *
 *  Value: "STORAGE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_DefaultStorageType_StorageTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Cluster.state

/**
 *  The cluster is currently being created, and may be destroyed if the creation
 *  process encounters an error. A cluster may not be able to serve requests
 *  while being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Creating;
/**
 *  The cluster has no backing nodes. The data (tables) still exist, but no
 *  operations can be performed on the cluster.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Disabled;
/**
 *  The cluster has been successfully created and is ready to serve requests.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Ready;
/**
 *  The cluster is currently being resized, and may revert to its previous node
 *  count if the process encounters an error. A cluster is still capable of
 *  serving requests while being resized, but may exhibit performance as if its
 *  number of allocated nodes is between the starting and requested states.
 *
 *  Value: "RESIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Resizing;
/**
 *  The state of the cluster could not be determined.
 *
 *  Value: "STATE_NOT_KNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_StateNotKnown;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_ClusterState.replicationState

/**
 *  The cluster was recently created, and the table must finish copying over
 *  pre-existing data from other clusters before it can begin receiving live
 *  replication updates and serving Data API requests.
 *
 *  Value: "INITIALIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_Initializing;
/**
 *  The table is temporarily unable to serve Data API requests from this cluster
 *  due to planned internal maintenance.
 *
 *  Value: "PLANNED_MAINTENANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_PlannedMaintenance;
/**
 *  The table can serve Data API requests from this cluster. Depending on
 *  replication delay, reads may not immediately reflect the state of the table
 *  in other clusters.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_Ready;
/**
 *  The table is fully created and ready for use after a restore, and is being
 *  optimized for performance. When optimizations are complete, the table will
 *  transition to `READY` state.
 *
 *  Value: "READY_OPTIMIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_ReadyOptimizing;
/**
 *  The replication state of the table is unknown in this cluster.
 *
 *  Value: "STATE_NOT_KNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_StateNotKnown;
/**
 *  The table is temporarily unable to serve Data API requests from this cluster
 *  due to unplanned or emergency maintenance.
 *
 *  Value: "UNPLANNED_MAINTENANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_UnplannedMaintenance;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_EncryptionInfo.encryptionType

/**
 *  The data backing this resource is encrypted at rest with a key that is
 *  managed by the customer. The in-use version of the key and its status are
 *  populated for CMEK-protected tables. CMEK-protected backups are pinned to
 *  the key version that was in use at the time the backup was taken. This key
 *  version is populated but its status is not tracked and is reported as
 *  `UNKNOWN`.
 *
 *  Value: "CUSTOMER_MANAGED_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_EncryptionInfo_EncryptionType_CustomerManagedEncryption;
/**
 *  Encryption type was not specified, though data at rest remains encrypted.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_EncryptionInfo_EncryptionType_EncryptionTypeUnspecified;
/**
 *  The data backing this resource is encrypted at rest with a key that is fully
 *  managed by Google. No key version or status will be populated. This is the
 *  default state.
 *
 *  Value: "GOOGLE_DEFAULT_ENCRYPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_EncryptionInfo_EncryptionType_GoogleDefaultEncryption;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Instance.state

/**
 *  The instance is currently being created, and may be destroyed if the
 *  creation process encounters an error.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Instance_State_Creating;
/**
 *  The instance has been successfully created and can serve requests to its
 *  tables.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Instance_State_Ready;
/**
 *  The state of the instance could not be determined.
 *
 *  Value: "STATE_NOT_KNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Instance_State_StateNotKnown;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Instance.type

/**
 *  DEPRECATED: Prefer PRODUCTION for all use cases, as it no longer enforces a
 *  higher minimum node count than DEVELOPMENT.
 *
 *  Value: "DEVELOPMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Instance_Type_Development;
/**
 *  An instance meant for production use. `serve_nodes` must be set on the
 *  cluster.
 *
 *  Value: "PRODUCTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Instance_Type_Production;
/**
 *  The type of the instance is unspecified. If set when creating an instance, a
 *  `PRODUCTION` instance will be created. If set when updating an instance, the
 *  type will be left unchanged.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Instance_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_RestoreInfo.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_RestoreInfo_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "RESTORE_SOURCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_RestoreInfo_SourceType_RestoreSourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_RestoreTableMetadata.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_RestoreTableMetadata_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "RESTORE_SOURCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_RestoreTableMetadata_SourceType_RestoreSourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Table.granularity

/**
 *  The table keeps data versioned at a granularity of 1ms.
 *
 *  Value: "MILLIS"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Table_Granularity_Millis;
/**
 *  The user did not specify a granularity. Should not be returned. When
 *  specified during table creation, MILLIS will be used.
 *
 *  Value: "TIMESTAMP_GRANULARITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_Table_Granularity_TimestampGranularityUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_TableProgress.state

/**
 *  The table was deleted before it finished copying to the new cluster. Note
 *  that tables deleted after completion will stay marked as COMPLETED, not
 *  CANCELLED.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Cancelled;
/**
 *  The table has been fully copied to the new cluster.
 *
 *  Value: "COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Completed;
/**
 *  The table is actively being copied to the new cluster.
 *
 *  Value: "COPYING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Copying;
/**
 *  The table has not yet begun copying to the new cluster.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Pending;
/** Value: "STATE_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_StateUnspecified;

/**
 *  A configuration object describing how Cloud Bigtable should treat traffic
 *  from a particular end user application.
 */
@interface GTLRBigtableAdmin_AppProfile : GTLRObject

/**
 *  Long form description of the use case for this AppProfile.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Strongly validated etag for optimistic concurrency control. Preserve the
 *  value returned from `GetAppProfile` when calling `UpdateAppProfile` to fail
 *  the request if there has been a modification in the mean time. The
 *  `update_mask` of the request need not include `etag` for this protection to
 *  apply. See [Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag) and [RFC
 *  7232](https://tools.ietf.org/html/rfc7232#section-2.3) for more details.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Use a multi-cluster routing policy. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_MultiClusterRoutingUseAny *multiClusterRoutingUseAny;

/**
 *  The unique name of the app profile. Values are of the form
 *  `projects/{project}/instances/{instance}/appProfiles/_a-zA-Z0-9*`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Use a single-cluster routing policy. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_SingleClusterRouting *singleClusterRouting;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRBigtableAdmin_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRBigtableAdmin_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Limits for the number of nodes a Cluster can autoscale up/down to.
 */
@interface GTLRBigtableAdmin_AutoscalingLimits : GTLRObject

/**
 *  Required. Maximum number of nodes to scale up to.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxServeNodes;

/**
 *  Required. Minimum number of nodes to scale down to.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minServeNodes;

@end


/**
 *  The Autoscaling targets for a Cluster. These determine the recommended
 *  nodes.
 */
@interface GTLRBigtableAdmin_AutoscalingTargets : GTLRObject

/**
 *  The cpu utilization that the Autoscaler should be trying to achieve. This
 *  number is on a scale from 0 (no utilization) to 100 (total utilization), and
 *  is limited between 10 and 80, otherwise it will return INVALID_ARGUMENT
 *  error.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cpuUtilizationPercent;

/**
 *  The storage utilization that the Autoscaler should be trying to achieve.
 *  This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD
 *  cluster and between 8192 (8TiB) and 16384 (16TiB) for an HDD cluster,
 *  otherwise it will return INVALID_ARGUMENT error. If this value is set to 0,
 *  it will be treated as if it were set to the default value: 2560 for SSD,
 *  8192 for HDD.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *storageUtilizationGibPerNode;

@end


/**
 *  A backup of a Cloud Bigtable table.
 */
@interface GTLRBigtableAdmin_Backup : GTLRObject

/** Output only. The encryption information for the backup. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_EncryptionInfo *encryptionInfo;

/**
 *  Output only. `end_time` is the time that the backup was finished. The row
 *  data in the backup will be no newer than this timestamp.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Required. The expiration time of the backup, with microseconds granularity
 *  that must be at least 6 hours and at most 30 days from the time the request
 *  is received. Once the `expire_time` has passed, Cloud Bigtable will delete
 *  the backup and free the resources used by the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  A globally unique identifier for the backup which cannot be changed. Values
 *  are of the form `projects/{project}/instances/{instance}/clusters/{cluster}/
 *  backups/_a-zA-Z0-9*` The final segment of the name must be between 1 and 50
 *  characters in length. The backup is stored in the cluster identified by the
 *  prefix of the backup name of the form
 *  `projects/{project}/instances/{instance}/clusters/{cluster}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Size of the backup in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeBytes;

/**
 *  Output only. Name of the backup from which this backup was copied. If a
 *  backup is not created by copying a backup, this field will be empty. Values
 *  are of the form: projects//instances//backups/.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

/**
 *  Required. Immutable. Name of the table from which this backup was created.
 *  This needs to be in the same instance as the backup. Values are of the form
 *  `projects/{project}/instances/{instance}/tables/{source_table}`.
 */
@property(nonatomic, copy, nullable) NSString *sourceTable;

/**
 *  Output only. `start_time` is the time that the backup was started (i.e.
 *  approximately the time the CreateBackup request is received). The row data
 *  in this backup will be no older than this timestamp.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Output only. The current state of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Backup_State_Creating The pending backup is
 *        still being created. Operations on the backup may fail with
 *        `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRBigtableAdmin_Backup_State_Ready The backup is complete and
 *        ready for use. (Value: "READY")
 *    @arg @c kGTLRBigtableAdmin_Backup_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Information about a backup.
 */
@interface GTLRBigtableAdmin_BackupInfo : GTLRObject

/** Output only. Name of the backup. */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  Output only. This time that the backup was finished. Row data in the backup
 *  will be no newer than this timestamp.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Name of the backup from which this backup was copied. If a
 *  backup is not created by copying a backup, this field will be empty. Values
 *  are of the form: projects//instances//backups/.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

/** Output only. Name of the table the backup was created from. */
@property(nonatomic, copy, nullable) NSString *sourceTable;

/**
 *  Output only. The time that the backup was started. Row data in the backup
 *  will be no older than this timestamp.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRBigtableAdmin_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
 *  An email address (plus unique identifier) representing a user that has been
 *  recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency
 */
@interface GTLRBigtableAdmin_CheckConsistencyRequest : GTLRObject

/**
 *  Required. The token created using GenerateConsistencyToken for the Table.
 */
@property(nonatomic, copy, nullable) NSString *consistencyToken;

@end


/**
 *  Response message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency
 */
@interface GTLRBigtableAdmin_CheckConsistencyResponse : GTLRObject

/**
 *  True only if the token is consistent. A token is consistent if replication
 *  has caught up with the restrictions specified in the request.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *consistent;

@end


/**
 *  A resizable group of nodes in a particular cloud location, capable of
 *  serving all Tables in the parent Instance.
 */
@interface GTLRBigtableAdmin_Cluster : GTLRObject

/** Configuration for this cluster. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ClusterConfig *clusterConfig;

/**
 *  Immutable. The type of storage used by this cluster to serve its parent
 *  instance's tables, unless explicitly overridden.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Cluster_DefaultStorageType_Hdd Magnetic drive
 *        (HDD) storage should be used. (Value: "HDD")
 *    @arg @c kGTLRBigtableAdmin_Cluster_DefaultStorageType_Ssd Flash (SSD)
 *        storage should be used. (Value: "SSD")
 *    @arg @c kGTLRBigtableAdmin_Cluster_DefaultStorageType_StorageTypeUnspecified
 *        The user did not specify a storage type. (Value:
 *        "STORAGE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *defaultStorageType;

/** Immutable. The encryption configuration for CMEK-protected clusters. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_EncryptionConfig *encryptionConfig;

/**
 *  Immutable. The location where this cluster's nodes and storage reside. For
 *  best performance, clients should be located as close as possible to this
 *  cluster. Currently only zones are supported, so values should be of the form
 *  `projects/{project}/locations/{zone}`.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The unique name of the cluster. Values are of the form
 *  `projects/{project}/instances/{instance}/clusters/a-z*`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The number of nodes allocated to this cluster. More nodes enable higher
 *  throughput and more consistent performance.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *serveNodes;

/**
 *  Output only. The current state of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Creating The cluster is currently
 *        being created, and may be destroyed if the creation process encounters
 *        an error. A cluster may not be able to serve requests while being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Disabled The cluster has no
 *        backing nodes. The data (tables) still exist, but no operations can be
 *        performed on the cluster. (Value: "DISABLED")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Ready The cluster has been
 *        successfully created and is ready to serve requests. (Value: "READY")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Resizing The cluster is currently
 *        being resized, and may revert to its previous node count if the
 *        process encounters an error. A cluster is still capable of serving
 *        requests while being resized, but may exhibit performance as if its
 *        number of allocated nodes is between the starting and requested
 *        states. (Value: "RESIZING")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_StateNotKnown The state of the
 *        cluster could not be determined. (Value: "STATE_NOT_KNOWN")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Autoscaling config for a cluster.
 */
@interface GTLRBigtableAdmin_ClusterAutoscalingConfig : GTLRObject

/** Required. Autoscaling limits for this cluster. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_AutoscalingLimits *autoscalingLimits;

/** Required. Autoscaling targets for this cluster. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_AutoscalingTargets *autoscalingTargets;

@end


/**
 *  Configuration for a cluster.
 */
@interface GTLRBigtableAdmin_ClusterConfig : GTLRObject

/** Autoscaling configuration for this cluster. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ClusterAutoscalingConfig *clusterAutoscalingConfig;

@end


/**
 *  The state of a table's data in a particular cluster.
 */
@interface GTLRBigtableAdmin_ClusterState : GTLRObject

/**
 *  Output only. The encryption information for the table in this cluster. If
 *  the encryption key protecting this resource is customer managed, then its
 *  version can be rotated in Cloud Key Management Service (Cloud KMS). The
 *  primary version of the key and its status will be reflected here when
 *  changes propagate from Cloud KMS.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_EncryptionInfo *> *encryptionInfo;

/**
 *  Output only. The state of replication for the table in this cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_Initializing The
 *        cluster was recently created, and the table must finish copying over
 *        pre-existing data from other clusters before it can begin receiving
 *        live replication updates and serving Data API requests. (Value:
 *        "INITIALIZING")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_PlannedMaintenance
 *        The table is temporarily unable to serve Data API requests from this
 *        cluster due to planned internal maintenance. (Value:
 *        "PLANNED_MAINTENANCE")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_Ready The table
 *        can serve Data API requests from this cluster. Depending on
 *        replication delay, reads may not immediately reflect the state of the
 *        table in other clusters. (Value: "READY")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_ReadyOptimizing
 *        The table is fully created and ready for use after a restore, and is
 *        being optimized for performance. When optimizations are complete, the
 *        table will transition to `READY` state. (Value: "READY_OPTIMIZING")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_StateNotKnown The
 *        replication state of the table is unknown in this cluster. (Value:
 *        "STATE_NOT_KNOWN")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_UnplannedMaintenance
 *        The table is temporarily unable to serve Data API requests from this
 *        cluster due to unplanned or emergency maintenance. (Value:
 *        "UNPLANNED_MAINTENANCE")
 */
@property(nonatomic, copy, nullable) NSString *replicationState;

@end


/**
 *  A set of columns within a table which share a common configuration.
 */
@interface GTLRBigtableAdmin_ColumnFamily : GTLRObject

/**
 *  Garbage collection rule specified as a protobuf. Must serialize to at most
 *  500 bytes. NOTE: Garbage collection executes opportunistically in the
 *  background, and so it's possible for reads to return a cell even if it
 *  matches the active GC expression for its family.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_GcRule *gcRule;

/**
 *  Only available with STATS_VIEW, this includes summary statistics about
 *  column family contents. For statistics over an entire table, see TableStats
 *  above.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ColumnFamilyStats *stats;

@end


/**
 *  Approximate statistics related to a single column family within a table.
 *  This information may change rapidly, interpreting these values at a point in
 *  time may already preset out-of-date information. Everything below is
 *  approximate, unless otherwise specified.
 */
@interface GTLRBigtableAdmin_ColumnFamilyStats : GTLRObject

/**
 *  How many cells are present per column qualifier in this column family,
 *  averaged over all rows containing any column in the column family. e.g. For
 *  column family "family" in a table with 3 rows: * A row with 3 cells in
 *  "family:col" and 1 cell in "other:col" (3 cells / 1 column in "family") * A
 *  row with 1 cell in "family:col", 7 cells in "family:other_col", and 7 cells
 *  in "other:data" (8 cells / 2 columns in "family") * A row with 3 cells in
 *  "other:col" (0 columns in "family", "family" not present) would report (3 +
 *  8 + 0)/(1 + 2 + 0) = 3.66 in this field.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *averageCellsPerColumn;

/**
 *  How many column qualifiers are present in this column family, averaged over
 *  all rows in the table. e.g. For column family "family" in a table with 3
 *  rows: * A row with cells in "family:col" and "other:col" (1 column in
 *  "family") * A row with cells in "family:col", "family:other_col", and
 *  "other:data" (2 columns in "family") * A row with cells in "other:col" (0
 *  columns in "family", "family" not present) would report (1 + 2 + 0)/3 = 1.5
 *  in this field.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *averageColumnsPerRow;

/**
 *  How much space the data in the column family occupies. This is roughly how
 *  many bytes would be needed to read the contents of the entire column family
 *  (e.g. by streaming all contents out).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logicalDataBytes;

@end


/**
 *  Metadata type for the google.longrunning.Operation returned by CopyBackup.
 */
@interface GTLRBigtableAdmin_CopyBackupMetadata : GTLRObject

/**
 *  The name of the backup being created through the copy operation. Values are
 *  of the form `projects//instances//clusters//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the CopyBackup operation. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_OperationProgress *progress;

/** Information about the source backup that is being copied from. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_BackupInfo *sourceBackupInfo;

@end


/**
 *  The request for CopyBackup.
 */
@interface GTLRBigtableAdmin_CopyBackupRequest : GTLRObject

/**
 *  Required. The id of the new backup. The `backup_id` along with `parent` are
 *  combined as {parent}/backups/{backup_id} to create the full backup name, of
 *  the form:
 *  `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup_id}`.
 *  This string must be between 1 and 50 characters in length and match the
 *  regex _a-zA-Z0-9*.
 */
@property(nonatomic, copy, nullable) NSString *backupId;

/**
 *  Required. Required. The expiration time of the copied backup with
 *  microsecond granularity that must be at least 6 hours and at most 30 days
 *  from the time the request is received. Once the `expire_time` has passed,
 *  Cloud Bigtable will delete the backup and free the resources used by the
 *  backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Required. The source backup to be copied from. The source backup needs to be
 *  in READY state for it to be copied. Copying a copied backup is not allowed.
 *  Once CopyBackup is in progress, the source backup cannot be deleted or
 *  cleaned up on expiration until CopyBackup is finished. Values are of the
 *  form: `projects//instances//clusters//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

@end


/**
 *  Metadata type for the operation returned by CreateBackup.
 */
@interface GTLRBigtableAdmin_CreateBackupMetadata : GTLRObject

/** If set, the time at which this operation finished or was cancelled. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The name of the backup being created. */
@property(nonatomic, copy, nullable) NSString *name;

/** The name of the table the backup is created from. */
@property(nonatomic, copy, nullable) NSString *sourceTable;

/** The time at which this operation started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The metadata for the Operation returned by CreateCluster.
 */
@interface GTLRBigtableAdmin_CreateClusterMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this CreateCluster operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateClusterRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

/**
 *  Keys: the full `name` of each table that existed in the instance when
 *  CreateCluster was first called, i.e. `projects//instances//tables/`. Any
 *  table added to the instance by a later API call will be created in the new
 *  cluster by that API call, not this one. Values: information on how much of a
 *  table's data has been copied to the newly-created cluster so far.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateClusterMetadata_Tables *tables;

@end


/**
 *  Keys: the full `name` of each table that existed in the instance when
 *  CreateCluster was first called, i.e. `projects//instances//tables/`. Any
 *  table added to the instance by a later API call will be created in the new
 *  cluster by that API call, not this one. Values: information on how much of a
 *  table's data has been copied to the newly-created cluster so far.
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_TableProgress. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_CreateClusterMetadata_Tables : GTLRObject
@end


/**
 *  Request message for BigtableInstanceAdmin.CreateCluster.
 */
@interface GTLRBigtableAdmin_CreateClusterRequest : GTLRObject

/**
 *  Required. The cluster to be created. Fields marked `OutputOnly` must be left
 *  blank.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Cluster *cluster;

/**
 *  Required. The ID to be used when referring to the new cluster within its
 *  instance, e.g., just `mycluster` rather than
 *  `projects/myproject/instances/myinstance/clusters/mycluster`.
 */
@property(nonatomic, copy, nullable) NSString *clusterId;

/**
 *  Required. The unique name of the instance in which to create the new
 *  cluster. Values are of the form `projects/{project}/instances/{instance}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

@end


/**
 *  The metadata for the Operation returned by CreateInstance.
 */
@interface GTLRBigtableAdmin_CreateInstanceMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this CreateInstance operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateInstanceRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end


/**
 *  Request message for BigtableInstanceAdmin.CreateInstance.
 */
@interface GTLRBigtableAdmin_CreateInstanceRequest : GTLRObject

/**
 *  Required. The clusters to be created within the instance, mapped by desired
 *  cluster ID, e.g., just `mycluster` rather than
 *  `projects/myproject/instances/myinstance/clusters/mycluster`. Fields marked
 *  `OutputOnly` must be left blank.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateInstanceRequest_Clusters *clusters;

/**
 *  Required. The instance to create. Fields marked `OutputOnly` must be left
 *  blank.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Instance *instance;

/**
 *  Required. The ID to be used when referring to the new instance within its
 *  project, e.g., just `myinstance` rather than
 *  `projects/myproject/instances/myinstance`.
 */
@property(nonatomic, copy, nullable) NSString *instanceId;

/**
 *  Required. The unique name of the project in which to create the new
 *  instance. Values are of the form `projects/{project}`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

@end


/**
 *  Required. The clusters to be created within the instance, mapped by desired
 *  cluster ID, e.g., just `mycluster` rather than
 *  `projects/myproject/instances/myinstance/clusters/mycluster`. Fields marked
 *  `OutputOnly` must be left blank.
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_Cluster. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_CreateInstanceRequest_Clusters : GTLRObject
@end


/**
 *  Request message for google.bigtable.admin.v2.BigtableTableAdmin.CreateTable
 */
@interface GTLRBigtableAdmin_CreateTableRequest : GTLRObject

/**
 *  The optional list of row keys that will be used to initially split the table
 *  into several tablets (tablets are similar to HBase regions). Given two split
 *  keys, `s1` and `s2`, three tablets will be created, spanning the key ranges:
 *  `[, s1), [s1, s2), [s2, )`. Example: * Row keys := `["a", "apple", "custom",
 *  "customer_1", "customer_2",` `"other", "zz"]` * initial_split_keys :=
 *  `["apple", "customer_1", "customer_2", "other"]` * Key assignment: - Tablet
 *  1 `[, apple) => {"a"}.` - Tablet 2 `[apple, customer_1) => {"apple",
 *  "custom"}.` - Tablet 3 `[customer_1, customer_2) => {"customer_1"}.` -
 *  Tablet 4 `[customer_2, other) => {"customer_2"}.` - Tablet 5 `[other, ) =>
 *  {"other", "zz"}.`
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Split *> *initialSplits;

/** Required. The Table to create. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Table *table;

/**
 *  Required. The name by which the new table should be referred to within the
 *  parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
 *  Maximum 50 characters.
 */
@property(nonatomic, copy, nullable) NSString *tableId;

@end


/**
 *  Request message for google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange
 */
@interface GTLRBigtableAdmin_DropRowRangeRequest : GTLRObject

/**
 *  Delete all rows in the table. Setting this to false is a no-op.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deleteAllDataFromTable;

/**
 *  Delete all rows that start with this row key prefix. Prefix cannot be zero
 *  length.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *rowKeyPrefix;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRBigtableAdmin_Empty : GTLRObject
@end


/**
 *  Cloud Key Management Service (Cloud KMS) settings for a CMEK-protected
 *  cluster.
 */
@interface GTLRBigtableAdmin_EncryptionConfig : GTLRObject

/**
 *  Describes the Cloud KMS encryption key that will be used to protect the
 *  destination Bigtable cluster. The requirements for this key are: 1) The
 *  Cloud Bigtable service account associated with the project that contains
 *  this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role
 *  on the CMEK key. 2) Only regional keys can be used and the region of the
 *  CMEK key must match the region of the cluster. Values are of the form
 *  `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}`
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyName;

@end


/**
 *  Encryption information for a given resource. If this resource is protected
 *  with customer managed encryption, the in-use Cloud Key Management Service
 *  (Cloud KMS) key version is specified along with its status.
 */
@interface GTLRBigtableAdmin_EncryptionInfo : GTLRObject

/**
 *  Output only. The status of encrypt/decrypt calls on underlying data for this
 *  resource. Regardless of status, the existing data is always encrypted at
 *  rest.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Status *encryptionStatus;

/**
 *  Output only. The type of encryption used to protect this resource.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_EncryptionInfo_EncryptionType_CustomerManagedEncryption
 *        The data backing this resource is encrypted at rest with a key that is
 *        managed by the customer. The in-use version of the key and its status
 *        are populated for CMEK-protected tables. CMEK-protected backups are
 *        pinned to the key version that was in use at the time the backup was
 *        taken. This key version is populated but its status is not tracked and
 *        is reported as `UNKNOWN`. (Value: "CUSTOMER_MANAGED_ENCRYPTION")
 *    @arg @c kGTLRBigtableAdmin_EncryptionInfo_EncryptionType_EncryptionTypeUnspecified
 *        Encryption type was not specified, though data at rest remains
 *        encrypted. (Value: "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRBigtableAdmin_EncryptionInfo_EncryptionType_GoogleDefaultEncryption
 *        The data backing this resource is encrypted at rest with a key that is
 *        fully managed by Google. No key version or status will be populated.
 *        This is the default state. (Value: "GOOGLE_DEFAULT_ENCRYPTION")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Output only. The version of the Cloud KMS key specified in the parent
 *  cluster that is in use for the data underlying this table.
 */
@property(nonatomic, copy, nullable) NSString *kmsKeyVersion;

@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRBigtableAdmin_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Rule for determining which cells to delete during garbage collection.
 */
@interface GTLRBigtableAdmin_GcRule : GTLRObject

/** Delete cells that would be deleted by every nested rule. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Intersection *intersection;

/**
 *  Delete cells in a column older than the given age. Values must be at least
 *  one millisecond, and will be truncated to microsecond granularity.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxAge;

/**
 *  Delete all cells in a column except the most recent N.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxNumVersions;

/**
 *  Delete cells that would be deleted by any nested rule.
 *
 *  Remapped to 'unionProperty' to avoid language reserved word 'union'.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Union *unionProperty;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken
 */
@interface GTLRBigtableAdmin_GenerateConsistencyTokenRequest : GTLRObject
@end


/**
 *  Response message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken
 */
@interface GTLRBigtableAdmin_GenerateConsistencyTokenResponse : GTLRObject

/** The generated consistency token. */
@property(nonatomic, copy, nullable) NSString *consistencyToken;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRBigtableAdmin_GetIamPolicyRequest : GTLRObject

/**
 *  OPTIONAL: A `GetPolicyOptions` object for specifying options to
 *  `GetIamPolicy`.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_GetPolicyOptions *options;

@end


/**
 *  Encapsulates settings provided to GetIamPolicy.
 */
@interface GTLRBigtableAdmin_GetPolicyOptions : GTLRObject

/**
 *  Optional. The maximum policy version that will be used to format the policy.
 *  Valid values are 0, 1, and 3. Requests specifying an invalid value will be
 *  rejected. Requests for policies with any conditional role bindings must
 *  specify version 3. Policies with no conditional role bindings may specify
 *  any valid value or leave the field unset. The policy in the response might
 *  use the policy version that you specified, or it might use a lower policy
 *  version. For example, if you specify version 3, but the policy has no
 *  conditional role bindings, the response uses version 1. To learn which
 *  resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedPolicyVersion;

@end


/**
 *  A tablet is a defined by a start and end key and is explained in
 *  https://cloud.google.com/bigtable/docs/overview#architecture and
 *  https://cloud.google.com/bigtable/docs/performance#optimization. A Hot
 *  tablet is a tablet that exhibits high average cpu usage during the time
 *  interval from start time to end time.
 */
@interface GTLRBigtableAdmin_HotTablet : GTLRObject

/** Tablet End Key (inclusive). */
@property(nonatomic, copy, nullable) NSString *endKey;

/** Output only. The end time of the hot tablet. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  The unique name of the hot tablet. Values are of the form
 *  `projects/{project}/instances/{instance}/clusters/{cluster}/hotTablets/[a-zA-Z0-9_-]*`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The average CPU usage spent by a node on this tablet over the
 *  start_time to end_time time range. The percentage is the amount of CPU used
 *  by the node to serve the tablet, from 0% (tablet was not interacted with) to
 *  100% (the node spent all cycles serving the hot tablet).
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCpuUsagePercent;

/** Tablet Start Key (inclusive). */
@property(nonatomic, copy, nullable) NSString *startKey;

/** Output only. The start time of the hot tablet. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Name of the table that contains the tablet. Values are of the form
 *  `projects/{project}/instances/{instance}/tables/_a-zA-Z0-9*`.
 */
@property(nonatomic, copy, nullable) NSString *tableName;

@end


/**
 *  A collection of Bigtable Tables and the resources that serve them. All
 *  tables in an instance are served from all Clusters in the instance.
 */
@interface GTLRBigtableAdmin_Instance : GTLRObject

/**
 *  Output only. A server-assigned timestamp representing when this Instance was
 *  created. For instances created before this field was added (August 2021),
 *  this value is `seconds: 0, nanos: 1`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. The descriptive name for this instance as it appears in UIs. Can
 *  be changed at any time, but should be kept globally unique to avoid
 *  confusion.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. They can be used to filter resources and aggregate
 *  metrics. * Label keys must be between 1 and 63 characters long and must
 *  conform to the regular expression: `\\p{Ll}\\p{Lo}{0,62}`. * Label values
 *  must be between 0 and 63 characters long and must conform to the regular
 *  expression: `[\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}`. * No more than 64 labels can
 *  be associated with a given resource. * Keys and values must both be under
 *  128 bytes.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Instance_Labels *labels;

/**
 *  The unique name of the instance. Values are of the form
 *  `projects/{project}/instances/a-z+[a-z0-9]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Reserved for future use.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzs;

/**
 *  Output only. The current state of the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Instance_State_Creating The instance is
 *        currently being created, and may be destroyed if the creation process
 *        encounters an error. (Value: "CREATING")
 *    @arg @c kGTLRBigtableAdmin_Instance_State_Ready The instance has been
 *        successfully created and can serve requests to its tables. (Value:
 *        "READY")
 *    @arg @c kGTLRBigtableAdmin_Instance_State_StateNotKnown The state of the
 *        instance could not be determined. (Value: "STATE_NOT_KNOWN")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The type of the instance. Defaults to `PRODUCTION`.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Instance_Type_Development DEPRECATED: Prefer
 *        PRODUCTION for all use cases, as it no longer enforces a higher
 *        minimum node count than DEVELOPMENT. (Value: "DEVELOPMENT")
 *    @arg @c kGTLRBigtableAdmin_Instance_Type_Production An instance meant for
 *        production use. `serve_nodes` must be set on the cluster. (Value:
 *        "PRODUCTION")
 *    @arg @c kGTLRBigtableAdmin_Instance_Type_TypeUnspecified The type of the
 *        instance is unspecified. If set when creating an instance, a
 *        `PRODUCTION` instance will be created. If set when updating an
 *        instance, the type will be left unchanged. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. They can be used to filter resources and aggregate
 *  metrics. * Label keys must be between 1 and 63 characters long and must
 *  conform to the regular expression: `\\p{Ll}\\p{Lo}{0,62}`. * Label values
 *  must be between 0 and 63 characters long and must conform to the regular
 *  expression: `[\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}`. * No more than 64 labels can
 *  be associated with a given resource. * Keys and values must both be under
 *  128 bytes.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBigtableAdmin_Instance_Labels : GTLRObject
@end


/**
 *  A GcRule which deletes cells matching all of the given rules.
 */
@interface GTLRBigtableAdmin_Intersection : GTLRObject

/** Only delete cells which would be deleted by every element of `rules`. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_GcRule *> *rules;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListAppProfiles.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "appProfiles" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListAppProfilesResponse : GTLRCollectionObject

/**
 *  The list of requested app profiles.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_AppProfile *> *appProfiles;

/**
 *  Locations from which AppProfile information could not be retrieved, due to
 *  an outage or some other transient condition. AppProfiles from these
 *  locations may be missing from `app_profiles`. Values are of the form
 *  `projects//locations/`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *failedLocations;

/**
 *  Set if not all app profiles could be returned in a single response. Pass
 *  this value to `page_token` in another request to get the next page of
 *  results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListBackups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListBackupsResponse : GTLRCollectionObject

/**
 *  The list of matching backups.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Backup *> *backups;

/**
 *  `next_page_token` can be sent in a subsequent ListBackups call to fetch more
 *  of the matching backups.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListClusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "clusters" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListClustersResponse : GTLRCollectionObject

/**
 *  The list of requested clusters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Cluster *> *clusters;

/**
 *  Locations from which Cluster information could not be retrieved, due to an
 *  outage or some other transient condition. Clusters from these locations may
 *  be missing from `clusters`, or may only have partial information returned.
 *  Values are of the form `projects//locations/`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *failedLocations;

/** DEPRECATED: This field is unused and ignored. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListHotTablets.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hotTablets" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListHotTabletsResponse : GTLRCollectionObject

/**
 *  List of hot tablets in the tables of the requested cluster that fall within
 *  the requested time range. Hot tablets are ordered by node cpu usage percent.
 *  If there are multiple hot tablets that correspond to the same tablet within
 *  a 15-minute interval, only the hot tablet with the highest node cpu usage
 *  will be included in the response.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_HotTablet *> *hotTablets;

/**
 *  Set if not all hot tablets could be returned in a single response. Pass this
 *  value to `page_token` in another request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListInstances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListInstancesResponse : GTLRCollectionObject

/**
 *  Locations from which Instance information could not be retrieved, due to an
 *  outage or some other transient condition. Instances whose Clusters are all
 *  in one of the failed locations may be missing from `instances`, and
 *  Instances with at least one Cluster in a failed location may only have
 *  partial information returned. Values are of the form `projects//locations/`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *failedLocations;

/**
 *  The list of requested instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Instance *> *instances;

/** DEPRECATED: This field is unused and ignored. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Operation *> *operations;

@end


/**
 *  Response message for google.bigtable.admin.v2.BigtableTableAdmin.ListTables
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "tables" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListTablesResponse : GTLRCollectionObject

/**
 *  Set if not all tables could be returned in a single response. Pass this
 *  value to `page_token` in another request to get the next page of results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The tables present in the requested instance.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Table *> *tables;

@end


/**
 *  A resource that represents Google Cloud Platform location.
 */
@interface GTLRBigtableAdmin_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBigtableAdmin_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Location_Metadata : GTLRObject
@end


/**
 *  A create, update, or delete of a particular column family.
 */
@interface GTLRBigtableAdmin_Modification : GTLRObject

/**
 *  Create a new column family with the specified schema, or fail if one already
 *  exists with the given ID.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ColumnFamily *create;

/**
 *  Drop (delete) the column family with the given ID, or fail if no such family
 *  exists.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *drop;

/**
 *  The ID of the column family to be modified.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Update an existing column family to the specified schema, or fail if no
 *  column family exists with the given ID.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ColumnFamily *update;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies
 */
@interface GTLRBigtableAdmin_ModifyColumnFamiliesRequest : GTLRObject

/**
 *  Required. Modifications to be atomically applied to the specified table's
 *  families. Entries are applied in order, meaning that earlier modifications
 *  can be masked by later ones (in the case of repeated updates to the same
 *  family, for example).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Modification *> *modifications;

@end


/**
 *  Read/write requests are routed to the nearest cluster in the instance, and
 *  will fail over to the nearest cluster that is available in the event of
 *  transient errors or delays. Clusters in a region are considered equidistant.
 *  Choosing this option sacrifices read-your-writes consistency to improve
 *  availability.
 */
@interface GTLRBigtableAdmin_MultiClusterRoutingUseAny : GTLRObject

/**
 *  The set of clusters to route to. The order is ignored; clusters will be
 *  tried in order of distance. If left empty, all clusters are eligible.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *clusterIds;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRBigtableAdmin_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Operation_Response : GTLRObject
@end


/**
 *  Encapsulates progress related information for a Cloud Bigtable long running
 *  operation.
 */
@interface GTLRBigtableAdmin_OperationProgress : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Percent completion of the operation. Values are between 0 and 100 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *progressPercent;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Metadata type for the long-running operation used to track the progress of
 *  optimizations performed on a newly restored table. This long-running
 *  operation is automatically created by the system after the successful
 *  completion of a table restore, and cannot be cancelled.
 */
@interface GTLRBigtableAdmin_OptimizeRestoredTableMetadata : GTLRObject

/** Name of the restored table being optimized. */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the post-restore optimizations. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_OperationProgress *progress;

@end


/**
 *  The metadata for the Operation returned by PartialUpdateCluster.
 */
@interface GTLRBigtableAdmin_PartialUpdateClusterMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/** The original request for PartialUpdateCluster. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_PartialUpdateClusterRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end


/**
 *  Request message for BigtableInstanceAdmin.PartialUpdateCluster.
 */
@interface GTLRBigtableAdmin_PartialUpdateClusterRequest : GTLRObject

/**
 *  Required. The Cluster which contains the partial updates to be applied,
 *  subject to the update_mask.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Cluster *cluster;

/**
 *  Required. The subset of Cluster fields which should be replaced.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Request message for BigtableInstanceAdmin.PartialUpdateInstance.
 */
@interface GTLRBigtableAdmin_PartialUpdateInstanceRequest : GTLRObject

/**
 *  Required. The Instance which will (partially) replace the current value.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Instance *instance;

/**
 *  Required. The subset of Instance fields which should be replaced. Must be
 *  explicitly set.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRBigtableAdmin_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Information about a table restore.
 */
@interface GTLRBigtableAdmin_RestoreInfo : GTLRObject

/**
 *  Information about the backup used to restore the table. The backup may no
 *  longer exist.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_BackupInfo *backupInfo;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_RestoreInfo_SourceType_Backup A backup was used
 *        as the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRBigtableAdmin_RestoreInfo_SourceType_RestoreSourceTypeUnspecified
 *        No restore associated. (Value: "RESTORE_SOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  Metadata type for the long-running operation returned by RestoreTable.
 */
@interface GTLRBigtableAdmin_RestoreTableMetadata : GTLRObject

@property(nonatomic, strong, nullable) GTLRBigtableAdmin_BackupInfo *backupInfo;

/** Name of the table being created and restored to. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If exists, the name of the long-running operation that will be used to track
 *  the post-restore optimization process to optimize the performance of the
 *  restored table. The metadata type of the long-running operation is
 *  OptimizeRestoreTableMetadata. The response type is Empty. This long-running
 *  operation may be automatically created by the system if applicable after the
 *  RestoreTable long-running operation completes successfully. This operation
 *  may not be created if the table is already optimized or the restore was not
 *  successful.
 */
@property(nonatomic, copy, nullable) NSString *optimizeTableOperationName;

/** The progress of the RestoreTable operation. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_OperationProgress *progress;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_RestoreTableMetadata_SourceType_Backup A backup
 *        was used as the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRBigtableAdmin_RestoreTableMetadata_SourceType_RestoreSourceTypeUnspecified
 *        No restore associated. (Value: "RESTORE_SOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  The request for RestoreTable.
 */
@interface GTLRBigtableAdmin_RestoreTableRequest : GTLRObject

/**
 *  Name of the backup from which to restore. Values are of the form
 *  `projects//instances//clusters//backups/`.
 */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  Required. The id of the table to create and restore to. This table must not
 *  already exist. The `table_id` appended to `parent` forms the full table name
 *  of the form `projects//instances//tables/`.
 */
@property(nonatomic, copy, nullable) NSString *tableId;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRBigtableAdmin_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Unconditionally routes all read/write requests to a specific cluster. This
 *  option preserves read-your-writes consistency but does not improve
 *  availability.
 */
@interface GTLRBigtableAdmin_SingleClusterRouting : GTLRObject

/**
 *  Whether or not `CheckAndMutateRow` and `ReadModifyWriteRow` requests are
 *  allowed by this app profile. It is unsafe to send these requests to the same
 *  table/row/column in multiple clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowTransactionalWrites;

/** The cluster to which read/write requests should be routed. */
@property(nonatomic, copy, nullable) NSString *clusterId;

@end


/**
 *  An initial split point for a newly created table.
 */
@interface GTLRBigtableAdmin_Split : GTLRObject

/**
 *  Row key to use as an initial tablet boundary.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *key;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRBigtableAdmin_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRBigtableAdmin_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Status_Details_Item : GTLRObject
@end


/**
 *  A collection of user data indexed by row, column, and timestamp. Each table
 *  is served using the resources of its parent cluster.
 */
@interface GTLRBigtableAdmin_Table : GTLRObject

/**
 *  Output only. Map from cluster ID to per-cluster table state. If it could not
 *  be determined whether or not the table has data in a particular cluster (for
 *  example, if its zone is unavailable), then there will be an entry for the
 *  cluster with UNKNOWN `replication_status`. Views: `REPLICATION_VIEW`,
 *  `ENCRYPTION_VIEW`, `FULL`
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Table_ClusterStates *clusterStates;

/**
 *  The column families configured for this table, mapped by column family ID.
 *  Views: `SCHEMA_VIEW`, `STATS_VIEW`, `FULL`
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Table_ColumnFamilies *columnFamilies;

/**
 *  Set to true to make the table protected against data loss. i.e. deleting the
 *  following resources through Admin APIs are prohibited: - The table. - The
 *  column families in the table. - The instance containing the table. Note one
 *  can still delete the data stored in the table through Data APIs.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deletionProtection;

/**
 *  Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored in
 *  this table. Timestamps not matching the granularity will be rejected. If
 *  unspecified at creation time, the value will be set to `MILLIS`. Views:
 *  `SCHEMA_VIEW`, `FULL`.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Table_Granularity_Millis The table keeps data
 *        versioned at a granularity of 1ms. (Value: "MILLIS")
 *    @arg @c kGTLRBigtableAdmin_Table_Granularity_TimestampGranularityUnspecified
 *        The user did not specify a granularity. Should not be returned. When
 *        specified during table creation, MILLIS will be used. (Value:
 *        "TIMESTAMP_GRANULARITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *granularity;

/**
 *  The unique name of the table. Values are of the form
 *  `projects/{project}/instances/{instance}/tables/_a-zA-Z0-9*`. Views:
 *  `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `STATS_VIEW`, `FULL`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. If this table was restored from another data source (e.g. a
 *  backup), this field will be populated with information about the restore.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_RestoreInfo *restoreInfo;

/**
 *  Only available with STATS_VIEW, this includes summary statistics about the
 *  entire table contents. For statistics about a specific column family, see
 *  ColumnFamilyStats in the mapped ColumnFamily collection above.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_TableStats *stats;

@end


/**
 *  Output only. Map from cluster ID to per-cluster table state. If it could not
 *  be determined whether or not the table has data in a particular cluster (for
 *  example, if its zone is unavailable), then there will be an entry for the
 *  cluster with UNKNOWN `replication_status`. Views: `REPLICATION_VIEW`,
 *  `ENCRYPTION_VIEW`, `FULL`
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_ClusterState. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Table_ClusterStates : GTLRObject
@end


/**
 *  The column families configured for this table, mapped by column family ID.
 *  Views: `SCHEMA_VIEW`, `STATS_VIEW`, `FULL`
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_ColumnFamily. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Table_ColumnFamilies : GTLRObject
@end


/**
 *  Progress info for copying a table's data to the new cluster.
 */
@interface GTLRBigtableAdmin_TableProgress : GTLRObject

/**
 *  Estimate of the number of bytes copied so far for this table. This will
 *  eventually reach 'estimated_size_bytes' unless the table copy is CANCELLED.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *estimatedCopiedBytes;

/**
 *  Estimate of the size of the table to be copied.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *estimatedSizeBytes;

/**
 *  state
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Cancelled The table was
 *        deleted before it finished copying to the new cluster. Note that
 *        tables deleted after completion will stay marked as COMPLETED, not
 *        CANCELLED. (Value: "CANCELLED")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Completed The table has
 *        been fully copied to the new cluster. (Value: "COMPLETED")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Copying The table is
 *        actively being copied to the new cluster. (Value: "COPYING")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Pending The table has not
 *        yet begun copying to the new cluster. (Value: "PENDING")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_StateUnspecified Value
 *        "STATE_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Approximate statistics related to a table. These statistics are calculated
 *  infrequently, while simultaneously, data in the table can change rapidly.
 *  Thus the values reported here (e.g. row count) are very likely out-of date,
 *  even the instant they are received in this API. Thus, only treat these
 *  values as approximate. IMPORTANT: Everything below is approximate, unless
 *  otherwise specified.
 */
@interface GTLRBigtableAdmin_TableStats : GTLRObject

/**
 *  How many cells are present per column (column family, column qualifier)
 *  combinations, averaged over all columns in all rows in the table. e.g. A
 *  table with 2 rows: * A row with 3 cells in "family:col" and 1 cell in
 *  "other:col" (4 cells / 2 columns) * A row with 1 cell in "family:col", 7
 *  cells in "family:other_col", and 7 cells in "other:data" (15 cells / 3
 *  columns) would report (4 + 15)/(2 + 3) = 3.8 in this field.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *averageCellsPerColumn;

/**
 *  How many (column family, column qualifier) combinations are present per row
 *  in the table, averaged over all rows in the table. e.g. A table with 2 rows:
 *  * A row with cells in "family:col" and "other:col" (2 distinct columns) * A
 *  row with cells in "family:col", "family:other_col", and "other:data" (3
 *  distinct columns) would report (2 + 3)/2 = 2.5 in this field.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *averageColumnsPerRow;

/**
 *  This is roughly how many bytes would be needed to read the entire table
 *  (e.g. by streaming all contents out).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logicalDataBytes;

/**
 *  How many rows are in the table.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCount;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRBigtableAdmin_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRBigtableAdmin_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Metadata type for the operation returned by
 *  google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable.
 */
@interface GTLRBigtableAdmin_UndeleteTableMetadata : GTLRObject

/** If set, the time at which this operation finished or was cancelled. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The name of the table being restored. */
@property(nonatomic, copy, nullable) NSString *name;

/** The time at which this operation started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable
 */
@interface GTLRBigtableAdmin_UndeleteTableRequest : GTLRObject
@end


/**
 *  A GcRule which deletes cells matching any of the given rules.
 */
@interface GTLRBigtableAdmin_Union : GTLRObject

/** Delete cells which would be deleted by any element of `rules`. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_GcRule *> *rules;

@end


/**
 *  The metadata for the Operation returned by UpdateAppProfile.
 */
@interface GTLRBigtableAdmin_UpdateAppProfileMetadata : GTLRObject
@end


/**
 *  The metadata for the Operation returned by UpdateCluster.
 */
@interface GTLRBigtableAdmin_UpdateClusterMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this UpdateCluster operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Cluster *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end


/**
 *  The metadata for the Operation returned by UpdateInstance.
 */
@interface GTLRBigtableAdmin_UpdateInstanceMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this UpdateInstance operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_PartialUpdateInstanceRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end


/**
 *  Metadata type for the operation returned by UpdateTable.
 */
@interface GTLRBigtableAdmin_UpdateTableMetadata : GTLRObject

/** If set, the time at which this operation finished or was canceled. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The name of the table being updated. */
@property(nonatomic, copy, nullable) NSString *name;

/** The time at which this operation started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
