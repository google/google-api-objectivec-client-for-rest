// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Monitoring API (monitoring/v3)
// Description:
//   Manages your Cloud Monitoring data and configurations.
// Documentation:
//   https://cloud.google.com/monitoring/api/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_Aggregation;
@class GTLRMonitoring_AlertPolicy;
@class GTLRMonitoring_AlertPolicy_UserLabels;
@class GTLRMonitoring_AlertStrategy;
@class GTLRMonitoring_AppEngine;
@class GTLRMonitoring_AvailabilityCriteria;
@class GTLRMonitoring_BasicAuthentication;
@class GTLRMonitoring_BasicService;
@class GTLRMonitoring_BasicService_ServiceLabels;
@class GTLRMonitoring_BasicSli;
@class GTLRMonitoring_BucketOptions;
@class GTLRMonitoring_CloudEndpoints;
@class GTLRMonitoring_CloudRun;
@class GTLRMonitoring_ClusterIstio;
@class GTLRMonitoring_CollectdPayload;
@class GTLRMonitoring_CollectdPayload_Metadata;
@class GTLRMonitoring_CollectdPayloadError;
@class GTLRMonitoring_CollectdValue;
@class GTLRMonitoring_CollectdValueError;
@class GTLRMonitoring_Condition;
@class GTLRMonitoring_ContentMatcher;
@class GTLRMonitoring_CreateTimeSeriesSummary;
@class GTLRMonitoring_Custom;
@class GTLRMonitoring_Distribution;
@class GTLRMonitoring_DistributionCut;
@class GTLRMonitoring_Documentation;
@class GTLRMonitoring_DroppedLabels_Label;
@class GTLRMonitoring_Error;
@class GTLRMonitoring_Exemplar;
@class GTLRMonitoring_Exemplar_Attachments_Item;
@class GTLRMonitoring_Explicit;
@class GTLRMonitoring_Exponential;
@class GTLRMonitoring_Field;
@class GTLRMonitoring_GkeNamespace;
@class GTLRMonitoring_GkeService;
@class GTLRMonitoring_GkeWorkload;
@class GTLRMonitoring_GoogleMonitoringV3Range;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_HttpCheck;
@class GTLRMonitoring_HttpCheck_Headers;
@class GTLRMonitoring_InternalChecker;
@class GTLRMonitoring_IstioCanonicalService;
@class GTLRMonitoring_JsonPathMatcher;
@class GTLRMonitoring_LabelDescriptor;
@class GTLRMonitoring_LabelValue;
@class GTLRMonitoring_LatencyCriteria;
@class GTLRMonitoring_Linear;
@class GTLRMonitoring_LogMatch;
@class GTLRMonitoring_LogMatch_LabelExtractors;
@class GTLRMonitoring_MeshIstio;
@class GTLRMonitoring_Metric;
@class GTLRMonitoring_Metric_Labels;
@class GTLRMonitoring_MetricAbsence;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_MetricDescriptorMetadata;
@class GTLRMonitoring_MetricRange;
@class GTLRMonitoring_MetricThreshold;
@class GTLRMonitoring_MonitoredResource;
@class GTLRMonitoring_MonitoredResource_Labels;
@class GTLRMonitoring_MonitoredResourceDescriptor;
@class GTLRMonitoring_MonitoredResourceMetadata;
@class GTLRMonitoring_MonitoredResourceMetadata_SystemLabels;
@class GTLRMonitoring_MonitoredResourceMetadata_UserLabels;
@class GTLRMonitoring_MutationRecord;
@class GTLRMonitoring_NotificationChannel;
@class GTLRMonitoring_NotificationChannel_Labels;
@class GTLRMonitoring_NotificationChannel_UserLabels;
@class GTLRMonitoring_NotificationChannelDescriptor;
@class GTLRMonitoring_NotificationRateLimit;
@class GTLRMonitoring_Option;
@class GTLRMonitoring_Option_Value;
@class GTLRMonitoring_PerformanceThreshold;
@class GTLRMonitoring_PingConfig;
@class GTLRMonitoring_Point;
@class GTLRMonitoring_PointData;
@class GTLRMonitoring_QueryLanguageCondition;
@class GTLRMonitoring_Range;
@class GTLRMonitoring_RequestBasedSli;
@class GTLRMonitoring_ResourceGroup;
@class GTLRMonitoring_ResponseStatusCode;
@class GTLRMonitoring_Service;
@class GTLRMonitoring_Service_UserLabels;
@class GTLRMonitoring_ServiceLevelIndicator;
@class GTLRMonitoring_ServiceLevelObjective;
@class GTLRMonitoring_ServiceLevelObjective_UserLabels;
@class GTLRMonitoring_SourceContext;
@class GTLRMonitoring_Status;
@class GTLRMonitoring_Status_Details_Item;
@class GTLRMonitoring_TcpCheck;
@class GTLRMonitoring_Telemetry;
@class GTLRMonitoring_TimeInterval;
@class GTLRMonitoring_TimeSeries;
@class GTLRMonitoring_TimeSeriesData;
@class GTLRMonitoring_TimeSeriesDescriptor;
@class GTLRMonitoring_TimeSeriesRatio;
@class GTLRMonitoring_Trigger;
@class GTLRMonitoring_TypedValue;
@class GTLRMonitoring_UptimeCheckConfig;
@class GTLRMonitoring_UptimeCheckConfig_UserLabels;
@class GTLRMonitoring_UptimeCheckIp;
@class GTLRMonitoring_ValueDescriptor;
@class GTLRMonitoring_WindowsBasedSli;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRMonitoring_Aggregation.crossSeriesReducer

/**
 *  Reduce by computing the number of data points across time series for each
 *  alignment period. This reducer is valid for DELTA and GAUGE metrics of
 *  numeric, Boolean, distribution, and string value_type. The value_type of the
 *  output is INT64.
 *
 *  Value: "REDUCE_COUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCount;
/**
 *  Reduce by computing the number of False-valued data points across time
 *  series for each alignment period. This reducer is valid for DELTA and GAUGE
 *  metrics of Boolean value_type. The value_type of the output is INT64.
 *
 *  Value: "REDUCE_COUNT_FALSE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountFalse;
/**
 *  Reduce by computing the number of True-valued data points across time series
 *  for each alignment period. This reducer is valid for DELTA and GAUGE metrics
 *  of Boolean value_type. The value_type of the output is INT64.
 *
 *  Value: "REDUCE_COUNT_TRUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountTrue;
/**
 *  Reduce by computing the ratio of the number of True-valued data points to
 *  the total number of data points for each alignment period. This reducer is
 *  valid for DELTA and GAUGE metrics of Boolean value_type. The output value is
 *  in the range 0.0, 1.0 and has value_type DOUBLE.
 *
 *  Value: "REDUCE_FRACTION_TRUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceFractionTrue;
/**
 *  Reduce by computing the maximum value across time series for each alignment
 *  period. This reducer is valid for DELTA and GAUGE metrics with numeric
 *  values. The value_type of the output is the same as the value_type of the
 *  input.
 *
 *  Value: "REDUCE_MAX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMax;
/**
 *  Reduce by computing the mean value across time series for each alignment
 *  period. This reducer is valid for DELTA and GAUGE metrics with numeric or
 *  distribution values. The value_type of the output is DOUBLE.
 *
 *  Value: "REDUCE_MEAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMean;
/**
 *  Reduce by computing the minimum value across time series for each alignment
 *  period. This reducer is valid for DELTA and GAUGE metrics with numeric
 *  values. The value_type of the output is the same as the value_type of the
 *  input.
 *
 *  Value: "REDUCE_MIN"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMin;
/**
 *  No cross-time series reduction. The output of the Aligner is returned.
 *
 *  Value: "REDUCE_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceNone;
/**
 *  Reduce by computing the 5th percentile
 *  (https://en.wikipedia.org/wiki/Percentile) of data points across time series
 *  for each alignment period. This reducer is valid for GAUGE and DELTA metrics
 *  of numeric and distribution type. The value of the output is DOUBLE.
 *
 *  Value: "REDUCE_PERCENTILE_05"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile05;
/**
 *  Reduce by computing the 50th percentile
 *  (https://en.wikipedia.org/wiki/Percentile) of data points across time series
 *  for each alignment period. This reducer is valid for GAUGE and DELTA metrics
 *  of numeric and distribution type. The value of the output is DOUBLE.
 *
 *  Value: "REDUCE_PERCENTILE_50"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile50;
/**
 *  Reduce by computing the 95th percentile
 *  (https://en.wikipedia.org/wiki/Percentile) of data points across time series
 *  for each alignment period. This reducer is valid for GAUGE and DELTA metrics
 *  of numeric and distribution type. The value of the output is DOUBLE.
 *
 *  Value: "REDUCE_PERCENTILE_95"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile95;
/**
 *  Reduce by computing the 99th percentile
 *  (https://en.wikipedia.org/wiki/Percentile) of data points across time series
 *  for each alignment period. This reducer is valid for GAUGE and DELTA metrics
 *  of numeric and distribution type. The value of the output is DOUBLE.
 *
 *  Value: "REDUCE_PERCENTILE_99"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile99;
/**
 *  Reduce by computing the standard deviation across time series for each
 *  alignment period. This reducer is valid for DELTA and GAUGE metrics with
 *  numeric or distribution values. The value_type of the output is DOUBLE.
 *
 *  Value: "REDUCE_STDDEV"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceStddev;
/**
 *  Reduce by computing the sum across time series for each alignment period.
 *  This reducer is valid for DELTA and GAUGE metrics with numeric and
 *  distribution values. The value_type of the output is the same as the
 *  value_type of the input.
 *
 *  Value: "REDUCE_SUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceSum;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Aggregation.perSeriesAligner

/**
 *  Align the time series by returning the number of values in each alignment
 *  period. This aligner is valid for GAUGE and DELTA metrics with numeric or
 *  Boolean values. The value_type of the aligned result is INT64.
 *
 *  Value: "ALIGN_COUNT"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCount;
/**
 *  Align the time series by returning the number of False values in each
 *  alignment period. This aligner is valid for GAUGE metrics with Boolean
 *  values. The value_type of the output is INT64.
 *
 *  Value: "ALIGN_COUNT_FALSE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountFalse;
/**
 *  Align the time series by returning the number of True values in each
 *  alignment period. This aligner is valid for GAUGE metrics with Boolean
 *  values. The value_type of the output is INT64.
 *
 *  Value: "ALIGN_COUNT_TRUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountTrue;
/**
 *  Align and convert to DELTA. The output is delta = y1 - y0.This alignment is
 *  valid for CUMULATIVE and DELTA metrics. If the selected alignment period
 *  results in periods with no data, then the aligned value for such a period is
 *  created by interpolation. The value_type of the aligned result is the same
 *  as the value_type of the input.
 *
 *  Value: "ALIGN_DELTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignDelta;
/**
 *  Align the time series by returning the ratio of the number of True values to
 *  the total number of values in each alignment period. This aligner is valid
 *  for GAUGE metrics with Boolean values. The output value is in the range 0.0,
 *  1.0 and has value_type DOUBLE.
 *
 *  Value: "ALIGN_FRACTION_TRUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignFractionTrue;
/**
 *  Align by interpolating between adjacent points around the alignment period
 *  boundary. This aligner is valid for GAUGE metrics with numeric values. The
 *  value_type of the aligned result is the same as the value_type of the input.
 *
 *  Value: "ALIGN_INTERPOLATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignInterpolate;
/**
 *  Align the time series by returning the maximum value in each alignment
 *  period. This aligner is valid for GAUGE and DELTA metrics with numeric
 *  values. The value_type of the aligned result is the same as the value_type
 *  of the input.
 *
 *  Value: "ALIGN_MAX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMax;
/**
 *  Align the time series by returning the mean value in each alignment period.
 *  This aligner is valid for GAUGE and DELTA metrics with numeric values. The
 *  value_type of the aligned result is DOUBLE.
 *
 *  Value: "ALIGN_MEAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMean;
/**
 *  Align the time series by returning the minimum value in each alignment
 *  period. This aligner is valid for GAUGE and DELTA metrics with numeric
 *  values. The value_type of the aligned result is the same as the value_type
 *  of the input.
 *
 *  Value: "ALIGN_MIN"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMin;
/**
 *  Align by moving the most recent data point before the end of the alignment
 *  period to the boundary at the end of the alignment period. This aligner is
 *  valid for GAUGE metrics. The value_type of the aligned result is the same as
 *  the value_type of the input.
 *
 *  Value: "ALIGN_NEXT_OLDER"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNextOlder;
/**
 *  No alignment. Raw data is returned. Not valid if cross-series reduction is
 *  requested. The value_type of the result is the same as the value_type of the
 *  input.
 *
 *  Value: "ALIGN_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNone;
/**
 *  Align and convert to a percentage change. This aligner is valid for GAUGE
 *  and DELTA metrics with numeric values. This alignment returns ((current -
 *  previous)/previous) * 100, where the value of previous is determined based
 *  on the alignment_period.If the values of current and previous are both 0,
 *  then the returned value is 0. If only previous is 0, the returned value is
 *  infinity.A 10-minute moving mean is computed at each point of the alignment
 *  period prior to the above calculation to smooth the metric and prevent false
 *  positives from very short-lived spikes. The moving mean is only applicable
 *  for data whose values are >= 0. Any values < 0 are treated as a missing
 *  datapoint, and are ignored. While DELTA metrics are accepted by this
 *  alignment, special care should be taken that the values for the metric will
 *  always be positive. The output is a GAUGE metric with value_type DOUBLE.
 *
 *  Value: "ALIGN_PERCENT_CHANGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentChange;
/**
 *  Align the time series by using percentile aggregation
 *  (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each
 *  alignment period is the 5th percentile of all data points in the period.
 *  This aligner is valid for GAUGE and DELTA metrics with distribution values.
 *  The output is a GAUGE metric with value_type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_05"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile05;
/**
 *  Align the time series by using percentile aggregation
 *  (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each
 *  alignment period is the 50th percentile of all data points in the period.
 *  This aligner is valid for GAUGE and DELTA metrics with distribution values.
 *  The output is a GAUGE metric with value_type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_50"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile50;
/**
 *  Align the time series by using percentile aggregation
 *  (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each
 *  alignment period is the 95th percentile of all data points in the period.
 *  This aligner is valid for GAUGE and DELTA metrics with distribution values.
 *  The output is a GAUGE metric with value_type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_95"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile95;
/**
 *  Align the time series by using percentile aggregation
 *  (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each
 *  alignment period is the 99th percentile of all data points in the period.
 *  This aligner is valid for GAUGE and DELTA metrics with distribution values.
 *  The output is a GAUGE metric with value_type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_99"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile99;
/**
 *  Align and convert to a rate. The result is computed as rate = (y1 - y0)/(t1
 *  - t0), or "delta over time". Think of this aligner as providing the slope of
 *  the line that passes through the value at the start and at the end of the
 *  alignment_period.This aligner is valid for CUMULATIVE and DELTA metrics with
 *  numeric values. If the selected alignment period results in periods with no
 *  data, then the aligned value for such a period is created by interpolation.
 *  The output is a GAUGE metric with value_type DOUBLE.If, by "rate", you mean
 *  "percentage change", see the ALIGN_PERCENT_CHANGE aligner instead.
 *
 *  Value: "ALIGN_RATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignRate;
/**
 *  Align the time series by returning the standard deviation of the values in
 *  each alignment period. This aligner is valid for GAUGE and DELTA metrics
 *  with numeric values. The value_type of the output is DOUBLE.
 *
 *  Value: "ALIGN_STDDEV"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignStddev;
/**
 *  Align the time series by returning the sum of the values in each alignment
 *  period. This aligner is valid for GAUGE and DELTA metrics with numeric and
 *  distribution values. The value_type of the aligned result is the same as the
 *  value_type of the input.
 *
 *  Value: "ALIGN_SUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignSum;

// ----------------------------------------------------------------------------
// GTLRMonitoring_AlertPolicy.combiner

/**
 *  Combine conditions using the logical AND operator. An incident is created
 *  only if all the conditions are met simultaneously. This combiner is
 *  satisfied if all conditions are met, even if they are met on completely
 *  different resources.
 *
 *  Value: "AND"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_And;
/**
 *  Combine conditions using logical AND operator, but unlike the regular AND
 *  option, an incident is created only if all conditions are met simultaneously
 *  on at least one resource.
 *
 *  Value: "AND_WITH_MATCHING_RESOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_AndWithMatchingResource;
/**
 *  An unspecified combiner.
 *
 *  Value: "COMBINE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_CombineUnspecified;
/**
 *  Combine conditions using the logical OR operator. An incident is created if
 *  any of the listed conditions is met.
 *
 *  Value: "OR"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_Or;

// ----------------------------------------------------------------------------
// GTLRMonitoring_CollectdValue.dataSourceType

/**
 *  An amount of change since the last measurement interval. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.DELTA.
 *
 *  Value: "ABSOLUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Absolute;
/**
 *  A cumulative value over time. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.CUMULATIVE.
 *
 *  Value: "COUNTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Counter;
/**
 *  A rate of change of the measurement.
 *
 *  Value: "DERIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Derive;
/**
 *  An instantaneous measurement of a varying quantity. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.GAUGE.
 *
 *  Value: "GAUGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Gauge;
/**
 *  An unspecified data source type. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *
 *  Value: "UNSPECIFIED_DATA_SOURCE_TYPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ContentMatcher.matcher

/**
 *  Selects substring matching. The match succeeds if the output contains the
 *  content string. This is the default value for checks without a matcher
 *  option, or where the value of matcher is CONTENT_MATCHER_OPTION_UNSPECIFIED.
 *
 *  Value: "CONTAINS_STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_ContainsString;
/**
 *  No content matcher type specified (maintained for backward compatibility,
 *  but deprecated for future use). Treated as CONTAINS_STRING.
 *
 *  Value: "CONTENT_MATCHER_OPTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_ContentMatcherOptionUnspecified;
/**
 *  Selects JSONPath matching. See JsonPathMatcher for details on when the match
 *  succeeds. JSONPath matching is only supported for HTTP/HTTPS checks.
 *
 *  Value: "MATCHES_JSON_PATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_MatchesJsonPath;
/**
 *  Selects regular-expression matching. The match succeeds if the output
 *  matches the regular expression specified in the content string. Regex
 *  matching is only supported for HTTP/HTTPS checks.
 *
 *  Value: "MATCHES_REGEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_MatchesRegex;
/**
 *  Selects negation of substring matching. The match succeeds if the output
 *  does NOT contain the content string.
 *
 *  Value: "NOT_CONTAINS_STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_NotContainsString;
/**
 *  Selects JSONPath matching. See JsonPathMatcher for details on when the match
 *  succeeds. Succeeds when output does NOT match as specified. JSONPath is only
 *  supported for HTTP/HTTPS checks.
 *
 *  Value: "NOT_MATCHES_JSON_PATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_NotMatchesJsonPath;
/**
 *  Selects negation of regular-expression matching. The match succeeds if the
 *  output does NOT match the regular expression specified in the content
 *  string. Regex matching is only supported for HTTP/HTTPS checks.
 *
 *  Value: "NOT_MATCHES_REGEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ContentMatcher_Matcher_NotMatchesRegex;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.cardinality

/**
 *  For optional fields.
 *
 *  Value: "CARDINALITY_OPTIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityOptional;
/**
 *  For repeated fields.
 *
 *  Value: "CARDINALITY_REPEATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRepeated;
/**
 *  For required fields. Proto2 syntax only.
 *
 *  Value: "CARDINALITY_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRequired;
/**
 *  For fields with unknown cardinality.
 *
 *  Value: "CARDINALITY_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.kind

/**
 *  Field type bool.
 *
 *  Value: "TYPE_BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBool;
/**
 *  Field type bytes.
 *
 *  Value: "TYPE_BYTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBytes;
/**
 *  Field type double.
 *
 *  Value: "TYPE_DOUBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeDouble;
/**
 *  Field type enum.
 *
 *  Value: "TYPE_ENUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeEnum;
/**
 *  Field type fixed32.
 *
 *  Value: "TYPE_FIXED32"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed32;
/**
 *  Field type fixed64.
 *
 *  Value: "TYPE_FIXED64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed64;
/**
 *  Field type float.
 *
 *  Value: "TYPE_FLOAT"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFloat;
/**
 *  Field type group. Proto2 syntax only, and deprecated.
 *
 *  Value: "TYPE_GROUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeGroup;
/**
 *  Field type int32.
 *
 *  Value: "TYPE_INT32"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt32;
/**
 *  Field type int64.
 *
 *  Value: "TYPE_INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt64;
/**
 *  Field type message.
 *
 *  Value: "TYPE_MESSAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeMessage;
/**
 *  Field type sfixed32.
 *
 *  Value: "TYPE_SFIXED32"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed32;
/**
 *  Field type sfixed64.
 *
 *  Value: "TYPE_SFIXED64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed64;
/**
 *  Field type sint32.
 *
 *  Value: "TYPE_SINT32"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint32;
/**
 *  Field type sint64.
 *
 *  Value: "TYPE_SINT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint64;
/**
 *  Field type string.
 *
 *  Value: "TYPE_STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeString;
/**
 *  Field type uint32.
 *
 *  Value: "TYPE_UINT32"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint32;
/**
 *  Field type uint64.
 *
 *  Value: "TYPE_UINT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint64;
/**
 *  Field type unknown.
 *
 *  Value: "TYPE_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_HttpCheck.contentType

/**
 *  No content type specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_HttpCheck_ContentType_TypeUnspecified;
/**
 *  body is in URL-encoded form. Equivalent to setting the Content-Type to
 *  application/x-www-form-urlencoded in the HTTP request.
 *
 *  Value: "URL_ENCODED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_HttpCheck_ContentType_UrlEncoded;

// ----------------------------------------------------------------------------
// GTLRMonitoring_HttpCheck.requestMethod

/**
 *  GET request.
 *
 *  Value: "GET"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_HttpCheck_RequestMethod_Get;
/**
 *  No request method specified.
 *
 *  Value: "METHOD_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_HttpCheck_RequestMethod_MethodUnspecified;
/**
 *  POST request.
 *
 *  Value: "POST"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_HttpCheck_RequestMethod_Post;

// ----------------------------------------------------------------------------
// GTLRMonitoring_InternalChecker.state

/**
 *  The checker is being created, provisioned, and configured. A checker in this
 *  state can be returned by ListInternalCheckers or GetInternalChecker, as well
 *  as by examining the long running Operation
 *  (https://cloud.google.com/apis/design/design_patterns#long_running_operations)
 *  that created it.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_InternalChecker_State_Creating;
/**
 *  The checker is running and available for use. A checker in this state can be
 *  returned by ListInternalCheckers or GetInternalChecker as well as by
 *  examining the long running Operation
 *  (https://cloud.google.com/apis/design/design_patterns#long_running_operations)
 *  that created it. If a checker is being torn down, it is neither visible nor
 *  usable, so there is no "deleting" or "down" state.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_InternalChecker_State_Running;
/**
 *  An internal checker should never be in the unspecified state.
 *
 *  Value: "UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_InternalChecker_State_Unspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_JsonPathMatcher.jsonMatcher

/**
 *  Selects 'exact string' matching. The match succeeds if the content at the
 *  json_path within the output is exactly the same as the content string.
 *
 *  Value: "EXACT_MATCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_JsonPathMatcher_JsonMatcher_ExactMatch;
/**
 *  No JSONPath matcher type specified (not valid).
 *
 *  Value: "JSON_PATH_MATCHER_OPTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_JsonPathMatcher_JsonMatcher_JsonPathMatcherOptionUnspecified;
/**
 *  Selects regular-expression matching. The match succeeds if the content at
 *  the json_path within the output matches the regular expression specified in
 *  the content string.
 *
 *  Value: "REGEX_MATCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_JsonPathMatcher_JsonMatcher_RegexMatch;

// ----------------------------------------------------------------------------
// GTLRMonitoring_LabelDescriptor.valueType

/**
 *  Boolean; true or false.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Bool;
/**
 *  A 64-bit signed integer.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Int64;
/**
 *  A variable-length string, not to exceed 1,024 characters. This is the
 *  default value type.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_String;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.launchStage

/**
 *  Alpha is a limited availability test for releases before they are cleared
 *  for widespread use. By Alpha, all significant design issues are resolved and
 *  we are in the process of verifying functionality. Alpha customers need to
 *  apply for access, agree to applicable terms, and have their projects
 *  allowlisted. Alpha releases don't have to be feature complete, no SLAs are
 *  provided, and there are no technical support obligations, but they will be
 *  far enough along that customers can actually use them in test environments
 *  or for limited-use tests -- just like they would in normal production cases.
 *
 *  Value: "ALPHA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_Alpha;
/**
 *  Beta is the point at which we are ready to open a release for any customer
 *  to use. There are no SLA or technical support obligations in a Beta release.
 *  Products will be complete from a feature perspective, but may have some open
 *  outstanding issues. Beta releases are suitable for limited production use
 *  cases.
 *
 *  Value: "BETA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_Beta;
/**
 *  Deprecated features are scheduled to be shut down and removed. For more
 *  information, see the "Deprecation Policy" section of our Terms of Service
 *  (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to
 *  the Deprecation Policy (https://cloud.google.com/terms/deprecation)
 *  documentation.
 *
 *  Value: "DEPRECATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_Deprecated;
/**
 *  Early Access features are limited to a closed group of testers. To use these
 *  features, you must sign up in advance and sign a Trusted Tester agreement
 *  (which includes confidentiality provisions). These features may be unstable,
 *  changed in backward-incompatible ways, and are not guaranteed to be
 *  released.
 *
 *  Value: "EARLY_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_EarlyAccess;
/**
 *  GA features are open to all developers and are considered stable and fully
 *  qualified for production use.
 *
 *  Value: "GA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_Ga;
/**
 *  Do not use this default value.
 *
 *  Value: "LAUNCH_STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_LaunchStageUnspecified;
/**
 *  Prelaunch features are hidden from users and are only visible internally.
 *
 *  Value: "PRELAUNCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_Prelaunch;
/**
 *  The feature is not yet implemented. Users can not use it.
 *
 *  Value: "UNIMPLEMENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_LaunchStage_Unimplemented;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptorMetadata.launchStage

/**
 *  Alpha is a limited availability test for releases before they are cleared
 *  for widespread use. By Alpha, all significant design issues are resolved and
 *  we are in the process of verifying functionality. Alpha customers need to
 *  apply for access, agree to applicable terms, and have their projects
 *  allowlisted. Alpha releases don't have to be feature complete, no SLAs are
 *  provided, and there are no technical support obligations, but they will be
 *  far enough along that customers can actually use them in test environments
 *  or for limited-use tests -- just like they would in normal production cases.
 *
 *  Value: "ALPHA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Alpha;
/**
 *  Beta is the point at which we are ready to open a release for any customer
 *  to use. There are no SLA or technical support obligations in a Beta release.
 *  Products will be complete from a feature perspective, but may have some open
 *  outstanding issues. Beta releases are suitable for limited production use
 *  cases.
 *
 *  Value: "BETA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Beta;
/**
 *  Deprecated features are scheduled to be shut down and removed. For more
 *  information, see the "Deprecation Policy" section of our Terms of Service
 *  (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to
 *  the Deprecation Policy (https://cloud.google.com/terms/deprecation)
 *  documentation.
 *
 *  Value: "DEPRECATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Deprecated;
/**
 *  Early Access features are limited to a closed group of testers. To use these
 *  features, you must sign up in advance and sign a Trusted Tester agreement
 *  (which includes confidentiality provisions). These features may be unstable,
 *  changed in backward-incompatible ways, and are not guaranteed to be
 *  released.
 *
 *  Value: "EARLY_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_EarlyAccess;
/**
 *  GA features are open to all developers and are considered stable and fully
 *  qualified for production use.
 *
 *  Value: "GA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Ga;
/**
 *  Do not use this default value.
 *
 *  Value: "LAUNCH_STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_LaunchStageUnspecified;
/**
 *  Prelaunch features are hidden from users and are only visible internally.
 *
 *  Value: "PRELAUNCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Prelaunch;
/**
 *  The feature is not yet implemented. Users can not use it.
 *
 *  Value: "UNIMPLEMENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Unimplemented;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricThreshold.comparison

/**
 *  True if the left argument is equal to the right argument.
 *
 *  Value: "COMPARISON_EQ"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonEq;
/**
 *  True if the left argument is greater than or equal to the right argument.
 *
 *  Value: "COMPARISON_GE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGe;
/**
 *  True if the left argument is greater than the right argument.
 *
 *  Value: "COMPARISON_GT"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGt;
/**
 *  True if the left argument is less than or equal to the right argument.
 *
 *  Value: "COMPARISON_LE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLe;
/**
 *  True if the left argument is less than the right argument.
 *
 *  Value: "COMPARISON_LT"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLt;
/**
 *  True if the left argument is not equal to the right argument.
 *
 *  Value: "COMPARISON_NE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonNe;
/**
 *  No ordering relationship is specified.
 *
 *  Value: "COMPARISON_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricThreshold.evaluationMissingData

/**
 *  If there is no data to evaluate the condition, then evaluate the condition
 *  as true.
 *
 *  Value: "EVALUATION_MISSING_DATA_ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataActive;
/**
 *  If there is no data to evaluate the condition, then evaluate the condition
 *  as false.
 *
 *  Value: "EVALUATION_MISSING_DATA_INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataInactive;
/**
 *  Do not evaluate the condition to any value if there is no data.
 *
 *  Value: "EVALUATION_MISSING_DATA_NO_OP"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataNoOp;
/**
 *  An unspecified evaluation missing data option. Equivalent to
 *  EVALUATION_MISSING_DATA_NO_OP.
 *
 *  Value: "EVALUATION_MISSING_DATA_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MonitoredResourceDescriptor.launchStage

/**
 *  Alpha is a limited availability test for releases before they are cleared
 *  for widespread use. By Alpha, all significant design issues are resolved and
 *  we are in the process of verifying functionality. Alpha customers need to
 *  apply for access, agree to applicable terms, and have their projects
 *  allowlisted. Alpha releases don't have to be feature complete, no SLAs are
 *  provided, and there are no technical support obligations, but they will be
 *  far enough along that customers can actually use them in test environments
 *  or for limited-use tests -- just like they would in normal production cases.
 *
 *  Value: "ALPHA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Alpha;
/**
 *  Beta is the point at which we are ready to open a release for any customer
 *  to use. There are no SLA or technical support obligations in a Beta release.
 *  Products will be complete from a feature perspective, but may have some open
 *  outstanding issues. Beta releases are suitable for limited production use
 *  cases.
 *
 *  Value: "BETA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Beta;
/**
 *  Deprecated features are scheduled to be shut down and removed. For more
 *  information, see the "Deprecation Policy" section of our Terms of Service
 *  (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to
 *  the Deprecation Policy (https://cloud.google.com/terms/deprecation)
 *  documentation.
 *
 *  Value: "DEPRECATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Deprecated;
/**
 *  Early Access features are limited to a closed group of testers. To use these
 *  features, you must sign up in advance and sign a Trusted Tester agreement
 *  (which includes confidentiality provisions). These features may be unstable,
 *  changed in backward-incompatible ways, and are not guaranteed to be
 *  released.
 *
 *  Value: "EARLY_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_EarlyAccess;
/**
 *  GA features are open to all developers and are considered stable and fully
 *  qualified for production use.
 *
 *  Value: "GA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Ga;
/**
 *  Do not use this default value.
 *
 *  Value: "LAUNCH_STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_LaunchStageUnspecified;
/**
 *  Prelaunch features are hidden from users and are only visible internally.
 *
 *  Value: "PRELAUNCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Prelaunch;
/**
 *  The feature is not yet implemented. Users can not use it.
 *
 *  Value: "UNIMPLEMENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Unimplemented;

// ----------------------------------------------------------------------------
// GTLRMonitoring_NotificationChannel.verificationStatus

/**
 *  The channel has yet to be verified and requires verification to function.
 *  Note that this state also applies to the case where the verification process
 *  has been initiated by sending a verification code but where the verification
 *  code has not been submitted to complete the process.
 *
 *  Value: "UNVERIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannel_VerificationStatus_Unverified;
/**
 *  Sentinel value used to indicate that the state is unknown, omitted, or is
 *  not applicable (as in the case of channels that neither support nor require
 *  verification in order to function).
 *
 *  Value: "VERIFICATION_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannel_VerificationStatus_VerificationStatusUnspecified;
/**
 *  It has been proven that notifications can be received on this notification
 *  channel and that someone on the project has access to messages that are
 *  delivered to that channel.
 *
 *  Value: "VERIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannel_VerificationStatus_Verified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_NotificationChannelDescriptor.launchStage

/**
 *  Alpha is a limited availability test for releases before they are cleared
 *  for widespread use. By Alpha, all significant design issues are resolved and
 *  we are in the process of verifying functionality. Alpha customers need to
 *  apply for access, agree to applicable terms, and have their projects
 *  allowlisted. Alpha releases don't have to be feature complete, no SLAs are
 *  provided, and there are no technical support obligations, but they will be
 *  far enough along that customers can actually use them in test environments
 *  or for limited-use tests -- just like they would in normal production cases.
 *
 *  Value: "ALPHA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Alpha;
/**
 *  Beta is the point at which we are ready to open a release for any customer
 *  to use. There are no SLA or technical support obligations in a Beta release.
 *  Products will be complete from a feature perspective, but may have some open
 *  outstanding issues. Beta releases are suitable for limited production use
 *  cases.
 *
 *  Value: "BETA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Beta;
/**
 *  Deprecated features are scheduled to be shut down and removed. For more
 *  information, see the "Deprecation Policy" section of our Terms of Service
 *  (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to
 *  the Deprecation Policy (https://cloud.google.com/terms/deprecation)
 *  documentation.
 *
 *  Value: "DEPRECATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Deprecated;
/**
 *  Early Access features are limited to a closed group of testers. To use these
 *  features, you must sign up in advance and sign a Trusted Tester agreement
 *  (which includes confidentiality provisions). These features may be unstable,
 *  changed in backward-incompatible ways, and are not guaranteed to be
 *  released.
 *
 *  Value: "EARLY_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_EarlyAccess;
/**
 *  GA features are open to all developers and are considered stable and fully
 *  qualified for production use.
 *
 *  Value: "GA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Ga;
/**
 *  Do not use this default value.
 *
 *  Value: "LAUNCH_STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_LaunchStageUnspecified;
/**
 *  Prelaunch features are hidden from users and are only visible internally.
 *
 *  Value: "PRELAUNCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Prelaunch;
/**
 *  The feature is not yet implemented. Users can not use it.
 *
 *  Value: "UNIMPLEMENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Unimplemented;

// ----------------------------------------------------------------------------
// GTLRMonitoring_NotificationChannelDescriptor.supportedTiers

/**
 *  The Cloud Monitoring Basic tier, a free tier of service that provides basic
 *  features, a moderate allotment of logs, and access to built-in metrics. A
 *  number of features are not available in this tier. For more details, see the
 *  service tiers documentation
 *  (https://cloud.google.com/monitoring/workspaces/tiers).
 *
 *  Value: "SERVICE_TIER_BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_SupportedTiers_ServiceTierBasic;
/**
 *  The Cloud Monitoring Premium tier, a higher, more expensive tier of service
 *  that provides access to all Cloud Monitoring features, lets you use Cloud
 *  Monitoring with AWS accounts, and has a larger allotments for logs and
 *  metrics. For more details, see the service tiers documentation
 *  (https://cloud.google.com/monitoring/workspaces/tiers).
 *
 *  Value: "SERVICE_TIER_PREMIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_SupportedTiers_ServiceTierPremium;
/**
 *  An invalid sentinel value, used to indicate that a tier has not been
 *  provided explicitly.
 *
 *  Value: "SERVICE_TIER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_SupportedTiers_ServiceTierUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_OperationMetadata.state

/**
 *  The batch processing was cancelled.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_OperationMetadata_State_Cancelled;
/**
 *  Request has been received.
 *
 *  Value: "CREATED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_OperationMetadata_State_Created;
/**
 *  The batch processing is done.
 *
 *  Value: "DONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_OperationMetadata_State_Done;
/**
 *  Request is actively being processed.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_OperationMetadata_State_Running;
/**
 *  Invalid.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_OperationMetadata_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_QueryLanguageCondition.evaluationMissingData

/**
 *  If there is no data to evaluate the condition, then evaluate the condition
 *  as true.
 *
 *  Value: "EVALUATION_MISSING_DATA_ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataActive;
/**
 *  If there is no data to evaluate the condition, then evaluate the condition
 *  as false.
 *
 *  Value: "EVALUATION_MISSING_DATA_INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataInactive;
/**
 *  Do not evaluate the condition to any value if there is no data.
 *
 *  Value: "EVALUATION_MISSING_DATA_NO_OP"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataNoOp;
/**
 *  An unspecified evaluation missing data option. Equivalent to
 *  EVALUATION_MISSING_DATA_NO_OP.
 *
 *  Value: "EVALUATION_MISSING_DATA_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ResourceGroup.resourceType

/**
 *  A group of Amazon ELB load balancers.
 *
 *  Value: "AWS_ELB_LOAD_BALANCER"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_AwsElbLoadBalancer;
/**
 *  A group of instances from Google Cloud Platform (GCP) or Amazon Web Services
 *  (AWS).
 *
 *  Value: "INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_Instance;
/**
 *  Default value (not valid).
 *
 *  Value: "RESOURCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_ResourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ResponseStatusCode.statusClass

/**
 *  The class of status codes between 100 and 199.
 *
 *  Value: "STATUS_CLASS_1XX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass1xx;
/**
 *  The class of status codes between 200 and 299.
 *
 *  Value: "STATUS_CLASS_2XX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass2xx;
/**
 *  The class of status codes between 300 and 399.
 *
 *  Value: "STATUS_CLASS_3XX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass3xx;
/**
 *  The class of status codes between 400 and 499.
 *
 *  Value: "STATUS_CLASS_4XX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass4xx;
/**
 *  The class of status codes between 500 and 599.
 *
 *  Value: "STATUS_CLASS_5XX"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass5xx;
/**
 *  The class of all status codes.
 *
 *  Value: "STATUS_CLASS_ANY"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClassAny;
/**
 *  Default value that matches no status codes.
 *
 *  Value: "STATUS_CLASS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClassUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ServiceLevelObjective.calendarPeriod

/**
 *  Undefined period, raises an error.
 *
 *  Value: "CALENDAR_PERIOD_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_CalendarPeriodUnspecified;
/**
 *  A day.
 *
 *  Value: "DAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Day;
/**
 *  A fortnight. The first calendar fortnight of the year begins at the start of
 *  week 1 according to ISO 8601 (https://en.wikipedia.org/wiki/ISO_week_date).
 *
 *  Value: "FORTNIGHT"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Fortnight;
/**
 *  A half-year. Half-years start on dates 1-Jan and 1-Jul.
 *
 *  Value: "HALF"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Half;
/**
 *  A month.
 *
 *  Value: "MONTH"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Month;
/**
 *  A quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of each
 *  year.
 *
 *  Value: "QUARTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Quarter;
/**
 *  A week. Weeks begin on Monday, following ISO 8601
 *  (https://en.wikipedia.org/wiki/ISO_week_date).
 *
 *  Value: "WEEK"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Week;
/**
 *  A year.
 *
 *  Value: "YEAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Year;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Type.syntax

/**
 *  Syntax proto2.
 *
 *  Value: "SYNTAX_PROTO2"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto2;
/**
 *  Syntax proto3.
 *
 *  Value: "SYNTAX_PROTO3"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto3;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckConfig.checkerType

/**
 *  The default checker type. Currently converted to STATIC_IP_CHECKERS on
 *  creation, the default conversion behavior may change in the future.
 *
 *  Value: "CHECKER_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_CheckerType_CheckerTypeUnspecified;
/**
 *  STATIC_IP_CHECKERS are used for uptime checks that perform egress across the
 *  public internet. STATIC_IP_CHECKERS use the static IP addresses returned by
 *  ListUptimeCheckIps.
 *
 *  Value: "STATIC_IP_CHECKERS"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_CheckerType_StaticIpCheckers;
/**
 *  VPC_CHECKERS are used for uptime checks that perform egress using Service
 *  Directory and private network access. When using VPC_CHECKERS, the monitored
 *  resource type must be servicedirectory_service.
 *
 *  Value: "VPC_CHECKERS"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_CheckerType_VpcCheckers;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckConfig.selectedRegions

/**
 *  Allows checks to run from locations within the Asia Pacific area (ex:
 *  Singapore).
 *
 *  Value: "ASIA_PACIFIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_AsiaPacific;
/**
 *  Allows checks to run from locations within the continent of Europe.
 *
 *  Value: "EUROPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_Europe;
/**
 *  Default value if no region is specified. Will result in Uptime checks
 *  running from all regions.
 *
 *  Value: "REGION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_RegionUnspecified;
/**
 *  Allows checks to run from locations within the continent of South America.
 *
 *  Value: "SOUTH_AMERICA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_SouthAmerica;
/**
 *  Allows checks to run from locations within the United States of America.
 *
 *  Value: "USA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_Usa;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckIp.region

/**
 *  Allows checks to run from locations within the Asia Pacific area (ex:
 *  Singapore).
 *
 *  Value: "ASIA_PACIFIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_AsiaPacific;
/**
 *  Allows checks to run from locations within the continent of Europe.
 *
 *  Value: "EUROPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_Europe;
/**
 *  Default value if no region is specified. Will result in Uptime checks
 *  running from all regions.
 *
 *  Value: "REGION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_RegionUnspecified;
/**
 *  Allows checks to run from locations within the continent of South America.
 *
 *  Value: "SOUTH_AMERICA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_SouthAmerica;
/**
 *  Allows checks to run from locations within the United States of America.
 *
 *  Value: "USA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_Usa;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ValueDescriptor.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ValueDescriptor.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRMonitoring_ValueDescriptor_ValueType_ValueTypeUnspecified;

/**
 *  Describes how to combine multiple time series to provide a different view of
 *  the data. Aggregation of time series is done in two steps. First, each time
 *  series in the set is aligned to the same time interval boundaries, then the
 *  set of time series is optionally reduced in number.Alignment consists of
 *  applying the per_series_aligner operation to each time series after its data
 *  has been divided into regular alignment_period time intervals. This process
 *  takes all of the data points in an alignment period, applies a mathematical
 *  transformation such as averaging, minimum, maximum, delta, etc., and
 *  converts them into a single data point per period.Reduction is when the
 *  aligned and transformed time series can optionally be combined, reducing the
 *  number of time series through similar mathematical transformations.
 *  Reduction involves applying a cross_series_reducer to all the time series,
 *  optionally sorting the time series into subsets with group_by_fields, and
 *  applying the reducer to each subset.The raw time series data can contain a
 *  huge amount of information from multiple sources. Alignment and reduction
 *  transforms this mass of data into a more manageable and representative
 *  collection of data, for example "the 95% latency across the average of all
 *  tasks in a cluster". This representative data can be more easily graphed and
 *  comprehended, and the individual time series data is still available for
 *  later drilldown. For more details, see Filtering and aggregation
 *  (https://cloud.google.com/monitoring/api/v3/aggregation).
 */
@interface GTLRMonitoring_Aggregation : GTLRObject

/**
 *  The alignment_period specifies a time interval, in seconds, that is used to
 *  divide the data in all the time series into consistent blocks of time. This
 *  will be done before the per-series aligner can be applied to the data.The
 *  value must be at least 60 seconds. If a per-series aligner other than
 *  ALIGN_NONE is specified, this field is required or an error is returned. If
 *  no per-series aligner is specified, or the aligner ALIGN_NONE is specified,
 *  then this field is ignored.The maximum value of the alignment_period is 104
 *  weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting
 *  policies.
 */
@property(nonatomic, strong, nullable) GTLRDuration *alignmentPeriod;

/**
 *  The reduction operation to be used to combine time series into a single time
 *  series, where the value of each data point in the resulting series is a
 *  function of all the already aligned values in the input time series.Not all
 *  reducer operations can be applied to all time series. The valid choices
 *  depend on the metric_kind and the value_type of the original time series.
 *  Reduction can yield a time series with a different metric_kind or value_type
 *  than the input time series.Time series data must first be aligned (see
 *  per_series_aligner) in order to perform cross-time series reduction. If
 *  cross_series_reducer is specified, then per_series_aligner must be
 *  specified, and must not be ALIGN_NONE. An alignment_period must also be
 *  specified; otherwise, an error is returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCount Reduce
 *        by computing the number of data points across time series for each
 *        alignment period. This reducer is valid for DELTA and GAUGE metrics of
 *        numeric, Boolean, distribution, and string value_type. The value_type
 *        of the output is INT64. (Value: "REDUCE_COUNT")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountFalse
 *        Reduce by computing the number of False-valued data points across time
 *        series for each alignment period. This reducer is valid for DELTA and
 *        GAUGE metrics of Boolean value_type. The value_type of the output is
 *        INT64. (Value: "REDUCE_COUNT_FALSE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountTrue
 *        Reduce by computing the number of True-valued data points across time
 *        series for each alignment period. This reducer is valid for DELTA and
 *        GAUGE metrics of Boolean value_type. The value_type of the output is
 *        INT64. (Value: "REDUCE_COUNT_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceFractionTrue
 *        Reduce by computing the ratio of the number of True-valued data points
 *        to the total number of data points for each alignment period. This
 *        reducer is valid for DELTA and GAUGE metrics of Boolean value_type.
 *        The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
 *        (Value: "REDUCE_FRACTION_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMax Reduce by
 *        computing the maximum value across time series for each alignment
 *        period. This reducer is valid for DELTA and GAUGE metrics with numeric
 *        values. The value_type of the output is the same as the value_type of
 *        the input. (Value: "REDUCE_MAX")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMean Reduce
 *        by computing the mean value across time series for each alignment
 *        period. This reducer is valid for DELTA and GAUGE metrics with numeric
 *        or distribution values. The value_type of the output is DOUBLE.
 *        (Value: "REDUCE_MEAN")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMin Reduce by
 *        computing the minimum value across time series for each alignment
 *        period. This reducer is valid for DELTA and GAUGE metrics with numeric
 *        values. The value_type of the output is the same as the value_type of
 *        the input. (Value: "REDUCE_MIN")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceNone No
 *        cross-time series reduction. The output of the Aligner is returned.
 *        (Value: "REDUCE_NONE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile05
 *        Reduce by computing the 5th percentile
 *        (https://en.wikipedia.org/wiki/Percentile) of data points across time
 *        series for each alignment period. This reducer is valid for GAUGE and
 *        DELTA metrics of numeric and distribution type. The value of the
 *        output is DOUBLE. (Value: "REDUCE_PERCENTILE_05")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile50
 *        Reduce by computing the 50th percentile
 *        (https://en.wikipedia.org/wiki/Percentile) of data points across time
 *        series for each alignment period. This reducer is valid for GAUGE and
 *        DELTA metrics of numeric and distribution type. The value of the
 *        output is DOUBLE. (Value: "REDUCE_PERCENTILE_50")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile95
 *        Reduce by computing the 95th percentile
 *        (https://en.wikipedia.org/wiki/Percentile) of data points across time
 *        series for each alignment period. This reducer is valid for GAUGE and
 *        DELTA metrics of numeric and distribution type. The value of the
 *        output is DOUBLE. (Value: "REDUCE_PERCENTILE_95")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile99
 *        Reduce by computing the 99th percentile
 *        (https://en.wikipedia.org/wiki/Percentile) of data points across time
 *        series for each alignment period. This reducer is valid for GAUGE and
 *        DELTA metrics of numeric and distribution type. The value of the
 *        output is DOUBLE. (Value: "REDUCE_PERCENTILE_99")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceStddev Reduce
 *        by computing the standard deviation across time series for each
 *        alignment period. This reducer is valid for DELTA and GAUGE metrics
 *        with numeric or distribution values. The value_type of the output is
 *        DOUBLE. (Value: "REDUCE_STDDEV")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceSum Reduce by
 *        computing the sum across time series for each alignment period. This
 *        reducer is valid for DELTA and GAUGE metrics with numeric and
 *        distribution values. The value_type of the output is the same as the
 *        value_type of the input. (Value: "REDUCE_SUM")
 */
@property(nonatomic, copy, nullable) NSString *crossSeriesReducer;

/**
 *  The set of fields to preserve when cross_series_reducer is specified. The
 *  group_by_fields determine how the time series are partitioned into subsets
 *  prior to applying the aggregation operation. Each subset contains time
 *  series that have the same value for each of the grouping fields. Each
 *  individual time series is a member of exactly one subset. The
 *  cross_series_reducer is applied to each subset of time series. It is not
 *  possible to reduce across different resource types, so this field implicitly
 *  contains resource.type. Fields not specified in group_by_fields are
 *  aggregated away. If group_by_fields is not specified and all the time series
 *  have the same resource type, then the time series are aggregated into a
 *  single output time series. If cross_series_reducer is not defined, this
 *  field is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *groupByFields;

/**
 *  An Aligner describes how to bring the data points in a single time series
 *  into temporal alignment. Except for ALIGN_NONE, all alignments cause all the
 *  data points in an alignment_period to be mathematically grouped together,
 *  resulting in a single data point for each alignment_period with end
 *  timestamp at the end of the period.Not all alignment operations may be
 *  applied to all time series. The valid choices depend on the metric_kind and
 *  value_type of the original time series. Alignment can change the metric_kind
 *  or the value_type of the time series.Time series data must be aligned in
 *  order to perform cross-time series reduction. If cross_series_reducer is
 *  specified, then per_series_aligner must be specified and not equal to
 *  ALIGN_NONE and alignment_period must be specified; otherwise, an error is
 *  returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCount Align the
 *        time series by returning the number of values in each alignment
 *        period. This aligner is valid for GAUGE and DELTA metrics with numeric
 *        or Boolean values. The value_type of the aligned result is INT64.
 *        (Value: "ALIGN_COUNT")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountFalse Align
 *        the time series by returning the number of False values in each
 *        alignment period. This aligner is valid for GAUGE metrics with Boolean
 *        values. The value_type of the output is INT64. (Value:
 *        "ALIGN_COUNT_FALSE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountTrue Align
 *        the time series by returning the number of True values in each
 *        alignment period. This aligner is valid for GAUGE metrics with Boolean
 *        values. The value_type of the output is INT64. (Value:
 *        "ALIGN_COUNT_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignDelta Align and
 *        convert to DELTA. The output is delta = y1 - y0.This alignment is
 *        valid for CUMULATIVE and DELTA metrics. If the selected alignment
 *        period results in periods with no data, then the aligned value for
 *        such a period is created by interpolation. The value_type of the
 *        aligned result is the same as the value_type of the input. (Value:
 *        "ALIGN_DELTA")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignFractionTrue
 *        Align the time series by returning the ratio of the number of True
 *        values to the total number of values in each alignment period. This
 *        aligner is valid for GAUGE metrics with Boolean values. The output
 *        value is in the range 0.0, 1.0 and has value_type DOUBLE. (Value:
 *        "ALIGN_FRACTION_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignInterpolate
 *        Align by interpolating between adjacent points around the alignment
 *        period boundary. This aligner is valid for GAUGE metrics with numeric
 *        values. The value_type of the aligned result is the same as the
 *        value_type of the input. (Value: "ALIGN_INTERPOLATE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMax Align the
 *        time series by returning the maximum value in each alignment period.
 *        This aligner is valid for GAUGE and DELTA metrics with numeric values.
 *        The value_type of the aligned result is the same as the value_type of
 *        the input. (Value: "ALIGN_MAX")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMean Align the
 *        time series by returning the mean value in each alignment period. This
 *        aligner is valid for GAUGE and DELTA metrics with numeric values. The
 *        value_type of the aligned result is DOUBLE. (Value: "ALIGN_MEAN")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMin Align the
 *        time series by returning the minimum value in each alignment period.
 *        This aligner is valid for GAUGE and DELTA metrics with numeric values.
 *        The value_type of the aligned result is the same as the value_type of
 *        the input. (Value: "ALIGN_MIN")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNextOlder Align
 *        by moving the most recent data point before the end of the alignment
 *        period to the boundary at the end of the alignment period. This
 *        aligner is valid for GAUGE metrics. The value_type of the aligned
 *        result is the same as the value_type of the input. (Value:
 *        "ALIGN_NEXT_OLDER")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNone No
 *        alignment. Raw data is returned. Not valid if cross-series reduction
 *        is requested. The value_type of the result is the same as the
 *        value_type of the input. (Value: "ALIGN_NONE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentChange
 *        Align and convert to a percentage change. This aligner is valid for
 *        GAUGE and DELTA metrics with numeric values. This alignment returns
 *        ((current - previous)/previous) * 100, where the value of previous is
 *        determined based on the alignment_period.If the values of current and
 *        previous are both 0, then the returned value is 0. If only previous is
 *        0, the returned value is infinity.A 10-minute moving mean is computed
 *        at each point of the alignment period prior to the above calculation
 *        to smooth the metric and prevent false positives from very short-lived
 *        spikes. The moving mean is only applicable for data whose values are
 *        >= 0. Any values < 0 are treated as a missing datapoint, and are
 *        ignored. While DELTA metrics are accepted by this alignment, special
 *        care should be taken that the values for the metric will always be
 *        positive. The output is a GAUGE metric with value_type DOUBLE. (Value:
 *        "ALIGN_PERCENT_CHANGE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile05
 *        Align the time series by using percentile aggregation
 *        (https://en.wikipedia.org/wiki/Percentile). The resulting data point
 *        in each alignment period is the 5th percentile of all data points in
 *        the period. This aligner is valid for GAUGE and DELTA metrics with
 *        distribution values. The output is a GAUGE metric with value_type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_05")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile50
 *        Align the time series by using percentile aggregation
 *        (https://en.wikipedia.org/wiki/Percentile). The resulting data point
 *        in each alignment period is the 50th percentile of all data points in
 *        the period. This aligner is valid for GAUGE and DELTA metrics with
 *        distribution values. The output is a GAUGE metric with value_type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_50")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile95
 *        Align the time series by using percentile aggregation
 *        (https://en.wikipedia.org/wiki/Percentile). The resulting data point
 *        in each alignment period is the 95th percentile of all data points in
 *        the period. This aligner is valid for GAUGE and DELTA metrics with
 *        distribution values. The output is a GAUGE metric with value_type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_95")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile99
 *        Align the time series by using percentile aggregation
 *        (https://en.wikipedia.org/wiki/Percentile). The resulting data point
 *        in each alignment period is the 99th percentile of all data points in
 *        the period. This aligner is valid for GAUGE and DELTA metrics with
 *        distribution values. The output is a GAUGE metric with value_type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_99")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignRate Align and
 *        convert to a rate. The result is computed as rate = (y1 - y0)/(t1 -
 *        t0), or "delta over time". Think of this aligner as providing the
 *        slope of the line that passes through the value at the start and at
 *        the end of the alignment_period.This aligner is valid for CUMULATIVE
 *        and DELTA metrics with numeric values. If the selected alignment
 *        period results in periods with no data, then the aligned value for
 *        such a period is created by interpolation. The output is a GAUGE
 *        metric with value_type DOUBLE.If, by "rate", you mean "percentage
 *        change", see the ALIGN_PERCENT_CHANGE aligner instead. (Value:
 *        "ALIGN_RATE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignStddev Align the
 *        time series by returning the standard deviation of the values in each
 *        alignment period. This aligner is valid for GAUGE and DELTA metrics
 *        with numeric values. The value_type of the output is DOUBLE. (Value:
 *        "ALIGN_STDDEV")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignSum Align the
 *        time series by returning the sum of the values in each alignment
 *        period. This aligner is valid for GAUGE and DELTA metrics with numeric
 *        and distribution values. The value_type of the aligned result is the
 *        same as the value_type of the input. (Value: "ALIGN_SUM")
 */
@property(nonatomic, copy, nullable) NSString *perSeriesAligner;

@end


/**
 *  A description of the conditions under which some aspect of your system is
 *  considered to be "unhealthy" and the ways to notify people or services about
 *  this state. For an overview of alert policies, see Introduction to Alerting
 *  (https://cloud.google.com/monitoring/alerts/).
 */
@interface GTLRMonitoring_AlertPolicy : GTLRObject

/**
 *  Control over how this alert policy's notification channels are notified.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_AlertStrategy *alertStrategy;

/**
 *  How to combine the results of multiple conditions to determine if an
 *  incident should be opened. If condition_time_series_query_language is
 *  present, this must be COMBINE_UNSPECIFIED.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_And Combine conditions using
 *        the logical AND operator. An incident is created only if all the
 *        conditions are met simultaneously. This combiner is satisfied if all
 *        conditions are met, even if they are met on completely different
 *        resources. (Value: "AND")
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_AndWithMatchingResource
 *        Combine conditions using logical AND operator, but unlike the regular
 *        AND option, an incident is created only if all conditions are met
 *        simultaneously on at least one resource. (Value:
 *        "AND_WITH_MATCHING_RESOURCE")
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_CombineUnspecified An
 *        unspecified combiner. (Value: "COMBINE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_Or Combine conditions using
 *        the logical OR operator. An incident is created if any of the listed
 *        conditions is met. (Value: "OR")
 */
@property(nonatomic, copy, nullable) NSString *combiner;

/**
 *  A list of conditions for the policy. The conditions are combined by AND or
 *  OR according to the combiner field. If the combined conditions evaluate to
 *  true, then an incident is created. A policy can have from one to six
 *  conditions. If condition_time_series_query_language is present, it must be
 *  the only condition.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Condition *> *conditions;

/**
 *  A read-only record of the creation of the alerting policy. If provided in a
 *  call to create or update, this field will be ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MutationRecord *creationRecord;

/**
 *  A short name or phrase used to identify the policy in dashboards,
 *  notifications, and incidents. To avoid confusion, don't use the same display
 *  name for multiple policies in the same project. The name is limited to 512
 *  Unicode characters.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Documentation that is included with notifications and incidents related to
 *  this policy. Best practice is for the documentation to include information
 *  to help responders understand, mitigate, escalate, and correct the
 *  underlying problems detected by the alerting policy. Notification channels
 *  that have limited capacity might not show this documentation.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Documentation *documentation;

/**
 *  Whether or not the policy is enabled. On write, the default interpretation
 *  if unset is that the policy is enabled. On read, clients should not make any
 *  assumption about the state if it has not been populated. The field should
 *  always be populated on List and Get operations, unless a field projection
 *  has been specified that strips it out.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  A read-only record of the most recent change to the alerting policy. If
 *  provided in a call to create or update, this field will be ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MutationRecord *mutationRecord;

/**
 *  Required if the policy exists. The resource name for this policy. The format
 *  is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 *  [ALERT_POLICY_ID] is assigned by Cloud Monitoring when the policy is
 *  created. When calling the alertPolicies.create method, do not include the
 *  name field in the alerting policy passed as part of the request.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Identifies the notification channels to which notifications should be sent
 *  when incidents are opened or closed or when new violations occur on an
 *  already opened incident. Each element of this array corresponds to the name
 *  field in each of the NotificationChannel objects that are returned from the
 *  ListNotificationChannels method. The format of the entries in this field is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *notificationChannels;

/**
 *  User-supplied key/value data to be used for organizing and identifying the
 *  AlertPolicy objects.The field can contain up to 64 entries. Each key and
 *  value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_AlertPolicy_UserLabels *userLabels;

/**
 *  Read-only description of how the alert policy is invalid. OK if the alert
 *  policy is valid. If not OK, the alert policy will not generate incidents.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *validity;

@end


/**
 *  User-supplied key/value data to be used for organizing and identifying the
 *  AlertPolicy objects.The field can contain up to 64 entries. Each key and
 *  value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_AlertPolicy_UserLabels : GTLRObject
@end


/**
 *  Control over how the notification channels in notification_channels are
 *  notified when this alert fires.
 */
@interface GTLRMonitoring_AlertStrategy : GTLRObject

/**
 *  If an alert policy that was active has no data for this long, any open
 *  incidents will close
 */
@property(nonatomic, strong, nullable) GTLRDuration *autoClose;

/**
 *  Required for alert policies with a LogMatch condition.This limit is not
 *  implemented for alert policies that are not log-based.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_NotificationRateLimit *notificationRateLimit;

@end


/**
 *  App Engine service. Learn more at https://cloud.google.com/appengine.
 */
@interface GTLRMonitoring_AppEngine : GTLRObject

/**
 *  The ID of the App Engine module underlying this service. Corresponds to the
 *  module_id resource label in the gae_app monitored resource
 *  (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
 */
@property(nonatomic, copy, nullable) NSString *moduleId;

@end


/**
 *  Future parameters for the availability SLI.
 */
@interface GTLRMonitoring_AvailabilityCriteria : GTLRObject
@end


/**
 *  The authentication parameters to provide to the specified resource or URL
 *  that requires a username and password. Currently, only Basic HTTP
 *  authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime
 *  checks.
 */
@interface GTLRMonitoring_BasicAuthentication : GTLRObject

/** The password to use when authenticating with the HTTP server. */
@property(nonatomic, copy, nullable) NSString *password;

/** The username to use when authenticating with the HTTP server. */
@property(nonatomic, copy, nullable) NSString *username;

@end


/**
 *  A well-known service type, defined by its service type and service labels.
 *  Documentation and examples here
 *  (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
 */
@interface GTLRMonitoring_BasicService : GTLRObject

/**
 *  Labels that specify the resource that emits the monitoring data which is
 *  used for SLO reporting of this Service. Documentation and valid values for
 *  given service types here
 *  (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicService_ServiceLabels *serviceLabels;

/**
 *  The type of service that this basic service defines, e.g. APP_ENGINE service
 *  type. Documentation and valid values here
 *  (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
 */
@property(nonatomic, copy, nullable) NSString *serviceType;

@end


/**
 *  Labels that specify the resource that emits the monitoring data which is
 *  used for SLO reporting of this Service. Documentation and valid values for
 *  given service types here
 *  (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_BasicService_ServiceLabels : GTLRObject
@end


/**
 *  An SLI measuring performance on a well-known service type. Performance will
 *  be computed on the basis of pre-defined metrics. The type of the
 *  service_resource determines the metrics to use and the
 *  service_resource.labels and metric_labels are used to construct a monitoring
 *  filter to filter that metric down to just the data relevant to this service.
 */
@interface GTLRMonitoring_BasicSli : GTLRObject

/**
 *  Good service is defined to be the count of requests made to this service
 *  that return successfully.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_AvailabilityCriteria *availability;

/**
 *  Good service is defined to be the count of requests made to this service
 *  that are fast enough with respect to latency.threshold.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_LatencyCriteria *latency;

/**
 *  OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from
 *  other locations will not be used to calculate performance for this SLI. If
 *  omitted, this SLI applies to all locations in which the Service has
 *  activity. For service types that don't support breaking down by location,
 *  setting this field will result in an error.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *location;

/**
 *  OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
 *  other methods will not be used to calculate performance for this SLI. If
 *  omitted, this SLI applies to all the Service's methods. For service types
 *  that don't support breaking down by method, setting this field will result
 *  in an error.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *method;

/**
 *  OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
 *  from other API versions will not be used to calculate performance for this
 *  SLI. If omitted, this SLI applies to all API versions. For service types
 *  that don't support breaking down by version, setting this field will result
 *  in an error.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *version;

@end


/**
 *  BucketOptions describes the bucket boundaries used to create a histogram for
 *  the distribution. The buckets can be in a linear sequence, an exponential
 *  sequence, or each bucket can be specified explicitly. BucketOptions does not
 *  include the number of values in each bucket.A bucket has an inclusive lower
 *  bound and exclusive upper bound for the values that are counted for that
 *  bucket. The upper bound of a bucket must be strictly greater than the lower
 *  bound. The sequence of N buckets for a distribution consists of an underflow
 *  bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
 *  an overflow bucket (number N - 1). The buckets are contiguous: the lower
 *  bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
 *  The buckets span the whole range of finite values: lower bound of the
 *  underflow bucket is -infinity and the upper bound of the overflow bucket is
 *  +infinity. The finite buckets are so-called because both bounds are finite.
 */
@interface GTLRMonitoring_BucketOptions : GTLRObject

/** The explicit buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Explicit *explicitBuckets;

/** The exponential buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Exponential *exponentialBuckets;

/** The linear bucket. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Linear *linearBuckets;

@end


/**
 *  Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
 */
@interface GTLRMonitoring_CloudEndpoints : GTLRObject

/**
 *  The name of the Cloud Endpoints service underlying this service. Corresponds
 *  to the service resource label in the api monitored resource
 *  (https://cloud.google.com/monitoring/api/resources#tag_api).
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Cloud Run service. Learn more at https://cloud.google.com/run.
 */
@interface GTLRMonitoring_CloudRun : GTLRObject

/**
 *  The location the service is run. Corresponds to the location resource label
 *  in the cloud_run_revision monitored resource
 *  (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The name of the Cloud Run service. Corresponds to the service_name resource
 *  label in the cloud_run_revision monitored resource
 *  (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
 */
@property(nonatomic, copy, nullable) NSString *serviceName;

@end


/**
 *  Istio service scoped to a single Kubernetes cluster. Learn more at
 *  https://istio.io. Clusters running OSS Istio will have their services
 *  ingested as this type.
 */
@interface GTLRMonitoring_ClusterIstio : GTLRObject

/**
 *  The name of the Kubernetes cluster in which this Istio service is defined.
 *  Corresponds to the cluster_name resource label in k8s_cluster resources.
 */
@property(nonatomic, copy, nullable) NSString *clusterName;

/**
 *  The location of the Kubernetes cluster in which this Istio service is
 *  defined. Corresponds to the location resource label in k8s_cluster
 *  resources.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The name of the Istio service underlying this service. Corresponds to the
 *  destination_service_name metric label in Istio metrics.
 */
@property(nonatomic, copy, nullable) NSString *serviceName;

/**
 *  The namespace of the Istio service underlying this service. Corresponds to
 *  the destination_service_namespace metric label in Istio metrics.
 */
@property(nonatomic, copy, nullable) NSString *serviceNamespace;

@end


/**
 *  A collection of data points sent from a collectd-based plugin. See the
 *  collectd documentation for more information.
 */
@interface GTLRMonitoring_CollectdPayload : GTLRObject

/** The end time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The measurement metadata. Example: "process_id" -> 12345 */
@property(nonatomic, strong, nullable) GTLRMonitoring_CollectdPayload_Metadata *metadata;

/** The name of the plugin. Example: "disk". */
@property(nonatomic, copy, nullable) NSString *plugin;

/** The instance name of the plugin Example: "hdcl". */
@property(nonatomic, copy, nullable) NSString *pluginInstance;

/** The start time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** The measurement type. Example: "memory". */
@property(nonatomic, copy, nullable) NSString *type;

/** The measurement type instance. Example: "used". */
@property(nonatomic, copy, nullable) NSString *typeInstance;

/**
 *  The measured values during this time interval. Each value must have a
 *  different data_source_name.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValue *> *values;

@end


/**
 *  The measurement metadata. Example: "process_id" -> 12345
 *
 *  @note This class is documented as having more properties of
 *        GTLRMonitoring_TypedValue. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_CollectdPayload_Metadata : GTLRObject
@end


/**
 *  Describes the error status for payloads that were not written.
 */
@interface GTLRMonitoring_CollectdPayloadError : GTLRObject

/**
 *  Records the error status for the payload. If this field is present, the
 *  partial errors for nested values won't be populated.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *error;

/**
 *  The zero-based index in CreateCollectdTimeSeriesRequest.collectd_payloads.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Records the error status for values that were not written due to an
 *  error.Failed payloads for which nothing is written will not include partial
 *  value errors.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValueError *> *valueErrors;

@end


/**
 *  A single data point from a collectd-based plugin.
 */
@interface GTLRMonitoring_CollectdValue : GTLRObject

/**
 *  The data source for the collectd value. For example, there are two data
 *  sources for network measurements: "rx" and "tx".
 */
@property(nonatomic, copy, nullable) NSString *dataSourceName;

/**
 *  The type of measurement.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Absolute An amount of
 *        change since the last measurement interval. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.DELTA. (Value: "ABSOLUTE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Counter A cumulative
 *        value over time. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.CUMULATIVE. (Value: "COUNTER")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Derive A rate of
 *        change of the measurement. (Value: "DERIVE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Gauge An
 *        instantaneous measurement of a varying quantity. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.GAUGE. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType
 *        An unspecified data source type. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *        (Value: "UNSPECIFIED_DATA_SOURCE_TYPE")
 */
@property(nonatomic, copy, nullable) NSString *dataSourceType;

/** The measurement value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  Describes the error status for values that were not written.
 */
@interface GTLRMonitoring_CollectdValueError : GTLRObject

/** Records the error status for the value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *error;

/**
 *  The zero-based index in CollectdPayload.values within the parent
 *  CreateCollectdTimeSeriesRequest.collectd_payloads.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

@end


/**
 *  A condition is a true/false test that determines when an alerting policy
 *  should open an incident. If a condition evaluates to true, it signifies that
 *  something is wrong.
 */
@interface GTLRMonitoring_Condition : GTLRObject

/**
 *  A condition that checks that a time series continues to receive new data
 *  points.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricAbsence *conditionAbsent;

/**
 *  A condition that checks for log messages matching given constraints. If set,
 *  no other conditions can be present.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_LogMatch *conditionMatchedLog;

/** A condition that uses the Monitoring Query Language to define alerts. */
@property(nonatomic, strong, nullable) GTLRMonitoring_QueryLanguageCondition *conditionMonitoringQueryLanguage;

/** A condition that compares a time series against a threshold. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricThreshold *conditionThreshold;

/**
 *  A short name or phrase used to identify the condition in dashboards,
 *  notifications, and incidents. To avoid confusion, don't use the same display
 *  name for multiple conditions in the same policy.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required if the condition exists. The unique resource name for this
 *  condition. Its format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
 *  [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created
 *  as part of a new or updated alerting policy.When calling the
 *  alertPolicies.create method, do not include the name field in the conditions
 *  of the requested alerting policy. Cloud Monitoring creates the condition
 *  identifiers and includes them in the new policy.When calling the
 *  alertPolicies.update method to update a policy, including a condition name
 *  causes the existing condition to be updated. Conditions without names are
 *  added to the updated policy. Existing conditions are deleted if they are not
 *  updated.Best practice is to preserve [CONDITION_ID] if you make only small
 *  changes, such as those to condition thresholds, durations, or trigger
 *  values. Otherwise, treat the change as a new condition and let the existing
 *  condition be deleted.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Optional. Used to perform content matching. This allows matching based on
 *  substrings and regular expressions, together with their negations. Only the
 *  first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP
 *  check's response) are examined for purposes of content matching.
 */
@interface GTLRMonitoring_ContentMatcher : GTLRObject

/**
 *  String, regex or JSON content to match. Maximum 1024 bytes. An empty content
 *  string indicates no content matching is to be performed.
 */
@property(nonatomic, copy, nullable) NSString *content;

/** Matcher information for MATCHES_JSON_PATH and NOT_MATCHES_JSON_PATH */
@property(nonatomic, strong, nullable) GTLRMonitoring_JsonPathMatcher *jsonPathMatcher;

/**
 *  The type of content matcher that will be applied to the server output,
 *  compared to the content string when the check is run.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_ContainsString Selects
 *        substring matching. The match succeeds if the output contains the
 *        content string. This is the default value for checks without a matcher
 *        option, or where the value of matcher is
 *        CONTENT_MATCHER_OPTION_UNSPECIFIED. (Value: "CONTAINS_STRING")
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_ContentMatcherOptionUnspecified
 *        No content matcher type specified (maintained for backward
 *        compatibility, but deprecated for future use). Treated as
 *        CONTAINS_STRING. (Value: "CONTENT_MATCHER_OPTION_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_MatchesJsonPath Selects
 *        JSONPath matching. See JsonPathMatcher for details on when the match
 *        succeeds. JSONPath matching is only supported for HTTP/HTTPS checks.
 *        (Value: "MATCHES_JSON_PATH")
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_MatchesRegex Selects
 *        regular-expression matching. The match succeeds if the output matches
 *        the regular expression specified in the content string. Regex matching
 *        is only supported for HTTP/HTTPS checks. (Value: "MATCHES_REGEX")
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_NotContainsString Selects
 *        negation of substring matching. The match succeeds if the output does
 *        NOT contain the content string. (Value: "NOT_CONTAINS_STRING")
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_NotMatchesJsonPath Selects
 *        JSONPath matching. See JsonPathMatcher for details on when the match
 *        succeeds. Succeeds when output does NOT match as specified. JSONPath
 *        is only supported for HTTP/HTTPS checks. (Value:
 *        "NOT_MATCHES_JSON_PATH")
 *    @arg @c kGTLRMonitoring_ContentMatcher_Matcher_NotMatchesRegex Selects
 *        negation of regular-expression matching. The match succeeds if the
 *        output does NOT match the regular expression specified in the content
 *        string. Regex matching is only supported for HTTP/HTTPS checks.
 *        (Value: "NOT_MATCHES_REGEX")
 */
@property(nonatomic, copy, nullable) NSString *matcher;

@end


/**
 *  The CreateCollectdTimeSeries request.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesRequest : GTLRObject

/**
 *  The collectd payloads representing the time series data. You must not
 *  include more than a single point for each time series, so no two payloads
 *  can have the same values for all of the fields plugin, plugin_instance,
 *  type, and type_instance.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayload *> *collectdPayloads;

/**
 *  The version of collectd that collected the data. Example: "5.3.0-192.el6".
 */
@property(nonatomic, copy, nullable) NSString *collectdVersion;

/** The monitored resource associated with the time series. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

@end


/**
 *  The CreateCollectdTimeSeries response.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesResponse : GTLRObject

/**
 *  Records the error status for points that were not written due to an error in
 *  the request.Failed requests for which nothing is written will return an
 *  error response instead. Requests where data points were rejected by the
 *  backend will set summary instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayloadError *> *payloadErrors;

/**
 *  Aggregate statistics from writing the payloads. This field is omitted if all
 *  points were successfully written, so that the response is empty. This is for
 *  backwards compatibility with clients that log errors on any non-empty
 *  response.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_CreateTimeSeriesSummary *summary;

@end


/**
 *  The CreateTimeSeries request.
 */
@interface GTLRMonitoring_CreateTimeSeriesRequest : GTLRObject

/**
 *  Required. The new data to be added to a list of time series. Adds at most
 *  one data point to each of several time series. The new data point must be
 *  more recent than any other point in its time series. Each TimeSeries value
 *  must fully specify a unique time series by supplying all label values for
 *  the metric and the monitored resource.The maximum number of TimeSeries
 *  objects per Create request is 200.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  Summary of the result of a failed request to write data to a time series.
 */
@interface GTLRMonitoring_CreateTimeSeriesSummary : GTLRObject

/**
 *  The number of points that failed to be written. Order is not guaranteed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Error *> *errors;

/**
 *  The number of points that were successfully written.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successPointCount;

/**
 *  The number of points in the request.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalPointCount;

@end


/**
 *  Use a custom service to designate a service that you want to monitor when
 *  none of the other service types (like App Engine, Cloud Run, or a GKE type)
 *  matches your intended service.
 */
@interface GTLRMonitoring_Custom : GTLRObject
@end


/**
 *  Distribution contains summary statistics for a population of values. It
 *  optionally contains a histogram representing the distribution of those
 *  values across a set of buckets.The summary statistics are the count, mean,
 *  sum of the squared deviation from the mean, the minimum, and the maximum of
 *  the set of population of values. The histogram is based on a sequence of
 *  buckets and gives a count of values that fall into each bucket. The
 *  boundaries of the buckets are given either explicitly or by formulas for
 *  buckets of fixed or exponentially increasing widths.Although it is not
 *  forbidden, it is generally a bad idea to include non-finite values
 *  (infinities or NaNs) in the population of values, as this will render the
 *  mean and sum_of_squared_deviation fields meaningless.
 */
@interface GTLRMonitoring_Distribution : GTLRObject

/**
 *  Required in the Cloud Monitoring API v3. The values for each bucket
 *  specified in bucket_options. The sum of the values in bucketCounts must
 *  equal the value in the count field of the Distribution object. The order of
 *  the bucket counts follows the numbering schemes described for the three
 *  bucket types. The underflow bucket has number 0; the finite buckets, if any,
 *  have numbers 1 through N-2; and the overflow bucket has number N-1. The size
 *  of bucket_counts must not be greater than N. If the size is less than N,
 *  then the remaining buckets are assigned values of zero.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  Required in the Cloud Monitoring API v3. Defines the histogram bucket
 *  boundaries.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BucketOptions *bucketOptions;

/**
 *  The number of values in the population. Must be non-negative. This value
 *  must equal the sum of the values in bucket_counts if a histogram is
 *  provided.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/** Must be in increasing order of value field. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Exemplar *> *exemplars;

/**
 *  The arithmetic mean of the values in the population. If count is zero then
 *  this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  If specified, contains the range of the population values. The field must
 *  not be present if the count is zero. This field is presently ignored by the
 *  Cloud Monitoring API v3.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Range *range;

/**
 *  The sum of squared deviations from the mean of the values in the population.
 *  For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of
 *  Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's
 *  method for accumulating this sum in one pass.If count is zero then this
 *  field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  A DistributionCut defines a TimeSeries and thresholds used for measuring
 *  good service and total service. The TimeSeries must have ValueType =
 *  DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed
 *  good_service will be the estimated count of values in the Distribution that
 *  fall within the specified min and max.
 */
@interface GTLRMonitoring_DistributionCut : GTLRObject

/**
 *  A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  specifying a TimeSeries aggregating values. Must have ValueType =
 *  DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
 */
@property(nonatomic, copy, nullable) NSString *distributionFilter;

/**
 *  Range of values considered "good." For a one-sided range, set one bound to
 *  an infinite value.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_GoogleMonitoringV3Range *range;

@end


/**
 *  A content string and a MIME type that describes the content string's format.
 */
@interface GTLRMonitoring_Documentation : GTLRObject

/**
 *  The text of the documentation, interpreted according to mime_type. The
 *  content may not exceed 8,192 Unicode characters and may not exceed more than
 *  10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text
 *  can be templatized by using variables
 *  (https://cloud.google.com/monitoring/alerts/doc-variables).
 */
@property(nonatomic, copy, nullable) NSString *content;

/**
 *  The format of the content field. Presently, only the value "text/markdown"
 *  is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more
 *  information.
 */
@property(nonatomic, copy, nullable) NSString *mimeType;

@end


/**
 *  A set of (label, value) pairs that were removed from a Distribution time
 *  series during aggregation and then added as an attachment to a
 *  Distribution.Exemplar.The full label set for the exemplars is constructed by
 *  using the dropped pairs in combination with the label values that remain on
 *  the aggregated Distribution time series. The constructed full label set can
 *  be used to identify the specific entity, such as the instance or job, which
 *  might be contributing to a long-tail. However, with dropped labels, the
 *  storage requirements are reduced because only the aggregated distribution
 *  values for a large group of time series are stored.Note that there are no
 *  guarantees on ordering of the labels from exemplar-to-exemplar and from
 *  distribution-to-distribution in the same stream, and there may be
 *  duplicates. It is up to clients to resolve any ambiguities.
 */
@interface GTLRMonitoring_DroppedLabels : GTLRObject

/** Map from label to its value, for all labels dropped in any aggregation. */
@property(nonatomic, strong, nullable) GTLRMonitoring_DroppedLabels_Label *label;

@end


/**
 *  Map from label to its value, for all labels dropped in any aggregation.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_DroppedLabels_Label : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRMonitoring_Empty : GTLRObject
@end


/**
 *  Detailed information about an error category.
 */
@interface GTLRMonitoring_Error : GTLRObject

/**
 *  The number of points that couldn't be written because of status.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pointCount;

/** The status of the requested write operation. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *status;

@end


/**
 *  Exemplars are example points that may be used to annotate aggregated
 *  distribution values. They are metadata that gives information about a
 *  particular value added to a Distribution bucket, such as a trace ID that was
 *  active when a value was added. They may contain further information, such as
 *  a example values and timestamps, origin, etc.
 */
@interface GTLRMonitoring_Exemplar : GTLRObject

/**
 *  Contextual information about the example value. Examples are:Trace:
 *  type.googleapis.com/google.monitoring.v3.SpanContextLiteral string:
 *  type.googleapis.com/google.protobuf.StringValueLabels dropped during
 *  aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may
 *  be only a single attachment of any given message type in a single exemplar,
 *  and this is enforced by the system.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Exemplar_Attachments_Item *> *attachments;

/** The observation (sampling) time of the above value. */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

/**
 *  Value of the exemplar point. This value determines to which bucket the
 *  exemplar belongs.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  GTLRMonitoring_Exemplar_Attachments_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Exemplar_Attachments_Item : GTLRObject
@end


/**
 *  Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1
 *  (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i <
 *  N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must
 *  contain at least one element. If bounds has only one element, then there are
 *  no finite buckets, and that single element is the common boundary of the
 *  overflow and underflow buckets.
 */
@interface GTLRMonitoring_Explicit : GTLRObject

/**
 *  The values must be monotonically increasing.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Specifies an exponential sequence of buckets that have a width that is
 *  proportional to the value of the lower bound. Each bucket represents a
 *  constant relative uncertainty on a specific value in the bucket.There are
 *  num_finite_buckets + 2 (= N) buckets. Bucket i has the following
 *  boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower
 *  bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
 */
@interface GTLRMonitoring_Exponential : GTLRObject

/**
 *  Must be greater than 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  A single field of a message type.
 */
@interface GTLRMonitoring_Field : GTLRObject

/**
 *  The field cardinality.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityOptional For optional
 *        fields. (Value: "CARDINALITY_OPTIONAL")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRepeated For repeated
 *        fields. (Value: "CARDINALITY_REPEATED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRequired For required
 *        fields. Proto2 syntax only. (Value: "CARDINALITY_REQUIRED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityUnknown For fields
 *        with unknown cardinality. (Value: "CARDINALITY_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *cardinality;

/**
 *  The string value of the default value of this field. Proto2 syntax only.
 */
@property(nonatomic, copy, nullable) NSString *defaultValue;

/** The field JSON name. */
@property(nonatomic, copy, nullable) NSString *jsonName;

/**
 *  The field type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBool Field type bool. (Value:
 *        "TYPE_BOOL")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBytes Field type bytes. (Value:
 *        "TYPE_BYTES")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeDouble Field type double. (Value:
 *        "TYPE_DOUBLE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeEnum Field type enum. (Value:
 *        "TYPE_ENUM")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed32 Field type fixed32. (Value:
 *        "TYPE_FIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed64 Field type fixed64. (Value:
 *        "TYPE_FIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFloat Field type float. (Value:
 *        "TYPE_FLOAT")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeGroup Field type group. Proto2
 *        syntax only, and deprecated. (Value: "TYPE_GROUP")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt32 Field type int32. (Value:
 *        "TYPE_INT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt64 Field type int64. (Value:
 *        "TYPE_INT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeMessage Field type message. (Value:
 *        "TYPE_MESSAGE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed32 Field type sfixed32.
 *        (Value: "TYPE_SFIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed64 Field type sfixed64.
 *        (Value: "TYPE_SFIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint32 Field type sint32. (Value:
 *        "TYPE_SINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint64 Field type sint64. (Value:
 *        "TYPE_SINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeString Field type string. (Value:
 *        "TYPE_STRING")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint32 Field type uint32. (Value:
 *        "TYPE_UINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint64 Field type uint64. (Value:
 *        "TYPE_UINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUnknown Field type unknown. (Value:
 *        "TYPE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The field name. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The field number.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *number;

/**
 *  The index of the field type in Type.oneofs, for message or enumeration
 *  types. The first type has index 1; zero means the type is not in the list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneofIndex;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/**
 *  Whether to use alternative packed wire representation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packed;

/**
 *  The field type URL, without the scheme, for message or enumeration types.
 *  Example: "type.googleapis.com/google.protobuf.Timestamp".
 */
@property(nonatomic, copy, nullable) NSString *typeUrl;

@end


/**
 *  The GetNotificationChannelVerificationCode request.
 */
@interface GTLRMonitoring_GetNotificationChannelVerificationCodeRequest : GTLRObject

/**
 *  The desired expiration time. If specified, the API will guarantee that the
 *  returned code will not be valid after the specified timestamp; however, the
 *  API cannot guarantee that the returned code will be valid for at least as
 *  long as the requested time (the API puts an upper bound on the amount of
 *  time for which a code may be valid). If omitted, a default expiration will
 *  be used, which may be less than the max permissible expiration (so
 *  specifying an expiration may extend the code's lifetime over omitting an
 *  expiration, even though the API does impose an upper limit on the maximum
 *  expiration that is permitted).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

@end


/**
 *  The GetNotificationChannelVerificationCode request.
 */
@interface GTLRMonitoring_GetNotificationChannelVerificationCodeResponse : GTLRObject

/**
 *  The verification code, which may be used to verify other channels that have
 *  an equivalent identity (i.e. other channels of the same type with the same
 *  fingerprint such as other email channels with the same email address or
 *  other sms channels with the same number).
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  The expiration time associated with the code that was returned. If an
 *  expiration was provided in the request, this is the minimum of the requested
 *  expiration in the request and the max permitted expiration.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

@end


/**
 *  GKE Namespace. The field names correspond to the resource metadata labels on
 *  monitored resources that fall under a namespace (for example, k8s_container
 *  or k8s_pod).
 */
@interface GTLRMonitoring_GkeNamespace : GTLRObject

/** The name of the parent cluster. */
@property(nonatomic, copy, nullable) NSString *clusterName;

/** The location of the parent cluster. This may be a zone or region. */
@property(nonatomic, copy, nullable) NSString *location;

/** The name of this namespace. */
@property(nonatomic, copy, nullable) NSString *namespaceName;

/**
 *  Output only. The project this resource lives in. For legacy services
 *  migrated from the Custom type, this may be a distinct project from the one
 *  parenting the service itself.
 */
@property(nonatomic, copy, nullable) NSString *projectId;

@end


/**
 *  GKE Service. The "service" here represents a Kubernetes service object
 *  (https://kubernetes.io/docs/concepts/services-networking/service). The field
 *  names correspond to the resource labels on k8s_service monitored resources
 *  (https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
 */
@interface GTLRMonitoring_GkeService : GTLRObject

/** The name of the parent cluster. */
@property(nonatomic, copy, nullable) NSString *clusterName;

/** The location of the parent cluster. This may be a zone or region. */
@property(nonatomic, copy, nullable) NSString *location;

/** The name of the parent namespace. */
@property(nonatomic, copy, nullable) NSString *namespaceName;

/**
 *  Output only. The project this resource lives in. For legacy services
 *  migrated from the Custom type, this may be a distinct project from the one
 *  parenting the service itself.
 */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The name of this service. */
@property(nonatomic, copy, nullable) NSString *serviceName;

@end


/**
 *  A GKE Workload (Deployment, StatefulSet, etc). The field names correspond to
 *  the metadata labels on monitored resources that fall under a workload (for
 *  example, k8s_container or k8s_pod).
 */
@interface GTLRMonitoring_GkeWorkload : GTLRObject

/** The name of the parent cluster. */
@property(nonatomic, copy, nullable) NSString *clusterName;

/** The location of the parent cluster. This may be a zone or region. */
@property(nonatomic, copy, nullable) NSString *location;

/** The name of the parent namespace. */
@property(nonatomic, copy, nullable) NSString *namespaceName;

/**
 *  Output only. The project this resource lives in. For legacy services
 *  migrated from the Custom type, this may be a distinct project from the one
 *  parenting the service itself.
 */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The name of this workload. */
@property(nonatomic, copy, nullable) NSString *topLevelControllerName;

/** The type of this workload (for example, "Deployment" or "DaemonSet") */
@property(nonatomic, copy, nullable) NSString *topLevelControllerType;

@end


/**
 *  Range of numerical values within min and max.
 */
@interface GTLRMonitoring_GoogleMonitoringV3Range : GTLRObject

/**
 *  Range maximum.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *max;

/**
 *  Range minimum.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *min;

@end


/**
 *  The description of a dynamic collection of monitored resources. Each group
 *  has a filter that is matched against monitored resources and their
 *  associated metadata. If a group's filter matches an available monitored
 *  resource, then that resource is a member of that group. Groups can contain
 *  any number of monitored resources, and each monitored resource can be a
 *  member of any number of groups.Groups can be nested in parent-child
 *  hierarchies. The parentName field identifies an optional parent for each
 *  group. If a group has a parent, then the only monitored resources available
 *  to be matched by the group's filter are the resources contained in the
 *  parent group. In other words, a group contains the monitored resources that
 *  match its filter and the filters of all the group's ancestors. A group
 *  without a parent can contain any monitored resource.For example, consider an
 *  infrastructure running a set of instances with two user-defined tags:
 *  "environment" and "role". A parent group has a filter,
 *  environment="production". A child of that parent group has a filter,
 *  role="transcoder". The parent group contains all instances in the production
 *  environment, regardless of their roles. The child group contains instances
 *  that have the transcoder role and are in the production environment.The
 *  monitored resources contained in a group can change at any moment, depending
 *  on what resources exist and what filters are associated with the group and
 *  its ancestors.
 */
@interface GTLRMonitoring_Group : GTLRObject

/** A user-assigned name for this group, used only for display purposes. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The filter used to determine which monitored resources belong to this group.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  If true, the members of this group are considered to be a cluster. The
 *  system can perform additional analysis on groups that are clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isCluster;

/**
 *  Output only. The name of this group. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] When creating a group,
 *  this field is ignored and a new name is created consisting of the project
 *  specified in the call to CreateGroup and a unique [GROUP_ID] that is
 *  generated automatically.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the group's parent, if it has one. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID] For groups with no parent,
 *  parent_name is the empty string, "".
 */
@property(nonatomic, copy, nullable) NSString *parentName;

@end


/**
 *  Information involved in an HTTP/HTTPS Uptime check request.
 */
@interface GTLRMonitoring_HttpCheck : GTLRObject

/**
 *  If present, the check will only pass if the HTTP response status code is in
 *  this set of status codes. If empty, the HTTP status code will only pass if
 *  the HTTP status code is 200-299.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_ResponseStatusCode *> *acceptedResponseStatusCodes;

/**
 *  The authentication information. Optional when creating an HTTP check;
 *  defaults to empty.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicAuthentication *authInfo;

/**
 *  The request body associated with the HTTP POST request. If content_type is
 *  URL_ENCODED, the body passed in must be URL-encoded. Users can provide a
 *  Content-Length header via the headers field or the API will do so. If the
 *  request_method is GET and body is not empty, the API will return an error.
 *  The maximum byte size is 1 megabyte.Note: If client libraries aren't used
 *  (which performs the conversion automatically) base64 encode your body data
 *  since the field is of bytes type.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *body;

/**
 *  The content type header to use for the check. The following configurations
 *  result in errors: 1. Content type is specified in both the headers field and
 *  the content_type field. 2. Request method is GET and content_type is not
 *  TYPE_UNSPECIFIED 3. Request method is POST and content_type is
 *  TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is
 *  provided via headers field. The content_type field should be used instead.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_HttpCheck_ContentType_TypeUnspecified No content
 *        type specified. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_HttpCheck_ContentType_UrlEncoded body is in
 *        URL-encoded form. Equivalent to setting the Content-Type to
 *        application/x-www-form-urlencoded in the HTTP request. (Value:
 *        "URL_ENCODED")
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The list of headers to send as part of the Uptime check request. If two
 *  headers have the same key and different values, they should be entered as a
 *  single header, with the value being a comma-separated list of all the
 *  desired values as described at
 *  https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two
 *  separate headers with the same key in a Create call will cause the first to
 *  be overwritten by the second. The maximum number of headers allowed is 100.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_HttpCheck_Headers *headers;

/**
 *  Boolean specifying whether to encrypt the header information. Encryption
 *  should be specified for any headers related to authentication that you do
 *  not wish to be seen when retrieving the configuration. The server will be
 *  responsible for encrypting the headers. On Get/List calls, if mask_headers
 *  is set to true then the headers will be obscured with ******.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maskHeaders;

/**
 *  Optional (defaults to "/"). The path to the page against which to run the
 *  check. Will be combined with the host (specified within the
 *  monitored_resource) and port to construct the full URL. If the provided path
 *  does not begin with "/", a "/" will be prepended automatically.
 */
@property(nonatomic, copy, nullable) NSString *path;

/** Contains information needed to add pings to an HTTP check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_PingConfig *pingConfig;

/**
 *  Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is
 *  true). The TCP port on the HTTP server against which to run the check. Will
 *  be combined with host (specified within the monitored_resource) and path to
 *  construct the full URL.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

/**
 *  The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED
 *  then request_method defaults to GET.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_HttpCheck_RequestMethod_Get GET request. (Value:
 *        "GET")
 *    @arg @c kGTLRMonitoring_HttpCheck_RequestMethod_MethodUnspecified No
 *        request method specified. (Value: "METHOD_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_HttpCheck_RequestMethod_Post POST request. (Value:
 *        "POST")
 */
@property(nonatomic, copy, nullable) NSString *requestMethod;

/**
 *  If true, use HTTPS instead of HTTP to run the check.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useSsl;

/**
 *  Boolean specifying whether to include SSL certificate validation as a part
 *  of the Uptime check. Only applies to checks where monitored_resource is set
 *  to uptime_url. If use_ssl is false, setting validate_ssl to true has no
 *  effect.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *validateSsl;

@end


/**
 *  The list of headers to send as part of the Uptime check request. If two
 *  headers have the same key and different values, they should be entered as a
 *  single header, with the value being a comma-separated list of all the
 *  desired values as described at
 *  https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two
 *  separate headers with the same key in a Create call will cause the first to
 *  be overwritten by the second. The maximum number of headers allowed is 100.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_HttpCheck_Headers : GTLRObject
@end


/**
 *  An internal checker allows Uptime checks to run on private/internal GCP
 *  resources.
 */
@interface GTLRMonitoring_InternalChecker : GTLRObject

/**
 *  The checker's human-readable name. The display name should be unique within
 *  a Cloud Monitoring Metrics Scope in order to make it easier to identify;
 *  however, uniqueness is not enforced.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The GCP zone the Uptime check should egress from. Only respected for
 *  internal Uptime checks, where internal_network is specified.
 */
@property(nonatomic, copy, nullable) NSString *gcpZone;

/**
 *  A unique resource name for this InternalChecker. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
 *  [PROJECT_ID_OR_NUMBER] is the Cloud Monitoring Metrics Scope project for the
 *  Uptime check config associated with the internal checker.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the
 *  internal resource lives (ex: "default").
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  The GCP project ID where the internal checker lives. Not necessary the same
 *  as the Metrics Scope project.
 */
@property(nonatomic, copy, nullable) NSString *peerProjectId;

/**
 *  The current operational state of the internal checker.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_InternalChecker_State_Creating The checker is
 *        being created, provisioned, and configured. A checker in this state
 *        can be returned by ListInternalCheckers or GetInternalChecker, as well
 *        as by examining the long running Operation
 *        (https://cloud.google.com/apis/design/design_patterns#long_running_operations)
 *        that created it. (Value: "CREATING")
 *    @arg @c kGTLRMonitoring_InternalChecker_State_Running The checker is
 *        running and available for use. A checker in this state can be returned
 *        by ListInternalCheckers or GetInternalChecker as well as by examining
 *        the long running Operation
 *        (https://cloud.google.com/apis/design/design_patterns#long_running_operations)
 *        that created it. If a checker is being torn down, it is neither
 *        visible nor usable, so there is no "deleting" or "down" state. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRMonitoring_InternalChecker_State_Unspecified An internal
 *        checker should never be in the unspecified state. (Value:
 *        "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Canonical service scoped to an Istio mesh. Anthos clusters running ASM >=
 *  1.6.8 will have their services ingested as this type.
 */
@interface GTLRMonitoring_IstioCanonicalService : GTLRObject

/**
 *  The name of the canonical service underlying this service. Corresponds to
 *  the destination_canonical_service_name metric label in label in Istio
 *  metrics (https://cloud.google.com/monitoring/api/metrics_istio).
 */
@property(nonatomic, copy, nullable) NSString *canonicalService;

/**
 *  The namespace of the canonical service underlying this service. Corresponds
 *  to the destination_canonical_service_namespace metric label in Istio metrics
 *  (https://cloud.google.com/monitoring/api/metrics_istio).
 */
@property(nonatomic, copy, nullable) NSString *canonicalServiceNamespace;

/**
 *  Identifier for the Istio mesh in which this canonical service is defined.
 *  Corresponds to the mesh_uid metric label in Istio metrics
 *  (https://cloud.google.com/monitoring/api/metrics_istio).
 */
@property(nonatomic, copy, nullable) NSString *meshUid;

@end


/**
 *  Information needed to perform a JSONPath content match. Used for
 *  ContentMatcherOption::MATCHES_JSON_PATH and
 *  ContentMatcherOption::NOT_MATCHES_JSON_PATH.
 */
@interface GTLRMonitoring_JsonPathMatcher : GTLRObject

/**
 *  The type of JSONPath match that will be applied to the JSON output
 *  (ContentMatcher.content)
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_JsonPathMatcher_JsonMatcher_ExactMatch Selects
 *        'exact string' matching. The match succeeds if the content at the
 *        json_path within the output is exactly the same as the content string.
 *        (Value: "EXACT_MATCH")
 *    @arg @c kGTLRMonitoring_JsonPathMatcher_JsonMatcher_JsonPathMatcherOptionUnspecified
 *        No JSONPath matcher type specified (not valid). (Value:
 *        "JSON_PATH_MATCHER_OPTION_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_JsonPathMatcher_JsonMatcher_RegexMatch Selects
 *        regular-expression matching. The match succeeds if the content at the
 *        json_path within the output matches the regular expression specified
 *        in the content string. (Value: "REGEX_MATCH")
 */
@property(nonatomic, copy, nullable) NSString *jsonMatcher;

/**
 *  JSONPath within the response output pointing to the expected
 *  ContentMatcher::content to match against.
 */
@property(nonatomic, copy, nullable) NSString *jsonPath;

@end


/**
 *  A description of a label.
 */
@interface GTLRMonitoring_LabelDescriptor : GTLRObject

/**
 *  A human-readable description for the label.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The key for this label. The key must meet the following criteria: Does not
 *  exceed 100 characters. Matches the following regular expression:
 *  [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case
 *  letter. The remaining characters must be letters, digits, or underscores.
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  The type of data that can be assigned to the label.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Bool Boolean; true or
 *        false. (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Int64 A 64-bit signed
 *        integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_String A variable-length
 *        string, not to exceed 1,024 characters. This is the default value
 *        type. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  A label value.
 */
@interface GTLRMonitoring_LabelValue : GTLRObject

/**
 *  A bool label value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/**
 *  An int64 label value.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** A string label value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  Parameters for a latency threshold SLI.
 */
@interface GTLRMonitoring_LatencyCriteria : GTLRObject

/**
 *  Good service is defined to be the count of requests made to this service
 *  that return in no more than threshold.
 */
@property(nonatomic, strong, nullable) GTLRDuration *threshold;

@end


/**
 *  Specifies a linear sequence of buckets that all have the same width (except
 *  overflow and underflow). Each bucket represents a constant absolute
 *  uncertainty on the specific value in the bucket.There are num_finite_buckets
 *  + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i
 *  < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i
 *  - 1)).
 */
@interface GTLRMonitoring_Linear : GTLRObject

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Lower bound of the first bucket.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  The protocol for the ListAlertPolicies response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "alertPolicies" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListAlertPoliciesResponse : GTLRCollectionObject

/**
 *  The returned alert policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_AlertPolicy *> *alertPolicies;

/**
 *  If there might be more results than were returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of alert policies in all pages. This number is only an
 *  estimate, and may change in subsequent pages. https://aip.dev/158
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The ListGroupMembers response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "members" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupMembersResponse : GTLRCollectionObject

/**
 *  A set of monitored resources in the group.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResource *> *members;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of elements matching this request.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The ListGroups response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "group" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupsResponse : GTLRCollectionObject

/**
 *  The groups that match the specified filters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Group *> *group;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMetricDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "metricDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMetricDescriptorsResponse : GTLRCollectionObject

/**
 *  The metric descriptors that are available to the project and that match the
 *  value of filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MetricDescriptor *> *metricDescriptors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMonitoredResourceDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resourceDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMonitoredResourceDescriptorsResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The monitored resource descriptors that are available to this project and
 *  that match filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResourceDescriptor *> *resourceDescriptors;

@end


/**
 *  The ListNotificationChannelDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "channelDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListNotificationChannelDescriptorsResponse : GTLRCollectionObject

/**
 *  The monitored resource descriptors supported for the specified project,
 *  optionally filtered.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_NotificationChannelDescriptor *> *channelDescriptors;

/**
 *  If not empty, indicates that there may be more results that match the
 *  request. Use the value in the page_token field in a subsequent request to
 *  fetch the next set of results. If empty, all results have been returned.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListNotificationChannels response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "notificationChannels" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListNotificationChannelsResponse : GTLRCollectionObject

/**
 *  If not empty, indicates that there may be more results that match the
 *  request. Use the value in the page_token field in a subsequent request to
 *  fetch the next set of results. If empty, all results have been returned.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The notification channels defined for the specified project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_NotificationChannel *> *notificationChannels;

/**
 *  The total number of notification channels in all pages. This number is only
 *  an estimate, and may change in subsequent pages. https://aip.dev/158
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The ListServiceLevelObjectives response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "serviceLevelObjectives" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListServiceLevelObjectivesResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The ServiceLevelObjectives matching the specified filter.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_ServiceLevelObjective *> *serviceLevelObjectives;

@end


/**
 *  The ListServices response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "services" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListServicesResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The Services matching the specified filter.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Service *> *services;

@end


/**
 *  The ListTimeSeries response.
 */
@interface GTLRMonitoring_ListTimeSeriesResponse : GTLRObject

/**
 *  Query execution errors that may have caused the time series data returned to
 *  be incomplete.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Status *> *executionErrors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** One or more time series that match the filter included in the request. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

/**
 *  The unit in which all time_series point values are reported. unit follows
 *  the UCUM format for units as seen in https://unitsofmeasure.org/ucum.html.
 *  If different time_series have different units (for example, because they
 *  come from different metric types, or a unit is absent), then unit will be
 *  "{not_a_unit}".
 */
@property(nonatomic, copy, nullable) NSString *unit;

@end


/**
 *  The protocol for the ListUptimeCheckConfigs response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "uptimeCheckConfigs" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListUptimeCheckConfigsResponse : GTLRCollectionObject

/**
 *  This field represents the pagination token to retrieve the next page of
 *  results. If the value is empty, it means no further results for the request.
 *  To retrieve the next page of results, the value of the next_page_token is
 *  passed to the subsequent List method call (in the request message's
 *  page_token field).
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of Uptime check configurations for the project,
 *  irrespective of any pagination.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

/**
 *  The returned Uptime check configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_UptimeCheckConfig *> *uptimeCheckConfigs;

@end


/**
 *  The protocol for the ListUptimeCheckIps response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "uptimeCheckIps" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRMonitoring_ListUptimeCheckIpsResponse : GTLRCollectionObject

/**
 *  This field represents the pagination token to retrieve the next page of
 *  results. If the value is empty, it means no further results for the request.
 *  To retrieve the next page of results, the value of the next_page_token is
 *  passed to the subsequent List method call (in the request message's
 *  page_token field). NOTE: this field is not yet implemented
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The returned list of IP addresses (including region and location) that the
 *  checkers run from.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_UptimeCheckIp *> *uptimeCheckIps;

@end


/**
 *  A condition type that checks whether a log message in the scoping project
 *  (https://cloud.google.com/monitoring/api/v3#project_name) satisfies the
 *  given filter. Logs from other projects in the metrics scope are not
 *  evaluated.
 */
@interface GTLRMonitoring_LogMatch : GTLRObject

/**
 *  Required. A logs-based filter. See Advanced Logs Queries
 *  (https://cloud.google.com/logging/docs/view/advanced-queries) for how this
 *  filter should be constructed.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Optional. A map from a label key to an extractor expression, which is used
 *  to extract the value for this label key. Each entry in this map is a
 *  specification for how data should be extracted from log entries that match
 *  filter. Each combination of extracted values is treated as a separate rule
 *  for the purposes of triggering notifications. Label keys and corresponding
 *  values can be used in notifications generated by this condition.Please see
 *  the documentation on logs-based metric valueExtractors
 *  (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
 *  for syntax and examples.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_LogMatch_LabelExtractors *labelExtractors;

@end


/**
 *  Optional. A map from a label key to an extractor expression, which is used
 *  to extract the value for this label key. Each entry in this map is a
 *  specification for how data should be extracted from log entries that match
 *  filter. Each combination of extracted values is treated as a separate rule
 *  for the purposes of triggering notifications. Label keys and corresponding
 *  values can be used in notifications generated by this condition.Please see
 *  the documentation on logs-based metric valueExtractors
 *  (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
 *  for syntax and examples.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_LogMatch_LabelExtractors : GTLRObject
@end


/**
 *  Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8
 *  will have their services ingested as this type.
 */
@interface GTLRMonitoring_MeshIstio : GTLRObject

/**
 *  Identifier for the mesh in which this Istio service is defined. Corresponds
 *  to the mesh_uid metric label in Istio metrics.
 */
@property(nonatomic, copy, nullable) NSString *meshUid;

/**
 *  The name of the Istio service underlying this service. Corresponds to the
 *  destination_service_name metric label in Istio metrics.
 */
@property(nonatomic, copy, nullable) NSString *serviceName;

/**
 *  The namespace of the Istio service underlying this service. Corresponds to
 *  the destination_service_namespace metric label in Istio metrics.
 */
@property(nonatomic, copy, nullable) NSString *serviceNamespace;

@end


/**
 *  A specific metric, identified by specifying values for all of the labels of
 *  a MetricDescriptor.
 */
@interface GTLRMonitoring_Metric : GTLRObject

/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric_Labels *labels;

/**
 *  An existing metric type, see google.api.MetricDescriptor. For example,
 *  custom.googleapis.com/invoice/paid/amount.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_Metric_Labels : GTLRObject
@end


/**
 *  A condition type that checks that monitored resources are reporting data.
 *  The configuration defines a metric and a set of monitored resources. The
 *  predicate is considered in violation when a time series for the specified
 *  metric of a monitored resource does not include any data in the specified
 *  duration.
 */
@interface GTLRMonitoring_MetricAbsence : GTLRObject

/**
 *  Specifies the alignment of data points in individual time series as well as
 *  how to combine the retrieved time series together (such as when aggregating
 *  multiple streams on each resource to a single stream for each resource or
 *  when aggregating streams across all members of a group of resources).
 *  Multiple aggregations are applied in the order specified.This field is
 *  similar to the one in the ListTimeSeries request
 *  (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
 *  It is advisable to use the ListTimeSeries method when debugging this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Aggregation *> *aggregations;

/**
 *  The amount of time that a time series must fail to report new data to be
 *  considered failing. The minimum value of this field is 120 seconds. Larger
 *  values that are a multiple of a minute--for example, 240 or 300 seconds--are
 *  supported. If an invalid value is given, an error will be returned. The
 *  Duration.nanos field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that
 *  identifies which time series should be compared with the threshold.The
 *  filter is similar to the one that is specified in the ListTimeSeries request
 *  (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
 *  (that call is useful to verify the time series that will be retrieved /
 *  processed). The filter must specify the metric type and the resource type.
 *  Optionally, it can specify resource labels and metric labels. This field
 *  must not exceed 2048 Unicode characters in length.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The number/percent of time series for which the comparison must hold in
 *  order for the condition to trigger. If unspecified, then the condition will
 *  trigger if the comparison is true for any of the time series that have been
 *  identified by filter and aggregations.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Trigger *trigger;

@end


/**
 *  Defines a metric type and its schema. Once a metric descriptor is created,
 *  deleting or altering it stops data collection and makes the metric type's
 *  existing data unusable.
 */
@interface GTLRMonitoring_MetricDescriptor : GTLRObject

/**
 *  A detailed description of the metric, which can be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A concise name for the metric, which can be displayed in user interfaces.
 *  Use sentence case without an ending period, for example "Request count".
 *  This field is optional but it is recommended to be set for any metrics
 *  associated with user-visible concepts, such as Quota.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that can be used to describe a specific instance of this
 *  metric type. For example, the
 *  appengine.googleapis.com/http/server/response_latencies metric type has a
 *  label for the HTTP response code, response_code, so you can look at
 *  latencies for successful responses or just for responses that failed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Optional. The launch stage of the metric definition.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_Alpha Alpha is a
 *        limited availability test for releases before they are cleared for
 *        widespread use. By Alpha, all significant design issues are resolved
 *        and we are in the process of verifying functionality. Alpha customers
 *        need to apply for access, agree to applicable terms, and have their
 *        projects allowlisted. Alpha releases don't have to be feature
 *        complete, no SLAs are provided, and there are no technical support
 *        obligations, but they will be far enough along that customers can
 *        actually use them in test environments or for limited-use tests --
 *        just like they would in normal production cases. (Value: "ALPHA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_Beta Beta is the
 *        point at which we are ready to open a release for any customer to use.
 *        There are no SLA or technical support obligations in a Beta release.
 *        Products will be complete from a feature perspective, but may have
 *        some open outstanding issues. Beta releases are suitable for limited
 *        production use cases. (Value: "BETA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_Deprecated Deprecated
 *        features are scheduled to be shut down and removed. For more
 *        information, see the "Deprecation Policy" section of our Terms of
 *        Service (https://cloud.google.com/terms/) and the Google Cloud
 *        Platform Subject to the Deprecation Policy
 *        (https://cloud.google.com/terms/deprecation) documentation. (Value:
 *        "DEPRECATED")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_EarlyAccess Early
 *        Access features are limited to a closed group of testers. To use these
 *        features, you must sign up in advance and sign a Trusted Tester
 *        agreement (which includes confidentiality provisions). These features
 *        may be unstable, changed in backward-incompatible ways, and are not
 *        guaranteed to be released. (Value: "EARLY_ACCESS")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_Ga GA features are
 *        open to all developers and are considered stable and fully qualified
 *        for production use. (Value: "GA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_LaunchStageUnspecified
 *        Do not use this default value. (Value: "LAUNCH_STAGE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_Prelaunch Prelaunch
 *        features are hidden from users and are only visible internally.
 *        (Value: "PRELAUNCH")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_LaunchStage_Unimplemented The
 *        feature is not yet implemented. Users can not use it. (Value:
 *        "UNIMPLEMENTED")
 */
@property(nonatomic, copy, nullable) NSString *launchStage;

/** Optional. Metadata which can be used to guide usage of the metric. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricDescriptorMetadata *metadata;

/**
 *  Whether the metric records instantaneous values, changes to a value, etc.
 *  Some combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Delta The change in a
 *        value during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified
 *        Do not use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  Read-only. If present, then a time series, which is identified partially by
 *  a metric type and a MonitoredResourceDescriptor, that is associated with
 *  this metric type can only be associated with one of the monitored resource
 *  types listed here.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *monitoredResourceTypes;

/** The resource name of the metric descriptor. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The metric type, including its DNS name prefix. The type is not URL-encoded.
 *  All user-defined metric types have the DNS name custom.googleapis.com or
 *  external.googleapis.com. Metric types should use a natural hierarchical
 *  grouping. For example: "custom.googleapis.com/invoice/paid/amount"
 *  "external.googleapis.com/prometheus/up"
 *  "appengine.googleapis.com/http/server/response_latencies"
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The units in which the metric value is reported. It is only applicable if
 *  the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the
 *  representation of the stored metric values.Different systems might scale the
 *  values to be more easily displayed (so a value of 0.02kBy might be displayed
 *  as 20By, and a value of 3523kBy might be displayed as 3.5MBy). However, if
 *  the unit is kBy, then the value of the metric is always in thousands of
 *  bytes, no matter how it might be displayed.If you want a custom metric to
 *  record the exact number of CPU-seconds used by a job, you can create an
 *  INT64 CUMULATIVE metric whose unit is s{CPU} (or equivalently 1s{CPU} or
 *  just s). If the job uses 12,005 CPU-seconds, then the value is written as
 *  12005.Alternatively, if you want a custom metric to record data in a more
 *  granular way, you can create a DOUBLE CUMULATIVE metric whose unit is
 *  ks{CPU}, and then write the value 12.005 (which is 12005/1000), or use
 *  Kis{CPU} and write 11.723 (which is 12005/1024).The supported units are a
 *  subset of The Unified Code for Units of Measure
 *  (https://unitsofmeasure.org/ucum.html) standard:Basic units (UNIT) bit bit
 *  By byte s second min minute h hour d day 1 dimensionlessPrefixes (PREFIX) k
 *  kilo (10^3) M mega (10^6) G giga (10^9) T tera (10^12) P peta (10^15) E exa
 *  (10^18) Z zetta (10^21) Y yotta (10^24) m milli (10^-3) u micro (10^-6) n
 *  nano (10^-9) p pico (10^-12) f femto (10^-15) a atto (10^-18) z zepto
 *  (10^-21) y yocto (10^-24) Ki kibi (2^10) Mi mebi (2^20) Gi gibi (2^30) Ti
 *  tebi (2^40) Pi pebi (2^50)GrammarThe grammar also includes these connectors:
 *  / division or ratio (as an infix operator). For examples, kBy/{email} or
 *  MiBy/10ms (although you should almost never have /s in a metric unit; rates
 *  should always be computed at query time from the underlying cumulative or
 *  delta value). . multiplication or composition (as an infix operator). For
 *  examples, GBy.d or k{watt}.h.The grammar for a unit is as follows:
 *  Expression = Component { "." Component } { "/" Component } ; Component = ( [
 *  PREFIX ] UNIT | "%" ) [ Annotation ] | Annotation | "1" ; Annotation = "{"
 *  NAME "}" ; Notes: Annotation is just a comment if it follows a UNIT. If the
 *  annotation is used alone, then the unit is equivalent to 1. For examples,
 *  {request}/s == 1/s, By{transmitted}/s == By/s. NAME is a sequence of
 *  non-blank printable ASCII characters not containing { or }. 1 represents a
 *  unitary dimensionless unit
 *  (https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such as in 1/s.
 *  It is typically used when none of the basic units are appropriate. For
 *  example, "new users per day" can be represented as 1/d or {new-users}/d (and
 *  a metric value 5 would mean "5 new users). Alternatively, "thousands of page
 *  views per day" would be represented as 1000/d or k1/d or k{page_views}/d
 *  (and a metric value of 5.3 would mean "5300 page views per day"). %
 *  represents dimensionless value of 1/100, and annotates values giving a
 *  percentage (so the metric values are typically in the range of 0..100, and a
 *  metric value 3 means "3 percent"). 10^2.% indicates a metric contains a
 *  ratio, typically in the range 0..1, that will be multiplied by 100 and
 *  displayed as a percentage (so a metric value 0.03 means "3 percent").
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  Whether the measurement is an integer, a floating-point number, etc. Some
 *  combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Bool The value is a
 *        boolean. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Distribution The value
 *        is a Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Double The value is a
 *        double precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Int64 The value is a
 *        signed 64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Money The value is
 *        money. (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_String The value is a
 *        text string. This value type can be used only if the metric kind is
 *        GAUGE. (Value: "STRING")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified Do
 *        not use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Additional annotations that can be used to guide the usage of a metric.
 */
@interface GTLRMonitoring_MetricDescriptorMetadata : GTLRObject

/**
 *  The delay of data points caused by ingestion. Data points older than this
 *  age are guaranteed to be ingested and available to be read, excluding data
 *  loss due to errors.
 */
@property(nonatomic, strong, nullable) GTLRDuration *ingestDelay;

/**
 *  Deprecated. Must use the MetricDescriptor.launch_stage instead.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Alpha Alpha
 *        is a limited availability test for releases before they are cleared
 *        for widespread use. By Alpha, all significant design issues are
 *        resolved and we are in the process of verifying functionality. Alpha
 *        customers need to apply for access, agree to applicable terms, and
 *        have their projects allowlisted. Alpha releases don't have to be
 *        feature complete, no SLAs are provided, and there are no technical
 *        support obligations, but they will be far enough along that customers
 *        can actually use them in test environments or for limited-use tests --
 *        just like they would in normal production cases. (Value: "ALPHA")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Beta Beta is
 *        the point at which we are ready to open a release for any customer to
 *        use. There are no SLA or technical support obligations in a Beta
 *        release. Products will be complete from a feature perspective, but may
 *        have some open outstanding issues. Beta releases are suitable for
 *        limited production use cases. (Value: "BETA")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Deprecated
 *        Deprecated features are scheduled to be shut down and removed. For
 *        more information, see the "Deprecation Policy" section of our Terms of
 *        Service (https://cloud.google.com/terms/) and the Google Cloud
 *        Platform Subject to the Deprecation Policy
 *        (https://cloud.google.com/terms/deprecation) documentation. (Value:
 *        "DEPRECATED")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_EarlyAccess
 *        Early Access features are limited to a closed group of testers. To use
 *        these features, you must sign up in advance and sign a Trusted Tester
 *        agreement (which includes confidentiality provisions). These features
 *        may be unstable, changed in backward-incompatible ways, and are not
 *        guaranteed to be released. (Value: "EARLY_ACCESS")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Ga GA
 *        features are open to all developers and are considered stable and
 *        fully qualified for production use. (Value: "GA")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_LaunchStageUnspecified
 *        Do not use this default value. (Value: "LAUNCH_STAGE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Prelaunch
 *        Prelaunch features are hidden from users and are only visible
 *        internally. (Value: "PRELAUNCH")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Unimplemented
 *        The feature is not yet implemented. Users can not use it. (Value:
 *        "UNIMPLEMENTED")
 */
@property(nonatomic, copy, nullable) NSString *launchStage;

/**
 *  The sampling period of metric data points. For metrics which are written
 *  periodically, consecutive data points are stored at this time interval,
 *  excluding data loss due to errors. Metrics with a higher granularity have a
 *  smaller sampling period.
 */
@property(nonatomic, strong, nullable) GTLRDuration *samplePeriod;

@end


/**
 *  A MetricRange is used when each window is good when the value x of a single
 *  TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries
 *  must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
 */
@interface GTLRMonitoring_MetricRange : GTLRObject

/**
 *  Range of values considered "good." For a one-sided range, set one bound to
 *  an infinite value.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_GoogleMonitoringV3Range *range;

/**
 *  A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  specifying the TimeSeries to use for evaluating window quality.
 */
@property(nonatomic, copy, nullable) NSString *timeSeries;

@end


/**
 *  A condition type that compares a collection of time series against a
 *  threshold.
 */
@interface GTLRMonitoring_MetricThreshold : GTLRObject

/**
 *  Specifies the alignment of data points in individual time series as well as
 *  how to combine the retrieved time series together (such as when aggregating
 *  multiple streams on each resource to a single stream for each resource or
 *  when aggregating streams across all members of a group of resources).
 *  Multiple aggregations are applied in the order specified.This field is
 *  similar to the one in the ListTimeSeries request
 *  (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
 *  It is advisable to use the ListTimeSeries method when debugging this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Aggregation *> *aggregations;

/**
 *  The comparison to apply between the time series (indicated by filter and
 *  aggregation) and the threshold (indicated by threshold_value). The
 *  comparison is applied on each time series, with the time series on the
 *  left-hand side and the threshold on the right-hand side.Only COMPARISON_LT
 *  and COMPARISON_GT are supported currently.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonEq True if
 *        the left argument is equal to the right argument. (Value:
 *        "COMPARISON_EQ")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGe True if
 *        the left argument is greater than or equal to the right argument.
 *        (Value: "COMPARISON_GE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGt True if
 *        the left argument is greater than the right argument. (Value:
 *        "COMPARISON_GT")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLe True if
 *        the left argument is less than or equal to the right argument. (Value:
 *        "COMPARISON_LE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLt True if
 *        the left argument is less than the right argument. (Value:
 *        "COMPARISON_LT")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonNe True if
 *        the left argument is not equal to the right argument. (Value:
 *        "COMPARISON_NE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonUnspecified
 *        No ordering relationship is specified. (Value:
 *        "COMPARISON_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *comparison;

/**
 *  Specifies the alignment of data points in individual time series selected by
 *  denominatorFilter as well as how to combine the retrieved time series
 *  together (such as when aggregating multiple streams on each resource to a
 *  single stream for each resource or when aggregating streams across all
 *  members of a group of resources).When computing ratios, the aggregations and
 *  denominator_aggregations fields must use the same alignment period and
 *  produce time series that have the same periodicity and labels.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Aggregation *> *denominatorAggregations;

/**
 *  A filter (https://cloud.google.com/monitoring/api/v3/filters) that
 *  identifies a time series that should be used as the denominator of a ratio
 *  that will be compared with the threshold. If a denominator_filter is
 *  specified, the time series specified by the filter field will be used as the
 *  numerator.The filter must specify the metric type and optionally may contain
 *  restrictions on resource type, resource labels, and metric labels. This
 *  field may not exceed 2048 Unicode characters in length.
 */
@property(nonatomic, copy, nullable) NSString *denominatorFilter;

/**
 *  The amount of time that a time series must violate the threshold to be
 *  considered failing. Currently, only values that are a multiple of a
 *  minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value
 *  is given, an error will be returned. When choosing a duration, it is useful
 *  to keep in mind the frequency of the underlying time series data (which may
 *  also be affected by any alignments specified in the aggregations field); a
 *  good duration is long enough so that a single outlier does not generate
 *  spurious alerts, but short enough that unhealthy states are detected and
 *  alerted on quickly.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  A condition control that determines how metric-threshold conditions are
 *  evaluated when data stops arriving.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataActive
 *        If there is no data to evaluate the condition, then evaluate the
 *        condition as true. (Value: "EVALUATION_MISSING_DATA_ACTIVE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataInactive
 *        If there is no data to evaluate the condition, then evaluate the
 *        condition as false. (Value: "EVALUATION_MISSING_DATA_INACTIVE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataNoOp
 *        Do not evaluate the condition to any value if there is no data.
 *        (Value: "EVALUATION_MISSING_DATA_NO_OP")
 *    @arg @c kGTLRMonitoring_MetricThreshold_EvaluationMissingData_EvaluationMissingDataUnspecified
 *        An unspecified evaluation missing data option. Equivalent to
 *        EVALUATION_MISSING_DATA_NO_OP. (Value:
 *        "EVALUATION_MISSING_DATA_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *evaluationMissingData;

/**
 *  Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that
 *  identifies which time series should be compared with the threshold.The
 *  filter is similar to the one that is specified in the ListTimeSeries request
 *  (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
 *  (that call is useful to verify the time series that will be retrieved /
 *  processed). The filter must specify the metric type and the resource type.
 *  Optionally, it can specify resource labels and metric labels. This field
 *  must not exceed 2048 Unicode characters in length.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  A value against which to compare the time series.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *thresholdValue;

/**
 *  The number/percent of time series for which the comparison must hold in
 *  order for the condition to trigger. If unspecified, then the condition will
 *  trigger if the comparison is true for any of the time series that have been
 *  identified by filter and aggregations, or by the ratio, if
 *  denominator_filter and denominator_aggregations are specified.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Trigger *trigger;

@end


/**
 *  An object representing a resource that can be used for monitoring, logging,
 *  billing, or other purposes. Examples include virtual machine instances,
 *  databases, and storage devices such as disks. The type field identifies a
 *  MonitoredResourceDescriptor object that describes the resource's schema.
 *  Information in the labels field identifies the actual resource and its
 *  attributes according to the schema. For example, a particular Compute Engine
 *  VM instance could be represented by the following object, because the
 *  MonitoredResourceDescriptor for "gce_instance" has labels "project_id",
 *  "instance_id" and "zone": { "type": "gce_instance", "labels": {
 *  "project_id": "my-project", "instance_id": "12345678901234", "zone":
 *  "us-central1-a" }}
 */
@interface GTLRMonitoring_MonitoredResource : GTLRObject

/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Compute Engine VM instances use the labels
 *  "project_id", "instance_id", and "zone".
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource_Labels *labels;

/**
 *  Required. The monitored resource type. This field must match the type field
 *  of a MonitoredResourceDescriptor object. For example, the type of a Compute
 *  Engine VM instance is gce_instance. For a list of types, see Monitoring
 *  resource types (https://cloud.google.com/monitoring/api/resources) and
 *  Logging resource types
 *  (https://cloud.google.com/logging/docs/api/v2/resource-list).
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Compute Engine VM instances use the labels
 *  "project_id", "instance_id", and "zone".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResource_Labels : GTLRObject
@end


/**
 *  An object that describes the schema of a MonitoredResource object using a
 *  type name and a set of labels. For example, the monitored resource
 *  descriptor for Google Compute Engine VM instances has a type of
 *  "gce_instance" and specifies the use of the labels "instance_id" and "zone"
 *  to identify particular VM instances.Different APIs can support different
 *  monitored resource types. APIs generally provide a list method that returns
 *  the monitored resource descriptors used by the API.
 */
@interface GTLRMonitoring_MonitoredResourceDescriptor : GTLRObject

/**
 *  Optional. A detailed description of the monitored resource type that might
 *  be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. A concise name for the monitored resource type that might be
 *  displayed in user interfaces. It should be a Title Cased Noun Phrase,
 *  without any article or other determiners. For example, "Google Cloud SQL
 *  Database".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required. A set of labels used to describe instances of this monitored
 *  resource type. For example, an individual Google Cloud SQL database is
 *  identified by values for the labels "database_id" and "zone".
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Optional. The launch stage of the monitored resource definition.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Alpha
 *        Alpha is a limited availability test for releases before they are
 *        cleared for widespread use. By Alpha, all significant design issues
 *        are resolved and we are in the process of verifying functionality.
 *        Alpha customers need to apply for access, agree to applicable terms,
 *        and have their projects allowlisted. Alpha releases don't have to be
 *        feature complete, no SLAs are provided, and there are no technical
 *        support obligations, but they will be far enough along that customers
 *        can actually use them in test environments or for limited-use tests --
 *        just like they would in normal production cases. (Value: "ALPHA")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Beta Beta
 *        is the point at which we are ready to open a release for any customer
 *        to use. There are no SLA or technical support obligations in a Beta
 *        release. Products will be complete from a feature perspective, but may
 *        have some open outstanding issues. Beta releases are suitable for
 *        limited production use cases. (Value: "BETA")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Deprecated
 *        Deprecated features are scheduled to be shut down and removed. For
 *        more information, see the "Deprecation Policy" section of our Terms of
 *        Service (https://cloud.google.com/terms/) and the Google Cloud
 *        Platform Subject to the Deprecation Policy
 *        (https://cloud.google.com/terms/deprecation) documentation. (Value:
 *        "DEPRECATED")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_EarlyAccess
 *        Early Access features are limited to a closed group of testers. To use
 *        these features, you must sign up in advance and sign a Trusted Tester
 *        agreement (which includes confidentiality provisions). These features
 *        may be unstable, changed in backward-incompatible ways, and are not
 *        guaranteed to be released. (Value: "EARLY_ACCESS")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Ga GA
 *        features are open to all developers and are considered stable and
 *        fully qualified for production use. (Value: "GA")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_LaunchStageUnspecified
 *        Do not use this default value. (Value: "LAUNCH_STAGE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Prelaunch
 *        Prelaunch features are hidden from users and are only visible
 *        internally. (Value: "PRELAUNCH")
 *    @arg @c kGTLRMonitoring_MonitoredResourceDescriptor_LaunchStage_Unimplemented
 *        The feature is not yet implemented. Users can not use it. (Value:
 *        "UNIMPLEMENTED")
 */
@property(nonatomic, copy, nullable) NSString *launchStage;

/**
 *  Optional. The resource name of the monitored resource descriptor:
 *  "projects/{project_id}/monitoredResourceDescriptors/{type}" where {type} is
 *  the value of the type field in this object and {project_id} is a project ID
 *  that provides API-specific context for accessing the type. APIs that do not
 *  use project information can use the resource name format
 *  "monitoredResourceDescriptors/{type}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The monitored resource type. For example, the type
 *  "cloudsql_database" represents databases in Google Cloud SQL. For a list of
 *  types, see Monitoring resource types
 *  (https://cloud.google.com/monitoring/api/resources) and Logging resource
 *  types (https://cloud.google.com/logging/docs/api/v2/resource-list).
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Auxiliary metadata for a MonitoredResource object. MonitoredResource objects
 *  contain the minimum set of information to uniquely identify a monitored
 *  resource instance. There is some other useful auxiliary metadata. Monitoring
 *  and Logging use an ingestion pipeline to extract metadata for cloud
 *  resources of all types, and store the metadata in this message.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata : GTLRObject

/**
 *  Output only. Values for predefined system metadata labels. System labels are
 *  a kind of metadata extracted by Google, including "machine_image", "vpc",
 *  "subnet_id", "security_group", "name", etc. System label values can be only
 *  strings, Boolean values, or a list of strings. For example: { "name":
 *  "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance":
 *  false }
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata_SystemLabels *systemLabels;

/** Output only. A map of user-defined metadata labels. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata_UserLabels *userLabels;

@end


/**
 *  Output only. Values for predefined system metadata labels. System labels are
 *  a kind of metadata extracted by Google, including "machine_image", "vpc",
 *  "subnet_id", "security_group", "name", etc. System label values can be only
 *  strings, Boolean values, or a list of strings. For example: { "name":
 *  "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance":
 *  false }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata_SystemLabels : GTLRObject
@end


/**
 *  Output only. A map of user-defined metadata labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata_UserLabels : GTLRObject
@end


/**
 *  Describes a change made to a configuration.
 */
@interface GTLRMonitoring_MutationRecord : GTLRObject

/** The email address of the user making the change. */
@property(nonatomic, copy, nullable) NSString *mutatedBy;

/** When the change occurred. */
@property(nonatomic, strong, nullable) GTLRDateTime *mutateTime;

@end


/**
 *  A NotificationChannel is a medium through which an alert is delivered when a
 *  policy violation is detected. Examples of channels include email, SMS, and
 *  third-party messaging applications. Fields containing sensitive information
 *  like authentication tokens or contact info are only partially populated on
 *  retrieval.
 */
@interface GTLRMonitoring_NotificationChannel : GTLRObject

/** Record of the creation of this channel. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MutationRecord *creationRecord;

/**
 *  An optional human-readable description of this notification channel. This
 *  description may provide additional details, beyond the display name, for the
 *  channel. This may not exceed 1024 Unicode characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  An optional human-readable name for this notification channel. It is
 *  recommended that you specify a non-empty and unique name in order to make it
 *  easier to identify the channels in your project, though this is not
 *  enforced. The display name is limited to 512 Unicode characters.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Whether notifications are forwarded to the described channel. This makes it
 *  possible to disable delivery of notifications to a particular channel
 *  without removing the channel from all alerting policies that reference the
 *  channel. This is a more convenient approach when the change is temporary and
 *  you want to receive notifications from the same set of alerting policies on
 *  the channel at some point in the future.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Configuration fields that define the channel and its behavior. The
 *  permissible and required labels are specified in the
 *  NotificationChannelDescriptor.labels of the NotificationChannelDescriptor
 *  corresponding to the type field.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_NotificationChannel_Labels *labels;

/** Records of the modification of this channel. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MutationRecord *> *mutationRecords;

/**
 *  The full REST resource name for this channel. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID] The
 *  [CHANNEL_ID] is automatically assigned by the server on creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The type of the notification channel. This field matches the value of the
 *  NotificationChannelDescriptor.type field.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  User-supplied key/value data that does not need to conform to the
 *  corresponding NotificationChannelDescriptor's schema, unlike the labels
 *  field. This field is intended to be used for organizing and identifying the
 *  NotificationChannel objects.The field can contain up to 64 entries. Each key
 *  and value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_NotificationChannel_UserLabels *userLabels;

/**
 *  Indicates whether this channel has been verified or not. On a
 *  ListNotificationChannels or GetNotificationChannel operation, this field is
 *  expected to be populated.If the value is UNVERIFIED, then it indicates that
 *  the channel is non-functioning (it both requires verification and lacks
 *  verification); otherwise, it is assumed that the channel works.If the
 *  channel is neither VERIFIED nor UNVERIFIED, it implies that the channel is
 *  of a type that does not require verification or that this specific channel
 *  has been exempted from verification because it was created prior to
 *  verification being required for channels of this type.This field cannot be
 *  modified using a standard UpdateNotificationChannel operation. To change the
 *  value of this field, you must call VerifyNotificationChannel.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_NotificationChannel_VerificationStatus_Unverified
 *        The channel has yet to be verified and requires verification to
 *        function. Note that this state also applies to the case where the
 *        verification process has been initiated by sending a verification code
 *        but where the verification code has not been submitted to complete the
 *        process. (Value: "UNVERIFIED")
 *    @arg @c kGTLRMonitoring_NotificationChannel_VerificationStatus_VerificationStatusUnspecified
 *        Sentinel value used to indicate that the state is unknown, omitted, or
 *        is not applicable (as in the case of channels that neither support nor
 *        require verification in order to function). (Value:
 *        "VERIFICATION_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_NotificationChannel_VerificationStatus_Verified It
 *        has been proven that notifications can be received on this
 *        notification channel and that someone on the project has access to
 *        messages that are delivered to that channel. (Value: "VERIFIED")
 */
@property(nonatomic, copy, nullable) NSString *verificationStatus;

@end


/**
 *  Configuration fields that define the channel and its behavior. The
 *  permissible and required labels are specified in the
 *  NotificationChannelDescriptor.labels of the NotificationChannelDescriptor
 *  corresponding to the type field.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_NotificationChannel_Labels : GTLRObject
@end


/**
 *  User-supplied key/value data that does not need to conform to the
 *  corresponding NotificationChannelDescriptor's schema, unlike the labels
 *  field. This field is intended to be used for organizing and identifying the
 *  NotificationChannel objects.The field can contain up to 64 entries. Each key
 *  and value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_NotificationChannel_UserLabels : GTLRObject
@end


/**
 *  A description of a notification channel. The descriptor includes the
 *  properties of the channel and the set of labels or fields that must be
 *  specified to configure channels of a given type.
 */
@interface GTLRMonitoring_NotificationChannelDescriptor : GTLRObject

/**
 *  A human-readable description of the notification channel type. The
 *  description may include a description of the properties of the channel and
 *  pointers to external documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A human-readable name for the notification channel type. This form of the
 *  name is suitable for a user interface.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that must be defined to identify a particular channel of
 *  the corresponding type. Each label includes a description for how that field
 *  should be populated.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  The product launch stage for channels of this type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Alpha
 *        Alpha is a limited availability test for releases before they are
 *        cleared for widespread use. By Alpha, all significant design issues
 *        are resolved and we are in the process of verifying functionality.
 *        Alpha customers need to apply for access, agree to applicable terms,
 *        and have their projects allowlisted. Alpha releases don't have to be
 *        feature complete, no SLAs are provided, and there are no technical
 *        support obligations, but they will be far enough along that customers
 *        can actually use them in test environments or for limited-use tests --
 *        just like they would in normal production cases. (Value: "ALPHA")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Beta
 *        Beta is the point at which we are ready to open a release for any
 *        customer to use. There are no SLA or technical support obligations in
 *        a Beta release. Products will be complete from a feature perspective,
 *        but may have some open outstanding issues. Beta releases are suitable
 *        for limited production use cases. (Value: "BETA")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Deprecated
 *        Deprecated features are scheduled to be shut down and removed. For
 *        more information, see the "Deprecation Policy" section of our Terms of
 *        Service (https://cloud.google.com/terms/) and the Google Cloud
 *        Platform Subject to the Deprecation Policy
 *        (https://cloud.google.com/terms/deprecation) documentation. (Value:
 *        "DEPRECATED")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_EarlyAccess
 *        Early Access features are limited to a closed group of testers. To use
 *        these features, you must sign up in advance and sign a Trusted Tester
 *        agreement (which includes confidentiality provisions). These features
 *        may be unstable, changed in backward-incompatible ways, and are not
 *        guaranteed to be released. (Value: "EARLY_ACCESS")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Ga GA
 *        features are open to all developers and are considered stable and
 *        fully qualified for production use. (Value: "GA")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_LaunchStageUnspecified
 *        Do not use this default value. (Value: "LAUNCH_STAGE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Prelaunch
 *        Prelaunch features are hidden from users and are only visible
 *        internally. (Value: "PRELAUNCH")
 *    @arg @c kGTLRMonitoring_NotificationChannelDescriptor_LaunchStage_Unimplemented
 *        The feature is not yet implemented. Users can not use it. (Value:
 *        "UNIMPLEMENTED")
 */
@property(nonatomic, copy, nullable) NSString *launchStage;

/**
 *  The full REST resource name for this descriptor. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[TYPE] In the
 *  above, [TYPE] is the value of the type field.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The tiers that support this notification channel; the project service tier
 *  must be one of the supported_tiers.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *supportedTiers;

/**
 *  The type of notification channel, such as "email" and "sms". To view the
 *  full list of channels, see Channel descriptors
 *  (https://cloud.google.com/monitoring/alerts/using-channels-api#ncd).
 *  Notification channel types are globally unique.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Control over the rate of notifications sent to this alert policy's
 *  notification channels.
 */
@interface GTLRMonitoring_NotificationRateLimit : GTLRObject

/** Not more than one notification per period. */
@property(nonatomic, strong, nullable) GTLRDuration *period;

@end


/**
 *  Contains metadata for longrunning operation for the edit Metrics Scope
 *  endpoints.
 */
@interface GTLRMonitoring_OperationMetadata : GTLRObject

/** The time when the batch request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Current state of the batch operation.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_OperationMetadata_State_Cancelled The batch
 *        processing was cancelled. (Value: "CANCELLED")
 *    @arg @c kGTLRMonitoring_OperationMetadata_State_Created Request has been
 *        received. (Value: "CREATED")
 *    @arg @c kGTLRMonitoring_OperationMetadata_State_Done The batch processing
 *        is done. (Value: "DONE")
 *    @arg @c kGTLRMonitoring_OperationMetadata_State_Running Request is
 *        actively being processed. (Value: "RUNNING")
 *    @arg @c kGTLRMonitoring_OperationMetadata_State_StateUnspecified Invalid.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** The time when the operation result was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  A protocol buffer option, which can be attached to a message, field,
 *  enumeration, etc.
 */
@interface GTLRMonitoring_Option : GTLRObject

/**
 *  The option's name. For protobuf built-in options (options defined in
 *  descriptor.proto), this is the short name. For example, "map_entry". For
 *  custom options, it should be the fully-qualified name. For example,
 *  "google.api.http".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Option_Value *value;

@end


/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Option_Value : GTLRObject
@end


/**
 *  A PerformanceThreshold is used when each window is good when that window has
 *  a sufficiently high performance.
 */
@interface GTLRMonitoring_PerformanceThreshold : GTLRObject

/** BasicSli to evaluate to judge window quality. */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicSli *basicSliPerformance;

/** RequestBasedSli to evaluate to judge window quality. */
@property(nonatomic, strong, nullable) GTLRMonitoring_RequestBasedSli *performance;

/**
 *  If window performance >= threshold, the window is counted as good.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *threshold;

@end


/**
 *  Information involved in sending ICMP pings alongside public HTTP/TCP checks.
 *  For HTTP, the pings are performed for each part of the redirect chain.
 */
@interface GTLRMonitoring_PingConfig : GTLRObject

/**
 *  Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pingsCount;

@end


/**
 *  A single data point in a time series.
 */
@interface GTLRMonitoring_Point : GTLRObject

/**
 *  The time interval to which the data point applies. For GAUGE metrics, the
 *  start time is optional, but if it is supplied, it must equal the end time.
 *  For DELTA metrics, the start and end time should specify a non-zero
 *  interval, with subsequent points specifying contiguous and non-overlapping
 *  intervals. For CUMULATIVE metrics, the start and end time should specify a
 *  non-zero interval, with subsequent points specifying the same start time and
 *  increasing end times, until an event resets the cumulative value to zero and
 *  sets a new start time for the following points.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeInterval *interval;

/** The value of the data point. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  A point's value columns and time interval. Each point has one or more point
 *  values corresponding to the entries in point_descriptors field in the
 *  TimeSeriesDescriptor associated with this object.
 */
@interface GTLRMonitoring_PointData : GTLRObject

/** The time interval associated with the point. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeInterval *timeInterval;

/** The values that make up the point. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TypedValue *> *values;

@end


/**
 *  A condition type that allows alert policies to be defined using Monitoring
 *  Query Language (https://cloud.google.com/monitoring/mql).
 */
@interface GTLRMonitoring_QueryLanguageCondition : GTLRObject

/**
 *  The amount of time that a time series must violate the threshold to be
 *  considered failing. Currently, only values that are a multiple of a
 *  minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value
 *  is given, an error will be returned. When choosing a duration, it is useful
 *  to keep in mind the frequency of the underlying time series data (which may
 *  also be affected by any alignments specified in the aggregations field); a
 *  good duration is long enough so that a single outlier does not generate
 *  spurious alerts, but short enough that unhealthy states are detected and
 *  alerted on quickly.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  A condition control that determines how metric-threshold conditions are
 *  evaluated when data stops arriving.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataActive
 *        If there is no data to evaluate the condition, then evaluate the
 *        condition as true. (Value: "EVALUATION_MISSING_DATA_ACTIVE")
 *    @arg @c kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataInactive
 *        If there is no data to evaluate the condition, then evaluate the
 *        condition as false. (Value: "EVALUATION_MISSING_DATA_INACTIVE")
 *    @arg @c kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataNoOp
 *        Do not evaluate the condition to any value if there is no data.
 *        (Value: "EVALUATION_MISSING_DATA_NO_OP")
 *    @arg @c kGTLRMonitoring_QueryLanguageCondition_EvaluationMissingData_EvaluationMissingDataUnspecified
 *        An unspecified evaluation missing data option. Equivalent to
 *        EVALUATION_MISSING_DATA_NO_OP. (Value:
 *        "EVALUATION_MISSING_DATA_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *evaluationMissingData;

/**
 *  Monitoring Query Language (https://cloud.google.com/monitoring/mql) query
 *  that outputs a boolean stream.
 */
@property(nonatomic, copy, nullable) NSString *query;

/**
 *  The number/percent of time series for which the comparison must hold in
 *  order for the condition to trigger. If unspecified, then the condition will
 *  trigger if the comparison is true for any of the time series that have been
 *  identified by filter and aggregations, or by the ratio, if
 *  denominator_filter and denominator_aggregations are specified.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Trigger *trigger;

@end


/**
 *  The QueryTimeSeries request.
 */
@interface GTLRMonitoring_QueryTimeSeriesRequest : GTLRObject

/**
 *  A positive number that is the maximum number of time_series_data to return.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The query in the Monitoring Query Language
 *  (https://cloud.google.com/monitoring/mql/reference) format. The default time
 *  zone is in UTC.
 */
@property(nonatomic, copy, nullable) NSString *query;

@end


/**
 *  The QueryTimeSeries response.
 */
@interface GTLRMonitoring_QueryTimeSeriesResponse : GTLRObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  page_token in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Query execution errors that may have caused the time series data returned to
 *  be incomplete. The available data will be available in the response.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Status *> *partialErrors;

/** The time series data. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeriesData *> *timeSeriesData;

/** The descriptor for the time series data. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeSeriesDescriptor *timeSeriesDescriptor;

@end


/**
 *  The range of the population values.
 */
@interface GTLRMonitoring_Range : GTLRObject

/**
 *  The maximum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *max;

/**
 *  The minimum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *min;

@end


/**
 *  Service Level Indicators for which atomic units of service are counted
 *  directly.
 */
@interface GTLRMonitoring_RequestBasedSli : GTLRObject

/**
 *  distribution_cut is used when good_service is a count of values aggregated
 *  in a Distribution that fall into a good range. The total_service is the
 *  total count of all values aggregated in the Distribution.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_DistributionCut *distributionCut;

/**
 *  good_total_ratio is used when the ratio of good_service to total_service is
 *  computed from two TimeSeries.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeSeriesRatio *goodTotalRatio;

@end


/**
 *  The resource submessage for group checks. It can be used instead of a
 *  monitored resource, when multiple resources are being monitored.
 */
@interface GTLRMonitoring_ResourceGroup : GTLRObject

/**
 *  The group of resources being monitored. Should be only the [GROUP_ID], and
 *  not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
 */
@property(nonatomic, copy, nullable) NSString *groupId;

/**
 *  The resource type of the group members.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_AwsElbLoadBalancer A
 *        group of Amazon ELB load balancers. (Value: "AWS_ELB_LOAD_BALANCER")
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_Instance A group of
 *        instances from Google Cloud Platform (GCP) or Amazon Web Services
 *        (AWS). (Value: "INSTANCE")
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_ResourceTypeUnspecified
 *        Default value (not valid). (Value: "RESOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  A status to accept. Either a status code class like "2xx", or an integer
 *  status code like "200".
 */
@interface GTLRMonitoring_ResponseStatusCode : GTLRObject

/**
 *  A class of status codes to accept.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass1xx The
 *        class of status codes between 100 and 199. (Value: "STATUS_CLASS_1XX")
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass2xx The
 *        class of status codes between 200 and 299. (Value: "STATUS_CLASS_2XX")
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass3xx The
 *        class of status codes between 300 and 399. (Value: "STATUS_CLASS_3XX")
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass4xx The
 *        class of status codes between 400 and 499. (Value: "STATUS_CLASS_4XX")
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClass5xx The
 *        class of status codes between 500 and 599. (Value: "STATUS_CLASS_5XX")
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClassAny The
 *        class of all status codes. (Value: "STATUS_CLASS_ANY")
 *    @arg @c kGTLRMonitoring_ResponseStatusCode_StatusClass_StatusClassUnspecified
 *        Default value that matches no status codes. (Value:
 *        "STATUS_CLASS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *statusClass;

/**
 *  A status code to accept.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *statusValue;

@end


/**
 *  The SendNotificationChannelVerificationCode request.
 */
@interface GTLRMonitoring_SendNotificationChannelVerificationCodeRequest : GTLRObject
@end


/**
 *  A Service is a discrete, autonomous, and network-accessible unit, designed
 *  to solve an individual concern (Wikipedia
 *  (https://en.wikipedia.org/wiki/Service-orientation)). In Cloud Monitoring, a
 *  Service acts as the root resource under which operational aspects of the
 *  service are accessible.
 */
@interface GTLRMonitoring_Service : GTLRObject

/** Type used for App Engine services. */
@property(nonatomic, strong, nullable) GTLRMonitoring_AppEngine *appEngine;

/**
 *  Message that contains the service type and service labels of this service if
 *  it is a basic service. Documentation and examples here
 *  (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicService *basicService;

/** Type used for Cloud Endpoints services. */
@property(nonatomic, strong, nullable) GTLRMonitoring_CloudEndpoints *cloudEndpoints;

/** Type used for Cloud Run services. */
@property(nonatomic, strong, nullable) GTLRMonitoring_CloudRun *cloudRun;

/** Type used for Istio services that live in a Kubernetes cluster. */
@property(nonatomic, strong, nullable) GTLRMonitoring_ClusterIstio *clusterIstio;

/** Custom service type. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Custom *custom;

/** Name used for UI elements listing this Service. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Type used for GKE Namespaces. */
@property(nonatomic, strong, nullable) GTLRMonitoring_GkeNamespace *gkeNamespace;

/** Type used for GKE Services (the Kubernetes concept of a service). */
@property(nonatomic, strong, nullable) GTLRMonitoring_GkeService *gkeService;

/** Type used for GKE Workloads. */
@property(nonatomic, strong, nullable) GTLRMonitoring_GkeWorkload *gkeWorkload;

/**
 *  Type used for canonical services scoped to an Istio mesh. Metrics for Istio
 *  are documented here (https://istio.io/latest/docs/reference/config/metrics/)
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_IstioCanonicalService *istioCanonicalService;

/** Type used for Istio services scoped to an Istio mesh. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MeshIstio *meshIstio;

/**
 *  Resource name for this Service. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Configuration for how to query telemetry on a Service. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Telemetry *telemetry;

/**
 *  Labels which have been used to annotate the service. Label keys must start
 *  with a letter. Label keys and values may contain lowercase letters, numbers,
 *  underscores, and dashes. Label keys and values have a maximum length of 63
 *  characters, and must be less than 128 bytes in size. Up to 64 label entries
 *  may be stored. For labels which do not have a semantic value, the empty
 *  string may be supplied for the label value.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Service_UserLabels *userLabels;

@end


/**
 *  Labels which have been used to annotate the service. Label keys must start
 *  with a letter. Label keys and values may contain lowercase letters, numbers,
 *  underscores, and dashes. Label keys and values have a maximum length of 63
 *  characters, and must be less than 128 bytes in size. Up to 64 label entries
 *  may be stored. For labels which do not have a semantic value, the empty
 *  string may be supplied for the label value.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_Service_UserLabels : GTLRObject
@end


/**
 *  A Service-Level Indicator (SLI) describes the "performance" of a service.
 *  For some services, the SLI is well-defined. In such cases, the SLI can be
 *  described easily by referencing the well-known SLI and providing the needed
 *  parameters. Alternatively, a "custom" SLI can be defined with a query to the
 *  underlying metric store. An SLI is defined to be good_service /
 *  total_service over any queried time interval. The value of performance
 *  always falls into the range 0 <= performance <= 1. A custom SLI describes
 *  how to compute this ratio, whether this is by dividing values from a pair of
 *  time series, cutting a Distribution into good and bad counts, or counting
 *  time windows in which the service complies with a criterion. For separation
 *  of concerns, a single Service-Level Indicator measures performance for only
 *  one aspect of service quality, such as fraction of successful queries or
 *  fast-enough queries.
 */
@interface GTLRMonitoring_ServiceLevelIndicator : GTLRObject

/** Basic SLI on a well-known service type. */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicSli *basicSli;

/** Request-based SLIs */
@property(nonatomic, strong, nullable) GTLRMonitoring_RequestBasedSli *requestBased;

/** Windows-based SLIs */
@property(nonatomic, strong, nullable) GTLRMonitoring_WindowsBasedSli *windowsBased;

@end


/**
 *  A Service-Level Objective (SLO) describes a level of desired good service.
 *  It consists of a service-level indicator (SLI), a performance goal, and a
 *  period over which the objective is to be evaluated against that goal. The
 *  SLO can use SLIs defined in a number of different manners. Typical SLOs
 *  might include "99% of requests in each rolling week have latency below 200
 *  milliseconds" or "99.5% of requests in each calendar month return
 *  successfully."
 */
@interface GTLRMonitoring_ServiceLevelObjective : GTLRObject

/**
 *  A calendar period, semantically "since the start of the current ". At this
 *  time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_CalendarPeriodUnspecified
 *        Undefined period, raises an error. (Value:
 *        "CALENDAR_PERIOD_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Day A day.
 *        (Value: "DAY")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Fortnight A
 *        fortnight. The first calendar fortnight of the year begins at the
 *        start of week 1 according to ISO 8601
 *        (https://en.wikipedia.org/wiki/ISO_week_date). (Value: "FORTNIGHT")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Half A
 *        half-year. Half-years start on dates 1-Jan and 1-Jul. (Value: "HALF")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Month A
 *        month. (Value: "MONTH")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Quarter A
 *        quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of
 *        each year. (Value: "QUARTER")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Week A week.
 *        Weeks begin on Monday, following ISO 8601
 *        (https://en.wikipedia.org/wiki/ISO_week_date). (Value: "WEEK")
 *    @arg @c kGTLRMonitoring_ServiceLevelObjective_CalendarPeriod_Year A year.
 *        (Value: "YEAR")
 */
@property(nonatomic, copy, nullable) NSString *calendarPeriod;

/** Name used for UI elements listing this SLO. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The fraction of service that must be good in order for this objective to be
 *  met. 0 < goal <= 0.999.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *goal;

/**
 *  Resource name for this ServiceLevelObjective. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A rolling time period, semantically "in the past ". Must be an integer
 *  multiple of 1 day no larger than 30 days.
 */
@property(nonatomic, strong, nullable) GTLRDuration *rollingPeriod;

/**
 *  The definition of good service, used to measure and calculate the quality of
 *  the Service's performance with respect to a single aspect of service
 *  quality.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_ServiceLevelIndicator *serviceLevelIndicator;

/**
 *  Labels which have been used to annotate the service-level objective. Label
 *  keys must start with a letter. Label keys and values may contain lowercase
 *  letters, numbers, underscores, and dashes. Label keys and values have a
 *  maximum length of 63 characters, and must be less than 128 bytes in size. Up
 *  to 64 label entries may be stored. For labels which do not have a semantic
 *  value, the empty string may be supplied for the label value.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_ServiceLevelObjective_UserLabels *userLabels;

@end


/**
 *  Labels which have been used to annotate the service-level objective. Label
 *  keys must start with a letter. Label keys and values may contain lowercase
 *  letters, numbers, underscores, and dashes. Label keys and values have a
 *  maximum length of 63 characters, and must be less than 128 bytes in size. Up
 *  to 64 label entries may be stored. For labels which do not have a semantic
 *  value, the empty string may be supplied for the label value.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_ServiceLevelObjective_UserLabels : GTLRObject
@end


/**
 *  SourceContext represents information about the source of a protobuf element,
 *  like the file in which it is defined.
 */
@interface GTLRMonitoring_SourceContext : GTLRObject

/**
 *  The path-qualified name of the .proto file that contained the associated
 *  protobuf element. For example: "google/protobuf/source_context.proto".
 */
@property(nonatomic, copy, nullable) NSString *fileName;

@end


/**
 *  The context of a span. This is attached to an Exemplar in Distribution
 *  values during aggregation.It contains the name of a span with format:
 *  projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID]
 */
@interface GTLRMonitoring_SpanContext : GTLRObject

/**
 *  The resource name of the span. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID] [TRACE_ID]
 *  is a unique identifier for a trace within a project; it is a 32-character
 *  hexadecimal encoding of a 16-byte array.[SPAN_ID] is a unique identifier for
 *  a span within a trace; it is a 16-character hexadecimal encoding of an
 *  8-byte array.
 */
@property(nonatomic, copy, nullable) NSString *spanName;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). Each Status message contains three pieces of
 *  data: error code, error message, and error details.You can find out more
 *  about this error model and how to work with it in the API Design Guide
 *  (https://cloud.google.com/apis/design/errors).
 */
@interface GTLRMonitoring_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRMonitoring_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Status_Details_Item : GTLRObject
@end


/**
 *  Information required for a TCP Uptime check request.
 */
@interface GTLRMonitoring_TcpCheck : GTLRObject

/** Contains information needed to add pings to a TCP check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_PingConfig *pingConfig;

/**
 *  The TCP port on the server against which to run the check. Will be combined
 *  with host (specified within the monitored_resource) to construct the full
 *  URL. Required.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

@end


/**
 *  Configuration for how to query telemetry on a Service.
 */
@interface GTLRMonitoring_Telemetry : GTLRObject

/**
 *  The full name of the resource that defines this service. Formatted as
 *  described in https://cloud.google.com/apis/design/resource_names.
 */
@property(nonatomic, copy, nullable) NSString *resourceName;

@end


/**
 *  Describes a time interval: Reads: A half-open time interval. It includes the
 *  end time but excludes the start time: (startTime, endTime]. The start time
 *  must be specified, must be earlier than the end time, and should be no older
 *  than the data retention period for the metric. Writes: A closed time
 *  interval. It extends from the start time to the end time, and includes both:
 *  [startTime, endTime]. Valid time intervals depend on the MetricKind
 *  (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind)
 *  of the metric value. The end time must not be earlier than the start time,
 *  and the end time must not be more than 25 hours in the past or more than
 *  five minutes in the future. For GAUGE metrics, the startTime value is
 *  technically optional; if no value is specified, the start time defaults to
 *  the value of the end time, and the interval represents a single point in
 *  time. If both start and end times are specified, they must be identical.
 *  Such an interval is valid only for GAUGE metrics, which are point-in-time
 *  measurements. The end time of a new interval must be at least a millisecond
 *  after the end time of the previous interval. For DELTA metrics, the start
 *  time and end time must specify a non-zero interval, with subsequent points
 *  specifying contiguous and non-overlapping intervals. For DELTA metrics, the
 *  start time of the next interval must be at least a millisecond after the end
 *  time of the previous interval. For CUMULATIVE metrics, the start time and
 *  end time must specify a non-zero interval, with subsequent points specifying
 *  the same start time and increasing end times, until an event resets the
 *  cumulative value to zero and sets a new start time for the following points.
 *  The new start time must be at least a millisecond after the end time of the
 *  previous interval. The start time of a new interval must be at least a
 *  millisecond after the end time of the previous interval because intervals
 *  are closed. If the start time of a new interval is the same as the end time
 *  of the previous interval, then data written at the new start time could
 *  overwrite data written at the previous end time.
 */
@interface GTLRMonitoring_TimeInterval : GTLRObject

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  A collection of data points that describes the time-varying values of a
 *  metric. A time series is identified by a combination of a fully-specified
 *  monitored resource and a fully-specified metric. This type is used for both
 *  listing and creating time series.
 */
@interface GTLRMonitoring_TimeSeries : GTLRObject

/**
 *  Output only. The associated monitored resource metadata. When reading a time
 *  series, this field will include metadata labels that are explicitly named in
 *  the reduction. When creating a time series, this field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata *metadata;

/**
 *  The associated metric. A fully-specified metric used to identify the time
 *  series.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric *metric;

/**
 *  The metric kind of the time series. When listing time series, this metric
 *  kind might be different from the metric kind of the associated metric if
 *  this time series is an alignment or reduction of other time series.When
 *  creating a time series, this field is optional. If present, it must be the
 *  same as the metric kind of the associated metric. If the associated metric's
 *  descriptor must be auto-created, then this field specifies the metric kind
 *  of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Delta The change in a value
 *        during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified Do not
 *        use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The data points of this time series. When listing time series, points are
 *  returned in reverse time order.When creating a time series, this field must
 *  contain exactly one point and the point's type must be the same as the value
 *  type of the associated metric. If the associated metric's descriptor must be
 *  auto-created, then the value type of the descriptor is determined by the
 *  point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Point *> *points;

/**
 *  The associated monitored resource. Custom metrics can use only certain
 *  monitored resource types in their time series data. For more information,
 *  see Monitored resources for custom metrics
 *  (https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

/**
 *  The units in which the metric value is reported. It is only applicable if
 *  the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the
 *  representation of the stored metric values.
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  The value type of the time series. When listing time series, this value type
 *  might be different from the value type of the associated metric if this time
 *  series is an alignment or reduction of other time series.When creating a
 *  time series, this field is optional. If present, it must be the same as the
 *  type of the data in the points field.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Bool The value is a boolean.
 *        This value type can be used only if the metric kind is GAUGE. (Value:
 *        "BOOL")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Distribution The value is a
 *        Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Double The value is a double
 *        precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Int64 The value is a signed
 *        64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Money The value is money.
 *        (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_String The value is a text
 *        string. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "STRING")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified Do not
 *        use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Represents the values of a time series associated with a
 *  TimeSeriesDescriptor.
 */
@interface GTLRMonitoring_TimeSeriesData : GTLRObject

/**
 *  The values of the labels in the time series identifier, given in the same
 *  order as the label_descriptors field of the TimeSeriesDescriptor associated
 *  with this object. Each value must have a value of the type given in the
 *  corresponding entry of label_descriptors.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelValue *> *labelValues;

/** The points in the time series. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_PointData *> *pointData;

@end


/**
 *  A descriptor for the labels and points in a time series.
 */
@interface GTLRMonitoring_TimeSeriesDescriptor : GTLRObject

/** Descriptors for the labels. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labelDescriptors;

/** Descriptors for the point data value columns. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_ValueDescriptor *> *pointDescriptors;

@end


/**
 *  A TimeSeriesRatio specifies two TimeSeries to use for computing the
 *  good_service / total_service ratio. The specified TimeSeries must have
 *  ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or
 *  MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of
 *  good, bad, and total, and the relationship good_service + bad_service =
 *  total_service will be assumed.
 */
@interface GTLRMonitoring_TimeSeriesRatio : GTLRObject

/**
 *  A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  specifying a TimeSeries quantifying bad service, either demanded service
 *  that was not provided or demanded service that was of inadequate quality.
 *  Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind =
 *  DELTA or MetricKind = CUMULATIVE.
 */
@property(nonatomic, copy, nullable) NSString *badServiceFilter;

/**
 *  A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  specifying a TimeSeries quantifying good service provided. Must have
 *  ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or
 *  MetricKind = CUMULATIVE.
 */
@property(nonatomic, copy, nullable) NSString *goodServiceFilter;

/**
 *  A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  specifying a TimeSeries quantifying total demanded service. Must have
 *  ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or
 *  MetricKind = CUMULATIVE.
 */
@property(nonatomic, copy, nullable) NSString *totalServiceFilter;

@end


/**
 *  Specifies how many time series must fail a predicate to trigger a condition.
 *  If not specified, then a {count: 1} trigger is used.
 */
@interface GTLRMonitoring_Trigger : GTLRObject

/**
 *  The absolute number of time series that must fail the predicate for the
 *  condition to be triggered.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The percentage of time series that must fail the predicate for the condition
 *  to be triggered.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percent;

@end


/**
 *  A protocol buffer message type.
 */
@interface GTLRMonitoring_Type : GTLRObject

/** The list of fields. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Field *> *fields;

/** The fully qualified message name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The list of types appearing in oneof definitions in this type. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oneofs;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/** The source context. */
@property(nonatomic, strong, nullable) GTLRMonitoring_SourceContext *sourceContext;

/**
 *  The source syntax.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto2 Syntax proto2. (Value:
 *        "SYNTAX_PROTO2")
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto3 Syntax proto3. (Value:
 *        "SYNTAX_PROTO3")
 */
@property(nonatomic, copy, nullable) NSString *syntax;

@end


/**
 *  A single strongly-typed value.
 */
@interface GTLRMonitoring_TypedValue : GTLRObject

/**
 *  A Boolean value: true or false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Distribution *distributionValue;

/**
 *  A 64-bit double-precision floating-point number. Its magnitude is
 *  approximately ±10±300 and it has 16 significant digits of precision.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  A 64-bit integer. Its range is approximately ±9.2x1018.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** A variable-length string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  This message configures which resources and services to monitor for
 *  availability.
 */
@interface GTLRMonitoring_UptimeCheckConfig : GTLRObject

/**
 *  The type of checkers to use to execute the Uptime check.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_UptimeCheckConfig_CheckerType_CheckerTypeUnspecified
 *        The default checker type. Currently converted to STATIC_IP_CHECKERS on
 *        creation, the default conversion behavior may change in the future.
 *        (Value: "CHECKER_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_UptimeCheckConfig_CheckerType_StaticIpCheckers
 *        STATIC_IP_CHECKERS are used for uptime checks that perform egress
 *        across the public internet. STATIC_IP_CHECKERS use the static IP
 *        addresses returned by ListUptimeCheckIps. (Value:
 *        "STATIC_IP_CHECKERS")
 *    @arg @c kGTLRMonitoring_UptimeCheckConfig_CheckerType_VpcCheckers
 *        VPC_CHECKERS are used for uptime checks that perform egress using
 *        Service Directory and private network access. When using VPC_CHECKERS,
 *        the monitored resource type must be servicedirectory_service. (Value:
 *        "VPC_CHECKERS")
 */
@property(nonatomic, copy, nullable) NSString *checkerType;

/**
 *  The content that is expected to appear in the data returned by the target
 *  server against which the check is run. Currently, only the first entry in
 *  the content_matchers list is supported, and additional entries will be
 *  ignored. This field is optional and should only be specified if a content
 *  match is required as part of the/ Uptime check.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_ContentMatcher *> *contentMatchers;

/**
 *  A human-friendly name for the Uptime check configuration. The display name
 *  should be unique within a Cloud Monitoring Workspace in order to make it
 *  easier to identify; however, uniqueness is not enforced. Required.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Contains information needed to make an HTTP or HTTPS check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_HttpCheck *httpCheck;

/**
 *  The internal checkers that this check will egress from. If is_internal is
 *  true and this list is empty, the check will egress from all the
 *  InternalCheckers configured for the project that owns this
 *  UptimeCheckConfig.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_InternalChecker *> *internalCheckers;

/**
 *  If this is true, then checks are made only from the 'internal_checkers'. If
 *  it is false, then checks are made only from the 'selected_regions'. It is an
 *  error to provide 'selected_regions' when is_internal is true, or to provide
 *  'internal_checkers' when is_internal is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isInternal;

/**
 *  The monitored resource (https://cloud.google.com/monitoring/api/resources)
 *  associated with the configuration. The following monitored resource types
 *  are valid for this field: uptime_url, gce_instance, gae_app,
 *  aws_ec2_instance, aws_elb_load_balancer k8s_service servicedirectory_service
 *  cloud_run_revision
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *monitoredResource;

/**
 *  A unique resource name for this Uptime check configuration. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 *  [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the
 *  Uptime check.This field should be omitted when creating the Uptime check
 *  configuration; on create, the resource name is assigned by the server and
 *  included in the response.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  How often, in seconds, the Uptime check is performed. Currently, the only
 *  supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes),
 *  and 900s (15 minutes). Optional, defaults to 60s.
 */
@property(nonatomic, strong, nullable) GTLRDuration *period;

/** The group resource associated with the configuration. */
@property(nonatomic, strong, nullable) GTLRMonitoring_ResourceGroup *resourceGroup;

/**
 *  The list of regions from which the check will be run. Some regions contain
 *  one location, and others contain more than one. If this field is specified,
 *  enough regions must be provided to include a minimum of 3 locations. Not
 *  specifying this field will result in Uptime checks running from all
 *  available regions.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *selectedRegions;

/** Contains information needed to make a TCP check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TcpCheck *tcpCheck;

/**
 *  The maximum amount of time to wait for the request to complete (must be
 *  between 1 and 60 seconds). Required.
 */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

/**
 *  User-supplied key/value data to be used for organizing and identifying the
 *  UptimeCheckConfig objects.The field can contain up to 64 entries. Each key
 *  and value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_UptimeCheckConfig_UserLabels *userLabels;

@end


/**
 *  User-supplied key/value data to be used for organizing and identifying the
 *  UptimeCheckConfig objects.The field can contain up to 64 entries. Each key
 *  and value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_UptimeCheckConfig_UserLabels : GTLRObject
@end


/**
 *  Contains the region, location, and list of IP addresses where checkers in
 *  the location run from.
 */
@interface GTLRMonitoring_UptimeCheckIp : GTLRObject

/**
 *  The IP address from which the Uptime check originates. This is a fully
 *  specified IP address (not an IP address range). Most IP addresses, as of
 *  this publication, are in IPv4 format; however, one should not rely on the IP
 *  addresses being in IPv4 format indefinitely, and should support interpreting
 *  this field in either IPv4 or IPv6 format.
 */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/**
 *  A more specific location within the region that typically encodes a
 *  particular city/town/metro (and its containing state/province or country)
 *  within the broader umbrella region category.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  A broad region category in which the IP address is located.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_AsiaPacific Allows checks to
 *        run from locations within the Asia Pacific area (ex: Singapore).
 *        (Value: "ASIA_PACIFIC")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_Europe Allows checks to run
 *        from locations within the continent of Europe. (Value: "EUROPE")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_RegionUnspecified Default
 *        value if no region is specified. Will result in Uptime checks running
 *        from all regions. (Value: "REGION_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_SouthAmerica Allows checks to
 *        run from locations within the continent of South America. (Value:
 *        "SOUTH_AMERICA")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_Usa Allows checks to run from
 *        locations within the United States of America. (Value: "USA")
 */
@property(nonatomic, copy, nullable) NSString *region;

@end


/**
 *  A descriptor for the value columns in a data point.
 */
@interface GTLRMonitoring_ValueDescriptor : GTLRObject

/** The value key. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  The value stream kind.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ValueDescriptor_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_MetricKind_Delta The change in a
 *        value during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_MetricKind_MetricKindUnspecified
 *        Do not use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The unit in which time_series point values are reported. unit follows the
 *  UCUM format for units as seen in https://unitsofmeasure.org/ucum.html. unit
 *  is only valid if value_type is INTEGER, DOUBLE, DISTRIBUTION.
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  The value type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_Bool The value is a
 *        boolean. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_Distribution The value
 *        is a Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_Double The value is a
 *        double precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_Int64 The value is a
 *        signed 64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_Money The value is
 *        money. (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_String The value is a
 *        text string. This value type can be used only if the metric kind is
 *        GAUGE. (Value: "STRING")
 *    @arg @c kGTLRMonitoring_ValueDescriptor_ValueType_ValueTypeUnspecified Do
 *        not use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  The VerifyNotificationChannel request.
 */
@interface GTLRMonitoring_VerifyNotificationChannelRequest : GTLRObject

/**
 *  Required. The verification code that was delivered to the channel as a
 *  result of invoking the SendNotificationChannelVerificationCode API method or
 *  that was retrieved from a verified channel via
 *  GetNotificationChannelVerificationCode. For example, one might have
 *  "G-123456" or "TKNZGhhd2EyN3I1MnRnMjRv" (in general, one is only guaranteed
 *  that the code is valid UTF-8; one should not make any assumptions regarding
 *  the structure or format of the code).
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  A WindowsBasedSli defines good_service as the count of time windows for
 *  which the provided service was of good quality. Criteria for determining if
 *  service was good are embedded in the window_criterion.
 */
@interface GTLRMonitoring_WindowsBasedSli : GTLRObject

/**
 *  A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  specifying a TimeSeries with ValueType = BOOL. The window is good if any
 *  true values appear in the window.
 */
@property(nonatomic, copy, nullable) NSString *goodBadMetricFilter;

/** A window is good if its performance is high enough. */
@property(nonatomic, strong, nullable) GTLRMonitoring_PerformanceThreshold *goodTotalRatioThreshold;

/**
 *  A window is good if the metric's value is in a good range, averaged across
 *  returned streams.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricRange *metricMeanInRange;

/**
 *  A window is good if the metric's value is in a good range, summed across
 *  returned streams.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricRange *metricSumInRange;

/**
 *  Duration over which window quality is evaluated. Must be an integer fraction
 *  of a day and at least 60s.
 */
@property(nonatomic, strong, nullable) GTLRDuration *windowPeriod;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
