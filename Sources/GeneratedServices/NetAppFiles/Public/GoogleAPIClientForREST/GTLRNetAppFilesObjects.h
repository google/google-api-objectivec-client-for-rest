// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   NetApp API (netapp/v1)
// Description:
//   Google Cloud NetApp Volumes is a fully-managed, cloud-based data storage
//   service that provides advanced data management capabilities and highly
//   scalable performance with global availability.
// Documentation:
//   https://cloud.google.com/netapp/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRNetAppFiles_ActiveDirectory;
@class GTLRNetAppFiles_ActiveDirectory_Labels;
@class GTLRNetAppFiles_Backup;
@class GTLRNetAppFiles_Backup_Labels;
@class GTLRNetAppFiles_BackupConfig;
@class GTLRNetAppFiles_BackupPolicy;
@class GTLRNetAppFiles_BackupPolicy_Labels;
@class GTLRNetAppFiles_BackupRetentionPolicy;
@class GTLRNetAppFiles_BackupVault;
@class GTLRNetAppFiles_BackupVault_Labels;
@class GTLRNetAppFiles_DailySchedule;
@class GTLRNetAppFiles_DestinationVolumeParameters;
@class GTLRNetAppFiles_ExportPolicy;
@class GTLRNetAppFiles_HourlySchedule;
@class GTLRNetAppFiles_HybridPeeringDetails;
@class GTLRNetAppFiles_HybridReplicationParameters;
@class GTLRNetAppFiles_HybridReplicationParameters_Labels;
@class GTLRNetAppFiles_KmsConfig;
@class GTLRNetAppFiles_KmsConfig_Labels;
@class GTLRNetAppFiles_Location;
@class GTLRNetAppFiles_Location_Labels;
@class GTLRNetAppFiles_Location_Metadata;
@class GTLRNetAppFiles_MonthlySchedule;
@class GTLRNetAppFiles_MountOption;
@class GTLRNetAppFiles_Operation;
@class GTLRNetAppFiles_Operation_Metadata;
@class GTLRNetAppFiles_Operation_Response;
@class GTLRNetAppFiles_QuotaRule;
@class GTLRNetAppFiles_QuotaRule_Labels;
@class GTLRNetAppFiles_Replication;
@class GTLRNetAppFiles_Replication_Labels;
@class GTLRNetAppFiles_RestoreParameters;
@class GTLRNetAppFiles_SimpleExportPolicyRule;
@class GTLRNetAppFiles_Snapshot;
@class GTLRNetAppFiles_Snapshot_Labels;
@class GTLRNetAppFiles_SnapshotPolicy;
@class GTLRNetAppFiles_Status;
@class GTLRNetAppFiles_Status_Details_Item;
@class GTLRNetAppFiles_StoragePool;
@class GTLRNetAppFiles_StoragePool_Labels;
@class GTLRNetAppFiles_TieringPolicy;
@class GTLRNetAppFiles_TransferStats;
@class GTLRNetAppFiles_Volume;
@class GTLRNetAppFiles_Volume_Labels;
@class GTLRNetAppFiles_WeeklySchedule;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_ActiveDirectory.state

/**
 *  Active Directory State is Creating
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_Creating;
/**
 *  Active Directory State is Deleting
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_Deleting;
/**
 *  Active Directory State is Diagnosing.
 *
 *  Value: "DIAGNOSING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_Diagnosing;
/**
 *  Active Directory State is Error
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_Error;
/**
 *  Active Directory State is In use
 *
 *  Value: "IN_USE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_InUse;
/**
 *  Active Directory State is Ready
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_Ready;
/**
 *  Unspecified Active Directory State
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_StateUnspecified;
/**
 *  Active Directory State is Updating
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ActiveDirectory_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Backup.backupType

/**
 *  Manual backup type.
 *
 *  Value: "MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_BackupType_Manual;
/**
 *  Scheduled backup type.
 *
 *  Value: "SCHEDULED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_BackupType_Scheduled;
/**
 *  Unspecified backup type.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_BackupType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Backup.state

/**
 *  Backup is being created. While in this state, the snapshot for the backup
 *  point-in-time may not have been created yet, and so the point-in-time may
 *  not have been fixed.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_Creating;
/**
 *  Backup is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_Deleting;
/**
 *  Backup is not valid and cannot be used for creating new volumes or restoring
 *  existing volumes.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_Error;
/**
 *  Backup is available for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_Ready;
/**
 *  State not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_StateUnspecified;
/**
 *  Backup is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_Updating;
/**
 *  Backup is being uploaded. While in this state, none of the writes to the
 *  volume will be included in the backup.
 *
 *  Value: "UPLOADING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Backup_State_Uploading;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_BackupPolicy.state

/**
 *  BackupPolicy is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupPolicy_State_Creating;
/**
 *  BackupPolicy is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupPolicy_State_Deleting;
/**
 *  BackupPolicy is not valid and cannot be used.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupPolicy_State_Error;
/**
 *  BackupPolicy is available for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupPolicy_State_Ready;
/**
 *  State not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupPolicy_State_StateUnspecified;
/**
 *  BackupPolicy is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupPolicy_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_BackupVault.backupVaultType

/**
 *  BackupVault type not set.
 *
 *  Value: "BACKUP_VAULT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_BackupVaultType_BackupVaultTypeUnspecified;
/**
 *  BackupVault type is CROSS_REGION.
 *
 *  Value: "CROSS_REGION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_BackupVaultType_CrossRegion;
/**
 *  BackupVault type is IN_REGION.
 *
 *  Value: "IN_REGION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_BackupVaultType_InRegion;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_BackupVault.state

/**
 *  BackupVault is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_State_Creating;
/**
 *  BackupVault is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_State_Deleting;
/**
 *  BackupVault is not valid and cannot be used.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_State_Error;
/**
 *  BackupVault is available for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_State_Ready;
/**
 *  State not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_State_StateUnspecified;
/**
 *  BackupVault is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_BackupVault_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_KmsConfig.state

/**
 *  KmsConfig State is Creating
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Creating;
/**
 *  KmsConfig State is Deleting
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Deleting;
/**
 *  KmsConfig State is Disabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Disabled;
/**
 *  KmsConfig State is Disabling.
 *
 *  Value: "DISABLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Disabling;
/**
 *  KmsConfig State is Error
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Error;
/**
 *  KmsConfig State is In Use.
 *
 *  Value: "IN_USE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_InUse;
/**
 *  KmsConfig State is Pending to verify crypto key access.
 *
 *  Value: "KEY_CHECK_PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_KeyCheckPending;
/**
 *  KmsConfig State is Not accessbile by the SDE service account to the crypto
 *  key.
 *
 *  Value: "KEY_NOT_REACHABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_KeyNotReachable;
/**
 *  KmsConfig State is Migrating. The existing volumes are migrating from SMEK
 *  to CMEK.
 *
 *  Value: "MIGRATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Migrating;
/**
 *  KmsConfig State is Ready
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Ready;
/**
 *  Unspecified KmsConfig State
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_StateUnspecified;
/**
 *  KmsConfig State is Updating
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_KmsConfig_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_LocationMetadata.supportedFlexPerformance

/**
 *  Flex Storage Pool with custom performance.
 *
 *  Value: "FLEX_PERFORMANCE_CUSTOM"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedFlexPerformance_FlexPerformanceCustom;
/**
 *  Flex Storage Pool with default performance.
 *
 *  Value: "FLEX_PERFORMANCE_DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedFlexPerformance_FlexPerformanceDefault;
/**
 *  Unspecified flex performance.
 *
 *  Value: "FLEX_PERFORMANCE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedFlexPerformance_FlexPerformanceUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_LocationMetadata.supportedServiceLevels

/**
 *  Extreme service level.
 *
 *  Value: "EXTREME"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedServiceLevels_Extreme;
/**
 *  Flex service level.
 *
 *  Value: "FLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedServiceLevels_Flex;
/**
 *  Premium service level.
 *
 *  Value: "PREMIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedServiceLevels_Premium;
/**
 *  Unspecified service level.
 *
 *  Value: "SERVICE_LEVEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedServiceLevels_ServiceLevelUnspecified;
/**
 *  Standard service level.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_LocationMetadata_SupportedServiceLevels_Standard;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_MountOption.protocol

/**
 *  NFS V3 protocol
 *
 *  Value: "NFSV3"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_MountOption_Protocol_Nfsv3;
/**
 *  NFS V4 protocol
 *
 *  Value: "NFSV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_MountOption_Protocol_Nfsv4;
/**
 *  Unspecified protocol
 *
 *  Value: "PROTOCOLS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_MountOption_Protocol_ProtocolsUnspecified;
/**
 *  SMB protocol
 *
 *  Value: "SMB"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_MountOption_Protocol_Smb;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_QuotaRule.state

/**
 *  Quota rule is creating
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_State_Creating;
/**
 *  Quota rule is deleting
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_State_Deleting;
/**
 *  Quota rule is in error state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_State_Error;
/**
 *  Quota rule is ready
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_State_Ready;
/**
 *  Unspecified state for quota rule
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_State_StateUnspecified;
/**
 *  Quota rule is updating
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_QuotaRule.type

/**
 *  Default group quota rule
 *
 *  Value: "DEFAULT_GROUP_QUOTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_Type_DefaultGroupQuota;
/**
 *  Default user quota rule
 *
 *  Value: "DEFAULT_USER_QUOTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_Type_DefaultUserQuota;
/**
 *  Individual group quota rule
 *
 *  Value: "INDIVIDUAL_GROUP_QUOTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_Type_IndividualGroupQuota;
/**
 *  Individual user quota rule
 *
 *  Value: "INDIVIDUAL_USER_QUOTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_Type_IndividualUserQuota;
/**
 *  Unspecified type for quota rule
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_QuotaRule_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Replication.hybridReplicationType

/**
 *  Hybrid replication type for continuous replication.
 *
 *  Value: "CONTINUOUS_REPLICATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_HybridReplicationType_ContinuousReplication;
/**
 *  Unspecified hybrid replication type.
 *
 *  Value: "HYBRID_REPLICATION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_HybridReplicationType_HybridReplicationTypeUnspecified;
/**
 *  Hybrid replication type for migration.
 *
 *  Value: "MIGRATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_HybridReplicationType_Migration;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Replication.mirrorState

/**
 *  Replication is aborted.
 *
 *  Value: "ABORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_Aborted;
/**
 *  Baseline replication is in progress.
 *
 *  Value: "BASELINE_TRANSFERRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_BaselineTransferring;
/**
 *  Destination volume has been initialized and is ready to receive replication
 *  transfers.
 *
 *  Value: "MIRRORED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_Mirrored;
/**
 *  Unspecified MirrorState
 *
 *  Value: "MIRROR_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_MirrorStateUnspecified;
/**
 *  Destination volume is being prepared.
 *
 *  Value: "PREPARING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_Preparing;
/**
 *  Destination volume is not receiving replication transfers.
 *
 *  Value: "STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_Stopped;
/**
 *  Incremental replication is in progress.
 *
 *  Value: "TRANSFERRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_MirrorState_Transferring;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Replication.replicationSchedule

/**
 *  Replication happens once every day.
 *
 *  Value: "DAILY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_ReplicationSchedule_Daily;
/**
 *  Replication happens once every 10 minutes.
 *
 *  Value: "EVERY_10_MINUTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_ReplicationSchedule_Every10Minutes;
/**
 *  Replication happens once every hour.
 *
 *  Value: "HOURLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_ReplicationSchedule_Hourly;
/**
 *  Unspecified ReplicationSchedule
 *
 *  Value: "REPLICATION_SCHEDULE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_ReplicationSchedule_ReplicationScheduleUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Replication.role

/**
 *  Indicates Destination volume.
 *
 *  Value: "DESTINATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_Role_Destination;
/**
 *  Unspecified replication role
 *
 *  Value: "REPLICATION_ROLE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_Role_ReplicationRoleUnspecified;
/**
 *  Indicates Source volume.
 *
 *  Value: "SOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_Role_Source;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Replication.state

/**
 *  Replication is creating.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_Creating;
/**
 *  Replication is deleting.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_Deleting;
/**
 *  Replication is in error state.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_Error;
/**
 *  Replication is waiting for cluster peering to be established.
 *
 *  Value: "PENDING_CLUSTER_PEERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_PendingClusterPeering;
/**
 *  Replication is waiting for SVM peering to be established.
 *
 *  Value: "PENDING_SVM_PEERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_PendingSvmPeering;
/**
 *  Replication is ready.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_Ready;
/**
 *  Unspecified replication State
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_StateUnspecified;
/**
 *  Replication is updating.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Replication_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_SimpleExportPolicyRule.accessType

/**
 *  Unspecified Access Type
 *
 *  Value: "ACCESS_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_AccessTypeUnspecified;
/**
 *  None
 *
 *  Value: "READ_NONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_ReadNone;
/**
 *  Read Only
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_ReadOnly;
/**
 *  Read Write
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_ReadWrite;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Snapshot.state

/**
 *  Snapshot State is Creating
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_Creating;
/**
 *  Snapshot State is Deleting
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_Deleting;
/**
 *  Snapshot State is Disabled
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_Disabled;
/**
 *  Snapshot State is Error
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_Error;
/**
 *  Snapshot State is Ready
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_Ready;
/**
 *  Unspecified Snapshot State
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_StateUnspecified;
/**
 *  Snapshot State is Updating
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Snapshot_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_StoragePool.encryptionType

/**
 *  Customer managed encryption key, which is stored in KMS.
 *
 *  Value: "CLOUD_KMS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_EncryptionType_CloudKms;
/**
 *  The source of the encryption key is not specified.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Google managed encryption key.
 *
 *  Value: "SERVICE_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_EncryptionType_ServiceManaged;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_StoragePool.serviceLevel

/**
 *  Extreme service level.
 *
 *  Value: "EXTREME"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_ServiceLevel_Extreme;
/**
 *  Flex service level.
 *
 *  Value: "FLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_ServiceLevel_Flex;
/**
 *  Premium service level.
 *
 *  Value: "PREMIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_ServiceLevel_Premium;
/**
 *  Unspecified service level.
 *
 *  Value: "SERVICE_LEVEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_ServiceLevel_ServiceLevelUnspecified;
/**
 *  Standard service level.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_ServiceLevel_Standard;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_StoragePool.state

/**
 *  Storage Pool State is Creating
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Creating;
/**
 *  Storage Pool State is Deleting
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Deleting;
/**
 *  Storage Pool State is Disabled
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Disabled;
/**
 *  Storage Pool State is Error
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Error;
/**
 *  Storage Pool State is Ready
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Ready;
/**
 *  Storage Pool State is Restoring
 *
 *  Value: "RESTORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Restoring;
/**
 *  Unspecified Storage Pool State
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_StateUnspecified;
/**
 *  Storage Pool State is Updating
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_StoragePool_State_Updating;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_TieringPolicy.tierAction

/**
 *  When tiering is enabled, new cold data will be tiered.
 *
 *  Value: "ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_TieringPolicy_TierAction_Enabled;
/**
 *  When paused, tiering won't be performed on new data. Existing data stays
 *  tiered until accessed.
 *
 *  Value: "PAUSED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_TieringPolicy_TierAction_Paused;
/**
 *  Unspecified.
 *
 *  Value: "TIER_ACTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_TieringPolicy_TierAction_TierActionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_ValidateDirectoryServiceRequest.directoryServiceType

/**
 *  Active directory policy attached to the storage pool.
 *
 *  Value: "ACTIVE_DIRECTORY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ValidateDirectoryServiceRequest_DirectoryServiceType_ActiveDirectory;
/**
 *  Directory service type is not specified.
 *
 *  Value: "DIRECTORY_SERVICE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_ValidateDirectoryServiceRequest_DirectoryServiceType_DirectoryServiceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.encryptionType

/**
 *  Customer managed encryption key, which is stored in KMS.
 *
 *  Value: "CLOUD_KMS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_EncryptionType_CloudKms;
/**
 *  The source of the encryption key is not specified.
 *
 *  Value: "ENCRYPTION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_EncryptionType_EncryptionTypeUnspecified;
/**
 *  Google managed encryption key.
 *
 *  Value: "SERVICE_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_EncryptionType_ServiceManaged;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.protocols

/**
 *  NFS V3 protocol
 *
 *  Value: "NFSV3"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_Protocols_Nfsv3;
/**
 *  NFS V4 protocol
 *
 *  Value: "NFSV4"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_Protocols_Nfsv4;
/**
 *  Unspecified protocol
 *
 *  Value: "PROTOCOLS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_Protocols_ProtocolsUnspecified;
/**
 *  SMB protocol
 *
 *  Value: "SMB"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_Protocols_Smb;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.restrictedActions

/**
 *  Prevent volume from being deleted when mounted.
 *
 *  Value: "DELETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_RestrictedActions_Delete;
/**
 *  Unspecified restricted action
 *
 *  Value: "RESTRICTED_ACTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_RestrictedActions_RestrictedActionUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.securityStyle

/**
 *  SecurityStyle uses NTFS
 *
 *  Value: "NTFS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SecurityStyle_Ntfs;
/**
 *  SecurityStyle is unspecified
 *
 *  Value: "SECURITY_STYLE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SecurityStyle_SecurityStyleUnspecified;
/**
 *  SecurityStyle uses UNIX
 *
 *  Value: "UNIX"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SecurityStyle_Unix;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.serviceLevel

/**
 *  Extreme service level.
 *
 *  Value: "EXTREME"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_ServiceLevel_Extreme;
/**
 *  Flex service level.
 *
 *  Value: "FLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_ServiceLevel_Flex;
/**
 *  Premium service level.
 *
 *  Value: "PREMIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_ServiceLevel_Premium;
/**
 *  Unspecified service level.
 *
 *  Value: "SERVICE_LEVEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_ServiceLevel_ServiceLevelUnspecified;
/**
 *  Standard service level.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_ServiceLevel_Standard;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.smbSettings

/**
 *  SMB setting to access volume based on enumerartion
 *
 *  Value: "ACCESS_BASED_ENUMERATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_AccessBasedEnumeration;
/**
 *  SMB setting browsable
 *
 *  Value: "BROWSABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_Browsable;
/**
 *  SMB setting notify change
 *
 *  Value: "CHANGE_NOTIFY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_ChangeNotify;
/**
 *  Continuously available enumeration
 *
 *  Value: "CONTINUOUSLY_AVAILABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_ContinuouslyAvailable;
/**
 *  SMB setting encrypt data
 *
 *  Value: "ENCRYPT_DATA"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_EncryptData;
/**
 *  SMB setting not to notify change
 *
 *  Value: "NON_BROWSABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_NonBrowsable;
/**
 *  SMB setting oplocks
 *
 *  Value: "OPLOCKS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_Oplocks;
/**
 *  SMB setting to show previous versions
 *
 *  Value: "SHOW_PREVIOUS_VERSIONS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_ShowPreviousVersions;
/**
 *  SMB setting to show snapshots
 *
 *  Value: "SHOW_SNAPSHOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_ShowSnapshot;
/**
 *  Unspecified default option
 *
 *  Value: "SMB_SETTINGS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_SmbSettings_SmbSettingsUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetAppFiles_Volume.state

/**
 *  Volume State is Creating
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Creating;
/**
 *  Volume State is Deleting
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Deleting;
/**
 *  Volume State is Disabled
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Disabled;
/**
 *  Volume State is Error
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Error;
/**
 *  Volume State is Preparing. Note that this is different from CREATING where
 *  CREATING means the volume is being created, while PREPARING means the volume
 *  is created and now being prepared for the replication.
 *
 *  Value: "PREPARING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Preparing;
/**
 *  Volume State is Read Only
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_ReadOnly;
/**
 *  Volume State is Ready
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Ready;
/**
 *  Volume State is Restoring
 *
 *  Value: "RESTORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Restoring;
/**
 *  Unspecified Volume State
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_StateUnspecified;
/**
 *  Volume State is Updating
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetAppFiles_Volume_State_Updating;

/**
 *  ActiveDirectory is the public representation of the active directory config.
 */
@interface GTLRNetAppFiles_ActiveDirectory : GTLRObject

/** Optional. Users to be added to the Built-in Admininstrators group. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *administrators;

/**
 *  If enabled, AES encryption will be enabled for SMB communication.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aesEncryption;

/**
 *  Optional. Users to be added to the Built-in Backup Operator active directory
 *  group.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backupOperators;

/** Output only. Create time of the active directory. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Description of the active directory.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. Comma separated list of DNS server IP addresses for the Active
 *  Directory domain.
 */
@property(nonatomic, copy, nullable) NSString *dns;

/** Required. Name of the Active Directory domain */
@property(nonatomic, copy, nullable) NSString *domain;

/**
 *  If enabled, traffic between the SMB server to Domain Controller (DC) will be
 *  encrypted.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *encryptDcConnections;

/**
 *  Name of the active directory machine. This optional parameter is used only
 *  while creating kerberos volume
 */
@property(nonatomic, copy, nullable) NSString *kdcHostname;

/** KDC server IP address for the active directory machine. */
@property(nonatomic, copy, nullable) NSString *kdcIp;

/** Labels for the active directory. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_ActiveDirectory_Labels *labels;

/**
 *  Specifies whether or not the LDAP traffic needs to be signed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ldapSigning;

/**
 *  Identifier. The resource name of the active directory. Format:
 *  `projects/{project_number}/locations/{location_id}/activeDirectories/{active_directory_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. NetBIOSPrefix is used as a prefix for SMB server name. */
@property(nonatomic, copy, nullable) NSString *netBiosPrefix;

/**
 *  If enabled, will allow access to local users and LDAP users. If access is
 *  needed for only LDAP users, it has to be disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nfsUsersWithLdap;

/**
 *  The Organizational Unit (OU) within the Windows Active Directory the user
 *  belongs to.
 */
@property(nonatomic, copy, nullable) NSString *organizationalUnit;

/** Required. Password of the Active Directory domain administrator. */
@property(nonatomic, copy, nullable) NSString *password;

/** Optional. Domain users to be given the SeSecurityPrivilege. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *securityOperators;

/**
 *  The Active Directory site the service will limit Domain Controller discovery
 *  too.
 */
@property(nonatomic, copy, nullable) NSString *site;

/**
 *  Output only. The state of the AD.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_Creating Active Directory
 *        State is Creating (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_Deleting Active Directory
 *        State is Deleting (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_Diagnosing Active Directory
 *        State is Diagnosing. (Value: "DIAGNOSING")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_Error Active Directory
 *        State is Error (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_InUse Active Directory
 *        State is In use (Value: "IN_USE")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_Ready Active Directory
 *        State is Ready (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_StateUnspecified
 *        Unspecified Active Directory State (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_ActiveDirectory_State_Updating Active Directory
 *        State is Updating (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. The state details of the Active Directory. */
@property(nonatomic, copy, nullable) NSString *stateDetails;

/** Required. Username of the Active Directory domain administrator. */
@property(nonatomic, copy, nullable) NSString *username;

@end


/**
 *  Labels for the active directory.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_ActiveDirectory_Labels : GTLRObject
@end


/**
 *  A NetApp Backup.
 */
@interface GTLRNetAppFiles_Backup : GTLRObject

/**
 *  Output only. Region in which backup is stored. Format:
 *  `projects/{project_id}/locations/{location}`
 */
@property(nonatomic, copy, nullable) NSString *backupRegion;

/**
 *  Output only. Type of backup, manually created or created by a backup policy.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Backup_BackupType_Manual Manual backup type.
 *        (Value: "MANUAL")
 *    @arg @c kGTLRNetAppFiles_Backup_BackupType_Scheduled Scheduled backup
 *        type. (Value: "SCHEDULED")
 *    @arg @c kGTLRNetAppFiles_Backup_BackupType_TypeUnspecified Unspecified
 *        backup type. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *backupType;

/**
 *  Output only. Total size of all backups in a chain in bytes = baseline backup
 *  size + sum(incremental backup size)
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *chainStorageBytes;

/** Output only. The time when the backup was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of the backup with 2048 characters or less. Requests with
 *  longer descriptions will be rejected.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Output only. The time until which the backup is not deletable. */
@property(nonatomic, strong, nullable) GTLRDateTime *enforcedRetentionEndTime;

/** Resource labels to represent user provided metadata. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Backup_Labels *labels;

/**
 *  Identifier. The resource name of the backup. Format:
 *  `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Reserved for future use
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzi;

/**
 *  Output only. Reserved for future use
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzs;

/**
 *  If specified, backup will be created from the given snapshot. If not
 *  specified, there will be a new snapshot taken to initiate the backup
 *  creation. Format:
 *  `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`
 */
@property(nonatomic, copy, nullable) NSString *sourceSnapshot;

/**
 *  Volume full name of this backup belongs to. Format:
 *  `projects/{projects_id}/locations/{location}/volumes/{volume_id}`
 */
@property(nonatomic, copy, nullable) NSString *sourceVolume;

/**
 *  Output only. The backup state.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Backup_State_Creating Backup is being created.
 *        While in this state, the snapshot for the backup point-in-time may not
 *        have been created yet, and so the point-in-time may not have been
 *        fixed. (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_Backup_State_Deleting Backup is being deleted.
 *        (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_Backup_State_Error Backup is not valid and cannot
 *        be used for creating new volumes or restoring existing volumes.
 *        (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_Backup_State_Ready Backup is available for use.
 *        (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_Backup_State_StateUnspecified State not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Backup_State_Updating Backup is being updated.
 *        (Value: "UPDATING")
 *    @arg @c kGTLRNetAppFiles_Backup_State_Uploading Backup is being uploaded.
 *        While in this state, none of the writes to the volume will be included
 *        in the backup. (Value: "UPLOADING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. Region of the volume from which the backup was created. Format:
 *  `projects/{project_id}/locations/{location}`
 */
@property(nonatomic, copy, nullable) NSString *volumeRegion;

/**
 *  Output only. Size of the file system when the backup was created. When
 *  creating a new volume from the backup, the volume capacity will have to be
 *  at least as big.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *volumeUsageBytes;

@end


/**
 *  Resource labels to represent user provided metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_Backup_Labels : GTLRObject
@end


/**
 *  BackupConfig contains backup related config on a volume.
 */
@interface GTLRNetAppFiles_BackupConfig : GTLRObject

/**
 *  Output only. Total size of all backups in a chain in bytes = baseline backup
 *  size + sum(incremental backup size).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *backupChainBytes;

/**
 *  Optional. When specified, schedule backups will be created based on the
 *  policy configuration.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backupPolicies;

/**
 *  Optional. Name of backup vault. Format:
 *  projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}
 */
@property(nonatomic, copy, nullable) NSString *backupVault;

/**
 *  Optional. When set to true, scheduled backup is enabled on the volume. This
 *  field should be nil when there's no backup policy attached.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scheduledBackupEnabled;

@end


/**
 *  Backup Policy.
 */
@interface GTLRNetAppFiles_BackupPolicy : GTLRObject

/**
 *  Output only. The total number of volumes assigned by this backup policy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *assignedVolumeCount;

/** Output only. The time when the backup policy was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Number of daily backups to keep. Note that the minimum daily backup limit is
 *  2.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dailyBackupLimit;

/**
 *  Description of the backup policy.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  If enabled, make backups automatically according to the schedules. This will
 *  be applied to all volumes that have this policy attached and enforced on
 *  volume level. If not specified, default is true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/** Resource labels to represent user provided metadata. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_BackupPolicy_Labels *labels;

/**
 *  Number of monthly backups to keep. Note that the sum of daily, weekly and
 *  monthly backups should be greater than 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *monthlyBackupLimit;

/**
 *  Identifier. The resource name of the backup policy. Format:
 *  `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The backup policy state.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_BackupPolicy_State_Creating BackupPolicy is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_BackupPolicy_State_Deleting BackupPolicy is being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_BackupPolicy_State_Error BackupPolicy is not
 *        valid and cannot be used. (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_BackupPolicy_State_Ready BackupPolicy is
 *        available for use. (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_BackupPolicy_State_StateUnspecified State not
 *        set. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_BackupPolicy_State_Updating BackupPolicy is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Number of weekly backups to keep. Note that the sum of daily, weekly and
 *  monthly backups should be greater than 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *weeklyBackupLimit;

@end


/**
 *  Resource labels to represent user provided metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_BackupPolicy_Labels : GTLRObject
@end


/**
 *  Retention policy for backups in the backup vault
 */
@interface GTLRNetAppFiles_BackupRetentionPolicy : GTLRObject

/**
 *  Required. Minimum retention duration in days for backups in the backup
 *  vault.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *backupMinimumEnforcedRetentionDays;

/**
 *  Optional. Indicates if the daily backups are immutable. Atleast one of
 *  daily_backup_immutable, weekly_backup_immutable, monthly_backup_immutable
 *  and manual_backup_immutable must be true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dailyBackupImmutable;

/**
 *  Optional. Indicates if the manual backups are immutable. Atleast one of
 *  daily_backup_immutable, weekly_backup_immutable, monthly_backup_immutable
 *  and manual_backup_immutable must be true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *manualBackupImmutable;

/**
 *  Optional. Indicates if the monthly backups are immutable. Atleast one of
 *  daily_backup_immutable, weekly_backup_immutable, monthly_backup_immutable
 *  and manual_backup_immutable must be true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *monthlyBackupImmutable;

/**
 *  Optional. Indicates if the weekly backups are immutable. Atleast one of
 *  daily_backup_immutable, weekly_backup_immutable, monthly_backup_immutable
 *  and manual_backup_immutable must be true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *weeklyBackupImmutable;

@end


/**
 *  A NetApp BackupVault.
 */
@interface GTLRNetAppFiles_BackupVault : GTLRObject

/**
 *  Optional. Region where the backups are stored. Format:
 *  `projects/{project_id}/locations/{location}`
 */
@property(nonatomic, copy, nullable) NSString *backupRegion;

/** Optional. Backup retention policy defining the retenton of backups. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_BackupRetentionPolicy *backupRetentionPolicy;

/**
 *  Optional. Type of backup vault to be created. Default is IN_REGION.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_BackupVault_BackupVaultType_BackupVaultTypeUnspecified
 *        BackupVault type not set. (Value: "BACKUP_VAULT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_BackupVault_BackupVaultType_CrossRegion
 *        BackupVault type is CROSS_REGION. (Value: "CROSS_REGION")
 *    @arg @c kGTLRNetAppFiles_BackupVault_BackupVaultType_InRegion BackupVault
 *        type is IN_REGION. (Value: "IN_REGION")
 */
@property(nonatomic, copy, nullable) NSString *backupVaultType;

/** Output only. Create time of the backup vault. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Description of the backup vault.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. Name of the Backup vault created in backup region. Format:
 *  `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
 */
@property(nonatomic, copy, nullable) NSString *destinationBackupVault;

/** Resource labels to represent user provided metadata. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_BackupVault_Labels *labels;

/**
 *  Identifier. The resource name of the backup vault. Format:
 *  `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Name of the Backup vault created in source region. Format:
 *  `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`
 */
@property(nonatomic, copy, nullable) NSString *sourceBackupVault;

/**
 *  Output only. Region in which the backup vault is created. Format:
 *  `projects/{project_id}/locations/{location}`
 */
@property(nonatomic, copy, nullable) NSString *sourceRegion;

/**
 *  Output only. The backup vault state.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_BackupVault_State_Creating BackupVault is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_BackupVault_State_Deleting BackupVault is being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_BackupVault_State_Error BackupVault is not valid
 *        and cannot be used. (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_BackupVault_State_Ready BackupVault is available
 *        for use. (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_BackupVault_State_StateUnspecified State not set.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_BackupVault_State_Updating BackupVault is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Resource labels to represent user provided metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_BackupVault_Labels : GTLRObject
@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRNetAppFiles_CancelOperationRequest : GTLRObject
@end


/**
 *  Make a snapshot every day e.g. at 04:00, 05:20, 23:50
 */
@interface GTLRNetAppFiles_DailySchedule : GTLRObject

/**
 *  Set the hour to start the snapshot (0-23), defaults to midnight (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hour;

/**
 *  Set the minute of the hour to start the snapshot (0-59), defaults to the top
 *  of the hour (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minute;

/**
 *  The maximum number of Snapshots to keep for the hourly schedule
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotsToKeep;

@end


/**
 *  DestinationVolumeParameters specify input parameters used for creating
 *  destination volume.
 */
@interface GTLRNetAppFiles_DestinationVolumeParameters : GTLRObject

/**
 *  Description for the destination volume.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Destination volume's share name. If not specified, source volume's share
 *  name will be used.
 */
@property(nonatomic, copy, nullable) NSString *shareName;

/** Required. Existing destination StoragePool name. */
@property(nonatomic, copy, nullable) NSString *storagePool;

/** Optional. Tiering policy for the volume. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_TieringPolicy *tieringPolicy;

/**
 *  Desired destination volume resource id. If not specified, source volume's
 *  resource id will be used. This value must start with a lowercase letter
 *  followed by up to 62 lowercase letters, numbers, or hyphens, and cannot end
 *  with a hyphen.
 */
@property(nonatomic, copy, nullable) NSString *volumeId;

@end


/**
 *  EncryptVolumesRequest specifies the KMS config to encrypt existing volumes.
 */
@interface GTLRNetAppFiles_EncryptVolumesRequest : GTLRObject
@end


/**
 *  EstablishPeeringRequest establishes cluster and svm peerings between the
 *  source and the destination replications.
 */
@interface GTLRNetAppFiles_EstablishPeeringRequest : GTLRObject

/**
 *  Required. Name of the user's local source cluster to be peered with the
 *  destination cluster.
 */
@property(nonatomic, copy, nullable) NSString *peerClusterName;

/** Optional. List of IPv4 ip addresses to be used for peering. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *peerIpAddresses;

/**
 *  Required. Name of the user's local source vserver svm to be peered with the
 *  destination vserver svm.
 */
@property(nonatomic, copy, nullable) NSString *peerSvmName;

/**
 *  Required. Name of the user's local source volume to be peered with the
 *  destination volume.
 */
@property(nonatomic, copy, nullable) NSString *peerVolumeName;

@end


/**
 *  Defines the export policy for the volume.
 */
@interface GTLRNetAppFiles_ExportPolicy : GTLRObject

/** Required. List of export policy rules */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_SimpleExportPolicyRule *> *rules;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRNetAppFiles_GoogleProtobufEmpty : GTLRObject
@end


/**
 *  Make a snapshot every hour e.g. at 04:00, 05:00, 06:00.
 */
@interface GTLRNetAppFiles_HourlySchedule : GTLRObject

/**
 *  Set the minute of the hour to start the snapshot (0-59), defaults to the top
 *  of the hour (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minute;

/**
 *  The maximum number of Snapshots to keep for the hourly schedule
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotsToKeep;

@end


/**
 *  HybridPeeringDetails contains details about the hybrid peering.
 */
@interface GTLRNetAppFiles_HybridPeeringDetails : GTLRObject

/**
 *  Optional. Copy-paste-able commands to be used on user's ONTAP to accept
 *  peering requests.
 */
@property(nonatomic, copy, nullable) NSString *command;

/**
 *  Optional. Expiration time for the peering command to be executed on user's
 *  ONTAP.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *commandExpiryTime;

/**
 *  Optional. Temporary passphrase generated to accept cluster peering command.
 */
@property(nonatomic, copy, nullable) NSString *passphrase;

/**
 *  Optional. Name of the user's local source cluster to be peered with the
 *  destination cluster.
 */
@property(nonatomic, copy, nullable) NSString *peerClusterName;

/**
 *  Optional. Name of the user's local source vserver svm to be peered with the
 *  destination vserver svm.
 */
@property(nonatomic, copy, nullable) NSString *peerSvmName;

/**
 *  Optional. Name of the user's local source volume to be peered with the
 *  destination volume.
 */
@property(nonatomic, copy, nullable) NSString *peerVolumeName;

/** Optional. IP address of the subnet. */
@property(nonatomic, copy, nullable) NSString *subnetIp;

@end


/**
 *  The Hybrid Replication parameters for the volume.
 */
@interface GTLRNetAppFiles_HybridReplicationParameters : GTLRObject

/**
 *  Optional. Name of source cluster location associated with the Hybrid
 *  replication. This is a free-form field for the display purpose only.
 */
@property(nonatomic, copy, nullable) NSString *clusterLocation;

/**
 *  Optional. Description of the replication.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Optional. Labels to be added to the replication as the key value pairs. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_HybridReplicationParameters_Labels *labels;

/**
 *  Required. Name of the user's local source cluster to be peered with the
 *  destination cluster.
 */
@property(nonatomic, copy, nullable) NSString *peerClusterName;

/** Required. List of node ip addresses to be peered with. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *peerIpAddresses;

/**
 *  Required. Name of the user's local source vserver svm to be peered with the
 *  destination vserver svm.
 */
@property(nonatomic, copy, nullable) NSString *peerSvmName;

/**
 *  Required. Name of the user's local source volume to be peered with the
 *  destination volume.
 */
@property(nonatomic, copy, nullable) NSString *peerVolumeName;

/** Required. Desired name for the replication of this volume. */
@property(nonatomic, copy, nullable) NSString *replication;

@end


/**
 *  Optional. Labels to be added to the replication as the key value pairs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_HybridReplicationParameters_Labels : GTLRObject
@end


/**
 *  KmsConfig is the customer managed encryption key(CMEK) configuration.
 */
@interface GTLRNetAppFiles_KmsConfig : GTLRObject

/** Output only. Create time of the KmsConfig. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. Customer managed crypto key resource full name. Format:
 *  projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{key}.
 */
@property(nonatomic, copy, nullable) NSString *cryptoKeyName;

/**
 *  Description of the KmsConfig.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. Instructions to provide the access to the customer provided
 *  encryption key.
 */
@property(nonatomic, copy, nullable) NSString *instructions;

/** Labels as key value pairs */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_KmsConfig_Labels *labels;

/** Identifier. Name of the KmsConfig. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The Service account which will have access to the customer
 *  provided encryption key.
 */
@property(nonatomic, copy, nullable) NSString *serviceAccount;

/**
 *  Output only. State of the KmsConfig.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Creating KmsConfig State is
 *        Creating (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Deleting KmsConfig State is
 *        Deleting (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Disabled KmsConfig State is
 *        Disabled. (Value: "DISABLED")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Disabling KmsConfig State is
 *        Disabling. (Value: "DISABLING")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Error KmsConfig State is Error
 *        (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_InUse KmsConfig State is In Use.
 *        (Value: "IN_USE")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_KeyCheckPending KmsConfig State
 *        is Pending to verify crypto key access. (Value: "KEY_CHECK_PENDING")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_KeyNotReachable KmsConfig State
 *        is Not accessbile by the SDE service account to the crypto key.
 *        (Value: "KEY_NOT_REACHABLE")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Migrating KmsConfig State is
 *        Migrating. The existing volumes are migrating from SMEK to CMEK.
 *        (Value: "MIGRATING")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Ready KmsConfig State is Ready
 *        (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_StateUnspecified Unspecified
 *        KmsConfig State (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_KmsConfig_State_Updating KmsConfig State is
 *        Updating (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. State details of the KmsConfig. */
@property(nonatomic, copy, nullable) NSString *stateDetails;

@end


/**
 *  Labels as key value pairs
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_KmsConfig_Labels : GTLRObject
@end


/**
 *  ListActiveDirectoriesResponse contains all the active directories requested.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "activeDirectories" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRNetAppFiles_ListActiveDirectoriesResponse : GTLRCollectionObject

/**
 *  The list of active directories.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_ActiveDirectory *> *activeDirectories;

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListBackupPoliciesResponse contains all the backup policies requested.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backupPolicies" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRNetAppFiles_ListBackupPoliciesResponse : GTLRCollectionObject

/**
 *  The list of backup policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_BackupPolicy *> *backupPolicies;

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListBackupsResponse is the result of ListBackupsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListBackupsResponse : GTLRCollectionObject

/**
 *  A list of backups in the project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Backup *> *backups;

/**
 *  The token you can use to retrieve the next page of results. Not returned if
 *  there are no more results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListBackupVaultsResponse is the result of ListBackupVaultsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backupVaults" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListBackupVaultsResponse : GTLRCollectionObject

/**
 *  A list of backupVaults in the project for the specified location.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_BackupVault *> *backupVaults;

/**
 *  The token you can use to retrieve the next page of results. Not returned if
 *  there are no more results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListKmsConfigsResponse is the response to a ListKmsConfigsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "kmsConfigs" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListKmsConfigsResponse : GTLRCollectionObject

/**
 *  The list of KmsConfigs
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_KmsConfig *> *kmsConfigs;

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Operation *> *operations;

@end


/**
 *  ListQuotaRulesResponse is the response to a ListQuotaRulesRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "quotaRules" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListQuotaRulesResponse : GTLRCollectionObject

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  List of quota rules
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_QuotaRule *> *quotaRules;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListReplicationsResponse is the result of ListReplicationsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "replications" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListReplicationsResponse : GTLRCollectionObject

/**
 *  The token you can use to retrieve the next page of results. Not returned if
 *  there are no more results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of replications in the project for the specified volume.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Replication *> *replications;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListSnapshotsResponse is the result of ListSnapshotsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "snapshots" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListSnapshotsResponse : GTLRCollectionObject

/**
 *  The token you can use to retrieve the next page of results. Not returned if
 *  there are no more results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of snapshots in the project for the specified volume.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Snapshot *> *snapshots;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListStoragePoolsResponse is the response to a ListStoragePoolsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "storagePools" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListStoragePoolsResponse : GTLRCollectionObject

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of StoragePools
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_StoragePool *> *storagePools;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Message for response to listing Volumes
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "volumes" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetAppFiles_ListVolumesResponse : GTLRCollectionObject

/** A token identifying a page of results the server should return. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

/**
 *  The list of Volume
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Volume *> *volumes;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRNetAppFiles_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetAppFiles_Location_Metadata : GTLRObject
@end


/**
 *  Metadata for a given google.cloud.location.Location.
 */
@interface GTLRNetAppFiles_LocationMetadata : GTLRObject

/** Output only. Supported flex performance in a location. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *supportedFlexPerformance;

/** Output only. Supported service levels in a location. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *supportedServiceLevels;

@end


/**
 *  Make a snapshot once a month e.g. at 2nd 04:00, 7th 05:20, 24th 23:50
 */
@interface GTLRNetAppFiles_MonthlySchedule : GTLRObject

/**
 *  Set the day or days of the month to make a snapshot (1-31). Accepts a comma
 *  separated number of days. Defaults to '1'.
 */
@property(nonatomic, copy, nullable) NSString *daysOfMonth;

/**
 *  Set the hour to start the snapshot (0-23), defaults to midnight (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hour;

/**
 *  Set the minute of the hour to start the snapshot (0-59), defaults to the top
 *  of the hour (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minute;

/**
 *  The maximum number of Snapshots to keep for the hourly schedule
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotsToKeep;

@end


/**
 *  View only mount options for a volume.
 */
@interface GTLRNetAppFiles_MountOption : GTLRObject

/**
 *  Export string
 *
 *  Remapped to 'exportProperty' to avoid language reserved word 'export'.
 */
@property(nonatomic, copy, nullable) NSString *exportProperty;

/** Full export string */
@property(nonatomic, copy, nullable) NSString *exportFull;

/** Instructions for mounting */
@property(nonatomic, copy, nullable) NSString *instructions;

/** Output only. IP Address. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/**
 *  Protocol to mount with.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_MountOption_Protocol_Nfsv3 NFS V3 protocol
 *        (Value: "NFSV3")
 *    @arg @c kGTLRNetAppFiles_MountOption_Protocol_Nfsv4 NFS V4 protocol
 *        (Value: "NFSV4")
 *    @arg @c kGTLRNetAppFiles_MountOption_Protocol_ProtocolsUnspecified
 *        Unspecified protocol (Value: "PROTOCOLS_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_MountOption_Protocol_Smb SMB protocol (Value:
 *        "SMB")
 */
@property(nonatomic, copy, nullable) NSString *protocol;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRNetAppFiles_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetAppFiles_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetAppFiles_Operation_Response : GTLRObject
@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRNetAppFiles_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have been canceled successfully have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  QuotaRule specifies the maximum disk space a user or group can use within a
 *  volume. They can be used for creating default and individual quota rules.
 */
@interface GTLRNetAppFiles_QuotaRule : GTLRObject

/** Output only. Create time of the quota rule */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. Description of the quota rule
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. The maximum allowed disk space in MiB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskLimitMib;

/** Optional. Labels of the quota rule */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_QuotaRule_Labels *labels;

/**
 *  Identifier. The resource name of the quota rule. Format:
 *  `projects/{project_number}/locations/{location_id}/volumes/volumes/{volume_id}/quotaRules/{quota_rule_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. State of the quota rule
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_QuotaRule_State_Creating Quota rule is creating
 *        (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_State_Deleting Quota rule is deleting
 *        (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_State_Error Quota rule is in error
 *        state. (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_State_Ready Quota rule is ready (Value:
 *        "READY")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_State_StateUnspecified Unspecified
 *        state for quota rule (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_State_Updating Quota rule is updating
 *        (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. State details of the quota rule */
@property(nonatomic, copy, nullable) NSString *stateDetails;

/**
 *  Optional. The quota rule applies to the specified user or group, identified
 *  by a Unix UID/GID, Windows SID, or null for default.
 */
@property(nonatomic, copy, nullable) NSString *target;

/**
 *  Required. The type of quota rule.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_QuotaRule_Type_DefaultGroupQuota Default group
 *        quota rule (Value: "DEFAULT_GROUP_QUOTA")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_Type_DefaultUserQuota Default user
 *        quota rule (Value: "DEFAULT_USER_QUOTA")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_Type_IndividualGroupQuota Individual
 *        group quota rule (Value: "INDIVIDUAL_GROUP_QUOTA")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_Type_IndividualUserQuota Individual
 *        user quota rule (Value: "INDIVIDUAL_USER_QUOTA")
 *    @arg @c kGTLRNetAppFiles_QuotaRule_Type_TypeUnspecified Unspecified type
 *        for quota rule (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Optional. Labels of the quota rule
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_QuotaRule_Labels : GTLRObject
@end


/**
 *  Replication is a nested resource under Volume, that describes a cross-region
 *  replication relationship between 2 volumes in different regions.
 */
@interface GTLRNetAppFiles_Replication : GTLRObject

/** Optional. Location of the user cluster. */
@property(nonatomic, copy, nullable) NSString *clusterLocation;

/** Output only. Replication create time. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description about this replication relationship.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. Full name of destination volume resource. Example :
 *  "projects/{project}/locations/{location}/volumes/{volume_id}"
 */
@property(nonatomic, copy, nullable) NSString *destinationVolume;

/** Required. Input only. Destination volume parameters */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_DestinationVolumeParameters *destinationVolumeParameters;

/**
 *  Output only. Condition of the relationship. Can be one of the following: -
 *  true: The replication relationship is healthy. It has not missed the most
 *  recent scheduled transfer. - false: The replication relationship is not
 *  healthy. It has missed the most recent scheduled transfer.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *healthy;

/** Output only. Hybrid peering details. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_HybridPeeringDetails *hybridPeeringDetails;

/**
 *  Output only. Type of the hybrid replication.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Replication_HybridReplicationType_ContinuousReplication
 *        Hybrid replication type for continuous replication. (Value:
 *        "CONTINUOUS_REPLICATION")
 *    @arg @c kGTLRNetAppFiles_Replication_HybridReplicationType_HybridReplicationTypeUnspecified
 *        Unspecified hybrid replication type. (Value:
 *        "HYBRID_REPLICATION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Replication_HybridReplicationType_Migration
 *        Hybrid replication type for migration. (Value: "MIGRATION")
 */
@property(nonatomic, copy, nullable) NSString *hybridReplicationType;

/** Resource labels to represent user provided metadata. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Replication_Labels *labels;

/**
 *  Output only. Indicates the state of mirroring.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_Aborted Replication is
 *        aborted. (Value: "ABORTED")
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_BaselineTransferring
 *        Baseline replication is in progress. (Value: "BASELINE_TRANSFERRING")
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_Mirrored Destination
 *        volume has been initialized and is ready to receive replication
 *        transfers. (Value: "MIRRORED")
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_MirrorStateUnspecified
 *        Unspecified MirrorState (Value: "MIRROR_STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_Preparing Destination
 *        volume is being prepared. (Value: "PREPARING")
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_Stopped Destination
 *        volume is not receiving replication transfers. (Value: "STOPPED")
 *    @arg @c kGTLRNetAppFiles_Replication_MirrorState_Transferring Incremental
 *        replication is in progress. (Value: "TRANSFERRING")
 */
@property(nonatomic, copy, nullable) NSString *mirrorState;

/**
 *  Identifier. The resource name of the Replication. Format:
 *  `projects/{project_id}/locations/{location}/volumes/{volume_id}/replications/{replication_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Indicates the schedule for replication.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Replication_ReplicationSchedule_Daily Replication
 *        happens once every day. (Value: "DAILY")
 *    @arg @c kGTLRNetAppFiles_Replication_ReplicationSchedule_Every10Minutes
 *        Replication happens once every 10 minutes. (Value: "EVERY_10_MINUTES")
 *    @arg @c kGTLRNetAppFiles_Replication_ReplicationSchedule_Hourly
 *        Replication happens once every hour. (Value: "HOURLY")
 *    @arg @c kGTLRNetAppFiles_Replication_ReplicationSchedule_ReplicationScheduleUnspecified
 *        Unspecified ReplicationSchedule (Value:
 *        "REPLICATION_SCHEDULE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *replicationSchedule;

/**
 *  Output only. Indicates whether this points to source or destination.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Replication_Role_Destination Indicates
 *        Destination volume. (Value: "DESTINATION")
 *    @arg @c kGTLRNetAppFiles_Replication_Role_ReplicationRoleUnspecified
 *        Unspecified replication role (Value: "REPLICATION_ROLE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Replication_Role_Source Indicates Source volume.
 *        (Value: "SOURCE")
 */
@property(nonatomic, copy, nullable) NSString *role;

/**
 *  Output only. Full name of source volume resource. Example :
 *  "projects/{project}/locations/{location}/volumes/{volume_id}"
 */
@property(nonatomic, copy, nullable) NSString *sourceVolume;

/**
 *  Output only. State of the replication.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Replication_State_Creating Replication is
 *        creating. (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_Replication_State_Deleting Replication is
 *        deleting. (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_Replication_State_Error Replication is in error
 *        state. (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_Replication_State_PendingClusterPeering
 *        Replication is waiting for cluster peering to be established. (Value:
 *        "PENDING_CLUSTER_PEERING")
 *    @arg @c kGTLRNetAppFiles_Replication_State_PendingSvmPeering Replication
 *        is waiting for SVM peering to be established. (Value:
 *        "PENDING_SVM_PEERING")
 *    @arg @c kGTLRNetAppFiles_Replication_State_Ready Replication is ready.
 *        (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_Replication_State_StateUnspecified Unspecified
 *        replication State (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Replication_State_Updating Replication is
 *        updating. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. State details of the replication. */
@property(nonatomic, copy, nullable) NSString *stateDetails;

/** Output only. Replication transfer statistics. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_TransferStats *transferStats;

@end


/**
 *  Resource labels to represent user provided metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_Replication_Labels : GTLRObject
@end


/**
 *  The RestoreParameters if volume is created from a snapshot or backup.
 */
@interface GTLRNetAppFiles_RestoreParameters : GTLRObject

/**
 *  Full name of the backup resource. Format:
 *  projects/{project}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}
 */
@property(nonatomic, copy, nullable) NSString *sourceBackup;

/**
 *  Full name of the snapshot resource. Format:
 *  projects/{project}/locations/{location}/volumes/{volume}/snapshots/{snapshot}
 */
@property(nonatomic, copy, nullable) NSString *sourceSnapshot;

@end


/**
 *  ResumeReplicationRequest resumes a stopped replication.
 */
@interface GTLRNetAppFiles_ResumeReplicationRequest : GTLRObject
@end


/**
 *  ReverseReplicationDirectionRequest reverses direction of replication. Source
 *  becomes destination and destination becomes source.
 */
@interface GTLRNetAppFiles_ReverseReplicationDirectionRequest : GTLRObject
@end


/**
 *  RevertVolumeRequest reverts the given volume to the specified snapshot.
 */
@interface GTLRNetAppFiles_RevertVolumeRequest : GTLRObject

/**
 *  Required. The snapshot resource ID, in the format 'my-snapshot', where the
 *  specified ID is the {snapshot_id} of the fully qualified name like
 *  projects/{project_id}/locations/{location_id}/volumes/{volume_id}/snapshots/{snapshot_id}
 */
@property(nonatomic, copy, nullable) NSString *snapshotId;

@end


/**
 *  An export policy rule describing various export options.
 */
@interface GTLRNetAppFiles_SimpleExportPolicyRule : GTLRObject

/**
 *  Access type (ReadWrite, ReadOnly, None)
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_AccessTypeUnspecified
 *        Unspecified Access Type (Value: "ACCESS_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_ReadNone None
 *        (Value: "READ_NONE")
 *    @arg @c kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_ReadOnly Read
 *        Only (Value: "READ_ONLY")
 *    @arg @c kGTLRNetAppFiles_SimpleExportPolicyRule_AccessType_ReadWrite Read
 *        Write (Value: "READ_WRITE")
 */
@property(nonatomic, copy, nullable) NSString *accessType;

/** Comma separated list of allowed clients IP addresses */
@property(nonatomic, copy, nullable) NSString *allowedClients;

/** Whether Unix root access will be granted. */
@property(nonatomic, copy, nullable) NSString *hasRootAccess;

/**
 *  If enabled (true) the rule defines a read only access for clients matching
 *  the 'allowedClients' specification. It enables nfs clients to mount using
 *  'integrity' kerberos security mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberos5iReadOnly;

/**
 *  If enabled (true) the rule defines read and write access for clients
 *  matching the 'allowedClients' specification. It enables nfs clients to mount
 *  using 'integrity' kerberos security mode. The 'kerberos5iReadOnly' value be
 *  ignored if this is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberos5iReadWrite;

/**
 *  If enabled (true) the rule defines a read only access for clients matching
 *  the 'allowedClients' specification. It enables nfs clients to mount using
 *  'privacy' kerberos security mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberos5pReadOnly;

/**
 *  If enabled (true) the rule defines read and write access for clients
 *  matching the 'allowedClients' specification. It enables nfs clients to mount
 *  using 'privacy' kerberos security mode. The 'kerberos5pReadOnly' value be
 *  ignored if this is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberos5pReadWrite;

/**
 *  If enabled (true) the rule defines a read only access for clients matching
 *  the 'allowedClients' specification. It enables nfs clients to mount using
 *  'authentication' kerberos security mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberos5ReadOnly;

/**
 *  If enabled (true) the rule defines read and write access for clients
 *  matching the 'allowedClients' specification. It enables nfs clients to mount
 *  using 'authentication' kerberos security mode. The 'kerberos5ReadOnly' value
 *  be ignored if this is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberos5ReadWrite;

/**
 *  NFS V3 protocol.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nfsv3;

/**
 *  NFS V4 protocol.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nfsv4;

@end


/**
 *  Snapshot is a point-in-time version of a Volume's content.
 */
@interface GTLRNetAppFiles_Snapshot : GTLRObject

/** Output only. The time when the snapshot was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A description of the snapshot with 2048 characters or less. Requests with
 *  longer descriptions will be rejected.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Resource labels to represent user provided metadata. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Snapshot_Labels *labels;

/**
 *  Identifier. The resource name of the snapshot. Format:
 *  `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The snapshot state.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_Creating Snapshot State is
 *        Creating (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_Deleting Snapshot State is
 *        Deleting (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_Disabled Snapshot State is
 *        Disabled (Value: "DISABLED")
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_Error Snapshot State is Error
 *        (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_Ready Snapshot State is Ready
 *        (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_StateUnspecified Unspecified
 *        Snapshot State (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Snapshot_State_Updating Snapshot State is
 *        Updating (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. State details of the storage pool */
@property(nonatomic, copy, nullable) NSString *stateDetails;

/**
 *  Output only. Current storage usage for the snapshot in bytes.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usedBytes;

@end


/**
 *  Resource labels to represent user provided metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_Snapshot_Labels : GTLRObject
@end


/**
 *  Snapshot Policy for a volume.
 */
@interface GTLRNetAppFiles_SnapshotPolicy : GTLRObject

/** Daily schedule policy. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_DailySchedule *dailySchedule;

/**
 *  If enabled, make snapshots automatically according to the schedules. Default
 *  is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/** Hourly schedule policy. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_HourlySchedule *hourlySchedule;

/** Monthly schedule policy. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_MonthlySchedule *monthlySchedule;

/** Weekly schedule policy. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_WeeklySchedule *weeklySchedule;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRNetAppFiles_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRNetAppFiles_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetAppFiles_Status_Details_Item : GTLRObject
@end


/**
 *  StopReplicationRequest stops a replication until resumed.
 */
@interface GTLRNetAppFiles_StopReplicationRequest : GTLRObject

/**
 *  Indicates whether to stop replication forcefully while data transfer is in
 *  progress. Warning! if force is true, this will abort any current transfers
 *  and can lead to data loss due to partial transfer. If force is false, stop
 *  replication will fail while data transfer is in progress and you will need
 *  to retry later.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *force;

@end


/**
 *  StoragePool is a container for volumes with a service level and capacity.
 *  Volumes can be created in a pool of sufficient available capacity.
 *  StoragePool capacity is what you are billed for.
 */
@interface GTLRNetAppFiles_StoragePool : GTLRObject

/**
 *  Optional. Specifies the Active Directory to be used for creating a SMB
 *  volume.
 */
@property(nonatomic, copy, nullable) NSString *activeDirectory;

/**
 *  Optional. True if the storage pool supports Auto Tiering enabled volumes.
 *  Default is false. Auto-tiering can be enabled after storage pool creation
 *  but it can't be disabled once enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowAutoTiering;

/**
 *  Required. Capacity in GIB of the pool
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *capacityGib;

/** Output only. Create time of the storage pool */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. True if using Independent Scaling of capacity and performance
 *  (Hyperdisk) By default set to false
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *customPerformanceEnabled;

/**
 *  Optional. Description of the storage pool
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. Specifies the current pool encryption key source.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_StoragePool_EncryptionType_CloudKms Customer
 *        managed encryption key, which is stored in KMS. (Value: "CLOUD_KMS")
 *    @arg @c kGTLRNetAppFiles_StoragePool_EncryptionType_EncryptionTypeUnspecified
 *        The source of the encryption key is not specified. (Value:
 *        "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_StoragePool_EncryptionType_ServiceManaged Google
 *        managed encryption key. (Value: "SERVICE_MANAGED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/**
 *  Deprecated. Used to allow SO pool to access AD or DNS server from other
 *  regions.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *globalAccessAllowed GTLR_DEPRECATED;

/** Optional. Specifies the KMS config to be used for volume encryption. */
@property(nonatomic, copy, nullable) NSString *kmsConfig;

/** Optional. Labels as key value pairs */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_StoragePool_Labels *labels;

/**
 *  Optional. Flag indicating if the pool is NFS LDAP enabled or not.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ldapEnabled;

/** Identifier. Name of the storage pool */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. VPC Network name. Format:
 *  projects/{project}/global/networks/{network}
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Optional. This field is not implemented. The values provided in this field
 *  are ignored.
 */
@property(nonatomic, copy, nullable) NSString *psaRange;

/** Optional. Specifies the replica zone for regional storagePool. */
@property(nonatomic, copy, nullable) NSString *replicaZone;

/**
 *  Output only. Reserved for future use
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzi;

/**
 *  Output only. Reserved for future use
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *satisfiesPzs;

/**
 *  Required. Service level of the storage pool
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_StoragePool_ServiceLevel_Extreme Extreme service
 *        level. (Value: "EXTREME")
 *    @arg @c kGTLRNetAppFiles_StoragePool_ServiceLevel_Flex Flex service level.
 *        (Value: "FLEX")
 *    @arg @c kGTLRNetAppFiles_StoragePool_ServiceLevel_Premium Premium service
 *        level. (Value: "PREMIUM")
 *    @arg @c kGTLRNetAppFiles_StoragePool_ServiceLevel_ServiceLevelUnspecified
 *        Unspecified service level. (Value: "SERVICE_LEVEL_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_StoragePool_ServiceLevel_Standard Standard
 *        service level. (Value: "STANDARD")
 */
@property(nonatomic, copy, nullable) NSString *serviceLevel;

/**
 *  Output only. State of the storage pool
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Creating Storage Pool State is
 *        Creating (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Deleting Storage Pool State is
 *        Deleting (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Disabled Storage Pool State is
 *        Disabled (Value: "DISABLED")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Error Storage Pool State is
 *        Error (Value: "ERROR")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Ready Storage Pool State is
 *        Ready (Value: "READY")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Restoring Storage Pool State is
 *        Restoring (Value: "RESTORING")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_StateUnspecified Unspecified
 *        Storage Pool State (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_StoragePool_State_Updating Storage Pool State is
 *        Updating (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. State details of the storage pool */
@property(nonatomic, copy, nullable) NSString *stateDetails;

/**
 *  Optional. Custom Performance Total IOPS of the pool If not provided, it will
 *  be calculated based on the total_throughput_mibps
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalIops;

/**
 *  Optional. Custom Performance Total Throughput of the pool (in MiB/s)
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalThroughputMibps;

/**
 *  Output only. Allocated size of all volumes in GIB in the storage pool
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *volumeCapacityGib;

/**
 *  Output only. Volume count of the storage pool
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *volumeCount;

/**
 *  Optional. Specifies the active zone for regional storagePool.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  Optional. Labels as key value pairs
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_StoragePool_Labels : GTLRObject
@end


/**
 *  SwitchActiveReplicaZoneRequest switch the active/replica zone for a regional
 *  storagePool.
 */
@interface GTLRNetAppFiles_SwitchActiveReplicaZoneRequest : GTLRObject
@end


/**
 *  SyncReplicationRequest syncs the replication from source to destination.
 */
@interface GTLRNetAppFiles_SyncReplicationRequest : GTLRObject
@end


/**
 *  Defines tiering policy for the volume.
 */
@interface GTLRNetAppFiles_TieringPolicy : GTLRObject

/**
 *  Optional. Time in days to mark the volume's data block as cold and make it
 *  eligible for tiering, can be range from 2-183. Default is 31.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *coolingThresholdDays;

/**
 *  Optional. Flag indicating if the volume has tiering policy enable/pause.
 *  Default is PAUSED.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_TieringPolicy_TierAction_Enabled When tiering is
 *        enabled, new cold data will be tiered. (Value: "ENABLED")
 *    @arg @c kGTLRNetAppFiles_TieringPolicy_TierAction_Paused When paused,
 *        tiering won't be performed on new data. Existing data stays tiered
 *        until accessed. (Value: "PAUSED")
 *    @arg @c kGTLRNetAppFiles_TieringPolicy_TierAction_TierActionUnspecified
 *        Unspecified. (Value: "TIER_ACTION_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *tierAction;

@end


/**
 *  TransferStats reports all statistics related to replication transfer.
 */
@interface GTLRNetAppFiles_TransferStats : GTLRObject

/**
 *  Lag duration indicates the duration by which Destination region volume
 *  content lags behind the primary region volume content.
 */
@property(nonatomic, strong, nullable) GTLRDuration *lagDuration;

/**
 *  Last transfer size in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lastTransferBytes;

/** Time taken during last transfer. */
@property(nonatomic, strong, nullable) GTLRDuration *lastTransferDuration;

/** Time when last transfer completed. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastTransferEndTime;

/** A message describing the cause of the last transfer failure. */
@property(nonatomic, copy, nullable) NSString *lastTransferError;

/**
 *  Cumulative time taken across all transfers for the replication relationship.
 */
@property(nonatomic, strong, nullable) GTLRDuration *totalTransferDuration;

/**
 *  Cumulative bytes transferred so far for the replication relationship.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *transferBytes;

/** Time when progress was updated last. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  ValidateDirectoryServiceRequest validates the directory service policy
 *  attached to the storage pool.
 */
@interface GTLRNetAppFiles_ValidateDirectoryServiceRequest : GTLRObject

/**
 *  Type of directory service policy attached to the storage pool.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_ValidateDirectoryServiceRequest_DirectoryServiceType_ActiveDirectory
 *        Active directory policy attached to the storage pool. (Value:
 *        "ACTIVE_DIRECTORY")
 *    @arg @c kGTLRNetAppFiles_ValidateDirectoryServiceRequest_DirectoryServiceType_DirectoryServiceTypeUnspecified
 *        Directory service type is not specified. (Value:
 *        "DIRECTORY_SERVICE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *directoryServiceType;

@end


/**
 *  VerifyKmsConfigRequest specifies the KMS config to be validated.
 */
@interface GTLRNetAppFiles_VerifyKmsConfigRequest : GTLRObject
@end


/**
 *  VerifyKmsConfigResponse contains the information if the config is correctly
 *  and error message.
 */
@interface GTLRNetAppFiles_VerifyKmsConfigResponse : GTLRObject

/** Output only. Error message if config is not healthy. */
@property(nonatomic, copy, nullable) NSString *healthError;

/**
 *  Output only. If the customer key configured correctly to the encrypt volume.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *healthy;

/**
 *  Output only. Instructions for the customers to provide the access to the
 *  encryption key.
 */
@property(nonatomic, copy, nullable) NSString *instructions;

@end


/**
 *  Volume provides a filesystem that you can mount.
 */
@interface GTLRNetAppFiles_Volume : GTLRObject

/** Output only. Specifies the ActiveDirectory name of a SMB volume. */
@property(nonatomic, copy, nullable) NSString *activeDirectory;

/** BackupConfig of the volume. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_BackupConfig *backupConfig;

/**
 *  Required. Capacity in GIB of the volume
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *capacityGib;

/**
 *  Output only. Size of the volume cold tier data in GiB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *coldTierSizeGib;

/** Output only. Create time of the volume */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Optional. Description of the volume
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. Specified the current volume encryption key source.
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Volume_EncryptionType_CloudKms Customer managed
 *        encryption key, which is stored in KMS. (Value: "CLOUD_KMS")
 *    @arg @c kGTLRNetAppFiles_Volume_EncryptionType_EncryptionTypeUnspecified
 *        The source of the encryption key is not specified. (Value:
 *        "ENCRYPTION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Volume_EncryptionType_ServiceManaged Google
 *        managed encryption key. (Value: "SERVICE_MANAGED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionType;

/** Optional. Export policy of the volume */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_ExportPolicy *exportPolicy;

/**
 *  Output only. Indicates whether the volume is part of a replication
 *  relationship.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasReplication;

/** Optional. The Hybrid Replication parameters for the volume. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_HybridReplicationParameters *hybridReplicationParameters;

/**
 *  Optional. Flag indicating if the volume is a kerberos volume or not, export
 *  policy rules control kerberos security modes (krb5, krb5i, krb5p).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kerberosEnabled;

/** Output only. Specifies the KMS config to be used for volume encryption. */
@property(nonatomic, copy, nullable) NSString *kmsConfig;

/** Optional. Labels as key value pairs */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_Volume_Labels *labels;

/**
 *  Optional. Flag indicating if the volume will be a large capacity volume or a
 *  regular volume.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *largeCapacity;

/**
 *  Output only. Flag indicating if the volume is NFS LDAP enabled or not.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ldapEnabled;

/** Output only. Mount options of this volume */
@property(nonatomic, strong, nullable) NSArray<GTLRNetAppFiles_MountOption *> *mountOptions;

/**
 *  Optional. Flag indicating if the volume will have an IP address per node for
 *  volumes supporting multiple IP endpoints. Only the volume with
 *  large_capacity will be allowed to have multiple endpoints.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *multipleEndpoints;

/** Identifier. Name of the volume */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. VPC Network name. Format:
 *  projects/{project}/global/networks/{network}
 */
@property(nonatomic, copy, nullable) NSString *network;

/** Required. Protocols required for the volume */
@property(nonatomic, strong, nullable) NSArray<NSString *> *protocols;

/**
 *  Output only. This field is not implemented. The values provided in this
 *  field are ignored.
 */
@property(nonatomic, copy, nullable) NSString *psaRange;

/** Output only. Specifies the replica zone for regional volume. */
@property(nonatomic, copy, nullable) NSString *replicaZone;

/** Optional. Specifies the source of the volume to be created from. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_RestoreParameters *restoreParameters;

/** Optional. List of actions that are restricted on this volume. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *restrictedActions;

/**
 *  Optional. Security Style of the Volume
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Volume_SecurityStyle_Ntfs SecurityStyle uses NTFS
 *        (Value: "NTFS")
 *    @arg @c kGTLRNetAppFiles_Volume_SecurityStyle_SecurityStyleUnspecified
 *        SecurityStyle is unspecified (Value: "SECURITY_STYLE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Volume_SecurityStyle_Unix SecurityStyle uses UNIX
 *        (Value: "UNIX")
 */
@property(nonatomic, copy, nullable) NSString *securityStyle;

/**
 *  Output only. Service level of the volume
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Volume_ServiceLevel_Extreme Extreme service
 *        level. (Value: "EXTREME")
 *    @arg @c kGTLRNetAppFiles_Volume_ServiceLevel_Flex Flex service level.
 *        (Value: "FLEX")
 *    @arg @c kGTLRNetAppFiles_Volume_ServiceLevel_Premium Premium service
 *        level. (Value: "PREMIUM")
 *    @arg @c kGTLRNetAppFiles_Volume_ServiceLevel_ServiceLevelUnspecified
 *        Unspecified service level. (Value: "SERVICE_LEVEL_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Volume_ServiceLevel_Standard Standard service
 *        level. (Value: "STANDARD")
 */
@property(nonatomic, copy, nullable) NSString *serviceLevel;

/** Required. Share name of the volume */
@property(nonatomic, copy, nullable) NSString *shareName;

/** Optional. SMB share settings for the volume. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *smbSettings;

/**
 *  Optional. Snap_reserve specifies percentage of volume storage reserved for
 *  snapshot storage. Default is 0 percent.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapReserve;

/**
 *  Optional. Snapshot_directory if enabled (true) the volume will contain a
 *  read-only .snapshot directory which provides access to each of the volume's
 *  snapshots.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotDirectory;

/** Optional. SnapshotPolicy for a volume. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_SnapshotPolicy *snapshotPolicy;

/**
 *  Output only. State of the volume
 *
 *  Likely values:
 *    @arg @c kGTLRNetAppFiles_Volume_State_Creating Volume State is Creating
 *        (Value: "CREATING")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Deleting Volume State is Deleting
 *        (Value: "DELETING")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Disabled Volume State is Disabled
 *        (Value: "DISABLED")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Error Volume State is Error (Value:
 *        "ERROR")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Preparing Volume State is Preparing.
 *        Note that this is different from CREATING where CREATING means the
 *        volume is being created, while PREPARING means the volume is created
 *        and now being prepared for the replication. (Value: "PREPARING")
 *    @arg @c kGTLRNetAppFiles_Volume_State_ReadOnly Volume State is Read Only
 *        (Value: "READ_ONLY")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Ready Volume State is Ready (Value:
 *        "READY")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Restoring Volume State is Restoring
 *        (Value: "RESTORING")
 *    @arg @c kGTLRNetAppFiles_Volume_State_StateUnspecified Unspecified Volume
 *        State (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetAppFiles_Volume_State_Updating Volume State is Updating
 *        (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Output only. State details of the volume */
@property(nonatomic, copy, nullable) NSString *stateDetails;

/** Required. StoragePool name of the volume */
@property(nonatomic, copy, nullable) NSString *storagePool;

/** Tiering policy for the volume. */
@property(nonatomic, strong, nullable) GTLRNetAppFiles_TieringPolicy *tieringPolicy;

/**
 *  Optional. Default unix style permission (e.g. 777) the mount point will be
 *  created with. Applicable for NFS protocol types only.
 */
@property(nonatomic, copy, nullable) NSString *unixPermissions;

/**
 *  Output only. Used capacity in GIB of the volume. This is computed
 *  periodically and it does not represent the realtime usage.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usedGib;

/**
 *  Output only. Specifies the active zone for regional volume.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  Optional. Labels as key value pairs
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetAppFiles_Volume_Labels : GTLRObject
@end


/**
 *  Make a snapshot every week e.g. at Monday 04:00, Wednesday 05:20, Sunday
 *  23:50
 */
@interface GTLRNetAppFiles_WeeklySchedule : GTLRObject

/**
 *  Set the day or days of the week to make a snapshot. Accepts a comma
 *  separated days of the week. Defaults to 'Sunday'.
 */
@property(nonatomic, copy, nullable) NSString *day;

/**
 *  Set the hour to start the snapshot (0-23), defaults to midnight (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hour;

/**
 *  Set the minute of the hour to start the snapshot (0-59), defaults to the top
 *  of the hour (0).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minute;

/**
 *  The maximum number of Snapshots to keep for the hourly schedule
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *snapshotsToKeep;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
