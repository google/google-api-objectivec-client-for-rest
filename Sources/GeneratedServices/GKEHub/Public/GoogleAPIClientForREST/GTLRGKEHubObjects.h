// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   GKE Hub API (gkehub/v2)
// Documentation:
//   https://cloud.google.com/anthos/multicluster-management/connect/registering-a-cluster

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRGKEHub_AppDevExperienceState;
@class GTLRGKEHub_AppDevExperienceStatus;
@class GTLRGKEHub_CloudBuildSpec;
@class GTLRGKEHub_ClusterUpgradeGKEUpgrade;
@class GTLRGKEHub_ClusterUpgradeIgnoredMembership;
@class GTLRGKEHub_ClusterUpgradeMembershipGKEUpgradeState;
@class GTLRGKEHub_ClusterUpgradeState;
@class GTLRGKEHub_ClusterUpgradeUpgradeStatus;
@class GTLRGKEHub_ConfigManagementBinauthzConfig;
@class GTLRGKEHub_ConfigManagementBinauthzState;
@class GTLRGKEHub_ConfigManagementBinauthzVersion;
@class GTLRGKEHub_ConfigManagementConfigSync;
@class GTLRGKEHub_ConfigManagementConfigSyncDeploymentState;
@class GTLRGKEHub_ConfigManagementConfigSyncError;
@class GTLRGKEHub_ConfigManagementConfigSyncState;
@class GTLRGKEHub_ConfigManagementConfigSyncVersion;
@class GTLRGKEHub_ConfigManagementContainerOverride;
@class GTLRGKEHub_ConfigManagementDeploymentOverride;
@class GTLRGKEHub_ConfigManagementErrorResource;
@class GTLRGKEHub_ConfigManagementGatekeeperDeploymentState;
@class GTLRGKEHub_ConfigManagementGitConfig;
@class GTLRGKEHub_ConfigManagementGroupVersionKind;
@class GTLRGKEHub_ConfigManagementHierarchyControllerConfig;
@class GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState;
@class GTLRGKEHub_ConfigManagementHierarchyControllerState;
@class GTLRGKEHub_ConfigManagementHierarchyControllerVersion;
@class GTLRGKEHub_ConfigManagementInstallError;
@class GTLRGKEHub_ConfigManagementOciConfig;
@class GTLRGKEHub_ConfigManagementOperatorState;
@class GTLRGKEHub_ConfigManagementPolicyController;
@class GTLRGKEHub_ConfigManagementPolicyControllerMigration;
@class GTLRGKEHub_ConfigManagementPolicyControllerMonitoring;
@class GTLRGKEHub_ConfigManagementPolicyControllerState;
@class GTLRGKEHub_ConfigManagementPolicyControllerVersion;
@class GTLRGKEHub_ConfigManagementSpec;
@class GTLRGKEHub_ConfigManagementState;
@class GTLRGKEHub_ConfigManagementSyncError;
@class GTLRGKEHub_ConfigManagementSyncState;
@class GTLRGKEHub_FeatureSpec;
@class GTLRGKEHub_FeatureState;
@class GTLRGKEHub_GoogleRpcStatus;
@class GTLRGKEHub_GoogleRpcStatus_Details_Item;
@class GTLRGKEHub_IdentityServiceAuthMethod;
@class GTLRGKEHub_IdentityServiceAzureADConfig;
@class GTLRGKEHub_IdentityServiceDiagnosticInterface;
@class GTLRGKEHub_IdentityServiceGoogleConfig;
@class GTLRGKEHub_IdentityServiceGroupConfig;
@class GTLRGKEHub_IdentityServiceIdentityServiceOptions;
@class GTLRGKEHub_IdentityServiceLdapConfig;
@class GTLRGKEHub_IdentityServiceOidcConfig;
@class GTLRGKEHub_IdentityServiceSamlConfig;
@class GTLRGKEHub_IdentityServiceSamlConfig_AttributeMapping;
@class GTLRGKEHub_IdentityServiceServerConfig;
@class GTLRGKEHub_IdentityServiceServiceAccountConfig;
@class GTLRGKEHub_IdentityServiceSimpleBindCredentials;
@class GTLRGKEHub_IdentityServiceSpec;
@class GTLRGKEHub_IdentityServiceState;
@class GTLRGKEHub_IdentityServiceUserConfig;
@class GTLRGKEHub_LifecycleState;
@class GTLRGKEHub_Location;
@class GTLRGKEHub_Location_Labels;
@class GTLRGKEHub_Location_Metadata;
@class GTLRGKEHub_MembershipFeature;
@class GTLRGKEHub_MembershipFeature_Labels;
@class GTLRGKEHub_MeteringState;
@class GTLRGKEHub_Operation;
@class GTLRGKEHub_Operation_Metadata;
@class GTLRGKEHub_Operation_Response;
@class GTLRGKEHub_Origin;
@class GTLRGKEHub_PolicyControllerBundleInstallSpec;
@class GTLRGKEHub_PolicyControllerHubConfig;
@class GTLRGKEHub_PolicyControllerHubConfig_DeploymentConfigs;
@class GTLRGKEHub_PolicyControllerMonitoringConfig;
@class GTLRGKEHub_PolicyControllerOnClusterState;
@class GTLRGKEHub_PolicyControllerPolicyContentSpec;
@class GTLRGKEHub_PolicyControllerPolicyContentSpec_Bundles;
@class GTLRGKEHub_PolicyControllerPolicyContentState;
@class GTLRGKEHub_PolicyControllerPolicyContentState_BundleStates;
@class GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig;
@class GTLRGKEHub_PolicyControllerResourceList;
@class GTLRGKEHub_PolicyControllerResourceRequirements;
@class GTLRGKEHub_PolicyControllerSpec;
@class GTLRGKEHub_PolicyControllerState;
@class GTLRGKEHub_PolicyControllerState_ComponentStates;
@class GTLRGKEHub_PolicyControllerTemplateLibraryConfig;
@class GTLRGKEHub_PolicyControllerToleration;
@class GTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState;
@class GTLRGKEHub_RBACRoleBindingActuationSpec;
@class GTLRGKEHub_RBACRoleBindingActuationState;
@class GTLRGKEHub_RBACRoleBindingActuationState_RbacrolebindingStates;
@class GTLRGKEHub_ServiceMeshAnalysisMessage;
@class GTLRGKEHub_ServiceMeshAnalysisMessage_Args;
@class GTLRGKEHub_ServiceMeshAnalysisMessageBase;
@class GTLRGKEHub_ServiceMeshCondition;
@class GTLRGKEHub_ServiceMeshControlPlaneManagement;
@class GTLRGKEHub_ServiceMeshDataPlaneManagement;
@class GTLRGKEHub_ServiceMeshSpec;
@class GTLRGKEHub_ServiceMeshState;
@class GTLRGKEHub_ServiceMeshStatusDetails;
@class GTLRGKEHub_ServiceMeshType;
@class GTLRGKEHub_State;
@class GTLRGKEHub_WorkloadCertificateSpec;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRGKEHub_AppDevExperienceStatus.code

/**
 *  Not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AppDevExperienceStatus_Code_CodeUnspecified;
/**
 *  AppDevExperienceFeature's specified subcomponent ready state is false. This
 *  means AppDevExperienceFeature has encountered an issue that blocks all, or a
 *  portion, of its normal operation. See the `description` for more details.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AppDevExperienceStatus_Code_Failed;
/**
 *  AppDevExperienceFeature's specified subcomponent is ready.
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AppDevExperienceStatus_Code_Ok;
/**
 *  AppDevExperienceFeature's specified subcomponent has a pending or unknown
 *  state.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AppDevExperienceStatus_Code_Unknown;

// ----------------------------------------------------------------------------
// GTLRGKEHub_CloudBuildSpec.securityPolicy

/**
 *  Privileged build pods are disallowed
 *
 *  Value: "NON_PRIVILEGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_CloudBuildSpec_SecurityPolicy_NonPrivileged;
/**
 *  Privileged build pods are allowed
 *
 *  Value: "PRIVILEGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_CloudBuildSpec_SecurityPolicy_Privileged;
/**
 *  Unspecified policy
 *
 *  Value: "SECURITY_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_CloudBuildSpec_SecurityPolicy_SecurityPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ClusterUpgradeUpgradeStatus.code

/**
 *  Required by https://linter.aip.dev/126/unspecified.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_CodeUnspecified;
/**
 *  The upgrade has passed all post conditions (soaking). At the scope level,
 *  this means all eligible clusters are in COMPLETE status.
 *
 *  Value: "COMPLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Complete;
/**
 *  A cluster will be forced to enter soaking if an upgrade doesn't finish
 *  within a certain limit, despite it's actual status.
 *
 *  Value: "FORCED_SOAKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_ForcedSoaking;
/**
 *  The upgrade is ineligible. At the scope level, this means the upgrade is
 *  ineligible for all the clusters in the scope.
 *
 *  Value: "INELIGIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Ineligible;
/**
 *  The upgrade is in progress. At the scope level, this means the upgrade is in
 *  progress for at least one cluster in the scope.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_InProgress;
/**
 *  The upgrade is pending. At the scope level, this means the upgrade is
 *  pending for all the clusters in the scope.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Pending;
/**
 *  The upgrade has finished and is soaking until the soaking time is up. At the
 *  scope level, this means at least one cluster is in soaking while the rest
 *  are either soaking or complete.
 *
 *  Value: "SOAKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Soaking;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementBinauthzState.webhook

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.admissionWebhook

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.gitSync

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.importer

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.monitor

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.otelCollector

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.reconcilerManager

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.resourceGroupControllerManager

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.rootReconciler

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.syncer

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.clusterLevelStopSyncingState

/**
 *  Syncing resources to the cluster is not stopped at the cluster level.
 *
 *  Value: "NOT_STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_NotStopped;
/**
 *  Some reconcilers stop syncing resources to the cluster, while others are
 *  still syncing.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_Pending;
/**
 *  Syncing resources to the cluster is stopped at the cluster level.
 *
 *  Value: "STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_Stopped;
/**
 *  State cannot be determined
 *
 *  Value: "STOP_SYNCING_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_StopSyncingStateUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.reposyncCrd

/**
 *  CRD's state cannot be determined
 *
 *  Value: "CRD_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_CrdStateUnspecified;
/**
 *  CRD is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installed;
/**
 *  CRD is installing
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installing;
/**
 *  CRD is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_NotInstalled;
/**
 *  CRD is terminating (i.e., it has been deleted and is cleaning up)
 *
 *  Value: "TERMINATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Terminating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.rootsyncCrd

/**
 *  CRD's state cannot be determined
 *
 *  Value: "CRD_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_CrdStateUnspecified;
/**
 *  CRD is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installed;
/**
 *  CRD is installing
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installing;
/**
 *  CRD is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_NotInstalled;
/**
 *  CRD is terminating (i.e., it has been deleted and is cleaning up)
 *
 *  Value: "TERMINATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Terminating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.state

/**
 *  CS encounters errors.
 *
 *  Value: "CONFIG_SYNC_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncError;
/**
 *  The expected CS version is installed successfully.
 *
 *  Value: "CONFIG_SYNC_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncInstalled;
/**
 *  CS is not installed.
 *
 *  Value: "CONFIG_SYNC_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncNotInstalled;
/**
 *  CS is installing or terminating.
 *
 *  Value: "CONFIG_SYNC_PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncPending;
/**
 *  CS's state cannot be determined.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementGatekeeperDeploymentState.gatekeeperAudit

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementGatekeeperDeploymentState.gatekeeperControllerManagerState

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementGatekeeperDeploymentState.gatekeeperMutation

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState.extension

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState.hnc

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementOperatorState.deploymentState

/**
 *  Deployment's state cannot be determined.
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Error;
/**
 *  Deployment is installed.
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Installed;
/**
 *  Deployment is not installed.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementPolicyControllerMigration.stage

/**
 *  ACM Hub/Operator manages policycontroller. No migration yet completed.
 *
 *  Value: "ACM_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_AcmManaged;
/**
 *  All migrations steps complete; Poco Hub now manages policycontroller.
 *
 *  Value: "POCO_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_PocoManaged;
/**
 *  Unknown state of migration.
 *
 *  Value: "STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_StageUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementPolicyControllerMonitoring.backends

/**
 *  Stackdriver/Cloud Monitoring backend for monitoring
 *
 *  Value: "CLOUD_MONITORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMonitoring_Backends_CloudMonitoring;
/**
 *  Backend cannot be determined
 *
 *  Value: "MONITORING_BACKEND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMonitoring_Backends_MonitoringBackendUnspecified;
/**
 *  Prometheus backend for monitoring
 *
 *  Value: "PROMETHEUS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMonitoring_Backends_Prometheus;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementSpec.management

/**
 *  Google will manage the Feature for the cluster.
 *
 *  Value: "MANAGEMENT_AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSpec_Management_ManagementAutomatic;
/**
 *  User will manually manage the Feature for the cluster.
 *
 *  Value: "MANAGEMENT_MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSpec_Management_ManagementManual;
/**
 *  Unspecified
 *
 *  Value: "MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSpec_Management_ManagementUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementSyncState.code

/**
 *  Indicates an error configuring Config Sync, and user action is required
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Error;
/**
 *  Config Sync has been installed but not configured
 *
 *  Value: "NOT_CONFIGURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_NotConfigured;
/**
 *  Config Sync has not been installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_NotInstalled;
/**
 *  Config Sync is in the progress of syncing a new change
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Pending;
/**
 *  Config Sync cannot determine a sync code
 *
 *  Value: "SYNC_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_SyncCodeUnspecified;
/**
 *  Config Sync successfully synced the git Repo with the cluster
 *
 *  Value: "SYNCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Synced;
/**
 *  Error authorizing with the cluster
 *
 *  Value: "UNAUTHORIZED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Unauthorized;
/**
 *  Cluster could not be reached
 *
 *  Value: "UNREACHABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRGKEHub_IdentityServiceState.state

/**
 *  Unspecified state
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_IdentityServiceState_State_DeploymentStateUnspecified;
/**
 *  Failure with error.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_IdentityServiceState_State_Error;
/**
 *  deployment succeeds
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_IdentityServiceState_State_Ok;

// ----------------------------------------------------------------------------
// GTLRGKEHub_LifecycleState.state

/**
 *  The MembershipFeature is enabled in this Hub, and the MembershipFeature
 *  resource is fully available.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_LifecycleState_State_Active;
/**
 *  The MembershipFeature is being disabled in this Hub, and the
 *  MembershipFeature resource is being deleted.
 *
 *  Value: "DISABLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_LifecycleState_State_Disabling;
/**
 *  The MembershipFeature is being enabled, and the MembershipFeature resource
 *  is being created. Once complete, the corresponding MembershipFeature will be
 *  enabled in this Hub.
 *
 *  Value: "ENABLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_LifecycleState_State_Enabling;
/**
 *  The MembershipFeature resource is being updated by the Hub Service.
 *
 *  Value: "SERVICE_UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_LifecycleState_State_ServiceUpdating;
/**
 *  State is unknown or not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_LifecycleState_State_StateUnspecified;
/**
 *  The MembershipFeature resource is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_LifecycleState_State_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_Origin.type

/**
 *  Per-Feature spec was inherited from the fleet-level default.
 *
 *  Value: "FLEET"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_Fleet;
/**
 *  Per-Feature spec was inherited from the fleet-level default but is now out
 *  of sync with the current default.
 *
 *  Value: "FLEET_OUT_OF_SYNC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_FleetOutOfSync;
/**
 *  Type is unknown or not set.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_TypeUnspecified;
/**
 *  Per-Feature spec was inherited from a user specification.
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_User;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerHubConfig.installSpec

/**
 *  Request to stop all reconciliation actions by PoCo Hub controller. This is a
 *  breakglass mechanism to stop PoCo Hub from affecting cluster resources.
 *
 *  Value: "INSTALL_SPEC_DETACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecDetached;
/**
 *  Request to install and enable Policy Controller.
 *
 *  Value: "INSTALL_SPEC_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecEnabled;
/**
 *  Request to uninstall Policy Controller.
 *
 *  Value: "INSTALL_SPEC_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecNotInstalled;
/**
 *  Request to suspend Policy Controller i.e. its webhooks. If Policy Controller
 *  is not installed, it will be installed but suspended.
 *
 *  Value: "INSTALL_SPEC_SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecSuspended;
/**
 *  Spec is unknown.
 *
 *  Value: "INSTALL_SPEC_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerMonitoringConfig.backends

/**
 *  Stackdriver/Cloud Monitoring backend for monitoring
 *
 *  Value: "CLOUD_MONITORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMonitoringConfig_Backends_CloudMonitoring;
/**
 *  Backend cannot be determined
 *
 *  Value: "MONITORING_BACKEND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMonitoringConfig_Backends_MonitoringBackendUnspecified;
/**
 *  Prometheus backend for monitoring
 *
 *  Value: "PROMETHEUS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMonitoringConfig_Backends_Prometheus;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerOnClusterState.state

/**
 *  The PC is fully installed on the cluster and in an operational mode. In this
 *  state PCH will be reconciling state with the PC, and the PC will be
 *  performing it's operational tasks per that software. Entering a READY state
 *  requires that the hub has confirmed the PC is installed and its pods are
 *  operational with the version of the PC the PCH expects.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Active;
/**
 *  The PC is not operational, and the PCH is unable to act to make it
 *  operational. Entering a CLUSTER_ERROR state happens automatically when the
 *  PCH determines that a PC installed on the cluster is non-operative or that
 *  the cluster does not meet requirements set for the PCH to administer the
 *  cluster but has nevertheless been given an instruction to do so (such as
 *  ‘install').
 *
 *  Value: "CLUSTER_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_ClusterError;
/**
 *  The PC may have resources on the cluster, but the PCH wishes to remove the
 *  Membership. The Membership still exists.
 *
 *  Value: "DECOMMISSIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Decommissioning;
/**
 *  PoCo Hub is not taking any action to reconcile cluster objects. Changes to
 *  those objects will not be overwritten by PoCo Hub.
 *
 *  Value: "DETACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Detached;
/**
 *  In this state, the PC may still be operational, and only the PCH is unable
 *  to act. The hub should not issue instructions to change the PC state, or
 *  otherwise interfere with the on-cluster resources. Entering a HUB_ERROR
 *  state happens automatically when the PCH determines the hub is in an
 *  unhealthy state and it wishes to ‘take hands off' to avoid corrupting the PC
 *  or other data.
 *
 *  Value: "HUB_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_HubError;
/**
 *  The PCH possesses a Membership, however the PC is not fully installed on the
 *  cluster. In this state the hub can be expected to be taking actions to
 *  install the PC on the cluster.
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Installing;
/**
 *  The lifecycle state is unspecified.
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_LifecycleStateUnspecified;
/**
 *  The PC does not exist on the given cluster, and no k8s resources of any type
 *  that are associated with the PC should exist there. The cluster does not
 *  possess a membership with the PCH.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_NotInstalled;
/**
 *  Policy Controller (PC) is installed but suspended. This means that the
 *  policies are not enforced, but violations are still recorded (through
 *  audit).
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Suspended;
/**
 *  The PC is fully installed, but in the process of changing the configuration
 *  (including changing the version of PC either up and down, or modifying the
 *  manifests of PC) of the resources running on the cluster. The PCH has a
 *  Membership, is aware of the version the cluster should be running in, but
 *  has not confirmed for itself that the PC is running with that version.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig.podAffinity

/**
 *  No affinity configuration has been specified.
 *
 *  Value: "AFFINITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AffinityUnspecified;
/**
 *  Anti-affinity configuration will be applied to this deployment. Default for
 *  admissions deployment.
 *
 *  Value: "ANTI_AFFINITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AntiAffinity;
/**
 *  Affinity configurations will be removed from the deployment.
 *
 *  Value: "NO_AFFINITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_NoAffinity;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerState.state

/**
 *  The PC is fully installed on the cluster and in an operational mode. In this
 *  state PCH will be reconciling state with the PC, and the PC will be
 *  performing it's operational tasks per that software. Entering a READY state
 *  requires that the hub has confirmed the PC is installed and its pods are
 *  operational with the version of the PC the PCH expects.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_Active;
/**
 *  The PC is not operational, and the PCH is unable to act to make it
 *  operational. Entering a CLUSTER_ERROR state happens automatically when the
 *  PCH determines that a PC installed on the cluster is non-operative or that
 *  the cluster does not meet requirements set for the PCH to administer the
 *  cluster but has nevertheless been given an instruction to do so (such as
 *  ‘install').
 *
 *  Value: "CLUSTER_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_ClusterError;
/**
 *  The PC may have resources on the cluster, but the PCH wishes to remove the
 *  Membership. The Membership still exists.
 *
 *  Value: "DECOMMISSIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_Decommissioning;
/**
 *  PoCo Hub is not taking any action to reconcile cluster objects. Changes to
 *  those objects will not be overwritten by PoCo Hub.
 *
 *  Value: "DETACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_Detached;
/**
 *  In this state, the PC may still be operational, and only the PCH is unable
 *  to act. The hub should not issue instructions to change the PC state, or
 *  otherwise interfere with the on-cluster resources. Entering a HUB_ERROR
 *  state happens automatically when the PCH determines the hub is in an
 *  unhealthy state and it wishes to ‘take hands off' to avoid corrupting the PC
 *  or other data.
 *
 *  Value: "HUB_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_HubError;
/**
 *  The PCH possesses a Membership, however the PC is not fully installed on the
 *  cluster. In this state the hub can be expected to be taking actions to
 *  install the PC on the cluster.
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_Installing;
/**
 *  The lifecycle state is unspecified.
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_LifecycleStateUnspecified;
/**
 *  The PC does not exist on the given cluster, and no k8s resources of any type
 *  that are associated with the PC should exist there. The cluster does not
 *  possess a membership with the PCH.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_NotInstalled;
/**
 *  Policy Controller (PC) is installed but suspended. This means that the
 *  policies are not enforced, but violations are still recorded (through
 *  audit).
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_Suspended;
/**
 *  The PC is fully installed, but in the process of changing the configuration
 *  (including changing the version of PC either up and down, or modifying the
 *  manifests of PC) of the resources running on the cluster. The PCH has a
 *  Membership, is aware of the version the cluster should be running in, but
 *  has not confirmed for itself that the PC is running with that version.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerState_State_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerTemplateLibraryConfig.installation

/**
 *  Install the entire template library.
 *
 *  Value: "ALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_All;
/**
 *  No installation strategy has been specified.
 *
 *  Value: "INSTALLATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_InstallationUnspecified;
/**
 *  Do not install the template library.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_NotInstalled;

// ----------------------------------------------------------------------------
// GTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState.state

/**
 *  The RBACRoleBinding was created on the cluster but the specified custom role
 *  does not exist on the cluster, hence the RBACRoleBinding has no effect.
 *
 *  Value: "CUSTOM_ROLE_MISSING_FROM_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState_State_CustomRoleMissingFromCluster;
/**
 *  RBACRoleBinding is created properly on the cluster.
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState_State_Ok;
/**
 *  Unspecified state.
 *
 *  Value: "ROLE_BINDING_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState_State_RoleBindingStateUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshAnalysisMessageBase.level

/**
 *  ERROR represents a misconfiguration that must be fixed.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_Error;
/**
 *  INFO represents an informational finding.
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_Info;
/**
 *  Illegal. Same istio.analysis.v1alpha1.AnalysisMessageBase.Level.UNKNOWN.
 *
 *  Value: "LEVEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_LevelUnspecified;
/**
 *  WARNING represents a misconfiguration that should be fixed.
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_Warning;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshCondition.code

/**
 *  Failure to reconcile CanonicalServices
 *
 *  Value: "CANONICAL_SERVICE_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CanonicalServiceError;
/**
 *  Cluster has zero node code
 *
 *  Value: "CLUSTER_HAS_ZERO_NODES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ClusterHasZeroNodes;
/**
 *  CNI config unsupported error code
 *
 *  Value: "CNI_CONFIG_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CniConfigUnsupported;
/**
 *  CNI installation failed error code
 *
 *  Value: "CNI_INSTALLATION_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CniInstallationFailed;
/**
 *  CNI pod unschedulable error code
 *
 *  Value: "CNI_POD_UNSCHEDULABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CniPodUnschedulable;
/**
 *  Default Unspecified code
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CodeUnspecified;
/**
 *  Configuration (Istio/k8s resources) failed to apply due to internal error.
 *
 *  Value: "CONFIG_APPLY_INTERNAL_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ConfigApplyInternalError;
/**
 *  Configuration failed to be applied due to being invalid.
 *
 *  Value: "CONFIG_VALIDATION_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ConfigValidationError;
/**
 *  Encountered configuration(s) with possible unintended behavior or invalid
 *  configuration. These configs may not have been applied.
 *
 *  Value: "CONFIG_VALIDATION_WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ConfigValidationWarning;
/**
 *  User is using deprecated ControlPlaneManagement and they have not yet set
 *  Management.
 *
 *  Value: "DEPRECATED_SPEC_CONTROL_PLANE_MANAGEMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_DeprecatedSpecControlPlaneManagement;
/**
 *  User is using deprecated ControlPlaneManagement and they have already set
 *  Management.
 *
 *  Value: "DEPRECATED_SPEC_CONTROL_PLANE_MANAGEMENT_SAFE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_DeprecatedSpecControlPlaneManagementSafe;
/**
 *  GKE sandbox unsupported error code
 *
 *  Value: "GKE_SANDBOX_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_GkeSandboxUnsupported;
/**
 *  Legacy istio secrets found for multicluster error code
 *
 *  Value: "LEGACY_MC_SECRETS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_LegacyMcSecrets;
/**
 *  Managed CNI not enabled error code
 *
 *  Value: "MANAGED_CNI_NOT_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ManagedCniNotEnabled;
/**
 *  Permission denied error code for cross-project
 *
 *  Value: "MESH_IAM_CROSS_PROJECT_PERMISSION_DENIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_MeshIamCrossProjectPermissionDenied;
/**
 *  Mesh IAM permission denied error code
 *
 *  Value: "MESH_IAM_PERMISSION_DENIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_MeshIamPermissionDenied;
/**
 *  Modernization is aborted for a cluster.
 *
 *  Value: "MODERNIZATION_ABORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationAborted;
/**
 *  Modernization is completed for a cluster.
 *
 *  Value: "MODERNIZATION_COMPLETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationCompleted;
/**
 *  Fleet is eligible for modernization.
 *
 *  Value: "MODERNIZATION_ELIGIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationEligible;
/**
 *  Modernization is finalized for all clusters in a fleet. Rollback is no
 *  longer allowed.
 *
 *  Value: "MODERNIZATION_FINALIZED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationFinalized;
/**
 *  Modernization is in progress for a cluster.
 *
 *  Value: "MODERNIZATION_IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationInProgress;
/**
 *  Fleet is opted out from automated modernization.
 *
 *  Value: "MODERNIZATION_MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationManual;
/**
 *  Migrating the cluster's workloads to the new implementation.
 *
 *  Value: "MODERNIZATION_MIGRATING_WORKLOADS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationMigratingWorkloads;
/**
 *  Modernization of all the fleet's clusters is complete. Soaking before
 *  finalizing the modernization.
 *
 *  Value: "MODERNIZATION_MODERNIZED_SOAKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationModernizedSoaking;
/**
 *  Modernization of one or more clusters in a fleet is in progress.
 *
 *  Value: "MODERNIZATION_MODERNIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationModernizing;
/**
 *  Cluster has been prepared for its workloads to be migrated.
 *
 *  Value: "MODERNIZATION_PREPARED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationPrepared;
/**
 *  Preparing cluster so that its workloads can be migrated.
 *
 *  Value: "MODERNIZATION_PREPARING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationPreparing;
/**
 *  Rollback is in progress for modernization of a cluster.
 *
 *  Value: "MODERNIZATION_ROLLING_BACK_CLUSTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationRollingBackCluster;
/**
 *  Rollback is in progress for modernization of all clusters in a fleet.
 *
 *  Value: "MODERNIZATION_ROLLING_BACK_FLEET"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationRollingBackFleet;
/**
 *  Modernization is scheduled for a cluster.
 *
 *  Value: "MODERNIZATION_SCHEDULED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationScheduled;
/**
 *  Modernization is stalled for a cluster.
 *
 *  Value: "MODERNIZATION_STALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationStalled;
/**
 *  Modernization will be scheduled for a fleet.
 *
 *  Value: "MODERNIZATION_WILL_BE_SCHEDULED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationWillBeScheduled;
/**
 *  Nodepool workload identity federation required error code
 *
 *  Value: "NODEPOOL_WORKLOAD_IDENTITY_FEDERATION_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_NodepoolWorkloadIdentityFederationRequired;
/**
 *  Non-standard binary usage error code
 *
 *  Value: "NON_STANDARD_BINARY_USAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_NonStandardBinaryUsage;
/**
 *  BackendService quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_BACKEND_SERVICES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededBackendServices;
/**
 *  ClientTLSPolicy quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_CLIENT_TLS_POLICIES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededClientTlsPolicies;
/**
 *  EndpointPolicy quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_ENDPOINT_POLICIES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededEndpointPolicies;
/**
 *  Gateway quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_GATEWAYS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededGateways;
/**
 *  HealthCheck quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_HEALTH_CHECKS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededHealthChecks;
/**
 *  HTTPFilter quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_HTTP_FILTERS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededHttpFilters;
/**
 *  HTTPRoute quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_HTTP_ROUTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededHttpRoutes;
/**
 *  Mesh quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_MESHES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededMeshes;
/**
 *  NetworkEndpointGroup quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_NETWORK_ENDPOINT_GROUPS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededNetworkEndpointGroups;
/**
 *  ServerTLSPolicy quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_SERVER_TLS_POLICIES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededServerTlsPolicies;
/**
 *  ServiceLBPolicy quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_SERVICE_LB_POLICIES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededServiceLbPolicies;
/**
 *  TCPFilter quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_TCP_FILTERS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTcpFilters;
/**
 *  TCPRoute quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_TCP_ROUTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTcpRoutes;
/**
 *  TLS routes quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_TLS_ROUTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTlsRoutes;
/**
 *  TrafficPolicy quota exceeded error code.
 *
 *  Value: "QUOTA_EXCEEDED_TRAFFIC_POLICIES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTrafficPolicies;
/**
 *  Unsupported gateway class error code
 *
 *  Value: "UNSUPPORTED_GATEWAY_CLASS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_UnsupportedGatewayClass;
/**
 *  Multiple control planes unsupported error code
 *
 *  Value: "UNSUPPORTED_MULTIPLE_CONTROL_PLANES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_UnsupportedMultipleControlPlanes;
/**
 *  VPC-SC GA is supported for this control plane.
 *
 *  Value: "VPCSC_GA_SUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_VpcscGaSupported;
/**
 *  Workload identity required error code
 *
 *  Value: "WORKLOAD_IDENTITY_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_WorkloadIdentityRequired;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshCondition.severity

/**
 *  Indicates an issue that prevents the mesh from operating correctly
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_Error;
/**
 *  An informational message, not requiring any action
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_Info;
/**
 *  Unspecified severity
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_SeverityUnspecified;
/**
 *  Indicates a setting is likely wrong, but the mesh is still able to operate
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshControlPlaneManagement.implementation

/**
 *  Unspecified
 *
 *  Value: "IMPLEMENTATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_ImplementationUnspecified;
/**
 *  A Google build of istiod is used for the managed control plane.
 *
 *  Value: "ISTIOD"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_Istiod;
/**
 *  Traffic director is used for the managed control plane.
 *
 *  Value: "TRAFFIC_DIRECTOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_TrafficDirector;
/**
 *  The control plane implementation is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshControlPlaneManagement.state

/**
 *  ACTIVE means that the component is ready for use.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Active;
/**
 *  DEGRADED means that the component is ready, but operating in a degraded
 *  state.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Degraded;
/**
 *  DEPROVISIONING means that deprovisioning is in progress.
 *
 *  Value: "DEPROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Deprovisioning;
/**
 *  DISABLED means that the component is not enabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Disabled;
/**
 *  FAILED_PRECONDITION means that provisioning cannot proceed because of some
 *  characteristic of the member cluster.
 *
 *  Value: "FAILED_PRECONDITION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_FailedPrecondition;
/**
 *  Unspecified
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_LifecycleStateUnspecified;
/**
 *  NEEDS_ATTENTION means that the component is ready, but some user
 *  intervention is required. (For example that the user should migrate
 *  workloads to a new control plane revision.)
 *
 *  Value: "NEEDS_ATTENTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_NeedsAttention;
/**
 *  PROVISIONING means that provisioning is in progress.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Provisioning;
/**
 *  STALLED means that provisioning could not be done.
 *
 *  Value: "STALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Stalled;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshDataPlaneManagement.state

/**
 *  ACTIVE means that the component is ready for use.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Active;
/**
 *  DEGRADED means that the component is ready, but operating in a degraded
 *  state.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Degraded;
/**
 *  DEPROVISIONING means that deprovisioning is in progress.
 *
 *  Value: "DEPROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Deprovisioning;
/**
 *  DISABLED means that the component is not enabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Disabled;
/**
 *  FAILED_PRECONDITION means that provisioning cannot proceed because of some
 *  characteristic of the member cluster.
 *
 *  Value: "FAILED_PRECONDITION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_FailedPrecondition;
/**
 *  Unspecified
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_LifecycleStateUnspecified;
/**
 *  NEEDS_ATTENTION means that the component is ready, but some user
 *  intervention is required. (For example that the user should migrate
 *  workloads to a new control plane revision.)
 *
 *  Value: "NEEDS_ATTENTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_NeedsAttention;
/**
 *  PROVISIONING means that provisioning is in progress.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Provisioning;
/**
 *  STALLED means that provisioning could not be done.
 *
 *  Value: "STALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Stalled;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshSpec.configApi

/**
 *  Use the K8s Gateway API for configuration.
 *
 *  Value: "CONFIG_API_GATEWAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_ConfigApi_ConfigApiGateway;
/**
 *  Use the Istio API for configuration.
 *
 *  Value: "CONFIG_API_ISTIO"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_ConfigApi_ConfigApiIstio;
/**
 *  Unspecified
 *
 *  Value: "CONFIG_API_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_ConfigApi_ConfigApiUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshSpec.controlPlane

/**
 *  Google should provision a control plane revision and make it available in
 *  the cluster. Google will enroll this revision in a release channel and keep
 *  it up to date. The control plane revision may be a managed service, or a
 *  managed install.
 *
 *  Value: "AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_ControlPlane_Automatic;
/**
 *  Unspecified
 *
 *  Value: "CONTROL_PLANE_MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_ControlPlane_ControlPlaneManagementUnspecified;
/**
 *  User will manually configure the control plane (e.g. via CLI, or via the
 *  ControlPlaneRevision KRM API)
 *
 *  Value: "MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_ControlPlane_Manual;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshSpec.defaultChannel

/**
 *  Unspecified
 *
 *  Value: "CHANNEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_ChannelUnspecified;
/**
 *  RAPID channel is offered on an early access basis for customers who want to
 *  test new releases.
 *
 *  Value: "RAPID"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_Rapid;
/**
 *  REGULAR channel is intended for production users who want to take advantage
 *  of new features.
 *
 *  Value: "REGULAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_Regular;
/**
 *  STABLE channel includes versions that are known to be stable and reliable in
 *  production.
 *
 *  Value: "STABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_Stable;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshSpec.management

/**
 *  Google should manage my Service Mesh for the cluster.
 *
 *  Value: "MANAGEMENT_AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_Management_ManagementAutomatic;
/**
 *  User will manually configure their service mesh components.
 *
 *  Value: "MANAGEMENT_MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_Management_ManagementManual;
/**
 *  Google should remove any managed Service Mesh components from this cluster
 *  and deprovision any resources.
 *
 *  Value: "MANAGEMENT_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_Management_ManagementNotInstalled;
/**
 *  Unspecified.
 *
 *  Value: "MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshSpec_Management_ManagementUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_State.code

/**
 *  Unknown or not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_State_Code_CodeUnspecified;
/**
 *  The MembershipFeature is not operating or is in a severely degraded state.
 *  The MembershipFeature may need intervention to return to normal operation.
 *  See the description and any associated MembershipFeature-specific details
 *  for more information.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_State_Code_Error;
/**
 *  The MembershipFeature is operating normally.
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_State_Code_Ok;
/**
 *  The MembershipFeature has encountered an issue, and is operating in a
 *  degraded state. The MembershipFeature may need intervention to return to
 *  normal operation. See the description and any associated
 *  MembershipFeature-specific details for more information.
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_State_Code_Warning;

// ----------------------------------------------------------------------------
// GTLRGKEHub_WorkloadCertificateSpec.certificateManagement

/**
 *  Disable workload certificate feature.
 *
 *  Value: "CERTIFICATE_MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_WorkloadCertificateSpec_CertificateManagement_CertificateManagementUnspecified;
/**
 *  Disable workload certificate feature.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_WorkloadCertificateSpec_CertificateManagement_Disabled;
/**
 *  Enable workload certificate feature.
 *
 *  Value: "ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_WorkloadCertificateSpec_CertificateManagement_Enabled;

/**
 *  State for App Dev Exp Feature.
 */
@interface GTLRGKEHub_AppDevExperienceState : GTLRObject

/** Status of subcomponent that detects configured Service Mesh resources. */
@property(nonatomic, strong, nullable) GTLRGKEHub_AppDevExperienceStatus *networkingInstallSucceeded;

@end


/**
 *  Status specifies state for the subcomponent.
 */
@interface GTLRGKEHub_AppDevExperienceStatus : GTLRObject

/**
 *  Code specifies AppDevExperienceFeature's subcomponent ready state.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_AppDevExperienceStatus_Code_CodeUnspecified Not set.
 *        (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_AppDevExperienceStatus_Code_Failed
 *        AppDevExperienceFeature's specified subcomponent ready state is false.
 *        This means AppDevExperienceFeature has encountered an issue that
 *        blocks all, or a portion, of its normal operation. See the
 *        `description` for more details. (Value: "FAILED")
 *    @arg @c kGTLRGKEHub_AppDevExperienceStatus_Code_Ok
 *        AppDevExperienceFeature's specified subcomponent is ready. (Value:
 *        "OK")
 *    @arg @c kGTLRGKEHub_AppDevExperienceStatus_Code_Unknown
 *        AppDevExperienceFeature's specified subcomponent has a pending or
 *        unknown state. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Description is populated if Code is Failed, explaining why it has failed.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRGKEHub_CancelOperationRequest : GTLRObject
@end


/**
 *  **Cloud Build**: Configurations for each Cloud Build enabled cluster.
 */
@interface GTLRGKEHub_CloudBuildSpec : GTLRObject

/**
 *  Whether it is allowed to run the privileged builds on the cluster or not.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_CloudBuildSpec_SecurityPolicy_NonPrivileged Privileged
 *        build pods are disallowed (Value: "NON_PRIVILEGED")
 *    @arg @c kGTLRGKEHub_CloudBuildSpec_SecurityPolicy_Privileged Privileged
 *        build pods are allowed (Value: "PRIVILEGED")
 *    @arg @c kGTLRGKEHub_CloudBuildSpec_SecurityPolicy_SecurityPolicyUnspecified
 *        Unspecified policy (Value: "SECURITY_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *securityPolicy;

/** Version of the cloud build software on the cluster. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  GKEUpgrade represents a GKE provided upgrade, e.g., control plane upgrade.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgrade : GTLRObject

/** Name of the upgrade, e.g., "k8s_control_plane". */
@property(nonatomic, copy, nullable) NSString *name;

/** Version of the upgrade, e.g., "1.22.1-gke.100". */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  IgnoredMembership represents a membership ignored by the feature. A
 *  membership can be ignored because it was manually upgraded to a newer
 *  version than RC default.
 */
@interface GTLRGKEHub_ClusterUpgradeIgnoredMembership : GTLRObject

/** Time when the membership was first set to ignored. */
@property(nonatomic, strong, nullable) GTLRDateTime *ignoredTime;

/** Reason why the membership is ignored. */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  MembershipGKEUpgradeState is a GKEUpgrade and its state per-membership.
 */
@interface GTLRGKEHub_ClusterUpgradeMembershipGKEUpgradeState : GTLRObject

/** Status of the upgrade. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeUpgradeStatus *status;

/** Which upgrade to track the state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeGKEUpgrade *upgrade;

@end


/**
 *  Per-membership state for this feature.
 */
@interface GTLRGKEHub_ClusterUpgradeState : GTLRObject

/**
 *  Whether this membership is ignored by the feature. For example, manually
 *  upgraded clusters can be ignored if they are newer than the default versions
 *  of its release channel.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeIgnoredMembership *ignored;

/** Actual upgrade state against desired. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ClusterUpgradeMembershipGKEUpgradeState *> *upgrades;

@end


/**
 *  UpgradeStatus provides status information for each upgrade.
 */
@interface GTLRGKEHub_ClusterUpgradeUpgradeStatus : GTLRObject

/**
 *  Status code of the upgrade.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_CodeUnspecified
 *        Required by https://linter.aip.dev/126/unspecified. (Value:
 *        "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Complete The upgrade
 *        has passed all post conditions (soaking). At the scope level, this
 *        means all eligible clusters are in COMPLETE status. (Value:
 *        "COMPLETE")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_ForcedSoaking A
 *        cluster will be forced to enter soaking if an upgrade doesn't finish
 *        within a certain limit, despite it's actual status. (Value:
 *        "FORCED_SOAKING")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Ineligible The
 *        upgrade is ineligible. At the scope level, this means the upgrade is
 *        ineligible for all the clusters in the scope. (Value: "INELIGIBLE")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_InProgress The
 *        upgrade is in progress. At the scope level, this means the upgrade is
 *        in progress for at least one cluster in the scope. (Value:
 *        "IN_PROGRESS")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Pending The upgrade
 *        is pending. At the scope level, this means the upgrade is pending for
 *        all the clusters in the scope. (Value: "PENDING")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Soaking The upgrade
 *        has finished and is soaking until the soaking time is up. At the scope
 *        level, this means at least one cluster is in soaking while the rest
 *        are either soaking or complete. (Value: "SOAKING")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** Reason for this status. */
@property(nonatomic, copy, nullable) NSString *reason;

/** Last timestamp the status was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Configuration for Binauthz.
 */
@interface GTLRGKEHub_ConfigManagementBinauthzConfig : GTLRObject

/**
 *  Whether binauthz is enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  State for Binauthz.
 */
@interface GTLRGKEHub_ConfigManagementBinauthzState : GTLRObject

/** The version of binauthz that is installed. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementBinauthzVersion *version;

/**
 *  The state of the binauthz webhook.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_Error Deployment
 *        was attempted to be installed, but has errors. (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementBinauthzState_Webhook_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *webhook;

@end


/**
 *  The version of binauthz.
 */
@interface GTLRGKEHub_ConfigManagementBinauthzVersion : GTLRObject

/** The version of the binauthz webhook. */
@property(nonatomic, copy, nullable) NSString *webhookVersion;

@end


/**
 *  Configuration for Config Sync
 */
@interface GTLRGKEHub_ConfigManagementConfigSync : GTLRObject

/** Optional. Configuration for deployment overrides. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementDeploymentOverride *> *deploymentOverrides;

/**
 *  Optional. Enables the installation of ConfigSync. If set to true, ConfigSync
 *  resources will be created and the other ConfigSync fields will be applied if
 *  exist. If set to false, all other ConfigSync fields will be ignored,
 *  ConfigSync resources will be deleted. If omitted, ConfigSync resources will
 *  be managed depends on the presence of the git or oci field.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/** Optional. Git repo configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementGitConfig *git;

/**
 *  Optional. The Email of the Google Cloud Service Account (GSA) used for
 *  exporting Config Sync metrics to Cloud Monitoring and Cloud Monarch when
 *  Workload Identity is enabled. The GSA should have the Monitoring Metric
 *  Writer (roles/monitoring.metricWriter) IAM role. The Kubernetes
 *  ServiceAccount `default` in the namespace `config-management-monitoring`
 *  should be bound to the GSA. Deprecated: If Workload Identity Federation for
 *  GKE is enabled, Google Cloud Service Account is no longer needed for
 *  exporting Config Sync metrics:
 *  https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/monitor-config-sync-cloud-monitoring#custom-monitoring.
 */
@property(nonatomic, copy, nullable) NSString *metricsGcpServiceAccountEmail GTLR_DEPRECATED;

/** Optional. OCI repo configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementOciConfig *oci;

/**
 *  Optional. Set to true to enable the Config Sync admission webhook to prevent
 *  drifts. If set to `false`, disables the Config Sync admission webhook and
 *  does not prevent drifts.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preventDrift;

/**
 *  Optional. Specifies whether the Config Sync Repo is in "hierarchical" or
 *  "unstructured" mode.
 */
@property(nonatomic, copy, nullable) NSString *sourceFormat;

/**
 *  Optional. Set to true to stop syncing configs for a single cluster. Default
 *  to false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *stopSyncing;

@end


/**
 *  The state of ConfigSync's deployment on a cluster.
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncDeploymentState : GTLRObject

/**
 *  Deployment state of admission-webhook.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *admissionWebhook;

/**
 *  Deployment state of the git-sync pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gitSync;

/**
 *  Deployment state of the importer pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *importer;

/**
 *  Deployment state of the monitor pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *monitor;

/**
 *  Deployment state of otel-collector
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_OtelCollector_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *otelCollector;

/**
 *  Deployment state of reconciler-manager pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *reconcilerManager;

/**
 *  Deployment state of resource-group-controller-manager
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ResourceGroupControllerManager_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *resourceGroupControllerManager;

/**
 *  Deployment state of root-reconciler.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *rootReconciler;

/**
 *  Deployment state of the syncer pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *syncer;

@end


/**
 *  Errors pertaining to the installation of Config Sync
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncError : GTLRObject

/** A string representing the user facing error message */
@property(nonatomic, copy, nullable) NSString *errorMessage;

@end


/**
 *  State information for ConfigSync.
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncState : GTLRObject

/**
 *  Output only. Whether syncing resources to the cluster is stopped at the
 *  cluster level.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_NotStopped
 *        Syncing resources to the cluster is not stopped at the cluster level.
 *        (Value: "NOT_STOPPED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_Pending
 *        Some reconcilers stop syncing resources to the cluster, while others
 *        are still syncing. (Value: "PENDING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_Stopped
 *        Syncing resources to the cluster is stopped at the cluster level.
 *        (Value: "STOPPED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ClusterLevelStopSyncingState_StopSyncingStateUnspecified
 *        State cannot be determined (Value: "STOP_SYNCING_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *clusterLevelStopSyncingState;

/**
 *  Output only. The number of RootSync and RepoSync CRs in the cluster.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crCount;

/**
 *  Output only. Information about the deployment of ConfigSync, including the
 *  version. of the various Pods deployed
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSyncDeploymentState *deploymentState;

/** Output only. Errors pertaining to the installation of Config Sync. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementConfigSyncError *> *errors;

/**
 *  Output only. The state of the Reposync CRD
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_CrdStateUnspecified
 *        CRD's state cannot be determined (Value: "CRD_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installed
 *        CRD is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installing
 *        CRD is installing (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_NotInstalled
 *        CRD is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Terminating
 *        CRD is terminating (i.e., it has been deleted and is cleaning up)
 *        (Value: "TERMINATING")
 */
@property(nonatomic, copy, nullable) NSString *reposyncCrd;

/**
 *  Output only. The state of the RootSync CRD
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_CrdStateUnspecified
 *        CRD's state cannot be determined (Value: "CRD_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installed
 *        CRD is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installing
 *        CRD is installing (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_NotInstalled
 *        CRD is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Terminating
 *        CRD is terminating (i.e., it has been deleted and is cleaning up)
 *        (Value: "TERMINATING")
 */
@property(nonatomic, copy, nullable) NSString *rootsyncCrd;

/**
 *  Output only. The state of CS This field summarizes the other fields in this
 *  message.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncError
 *        CS encounters errors. (Value: "CONFIG_SYNC_ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncInstalled
 *        The expected CS version is installed successfully. (Value:
 *        "CONFIG_SYNC_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncNotInstalled
 *        CS is not installed. (Value: "CONFIG_SYNC_NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncPending
 *        CS is installing or terminating. (Value: "CONFIG_SYNC_PENDING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_StateUnspecified
 *        CS's state cannot be determined. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Output only. The state of ConfigSync's process to sync configs to a cluster.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementSyncState *syncState;

/** Output only. The version of ConfigSync deployed. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSyncVersion *version;

@end


/**
 *  Specific versioning information pertaining to ConfigSync's Pods.
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncVersion : GTLRObject

/** Version of the deployed admission-webhook pod. */
@property(nonatomic, copy, nullable) NSString *admissionWebhook;

/** Version of the deployed git-sync pod. */
@property(nonatomic, copy, nullable) NSString *gitSync;

/** Version of the deployed importer pod. */
@property(nonatomic, copy, nullable) NSString *importer;

/** Version of the deployed monitor pod. */
@property(nonatomic, copy, nullable) NSString *monitor;

/** Version of the deployed otel-collector pod */
@property(nonatomic, copy, nullable) NSString *otelCollector;

/** Version of the deployed reconciler-manager pod. */
@property(nonatomic, copy, nullable) NSString *reconcilerManager;

/** Version of the deployed resource-group-controller-manager pod */
@property(nonatomic, copy, nullable) NSString *resourceGroupControllerManager;

/** Version of the deployed reconciler container in root-reconciler pod. */
@property(nonatomic, copy, nullable) NSString *rootReconciler;

/** Version of the deployed syncer pod. */
@property(nonatomic, copy, nullable) NSString *syncer;

@end


/**
 *  Configuration for a container override.
 */
@interface GTLRGKEHub_ConfigManagementContainerOverride : GTLRObject

/** Required. The name of the container. */
@property(nonatomic, copy, nullable) NSString *containerName;

/** Optional. The cpu limit of the container. */
@property(nonatomic, copy, nullable) NSString *cpuLimit;

/** Optional. The cpu request of the container. */
@property(nonatomic, copy, nullable) NSString *cpuRequest;

/** Optional. The memory limit of the container. */
@property(nonatomic, copy, nullable) NSString *memoryLimit;

/** Optional. The memory request of the container. */
@property(nonatomic, copy, nullable) NSString *memoryRequest;

@end


/**
 *  Configuration for a deployment override.
 */
@interface GTLRGKEHub_ConfigManagementDeploymentOverride : GTLRObject

/** Optional. The containers of the deployment resource to be overridden. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementContainerOverride *> *containers;

/** Required. The name of the deployment resource to be overridden. */
@property(nonatomic, copy, nullable) NSString *deploymentName;

/** Required. The namespace of the deployment resource to be overridden. */
@property(nonatomic, copy, nullable) NSString *deploymentNamespace;

@end


/**
 *  Model for a config file in the git repo with an associated Sync error.
 */
@interface GTLRGKEHub_ConfigManagementErrorResource : GTLRObject

/** Group/version/kind of the resource that is causing an error */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementGroupVersionKind *resourceGvk;

/** Metadata name of the resource that is causing an error */
@property(nonatomic, copy, nullable) NSString *resourceName;

/** Namespace of the resource that is causing an error */
@property(nonatomic, copy, nullable) NSString *resourceNamespace;

/** Path in the git repo of the erroneous config */
@property(nonatomic, copy, nullable) NSString *sourcePath;

@end


/**
 *  State of Policy Controller installation.
 */
@interface GTLRGKEHub_ConfigManagementGatekeeperDeploymentState : GTLRObject

/**
 *  Status of gatekeeper-audit deployment.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gatekeeperAudit;

/**
 *  Status of gatekeeper-controller-manager pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gatekeeperControllerManagerState;

/**
 *  Status of the pod serving the mutation webhook.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gatekeeperMutation;

@end


/**
 *  Git repo configuration for a single cluster.
 */
@interface GTLRGKEHub_ConfigManagementGitConfig : GTLRObject

/**
 *  Optional. The Google Cloud Service Account Email used for auth when
 *  secret_type is gcpServiceAccount.
 */
@property(nonatomic, copy, nullable) NSString *gcpServiceAccountEmail;

/**
 *  Optional. URL for the HTTPS proxy to be used when communicating with the Git
 *  repo.
 */
@property(nonatomic, copy, nullable) NSString *httpsProxy;

/**
 *  Optional. The path within the Git repository that represents the top level
 *  of the repo to sync. Default: the root directory of the repository.
 */
@property(nonatomic, copy, nullable) NSString *policyDir;

/**
 *  Required. Type of secret configured for access to the Git repo. Must be one
 *  of ssh, cookiefile, gcenode, token, gcpserviceaccount, githubapp or none.
 *  The validation of this is case-sensitive.
 */
@property(nonatomic, copy, nullable) NSString *secretType;

/** Optional. The branch of the repository to sync from. Default: master. */
@property(nonatomic, copy, nullable) NSString *syncBranch;

/** Required. The URL of the Git repository to use as the source of truth. */
@property(nonatomic, copy, nullable) NSString *syncRepo;

/** Optional. Git revision (tag or hash) to check out. Default HEAD. */
@property(nonatomic, copy, nullable) NSString *syncRev;

/**
 *  Optional. Period in seconds between consecutive syncs. Default: 15.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *syncWaitSecs;

@end


/**
 *  A Kubernetes object's GVK.
 */
@interface GTLRGKEHub_ConfigManagementGroupVersionKind : GTLRObject

/** Kubernetes Group */
@property(nonatomic, copy, nullable) NSString *group;

/** Kubernetes Kind */
@property(nonatomic, copy, nullable) NSString *kind;

/** Kubernetes Version */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Configuration for Hierarchy Controller.
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerConfig : GTLRObject

/**
 *  Whether Hierarchy Controller is enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Whether hierarchical resource quota is enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableHierarchicalResourceQuota;

/**
 *  Whether pod tree labels are enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enablePodTreeLabels;

@end


/**
 *  Deployment state for Hierarchy Controller
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState : GTLRObject

/**
 *  The deployment state for Hierarchy Controller extension (e.g. v0.7.0-hc.1).
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *extension;

/**
 *  The deployment state for open source HNC (e.g. v0.7.0-hc.0).
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *hnc;

@end


/**
 *  State for Hierarchy Controller.
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerState : GTLRObject

/** The deployment state for Hierarchy Controller. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState *state;

/** The version for Hierarchy Controller. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerVersion *version;

@end


/**
 *  Version for Hierarchy Controller.
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerVersion : GTLRObject

/** Version for Hierarchy Controller extension. */
@property(nonatomic, copy, nullable) NSString *extension;

/** Version for open source HNC. */
@property(nonatomic, copy, nullable) NSString *hnc;

@end


/**
 *  Errors pertaining to the installation of ACM.
 */
@interface GTLRGKEHub_ConfigManagementInstallError : GTLRObject

/** A string representing the user facing error message. */
@property(nonatomic, copy, nullable) NSString *errorMessage;

@end


/**
 *  OCI repo configuration for a single cluster.
 */
@interface GTLRGKEHub_ConfigManagementOciConfig : GTLRObject

/**
 *  Optional. The Google Cloud Service Account Email used for auth when
 *  secret_type is gcpServiceAccount.
 */
@property(nonatomic, copy, nullable) NSString *gcpServiceAccountEmail;

/**
 *  Optional. The absolute path of the directory that contains the local
 *  resources. Default: the root directory of the image.
 */
@property(nonatomic, copy, nullable) NSString *policyDir;

/**
 *  Required. Type of secret configured for access to the OCI repo. Must be one
 *  of gcenode, gcpserviceaccount, k8sserviceaccount or none. The validation of
 *  this is case-sensitive.
 */
@property(nonatomic, copy, nullable) NSString *secretType;

/**
 *  Required. The OCI image repository URL for the package to sync from. e.g.
 *  `LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME`.
 */
@property(nonatomic, copy, nullable) NSString *syncRepo;

/**
 *  Optional. Period in seconds between consecutive syncs. Default: 15.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *syncWaitSecs;

@end


/**
 *  State information for an ACM's Operator.
 */
@interface GTLRGKEHub_ConfigManagementOperatorState : GTLRObject

/**
 *  The state of the Operator's deployment.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_DeploymentStateUnspecified
 *        Deployment's state cannot be determined. (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Error
 *        Deployment was attempted to be installed, but has errors. (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Installed
 *        Deployment is installed. (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_NotInstalled
 *        Deployment is not installed. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *deploymentState;

/** Install errors. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementInstallError *> *errors;

/** The semenatic version number of the operator. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Configuration for Policy Controller
 */
@interface GTLRGKEHub_ConfigManagementPolicyController : GTLRObject

/**
 *  Sets the interval for Policy Controller Audit Scans (in seconds). When set
 *  to 0, this disables audit functionality altogether.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *auditIntervalSeconds;

/**
 *  Enables the installation of Policy Controller. If false, the rest of
 *  PolicyController fields take no effect.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  The set of namespaces that are excluded from Policy Controller checks.
 *  Namespaces do not need to currently exist on the cluster.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptableNamespaces;

/**
 *  Logs all denies and dry run failures.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logDeniesEnabled;

/** Monitoring specifies the configuration of monitoring. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerMonitoring *monitoring;

/**
 *  Enable or disable mutation in policy controller. If true, mutation CRDs,
 *  webhook and controller deployment will be deployed to the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mutationEnabled;

/**
 *  Enables the ability to use Constraint Templates that reference to objects
 *  other than the object currently being evaluated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *referentialRulesEnabled;

/**
 *  Installs the default template library along with Policy Controller.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *templateLibraryInstalled;

/** Output only. Last time this membership spec was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  State for the migration of PolicyController from ACM -> PoCo Hub.
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerMigration : GTLRObject

/** Last time this membership spec was copied to PoCo feature. */
@property(nonatomic, strong, nullable) GTLRDateTime *copyTime NS_RETURNS_NOT_RETAINED;

/**
 *  Stage of the migration.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_AcmManaged
 *        ACM Hub/Operator manages policycontroller. No migration yet completed.
 *        (Value: "ACM_MANAGED")
 *    @arg @c kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_PocoManaged
 *        All migrations steps complete; Poco Hub now manages policycontroller.
 *        (Value: "POCO_MANAGED")
 *    @arg @c kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_StageUnspecified
 *        Unknown state of migration. (Value: "STAGE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *stage;

@end


/**
 *  PolicyControllerMonitoring specifies the backends Policy Controller should
 *  export metrics to. For example, to specify metrics should be exported to
 *  Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring",
 *  "prometheus"]
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerMonitoring : GTLRObject

/**
 *  Specifies the list of backends Policy Controller will export to. An empty
 *  list would effectively disable metrics export.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backends;

@end


/**
 *  State for PolicyControllerState.
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerState : GTLRObject

/** The state about the policy controller installation. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementGatekeeperDeploymentState *deploymentState;

/** Record state of ACM -> PoCo Hub migration for this feature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerMigration *migration;

/** The version of Gatekeeper Policy Controller deployed. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerVersion *version;

@end


/**
 *  The build version of Gatekeeper Policy Controller is using.
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerVersion : GTLRObject

/**
 *  The gatekeeper image tag that is composed of ACM version, git tag, build
 *  number.
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  **Anthos Config Management**: Configuration for a single cluster. Intended
 *  to parallel the ConfigManagement CR.
 */
@interface GTLRGKEHub_ConfigManagementSpec : GTLRObject

/**
 *  Optional. Binauthz conifguration for the cluster. Deprecated: This field
 *  will be ignored and should not be set.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementBinauthzConfig *binauthz GTLR_DEPRECATED;

/**
 *  Optional. The user-specified cluster name used by Config Sync
 *  cluster-name-selector annotation or ClusterSelector, for applying configs to
 *  only a subset of clusters. Omit this field if the cluster's fleet membership
 *  name is used by Config Sync cluster-name-selector annotation or
 *  ClusterSelector. Set this field if a name different from the cluster's fleet
 *  membership name is used by Config Sync cluster-name-selector annotation or
 *  ClusterSelector.
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/** Optional. Config Sync configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSync *configSync;

/**
 *  Optional. Hierarchy Controller configuration for the cluster. Deprecated:
 *  Configuring Hierarchy Controller through the configmanagement feature is no
 *  longer recommended. Use
 *  https://github.com/kubernetes-sigs/hierarchical-namespaces instead.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerConfig *hierarchyController GTLR_DEPRECATED;

/**
 *  Optional. Enables automatic Feature management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementSpec_Management_ManagementAutomatic
 *        Google will manage the Feature for the cluster. (Value:
 *        "MANAGEMENT_AUTOMATIC")
 *    @arg @c kGTLRGKEHub_ConfigManagementSpec_Management_ManagementManual User
 *        will manually manage the Feature for the cluster. (Value:
 *        "MANAGEMENT_MANUAL")
 *    @arg @c kGTLRGKEHub_ConfigManagementSpec_Management_ManagementUnspecified
 *        Unspecified (Value: "MANAGEMENT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *management;

/**
 *  Optional. Policy Controller configuration for the cluster. Deprecated:
 *  Configuring Policy Controller through the configmanagement feature is no
 *  longer recommended. Use the policycontroller feature instead.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyController *policyController GTLR_DEPRECATED;

/** Optional. Version of ACM installed. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  **Anthos Config Management**: State for a single cluster.
 */
@interface GTLRGKEHub_ConfigManagementState : GTLRObject

/** Output only. Binauthz status. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementBinauthzState *binauthzState;

/**
 *  Output only. This field is set to the `cluster_name` field of the Membership
 *  Spec if it is not empty. Otherwise, it is set to the cluster's fleet
 *  membership name.
 */
@property(nonatomic, copy, nullable) NSString *clusterName;

/** Output only. Current sync status. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSyncState *configSyncState;

/** Output only. Hierarchy Controller status. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerState *hierarchyControllerState;

/** Output only. The Kubernetes API server version of the cluster. */
@property(nonatomic, copy, nullable) NSString *kubernetesApiServerVersion;

/**
 *  Output only. Membership configuration in the cluster. This represents the
 *  actual state in the cluster, while the MembershipSpec in the FeatureSpec
 *  represents the intended state.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementSpec *membershipSpec;

/** Output only. Current install status of ACM's Operator. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementOperatorState *operatorState;

/** Output only. PolicyController status. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerState *policyControllerState;

@end


/**
 *  An ACM created error representing a problem syncing configurations.
 */
@interface GTLRGKEHub_ConfigManagementSyncError : GTLRObject

/** An ACM defined error code */
@property(nonatomic, copy, nullable) NSString *code;

/** A description of the error */
@property(nonatomic, copy, nullable) NSString *errorMessage;

/** A list of config(s) associated with the error, if any */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementErrorResource *> *errorResources;

@end


/**
 *  State indicating an ACM's progress syncing configurations to a cluster.
 */
@interface GTLRGKEHub_ConfigManagementSyncState : GTLRObject

/**
 *  Sync status code.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Error Indicates an
 *        error configuring Config Sync, and user action is required (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_NotConfigured Config
 *        Sync has been installed but not configured (Value: "NOT_CONFIGURED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_NotInstalled Config
 *        Sync has not been installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Pending Config Sync is
 *        in the progress of syncing a new change (Value: "PENDING")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_SyncCodeUnspecified
 *        Config Sync cannot determine a sync code (Value:
 *        "SYNC_CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Synced Config Sync
 *        successfully synced the git Repo with the cluster (Value: "SYNCED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Unauthorized Error
 *        authorizing with the cluster (Value: "UNAUTHORIZED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Unreachable Cluster
 *        could not be reached (Value: "UNREACHABLE")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  A list of errors resulting from problematic configs. This list will be
 *  truncated after 100 errors, although it is unlikely for that many errors to
 *  simultaneously exist.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementSyncError *> *errors;

/** Token indicating the state of the importer. */
@property(nonatomic, copy, nullable) NSString *importToken;

/**
 *  Deprecated: use last_sync_time instead. Timestamp of when ACM last
 *  successfully synced the repo. The time format is specified in
 *  https://golang.org/pkg/time/#Time.String
 */
@property(nonatomic, copy, nullable) NSString *lastSync GTLR_DEPRECATED;

/** Timestamp type of when ACM last successfully synced the repo. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastSyncTime;

/** Token indicating the state of the repo. */
@property(nonatomic, copy, nullable) NSString *sourceToken;

/** Token indicating the state of the syncer. */
@property(nonatomic, copy, nullable) NSString *syncToken;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRGKEHub_Empty : GTLRObject
@end


/**
 *  FeatureSpec contains user input per-feature spec information.
 */
@interface GTLRGKEHub_FeatureSpec : GTLRObject

/** Cloudbuild-specific FeatureSpec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_CloudBuildSpec *cloudbuild;

/** Config Management FeatureSpec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementSpec *configmanagement;

/** IdentityService FeatureSpec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSpec *identityservice;

/**
 *  Whether this per-Feature spec was inherited from a fleet-level default. This
 *  field can be updated by users by either overriding a Feature config (updated
 *  to USER implicitly) or setting to FLEET explicitly.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Origin *origin;

/** Policycontroller-specific FeatureSpec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerSpec *policycontroller;

/** Rbacrolebindingactuation-specific FeatureSpec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_RBACRoleBindingActuationSpec *rbacrolebindingactuation;

/** ServiceMesh Feature Spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshSpec *servicemesh;

/** Workloadcertificate-specific FeatureSpec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_WorkloadCertificateSpec *workloadcertificate;

@end


/**
 *  FeatureState contains high-level state information and per-feature state
 *  information for this MembershipFeature.
 */
@interface GTLRGKEHub_FeatureState : GTLRObject

/** Appdevexperience specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_AppDevExperienceState *appdevexperience;

/** Cluster upgrade state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeState *clusterupgrade;

/** Config Management state */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementState *configmanagement;

/** Identity service state */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceState *identityservice;

/** Metering state */
@property(nonatomic, strong, nullable) GTLRGKEHub_MeteringState *metering;

/** Policy Controller state */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerState *policycontroller;

/** RBAC Role Binding Actuation state */
@property(nonatomic, strong, nullable) GTLRGKEHub_RBACRoleBindingActuationState *rbacrolebindingactuation;

/** Service mesh state */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshState *servicemesh;

/** The high-level state of this MembershipFeature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_State *state;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRGKEHub_GoogleRpcStatus : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_GoogleRpcStatus_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRGKEHub_GoogleRpcStatus_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_GoogleRpcStatus_Details_Item : GTLRObject
@end


/**
 *  Configuration of an auth method for a member/cluster. Only one
 *  authentication method (e.g., OIDC and LDAP) can be set per AuthMethod.
 */
@interface GTLRGKEHub_IdentityServiceAuthMethod : GTLRObject

/** AzureAD specific Configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceAzureADConfig *azureadConfig;

/** GoogleConfig specific configuration */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceGoogleConfig *googleConfig;

/** LDAP specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceLdapConfig *ldapConfig;

/** Identifier for auth config. */
@property(nonatomic, copy, nullable) NSString *name;

/** OIDC specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceOidcConfig *oidcConfig;

/** Proxy server address to use for auth method. */
@property(nonatomic, copy, nullable) NSString *proxy;

/** SAML specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSamlConfig *samlConfig;

@end


/**
 *  Configuration for the AzureAD Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceAzureADConfig : GTLRObject

/**
 *  ID for the registered client application that makes authentication requests
 *  to the Azure AD identity provider.
 */
@property(nonatomic, copy, nullable) NSString *clientId;

/**
 *  Input only. Unencrypted AzureAD client secret will be passed to the GKE Hub
 *  CLH.
 */
@property(nonatomic, copy, nullable) NSString *clientSecret;

/**
 *  Output only. Encrypted AzureAD client secret.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *encryptedClientSecret;

/** Optional. Format of the AzureAD groups that the client wants for auth. */
@property(nonatomic, copy, nullable) NSString *groupFormat;

/** The redirect URL that kubectl uses for authorization. */
@property(nonatomic, copy, nullable) NSString *kubectlRedirectUri;

/**
 *  Kind of Azure AD account to be authenticated. Supported values are or for
 *  accounts belonging to a specific tenant.
 */
@property(nonatomic, copy, nullable) NSString *tenant;

/** Optional. Claim in the AzureAD ID Token that holds the user details. */
@property(nonatomic, copy, nullable) NSString *userClaim;

@end


/**
 *  Configuration options for the AIS diagnostic interface.
 */
@interface GTLRGKEHub_IdentityServiceDiagnosticInterface : GTLRObject

/**
 *  Determines whether to enable the diagnostic interface.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Determines the expiration time of the diagnostic interface enablement. When
 *  reached, requests to the interface would be automatically rejected.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTime;

@end


/**
 *  Configuration for the Google Plugin Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceGoogleConfig : GTLRObject

/**
 *  Disable automatic configuration of Google Plugin on supported platforms.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disable;

@end


/**
 *  Contains the properties for locating and authenticating groups in the
 *  directory.
 */
@interface GTLRGKEHub_IdentityServiceGroupConfig : GTLRObject

/**
 *  Required. The location of the subtree in the LDAP directory to search for
 *  group entries.
 */
@property(nonatomic, copy, nullable) NSString *baseDn;

/**
 *  Optional. Optional filter to be used when searching for groups a user
 *  belongs to. This can be used to explicitly match only certain groups in
 *  order to reduce the amount of groups returned for each user. This defaults
 *  to "(objectClass=Group)".
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Optional. The identifying name of each group a user belongs to. For example,
 *  if this is set to "distinguishedName" then RBACs and other group
 *  expectations should be written as full DNs. This defaults to
 *  "distinguishedName".
 */
@property(nonatomic, copy, nullable) NSString *idAttribute;

@end


/**
 *  Holds non-protocol-related configuration options.
 */
@interface GTLRGKEHub_IdentityServiceIdentityServiceOptions : GTLRObject

/** Configuration options for the AIS diagnostic interface. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceDiagnosticInterface *diagnosticInterface;

/**
 *  Determines the lifespan of STS tokens issued by Anthos Identity Service.
 */
@property(nonatomic, strong, nullable) GTLRDuration *sessionDuration;

@end


/**
 *  Configuration for the LDAP Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceLdapConfig : GTLRObject

/**
 *  Optional. Contains the properties for locating and authenticating groups in
 *  the directory.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceGroupConfig *group;

/** Required. Server settings for the external LDAP server. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceServerConfig *server;

/**
 *  Required. Contains the credentials of the service account which is
 *  authorized to perform the LDAP search in the directory. The credentials can
 *  be supplied by the combination of the DN and password or the client
 *  certificate.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceServiceAccountConfig *serviceAccount;

/** Required. Defines where users exist in the LDAP directory. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceUserConfig *user;

@end


/**
 *  Configuration for OIDC Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceOidcConfig : GTLRObject

/** PEM-encoded CA for OIDC provider. */
@property(nonatomic, copy, nullable) NSString *certificateAuthorityData;

/** ID for OIDC client application. */
@property(nonatomic, copy, nullable) NSString *clientId;

/**
 *  Input only. Unencrypted OIDC client secret will be passed to the GKE Hub
 *  CLH.
 */
@property(nonatomic, copy, nullable) NSString *clientSecret;

/**
 *  Flag to denote if reverse proxy is used to connect to auth provider. This
 *  flag should be set to true when provider is not reachable by Google Cloud
 *  Console.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deployCloudConsoleProxy;

/**
 *  Enable access token.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableAccessToken;

/**
 *  Output only. Encrypted OIDC Client secret
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *encryptedClientSecret;

/** Comma-separated list of key-value pairs. */
@property(nonatomic, copy, nullable) NSString *extraParams;

/** Prefix to prepend to group name. */
@property(nonatomic, copy, nullable) NSString *groupPrefix;

/** Claim in OIDC ID token that holds group information. */
@property(nonatomic, copy, nullable) NSString *groupsClaim;

/**
 *  URI for the OIDC provider. This should point to the level below
 *  .well-known/openid-configuration.
 */
@property(nonatomic, copy, nullable) NSString *issuerUri;

/**
 *  Registered redirect uri to redirect users going through OAuth flow using
 *  kubectl plugin.
 */
@property(nonatomic, copy, nullable) NSString *kubectlRedirectUri;

/** Comma-separated list of identifiers. */
@property(nonatomic, copy, nullable) NSString *scopes;

/** Claim in OIDC ID token that holds username. */
@property(nonatomic, copy, nullable) NSString *userClaim;

/** Prefix to prepend to user name. */
@property(nonatomic, copy, nullable) NSString *userPrefix;

@end


/**
 *  Configuration for the SAML Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceSamlConfig : GTLRObject

/**
 *  Optional. The mapping of additional user attributes like nickname, birthday
 *  and address etc.. `key` is the name of this additional attribute. `value` is
 *  a string presenting as CEL(common expression language, go/cel) used for
 *  getting the value from the resources. Take nickname as an example, in this
 *  case, `key` is "attribute.nickname" and `value` is "assertion.nickname".
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSamlConfig_AttributeMapping *attributeMapping;

/** Optional. Prefix to prepend to group name. */
@property(nonatomic, copy, nullable) NSString *groupPrefix;

/**
 *  Optional. The SAML attribute to read groups from. This value is expected to
 *  be a string and will be passed along as-is (with the option of being
 *  prefixed by the `group_prefix`).
 */
@property(nonatomic, copy, nullable) NSString *groupsAttribute;

/**
 *  Required. The list of IdP certificates to validate the SAML response
 *  against.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *identityProviderCertificates;

/** Required. The entity ID of the SAML IdP. */
@property(nonatomic, copy, nullable) NSString *identityProviderId;

/** Required. The URI where the SAML IdP exposes the SSO service. */
@property(nonatomic, copy, nullable) NSString *identityProviderSsoUri;

/**
 *  Optional. The SAML attribute to read username from. If unspecified, the
 *  username will be read from the NameID element of the assertion in SAML
 *  response. This value is expected to be a string and will be passed along
 *  as-is (with the option of being prefixed by the `user_prefix`).
 */
@property(nonatomic, copy, nullable) NSString *userAttribute;

/** Optional. Prefix to prepend to user name. */
@property(nonatomic, copy, nullable) NSString *userPrefix;

@end


/**
 *  Optional. The mapping of additional user attributes like nickname, birthday
 *  and address etc.. `key` is the name of this additional attribute. `value` is
 *  a string presenting as CEL(common expression language, go/cel) used for
 *  getting the value from the resources. Take nickname as an example, in this
 *  case, `key` is "attribute.nickname" and `value` is "assertion.nickname".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_IdentityServiceSamlConfig_AttributeMapping : GTLRObject
@end


/**
 *  Server settings for the external LDAP server.
 */
@interface GTLRGKEHub_IdentityServiceServerConfig : GTLRObject

/**
 *  Optional. Contains a Base64 encoded, PEM formatted certificate authority
 *  certificate for the LDAP server. This must be provided for the "ldaps" and
 *  "startTLS" connections.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *certificateAuthorityData;

/**
 *  Optional. Defines the connection type to communicate with the LDAP server.
 *  If `starttls` or `ldaps` is specified, the certificate_authority_data should
 *  not be empty.
 */
@property(nonatomic, copy, nullable) NSString *connectionType;

/**
 *  Required. Defines the hostname or IP of the LDAP server. Port is optional
 *  and will default to 389, if unspecified. For example, "ldap.server.example"
 *  or "10.10.10.10:389".
 */
@property(nonatomic, copy, nullable) NSString *host;

@end


/**
 *  Contains the credentials of the service account which is authorized to
 *  perform the LDAP search in the directory. The credentials can be supplied by
 *  the combination of the DN and password or the client certificate.
 */
@interface GTLRGKEHub_IdentityServiceServiceAccountConfig : GTLRObject

/** Credentials for basic auth. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSimpleBindCredentials *simpleBindCredentials;

@end


/**
 *  The structure holds the LDAP simple binding credential.
 */
@interface GTLRGKEHub_IdentityServiceSimpleBindCredentials : GTLRObject

/**
 *  Required. The distinguished name(DN) of the service account object/user.
 */
@property(nonatomic, copy, nullable) NSString *dn;

/**
 *  Output only. The encrypted password of the service account object/user.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *encryptedPassword;

/** Required. Input only. The password of the service account object/user. */
@property(nonatomic, copy, nullable) NSString *password;

@end


/**
 *  **IdentityService**: Configuration for a single membership.
 */
@interface GTLRGKEHub_IdentityServiceSpec : GTLRObject

/** A member may support multiple auth methods. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_IdentityServiceAuthMethod *> *authMethods;

/** Optional. non-protocol-related configuration options. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceIdentityServiceOptions *identityServiceOptions;

@end


/**
 *  **IdentityService**: State for a single membership, analyzed and reported by
 *  feature controller.
 */
@interface GTLRGKEHub_IdentityServiceState : GTLRObject

/** The reason of the failure. */
@property(nonatomic, copy, nullable) NSString *failureReason;

/**
 *  Installed AIS version. This is the AIS version installed on this member. The
 *  values makes sense iff state is OK.
 */
@property(nonatomic, copy, nullable) NSString *installedVersion;

/** Last reconciled membership configuration */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSpec *memberConfig;

/**
 *  Deployment state on this member
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_IdentityServiceState_State_DeploymentStateUnspecified
 *        Unspecified state (Value: "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_IdentityServiceState_State_Error Failure with error.
 *        (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_IdentityServiceState_State_Ok deployment succeeds
 *        (Value: "OK")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Defines where users exist in the LDAP directory.
 */
@interface GTLRGKEHub_IdentityServiceUserConfig : GTLRObject

/**
 *  Required. The location of the subtree in the LDAP directory to search for
 *  user entries.
 */
@property(nonatomic, copy, nullable) NSString *baseDn;

/**
 *  Optional. Filter to apply when searching for the user. This can be used to
 *  further restrict the user accounts which are allowed to login. This defaults
 *  to "(objectClass=User)".
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Optional. Determines which attribute to use as the user's identity after
 *  they are authenticated. This is distinct from the loginAttribute field to
 *  allow users to login with a username, but then have their actual identifier
 *  be an email address or full Distinguished Name (DN). For example, setting
 *  loginAttribute to "sAMAccountName" and identifierAttribute to
 *  "userPrincipalName" would allow a user to login as "bsmith", but actual RBAC
 *  policies for the user would be written as "bsmith\@example.com". Using
 *  "userPrincipalName" is recommended since this will be unique for each user.
 *  This defaults to "userPrincipalName".
 */
@property(nonatomic, copy, nullable) NSString *idAttribute;

/**
 *  Optional. The name of the attribute which matches against the input
 *  username. This is used to find the user in the LDAP database e.g. "(=)" and
 *  is combined with the optional filter field. This defaults to
 *  "userPrincipalName".
 */
@property(nonatomic, copy, nullable) NSString *loginAttribute;

@end


/**
 *  LifecycleState describes the state of a MembershipFeature *resource* in the
 *  GkeHub API. See `FeatureState` for the "running state" of the
 *  MembershipFeature.
 */
@interface GTLRGKEHub_LifecycleState : GTLRObject

/**
 *  Output only. The current state of the Feature resource in the Hub API.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_LifecycleState_State_Active The MembershipFeature is
 *        enabled in this Hub, and the MembershipFeature resource is fully
 *        available. (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_LifecycleState_State_Disabling The MembershipFeature
 *        is being disabled in this Hub, and the MembershipFeature resource is
 *        being deleted. (Value: "DISABLING")
 *    @arg @c kGTLRGKEHub_LifecycleState_State_Enabling The MembershipFeature is
 *        being enabled, and the MembershipFeature resource is being created.
 *        Once complete, the corresponding MembershipFeature will be enabled in
 *        this Hub. (Value: "ENABLING")
 *    @arg @c kGTLRGKEHub_LifecycleState_State_ServiceUpdating The
 *        MembershipFeature resource is being updated by the Hub Service.
 *        (Value: "SERVICE_UPDATING")
 *    @arg @c kGTLRGKEHub_LifecycleState_State_StateUnspecified State is unknown
 *        or not set. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_LifecycleState_State_Updating The MembershipFeature
 *        resource is being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for the `GkeHubFeature.ListMembershipFeatures` method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "membershipFeatures" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRGKEHub_ListMembershipFeaturesResponse : GTLRCollectionObject

/**
 *  The list of matching MembershipFeatures.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_MembershipFeature *> *membershipFeatures;

/**
 *  A token to request the next page of resources from the
 *  `ListMembershipFeatures` method. The value of an empty string means that
 *  there are no more resources to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** List of locations that could not be reached while fetching this list. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Operation *> *operations;

/**
 *  Unordered list. Unreachable resources. Populated when the request sets
 *  `ListOperationsRequest.return_partial_success` and reads across collections.
 *  For example, when attempting to list all resources across all supported
 *  locations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRGKEHub_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Location_Metadata : GTLRObject
@end


/**
 *  MembershipFeature represents the settings and status of a Fleet Feature
 *  enabled on a single Fleet Membership.
 */
@interface GTLRGKEHub_MembershipFeature : GTLRObject

/** Output only. When the MembershipFeature resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the MembershipFeature resource was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** GCP labels for this MembershipFeature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MembershipFeature_Labels *labels;

/** Output only. Lifecycle information of the resource itself. */
@property(nonatomic, strong, nullable) GTLRGKEHub_LifecycleState *lifecycleState;

/**
 *  Output only. The resource name of the membershipFeature, in the format:
 *  `projects/{project}/locations/{location}/memberships/{membership}/features/{feature}`.
 *  Note that `membershipFeatures` is shortened to `features` in the resource
 *  name. (see http://go/aip/122#collection-identifiers)
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Optional. Spec of this membershipFeature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FeatureSpec *spec;

/** Output only. State of the this membershipFeature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FeatureState *state;

/** Output only. When the MembershipFeature resource was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  GCP labels for this MembershipFeature.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_MembershipFeature_Labels : GTLRObject
@end


/**
 *  **Metering**: State for a single membership, analyzed and reported by
 *  feature controller.
 */
@interface GTLRGKEHub_MeteringState : GTLRObject

/**
 *  The time stamp of the most recent measurement of the number of vCPUs in the
 *  cluster.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastMeasurementTime;

/**
 *  The vCPUs capacity in the cluster according to the most recent measurement
 *  (1/1000 precision).
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preciseLastMeasuredClusterVcpuCapacity;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRGKEHub_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRGKEHub_GoogleRpcStatus *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Operation_Response : GTLRObject
@end


/**
 *  Metadata of the long-running operation.
 */
@interface GTLRGKEHub_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have successfully been cancelled have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cancelRequested;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusDetail;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  Origin defines where this FeatureSpec originated from.
 */
@interface GTLRGKEHub_Origin : GTLRObject

/**
 *  Type specifies which type of origin is set.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_Origin_Type_Fleet Per-Feature spec was inherited from
 *        the fleet-level default. (Value: "FLEET")
 *    @arg @c kGTLRGKEHub_Origin_Type_FleetOutOfSync Per-Feature spec was
 *        inherited from the fleet-level default but is now out of sync with the
 *        current default. (Value: "FLEET_OUT_OF_SYNC")
 *    @arg @c kGTLRGKEHub_Origin_Type_TypeUnspecified Type is unknown or not
 *        set. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_Origin_Type_User Per-Feature spec was inherited from a
 *        user specification. (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  BundleInstallSpec is the specification configuration for a single managed
 *  bundle.
 */
@interface GTLRGKEHub_PolicyControllerBundleInstallSpec : GTLRObject

/** the set of namespaces to be exempted from the bundle */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedNamespaces;

@end


/**
 *  Configuration for Policy Controller
 */
@interface GTLRGKEHub_PolicyControllerHubConfig : GTLRObject

/**
 *  Sets the interval for Policy Controller Audit Scans (in seconds). When set
 *  to 0, this disables audit functionality altogether.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *auditIntervalSeconds;

/**
 *  The maximum number of audit violations to be stored in a constraint. If not
 *  set, the internal default (currently 20) will be used.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *constraintViolationLimit;

/**
 *  Map of deployment configs to deployments (“admission”, “audit”, “mutation”).
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerHubConfig_DeploymentConfigs *deploymentConfigs;

/**
 *  The set of namespaces that are excluded from Policy Controller checks.
 *  Namespaces do not need to currently exist on the cluster.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptableNamespaces;

/**
 *  The install_spec represents the intended state specified by the latest
 *  request that mutated install_spec in the feature spec, not the lifecycle
 *  state of the feature observed by the Hub feature controller that is reported
 *  in the feature state.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecDetached
 *        Request to stop all reconciliation actions by PoCo Hub controller.
 *        This is a breakglass mechanism to stop PoCo Hub from affecting cluster
 *        resources. (Value: "INSTALL_SPEC_DETACHED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecEnabled
 *        Request to install and enable Policy Controller. (Value:
 *        "INSTALL_SPEC_ENABLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecNotInstalled
 *        Request to uninstall Policy Controller. (Value:
 *        "INSTALL_SPEC_NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecSuspended
 *        Request to suspend Policy Controller i.e. its webhooks. If Policy
 *        Controller is not installed, it will be installed but suspended.
 *        (Value: "INSTALL_SPEC_SUSPENDED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecUnspecified
 *        Spec is unknown. (Value: "INSTALL_SPEC_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *installSpec;

/**
 *  Logs all denies and dry run failures.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logDeniesEnabled;

/** Monitoring specifies the configuration of monitoring. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerMonitoringConfig *monitoring;

/**
 *  Enables the ability to mutate resources using Policy Controller.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mutationEnabled;

/** Specifies the desired policy content on the cluster */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentSpec *policyContent;

/**
 *  Enables the ability to use Constraint Templates that reference to objects
 *  other than the object currently being evaluated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *referentialRulesEnabled;

@end


/**
 *  Map of deployment configs to deployments (“admission”, “audit”, “mutation”).
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_PolicyControllerHubConfig_DeploymentConfigs : GTLRObject
@end


/**
 *  MonitoringConfig specifies the backends Policy Controller should export
 *  metrics to. For example, to specify metrics should be exported to Cloud
 *  Monitoring and Prometheus, specify backends: ["cloudmonitoring",
 *  "prometheus"]
 */
@interface GTLRGKEHub_PolicyControllerMonitoringConfig : GTLRObject

/**
 *  Specifies the list of backends Policy Controller will export to. An empty
 *  list would effectively disable metrics export.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backends;

@end


/**
 *  OnClusterState represents the state of a sub-component of Policy Controller.
 */
@interface GTLRGKEHub_PolicyControllerOnClusterState : GTLRObject

/** Surface potential errors or information logs. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  The lifecycle state of this component.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Active The PC is
 *        fully installed on the cluster and in an operational mode. In this
 *        state PCH will be reconciling state with the PC, and the PC will be
 *        performing it's operational tasks per that software. Entering a READY
 *        state requires that the hub has confirmed the PC is installed and its
 *        pods are operational with the version of the PC the PCH expects.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_ClusterError The
 *        PC is not operational, and the PCH is unable to act to make it
 *        operational. Entering a CLUSTER_ERROR state happens automatically when
 *        the PCH determines that a PC installed on the cluster is non-operative
 *        or that the cluster does not meet requirements set for the PCH to
 *        administer the cluster but has nevertheless been given an instruction
 *        to do so (such as ‘install'). (Value: "CLUSTER_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Decommissioning
 *        The PC may have resources on the cluster, but the PCH wishes to remove
 *        the Membership. The Membership still exists. (Value:
 *        "DECOMMISSIONING")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Detached PoCo Hub
 *        is not taking any action to reconcile cluster objects. Changes to
 *        those objects will not be overwritten by PoCo Hub. (Value: "DETACHED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_HubError In this
 *        state, the PC may still be operational, and only the PCH is unable to
 *        act. The hub should not issue instructions to change the PC state, or
 *        otherwise interfere with the on-cluster resources. Entering a
 *        HUB_ERROR state happens automatically when the PCH determines the hub
 *        is in an unhealthy state and it wishes to ‘take hands off' to avoid
 *        corrupting the PC or other data. (Value: "HUB_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Installing The
 *        PCH possesses a Membership, however the PC is not fully installed on
 *        the cluster. In this state the hub can be expected to be taking
 *        actions to install the PC on the cluster. (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_LifecycleStateUnspecified
 *        The lifecycle state is unspecified. (Value:
 *        "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_NotInstalled The
 *        PC does not exist on the given cluster, and no k8s resources of any
 *        type that are associated with the PC should exist there. The cluster
 *        does not possess a membership with the PCH. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Suspended Policy
 *        Controller (PC) is installed but suspended. This means that the
 *        policies are not enforced, but violations are still recorded (through
 *        audit). (Value: "SUSPENDED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Updating The PC
 *        is fully installed, but in the process of changing the configuration
 *        (including changing the version of PC either up and down, or modifying
 *        the manifests of PC) of the resources running on the cluster. The PCH
 *        has a Membership, is aware of the version the cluster should be
 *        running in, but has not confirmed for itself that the PC is running
 *        with that version. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  PolicyContentSpec defines the user's desired content configuration on the
 *  cluster.
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentSpec : GTLRObject

/**
 *  map of bundle name to BundleInstallSpec. The bundle name maps to the
 *  `bundleName` key in the `policycontroller.gke.io/constraintData` annotation
 *  on a constraint.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentSpec_Bundles *bundles;

/** Configures the installation of the Template Library. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerTemplateLibraryConfig *templateLibrary;

@end


/**
 *  map of bundle name to BundleInstallSpec. The bundle name maps to the
 *  `bundleName` key in the `policycontroller.gke.io/constraintData` annotation
 *  on a constraint.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerBundleInstallSpec. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentSpec_Bundles : GTLRObject
@end


/**
 *  The state of the policy controller policy content
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentState : GTLRObject

/**
 *  The state of the any bundles included in the chosen version of the manifest
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentState_BundleStates *bundleStates;

/**
 *  The state of the referential data sync configuration. This could represent
 *  the state of either the syncSet object(s) or the config object, depending on
 *  the version of PoCo configured by the user.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerOnClusterState *referentialSyncConfigState;

/** The state of the template library */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerOnClusterState *templateLibraryState;

@end


/**
 *  The state of the any bundles included in the chosen version of the manifest
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerOnClusterState. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentState_BundleStates : GTLRObject
@end


/**
 *  Deployment-specific configuration.
 */
@interface GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig : GTLRObject

/** Container resource requirements. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerResourceRequirements *containerResources;

/**
 *  Pod affinity configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AffinityUnspecified
 *        No affinity configuration has been specified. (Value:
 *        "AFFINITY_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AntiAffinity
 *        Anti-affinity configuration will be applied to this deployment.
 *        Default for admissions deployment. (Value: "ANTI_AFFINITY")
 *    @arg @c kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_NoAffinity
 *        Affinity configurations will be removed from the deployment. (Value:
 *        "NO_AFFINITY")
 */
@property(nonatomic, copy, nullable) NSString *podAffinity;

/**
 *  Pod anti-affinity enablement. Deprecated: use `pod_affinity` instead.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podAntiAffinity GTLR_DEPRECATED;

/** Pod tolerations of node taints. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_PolicyControllerToleration *> *podTolerations;

/**
 *  Pod replica count.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicaCount;

@end


/**
 *  ResourceList contains container resource requirements.
 */
@interface GTLRGKEHub_PolicyControllerResourceList : GTLRObject

/** CPU requirement expressed in Kubernetes resource units. */
@property(nonatomic, copy, nullable) NSString *cpu;

/** Memory requirement expressed in Kubernetes resource units. */
@property(nonatomic, copy, nullable) NSString *memory;

@end


/**
 *  ResourceRequirements describes the compute resource requirements.
 */
@interface GTLRGKEHub_PolicyControllerResourceRequirements : GTLRObject

/**
 *  Limits describes the maximum amount of compute resources allowed for use by
 *  the running container.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerResourceList *limits;

/**
 *  Requests describes the amount of compute resources reserved for the
 *  container by the kube-scheduler.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerResourceList *requests;

@end


/**
 *  **Policy Controller**: Configuration for a single cluster. Intended to
 *  parallel the PolicyController CR.
 */
@interface GTLRGKEHub_PolicyControllerSpec : GTLRObject

/** Policy Controller configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerHubConfig *policyControllerHubConfig;

/** Version of Policy Controller installed. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  **Policy Controller**: State for a single cluster.
 */
@interface GTLRGKEHub_PolicyControllerState : GTLRObject

/**
 *  Currently these include (also serving as map keys): 1. "admission" 2.
 *  "audit" 3. "mutation"
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerState_ComponentStates *componentStates;

/** The overall content state observed by the Hub Feature controller. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentState *policyContentState;

/**
 *  The overall Policy Controller lifecycle state observed by the Hub Feature
 *  controller.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_Active The PC is fully
 *        installed on the cluster and in an operational mode. In this state PCH
 *        will be reconciling state with the PC, and the PC will be performing
 *        it's operational tasks per that software. Entering a READY state
 *        requires that the hub has confirmed the PC is installed and its pods
 *        are operational with the version of the PC the PCH expects. (Value:
 *        "ACTIVE")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_ClusterError The PC is not
 *        operational, and the PCH is unable to act to make it operational.
 *        Entering a CLUSTER_ERROR state happens automatically when the PCH
 *        determines that a PC installed on the cluster is non-operative or that
 *        the cluster does not meet requirements set for the PCH to administer
 *        the cluster but has nevertheless been given an instruction to do so
 *        (such as ‘install'). (Value: "CLUSTER_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_Decommissioning The PC may
 *        have resources on the cluster, but the PCH wishes to remove the
 *        Membership. The Membership still exists. (Value: "DECOMMISSIONING")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_Detached PoCo Hub is not
 *        taking any action to reconcile cluster objects. Changes to those
 *        objects will not be overwritten by PoCo Hub. (Value: "DETACHED")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_HubError In this state,
 *        the PC may still be operational, and only the PCH is unable to act.
 *        The hub should not issue instructions to change the PC state, or
 *        otherwise interfere with the on-cluster resources. Entering a
 *        HUB_ERROR state happens automatically when the PCH determines the hub
 *        is in an unhealthy state and it wishes to ‘take hands off' to avoid
 *        corrupting the PC or other data. (Value: "HUB_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_Installing The PCH
 *        possesses a Membership, however the PC is not fully installed on the
 *        cluster. In this state the hub can be expected to be taking actions to
 *        install the PC on the cluster. (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_LifecycleStateUnspecified
 *        The lifecycle state is unspecified. (Value:
 *        "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_NotInstalled The PC does
 *        not exist on the given cluster, and no k8s resources of any type that
 *        are associated with the PC should exist there. The cluster does not
 *        possess a membership with the PCH. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_Suspended Policy
 *        Controller (PC) is installed but suspended. This means that the
 *        policies are not enforced, but violations are still recorded (through
 *        audit). (Value: "SUSPENDED")
 *    @arg @c kGTLRGKEHub_PolicyControllerState_State_Updating The PC is fully
 *        installed, but in the process of changing the configuration (including
 *        changing the version of PC either up and down, or modifying the
 *        manifests of PC) of the resources running on the cluster. The PCH has
 *        a Membership, is aware of the version the cluster should be running
 *        in, but has not confirmed for itself that the PC is running with that
 *        version. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Currently these include (also serving as map keys): 1. "admission" 2.
 *  "audit" 3. "mutation"
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerOnClusterState. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRGKEHub_PolicyControllerState_ComponentStates : GTLRObject
@end


/**
 *  The config specifying which default library templates to install.
 */
@interface GTLRGKEHub_PolicyControllerTemplateLibraryConfig : GTLRObject

/**
 *  Configures the manner in which the template library is installed on the
 *  cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_All
 *        Install the entire template library. (Value: "ALL")
 *    @arg @c kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_InstallationUnspecified
 *        No installation strategy has been specified. (Value:
 *        "INSTALLATION_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_NotInstalled
 *        Do not install the template library. (Value: "NOT_INSTALLED")
 */
@property(nonatomic, copy, nullable) NSString *installation;

@end


/**
 *  Toleration of a node taint.
 */
@interface GTLRGKEHub_PolicyControllerToleration : GTLRObject

/** Matches a taint effect. */
@property(nonatomic, copy, nullable) NSString *effect;

/** Matches a taint key (not necessarily unique). */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Matches a taint operator.
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

/** Matches a taint value. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  RBACRoleBindingState is the status of an RBACRoleBinding which exists on a
 *  membership.
 */
@interface GTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState : GTLRObject

/**
 *  The reason for the failure.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Output only. The state of the RBACRoleBinding.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState_State_CustomRoleMissingFromCluster
 *        The RBACRoleBinding was created on the cluster but the specified
 *        custom role does not exist on the cluster, hence the RBACRoleBinding
 *        has no effect. (Value: "CUSTOM_ROLE_MISSING_FROM_CLUSTER")
 *    @arg @c kGTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState_State_Ok
 *        RBACRoleBinding is created properly on the cluster. (Value: "OK")
 *    @arg @c kGTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState_State_RoleBindingStateUnspecified
 *        Unspecified state. (Value: "ROLE_BINDING_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** The time the RBACRoleBinding status was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  **RBAC RoleBinding Actuation**: The membership-specific input for
 *  RBACRoleBindingActuation feature.
 */
@interface GTLRGKEHub_RBACRoleBindingActuationSpec : GTLRObject
@end


/**
 *  **RBAC RoleBinding Actuation**: A membership-specific Feature state for the
 *  RBACRoleBindingActuation fleet feature.
 */
@interface GTLRGKEHub_RBACRoleBindingActuationState : GTLRObject

/**
 *  Output only. The state of RBACRoleBindings using custom roles that exist on
 *  the cluster, keyed by RBACRoleBinding resource name with format:
 *  projects/{project}/locations/{location}/scopes/{scope}/rbacrolebindings/{rbacrolebinding}.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_RBACRoleBindingActuationState_RbacrolebindingStates *rbacrolebindingStates;

@end


/**
 *  Output only. The state of RBACRoleBindings using custom roles that exist on
 *  the cluster, keyed by RBACRoleBinding resource name with format:
 *  projects/{project}/locations/{location}/scopes/{scope}/rbacrolebindings/{rbacrolebinding}.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_RBACRoleBindingActuationRBACRoleBindingState. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_RBACRoleBindingActuationState_RbacrolebindingStates : GTLRObject
@end


/**
 *  AnalysisMessage is a single message produced by an analyzer, and it used to
 *  communicate to the end user about the state of their Service Mesh
 *  configuration.
 */
@interface GTLRGKEHub_ServiceMeshAnalysisMessage : GTLRObject

/**
 *  A UI can combine these args with a template (based on message_base.type) to
 *  produce an internationalized message.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshAnalysisMessage_Args *args;

/**
 *  A human readable description of what the error means. It is suitable for
 *  non-internationalize display purposes.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Details common to all types of Istio and ServiceMesh analysis messages. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshAnalysisMessageBase *messageBase;

/**
 *  A list of strings specifying the resource identifiers that were the cause of
 *  message generation. A "path" here may be: * MEMBERSHIP_ID if the cause is a
 *  specific member cluster * MEMBERSHIP_ID/(NAMESPACE\\/)?RESOURCETYPE/NAME if
 *  the cause is a resource in a cluster
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourcePaths;

@end


/**
 *  A UI can combine these args with a template (based on message_base.type) to
 *  produce an internationalized message.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_ServiceMeshAnalysisMessage_Args : GTLRObject
@end


/**
 *  AnalysisMessageBase describes some common information that is needed for all
 *  messages.
 */
@interface GTLRGKEHub_ServiceMeshAnalysisMessageBase : GTLRObject

/**
 *  A url pointing to the Service Mesh or Istio documentation for this specific
 *  error type.
 */
@property(nonatomic, copy, nullable) NSString *documentationUrl;

/**
 *  Represents how severe a message is.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_Error ERROR
 *        represents a misconfiguration that must be fixed. (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_Info INFO
 *        represents an informational finding. (Value: "INFO")
 *    @arg @c kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_LevelUnspecified
 *        Illegal. Same
 *        istio.analysis.v1alpha1.AnalysisMessageBase.Level.UNKNOWN. (Value:
 *        "LEVEL_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshAnalysisMessageBase_Level_Warning WARNING
 *        represents a misconfiguration that should be fixed. (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *level;

/** Represents the specific type of a message. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshType *type;

@end


/**
 *  Condition being reported.
 */
@interface GTLRGKEHub_ServiceMeshCondition : GTLRObject

/**
 *  Unique identifier of the condition which describes the condition
 *  recognizable to the user.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CanonicalServiceError
 *        Failure to reconcile CanonicalServices (Value:
 *        "CANONICAL_SERVICE_ERROR")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ClusterHasZeroNodes Cluster
 *        has zero node code (Value: "CLUSTER_HAS_ZERO_NODES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CniConfigUnsupported CNI
 *        config unsupported error code (Value: "CNI_CONFIG_UNSUPPORTED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CniInstallationFailed CNI
 *        installation failed error code (Value: "CNI_INSTALLATION_FAILED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CniPodUnschedulable CNI pod
 *        unschedulable error code (Value: "CNI_POD_UNSCHEDULABLE")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CodeUnspecified Default
 *        Unspecified code (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ConfigApplyInternalError
 *        Configuration (Istio/k8s resources) failed to apply due to internal
 *        error. (Value: "CONFIG_APPLY_INTERNAL_ERROR")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ConfigValidationError
 *        Configuration failed to be applied due to being invalid. (Value:
 *        "CONFIG_VALIDATION_ERROR")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ConfigValidationWarning
 *        Encountered configuration(s) with possible unintended behavior or
 *        invalid configuration. These configs may not have been applied.
 *        (Value: "CONFIG_VALIDATION_WARNING")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_DeprecatedSpecControlPlaneManagement
 *        User is using deprecated ControlPlaneManagement and they have not yet
 *        set Management. (Value: "DEPRECATED_SPEC_CONTROL_PLANE_MANAGEMENT")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_DeprecatedSpecControlPlaneManagementSafe
 *        User is using deprecated ControlPlaneManagement and they have already
 *        set Management. (Value:
 *        "DEPRECATED_SPEC_CONTROL_PLANE_MANAGEMENT_SAFE")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_GkeSandboxUnsupported GKE
 *        sandbox unsupported error code (Value: "GKE_SANDBOX_UNSUPPORTED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_LegacyMcSecrets Legacy istio
 *        secrets found for multicluster error code (Value: "LEGACY_MC_SECRETS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ManagedCniNotEnabled Managed
 *        CNI not enabled error code (Value: "MANAGED_CNI_NOT_ENABLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_MeshIamCrossProjectPermissionDenied
 *        Permission denied error code for cross-project (Value:
 *        "MESH_IAM_CROSS_PROJECT_PERMISSION_DENIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_MeshIamPermissionDenied Mesh
 *        IAM permission denied error code (Value: "MESH_IAM_PERMISSION_DENIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationAborted
 *        Modernization is aborted for a cluster. (Value:
 *        "MODERNIZATION_ABORTED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationCompleted
 *        Modernization is completed for a cluster. (Value:
 *        "MODERNIZATION_COMPLETED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationEligible Fleet
 *        is eligible for modernization. (Value: "MODERNIZATION_ELIGIBLE")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationFinalized
 *        Modernization is finalized for all clusters in a fleet. Rollback is no
 *        longer allowed. (Value: "MODERNIZATION_FINALIZED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationInProgress
 *        Modernization is in progress for a cluster. (Value:
 *        "MODERNIZATION_IN_PROGRESS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationManual Fleet is
 *        opted out from automated modernization. (Value:
 *        "MODERNIZATION_MANUAL")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationMigratingWorkloads
 *        Migrating the cluster's workloads to the new implementation. (Value:
 *        "MODERNIZATION_MIGRATING_WORKLOADS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationModernizedSoaking
 *        Modernization of all the fleet's clusters is complete. Soaking before
 *        finalizing the modernization. (Value:
 *        "MODERNIZATION_MODERNIZED_SOAKING")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationModernizing
 *        Modernization of one or more clusters in a fleet is in progress.
 *        (Value: "MODERNIZATION_MODERNIZING")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationPrepared
 *        Cluster has been prepared for its workloads to be migrated. (Value:
 *        "MODERNIZATION_PREPARED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationPreparing
 *        Preparing cluster so that its workloads can be migrated. (Value:
 *        "MODERNIZATION_PREPARING")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationRollingBackCluster
 *        Rollback is in progress for modernization of a cluster. (Value:
 *        "MODERNIZATION_ROLLING_BACK_CLUSTER")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationRollingBackFleet
 *        Rollback is in progress for modernization of all clusters in a fleet.
 *        (Value: "MODERNIZATION_ROLLING_BACK_FLEET")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationScheduled
 *        Modernization is scheduled for a cluster. (Value:
 *        "MODERNIZATION_SCHEDULED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationStalled
 *        Modernization is stalled for a cluster. (Value:
 *        "MODERNIZATION_STALLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_ModernizationWillBeScheduled
 *        Modernization will be scheduled for a fleet. (Value:
 *        "MODERNIZATION_WILL_BE_SCHEDULED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_NodepoolWorkloadIdentityFederationRequired
 *        Nodepool workload identity federation required error code (Value:
 *        "NODEPOOL_WORKLOAD_IDENTITY_FEDERATION_REQUIRED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_NonStandardBinaryUsage
 *        Non-standard binary usage error code (Value:
 *        "NON_STANDARD_BINARY_USAGE")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededBackendServices
 *        BackendService quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_BACKEND_SERVICES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededClientTlsPolicies
 *        ClientTLSPolicy quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_CLIENT_TLS_POLICIES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededEndpointPolicies
 *        EndpointPolicy quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_ENDPOINT_POLICIES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededGateways
 *        Gateway quota exceeded error code. (Value: "QUOTA_EXCEEDED_GATEWAYS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededHealthChecks
 *        HealthCheck quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_HEALTH_CHECKS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededHttpFilters
 *        HTTPFilter quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_HTTP_FILTERS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededHttpRoutes
 *        HTTPRoute quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_HTTP_ROUTES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededMeshes Mesh
 *        quota exceeded error code. (Value: "QUOTA_EXCEEDED_MESHES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededNetworkEndpointGroups
 *        NetworkEndpointGroup quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_NETWORK_ENDPOINT_GROUPS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededServerTlsPolicies
 *        ServerTLSPolicy quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_SERVER_TLS_POLICIES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededServiceLbPolicies
 *        ServiceLBPolicy quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_SERVICE_LB_POLICIES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTcpFilters
 *        TCPFilter quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_TCP_FILTERS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTcpRoutes
 *        TCPRoute quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_TCP_ROUTES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTlsRoutes TLS
 *        routes quota exceeded error code. (Value: "QUOTA_EXCEEDED_TLS_ROUTES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_QuotaExceededTrafficPolicies
 *        TrafficPolicy quota exceeded error code. (Value:
 *        "QUOTA_EXCEEDED_TRAFFIC_POLICIES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_UnsupportedGatewayClass
 *        Unsupported gateway class error code (Value:
 *        "UNSUPPORTED_GATEWAY_CLASS")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_UnsupportedMultipleControlPlanes
 *        Multiple control planes unsupported error code (Value:
 *        "UNSUPPORTED_MULTIPLE_CONTROL_PLANES")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_VpcscGaSupported VPC-SC GA
 *        is supported for this control plane. (Value: "VPCSC_GA_SUPPORTED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_WorkloadIdentityRequired
 *        Workload identity required error code (Value:
 *        "WORKLOAD_IDENTITY_REQUIRED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** A short summary about the issue. */
@property(nonatomic, copy, nullable) NSString *details;

/** Links contains actionable information. */
@property(nonatomic, copy, nullable) NSString *documentationLink;

/**
 *  Severity level of the condition.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_Error Indicates an issue
 *        that prevents the mesh from operating correctly (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_Info An informational
 *        message, not requiring any action (Value: "INFO")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_SeverityUnspecified
 *        Unspecified severity (Value: "SEVERITY_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_Warning Indicates a
 *        setting is likely wrong, but the mesh is still able to operate (Value:
 *        "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  Status of control plane management.
 */
@interface GTLRGKEHub_ServiceMeshControlPlaneManagement : GTLRObject

/** Explanation of state. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshStatusDetails *> *details;

/**
 *  Output only. Implementation of managed control plane.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_ImplementationUnspecified
 *        Unspecified (Value: "IMPLEMENTATION_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_Istiod
 *        A Google build of istiod is used for the managed control plane.
 *        (Value: "ISTIOD")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_TrafficDirector
 *        Traffic director is used for the managed control plane. (Value:
 *        "TRAFFIC_DIRECTOR")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_Implementation_Updating
 *        The control plane implementation is being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *implementation;

/**
 *  LifecycleState of control plane management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Active ACTIVE
 *        means that the component is ready for use. (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Degraded
 *        DEGRADED means that the component is ready, but operating in a
 *        degraded state. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Deprovisioning
 *        DEPROVISIONING means that deprovisioning is in progress. (Value:
 *        "DEPROVISIONING")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Disabled
 *        DISABLED means that the component is not enabled. (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_FailedPrecondition
 *        FAILED_PRECONDITION means that provisioning cannot proceed because of
 *        some characteristic of the member cluster. (Value:
 *        "FAILED_PRECONDITION")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_LifecycleStateUnspecified
 *        Unspecified (Value: "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_NeedsAttention
 *        NEEDS_ATTENTION means that the component is ready, but some user
 *        intervention is required. (For example that the user should migrate
 *        workloads to a new control plane revision.) (Value: "NEEDS_ATTENTION")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Provisioning
 *        PROVISIONING means that provisioning is in progress. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Stalled
 *        STALLED means that provisioning could not be done. (Value: "STALLED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Status of data plane management. Only reported per-member.
 */
@interface GTLRGKEHub_ServiceMeshDataPlaneManagement : GTLRObject

/** Explanation of the status. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshStatusDetails *> *details;

/**
 *  Lifecycle status of data plane management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Active ACTIVE
 *        means that the component is ready for use. (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Degraded DEGRADED
 *        means that the component is ready, but operating in a degraded state.
 *        (Value: "DEGRADED")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Deprovisioning
 *        DEPROVISIONING means that deprovisioning is in progress. (Value:
 *        "DEPROVISIONING")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Disabled DISABLED
 *        means that the component is not enabled. (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_FailedPrecondition
 *        FAILED_PRECONDITION means that provisioning cannot proceed because of
 *        some characteristic of the member cluster. (Value:
 *        "FAILED_PRECONDITION")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_LifecycleStateUnspecified
 *        Unspecified (Value: "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_NeedsAttention
 *        NEEDS_ATTENTION means that the component is ready, but some user
 *        intervention is required. (For example that the user should migrate
 *        workloads to a new control plane revision.) (Value: "NEEDS_ATTENTION")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Provisioning
 *        PROVISIONING means that provisioning is in progress. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Stalled STALLED
 *        means that provisioning could not be done. (Value: "STALLED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  **Service Mesh**: Spec for a single Membership for the servicemesh feature
 */
@interface GTLRGKEHub_ServiceMeshSpec : GTLRObject

/**
 *  Optional. Specifies the API that will be used for configuring the mesh
 *  workloads.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_ConfigApi_ConfigApiGateway Use the K8s
 *        Gateway API for configuration. (Value: "CONFIG_API_GATEWAY")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_ConfigApi_ConfigApiIstio Use the Istio
 *        API for configuration. (Value: "CONFIG_API_ISTIO")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_ConfigApi_ConfigApiUnspecified
 *        Unspecified (Value: "CONFIG_API_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *configApi;

/**
 *  Deprecated: use `management` instead Enables automatic control plane
 *  management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_ControlPlane_Automatic Google should
 *        provision a control plane revision and make it available in the
 *        cluster. Google will enroll this revision in a release channel and
 *        keep it up to date. The control plane revision may be a managed
 *        service, or a managed install. (Value: "AUTOMATIC")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_ControlPlane_ControlPlaneManagementUnspecified
 *        Unspecified (Value: "CONTROL_PLANE_MANAGEMENT_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_ControlPlane_Manual User will manually
 *        configure the control plane (e.g. via CLI, or via the
 *        ControlPlaneRevision KRM API) (Value: "MANUAL")
 */
@property(nonatomic, copy, nullable) NSString *controlPlane GTLR_DEPRECATED;

/**
 *  Determines which release channel to use for default injection and service
 *  mesh APIs.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_ChannelUnspecified
 *        Unspecified (Value: "CHANNEL_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_Rapid RAPID channel is
 *        offered on an early access basis for customers who want to test new
 *        releases. (Value: "RAPID")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_Regular REGULAR channel
 *        is intended for production users who want to take advantage of new
 *        features. (Value: "REGULAR")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_DefaultChannel_Stable STABLE channel
 *        includes versions that are known to be stable and reliable in
 *        production. (Value: "STABLE")
 */
@property(nonatomic, copy, nullable) NSString *defaultChannel GTLR_DEPRECATED;

/**
 *  Optional. Enables automatic Service Mesh management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_Management_ManagementAutomatic Google
 *        should manage my Service Mesh for the cluster. (Value:
 *        "MANAGEMENT_AUTOMATIC")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_Management_ManagementManual User will
 *        manually configure their service mesh components. (Value:
 *        "MANAGEMENT_MANUAL")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_Management_ManagementNotInstalled
 *        Google should remove any managed Service Mesh components from this
 *        cluster and deprovision any resources. (Value:
 *        "MANAGEMENT_NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshSpec_Management_ManagementUnspecified
 *        Unspecified. (Value: "MANAGEMENT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *management;

@end


/**
 *  **Service Mesh**: State for a single Membership, as analyzed by the Service
 *  Mesh Hub Controller.
 */
@interface GTLRGKEHub_ServiceMeshState : GTLRObject

/** Output only. Results of running Service Mesh analyzers. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshAnalysisMessage *> *analysisMessages;

/** Output only. List of conditions reported for this membership. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshCondition *> *conditions;

/**
 *  The API version (i.e. Istio CRD version) for configuring service mesh in
 *  this cluster. This version is influenced by the `default_channel` field.
 */
@property(nonatomic, copy, nullable) NSString *configApiVersion;

/** Output only. Status of control plane management */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshControlPlaneManagement *controlPlaneManagement;

/** Output only. Status of data plane management. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshDataPlaneManagement *dataPlaneManagement;

@end


/**
 *  Structured and human-readable details for a status.
 */
@interface GTLRGKEHub_ServiceMeshStatusDetails : GTLRObject

/** A machine-readable code that further describes a broad status. */
@property(nonatomic, copy, nullable) NSString *code;

/** Human-readable explanation of code. */
@property(nonatomic, copy, nullable) NSString *details;

@end


/**
 *  A unique identifier for the type of message. Display_name is intended to be
 *  human-readable, code is intended to be machine readable. There should be a
 *  one-to-one mapping between display_name and code. (i.e. do not re-use
 *  display_names or codes between message types.) See
 *  istio.analysis.v1alpha1.AnalysisMessageBase.Type
 */
@interface GTLRGKEHub_ServiceMeshType : GTLRObject

/**
 *  A 7 character code matching `^IST[0-9]{4}$` or `^ASM[0-9]{4}$`, intended to
 *  uniquely identify the message type. (e.g. "IST0001" is mapped to the
 *  "InternalError" message type.)
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  A human-readable name for the message type. e.g. "InternalError",
 *  "PodMissingProxy". This should be the same for all messages of the same
 *  type. (This corresponds to the `name` field in open-source Istio.)
 */
@property(nonatomic, copy, nullable) NSString *displayName;

@end


/**
 *  High-level state of a MembershipFeature.
 */
@interface GTLRGKEHub_State : GTLRObject

/**
 *  The high-level, machine-readable status of this MembershipFeature.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_State_Code_CodeUnspecified Unknown or not set. (Value:
 *        "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_State_Code_Error The MembershipFeature is not
 *        operating or is in a severely degraded state. The MembershipFeature
 *        may need intervention to return to normal operation. See the
 *        description and any associated MembershipFeature-specific details for
 *        more information. (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_State_Code_Ok The MembershipFeature is operating
 *        normally. (Value: "OK")
 *    @arg @c kGTLRGKEHub_State_Code_Warning The MembershipFeature has
 *        encountered an issue, and is operating in a degraded state. The
 *        MembershipFeature may need intervention to return to normal operation.
 *        See the description and any associated MembershipFeature-specific
 *        details for more information. (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  A human-readable description of the current status.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The time this status and any related Feature-specific details were updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  **WorkloadCertificate**: The membership-specific input for
 *  WorkloadCertificate feature.
 */
@interface GTLRGKEHub_WorkloadCertificateSpec : GTLRObject

/**
 *  CertificateManagement specifies workload certificate management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_WorkloadCertificateSpec_CertificateManagement_CertificateManagementUnspecified
 *        Disable workload certificate feature. (Value:
 *        "CERTIFICATE_MANAGEMENT_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_WorkloadCertificateSpec_CertificateManagement_Disabled
 *        Disable workload certificate feature. (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_WorkloadCertificateSpec_CertificateManagement_Enabled
 *        Enable workload certificate feature. (Value: "ENABLED")
 */
@property(nonatomic, copy, nullable) NSString *certificateManagement;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
