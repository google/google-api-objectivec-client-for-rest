// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   GKE Hub API (gkehub/v1)
// Documentation:
//   https://cloud.google.com/anthos/multicluster-management/connect/registering-a-cluster

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRGKEHub_AppDevExperienceFeatureSpec;
@class GTLRGKEHub_AppDevExperienceFeatureState;
@class GTLRGKEHub_ApplianceCluster;
@class GTLRGKEHub_AuditConfig;
@class GTLRGKEHub_AuditLogConfig;
@class GTLRGKEHub_Authority;
@class GTLRGKEHub_BinaryAuthorizationConfig;
@class GTLRGKEHub_Binding;
@class GTLRGKEHub_ClusterUpgradeFleetSpec;
@class GTLRGKEHub_ClusterUpgradeFleetState;
@class GTLRGKEHub_ClusterUpgradeFleetState_Ignored;
@class GTLRGKEHub_ClusterUpgradeGKEUpgrade;
@class GTLRGKEHub_ClusterUpgradeGKEUpgradeFeatureCondition;
@class GTLRGKEHub_ClusterUpgradeGKEUpgradeFeatureState;
@class GTLRGKEHub_ClusterUpgradeGKEUpgradeOverride;
@class GTLRGKEHub_ClusterUpgradeGKEUpgradeState;
@class GTLRGKEHub_ClusterUpgradeGKEUpgradeState_Stats;
@class GTLRGKEHub_ClusterUpgradeIgnoredMembership;
@class GTLRGKEHub_ClusterUpgradeMembershipGKEUpgradeState;
@class GTLRGKEHub_ClusterUpgradeMembershipState;
@class GTLRGKEHub_ClusterUpgradePostConditions;
@class GTLRGKEHub_ClusterUpgradeUpgradeStatus;
@class GTLRGKEHub_CommonFeatureSpec;
@class GTLRGKEHub_CommonFeatureState;
@class GTLRGKEHub_CommonFleetDefaultMemberConfigSpec;
@class GTLRGKEHub_ConfigManagementConfigSync;
@class GTLRGKEHub_ConfigManagementConfigSyncDeploymentState;
@class GTLRGKEHub_ConfigManagementConfigSyncError;
@class GTLRGKEHub_ConfigManagementConfigSyncState;
@class GTLRGKEHub_ConfigManagementConfigSyncVersion;
@class GTLRGKEHub_ConfigManagementErrorResource;
@class GTLRGKEHub_ConfigManagementGatekeeperDeploymentState;
@class GTLRGKEHub_ConfigManagementGitConfig;
@class GTLRGKEHub_ConfigManagementGroupVersionKind;
@class GTLRGKEHub_ConfigManagementHierarchyControllerConfig;
@class GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState;
@class GTLRGKEHub_ConfigManagementHierarchyControllerState;
@class GTLRGKEHub_ConfigManagementHierarchyControllerVersion;
@class GTLRGKEHub_ConfigManagementInstallError;
@class GTLRGKEHub_ConfigManagementMembershipSpec;
@class GTLRGKEHub_ConfigManagementMembershipState;
@class GTLRGKEHub_ConfigManagementOciConfig;
@class GTLRGKEHub_ConfigManagementOperatorState;
@class GTLRGKEHub_ConfigManagementPolicyController;
@class GTLRGKEHub_ConfigManagementPolicyControllerMigration;
@class GTLRGKEHub_ConfigManagementPolicyControllerMonitoring;
@class GTLRGKEHub_ConfigManagementPolicyControllerState;
@class GTLRGKEHub_ConfigManagementPolicyControllerVersion;
@class GTLRGKEHub_ConfigManagementSyncError;
@class GTLRGKEHub_ConfigManagementSyncState;
@class GTLRGKEHub_ConnectAgentResource;
@class GTLRGKEHub_DataplaneV2FeatureSpec;
@class GTLRGKEHub_DefaultClusterConfig;
@class GTLRGKEHub_EdgeCluster;
@class GTLRGKEHub_Expr;
@class GTLRGKEHub_Feature;
@class GTLRGKEHub_Feature_Labels;
@class GTLRGKEHub_Feature_MembershipSpecs;
@class GTLRGKEHub_Feature_MembershipStates;
@class GTLRGKEHub_Feature_ScopeSpecs;
@class GTLRGKEHub_Feature_ScopeStates;
@class GTLRGKEHub_FeatureResourceState;
@class GTLRGKEHub_FeatureState;
@class GTLRGKEHub_Fleet;
@class GTLRGKEHub_Fleet_Labels;
@class GTLRGKEHub_FleetLifecycleState;
@class GTLRGKEHub_FleetObservabilityFeatureError;
@class GTLRGKEHub_FleetObservabilityFeatureSpec;
@class GTLRGKEHub_FleetObservabilityFeatureState;
@class GTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState;
@class GTLRGKEHub_FleetObservabilityFleetObservabilityLoggingState;
@class GTLRGKEHub_FleetObservabilityFleetObservabilityMonitoringState;
@class GTLRGKEHub_FleetObservabilityLoggingConfig;
@class GTLRGKEHub_FleetObservabilityMembershipSpec;
@class GTLRGKEHub_FleetObservabilityMembershipState;
@class GTLRGKEHub_FleetObservabilityRoutingConfig;
@class GTLRGKEHub_GkeCluster;
@class GTLRGKEHub_GoogleRpcStatus;
@class GTLRGKEHub_GoogleRpcStatus_Details_Item;
@class GTLRGKEHub_IdentityServiceAuthMethod;
@class GTLRGKEHub_IdentityServiceAzureADConfig;
@class GTLRGKEHub_IdentityServiceGoogleConfig;
@class GTLRGKEHub_IdentityServiceGroupConfig;
@class GTLRGKEHub_IdentityServiceLdapConfig;
@class GTLRGKEHub_IdentityServiceMembershipSpec;
@class GTLRGKEHub_IdentityServiceMembershipState;
@class GTLRGKEHub_IdentityServiceOidcConfig;
@class GTLRGKEHub_IdentityServiceSamlConfig;
@class GTLRGKEHub_IdentityServiceSamlConfig_AttributeMapping;
@class GTLRGKEHub_IdentityServiceServerConfig;
@class GTLRGKEHub_IdentityServiceServiceAccountConfig;
@class GTLRGKEHub_IdentityServiceSimpleBindCredentials;
@class GTLRGKEHub_IdentityServiceUserConfig;
@class GTLRGKEHub_KubernetesMetadata;
@class GTLRGKEHub_KubernetesResource;
@class GTLRGKEHub_Location;
@class GTLRGKEHub_Location_Labels;
@class GTLRGKEHub_Location_Metadata;
@class GTLRGKEHub_Membership;
@class GTLRGKEHub_Membership_Labels;
@class GTLRGKEHub_MembershipBinding;
@class GTLRGKEHub_MembershipBinding_Labels;
@class GTLRGKEHub_MembershipBindingLifecycleState;
@class GTLRGKEHub_MembershipEndpoint;
@class GTLRGKEHub_MembershipFeatureSpec;
@class GTLRGKEHub_MembershipFeatureState;
@class GTLRGKEHub_MembershipState;
@class GTLRGKEHub_MonitoringConfig;
@class GTLRGKEHub_MultiCloudCluster;
@class GTLRGKEHub_MultiClusterIngressFeatureSpec;
@class GTLRGKEHub_Namespace;
@class GTLRGKEHub_Namespace_Labels;
@class GTLRGKEHub_Namespace_NamespaceLabels;
@class GTLRGKEHub_NamespaceLifecycleState;
@class GTLRGKEHub_OnPremCluster;
@class GTLRGKEHub_Operation;
@class GTLRGKEHub_Operation_Metadata;
@class GTLRGKEHub_Operation_Response;
@class GTLRGKEHub_Origin;
@class GTLRGKEHub_Policy;
@class GTLRGKEHub_PolicyBinding;
@class GTLRGKEHub_PolicyControllerBundleInstallSpec;
@class GTLRGKEHub_PolicyControllerHubConfig;
@class GTLRGKEHub_PolicyControllerHubConfig_DeploymentConfigs;
@class GTLRGKEHub_PolicyControllerMembershipSpec;
@class GTLRGKEHub_PolicyControllerMembershipState;
@class GTLRGKEHub_PolicyControllerMembershipState_ComponentStates;
@class GTLRGKEHub_PolicyControllerMonitoringConfig;
@class GTLRGKEHub_PolicyControllerOnClusterState;
@class GTLRGKEHub_PolicyControllerPolicyContentSpec;
@class GTLRGKEHub_PolicyControllerPolicyContentSpec_Bundles;
@class GTLRGKEHub_PolicyControllerPolicyContentState;
@class GTLRGKEHub_PolicyControllerPolicyContentState_BundleStates;
@class GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig;
@class GTLRGKEHub_PolicyControllerResourceList;
@class GTLRGKEHub_PolicyControllerResourceRequirements;
@class GTLRGKEHub_PolicyControllerTemplateLibraryConfig;
@class GTLRGKEHub_PolicyControllerToleration;
@class GTLRGKEHub_RBACRoleBinding;
@class GTLRGKEHub_RBACRoleBinding_Labels;
@class GTLRGKEHub_RBACRoleBindingLifecycleState;
@class GTLRGKEHub_ResourceManifest;
@class GTLRGKEHub_ResourceOptions;
@class GTLRGKEHub_Role;
@class GTLRGKEHub_Scope;
@class GTLRGKEHub_Scope_Labels;
@class GTLRGKEHub_Scope_NamespaceLabels;
@class GTLRGKEHub_ScopeFeatureSpec;
@class GTLRGKEHub_ScopeFeatureState;
@class GTLRGKEHub_ScopeLifecycleState;
@class GTLRGKEHub_SecurityPostureConfig;
@class GTLRGKEHub_ServiceMeshCondition;
@class GTLRGKEHub_ServiceMeshControlPlaneManagement;
@class GTLRGKEHub_ServiceMeshDataPlaneManagement;
@class GTLRGKEHub_ServiceMeshMembershipSpec;
@class GTLRGKEHub_ServiceMeshMembershipState;
@class GTLRGKEHub_ServiceMeshStatusDetails;
@class GTLRGKEHub_Status;
@class GTLRGKEHub_TypeMeta;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRGKEHub_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_BinaryAuthorizationConfig.evaluationMode

/**
 *  Disable BinaryAuthorization
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_BinaryAuthorizationConfig_EvaluationMode_Disabled;
/**
 *  Default value
 *
 *  Value: "EVALUATION_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_BinaryAuthorizationConfig_EvaluationMode_EvaluationModeUnspecified;
/**
 *  Use Binary Authorization with the policies specified in policy_bindings.
 *
 *  Value: "POLICY_BINDINGS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_BinaryAuthorizationConfig_EvaluationMode_PolicyBindings;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ClusterUpgradeUpgradeStatus.code

/**
 *  Required by https://linter.aip.dev/126/unspecified.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_CodeUnspecified;
/**
 *  The upgrade has passed all post conditions (soaking). At the scope level,
 *  this means all eligible clusters are in COMPLETE status.
 *
 *  Value: "COMPLETE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Complete;
/**
 *  A cluster will be forced to enter soaking if an upgrade doesn't finish
 *  within a certain limit, despite it's actual status.
 *
 *  Value: "FORCED_SOAKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_ForcedSoaking;
/**
 *  The upgrade is ineligible. At the scope level, this means the upgrade is
 *  ineligible for all the clusters in the scope.
 *
 *  Value: "INELIGIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Ineligible;
/**
 *  The upgrade is in progress. At the scope level, this means the upgrade is in
 *  progress for at least one cluster in the scope.
 *
 *  Value: "IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_InProgress;
/**
 *  The upgrade is pending. At the scope level, this means the upgrade is
 *  pending for all the clusters in the scope.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Pending;
/**
 *  The upgrade has finished and is soaking until the soaking time is up. At the
 *  scope level, this means at least one cluster is in soaking while the rest
 *  are either soaking or complete.
 *
 *  Value: "SOAKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Soaking;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.admissionWebhook

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.gitSync

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.importer

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.monitor

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.reconcilerManager

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.rootReconciler

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncDeploymentState.syncer

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.reposyncCrd

/**
 *  CRD's state cannot be determined
 *
 *  Value: "CRD_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_CrdStateUnspecified;
/**
 *  CRD is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installed;
/**
 *  CRD is installing
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installing;
/**
 *  CRD is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_NotInstalled;
/**
 *  CRD is terminating (i.e., it has been deleted and is cleaning up)
 *
 *  Value: "TERMINATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Terminating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.rootsyncCrd

/**
 *  CRD's state cannot be determined
 *
 *  Value: "CRD_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_CrdStateUnspecified;
/**
 *  CRD is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installed;
/**
 *  CRD is installing
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installing;
/**
 *  CRD is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_NotInstalled;
/**
 *  CRD is terminating (i.e., it has been deleted and is cleaning up)
 *
 *  Value: "TERMINATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Terminating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementConfigSyncState.state

/**
 *  CS encounters errors.
 *
 *  Value: "CONFIG_SYNC_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncError;
/**
 *  The expected CS version is installed successfully.
 *
 *  Value: "CONFIG_SYNC_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncInstalled;
/**
 *  CS is not installed.
 *
 *  Value: "CONFIG_SYNC_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncNotInstalled;
/**
 *  CS is installing or terminating.
 *
 *  Value: "CONFIG_SYNC_PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncPending;
/**
 *  CS's state cannot be determined.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementConfigSyncState_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementGatekeeperDeploymentState.gatekeeperAudit

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementGatekeeperDeploymentState.gatekeeperControllerManagerState

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementGatekeeperDeploymentState.gatekeeperMutation

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState.extension

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState.hnc

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementMembershipSpec.management

/**
 *  Google will manage the Feature for the cluster.
 *
 *  Value: "MANAGEMENT_AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementMembershipSpec_Management_ManagementAutomatic;
/**
 *  User will manually manage the Feature for the cluster.
 *
 *  Value: "MANAGEMENT_MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementMembershipSpec_Management_ManagementManual;
/**
 *  Unspecified
 *
 *  Value: "MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementMembershipSpec_Management_ManagementUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementOperatorState.deploymentState

/**
 *  Deployment's state cannot be determined
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_DeploymentStateUnspecified;
/**
 *  Deployment was attempted to be installed, but has errors
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Error;
/**
 *  Deployment is installed
 *
 *  Value: "INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Installed;
/**
 *  Deployment is not installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_NotInstalled;
/**
 *  Deployment is installing or terminating
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Pending;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementPolicyControllerMigration.stage

/**
 *  ACM Hub/Operator manages policycontroller. No migration yet completed.
 *
 *  Value: "ACM_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_AcmManaged;
/**
 *  All migrations steps complete; Poco Hub now manages policycontroller.
 *
 *  Value: "POCO_MANAGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_PocoManaged;
/**
 *  Unknown state of migration.
 *
 *  Value: "STAGE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_StageUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementPolicyControllerMonitoring.backends

/**
 *  Stackdriver/Cloud Monitoring backend for monitoring
 *
 *  Value: "CLOUD_MONITORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMonitoring_Backends_CloudMonitoring;
/**
 *  Backend cannot be determined
 *
 *  Value: "MONITORING_BACKEND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMonitoring_Backends_MonitoringBackendUnspecified;
/**
 *  Prometheus backend for monitoring
 *
 *  Value: "PROMETHEUS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementPolicyControllerMonitoring_Backends_Prometheus;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ConfigManagementSyncState.code

/**
 *  Indicates an error configuring Config Sync, and user action is required
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Error;
/**
 *  Config Sync has been installed but not configured
 *
 *  Value: "NOT_CONFIGURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_NotConfigured;
/**
 *  Config Sync has not been installed
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_NotInstalled;
/**
 *  Config Sync is in the progress of syncing a new change
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Pending;
/**
 *  Config Sync cannot determine a sync code
 *
 *  Value: "SYNC_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_SyncCodeUnspecified;
/**
 *  Config Sync successfully synced the git Repo with the cluster
 *
 *  Value: "SYNCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Synced;
/**
 *  Error authorizing with the cluster
 *
 *  Value: "UNAUTHORIZED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Unauthorized;
/**
 *  Cluster could not be reached
 *
 *  Value: "UNREACHABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ConfigManagementSyncState_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRGKEHub_FeatureResourceState.state

/**
 *  The Feature is enabled in this Hub, and the Feature resource is fully
 *  available.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureResourceState_State_Active;
/**
 *  The Feature is being disabled in this Hub, and the Feature resource is being
 *  deleted.
 *
 *  Value: "DISABLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureResourceState_State_Disabling;
/**
 *  The Feature is being enabled, and the Feature resource is being created.
 *  Once complete, the corresponding Feature will be enabled in this Hub.
 *
 *  Value: "ENABLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureResourceState_State_Enabling;
/**
 *  The Feature resource is being updated by the Hub Service.
 *
 *  Value: "SERVICE_UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureResourceState_State_ServiceUpdating;
/**
 *  State is unknown or not set.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureResourceState_State_StateUnspecified;
/**
 *  The Feature resource is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureResourceState_State_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_FeatureState.code

/**
 *  Unknown or not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureState_Code_CodeUnspecified;
/**
 *  The Feature is not operating or is in a severely degraded state. The Feature
 *  may need intervention to return to normal operation. See the description and
 *  any associated Feature-specific details for more information.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureState_Code_Error;
/**
 *  The Feature is operating normally.
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureState_Code_Ok;
/**
 *  The Feature has encountered an issue, and is operating in a degraded state.
 *  The Feature may need intervention to return to normal operation. See the
 *  description and any associated Feature-specific details for more
 *  information.
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FeatureState_Code_Warning;

// ----------------------------------------------------------------------------
// GTLRGKEHub_FleetLifecycleState.code

/**
 *  The code is not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetLifecycleState_Code_CodeUnspecified;
/**
 *  The fleet is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetLifecycleState_Code_Creating;
/**
 *  The fleet is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetLifecycleState_Code_Deleting;
/**
 *  The fleet active.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetLifecycleState_Code_Ready;
/**
 *  The fleet is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetLifecycleState_Code_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState.code

/**
 *  Unknown or not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState_Code_CodeUnspecified;
/**
 *  The Feature is encountering errors in the reconciliation. The Feature may
 *  need intervention to return to normal operation. See the description and any
 *  associated Feature-specific details for more information.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState_Code_Error;
/**
 *  The Feature is operating normally.
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState_Code_Ok;

// ----------------------------------------------------------------------------
// GTLRGKEHub_FleetObservabilityRoutingConfig.mode

/**
 *  logs will be copied to the destination project.
 *
 *  Value: "COPY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetObservabilityRoutingConfig_Mode_Copy;
/**
 *  If UNSPECIFIED, fleet logging feature is disabled.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetObservabilityRoutingConfig_Mode_ModeUnspecified;
/**
 *  logs will be moved to the destination project.
 *
 *  Value: "MOVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_FleetObservabilityRoutingConfig_Mode_Move;

// ----------------------------------------------------------------------------
// GTLRGKEHub_IdentityServiceMembershipState.state

/**
 *  Unspecified state
 *
 *  Value: "DEPLOYMENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_IdentityServiceMembershipState_State_DeploymentStateUnspecified;
/**
 *  Failure with error.
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_IdentityServiceMembershipState_State_Error;
/**
 *  deployment succeeds
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_IdentityServiceMembershipState_State_Ok;

// ----------------------------------------------------------------------------
// GTLRGKEHub_MembershipBindingLifecycleState.code

/**
 *  The code is not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipBindingLifecycleState_Code_CodeUnspecified;
/**
 *  The membershipbinding is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipBindingLifecycleState_Code_Creating;
/**
 *  The membershipbinding is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipBindingLifecycleState_Code_Deleting;
/**
 *  The membershipbinding active.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipBindingLifecycleState_Code_Ready;
/**
 *  The membershipbinding is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipBindingLifecycleState_Code_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_MembershipState.code

/**
 *  The code is not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipState_Code_CodeUnspecified;
/**
 *  The cluster is being registered.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipState_Code_Creating;
/**
 *  The cluster is being unregistered.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipState_Code_Deleting;
/**
 *  The cluster is registered.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipState_Code_Ready;
/**
 *  The Membership is being updated by the Hub Service.
 *
 *  Value: "SERVICE_UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipState_Code_ServiceUpdating;
/**
 *  The Membership is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_MembershipState_Code_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_NamespaceLifecycleState.code

/**
 *  The code is not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_NamespaceLifecycleState_Code_CodeUnspecified;
/**
 *  The namespace is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_NamespaceLifecycleState_Code_Creating;
/**
 *  The namespace is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_NamespaceLifecycleState_Code_Deleting;
/**
 *  The namespace active.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_NamespaceLifecycleState_Code_Ready;
/**
 *  The namespace is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_NamespaceLifecycleState_Code_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_OnPremCluster.clusterType

/**
 *  The ClusterType is bootstrap cluster.
 *
 *  Value: "BOOTSTRAP"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_OnPremCluster_ClusterType_Bootstrap;
/**
 *  The ClusterType is not set.
 *
 *  Value: "CLUSTERTYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_OnPremCluster_ClusterType_ClustertypeUnspecified;
/**
 *  The ClusterType is baremetal hybrid cluster.
 *
 *  Value: "HYBRID"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_OnPremCluster_ClusterType_Hybrid;
/**
 *  The ClusterType is baremetal standalone cluster.
 *
 *  Value: "STANDALONE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_OnPremCluster_ClusterType_Standalone;
/**
 *  The ClusterType is user cluster.
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_OnPremCluster_ClusterType_User;

// ----------------------------------------------------------------------------
// GTLRGKEHub_Origin.type

/**
 *  Per-Membership spec was inherited from the fleet-level default.
 *
 *  Value: "FLEET"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_Fleet;
/**
 *  Per-Membership spec was inherited from the fleet-level default but is now
 *  out of sync with the current default.
 *
 *  Value: "FLEET_OUT_OF_SYNC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_FleetOutOfSync;
/**
 *  Type is unknown or not set.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_TypeUnspecified;
/**
 *  Per-Membership spec was inherited from a user specification.
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Origin_Type_User;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerHubConfig.installSpec

/**
 *  Request to stop all reconciliation actions by PoCo Hub controller. This is a
 *  breakglass mechanism to stop PoCo Hub from affecting cluster resources.
 *
 *  Value: "INSTALL_SPEC_DETACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecDetached;
/**
 *  Request to install and enable Policy Controller.
 *
 *  Value: "INSTALL_SPEC_ENABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecEnabled;
/**
 *  Request to uninstall Policy Controller.
 *
 *  Value: "INSTALL_SPEC_NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecNotInstalled;
/**
 *  Request to suspend Policy Controller i.e. its webhooks. If Policy Controller
 *  is not installed, it will be installed but suspended.
 *
 *  Value: "INSTALL_SPEC_SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecSuspended;
/**
 *  Spec is unknown.
 *
 *  Value: "INSTALL_SPEC_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerMembershipState.state

/**
 *  The PC is fully installed on the cluster and in an operational mode. In this
 *  state PCH will be reconciling state with the PC, and the PC will be
 *  performing it's operational tasks per that software. Entering a READY state
 *  requires that the hub has confirmed the PC is installed and its pods are
 *  operational with the version of the PC the PCH expects.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_Active;
/**
 *  The PC is not operational, and the PCH is unable to act to make it
 *  operational. Entering a CLUSTER_ERROR state happens automatically when the
 *  PCH determines that a PC installed on the cluster is non-operative or that
 *  the cluster does not meet requirements set for the PCH to administer the
 *  cluster but has nevertheless been given an instruction to do so (such as
 *  'install').
 *
 *  Value: "CLUSTER_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_ClusterError;
/**
 *  The PC may have resources on the cluster, but the PCH wishes to remove the
 *  Membership. The Membership still exists.
 *
 *  Value: "DECOMMISSIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_Decommissioning;
/**
 *  PoCo Hub is not taking any action to reconcile cluster objects. Changes to
 *  those objects will not be overwritten by PoCo Hub.
 *
 *  Value: "DETACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_Detached;
/**
 *  In this state, the PC may still be operational, and only the PCH is unable
 *  to act. The hub should not issue instructions to change the PC state, or
 *  otherwise interfere with the on-cluster resources. Entering a HUB_ERROR
 *  state happens automatically when the PCH determines the hub is in an
 *  unhealthy state and it wishes to 'take hands off' to avoid corrupting the PC
 *  or other data.
 *
 *  Value: "HUB_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_HubError;
/**
 *  The PCH possesses a Membership, however the PC is not fully installed on the
 *  cluster. In this state the hub can be expected to be taking actions to
 *  install the PC on the cluster.
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_Installing;
/**
 *  The lifecycle state is unspecified.
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_LifecycleStateUnspecified;
/**
 *  The PC does not exist on the given cluster, and no k8s resources of any type
 *  that are associated with the PC should exist there. The cluster does not
 *  possess a membership with the PCH.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_NotInstalled;
/**
 *  Policy Controller (PC) is installed but suspended. This means that the
 *  policies are not enforced, but violations are still recorded (through
 *  audit).
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_Suspended;
/**
 *  The PC is fully installed, but in the process of changing the configuration
 *  (including changing the version of PC either up and down, or modifying the
 *  manifests of PC) of the resources running on the cluster. The PCH has a
 *  Membership, is aware of the version the cluster should be running in, but
 *  has not confirmed for itself that the PC is running with that version.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMembershipState_State_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerMonitoringConfig.backends

/**
 *  Stackdriver/Cloud Monitoring backend for monitoring
 *
 *  Value: "CLOUD_MONITORING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMonitoringConfig_Backends_CloudMonitoring;
/**
 *  Backend cannot be determined
 *
 *  Value: "MONITORING_BACKEND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMonitoringConfig_Backends_MonitoringBackendUnspecified;
/**
 *  Prometheus backend for monitoring
 *
 *  Value: "PROMETHEUS"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerMonitoringConfig_Backends_Prometheus;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerOnClusterState.state

/**
 *  The PC is fully installed on the cluster and in an operational mode. In this
 *  state PCH will be reconciling state with the PC, and the PC will be
 *  performing it's operational tasks per that software. Entering a READY state
 *  requires that the hub has confirmed the PC is installed and its pods are
 *  operational with the version of the PC the PCH expects.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Active;
/**
 *  The PC is not operational, and the PCH is unable to act to make it
 *  operational. Entering a CLUSTER_ERROR state happens automatically when the
 *  PCH determines that a PC installed on the cluster is non-operative or that
 *  the cluster does not meet requirements set for the PCH to administer the
 *  cluster but has nevertheless been given an instruction to do so (such as
 *  'install').
 *
 *  Value: "CLUSTER_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_ClusterError;
/**
 *  The PC may have resources on the cluster, but the PCH wishes to remove the
 *  Membership. The Membership still exists.
 *
 *  Value: "DECOMMISSIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Decommissioning;
/**
 *  PoCo Hub is not taking any action to reconcile cluster objects. Changes to
 *  those objects will not be overwritten by PoCo Hub.
 *
 *  Value: "DETACHED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Detached;
/**
 *  In this state, the PC may still be operational, and only the PCH is unable
 *  to act. The hub should not issue instructions to change the PC state, or
 *  otherwise interfere with the on-cluster resources. Entering a HUB_ERROR
 *  state happens automatically when the PCH determines the hub is in an
 *  unhealthy state and it wishes to 'take hands off' to avoid corrupting the PC
 *  or other data.
 *
 *  Value: "HUB_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_HubError;
/**
 *  The PCH possesses a Membership, however the PC is not fully installed on the
 *  cluster. In this state the hub can be expected to be taking actions to
 *  install the PC on the cluster.
 *
 *  Value: "INSTALLING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Installing;
/**
 *  The lifecycle state is unspecified.
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_LifecycleStateUnspecified;
/**
 *  The PC does not exist on the given cluster, and no k8s resources of any type
 *  that are associated with the PC should exist there. The cluster does not
 *  possess a membership with the PCH.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_NotInstalled;
/**
 *  Policy Controller (PC) is installed but suspended. This means that the
 *  policies are not enforced, but violations are still recorded (through
 *  audit).
 *
 *  Value: "SUSPENDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Suspended;
/**
 *  The PC is fully installed, but in the process of changing the configuration
 *  (including changing the version of PC either up and down, or modifying the
 *  manifests of PC) of the resources running on the cluster. The PCH has a
 *  Membership, is aware of the version the cluster should be running in, but
 *  has not confirmed for itself that the PC is running with that version.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerOnClusterState_State_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig.podAffinity

/**
 *  No affinity configuration has been specified.
 *
 *  Value: "AFFINITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AffinityUnspecified;
/**
 *  Anti-affinity configuration will be applied to this deployment. Default for
 *  admissions deployment.
 *
 *  Value: "ANTI_AFFINITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AntiAffinity;
/**
 *  Affinity configurations will be removed from the deployment.
 *
 *  Value: "NO_AFFINITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_NoAffinity;

// ----------------------------------------------------------------------------
// GTLRGKEHub_PolicyControllerTemplateLibraryConfig.installation

/**
 *  Install the entire template library.
 *
 *  Value: "ALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_All;
/**
 *  No installation strategy has been specified.
 *
 *  Value: "INSTALLATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_InstallationUnspecified;
/**
 *  Do not install the template library.
 *
 *  Value: "NOT_INSTALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_NotInstalled;

// ----------------------------------------------------------------------------
// GTLRGKEHub_RBACRoleBindingLifecycleState.code

/**
 *  The code is not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_CodeUnspecified;
/**
 *  The rbacrolebinding is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Creating;
/**
 *  The rbacrolebinding is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Deleting;
/**
 *  The rbacrolebinding active.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Ready;
/**
 *  The rbacrolebinding is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_Role.predefinedRole

/**
 *  ADMIN has EDIT and RBAC permissions
 *
 *  Value: "ADMIN"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Role_PredefinedRole_Admin;
/**
 *  ANTHOS_SUPPORT gives Google Support read-only access to a number of cluster
 *  resources.
 *
 *  Value: "ANTHOS_SUPPORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Role_PredefinedRole_AnthosSupport;
/**
 *  EDIT can edit all resources except RBAC
 *
 *  Value: "EDIT"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Role_PredefinedRole_Edit;
/**
 *  UNKNOWN
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Role_PredefinedRole_Unknown;
/**
 *  VIEW can only read resources
 *
 *  Value: "VIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Role_PredefinedRole_View;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ScopeLifecycleState.code

/**
 *  The code is not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ScopeLifecycleState_Code_CodeUnspecified;
/**
 *  The scope is being created.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ScopeLifecycleState_Code_Creating;
/**
 *  The scope is being deleted.
 *
 *  Value: "DELETING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ScopeLifecycleState_Code_Deleting;
/**
 *  The scope active.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ScopeLifecycleState_Code_Ready;
/**
 *  The scope is being updated.
 *
 *  Value: "UPDATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ScopeLifecycleState_Code_Updating;

// ----------------------------------------------------------------------------
// GTLRGKEHub_SecurityPostureConfig.mode

/**
 *  Applies Security Posture features on the cluster.
 *
 *  Value: "BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_Mode_Basic;
/**
 *  Disables Security Posture features on the cluster.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_Mode_Disabled;
/**
 *  Default value not specified.
 *
 *  Value: "MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_Mode_ModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_SecurityPostureConfig.vulnerabilityMode

/**
 *  Applies basic vulnerability scanning on the cluster.
 *
 *  Value: "VULNERABILITY_BASIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityBasic;
/**
 *  Disables vulnerability scanning on the cluster.
 *
 *  Value: "VULNERABILITY_DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityDisabled;
/**
 *  Applies the Security Posture's vulnerability on cluster Enterprise level
 *  features.
 *
 *  Value: "VULNERABILITY_ENTERPRISE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityEnterprise;
/**
 *  Default value not specified.
 *
 *  Value: "VULNERABILITY_MODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshCondition.code

/**
 *  CNI config unsupported error code
 *
 *  Value: "CNI_CONFIG_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CniConfigUnsupported;
/**
 *  CNI installation failed error code
 *
 *  Value: "CNI_INSTALLATION_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CniInstallationFailed;
/**
 *  CNI pod unschedulable error code
 *
 *  Value: "CNI_POD_UNSCHEDULABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CniPodUnschedulable;
/**
 *  Default Unspecified code
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_CodeUnspecified;
/**
 *  GKE sandbox unsupported error code
 *
 *  Value: "GKE_SANDBOX_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_GkeSandboxUnsupported;
/**
 *  Mesh IAM permission denied error code
 *
 *  Value: "MESH_IAM_PERMISSION_DENIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_MeshIamPermissionDenied;
/**
 *  Nodepool workload identity federation required error code
 *
 *  Value: "NODEPOOL_WORKLOAD_IDENTITY_FEDERATION_REQUIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_NodepoolWorkloadIdentityFederationRequired;
/**
 *  Multiple control planes unsupported error code
 *
 *  Value: "UNSUPPORTED_MULTIPLE_CONTROL_PLANES"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Code_UnsupportedMultipleControlPlanes;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshCondition.severity

/**
 *  Indicates an issue that prevents the mesh from operating correctly
 *
 *  Value: "ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_Error;
/**
 *  An informational message, not requiring any action
 *
 *  Value: "INFO"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_Info;
/**
 *  Unspecified severity
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_SeverityUnspecified;
/**
 *  Indicates a setting is likely wrong, but the mesh is still able to operate
 *
 *  Value: "WARNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshCondition_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshControlPlaneManagement.state

/**
 *  ACTIVE means that the component is ready for use.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Active;
/**
 *  DEGRADED means that the component is ready, but operating in a degraded
 *  state.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Degraded;
/**
 *  DISABLED means that the component is not enabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Disabled;
/**
 *  FAILED_PRECONDITION means that provisioning cannot proceed because of some
 *  characteristic of the member cluster.
 *
 *  Value: "FAILED_PRECONDITION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_FailedPrecondition;
/**
 *  Unspecified
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_LifecycleStateUnspecified;
/**
 *  NEEDS_ATTENTION means that the component is ready, but some user
 *  intervention is required. (For example that the user should migrate
 *  workloads to a new control plane revision.)
 *
 *  Value: "NEEDS_ATTENTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_NeedsAttention;
/**
 *  PROVISIONING means that provisioning is in progress.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Provisioning;
/**
 *  STALLED means that provisioning could not be done.
 *
 *  Value: "STALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Stalled;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshDataPlaneManagement.state

/**
 *  ACTIVE means that the component is ready for use.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Active;
/**
 *  DEGRADED means that the component is ready, but operating in a degraded
 *  state.
 *
 *  Value: "DEGRADED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Degraded;
/**
 *  DISABLED means that the component is not enabled.
 *
 *  Value: "DISABLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Disabled;
/**
 *  FAILED_PRECONDITION means that provisioning cannot proceed because of some
 *  characteristic of the member cluster.
 *
 *  Value: "FAILED_PRECONDITION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_FailedPrecondition;
/**
 *  Unspecified
 *
 *  Value: "LIFECYCLE_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_LifecycleStateUnspecified;
/**
 *  NEEDS_ATTENTION means that the component is ready, but some user
 *  intervention is required. (For example that the user should migrate
 *  workloads to a new control plane revision.)
 *
 *  Value: "NEEDS_ATTENTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_NeedsAttention;
/**
 *  PROVISIONING means that provisioning is in progress.
 *
 *  Value: "PROVISIONING"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Provisioning;
/**
 *  STALLED means that provisioning could not be done.
 *
 *  Value: "STALLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Stalled;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshMembershipSpec.controlPlane

/**
 *  Google should provision a control plane revision and make it available in
 *  the cluster. Google will enroll this revision in a release channel and keep
 *  it up to date. The control plane revision may be a managed service, or a
 *  managed install.
 *
 *  Value: "AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshMembershipSpec_ControlPlane_Automatic;
/**
 *  Unspecified
 *
 *  Value: "CONTROL_PLANE_MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshMembershipSpec_ControlPlane_ControlPlaneManagementUnspecified;
/**
 *  User will manually configure the control plane (e.g. via CLI, or via the
 *  ControlPlaneRevision KRM API)
 *
 *  Value: "MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshMembershipSpec_ControlPlane_Manual;

// ----------------------------------------------------------------------------
// GTLRGKEHub_ServiceMeshMembershipSpec.management

/**
 *  Google should manage my Service Mesh for the cluster.
 *
 *  Value: "MANAGEMENT_AUTOMATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshMembershipSpec_Management_ManagementAutomatic;
/**
 *  User will manually configure their service mesh components.
 *
 *  Value: "MANAGEMENT_MANUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshMembershipSpec_Management_ManagementManual;
/**
 *  Unspecified
 *
 *  Value: "MANAGEMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_ServiceMeshMembershipSpec_Management_ManagementUnspecified;

// ----------------------------------------------------------------------------
// GTLRGKEHub_Status.code

/**
 *  Not set.
 *
 *  Value: "CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Status_Code_CodeUnspecified;
/**
 *  AppDevExperienceFeature's specified subcomponent ready state is false. This
 *  means AppDevExperienceFeature has encountered an issue that blocks all, or a
 *  portion, of its normal operation. See the `description` for more details.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Status_Code_Failed;
/**
 *  AppDevExperienceFeature's specified subcomponent is ready.
 *
 *  Value: "OK"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Status_Code_Ok;
/**
 *  AppDevExperienceFeature's specified subcomponent has a pending or unknown
 *  state.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRGKEHub_Status_Code_Unknown;

/**
 *  Spec for App Dev Experience Feature.
 */
@interface GTLRGKEHub_AppDevExperienceFeatureSpec : GTLRObject
@end


/**
 *  State for App Dev Exp Feature.
 */
@interface GTLRGKEHub_AppDevExperienceFeatureState : GTLRObject

/** Status of subcomponent that detects configured Service Mesh resources. */
@property(nonatomic, strong, nullable) GTLRGKEHub_Status *networkingInstallSucceeded;

@end


/**
 *  ApplianceCluster contains information specific to GDC Edge Appliance
 *  Clusters.
 */
@interface GTLRGKEHub_ApplianceCluster : GTLRObject

/**
 *  Immutable. Self-link of the Google Cloud resource for the Appliance Cluster.
 *  For example:
 *  //transferappliance.googleapis.com/projects/my-project/locations/us-west1-a/appliances/my-appliance
 */
@property(nonatomic, copy, nullable) NSString *resourceLink;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts `jose\@example.com` from DATA_READ logging, and
 *  `aliya\@example.com` from DATA_WRITE logging.
 */
@interface GTLRGKEHub_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRGKEHub_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_AuditLogConfig_LogType_AdminRead Admin reads. Example:
 *        CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRGKEHub_AuditLogConfig_LogType_DataRead Data reads. Example:
 *        CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRGKEHub_AuditLogConfig_LogType_DataWrite Data writes. Example:
 *        CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRGKEHub_AuditLogConfig_LogType_LogTypeUnspecified Default
 *        case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Authority encodes how Google will recognize identities from this Membership.
 *  See the workload identity documentation for more details:
 *  https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
 */
@interface GTLRGKEHub_Authority : GTLRObject

/**
 *  Output only. An identity provider that reflects the `issuer` in the workload
 *  identity pool.
 */
@property(nonatomic, copy, nullable) NSString *identityProvider;

/**
 *  Optional. A JSON Web Token (JWT) issuer URI. `issuer` must start with
 *  `https://` and be a valid URL with length <2000 characters, it must use
 *  `location` rather than `zone` for GKE clusters. If set, then Google will
 *  allow valid OIDC tokens from this issuer to authenticate within the
 *  workload_identity_pool. OIDC discovery will be performed on this URI to
 *  validate tokens from the issuer. Clearing `issuer` disables Workload
 *  Identity. `issuer` cannot be directly modified; it must be cleared (and
 *  Workload Identity disabled) before using a new issuer (and re-enabling
 *  Workload Identity).
 */
@property(nonatomic, copy, nullable) NSString *issuer;

/**
 *  Optional. OIDC verification keys for this Membership in JWKS format (RFC
 *  7517). When this field is set, OIDC discovery will NOT be performed on
 *  `issuer`, and instead OIDC tokens will be validated using this field.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *oidcJwks;

/**
 *  Output only. The name of the workload identity pool in which `issuer` will
 *  be recognized. There is a single Workload Identity Pool per Hub that is
 *  shared between all Memberships that belong to that Hub. For a Hub hosted in
 *  {PROJECT_ID}, the workload pool format is `{PROJECT_ID}.hub.id.goog`,
 *  although this is subject to change in newer versions of this API.
 */
@property(nonatomic, copy, nullable) NSString *workloadIdentityPool;

@end


/**
 *  BinaryAuthorizationConfig defines the fleet level configuration of binary
 *  authorization feature.
 */
@interface GTLRGKEHub_BinaryAuthorizationConfig : GTLRObject

/**
 *  Optional. Mode of operation for binauthz policy evaluation.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_BinaryAuthorizationConfig_EvaluationMode_Disabled
 *        Disable BinaryAuthorization (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_BinaryAuthorizationConfig_EvaluationMode_EvaluationModeUnspecified
 *        Default value (Value: "EVALUATION_MODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_BinaryAuthorizationConfig_EvaluationMode_PolicyBindings
 *        Use Binary Authorization with the policies specified in
 *        policy_bindings. (Value: "POLICY_BINDINGS")
 */
@property(nonatomic, copy, nullable) NSString *evaluationMode;

/** Optional. Binauthz policies that apply to this cluster. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_PolicyBinding *> *policyBindings;

@end


/**
 *  Associates `members`, or principals, with a `role`.
 */
@interface GTLRGKEHub_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the principals in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Expr *condition;

/**
 *  Specifies the principals requesting access for a Google Cloud resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. Does
 *  not include identities that come from external identity providers (IdPs)
 *  through identity federation. * `user:{emailid}`: An email address that
 *  represents a specific Google account. For example, `alice\@example.com` . *
 *  `serviceAccount:{emailid}`: An email address that represents a Google
 *  service account. For example, `my-other-app\@appspot.gserviceaccount.com`. *
 *  `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
 *  identifier for a [Kubernetes service
 *  account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
 *  For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
 *  `group:{emailid}`: An email address that represents a Google group. For
 *  example, `admins\@example.com`. * `domain:{domain}`: The G Suite domain
 *  (primary) that represents all the users of that domain. For example,
 *  `google.com` or `example.com`. *
 *  `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workforce identity pool. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
 *  All workforce identities in a group. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All workforce identities with a specific attribute value. *
 *  `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/
 *  *`: All identities in a workforce identity pool. *
 *  `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
 *  A single identity in a workload identity pool. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
 *  A workload identity pool group. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
 *  All identities in a workload identity pool with a certain attribute. *
 *  `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/
 *  *`: All identities in a workload identity pool. *
 *  `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. *
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
 *  Deleted single identity in a workforce identity pool. For example,
 *  `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to the list of `members`, or principals. For example,
 *  `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM
 *  roles and permissions, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/roles-overview). For a list
 *  of the available pre-defined roles, see
 *  [here](https://cloud.google.com/iam/docs/understanding-roles).
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRGKEHub_CancelOperationRequest : GTLRObject
@end


/**
 *  **ClusterUpgrade**: The configuration for the fleet-level ClusterUpgrade
 *  feature.
 */
@interface GTLRGKEHub_ClusterUpgradeFleetSpec : GTLRObject

/** Allow users to override some properties of each GKE upgrade. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ClusterUpgradeGKEUpgradeOverride *> *gkeUpgradeOverrides;

/**
 *  Required. Post conditions to evaluate to mark an upgrade COMPLETE. Required.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradePostConditions *postConditions;

/**
 *  This fleet consumes upgrades that have COMPLETE status code in the upstream
 *  fleets. See UpgradeStatus.Code for code definitions. The fleet name should
 *  be either fleet project number or id. This is defined as repeated for future
 *  proof reasons. Initial implementation will enforce at most one upstream
 *  fleet.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *upstreamFleets;

@end


/**
 *  **ClusterUpgrade**: The state for the fleet-level ClusterUpgrade feature.
 */
@interface GTLRGKEHub_ClusterUpgradeFleetState : GTLRObject

/**
 *  This fleets whose upstream_fleets contain the current fleet. The fleet name
 *  should be either fleet project number or id.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *downstreamFleets;

/** Feature state for GKE clusters. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeGKEUpgradeFeatureState *gkeState;

/**
 *  A list of memberships ignored by the feature. For example, manually upgraded
 *  clusters can be ignored if they are newer than the default versions of its
 *  release channel. The membership resource is in the format:
 *  `projects/{p}/locations/{l}/membership/{m}`.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeFleetState_Ignored *ignored;

@end


/**
 *  A list of memberships ignored by the feature. For example, manually upgraded
 *  clusters can be ignored if they are newer than the default versions of its
 *  release channel. The membership resource is in the format:
 *  `projects/{p}/locations/{l}/membership/{m}`.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_ClusterUpgradeIgnoredMembership. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRGKEHub_ClusterUpgradeFleetState_Ignored : GTLRObject
@end


/**
 *  GKEUpgrade represents a GKE provided upgrade, e.g., control plane upgrade.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgrade : GTLRObject

/**
 *  Name of the upgrade, e.g., "k8s_control_plane". It should be a valid upgrade
 *  name. It must not exceet 99 characters.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Version of the upgrade, e.g., "1.22.1-gke.100". It should be a valid
 *  version. It must not exceet 99 characters.
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  GKEUpgradeFeatureCondition describes the condition of the feature for GKE
 *  clusters at a certain point of time.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgradeFeatureCondition : GTLRObject

/** Reason why the feature is in this status. */
@property(nonatomic, copy, nullable) NSString *reason;

/** Status of the condition, one of True, False, Unknown. */
@property(nonatomic, copy, nullable) NSString *status;

/** Type of the condition, for example, "ready". */
@property(nonatomic, copy, nullable) NSString *type;

/** Last timestamp the condition was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  GKEUpgradeFeatureState contains feature states for GKE clusters in the
 *  scope.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgradeFeatureState : GTLRObject

/** Current conditions of the feature. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ClusterUpgradeGKEUpgradeFeatureCondition *> *conditions;

/** Upgrade state. It will eventually replace `state`. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ClusterUpgradeGKEUpgradeState *> *upgradeState;

@end


/**
 *  Properties of a GKE upgrade that can be overridden by the user. For example,
 *  a user can skip soaking by overriding the soaking to 0.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgradeOverride : GTLRObject

/**
 *  Required. Post conditions to override for the specified upgrade (name +
 *  version). Required.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradePostConditions *postConditions;

/** Required. Which upgrade to override. Required. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeGKEUpgrade *upgrade;

@end


/**
 *  GKEUpgradeState is a GKEUpgrade and its state at the scope and fleet level.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgradeState : GTLRObject

/** Number of GKE clusters in each status code. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeGKEUpgradeState_Stats *stats;

/** Status of the upgrade. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeUpgradeStatus *status;

/** Which upgrade to track the state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeGKEUpgrade *upgrade;

@end


/**
 *  Number of GKE clusters in each status code.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of longLongValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_ClusterUpgradeGKEUpgradeState_Stats : GTLRObject
@end


/**
 *  IgnoredMembership represents a membership ignored by the feature. A
 *  membership can be ignored because it was manually upgraded to a newer
 *  version than RC default.
 */
@interface GTLRGKEHub_ClusterUpgradeIgnoredMembership : GTLRObject

/** Time when the membership was first set to ignored. */
@property(nonatomic, strong, nullable) GTLRDateTime *ignoredTime;

/** Reason why the membership is ignored. */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  ScopeGKEUpgradeState is a GKEUpgrade and its state per-membership.
 */
@interface GTLRGKEHub_ClusterUpgradeMembershipGKEUpgradeState : GTLRObject

/** Status of the upgrade. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeUpgradeStatus *status;

/** Which upgrade to track the state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeGKEUpgrade *upgrade;

@end


/**
 *  Per-membership state for this feature.
 */
@interface GTLRGKEHub_ClusterUpgradeMembershipState : GTLRObject

/**
 *  Whether this membership is ignored by the feature. For example, manually
 *  upgraded clusters can be ignored if they are newer than the default versions
 *  of its release channel.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeIgnoredMembership *ignored;

/** Actual upgrade state against desired. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ClusterUpgradeMembershipGKEUpgradeState *> *upgrades;

@end


/**
 *  Post conditional checks after an upgrade has been applied on all eligible
 *  clusters.
 */
@interface GTLRGKEHub_ClusterUpgradePostConditions : GTLRObject

/**
 *  Required. Amount of time to "soak" after a rollout has been finished before
 *  marking it COMPLETE. Cannot exceed 30 days. Required.
 */
@property(nonatomic, strong, nullable) GTLRDuration *soaking;

@end


/**
 *  UpgradeStatus provides status information for each upgrade.
 */
@interface GTLRGKEHub_ClusterUpgradeUpgradeStatus : GTLRObject

/**
 *  Status code of the upgrade.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_CodeUnspecified
 *        Required by https://linter.aip.dev/126/unspecified. (Value:
 *        "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Complete The upgrade
 *        has passed all post conditions (soaking). At the scope level, this
 *        means all eligible clusters are in COMPLETE status. (Value:
 *        "COMPLETE")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_ForcedSoaking A
 *        cluster will be forced to enter soaking if an upgrade doesn't finish
 *        within a certain limit, despite it's actual status. (Value:
 *        "FORCED_SOAKING")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Ineligible The
 *        upgrade is ineligible. At the scope level, this means the upgrade is
 *        ineligible for all the clusters in the scope. (Value: "INELIGIBLE")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_InProgress The
 *        upgrade is in progress. At the scope level, this means the upgrade is
 *        in progress for at least one cluster in the scope. (Value:
 *        "IN_PROGRESS")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Pending The upgrade
 *        is pending. At the scope level, this means the upgrade is pending for
 *        all the clusters in the scope. (Value: "PENDING")
 *    @arg @c kGTLRGKEHub_ClusterUpgradeUpgradeStatus_Code_Soaking The upgrade
 *        has finished and is soaking until the soaking time is up. At the scope
 *        level, this means at least one cluster is in soaking while the rest
 *        are either soaking or complete. (Value: "SOAKING")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** Reason for this status. */
@property(nonatomic, copy, nullable) NSString *reason;

/** Last timestamp the status was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  CommonFeatureSpec contains Hub-wide configuration information
 */
@interface GTLRGKEHub_CommonFeatureSpec : GTLRObject

/** Appdevexperience specific spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_AppDevExperienceFeatureSpec *appdevexperience;

/** ClusterUpgrade (fleet-based) feature spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeFleetSpec *clusterupgrade;

/** DataplaneV2 feature spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_DataplaneV2FeatureSpec *dataplanev2;

/** FleetObservability feature spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFeatureSpec *fleetobservability;

/** Multicluster Ingress-specific spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MultiClusterIngressFeatureSpec *multiclusteringress;

@end


/**
 *  CommonFeatureState contains Hub-wide Feature status information.
 */
@interface GTLRGKEHub_CommonFeatureState : GTLRObject

/** Appdevexperience specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_AppDevExperienceFeatureState *appdevexperience;

/** ClusterUpgrade fleet-level state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeFleetState *clusterupgrade;

/** FleetObservability feature state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFeatureState *fleetobservability;

/** Output only. The "running state" of the Feature in this Hub. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FeatureState *state;

@end


/**
 *  CommonFleetDefaultMemberConfigSpec contains default configuration
 *  information for memberships of a fleet
 */
@interface GTLRGKEHub_CommonFleetDefaultMemberConfigSpec : GTLRObject

/** Config Management-specific spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementMembershipSpec *configmanagement;

/** Identity Service-specific spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceMembershipSpec *identityservice;

/** Anthos Service Mesh-specific spec */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshMembershipSpec *mesh;

/** Policy Controller spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerMembershipSpec *policycontroller;

@end


/**
 *  Configuration for Config Sync
 */
@interface GTLRGKEHub_ConfigManagementConfigSync : GTLRObject

/**
 *  Set to true to allow the vertical scaling. Defaults to false which disallows
 *  vertical scaling. This field is deprecated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowVerticalScale GTLR_DEPRECATED;

/**
 *  Enables the installation of ConfigSync. If set to true, ConfigSync resources
 *  will be created and the other ConfigSync fields will be applied if exist. If
 *  set to false, all other ConfigSync fields will be ignored, ConfigSync
 *  resources will be deleted. If omitted, ConfigSync resources will be managed
 *  depends on the presence of the git or oci field.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/** Git repo configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementGitConfig *git;

/**
 *  The Email of the Google Cloud Service Account (GSA) used for exporting
 *  Config Sync metrics to Cloud Monitoring and Cloud Monarch when Workload
 *  Identity is enabled. The GSA should have the Monitoring Metric Writer
 *  (roles/monitoring.metricWriter) IAM role. The Kubernetes ServiceAccount
 *  `default` in the namespace `config-management-monitoring` should be bound to
 *  the GSA.
 */
@property(nonatomic, copy, nullable) NSString *metricsGcpServiceAccountEmail;

/** OCI repo configuration for the cluster */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementOciConfig *oci;

/**
 *  Set to true to enable the Config Sync admission webhook to prevent drifts.
 *  If set to `false`, disables the Config Sync admission webhook and does not
 *  prevent drifts.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preventDrift;

/**
 *  Specifies whether the Config Sync Repo is in "hierarchical" or
 *  "unstructured" mode.
 */
@property(nonatomic, copy, nullable) NSString *sourceFormat;

@end


/**
 *  The state of ConfigSync's deployment on a cluster
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncDeploymentState : GTLRObject

/**
 *  Deployment state of admission-webhook
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_AdmissionWebhook_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *admissionWebhook;

/**
 *  Deployment state of the git-sync pod
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_GitSync_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gitSync;

/**
 *  Deployment state of the importer pod
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Importer_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *importer;

/**
 *  Deployment state of the monitor pod
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Monitor_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *monitor;

/**
 *  Deployment state of reconciler-manager pod
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_ReconcilerManager_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *reconcilerManager;

/**
 *  Deployment state of root-reconciler
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_RootReconciler_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *rootReconciler;

/**
 *  Deployment state of the syncer pod
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncDeploymentState_Syncer_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *syncer;

@end


/**
 *  Errors pertaining to the installation of Config Sync
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncError : GTLRObject

/** A string representing the user facing error message */
@property(nonatomic, copy, nullable) NSString *errorMessage;

@end


/**
 *  State information for ConfigSync
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncState : GTLRObject

/**
 *  Information about the deployment of ConfigSync, including the version of the
 *  various Pods deployed
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSyncDeploymentState *deploymentState;

/** Errors pertaining to the installation of Config Sync. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementConfigSyncError *> *errors;

/**
 *  The state of the Reposync CRD
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_CrdStateUnspecified
 *        CRD's state cannot be determined (Value: "CRD_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installed
 *        CRD is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Installing
 *        CRD is installing (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_NotInstalled
 *        CRD is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_ReposyncCrd_Terminating
 *        CRD is terminating (i.e., it has been deleted and is cleaning up)
 *        (Value: "TERMINATING")
 */
@property(nonatomic, copy, nullable) NSString *reposyncCrd;

/**
 *  The state of the RootSync CRD
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_CrdStateUnspecified
 *        CRD's state cannot be determined (Value: "CRD_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installed
 *        CRD is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Installing
 *        CRD is installing (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_NotInstalled
 *        CRD is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_RootsyncCrd_Terminating
 *        CRD is terminating (i.e., it has been deleted and is cleaning up)
 *        (Value: "TERMINATING")
 */
@property(nonatomic, copy, nullable) NSString *rootsyncCrd;

/**
 *  The state of CS This field summarizes the other fields in this message.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncError
 *        CS encounters errors. (Value: "CONFIG_SYNC_ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncInstalled
 *        The expected CS version is installed successfully. (Value:
 *        "CONFIG_SYNC_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncNotInstalled
 *        CS is not installed. (Value: "CONFIG_SYNC_NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_ConfigSyncPending
 *        CS is installing or terminating. (Value: "CONFIG_SYNC_PENDING")
 *    @arg @c kGTLRGKEHub_ConfigManagementConfigSyncState_State_StateUnspecified
 *        CS's state cannot be determined. (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** The state of ConfigSync's process to sync configs to a cluster */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementSyncState *syncState;

/** The version of ConfigSync deployed */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSyncVersion *version;

@end


/**
 *  Specific versioning information pertaining to ConfigSync's Pods
 */
@interface GTLRGKEHub_ConfigManagementConfigSyncVersion : GTLRObject

/** Version of the deployed admission_webhook pod */
@property(nonatomic, copy, nullable) NSString *admissionWebhook;

/** Version of the deployed git-sync pod */
@property(nonatomic, copy, nullable) NSString *gitSync;

/** Version of the deployed importer pod */
@property(nonatomic, copy, nullable) NSString *importer;

/** Version of the deployed monitor pod */
@property(nonatomic, copy, nullable) NSString *monitor;

/** Version of the deployed reconciler-manager pod */
@property(nonatomic, copy, nullable) NSString *reconcilerManager;

/** Version of the deployed reconciler container in root-reconciler pod */
@property(nonatomic, copy, nullable) NSString *rootReconciler;

/** Version of the deployed syncer pod */
@property(nonatomic, copy, nullable) NSString *syncer;

@end


/**
 *  Model for a config file in the git repo with an associated Sync error
 */
@interface GTLRGKEHub_ConfigManagementErrorResource : GTLRObject

/** Group/version/kind of the resource that is causing an error */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementGroupVersionKind *resourceGvk;

/** Metadata name of the resource that is causing an error */
@property(nonatomic, copy, nullable) NSString *resourceName;

/** Namespace of the resource that is causing an error */
@property(nonatomic, copy, nullable) NSString *resourceNamespace;

/** Path in the git repo of the erroneous config */
@property(nonatomic, copy, nullable) NSString *sourcePath;

@end


/**
 *  State of Policy Controller installation.
 */
@interface GTLRGKEHub_ConfigManagementGatekeeperDeploymentState : GTLRObject

/**
 *  Status of gatekeeper-audit deployment.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperAudit_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gatekeeperAudit;

/**
 *  Status of gatekeeper-controller-manager pod.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperControllerManagerState_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gatekeeperControllerManagerState;

/**
 *  Status of the pod serving the mutation webhook.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementGatekeeperDeploymentState_GatekeeperMutation_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *gatekeeperMutation;

@end


/**
 *  Git repo configuration for a single cluster.
 */
@interface GTLRGKEHub_ConfigManagementGitConfig : GTLRObject

/**
 *  The Google Cloud Service Account Email used for auth when secret_type is
 *  gcpServiceAccount.
 */
@property(nonatomic, copy, nullable) NSString *gcpServiceAccountEmail;

/**
 *  URL for the HTTPS proxy to be used when communicating with the Git repo.
 */
@property(nonatomic, copy, nullable) NSString *httpsProxy;

/**
 *  The path within the Git repository that represents the top level of the repo
 *  to sync. Default: the root directory of the repository.
 */
@property(nonatomic, copy, nullable) NSString *policyDir;

/**
 *  Type of secret configured for access to the Git repo. Must be one of ssh,
 *  cookiefile, gcenode, token, gcpserviceaccount or none. The validation of
 *  this is case-sensitive. Required.
 */
@property(nonatomic, copy, nullable) NSString *secretType;

/** The branch of the repository to sync from. Default: master. */
@property(nonatomic, copy, nullable) NSString *syncBranch;

/** The URL of the Git repository to use as the source of truth. */
@property(nonatomic, copy, nullable) NSString *syncRepo;

/** Git revision (tag or hash) to check out. Default HEAD. */
@property(nonatomic, copy, nullable) NSString *syncRev;

/**
 *  Period in seconds between consecutive syncs. Default: 15.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *syncWaitSecs;

@end


/**
 *  A Kubernetes object's GVK
 */
@interface GTLRGKEHub_ConfigManagementGroupVersionKind : GTLRObject

/** Kubernetes Group */
@property(nonatomic, copy, nullable) NSString *group;

/** Kubernetes Kind */
@property(nonatomic, copy, nullable) NSString *kind;

/** Kubernetes Version */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Configuration for Hierarchy Controller
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerConfig : GTLRObject

/**
 *  Whether Hierarchy Controller is enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Whether hierarchical resource quota is enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableHierarchicalResourceQuota;

/**
 *  Whether pod tree labels are enabled in this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enablePodTreeLabels;

@end


/**
 *  Deployment state for Hierarchy Controller
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState : GTLRObject

/**
 *  The deployment state for Hierarchy Controller extension (e.g. v0.7.0-hc.1)
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Extension_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *extension;

/**
 *  The deployment state for open source HNC (e.g. v0.7.0-hc.0)
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState_Hnc_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *hnc;

@end


/**
 *  State for Hierarchy Controller
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerState : GTLRObject

/** The deployment state for Hierarchy Controller */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerDeploymentState *state;

/** The version for Hierarchy Controller */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerVersion *version;

@end


/**
 *  Version for Hierarchy Controller
 */
@interface GTLRGKEHub_ConfigManagementHierarchyControllerVersion : GTLRObject

/** Version for Hierarchy Controller extension */
@property(nonatomic, copy, nullable) NSString *extension;

/** Version for open source HNC */
@property(nonatomic, copy, nullable) NSString *hnc;

@end


/**
 *  Errors pertaining to the installation of ACM
 */
@interface GTLRGKEHub_ConfigManagementInstallError : GTLRObject

/** A string representing the user facing error message */
@property(nonatomic, copy, nullable) NSString *errorMessage;

@end


/**
 *  **Anthos Config Management**: Configuration for a single cluster. Intended
 *  to parallel the ConfigManagement CR.
 */
@interface GTLRGKEHub_ConfigManagementMembershipSpec : GTLRObject

/**
 *  The user-specified cluster name used by Config Sync cluster-name-selector
 *  annotation or ClusterSelector, for applying configs to only a subset of
 *  clusters. Omit this field if the cluster's fleet membership name is used by
 *  Config Sync cluster-name-selector annotation or ClusterSelector. Set this
 *  field if a name different from the cluster's fleet membership name is used
 *  by Config Sync cluster-name-selector annotation or ClusterSelector.
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/** Config Sync configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSync *configSync;

/** Hierarchy Controller configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerConfig *hierarchyController;

/**
 *  Enables automatic Feature management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementMembershipSpec_Management_ManagementAutomatic
 *        Google will manage the Feature for the cluster. (Value:
 *        "MANAGEMENT_AUTOMATIC")
 *    @arg @c kGTLRGKEHub_ConfigManagementMembershipSpec_Management_ManagementManual
 *        User will manually manage the Feature for the cluster. (Value:
 *        "MANAGEMENT_MANUAL")
 *    @arg @c kGTLRGKEHub_ConfigManagementMembershipSpec_Management_ManagementUnspecified
 *        Unspecified (Value: "MANAGEMENT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *management;

/** Policy Controller configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyController *policyController;

/** Version of ACM installed. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  **Anthos Config Management**: State for a single cluster.
 */
@interface GTLRGKEHub_ConfigManagementMembershipState : GTLRObject

/**
 *  This field is set to the `cluster_name` field of the Membership Spec if it
 *  is not empty. Otherwise, it is set to the cluster's fleet membership name.
 */
@property(nonatomic, copy, nullable) NSString *clusterName;

/** Current sync status */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementConfigSyncState *configSyncState;

/** Hierarchy Controller status */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementHierarchyControllerState *hierarchyControllerState;

/**
 *  Membership configuration in the cluster. This represents the actual state in
 *  the cluster, while the MembershipSpec in the FeatureSpec represents the
 *  intended state
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementMembershipSpec *membershipSpec;

/** Current install status of ACM's Operator */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementOperatorState *operatorState;

/** PolicyController status */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerState *policyControllerState;

@end


/**
 *  OCI repo configuration for a single cluster
 */
@interface GTLRGKEHub_ConfigManagementOciConfig : GTLRObject

/**
 *  The Google Cloud Service Account Email used for auth when secret_type is
 *  gcpServiceAccount.
 */
@property(nonatomic, copy, nullable) NSString *gcpServiceAccountEmail;

/**
 *  The absolute path of the directory that contains the local resources.
 *  Default: the root directory of the image.
 */
@property(nonatomic, copy, nullable) NSString *policyDir;

/** Type of secret configured for access to the Git repo. */
@property(nonatomic, copy, nullable) NSString *secretType;

/**
 *  The OCI image repository URL for the package to sync from. e.g.
 *  `LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME`.
 */
@property(nonatomic, copy, nullable) NSString *syncRepo;

/**
 *  Period in seconds between consecutive syncs. Default: 15.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *syncWaitSecs;

@end


/**
 *  State information for an ACM's Operator
 */
@interface GTLRGKEHub_ConfigManagementOperatorState : GTLRObject

/**
 *  The state of the Operator's deployment
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_DeploymentStateUnspecified
 *        Deployment's state cannot be determined (Value:
 *        "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Error
 *        Deployment was attempted to be installed, but has errors (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Installed
 *        Deployment is installed (Value: "INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_NotInstalled
 *        Deployment is not installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementOperatorState_DeploymentState_Pending
 *        Deployment is installing or terminating (Value: "PENDING")
 */
@property(nonatomic, copy, nullable) NSString *deploymentState;

/** Install errors. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementInstallError *> *errors;

/** The semenatic version number of the operator */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  Configuration for Policy Controller
 */
@interface GTLRGKEHub_ConfigManagementPolicyController : GTLRObject

/**
 *  Sets the interval for Policy Controller Audit Scans (in seconds). When set
 *  to 0, this disables audit functionality altogether.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *auditIntervalSeconds;

/**
 *  Enables the installation of Policy Controller. If false, the rest of
 *  PolicyController fields take no effect.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  The set of namespaces that are excluded from Policy Controller checks.
 *  Namespaces do not need to currently exist on the cluster.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptableNamespaces;

/**
 *  Logs all denies and dry run failures.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logDeniesEnabled;

/** Monitoring specifies the configuration of monitoring. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerMonitoring *monitoring;

/**
 *  Enable or disable mutation in policy controller. If true, mutation CRDs,
 *  webhook and controller deployment will be deployed to the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mutationEnabled;

/**
 *  Enables the ability to use Constraint Templates that reference to objects
 *  other than the object currently being evaluated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *referentialRulesEnabled;

/**
 *  Installs the default template library along with Policy Controller.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *templateLibraryInstalled;

/** Output only. Last time this membership spec was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  State for the migration of PolicyController from ACM -> PoCo Hub.
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerMigration : GTLRObject

/** Last time this membership spec was copied to PoCo feature. */
@property(nonatomic, strong, nullable) GTLRDateTime *copyTime NS_RETURNS_NOT_RETAINED;

/**
 *  Stage of the migration.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_AcmManaged
 *        ACM Hub/Operator manages policycontroller. No migration yet completed.
 *        (Value: "ACM_MANAGED")
 *    @arg @c kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_PocoManaged
 *        All migrations steps complete; Poco Hub now manages policycontroller.
 *        (Value: "POCO_MANAGED")
 *    @arg @c kGTLRGKEHub_ConfigManagementPolicyControllerMigration_Stage_StageUnspecified
 *        Unknown state of migration. (Value: "STAGE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *stage;

@end


/**
 *  PolicyControllerMonitoring specifies the backends Policy Controller should
 *  export metrics to. For example, to specify metrics should be exported to
 *  Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring",
 *  "prometheus"]
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerMonitoring : GTLRObject

/**
 *  Specifies the list of backends Policy Controller will export to. An empty
 *  list would effectively disable metrics export.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backends;

@end


/**
 *  State for PolicyControllerState.
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerState : GTLRObject

/** The state about the policy controller installation. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementGatekeeperDeploymentState *deploymentState;

/** Record state of ACM -> PoCo Hub migration for this feature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerMigration *migration;

/** The version of Gatekeeper Policy Controller deployed. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementPolicyControllerVersion *version;

@end


/**
 *  The build version of Gatekeeper Policy Controller is using.
 */
@interface GTLRGKEHub_ConfigManagementPolicyControllerVersion : GTLRObject

/**
 *  The gatekeeper image tag that is composed of ACM version, git tag, build
 *  number.
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  An ACM created error representing a problem syncing configurations
 */
@interface GTLRGKEHub_ConfigManagementSyncError : GTLRObject

/** An ACM defined error code */
@property(nonatomic, copy, nullable) NSString *code;

/** A description of the error */
@property(nonatomic, copy, nullable) NSString *errorMessage;

/** A list of config(s) associated with the error, if any */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementErrorResource *> *errorResources;

@end


/**
 *  State indicating an ACM's progress syncing configurations to a cluster
 */
@interface GTLRGKEHub_ConfigManagementSyncState : GTLRObject

/**
 *  Sync status code
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Error Indicates an
 *        error configuring Config Sync, and user action is required (Value:
 *        "ERROR")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_NotConfigured Config
 *        Sync has been installed but not configured (Value: "NOT_CONFIGURED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_NotInstalled Config
 *        Sync has not been installed (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Pending Config Sync is
 *        in the progress of syncing a new change (Value: "PENDING")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_SyncCodeUnspecified
 *        Config Sync cannot determine a sync code (Value:
 *        "SYNC_CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Synced Config Sync
 *        successfully synced the git Repo with the cluster (Value: "SYNCED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Unauthorized Error
 *        authorizing with the cluster (Value: "UNAUTHORIZED")
 *    @arg @c kGTLRGKEHub_ConfigManagementSyncState_Code_Unreachable Cluster
 *        could not be reached (Value: "UNREACHABLE")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  A list of errors resulting from problematic configs. This list will be
 *  truncated after 100 errors, although it is unlikely for that many errors to
 *  simultaneously exist.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConfigManagementSyncError *> *errors;

/** Token indicating the state of the importer. */
@property(nonatomic, copy, nullable) NSString *importToken;

/**
 *  Deprecated: use last_sync_time instead. Timestamp of when ACM last
 *  successfully synced the repo The time format is specified in
 *  https://golang.org/pkg/time/#Time.String
 */
@property(nonatomic, copy, nullable) NSString *lastSync GTLR_DEPRECATED;

/** Timestamp type of when ACM last successfully synced the repo */
@property(nonatomic, strong, nullable) GTLRDateTime *lastSyncTime;

/** Token indicating the state of the repo. */
@property(nonatomic, copy, nullable) NSString *sourceToken;

/** Token indicating the state of the syncer. */
@property(nonatomic, copy, nullable) NSString *syncToken;

@end


/**
 *  ConnectAgentResource represents a Kubernetes resource manifest for Connect
 *  Agent deployment.
 */
@interface GTLRGKEHub_ConnectAgentResource : GTLRObject

/** YAML manifest of the resource. */
@property(nonatomic, copy, nullable) NSString *manifest;

/** Kubernetes type of the resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_TypeMeta *type;

@end


/**
 *  **Dataplane V2**: Spec
 */
@interface GTLRGKEHub_DataplaneV2FeatureSpec : GTLRObject

/**
 *  Enable dataplane-v2 based encryption for multiple clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableEncryption;

@end


/**
 *  DefaultClusterConfig describes the default cluster configurations to be
 *  applied to all clusters born-in-fleet.
 */
@interface GTLRGKEHub_DefaultClusterConfig : GTLRObject

/** Optional. Enable/Disable binary authorization features for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_BinaryAuthorizationConfig *binaryAuthorizationConfig;

/** Enable/Disable Security Posture features for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_SecurityPostureConfig *securityPostureConfig;

@end


/**
 *  EdgeCluster contains information specific to Google Edge Clusters.
 */
@interface GTLRGKEHub_EdgeCluster : GTLRObject

/**
 *  Immutable. Self-link of the Google Cloud resource for the Edge Cluster. For
 *  example:
 *  //edgecontainer.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
 */
@property(nonatomic, copy, nullable) NSString *resourceLink;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRGKEHub_Empty : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRGKEHub_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Feature represents the settings and status of any Hub Feature.
 */
@interface GTLRGKEHub_Feature : GTLRObject

/** Output only. When the Feature resource was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the Feature resource was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/**
 *  Optional. Feature configuration applicable to all memberships of the fleet.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_CommonFleetDefaultMemberConfigSpec *fleetDefaultMemberConfig;

/** Labels for this Feature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_Feature_Labels *labels;

/**
 *  Optional. Membership-specific configuration for this Feature. If this
 *  Feature does not support any per-Membership configuration, this field may be
 *  unused. The keys indicate which Membership the configuration is for, in the
 *  form: `projects/{p}/locations/{l}/memberships/{m}` Where {p} is the project,
 *  {l} is a valid location and {m} is a valid Membership in this project at
 *  that location. {p} WILL match the Feature's project. {p} will always be
 *  returned as the project number, but the project ID is also accepted during
 *  input. If the same Membership is specified in the map twice (using the
 *  project ID form, and the project number form), exactly ONE of the entries
 *  will be saved, with no guarantees as to which. For this reason, it is
 *  recommended the same format be used for all entries when mutating a Feature.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Feature_MembershipSpecs *membershipSpecs;

/**
 *  Output only. Membership-specific Feature status. If this Feature does report
 *  any per-Membership status, this field may be unused. The keys indicate which
 *  Membership the state is for, in the form:
 *  `projects/{p}/locations/{l}/memberships/{m}` Where {p} is the project
 *  number, {l} is a valid location and {m} is a valid Membership in this
 *  project at that location. {p} MUST match the Feature's project number.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Feature_MembershipStates *membershipStates;

/**
 *  Output only. The full, unique name of this Feature resource in the format
 *  `projects/ * /locations/ * /features/ *`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. State of the Feature resource itself. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FeatureResourceState *resourceState;

/**
 *  Optional. Scope-specific configuration for this Feature. If this Feature
 *  does not support any per-Scope configuration, this field may be unused. The
 *  keys indicate which Scope the configuration is for, in the form:
 *  `projects/{p}/locations/global/scopes/{s}` Where {p} is the project, {s} is
 *  a valid Scope in this project. {p} WILL match the Feature's project. {p}
 *  will always be returned as the project number, but the project ID is also
 *  accepted during input. If the same Scope is specified in the map twice
 *  (using the project ID form, and the project number form), exactly ONE of the
 *  entries will be saved, with no guarantees as to which. For this reason, it
 *  is recommended the same format be used for all entries when mutating a
 *  Feature.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Feature_ScopeSpecs *scopeSpecs;

/**
 *  Output only. Scope-specific Feature status. If this Feature does report any
 *  per-Scope status, this field may be unused. The keys indicate which Scope
 *  the state is for, in the form: `projects/{p}/locations/global/scopes/{s}`
 *  Where {p} is the project, {s} is a valid Scope in this project. {p} WILL
 *  match the Feature's project.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Feature_ScopeStates *scopeStates;

/**
 *  Optional. Hub-wide Feature configuration. If this Feature does not support
 *  any Hub-wide configuration, this field may be unused.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_CommonFeatureSpec *spec;

/** Output only. The Hub-wide Feature state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_CommonFeatureState *state;

/** Output only. When the Feature resource was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Labels for this Feature.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Feature_Labels : GTLRObject
@end


/**
 *  Optional. Membership-specific configuration for this Feature. If this
 *  Feature does not support any per-Membership configuration, this field may be
 *  unused. The keys indicate which Membership the configuration is for, in the
 *  form: `projects/{p}/locations/{l}/memberships/{m}` Where {p} is the project,
 *  {l} is a valid location and {m} is a valid Membership in this project at
 *  that location. {p} WILL match the Feature's project. {p} will always be
 *  returned as the project number, but the project ID is also accepted during
 *  input. If the same Membership is specified in the map twice (using the
 *  project ID form, and the project number form), exactly ONE of the entries
 *  will be saved, with no guarantees as to which. For this reason, it is
 *  recommended the same format be used for all entries when mutating a Feature.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_MembershipFeatureSpec. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Feature_MembershipSpecs : GTLRObject
@end


/**
 *  Output only. Membership-specific Feature status. If this Feature does report
 *  any per-Membership status, this field may be unused. The keys indicate which
 *  Membership the state is for, in the form:
 *  `projects/{p}/locations/{l}/memberships/{m}` Where {p} is the project
 *  number, {l} is a valid location and {m} is a valid Membership in this
 *  project at that location. {p} MUST match the Feature's project number.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_MembershipFeatureState. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Feature_MembershipStates : GTLRObject
@end


/**
 *  Optional. Scope-specific configuration for this Feature. If this Feature
 *  does not support any per-Scope configuration, this field may be unused. The
 *  keys indicate which Scope the configuration is for, in the form:
 *  `projects/{p}/locations/global/scopes/{s}` Where {p} is the project, {s} is
 *  a valid Scope in this project. {p} WILL match the Feature's project. {p}
 *  will always be returned as the project number, but the project ID is also
 *  accepted during input. If the same Scope is specified in the map twice
 *  (using the project ID form, and the project number form), exactly ONE of the
 *  entries will be saved, with no guarantees as to which. For this reason, it
 *  is recommended the same format be used for all entries when mutating a
 *  Feature.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_ScopeFeatureSpec. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Feature_ScopeSpecs : GTLRObject
@end


/**
 *  Output only. Scope-specific Feature status. If this Feature does report any
 *  per-Scope status, this field may be unused. The keys indicate which Scope
 *  the state is for, in the form: `projects/{p}/locations/global/scopes/{s}`
 *  Where {p} is the project, {s} is a valid Scope in this project. {p} WILL
 *  match the Feature's project.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_ScopeFeatureState. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Feature_ScopeStates : GTLRObject
@end


/**
 *  FeatureResourceState describes the state of a Feature *resource* in the
 *  GkeHub API. See `FeatureState` for the "running state" of the Feature in the
 *  Hub and across Memberships.
 */
@interface GTLRGKEHub_FeatureResourceState : GTLRObject

/**
 *  The current state of the Feature resource in the Hub API.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_FeatureResourceState_State_Active The Feature is
 *        enabled in this Hub, and the Feature resource is fully available.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_FeatureResourceState_State_Disabling The Feature is
 *        being disabled in this Hub, and the Feature resource is being deleted.
 *        (Value: "DISABLING")
 *    @arg @c kGTLRGKEHub_FeatureResourceState_State_Enabling The Feature is
 *        being enabled, and the Feature resource is being created. Once
 *        complete, the corresponding Feature will be enabled in this Hub.
 *        (Value: "ENABLING")
 *    @arg @c kGTLRGKEHub_FeatureResourceState_State_ServiceUpdating The Feature
 *        resource is being updated by the Hub Service. (Value:
 *        "SERVICE_UPDATING")
 *    @arg @c kGTLRGKEHub_FeatureResourceState_State_StateUnspecified State is
 *        unknown or not set. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_FeatureResourceState_State_Updating The Feature
 *        resource is being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  FeatureState describes the high-level state of a Feature. It may be used to
 *  describe a Feature's state at the environ-level, or per-membershop,
 *  depending on the context.
 */
@interface GTLRGKEHub_FeatureState : GTLRObject

/**
 *  The high-level, machine-readable status of this Feature.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_FeatureState_Code_CodeUnspecified Unknown or not set.
 *        (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_FeatureState_Code_Error The Feature is not operating
 *        or is in a severely degraded state. The Feature may need intervention
 *        to return to normal operation. See the description and any associated
 *        Feature-specific details for more information. (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_FeatureState_Code_Ok The Feature is operating
 *        normally. (Value: "OK")
 *    @arg @c kGTLRGKEHub_FeatureState_Code_Warning The Feature has encountered
 *        an issue, and is operating in a degraded state. The Feature may need
 *        intervention to return to normal operation. See the description and
 *        any associated Feature-specific details for more information. (Value:
 *        "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  A human-readable description of the current status.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The time this status and any related Feature-specific details were updated.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Fleet contains the Fleet-wide metadata and configuration.
 */
@interface GTLRGKEHub_Fleet : GTLRObject

/** Output only. When the Fleet was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Optional. The default cluster configurations to apply across the fleet. */
@property(nonatomic, strong, nullable) GTLRGKEHub_DefaultClusterConfig *defaultClusterConfig;

/** Output only. When the Fleet was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/**
 *  Optional. A user-assigned display name of the Fleet. When present, it must
 *  be between 4 to 30 characters. Allowed characters are: lowercase and
 *  uppercase letters, numbers, hyphen, single-quote, double-quote, space, and
 *  exclamation point. Example: `Production Fleet`
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Optional. Labels for this Fleet. */
@property(nonatomic, strong, nullable) GTLRGKEHub_Fleet_Labels *labels;

/**
 *  Output only. The full, unique resource name of this fleet in the format of
 *  `projects/{project}/locations/{location}/fleets/{fleet}`. Each Google Cloud
 *  project can have at most one fleet resource, named "default".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. State of the namespace resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetLifecycleState *state;

/**
 *  Output only. Google-generated UUID for this resource. This is unique across
 *  all Fleet resources. If a Fleet resource is deleted and another resource
 *  with the same name is created, it gets a different uid.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. When the Fleet was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels for this Fleet.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Fleet_Labels : GTLRObject
@end


/**
 *  FleetLifecycleState describes the state of a Fleet resource.
 */
@interface GTLRGKEHub_FleetLifecycleState : GTLRObject

/**
 *  Output only. The current state of the Fleet resource.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_FleetLifecycleState_Code_CodeUnspecified The code is
 *        not set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_FleetLifecycleState_Code_Creating The fleet is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRGKEHub_FleetLifecycleState_Code_Deleting The fleet is being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRGKEHub_FleetLifecycleState_Code_Ready The fleet active.
 *        (Value: "READY")
 *    @arg @c kGTLRGKEHub_FleetLifecycleState_Code_Updating The fleet is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  All error details of the fleet observability feature.
 */
@interface GTLRGKEHub_FleetObservabilityFeatureError : GTLRObject

/** The code of the error. */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  A human-readable description of the current status.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

@end


/**
 *  **Fleet Observability**: The Hub-wide input for the FleetObservability
 *  feature.
 */
@interface GTLRGKEHub_FleetObservabilityFeatureSpec : GTLRObject

/**
 *  Specified if fleet logging feature is enabled for the entire fleet. If
 *  UNSPECIFIED, fleet logging feature is disabled for the entire fleet.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityLoggingConfig *loggingConfig;

@end


/**
 *  **FleetObservability**: Hub-wide Feature for FleetObservability feature.
 *  state.
 */
@interface GTLRGKEHub_FleetObservabilityFeatureState : GTLRObject

/** The feature state of default logging. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFleetObservabilityLoggingState *logging;

/** The feature state of fleet monitoring. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFleetObservabilityMonitoringState *monitoring;

@end


/**
 *  Base state for fleet observability feature.
 */
@interface GTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState : GTLRObject

/**
 *  The high-level, machine-readable status of this Feature.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState_Code_CodeUnspecified
 *        Unknown or not set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState_Code_Error
 *        The Feature is encountering errors in the reconciliation. The Feature
 *        may need intervention to return to normal operation. See the
 *        description and any associated Feature-specific details for more
 *        information. (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState_Code_Ok
 *        The Feature is operating normally. (Value: "OK")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Errors after reconciling the monitoring and logging feature if the code is
 *  not OK.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_FleetObservabilityFeatureError *> *errors;

@end


/**
 *  Feature state for logging feature.
 */
@interface GTLRGKEHub_FleetObservabilityFleetObservabilityLoggingState : GTLRObject

/** The base feature state of fleet default log. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState *defaultLog;

/** The base feature state of fleet scope log. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState *scopeLog;

@end


/**
 *  Feature state for monitoring feature.
 */
@interface GTLRGKEHub_FleetObservabilityFleetObservabilityMonitoringState : GTLRObject

/** The base feature state of fleet monitoring feature. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityFleetObservabilityBaseFeatureState *state;

@end


/**
 *  LoggingConfig defines the configuration for different types of logs.
 */
@interface GTLRGKEHub_FleetObservabilityLoggingConfig : GTLRObject

/**
 *  Specified if applying the default routing config to logs not specified in
 *  other configs.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityRoutingConfig *defaultConfig;

/**
 *  Specified if applying the routing config to all logs for all fleet scopes.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityRoutingConfig *fleetScopeLogsConfig;

@end


/**
 *  **FleetObservability**: The membership-specific input for FleetObservability
 *  feature.
 */
@interface GTLRGKEHub_FleetObservabilityMembershipSpec : GTLRObject
@end


/**
 *  **FleetObservability**: Membership-specific Feature state for
 *  fleetobservability.
 */
@interface GTLRGKEHub_FleetObservabilityMembershipState : GTLRObject
@end


/**
 *  RoutingConfig configures the behaviour of fleet logging feature.
 */
@interface GTLRGKEHub_FleetObservabilityRoutingConfig : GTLRObject

/**
 *  mode configures the logs routing mode.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_FleetObservabilityRoutingConfig_Mode_Copy logs will be
 *        copied to the destination project. (Value: "COPY")
 *    @arg @c kGTLRGKEHub_FleetObservabilityRoutingConfig_Mode_ModeUnspecified
 *        If UNSPECIFIED, fleet logging feature is disabled. (Value:
 *        "MODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_FleetObservabilityRoutingConfig_Mode_Move logs will be
 *        moved to the destination project. (Value: "MOVE")
 */
@property(nonatomic, copy, nullable) NSString *mode;

@end


/**
 *  GenerateConnectManifestResponse contains manifest information for
 *  installing/upgrading a Connect agent.
 */
@interface GTLRGKEHub_GenerateConnectManifestResponse : GTLRObject

/**
 *  The ordered list of Kubernetes resources that need to be applied to the
 *  cluster for GKE Connect agent installation/upgrade.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ConnectAgentResource *> *manifest;

@end


/**
 *  GkeCluster contains information specific to GKE clusters.
 */
@interface GTLRGKEHub_GkeCluster : GTLRObject

/**
 *  Output only. If cluster_missing is set then it denotes that the GKE cluster
 *  no longer exists in the GKE Control Plane.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *clusterMissing;

/**
 *  Immutable. Self-link of the Google Cloud resource for the GKE cluster. For
 *  example:
 *  //container.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
 *  Zonal clusters are also supported.
 */
@property(nonatomic, copy, nullable) NSString *resourceLink;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRGKEHub_GoogleRpcStatus : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_GoogleRpcStatus_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRGKEHub_GoogleRpcStatus_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_GoogleRpcStatus_Details_Item : GTLRObject
@end


/**
 *  Configuration of an auth method for a member/cluster. Only one
 *  authentication method (e.g., OIDC and LDAP) can be set per AuthMethod.
 */
@interface GTLRGKEHub_IdentityServiceAuthMethod : GTLRObject

/** AzureAD specific Configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceAzureADConfig *azureadConfig;

/** GoogleConfig specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceGoogleConfig *googleConfig;

/** LDAP specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceLdapConfig *ldapConfig;

/** Identifier for auth config. */
@property(nonatomic, copy, nullable) NSString *name;

/** OIDC specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceOidcConfig *oidcConfig;

/** Proxy server address to use for auth method. */
@property(nonatomic, copy, nullable) NSString *proxy;

/** SAML specific configuration. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSamlConfig *samlConfig;

@end


/**
 *  Configuration for the AzureAD Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceAzureADConfig : GTLRObject

/**
 *  ID for the registered client application that makes authentication requests
 *  to the Azure AD identity provider.
 */
@property(nonatomic, copy, nullable) NSString *clientId;

/**
 *  Input only. Unencrypted AzureAD client secret will be passed to the GKE Hub
 *  CLH.
 */
@property(nonatomic, copy, nullable) NSString *clientSecret;

/**
 *  Output only. Encrypted AzureAD client secret.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *encryptedClientSecret;

/** Optional. Format of the AzureAD groups that the client wants for auth. */
@property(nonatomic, copy, nullable) NSString *groupFormat;

/** The redirect URL that kubectl uses for authorization. */
@property(nonatomic, copy, nullable) NSString *kubectlRedirectUri;

/**
 *  Kind of Azure AD account to be authenticated. Supported values are or for
 *  accounts belonging to a specific tenant.
 */
@property(nonatomic, copy, nullable) NSString *tenant;

/** Optional. Claim in the AzureAD ID Token that holds the user details. */
@property(nonatomic, copy, nullable) NSString *userClaim;

@end


/**
 *  Configuration for the Google Plugin Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceGoogleConfig : GTLRObject

/**
 *  Disable automatic configuration of Google Plugin on supported platforms.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disable;

@end


/**
 *  Contains the properties for locating and authenticating groups in the
 *  directory.
 */
@interface GTLRGKEHub_IdentityServiceGroupConfig : GTLRObject

/**
 *  Required. The location of the subtree in the LDAP directory to search for
 *  group entries.
 */
@property(nonatomic, copy, nullable) NSString *baseDn;

/**
 *  Optional. Optional filter to be used when searching for groups a user
 *  belongs to. This can be used to explicitly match only certain groups in
 *  order to reduce the amount of groups returned for each user. This defaults
 *  to "(objectClass=Group)".
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Optional. The identifying name of each group a user belongs to. For example,
 *  if this is set to "distinguishedName" then RBACs and other group
 *  expectations should be written as full DNs. This defaults to
 *  "distinguishedName".
 */
@property(nonatomic, copy, nullable) NSString *idAttribute;

@end


/**
 *  Configuration for the LDAP Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceLdapConfig : GTLRObject

/**
 *  Optional. Contains the properties for locating and authenticating groups in
 *  the directory.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceGroupConfig *group;

/** Required. Server settings for the external LDAP server. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceServerConfig *server;

/**
 *  Required. Contains the credentials of the service account which is
 *  authorized to perform the LDAP search in the directory. The credentials can
 *  be supplied by the combination of the DN and password or the client
 *  certificate.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceServiceAccountConfig *serviceAccount;

/** Required. Defines where users exist in the LDAP directory. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceUserConfig *user;

@end


/**
 *  **Anthos Identity Service**: Configuration for a single Membership.
 */
@interface GTLRGKEHub_IdentityServiceMembershipSpec : GTLRObject

/** A member may support multiple auth methods. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_IdentityServiceAuthMethod *> *authMethods;

@end


/**
 *  **Anthos Identity Service**: State for a single Membership.
 */
@interface GTLRGKEHub_IdentityServiceMembershipState : GTLRObject

/** The reason of the failure. */
@property(nonatomic, copy, nullable) NSString *failureReason;

/**
 *  Installed AIS version. This is the AIS version installed on this member. The
 *  values makes sense iff state is OK.
 */
@property(nonatomic, copy, nullable) NSString *installedVersion;

/** Last reconciled membership configuration */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceMembershipSpec *memberConfig;

/**
 *  Deployment state on this member
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_IdentityServiceMembershipState_State_DeploymentStateUnspecified
 *        Unspecified state (Value: "DEPLOYMENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_IdentityServiceMembershipState_State_Error Failure
 *        with error. (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_IdentityServiceMembershipState_State_Ok deployment
 *        succeeds (Value: "OK")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Configuration for OIDC Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceOidcConfig : GTLRObject

/** PEM-encoded CA for OIDC provider. */
@property(nonatomic, copy, nullable) NSString *certificateAuthorityData;

/** ID for OIDC client application. */
@property(nonatomic, copy, nullable) NSString *clientId;

/**
 *  Input only. Unencrypted OIDC client secret will be passed to the GKE Hub
 *  CLH.
 */
@property(nonatomic, copy, nullable) NSString *clientSecret;

/**
 *  Flag to denote if reverse proxy is used to connect to auth provider. This
 *  flag should be set to true when provider is not reachable by Google Cloud
 *  Console.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deployCloudConsoleProxy;

/**
 *  Enable access token.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableAccessToken;

/**
 *  Output only. Encrypted OIDC Client secret
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *encryptedClientSecret;

/** Comma-separated list of key-value pairs. */
@property(nonatomic, copy, nullable) NSString *extraParams;

/** Prefix to prepend to group name. */
@property(nonatomic, copy, nullable) NSString *groupPrefix;

/** Claim in OIDC ID token that holds group information. */
@property(nonatomic, copy, nullable) NSString *groupsClaim;

/**
 *  URI for the OIDC provider. This should point to the level below
 *  .well-known/openid-configuration.
 */
@property(nonatomic, copy, nullable) NSString *issuerUri;

/**
 *  Registered redirect uri to redirect users going through OAuth flow using
 *  kubectl plugin.
 */
@property(nonatomic, copy, nullable) NSString *kubectlRedirectUri;

/** Comma-separated list of identifiers. */
@property(nonatomic, copy, nullable) NSString *scopes;

/** Claim in OIDC ID token that holds username. */
@property(nonatomic, copy, nullable) NSString *userClaim;

/** Prefix to prepend to user name. */
@property(nonatomic, copy, nullable) NSString *userPrefix;

@end


/**
 *  Configuration for the SAML Auth flow.
 */
@interface GTLRGKEHub_IdentityServiceSamlConfig : GTLRObject

/**
 *  Optional. The mapping of additional user attributes like nickname, birthday
 *  and address etc.. `key` is the name of this additional attribute. `value` is
 *  a string presenting as CEL(common expression language, go/cel) used for
 *  getting the value from the resources. Take nickname as an example, in this
 *  case, `key` is "attribute.nickname" and `value` is "assertion.nickname".
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSamlConfig_AttributeMapping *attributeMapping;

/** Optional. Prefix to prepend to group name. */
@property(nonatomic, copy, nullable) NSString *groupPrefix;

/**
 *  Optional. The SAML attribute to read groups from. This value is expected to
 *  be a string and will be passed along as-is (with the option of being
 *  prefixed by the `group_prefix`).
 */
@property(nonatomic, copy, nullable) NSString *groupsAttribute;

/**
 *  Required. The list of IdP certificates to validate the SAML response
 *  against.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *identityProviderCertificates;

/** Required. The entity ID of the SAML IdP. */
@property(nonatomic, copy, nullable) NSString *identityProviderId;

/** Required. The URI where the SAML IdP exposes the SSO service. */
@property(nonatomic, copy, nullable) NSString *identityProviderSsoUri;

/**
 *  Optional. The SAML attribute to read username from. If unspecified, the
 *  username will be read from the NameID element of the assertion in SAML
 *  response. This value is expected to be a string and will be passed along
 *  as-is (with the option of being prefixed by the `user_prefix`).
 */
@property(nonatomic, copy, nullable) NSString *userAttribute;

/** Optional. Prefix to prepend to user name. */
@property(nonatomic, copy, nullable) NSString *userPrefix;

@end


/**
 *  Optional. The mapping of additional user attributes like nickname, birthday
 *  and address etc.. `key` is the name of this additional attribute. `value` is
 *  a string presenting as CEL(common expression language, go/cel) used for
 *  getting the value from the resources. Take nickname as an example, in this
 *  case, `key` is "attribute.nickname" and `value` is "assertion.nickname".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_IdentityServiceSamlConfig_AttributeMapping : GTLRObject
@end


/**
 *  Server settings for the external LDAP server.
 */
@interface GTLRGKEHub_IdentityServiceServerConfig : GTLRObject

/**
 *  Optional. Contains a Base64 encoded, PEM formatted certificate authority
 *  certificate for the LDAP server. This must be provided for the "ldaps" and
 *  "startTLS" connections.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *certificateAuthorityData;

/**
 *  Optional. Defines the connection type to communicate with the LDAP server.
 *  If `starttls` or `ldaps` is specified, the certificate_authority_data should
 *  not be empty.
 */
@property(nonatomic, copy, nullable) NSString *connectionType;

/**
 *  Required. Defines the hostname or IP of the LDAP server. Port is optional
 *  and will default to 389, if unspecified. For example, "ldap.server.example"
 *  or "10.10.10.10:389".
 */
@property(nonatomic, copy, nullable) NSString *host;

@end


/**
 *  Contains the credentials of the service account which is authorized to
 *  perform the LDAP search in the directory. The credentials can be supplied by
 *  the combination of the DN and password or the client certificate.
 */
@interface GTLRGKEHub_IdentityServiceServiceAccountConfig : GTLRObject

/** Credentials for basic auth. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceSimpleBindCredentials *simpleBindCredentials;

@end


/**
 *  The structure holds the LDAP simple binding credential.
 */
@interface GTLRGKEHub_IdentityServiceSimpleBindCredentials : GTLRObject

/**
 *  Required. The distinguished name(DN) of the service account object/user.
 */
@property(nonatomic, copy, nullable) NSString *dn;

/**
 *  Output only. The encrypted password of the service account object/user.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *encryptedPassword;

/** Required. Input only. The password of the service account object/user. */
@property(nonatomic, copy, nullable) NSString *password;

@end


/**
 *  Defines where users exist in the LDAP directory.
 */
@interface GTLRGKEHub_IdentityServiceUserConfig : GTLRObject

/**
 *  Required. The location of the subtree in the LDAP directory to search for
 *  user entries.
 */
@property(nonatomic, copy, nullable) NSString *baseDn;

/**
 *  Optional. Filter to apply when searching for the user. This can be used to
 *  further restrict the user accounts which are allowed to login. This defaults
 *  to "(objectClass=User)".
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Optional. Determines which attribute to use as the user's identity after
 *  they are authenticated. This is distinct from the loginAttribute field to
 *  allow users to login with a username, but then have their actual identifier
 *  be an email address or full Distinguished Name (DN). For example, setting
 *  loginAttribute to "sAMAccountName" and identifierAttribute to
 *  "userPrincipalName" would allow a user to login as "bsmith", but actual RBAC
 *  policies for the user would be written as "bsmith\@example.com". Using
 *  "userPrincipalName" is recommended since this will be unique for each user.
 *  This defaults to "userPrincipalName".
 */
@property(nonatomic, copy, nullable) NSString *idAttribute;

/**
 *  Optional. The name of the attribute which matches against the input
 *  username. This is used to find the user in the LDAP database e.g. "(=)" and
 *  is combined with the optional filter field. This defaults to
 *  "userPrincipalName".
 */
@property(nonatomic, copy, nullable) NSString *loginAttribute;

@end


/**
 *  KubernetesMetadata provides informational metadata for Memberships
 *  representing Kubernetes clusters.
 */
@interface GTLRGKEHub_KubernetesMetadata : GTLRObject

/**
 *  Output only. Kubernetes API server version string as reported by `/version`.
 */
@property(nonatomic, copy, nullable) NSString *kubernetesApiServerVersion;

/**
 *  Output only. The total memory capacity as reported by the sum of all
 *  Kubernetes nodes resources, defined in MB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryMb;

/**
 *  Output only. Node count as reported by Kubernetes nodes resources.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  Output only. Node providerID as reported by the first node in the list of
 *  nodes on the Kubernetes endpoint. On Kubernetes platforms that support
 *  zero-node clusters (like GKE-on-GCP), the node_count will be zero and the
 *  node_provider_id will be empty.
 */
@property(nonatomic, copy, nullable) NSString *nodeProviderId;

/**
 *  Output only. The time at which these details were last updated. This
 *  update_time is different from the Membership-level update_time since
 *  EndpointDetails are updated internally for API consumers.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  Output only. vCPU count as reported by Kubernetes nodes resources.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vcpuCount;

@end


/**
 *  KubernetesResource contains the YAML manifests and configuration for
 *  Membership Kubernetes resources in the cluster. After CreateMembership or
 *  UpdateMembership, these resources should be re-applied in the cluster.
 */
@interface GTLRGKEHub_KubernetesResource : GTLRObject

/**
 *  Output only. The Kubernetes resources for installing the GKE Connect agent
 *  This field is only populated in the Membership returned from a successful
 *  long-running operation from CreateMembership or UpdateMembership. It is not
 *  populated during normal GetMembership or ListMemberships requests. To get
 *  the resource manifest after the initial registration, the caller should make
 *  a UpdateMembership call with an empty field mask.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ResourceManifest *> *connectResources;

/**
 *  Input only. The YAML representation of the Membership CR. This field is
 *  ignored for GKE clusters where Hub can read the CR directly. Callers should
 *  provide the CR that is currently present in the cluster during
 *  CreateMembership or UpdateMembership, or leave this field empty if none
 *  exists. The CR manifest is used to validate the cluster has not been
 *  registered with another Membership.
 */
@property(nonatomic, copy, nullable) NSString *membershipCrManifest;

/**
 *  Output only. Additional Kubernetes resources that need to be applied to the
 *  cluster after Membership creation, and after every update. This field is
 *  only populated in the Membership returned from a successful long-running
 *  operation from CreateMembership or UpdateMembership. It is not populated
 *  during normal GetMembership or ListMemberships requests. To get the resource
 *  manifest after the initial registration, the caller should make a
 *  UpdateMembership call with an empty field mask.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ResourceManifest *> *membershipResources;

/** Optional. Options for Kubernetes resource generation. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ResourceOptions *resourceOptions;

@end


/**
 *  List of Memberships bound to a Scope.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "memberships" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListBoundMembershipsResponse : GTLRCollectionObject

/**
 *  The list of Memberships bound to the given Scope.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Membership *> *memberships;

/**
 *  A token to request the next page of resources from the
 *  `ListBoundMemberships` method. The value of an empty string means that there
 *  are no more resources to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** List of locations that could not be reached while fetching this list. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for the `GkeHub.ListFeatures` method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resources" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListFeaturesResponse : GTLRCollectionObject

/**
 *  A token to request the next page of resources from the `ListFeatures`
 *  method. The value of an empty string means that there are no more resources
 *  to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching Features
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Feature *> *resources;

@end


/**
 *  Response message for the `GkeHub.ListFleetsResponse` method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "fleets" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListFleetsResponse : GTLRCollectionObject

/**
 *  The list of matching fleets.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Fleet *> *fleets;

/**
 *  A token, which can be sent as `page_token` to retrieve the next page. If
 *  this field is omitted, there are no subsequent pages. The token is only
 *  valid for 1h.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  List of MembershipBindings.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "membershipBindings" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRGKEHub_ListMembershipBindingsResponse : GTLRCollectionObject

/**
 *  The list of membership_bindings
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_MembershipBinding *> *membershipBindings;

/**
 *  A token to request the next page of resources from the
 *  `ListMembershipBindings` method. The value of an empty string means that
 *  there are no more resources to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for the `GkeHub.ListMemberships` method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resources" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListMembershipsResponse : GTLRCollectionObject

/**
 *  A token to request the next page of resources from the `ListMemberships`
 *  method. The value of an empty string means that there are no more resources
 *  to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching Memberships.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Membership *> *resources;

/** List of locations that could not be reached while fetching this list. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Operation *> *operations;

@end


/**
 *  List of permitted Scopes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scopes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListPermittedScopesResponse : GTLRCollectionObject

/**
 *  A token to request the next page of resources from the `ListPermittedScopes`
 *  method. The value of an empty string means that there are no more resources
 *  to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of permitted Scopes
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Scope *> *scopes;

@end


/**
 *  List of fleet namespaces.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scopeNamespaces" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRGKEHub_ListScopeNamespacesResponse : GTLRCollectionObject

/**
 *  A token to request the next page of resources from the `ListNamespaces`
 *  method. The value of an empty string means that there are no more resources
 *  to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of fleet namespaces
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Namespace *> *scopeNamespaces;

@end


/**
 *  List of Scope RBACRoleBindings.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "rbacrolebindings" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRGKEHub_ListScopeRBACRoleBindingsResponse : GTLRCollectionObject

/**
 *  A token to request the next page of resources from the
 *  `ListScopeRBACRoleBindings` method. The value of an empty string means that
 *  there are no more resources to return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of Scope RBACRoleBindings.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_RBACRoleBinding *> *rbacrolebindings;

@end


/**
 *  List of Scopes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scopes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRGKEHub_ListScopesResponse : GTLRCollectionObject

/**
 *  A token to request the next page of resources from the `ListScopes` method.
 *  The value of an empty string means that there are no more resources to
 *  return.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of Scopes
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Scope *> *scopes;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRGKEHub_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Location_Metadata : GTLRObject
@end


/**
 *  Membership contains information about a member cluster.
 */
@interface GTLRGKEHub_Membership : GTLRObject

/**
 *  Optional. How to identify workloads from this Membership. See the
 *  documentation on Workload Identity for more details:
 *  https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Authority *authority;

/** Output only. When the Membership was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the Membership was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/**
 *  Output only. Description of this membership, limited to 63 characters. Must
 *  match the regex: `a-zA-Z0-9*` This field is present for legacy purposes.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Optional. Endpoint information to reach this member. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MembershipEndpoint *endpoint;

/**
 *  Optional. An externally-generated and managed ID for this Membership. This
 *  ID may be modified after creation, but this is not recommended. The ID must
 *  match the regex: `a-zA-Z0-9*` If this Membership represents a Kubernetes
 *  cluster, this value should be set to the UID of the `kube-system` namespace
 *  object.
 */
@property(nonatomic, copy, nullable) NSString *externalId;

/** Optional. Labels for this membership. */
@property(nonatomic, strong, nullable) GTLRGKEHub_Membership_Labels *labels;

/**
 *  Output only. For clusters using Connect, the timestamp of the most recent
 *  connection established with Google Cloud. This time is updated every several
 *  minutes, not continuously. For clusters that do not use GKE Connect, or that
 *  have never connected successfully, this field will be unset.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastConnectionTime;

/** Optional. The monitoring config information for this membership. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MonitoringConfig *monitoringConfig;

/**
 *  Output only. The full, unique name of this Membership resource in the format
 *  `projects/ * /locations/ * /memberships/{membership_id}`, set during
 *  creation. `membership_id` must be a valid RFC 1123 compliant DNS label: 1.
 *  At most 63 characters in length 2. It must consist of lower case
 *  alphanumeric characters or `-` 3. It must start and end with an alphanumeric
 *  character Which can be expressed as the regex:
 *  `[a-z0-9]([-a-z0-9]*[a-z0-9])?`, with a maximum length of 63 characters.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. State of the Membership resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MembershipState *state;

/**
 *  Output only. Google-generated UUID for this resource. This is unique across
 *  all Membership resources. If a Membership resource is deleted and another
 *  resource with the same name is created, it gets a different unique_id.
 */
@property(nonatomic, copy, nullable) NSString *uniqueId;

/** Output only. When the Membership was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels for this membership.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Membership_Labels : GTLRObject
@end


/**
 *  MembershipBinding is a subresource of a Membership, representing what Fleet
 *  Scopes (or other, future Fleet resources) a Membership is bound to.
 */
@interface GTLRGKEHub_MembershipBinding : GTLRObject

/** Output only. When the membership binding was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the membership binding was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** Optional. Labels for this MembershipBinding. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MembershipBinding_Labels *labels;

/**
 *  The resource name for the membershipbinding itself
 *  `projects/{project}/locations/{location}/memberships/{membership}/bindings/{membershipbinding}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A Scope resource name in the format `projects/ * /locations/ * /scopes/ *`.
 */
@property(nonatomic, copy, nullable) NSString *scope;

/** Output only. State of the membership binding resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MembershipBindingLifecycleState *state;

/**
 *  Output only. Google-generated UUID for this resource. This is unique across
 *  all membershipbinding resources. If a membershipbinding resource is deleted
 *  and another resource with the same name is created, it gets a different uid.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. When the membership binding was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels for this MembershipBinding.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_MembershipBinding_Labels : GTLRObject
@end


/**
 *  MembershipBindingLifecycleState describes the state of a Binding resource.
 */
@interface GTLRGKEHub_MembershipBindingLifecycleState : GTLRObject

/**
 *  Output only. The current state of the MembershipBinding resource.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_MembershipBindingLifecycleState_Code_CodeUnspecified
 *        The code is not set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_MembershipBindingLifecycleState_Code_Creating The
 *        membershipbinding is being created. (Value: "CREATING")
 *    @arg @c kGTLRGKEHub_MembershipBindingLifecycleState_Code_Deleting The
 *        membershipbinding is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRGKEHub_MembershipBindingLifecycleState_Code_Ready The
 *        membershipbinding active. (Value: "READY")
 *    @arg @c kGTLRGKEHub_MembershipBindingLifecycleState_Code_Updating The
 *        membershipbinding is being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  MembershipEndpoint contains information needed to contact a Kubernetes API,
 *  endpoint and any additional Kubernetes metadata.
 */
@interface GTLRGKEHub_MembershipEndpoint : GTLRObject

/** Optional. Specific information for a GDC Edge Appliance cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ApplianceCluster *applianceCluster;

/** Optional. Specific information for a Google Edge cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_EdgeCluster *edgeCluster;

/** Optional. Specific information for a GKE-on-GCP cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_GkeCluster *gkeCluster;

/**
 *  Output only. Whether the lifecycle of this membership is managed by a google
 *  cluster platform service.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *googleManaged;

/** Output only. Useful Kubernetes-specific metadata. */
@property(nonatomic, strong, nullable) GTLRGKEHub_KubernetesMetadata *kubernetesMetadata;

/**
 *  Optional. The in-cluster Kubernetes Resources that should be applied for a
 *  correctly registered cluster, in the steady state. These resources: * Ensure
 *  that the cluster is exclusively registered to one and only one Hub
 *  Membership. * Propagate Workload Pool Information available in the
 *  Membership Authority field. * Ensure proper initial configuration of default
 *  Hub Features.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_KubernetesResource *kubernetesResource;

/** Optional. Specific information for a GKE Multi-Cloud cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_MultiCloudCluster *multiCloudCluster;

/**
 *  Optional. Specific information for a GKE On-Prem cluster. An onprem
 *  user-cluster who has no resourceLink is not allowed to use this field, it
 *  should have a nil "type" instead.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_OnPremCluster *onPremCluster;

@end


/**
 *  MembershipFeatureSpec contains configuration information for a single
 *  Membership. NOTE: Please use snake case in your feature name.
 */
@interface GTLRGKEHub_MembershipFeatureSpec : GTLRObject

/** Config Management-specific spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementMembershipSpec *configmanagement;

/** Fleet observability membership spec */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityMembershipSpec *fleetobservability;

/** Identity Service-specific spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceMembershipSpec *identityservice;

/** Anthos Service Mesh-specific spec */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshMembershipSpec *mesh;

/**
 *  Whether this per-Membership spec was inherited from a fleet-level default.
 *  This field can be updated by users by either overriding a Membership config
 *  (updated to USER implicitly) or setting to FLEET explicitly.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Origin *origin;

/** Policy Controller spec. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerMembershipSpec *policycontroller;

@end


/**
 *  MembershipFeatureState contains Feature status information for a single
 *  Membership.
 */
@interface GTLRGKEHub_MembershipFeatureState : GTLRObject

/** Appdevexperience specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_AppDevExperienceFeatureState *appdevexperience;

/** ClusterUpgrade state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ClusterUpgradeMembershipState *clusterupgrade;

/** Config Management-specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ConfigManagementMembershipState *configmanagement;

/** Fleet observability membership state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FleetObservabilityMembershipState *fleetobservability;

/** Identity Service-specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_IdentityServiceMembershipState *identityservice;

/** Policycontroller-specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerMembershipState *policycontroller;

/** Service Mesh-specific state. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshMembershipState *servicemesh;

/** The high-level state of this Feature for a single membership. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FeatureState *state;

@end


/**
 *  MembershipState describes the state of a Membership resource.
 */
@interface GTLRGKEHub_MembershipState : GTLRObject

/**
 *  Output only. The current state of the Membership resource.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_MembershipState_Code_CodeUnspecified The code is not
 *        set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_MembershipState_Code_Creating The cluster is being
 *        registered. (Value: "CREATING")
 *    @arg @c kGTLRGKEHub_MembershipState_Code_Deleting The cluster is being
 *        unregistered. (Value: "DELETING")
 *    @arg @c kGTLRGKEHub_MembershipState_Code_Ready The cluster is registered.
 *        (Value: "READY")
 *    @arg @c kGTLRGKEHub_MembershipState_Code_ServiceUpdating The Membership is
 *        being updated by the Hub Service. (Value: "SERVICE_UPDATING")
 *    @arg @c kGTLRGKEHub_MembershipState_Code_Updating The Membership is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  MonitoringConfig informs Fleet-based applications/services/UIs how the
 *  metrics for the underlying cluster is reported to cloud monitoring services.
 *  It can be set from empty to non-empty, but can't be mutated directly to
 *  prevent accidentally breaking the constinousty of metrics.
 */
@interface GTLRGKEHub_MonitoringConfig : GTLRObject

/**
 *  Optional. Cluster name used to report metrics. For Anthos on
 *  VMWare/Baremetal/MultiCloud clusters, it would be in format
 *  {cluster_type}/{cluster_name}, e.g., "awsClusters/cluster_1".
 */
@property(nonatomic, copy, nullable) NSString *cluster;

/**
 *  Optional. For GKE and Multicloud clusters, this is the UUID of the cluster
 *  resource. For VMWare and Baremetal clusters, this is the kube-system UID.
 */
@property(nonatomic, copy, nullable) NSString *clusterHash;

/**
 *  Optional. Kubernetes system metrics, if available, are written to this
 *  prefix. This defaults to kubernetes.io for GKE, and kubernetes.io/anthos for
 *  Anthos eventually. Noted: Anthos MultiCloud will have kubernetes.io prefix
 *  today but will migration to be under kubernetes.io/anthos.
 */
@property(nonatomic, copy, nullable) NSString *kubernetesMetricsPrefix;

/** Optional. Location used to report Metrics */
@property(nonatomic, copy, nullable) NSString *location;

/** Optional. Project used to report Metrics */
@property(nonatomic, copy, nullable) NSString *projectId;

@end


/**
 *  MultiCloudCluster contains information specific to GKE Multi-Cloud clusters.
 */
@interface GTLRGKEHub_MultiCloudCluster : GTLRObject

/**
 *  Output only. If cluster_missing is set then it denotes that
 *  API(gkemulticloud.googleapis.com) resource for this GKE Multi-Cloud cluster
 *  no longer exists.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *clusterMissing;

/**
 *  Immutable. Self-link of the Google Cloud resource for the GKE Multi-Cloud
 *  cluster. For example:
 *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/awsClusters/my-cluster
 *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/azureClusters/my-cluster
 *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/attachedClusters/my-cluster
 */
@property(nonatomic, copy, nullable) NSString *resourceLink;

@end


/**
 *  **Multi-cluster Ingress**: The configuration for the MultiClusterIngress
 *  feature.
 */
@interface GTLRGKEHub_MultiClusterIngressFeatureSpec : GTLRObject

/**
 *  Fully-qualified Membership name which hosts the MultiClusterIngress CRD.
 *  Example: `projects/foo-proj/locations/global/memberships/bar`
 */
@property(nonatomic, copy, nullable) NSString *configMembership;

@end


/**
 *  Namespace represents a namespace across the Fleet
 */
@interface GTLRGKEHub_Namespace : GTLRObject

/** Output only. When the namespace was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the namespace was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** Optional. Labels for this Namespace. */
@property(nonatomic, strong, nullable) GTLRGKEHub_Namespace_Labels *labels;

/**
 *  The resource name for the namespace
 *  `projects/{project}/locations/{location}/namespaces/{namespace}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Namespace-level cluster namespace labels. These labels are applied
 *  to the related namespace of the member clusters bound to the parent Scope.
 *  Scope-level labels (`namespace_labels` in the Fleet Scope resource) take
 *  precedence over Namespace-level labels if they share a key. Keys and values
 *  must be Kubernetes-conformant.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Namespace_NamespaceLabels *namespaceLabels;

/** Required. Scope associated with the namespace */
@property(nonatomic, copy, nullable) NSString *scope;

/** Output only. State of the namespace resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_NamespaceLifecycleState *state;

/**
 *  Output only. Google-generated UUID for this resource. This is unique across
 *  all namespace resources. If a namespace resource is deleted and another
 *  resource with the same name is created, it gets a different uid.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. When the namespace was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels for this Namespace.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Namespace_Labels : GTLRObject
@end


/**
 *  Optional. Namespace-level cluster namespace labels. These labels are applied
 *  to the related namespace of the member clusters bound to the parent Scope.
 *  Scope-level labels (`namespace_labels` in the Fleet Scope resource) take
 *  precedence over Namespace-level labels if they share a key. Keys and values
 *  must be Kubernetes-conformant.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Namespace_NamespaceLabels : GTLRObject
@end


/**
 *  NamespaceLifecycleState describes the state of a Namespace resource.
 */
@interface GTLRGKEHub_NamespaceLifecycleState : GTLRObject

/**
 *  Output only. The current state of the Namespace resource.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_NamespaceLifecycleState_Code_CodeUnspecified The code
 *        is not set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_NamespaceLifecycleState_Code_Creating The namespace is
 *        being created. (Value: "CREATING")
 *    @arg @c kGTLRGKEHub_NamespaceLifecycleState_Code_Deleting The namespace is
 *        being deleted. (Value: "DELETING")
 *    @arg @c kGTLRGKEHub_NamespaceLifecycleState_Code_Ready The namespace
 *        active. (Value: "READY")
 *    @arg @c kGTLRGKEHub_NamespaceLifecycleState_Code_Updating The namespace is
 *        being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  OnPremCluster contains information specific to GKE On-Prem clusters.
 */
@interface GTLRGKEHub_OnPremCluster : GTLRObject

/**
 *  Immutable. Whether the cluster is an admin cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adminCluster;

/**
 *  Output only. If cluster_missing is set then it denotes that
 *  API(gkeonprem.googleapis.com) resource for this GKE On-Prem cluster no
 *  longer exists.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *clusterMissing;

/**
 *  Immutable. The on prem cluster's type.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_OnPremCluster_ClusterType_Bootstrap The ClusterType is
 *        bootstrap cluster. (Value: "BOOTSTRAP")
 *    @arg @c kGTLRGKEHub_OnPremCluster_ClusterType_ClustertypeUnspecified The
 *        ClusterType is not set. (Value: "CLUSTERTYPE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_OnPremCluster_ClusterType_Hybrid The ClusterType is
 *        baremetal hybrid cluster. (Value: "HYBRID")
 *    @arg @c kGTLRGKEHub_OnPremCluster_ClusterType_Standalone The ClusterType
 *        is baremetal standalone cluster. (Value: "STANDALONE")
 *    @arg @c kGTLRGKEHub_OnPremCluster_ClusterType_User The ClusterType is user
 *        cluster. (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *clusterType;

/**
 *  Immutable. Self-link of the Google Cloud resource for the GKE On-Prem
 *  cluster. For example:
 *  //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/vmwareClusters/my-cluster
 *  //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/bareMetalClusters/my-cluster
 */
@property(nonatomic, copy, nullable) NSString *resourceLink;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRGKEHub_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRGKEHub_GoogleRpcStatus *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRGKEHub_Operation_Response : GTLRObject
@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRGKEHub_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have successfully been cancelled have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cancelRequested;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusDetail;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  Origin defines where this MembershipFeatureSpec originated from.
 */
@interface GTLRGKEHub_Origin : GTLRObject

/**
 *  Type specifies which type of origin is set.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_Origin_Type_Fleet Per-Membership spec was inherited
 *        from the fleet-level default. (Value: "FLEET")
 *    @arg @c kGTLRGKEHub_Origin_Type_FleetOutOfSync Per-Membership spec was
 *        inherited from the fleet-level default but is now out of sync with the
 *        current default. (Value: "FLEET_OUT_OF_SYNC")
 *    @arg @c kGTLRGKEHub_Origin_Type_TypeUnspecified Type is unknown or not
 *        set. (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_Origin_Type_User Per-Membership spec was inherited
 *        from a user specification. (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members`, or principals, to a
 *  single `role`. Principals can be user accounts, service accounts, Google
 *  groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role. For some types of Google Cloud resources, a `binding` can also
 *  specify a `condition`, which is a logical expression that allows access to a
 *  resource only if the expression evaluates to `true`. A condition can add
 *  constraints based on attributes of the request, the resource, or both. To
 *  learn which resources support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** ``` { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
 *  members: - user:mike\@example.com - group:admins\@example.com -
 *  domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 ``` For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRGKEHub_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members`, or principals, with a `role`. Optionally,
 *  may specify a `condition` that determines how and when the `bindings` are
 *  applied. Each of the `bindings` must contain at least one principal. The
 *  `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of
 *  these principals can be Google groups. Each occurrence of a principal counts
 *  towards these limits. For example, if the `bindings` grant 50 different
 *  roles to `user:alice\@example.com`, and not to any other principal, then you
 *  can add another 1,450 principals to the `bindings` in the `Policy`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Binauthz policy that applies to this cluster.
 */
@interface GTLRGKEHub_PolicyBinding : GTLRObject

/**
 *  The relative resource name of the binauthz platform policy to audit. GKE
 *  platform policies have the following format:
 *  `projects/{project_number}/platforms/gke/policies/{policy_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  BundleInstallSpec is the specification configuration for a single managed
 *  bundle.
 */
@interface GTLRGKEHub_PolicyControllerBundleInstallSpec : GTLRObject

/** The set of namespaces to be exempted from the bundle. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedNamespaces;

@end


/**
 *  Configuration for Policy Controller
 */
@interface GTLRGKEHub_PolicyControllerHubConfig : GTLRObject

/**
 *  Sets the interval for Policy Controller Audit Scans (in seconds). When set
 *  to 0, this disables audit functionality altogether.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *auditIntervalSeconds;

/**
 *  The maximum number of audit violations to be stored in a constraint. If not
 *  set, the internal default (currently 20) will be used.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *constraintViolationLimit;

/**
 *  Map of deployment configs to deployments ("admission", "audit", "mutation').
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerHubConfig_DeploymentConfigs *deploymentConfigs;

/**
 *  The set of namespaces that are excluded from Policy Controller checks.
 *  Namespaces do not need to currently exist on the cluster.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptableNamespaces;

/**
 *  The install_spec represents the intended state specified by the latest
 *  request that mutated install_spec in the feature spec, not the lifecycle
 *  state of the feature observed by the Hub feature controller that is reported
 *  in the feature state.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecDetached
 *        Request to stop all reconciliation actions by PoCo Hub controller.
 *        This is a breakglass mechanism to stop PoCo Hub from affecting cluster
 *        resources. (Value: "INSTALL_SPEC_DETACHED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecEnabled
 *        Request to install and enable Policy Controller. (Value:
 *        "INSTALL_SPEC_ENABLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecNotInstalled
 *        Request to uninstall Policy Controller. (Value:
 *        "INSTALL_SPEC_NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecSuspended
 *        Request to suspend Policy Controller i.e. its webhooks. If Policy
 *        Controller is not installed, it will be installed but suspended.
 *        (Value: "INSTALL_SPEC_SUSPENDED")
 *    @arg @c kGTLRGKEHub_PolicyControllerHubConfig_InstallSpec_InstallSpecUnspecified
 *        Spec is unknown. (Value: "INSTALL_SPEC_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *installSpec;

/**
 *  Logs all denies and dry run failures.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logDeniesEnabled;

/** Monitoring specifies the configuration of monitoring. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerMonitoringConfig *monitoring;

/**
 *  Enables the ability to mutate resources using Policy Controller.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mutationEnabled;

/** Specifies the desired policy content on the cluster */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentSpec *policyContent;

/**
 *  Enables the ability to use Constraint Templates that reference to objects
 *  other than the object currently being evaluated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *referentialRulesEnabled;

@end


/**
 *  Map of deployment configs to deployments ("admission", "audit", "mutation').
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_PolicyControllerHubConfig_DeploymentConfigs : GTLRObject
@end


/**
 *  **Policy Controller**: Configuration for a single cluster. Intended to
 *  parallel the PolicyController CR.
 */
@interface GTLRGKEHub_PolicyControllerMembershipSpec : GTLRObject

/** Policy Controller configuration for the cluster. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerHubConfig *policyControllerHubConfig;

/** Version of Policy Controller installed. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  **Policy Controller**: State for a single cluster.
 */
@interface GTLRGKEHub_PolicyControllerMembershipState : GTLRObject

/**
 *  Currently these include (also serving as map keys): 1. "admission" 2.
 *  "audit" 3. "mutation"
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerMembershipState_ComponentStates *componentStates;

/** The overall content state observed by the Hub Feature controller. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentState *policyContentState;

/**
 *  The overall Policy Controller lifecycle state observed by the Hub Feature
 *  controller.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_Active The PC is
 *        fully installed on the cluster and in an operational mode. In this
 *        state PCH will be reconciling state with the PC, and the PC will be
 *        performing it's operational tasks per that software. Entering a READY
 *        state requires that the hub has confirmed the PC is installed and its
 *        pods are operational with the version of the PC the PCH expects.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_ClusterError The
 *        PC is not operational, and the PCH is unable to act to make it
 *        operational. Entering a CLUSTER_ERROR state happens automatically when
 *        the PCH determines that a PC installed on the cluster is non-operative
 *        or that the cluster does not meet requirements set for the PCH to
 *        administer the cluster but has nevertheless been given an instruction
 *        to do so (such as 'install'). (Value: "CLUSTER_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_Decommissioning
 *        The PC may have resources on the cluster, but the PCH wishes to remove
 *        the Membership. The Membership still exists. (Value:
 *        "DECOMMISSIONING")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_Detached PoCo
 *        Hub is not taking any action to reconcile cluster objects. Changes to
 *        those objects will not be overwritten by PoCo Hub. (Value: "DETACHED")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_HubError In this
 *        state, the PC may still be operational, and only the PCH is unable to
 *        act. The hub should not issue instructions to change the PC state, or
 *        otherwise interfere with the on-cluster resources. Entering a
 *        HUB_ERROR state happens automatically when the PCH determines the hub
 *        is in an unhealthy state and it wishes to 'take hands off' to avoid
 *        corrupting the PC or other data. (Value: "HUB_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_Installing The
 *        PCH possesses a Membership, however the PC is not fully installed on
 *        the cluster. In this state the hub can be expected to be taking
 *        actions to install the PC on the cluster. (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_LifecycleStateUnspecified
 *        The lifecycle state is unspecified. (Value:
 *        "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_NotInstalled The
 *        PC does not exist on the given cluster, and no k8s resources of any
 *        type that are associated with the PC should exist there. The cluster
 *        does not possess a membership with the PCH. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_Suspended Policy
 *        Controller (PC) is installed but suspended. This means that the
 *        policies are not enforced, but violations are still recorded (through
 *        audit). (Value: "SUSPENDED")
 *    @arg @c kGTLRGKEHub_PolicyControllerMembershipState_State_Updating The PC
 *        is fully installed, but in the process of changing the configuration
 *        (including changing the version of PC either up and down, or modifying
 *        the manifests of PC) of the resources running on the cluster. The PCH
 *        has a Membership, is aware of the version the cluster should be
 *        running in, but has not confirmed for itself that the PC is running
 *        with that version. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Currently these include (also serving as map keys): 1. "admission" 2.
 *  "audit" 3. "mutation"
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerOnClusterState. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRGKEHub_PolicyControllerMembershipState_ComponentStates : GTLRObject
@end


/**
 *  MonitoringConfig specifies the backends Policy Controller should export
 *  metrics to. For example, to specify metrics should be exported to Cloud
 *  Monitoring and Prometheus, specify backends: ["cloudmonitoring",
 *  "prometheus"]
 */
@interface GTLRGKEHub_PolicyControllerMonitoringConfig : GTLRObject

/**
 *  Specifies the list of backends Policy Controller will export to. An empty
 *  list would effectively disable metrics export.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *backends;

@end


/**
 *  OnClusterState represents the state of a sub-component of Policy Controller.
 */
@interface GTLRGKEHub_PolicyControllerOnClusterState : GTLRObject

/** Surface potential errors or information logs. */
@property(nonatomic, copy, nullable) NSString *details;

/**
 *  The lifecycle state of this component.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Active The PC is
 *        fully installed on the cluster and in an operational mode. In this
 *        state PCH will be reconciling state with the PC, and the PC will be
 *        performing it's operational tasks per that software. Entering a READY
 *        state requires that the hub has confirmed the PC is installed and its
 *        pods are operational with the version of the PC the PCH expects.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_ClusterError The
 *        PC is not operational, and the PCH is unable to act to make it
 *        operational. Entering a CLUSTER_ERROR state happens automatically when
 *        the PCH determines that a PC installed on the cluster is non-operative
 *        or that the cluster does not meet requirements set for the PCH to
 *        administer the cluster but has nevertheless been given an instruction
 *        to do so (such as 'install'). (Value: "CLUSTER_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Decommissioning
 *        The PC may have resources on the cluster, but the PCH wishes to remove
 *        the Membership. The Membership still exists. (Value:
 *        "DECOMMISSIONING")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Detached PoCo Hub
 *        is not taking any action to reconcile cluster objects. Changes to
 *        those objects will not be overwritten by PoCo Hub. (Value: "DETACHED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_HubError In this
 *        state, the PC may still be operational, and only the PCH is unable to
 *        act. The hub should not issue instructions to change the PC state, or
 *        otherwise interfere with the on-cluster resources. Entering a
 *        HUB_ERROR state happens automatically when the PCH determines the hub
 *        is in an unhealthy state and it wishes to 'take hands off' to avoid
 *        corrupting the PC or other data. (Value: "HUB_ERROR")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Installing The
 *        PCH possesses a Membership, however the PC is not fully installed on
 *        the cluster. In this state the hub can be expected to be taking
 *        actions to install the PC on the cluster. (Value: "INSTALLING")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_LifecycleStateUnspecified
 *        The lifecycle state is unspecified. (Value:
 *        "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_NotInstalled The
 *        PC does not exist on the given cluster, and no k8s resources of any
 *        type that are associated with the PC should exist there. The cluster
 *        does not possess a membership with the PCH. (Value: "NOT_INSTALLED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Suspended Policy
 *        Controller (PC) is installed but suspended. This means that the
 *        policies are not enforced, but violations are still recorded (through
 *        audit). (Value: "SUSPENDED")
 *    @arg @c kGTLRGKEHub_PolicyControllerOnClusterState_State_Updating The PC
 *        is fully installed, but in the process of changing the configuration
 *        (including changing the version of PC either up and down, or modifying
 *        the manifests of PC) of the resources running on the cluster. The PCH
 *        has a Membership, is aware of the version the cluster should be
 *        running in, but has not confirmed for itself that the PC is running
 *        with that version. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  PolicyContentSpec defines the user's desired content configuration on the
 *  cluster.
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentSpec : GTLRObject

/**
 *  map of bundle name to BundleInstallSpec. The bundle name maps to the
 *  `bundleName` key in the `policycontroller.gke.io/constraintData` annotation
 *  on a constraint.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentSpec_Bundles *bundles;

/** Configures the installation of the Template Library. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerTemplateLibraryConfig *templateLibrary;

@end


/**
 *  map of bundle name to BundleInstallSpec. The bundle name maps to the
 *  `bundleName` key in the `policycontroller.gke.io/constraintData` annotation
 *  on a constraint.
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerBundleInstallSpec. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentSpec_Bundles : GTLRObject
@end


/**
 *  The state of the policy controller policy content
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentState : GTLRObject

/**
 *  The state of the any bundles included in the chosen version of the manifest
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerPolicyContentState_BundleStates *bundleStates;

/**
 *  The state of the referential data sync configuration. This could represent
 *  the state of either the syncSet object(s) or the config object, depending on
 *  the version of PoCo configured by the user.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerOnClusterState *referentialSyncConfigState;

/** The state of the template library */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerOnClusterState *templateLibraryState;

@end


/**
 *  The state of the any bundles included in the chosen version of the manifest
 *
 *  @note This class is documented as having more properties of
 *        GTLRGKEHub_PolicyControllerOnClusterState. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRGKEHub_PolicyControllerPolicyContentState_BundleStates : GTLRObject
@end


/**
 *  Deployment-specific configuration.
 */
@interface GTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig : GTLRObject

/** Container resource requirements. */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerResourceRequirements *containerResources;

/**
 *  Pod affinity configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AffinityUnspecified
 *        No affinity configuration has been specified. (Value:
 *        "AFFINITY_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_AntiAffinity
 *        Anti-affinity configuration will be applied to this deployment.
 *        Default for admissions deployment. (Value: "ANTI_AFFINITY")
 *    @arg @c kGTLRGKEHub_PolicyControllerPolicyControllerDeploymentConfig_PodAffinity_NoAffinity
 *        Affinity configurations will be removed from the deployment. (Value:
 *        "NO_AFFINITY")
 */
@property(nonatomic, copy, nullable) NSString *podAffinity;

/**
 *  Pod anti-affinity enablement. Deprecated: use `pod_affinity` instead.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *podAntiAffinity GTLR_DEPRECATED;

/** Pod tolerations of node taints. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_PolicyControllerToleration *> *podTolerations;

/**
 *  Pod replica count.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *replicaCount;

@end


/**
 *  ResourceList contains container resource requirements.
 */
@interface GTLRGKEHub_PolicyControllerResourceList : GTLRObject

/** CPU requirement expressed in Kubernetes resource units. */
@property(nonatomic, copy, nullable) NSString *cpu;

/** Memory requirement expressed in Kubernetes resource units. */
@property(nonatomic, copy, nullable) NSString *memory;

@end


/**
 *  ResourceRequirements describes the compute resource requirements.
 */
@interface GTLRGKEHub_PolicyControllerResourceRequirements : GTLRObject

/**
 *  Limits describes the maximum amount of compute resources allowed for use by
 *  the running container.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerResourceList *limits;

/**
 *  Requests describes the amount of compute resources reserved for the
 *  container by the kube-scheduler.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_PolicyControllerResourceList *requests;

@end


/**
 *  The config specifying which default library templates to install.
 */
@interface GTLRGKEHub_PolicyControllerTemplateLibraryConfig : GTLRObject

/**
 *  Configures the manner in which the template library is installed on the
 *  cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_All
 *        Install the entire template library. (Value: "ALL")
 *    @arg @c kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_InstallationUnspecified
 *        No installation strategy has been specified. (Value:
 *        "INSTALLATION_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_PolicyControllerTemplateLibraryConfig_Installation_NotInstalled
 *        Do not install the template library. (Value: "NOT_INSTALLED")
 */
@property(nonatomic, copy, nullable) NSString *installation;

@end


/**
 *  Toleration of a node taint.
 */
@interface GTLRGKEHub_PolicyControllerToleration : GTLRObject

/** Matches a taint effect. */
@property(nonatomic, copy, nullable) NSString *effect;

/** Matches a taint key (not necessarily unique). */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Matches a taint operator.
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

/** Matches a taint value. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  RBACRoleBinding represents a rbacrolebinding across the Fleet
 */
@interface GTLRGKEHub_RBACRoleBinding : GTLRObject

/** Output only. When the rbacrolebinding was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the rbacrolebinding was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** group is the group, as seen by the kubernetes cluster. */
@property(nonatomic, copy, nullable) NSString *group;

/** Optional. Labels for this RBACRolebinding. */
@property(nonatomic, strong, nullable) GTLRGKEHub_RBACRoleBinding_Labels *labels;

/**
 *  The resource name for the rbacrolebinding
 *  `projects/{project}/locations/{location}/scopes/{scope}/rbacrolebindings/{rbacrolebinding}`
 *  or
 *  `projects/{project}/locations/{location}/memberships/{membership}/rbacrolebindings/{rbacrolebinding}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Required. Role to bind to the principal */
@property(nonatomic, strong, nullable) GTLRGKEHub_Role *role;

/** Output only. State of the rbacrolebinding resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_RBACRoleBindingLifecycleState *state;

/**
 *  Output only. Google-generated UUID for this resource. This is unique across
 *  all rbacrolebinding resources. If a rbacrolebinding resource is deleted and
 *  another resource with the same name is created, it gets a different uid.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. When the rbacrolebinding was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  user is the name of the user as seen by the kubernetes cluster, example
 *  "alice" or "alice\@domain.tld"
 */
@property(nonatomic, copy, nullable) NSString *user;

@end


/**
 *  Optional. Labels for this RBACRolebinding.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_RBACRoleBinding_Labels : GTLRObject
@end


/**
 *  RBACRoleBindingLifecycleState describes the state of a RbacRoleBinding
 *  resource.
 */
@interface GTLRGKEHub_RBACRoleBindingLifecycleState : GTLRObject

/**
 *  Output only. The current state of the rbacrolebinding resource.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_CodeUnspecified The
 *        code is not set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Creating The
 *        rbacrolebinding is being created. (Value: "CREATING")
 *    @arg @c kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Deleting The
 *        rbacrolebinding is being deleted. (Value: "DELETING")
 *    @arg @c kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Ready The
 *        rbacrolebinding active. (Value: "READY")
 *    @arg @c kGTLRGKEHub_RBACRoleBindingLifecycleState_Code_Updating The
 *        rbacrolebinding is being updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  ResourceManifest represents a single Kubernetes resource to be applied to
 *  the cluster.
 */
@interface GTLRGKEHub_ResourceManifest : GTLRObject

/**
 *  Whether the resource provided in the manifest is `cluster_scoped`. If unset,
 *  the manifest is assumed to be namespace scoped. This field is used for REST
 *  mapping when applying the resource in a cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *clusterScoped;

/** YAML manifest of the resource. */
@property(nonatomic, copy, nullable) NSString *manifest;

@end


/**
 *  ResourceOptions represent options for Kubernetes resource generation.
 */
@interface GTLRGKEHub_ResourceOptions : GTLRObject

/**
 *  Optional. The Connect agent version to use for connect_resources. Defaults
 *  to the latest GKE Connect version. The version must be a currently supported
 *  version, obsolete versions will be rejected.
 */
@property(nonatomic, copy, nullable) NSString *connectVersion;

/**
 *  Optional. Major version of the Kubernetes cluster. This is only used to
 *  determine which version to use for the CustomResourceDefinition resources,
 *  `apiextensions/v1beta1` or`apiextensions/v1`.
 */
@property(nonatomic, copy, nullable) NSString *k8sVersion;

/**
 *  Optional. Use `apiextensions/v1beta1` instead of `apiextensions/v1` for
 *  CustomResourceDefinition resources. This option should be set for clusters
 *  with Kubernetes apiserver versions <1.16.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *v1beta1Crd;

@end


/**
 *  Role is the type for Kubernetes roles
 */
@interface GTLRGKEHub_Role : GTLRObject

/**
 *  predefined_role is the Kubernetes default role to use
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_Role_PredefinedRole_Admin ADMIN has EDIT and RBAC
 *        permissions (Value: "ADMIN")
 *    @arg @c kGTLRGKEHub_Role_PredefinedRole_AnthosSupport ANTHOS_SUPPORT gives
 *        Google Support read-only access to a number of cluster resources.
 *        (Value: "ANTHOS_SUPPORT")
 *    @arg @c kGTLRGKEHub_Role_PredefinedRole_Edit EDIT can edit all resources
 *        except RBAC (Value: "EDIT")
 *    @arg @c kGTLRGKEHub_Role_PredefinedRole_Unknown UNKNOWN (Value: "UNKNOWN")
 *    @arg @c kGTLRGKEHub_Role_PredefinedRole_View VIEW can only read resources
 *        (Value: "VIEW")
 */
@property(nonatomic, copy, nullable) NSString *predefinedRole;

@end


/**
 *  Scope represents a Scope in a Fleet.
 */
@interface GTLRGKEHub_Scope : GTLRObject

/** Output only. When the scope was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. When the scope was deleted. */
@property(nonatomic, strong, nullable) GTLRDateTime *deleteTime;

/** Optional. Labels for this Scope. */
@property(nonatomic, strong, nullable) GTLRGKEHub_Scope_Labels *labels;

/**
 *  The resource name for the scope
 *  `projects/{project}/locations/{location}/scopes/{scope}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. Scope-level cluster namespace labels. For the member clusters
 *  bound to the Scope, these labels are applied to each namespace under the
 *  Scope. Scope-level labels take precedence over Namespace-level labels
 *  (`namespace_labels` in the Fleet Namespace resource) if they share a key.
 *  Keys and values must be Kubernetes-conformant.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Scope_NamespaceLabels *namespaceLabels;

/** Output only. State of the scope resource. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ScopeLifecycleState *state;

/**
 *  Output only. Google-generated UUID for this resource. This is unique across
 *  all scope resources. If a scope resource is deleted and another resource
 *  with the same name is created, it gets a different uid.
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. When the scope was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Optional. Labels for this Scope.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Scope_Labels : GTLRObject
@end


/**
 *  Optional. Scope-level cluster namespace labels. For the member clusters
 *  bound to the Scope, these labels are applied to each namespace under the
 *  Scope. Scope-level labels take precedence over Namespace-level labels
 *  (`namespace_labels` in the Fleet Namespace resource) if they share a key.
 *  Keys and values must be Kubernetes-conformant.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRGKEHub_Scope_NamespaceLabels : GTLRObject
@end


/**
 *  ScopeFeatureSpec contains feature specs for a fleet scope.
 */
@interface GTLRGKEHub_ScopeFeatureSpec : GTLRObject
@end


/**
 *  ScopeFeatureState contains Scope-wide Feature status information.
 */
@interface GTLRGKEHub_ScopeFeatureState : GTLRObject

/** Output only. The "running state" of the Feature in this Scope. */
@property(nonatomic, strong, nullable) GTLRGKEHub_FeatureState *state;

@end


/**
 *  ScopeLifecycleState describes the state of a Scope resource.
 */
@interface GTLRGKEHub_ScopeLifecycleState : GTLRObject

/**
 *  Output only. The current state of the scope resource.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ScopeLifecycleState_Code_CodeUnspecified The code is
 *        not set. (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ScopeLifecycleState_Code_Creating The scope is being
 *        created. (Value: "CREATING")
 *    @arg @c kGTLRGKEHub_ScopeLifecycleState_Code_Deleting The scope is being
 *        deleted. (Value: "DELETING")
 *    @arg @c kGTLRGKEHub_ScopeLifecycleState_Code_Ready The scope active.
 *        (Value: "READY")
 *    @arg @c kGTLRGKEHub_ScopeLifecycleState_Code_Updating The scope is being
 *        updated. (Value: "UPDATING")
 */
@property(nonatomic, copy, nullable) NSString *code;

@end


/**
 *  SecurityPostureConfig defines the flags needed to enable/disable features
 *  for the Security Posture API.
 */
@interface GTLRGKEHub_SecurityPostureConfig : GTLRObject

/**
 *  Sets which mode to use for Security Posture features.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_Mode_Basic Applies Security
 *        Posture features on the cluster. (Value: "BASIC")
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_Mode_Disabled Disables Security
 *        Posture features on the cluster. (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_Mode_ModeUnspecified Default
 *        value not specified. (Value: "MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *mode;

/**
 *  Sets which mode to use for vulnerability scanning.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityBasic
 *        Applies basic vulnerability scanning on the cluster. (Value:
 *        "VULNERABILITY_BASIC")
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityDisabled
 *        Disables vulnerability scanning on the cluster. (Value:
 *        "VULNERABILITY_DISABLED")
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityEnterprise
 *        Applies the Security Posture's vulnerability on cluster Enterprise
 *        level features. (Value: "VULNERABILITY_ENTERPRISE")
 *    @arg @c kGTLRGKEHub_SecurityPostureConfig_VulnerabilityMode_VulnerabilityModeUnspecified
 *        Default value not specified. (Value: "VULNERABILITY_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *vulnerabilityMode;

@end


/**
 *  Condition being reported.
 */
@interface GTLRGKEHub_ServiceMeshCondition : GTLRObject

/**
 *  Unique identifier of the condition which describes the condition
 *  recognizable to the user.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CniConfigUnsupported CNI
 *        config unsupported error code (Value: "CNI_CONFIG_UNSUPPORTED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CniInstallationFailed CNI
 *        installation failed error code (Value: "CNI_INSTALLATION_FAILED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CniPodUnschedulable CNI pod
 *        unschedulable error code (Value: "CNI_POD_UNSCHEDULABLE")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_CodeUnspecified Default
 *        Unspecified code (Value: "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_GkeSandboxUnsupported GKE
 *        sandbox unsupported error code (Value: "GKE_SANDBOX_UNSUPPORTED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_MeshIamPermissionDenied Mesh
 *        IAM permission denied error code (Value: "MESH_IAM_PERMISSION_DENIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_NodepoolWorkloadIdentityFederationRequired
 *        Nodepool workload identity federation required error code (Value:
 *        "NODEPOOL_WORKLOAD_IDENTITY_FEDERATION_REQUIRED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Code_UnsupportedMultipleControlPlanes
 *        Multiple control planes unsupported error code (Value:
 *        "UNSUPPORTED_MULTIPLE_CONTROL_PLANES")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** A short summary about the issue. */
@property(nonatomic, copy, nullable) NSString *details;

/** Links contains actionable information. */
@property(nonatomic, copy, nullable) NSString *documentationLink;

/**
 *  Severity level of the condition.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_Error Indicates an issue
 *        that prevents the mesh from operating correctly (Value: "ERROR")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_Info An informational
 *        message, not requiring any action (Value: "INFO")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_SeverityUnspecified
 *        Unspecified severity (Value: "SEVERITY_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshCondition_Severity_Warning Indicates a
 *        setting is likely wrong, but the mesh is still able to operate (Value:
 *        "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  Status of control plane management.
 */
@interface GTLRGKEHub_ServiceMeshControlPlaneManagement : GTLRObject

/** Explanation of state. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshStatusDetails *> *details;

/**
 *  LifecycleState of control plane management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Active ACTIVE
 *        means that the component is ready for use. (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Degraded
 *        DEGRADED means that the component is ready, but operating in a
 *        degraded state. (Value: "DEGRADED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Disabled
 *        DISABLED means that the component is not enabled. (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_FailedPrecondition
 *        FAILED_PRECONDITION means that provisioning cannot proceed because of
 *        some characteristic of the member cluster. (Value:
 *        "FAILED_PRECONDITION")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_LifecycleStateUnspecified
 *        Unspecified (Value: "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_NeedsAttention
 *        NEEDS_ATTENTION means that the component is ready, but some user
 *        intervention is required. (For example that the user should migrate
 *        workloads to a new control plane revision.) (Value: "NEEDS_ATTENTION")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Provisioning
 *        PROVISIONING means that provisioning is in progress. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEHub_ServiceMeshControlPlaneManagement_State_Stalled
 *        STALLED means that provisioning could not be done. (Value: "STALLED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Status of data plane management. Only reported per-member.
 */
@interface GTLRGKEHub_ServiceMeshDataPlaneManagement : GTLRObject

/** Explanation of the status. */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshStatusDetails *> *details;

/**
 *  Lifecycle status of data plane management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Active ACTIVE
 *        means that the component is ready for use. (Value: "ACTIVE")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Degraded DEGRADED
 *        means that the component is ready, but operating in a degraded state.
 *        (Value: "DEGRADED")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Disabled DISABLED
 *        means that the component is not enabled. (Value: "DISABLED")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_FailedPrecondition
 *        FAILED_PRECONDITION means that provisioning cannot proceed because of
 *        some characteristic of the member cluster. (Value:
 *        "FAILED_PRECONDITION")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_LifecycleStateUnspecified
 *        Unspecified (Value: "LIFECYCLE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_NeedsAttention
 *        NEEDS_ATTENTION means that the component is ready, but some user
 *        intervention is required. (For example that the user should migrate
 *        workloads to a new control plane revision.) (Value: "NEEDS_ATTENTION")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Provisioning
 *        PROVISIONING means that provisioning is in progress. (Value:
 *        "PROVISIONING")
 *    @arg @c kGTLRGKEHub_ServiceMeshDataPlaneManagement_State_Stalled STALLED
 *        means that provisioning could not be done. (Value: "STALLED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  **Service Mesh**: Spec for a single Membership for the servicemesh feature
 */
@interface GTLRGKEHub_ServiceMeshMembershipSpec : GTLRObject

/**
 *  Deprecated: use `management` instead Enables automatic control plane
 *  management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshMembershipSpec_ControlPlane_Automatic
 *        Google should provision a control plane revision and make it available
 *        in the cluster. Google will enroll this revision in a release channel
 *        and keep it up to date. The control plane revision may be a managed
 *        service, or a managed install. (Value: "AUTOMATIC")
 *    @arg @c kGTLRGKEHub_ServiceMeshMembershipSpec_ControlPlane_ControlPlaneManagementUnspecified
 *        Unspecified (Value: "CONTROL_PLANE_MANAGEMENT_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_ServiceMeshMembershipSpec_ControlPlane_Manual User
 *        will manually configure the control plane (e.g. via CLI, or via the
 *        ControlPlaneRevision KRM API) (Value: "MANUAL")
 */
@property(nonatomic, copy, nullable) NSString *controlPlane GTLR_DEPRECATED;

/**
 *  Enables automatic Service Mesh management.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_ServiceMeshMembershipSpec_Management_ManagementAutomatic
 *        Google should manage my Service Mesh for the cluster. (Value:
 *        "MANAGEMENT_AUTOMATIC")
 *    @arg @c kGTLRGKEHub_ServiceMeshMembershipSpec_Management_ManagementManual
 *        User will manually configure their service mesh components. (Value:
 *        "MANAGEMENT_MANUAL")
 *    @arg @c kGTLRGKEHub_ServiceMeshMembershipSpec_Management_ManagementUnspecified
 *        Unspecified (Value: "MANAGEMENT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *management;

@end


/**
 *  **Service Mesh**: State for a single Membership, as analyzed by the Service
 *  Mesh Hub Controller.
 */
@interface GTLRGKEHub_ServiceMeshMembershipState : GTLRObject

/** Output only. List of condition reporting membership statues */
@property(nonatomic, strong, nullable) NSArray<GTLRGKEHub_ServiceMeshCondition *> *conditions;

/** Output only. Status of control plane management */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshControlPlaneManagement *controlPlaneManagement;

/** Output only. Status of data plane management. */
@property(nonatomic, strong, nullable) GTLRGKEHub_ServiceMeshDataPlaneManagement *dataPlaneManagement;

@end


/**
 *  Structured and human-readable details for a status.
 */
@interface GTLRGKEHub_ServiceMeshStatusDetails : GTLRObject

/** A machine-readable code that further describes a broad status. */
@property(nonatomic, copy, nullable) NSString *code;

/** Human-readable explanation of code. */
@property(nonatomic, copy, nullable) NSString *details;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRGKEHub_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Google Cloud services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRGKEHub_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Status specifies state for the subcomponent.
 */
@interface GTLRGKEHub_Status : GTLRObject

/**
 *  Code specifies AppDevExperienceFeature's subcomponent ready state.
 *
 *  Likely values:
 *    @arg @c kGTLRGKEHub_Status_Code_CodeUnspecified Not set. (Value:
 *        "CODE_UNSPECIFIED")
 *    @arg @c kGTLRGKEHub_Status_Code_Failed AppDevExperienceFeature's specified
 *        subcomponent ready state is false. This means AppDevExperienceFeature
 *        has encountered an issue that blocks all, or a portion, of its normal
 *        operation. See the `description` for more details. (Value: "FAILED")
 *    @arg @c kGTLRGKEHub_Status_Code_Ok AppDevExperienceFeature's specified
 *        subcomponent is ready. (Value: "OK")
 *    @arg @c kGTLRGKEHub_Status_Code_Unknown AppDevExperienceFeature's
 *        specified subcomponent has a pending or unknown state. (Value:
 *        "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Description is populated if Code is Failed, explaining why it has failed.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRGKEHub_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as `*` or `storage.*`) are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRGKEHub_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  TypeMeta is the type information needed for content unmarshalling of
 *  Kubernetes resources in the manifest.
 */
@interface GTLRGKEHub_TypeMeta : GTLRObject

/** APIVersion of the resource (e.g. v1). */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Kind of the resource (e.g. Deployment). */
@property(nonatomic, copy, nullable) NSString *kind;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
