// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Batch API (batch/v1)
// Description:
//   An API to manage the running of Batch resources on Google Cloud Platform.
// Documentation:
//   https://cloud.google.com/batch/

#import <GoogleAPIClientForREST/GTLRObject.h>

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCloudBatch_Accelerator;
@class GTLRCloudBatch_ActionCondition;
@class GTLRCloudBatch_AgentContainer;
@class GTLRCloudBatch_AgentEnvironment;
@class GTLRCloudBatch_AgentEnvironment_SecretVariables;
@class GTLRCloudBatch_AgentEnvironment_Variables;
@class GTLRCloudBatch_AgentInfo;
@class GTLRCloudBatch_AgentKMSEnvMap;
@class GTLRCloudBatch_AgentMetadata;
@class GTLRCloudBatch_AgentMetadata_OsRelease;
@class GTLRCloudBatch_AgentScript;
@class GTLRCloudBatch_AgentTask;
@class GTLRCloudBatch_AgentTaskInfo;
@class GTLRCloudBatch_AgentTaskRunnable;
@class GTLRCloudBatch_AgentTaskSpec;
@class GTLRCloudBatch_AgentTaskUserAccount;
@class GTLRCloudBatch_AgentTimingInfo;
@class GTLRCloudBatch_AllocationPolicy;
@class GTLRCloudBatch_AllocationPolicy_Labels;
@class GTLRCloudBatch_AttachedDisk;
@class GTLRCloudBatch_Barrier;
@class GTLRCloudBatch_CloudLoggingOption;
@class GTLRCloudBatch_ComputeResource;
@class GTLRCloudBatch_Container;
@class GTLRCloudBatch_Disk;
@class GTLRCloudBatch_Environment;
@class GTLRCloudBatch_Environment_SecretVariables;
@class GTLRCloudBatch_Environment_Variables;
@class GTLRCloudBatch_GCS;
@class GTLRCloudBatch_InstancePolicy;
@class GTLRCloudBatch_InstancePolicyOrTemplate;
@class GTLRCloudBatch_InstanceStatus;
@class GTLRCloudBatch_Job;
@class GTLRCloudBatch_Job_Labels;
@class GTLRCloudBatch_JobNotification;
@class GTLRCloudBatch_JobStatus;
@class GTLRCloudBatch_JobStatus_TaskGroups;
@class GTLRCloudBatch_KMSEnvMap;
@class GTLRCloudBatch_LifecyclePolicy;
@class GTLRCloudBatch_Location;
@class GTLRCloudBatch_Location_Labels;
@class GTLRCloudBatch_Location_Metadata;
@class GTLRCloudBatch_LocationPolicy;
@class GTLRCloudBatch_LogsPolicy;
@class GTLRCloudBatch_Message;
@class GTLRCloudBatch_NetworkInterface;
@class GTLRCloudBatch_NetworkPolicy;
@class GTLRCloudBatch_NFS;
@class GTLRCloudBatch_Operation;
@class GTLRCloudBatch_Operation_Metadata;
@class GTLRCloudBatch_Operation_Response;
@class GTLRCloudBatch_PlacementPolicy;
@class GTLRCloudBatch_Runnable;
@class GTLRCloudBatch_Runnable_Labels;
@class GTLRCloudBatch_Script;
@class GTLRCloudBatch_ServiceAccount;
@class GTLRCloudBatch_Status;
@class GTLRCloudBatch_Status_Details_Item;
@class GTLRCloudBatch_StatusEvent;
@class GTLRCloudBatch_Task;
@class GTLRCloudBatch_TaskExecution;
@class GTLRCloudBatch_TaskGroup;
@class GTLRCloudBatch_TaskGroupStatus;
@class GTLRCloudBatch_TaskGroupStatus_Counts;
@class GTLRCloudBatch_TaskSpec;
@class GTLRCloudBatch_TaskSpec_Environments;
@class GTLRCloudBatch_TaskStatus;
@class GTLRCloudBatch_Volume;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCloudBatch_AgentInfo.state

/**
 *  The agent is running. The agent in the RUNNING state can never go back to
 *  the STARTING state.
 *
 *  Value: "AGENT_RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentInfo_State_AgentRunning;
/**
 *  The agent is starting on the VM instance.
 *
 *  Value: "AGENT_STARTING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentInfo_State_AgentStarting;
/**
 *  Unspecified state.
 *
 *  Value: "AGENT_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentInfo_State_AgentStateUnspecified;
/**
 *  The agent has stopped, either on request or due to a failure.
 *
 *  Value: "AGENT_STOPPED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentInfo_State_AgentStopped;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_AgentTask.intendedState

/**
 *  Assigned state (includes running and finished).
 *
 *  Value: "ASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_IntendedState_Assigned;
/**
 *  The agent should cancel the execution of this task.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_IntendedState_Cancelled;
/**
 *  Delete task from agent storage, stop reporting its state.
 *
 *  Value: "DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_IntendedState_Deleted;
/**
 *  Unspecified state.
 *
 *  Value: "INTENDED_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_IntendedState_IntendedStateUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_AgentTask.taskSource

/**
 *  The AgentTask from this source is generated by Batch server. E.g. all the
 *  VMActions are from this source. When Batch Agent execute AgentTask from
 *  BATCH_INTERNAL, it will log stdout/err with "batch_agent_logs" log name.
 *
 *  Value: "BATCH_INTERNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_TaskSource_BatchInternal;
/**
 *  Unspecified task source.
 *
 *  Value: "TASK_SOURCE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_TaskSource_TaskSourceUnspecified;
/**
 *  The AgentTask from this source is provided by Batch users. When Batch Agent
 *  execute AgentTask from USER, it will log stdout/err with "batch_task_logs"
 *  log name.
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_AgentTask_TaskSource_User;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_InstancePolicy.provisioningModel

/**
 *  Preemptible VM (PVM). Above SPOT VM is the preferable model for preemptible
 *  VM instances: the old preemptible VM model (indicated by this field) is the
 *  older model, and has been migrated to use the SPOT model as the underlying
 *  technology. This old model will still be supported.
 *
 *  Value: "PREEMPTIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstancePolicy_ProvisioningModel_Preemptible;
/**
 *  Unspecified.
 *
 *  Value: "PROVISIONING_MODEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstancePolicy_ProvisioningModel_ProvisioningModelUnspecified;
/**
 *  SPOT VM.
 *
 *  Value: "SPOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstancePolicy_ProvisioningModel_Spot;
/**
 *  Standard VM.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstancePolicy_ProvisioningModel_Standard;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_InstanceStatus.provisioningModel

/**
 *  Preemptible VM (PVM). Above SPOT VM is the preferable model for preemptible
 *  VM instances: the old preemptible VM model (indicated by this field) is the
 *  older model, and has been migrated to use the SPOT model as the underlying
 *  technology. This old model will still be supported.
 *
 *  Value: "PREEMPTIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstanceStatus_ProvisioningModel_Preemptible;
/**
 *  Unspecified.
 *
 *  Value: "PROVISIONING_MODEL_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstanceStatus_ProvisioningModel_ProvisioningModelUnspecified;
/**
 *  SPOT VM.
 *
 *  Value: "SPOT"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstanceStatus_ProvisioningModel_Spot;
/**
 *  Standard VM.
 *
 *  Value: "STANDARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_InstanceStatus_ProvisioningModel_Standard;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_JobStatus.state

/**
 *  The Job will be deleted, but has not been deleted yet. Typically this is
 *  because resources used by the Job are still being cleaned up.
 *
 *  Value: "DELETION_IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_DeletionInProgress;
/**
 *  At least one Task in the Job has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_Failed;
/**
 *  Job is admitted (validated and persisted) and waiting for resources.
 *
 *  Value: "QUEUED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_Queued;
/**
 *  Resource allocation has been successful. At least one Task in the Job is
 *  RUNNING.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_Running;
/**
 *  Job is scheduled to run as soon as resource allocation is ready. The
 *  resource allocation may happen at a later time but with a high chance to
 *  succeed.
 *
 *  Value: "SCHEDULED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_Scheduled;
/**
 *  Job state unspecified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_StateUnspecified;
/**
 *  All Tasks in the Job have finished successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_JobStatus_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_LifecyclePolicy.action

/**
 *  Action unspecified.
 *
 *  Value: "ACTION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_LifecyclePolicy_Action_ActionUnspecified;
/**
 *  Action that tasks in the group will be stopped immediately.
 *
 *  Value: "FAIL_TASK"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_LifecyclePolicy_Action_FailTask;
/**
 *  Action that tasks in the group will be scheduled to re-execute.
 *
 *  Value: "RETRY_TASK"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_LifecyclePolicy_Action_RetryTask;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_LogsPolicy.destination

/**
 *  Logs are streamed to Cloud Logging.
 *
 *  Value: "CLOUD_LOGGING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_LogsPolicy_Destination_CloudLogging;
/**
 *  Logs are not preserved.
 *
 *  Value: "DESTINATION_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_LogsPolicy_Destination_DestinationUnspecified;
/**
 *  Logs are saved to a file path.
 *
 *  Value: "PATH"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_LogsPolicy_Destination_Path;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_Message.newJobState

/**
 *  The Job will be deleted, but has not been deleted yet. Typically this is
 *  because resources used by the Job are still being cleaned up.
 *
 *  Value: "DELETION_IN_PROGRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_DeletionInProgress;
/**
 *  At least one Task in the Job has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_Failed;
/**
 *  Job is admitted (validated and persisted) and waiting for resources.
 *
 *  Value: "QUEUED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_Queued;
/**
 *  Resource allocation has been successful. At least one Task in the Job is
 *  RUNNING.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_Running;
/**
 *  Job is scheduled to run as soon as resource allocation is ready. The
 *  resource allocation may happen at a later time but with a high chance to
 *  succeed.
 *
 *  Value: "SCHEDULED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_Scheduled;
/**
 *  Job state unspecified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_StateUnspecified;
/**
 *  All Tasks in the Job have finished successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewJobState_Succeeded;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_Message.newTaskState

/**
 *  The Task is assigned to at least one VM.
 *
 *  Value: "ASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_Assigned;
/**
 *  The Task has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_Failed;
/**
 *  The Task is created and waiting for resources.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_Pending;
/**
 *  The Task is running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_Running;
/**
 *  Unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_StateUnspecified;
/**
 *  The Task has succeeded.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_Succeeded;
/**
 *  The Task has not been executed when the Job finishes.
 *
 *  Value: "UNEXECUTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_NewTaskState_Unexecuted;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_Message.type

/**
 *  Notify users that the job state has changed.
 *
 *  Value: "JOB_STATE_CHANGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_Type_JobStateChanged;
/**
 *  Notify users that the task state has changed.
 *
 *  Value: "TASK_STATE_CHANGED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_Type_TaskStateChanged;
/**
 *  Unspecified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_Message_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_StatusEvent.taskState

/**
 *  The Task is assigned to at least one VM.
 *
 *  Value: "ASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_Assigned;
/**
 *  The Task has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_Failed;
/**
 *  The Task is created and waiting for resources.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_Pending;
/**
 *  The Task is running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_Running;
/**
 *  Unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_StateUnspecified;
/**
 *  The Task has succeeded.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_Succeeded;
/**
 *  The Task has not been executed when the Job finishes.
 *
 *  Value: "UNEXECUTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_StatusEvent_TaskState_Unexecuted;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_TaskGroup.schedulingPolicy

/**
 *  Run Tasks as soon as resources are available. Tasks might be executed in
 *  parallel depending on parallelism and task_count values.
 *
 *  Value: "AS_SOON_AS_POSSIBLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskGroup_SchedulingPolicy_AsSoonAsPossible;
/**
 *  Run Tasks sequentially with increased task index.
 *
 *  Value: "IN_ORDER"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskGroup_SchedulingPolicy_InOrder;
/**
 *  Unspecified.
 *
 *  Value: "SCHEDULING_POLICY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskGroup_SchedulingPolicy_SchedulingPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudBatch_TaskStatus.state

/**
 *  The Task is assigned to at least one VM.
 *
 *  Value: "ASSIGNED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_Assigned;
/**
 *  The Task has failed.
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_Failed;
/**
 *  The Task is created and waiting for resources.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_Pending;
/**
 *  The Task is running.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_Running;
/**
 *  Unknown state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_StateUnspecified;
/**
 *  The Task has succeeded.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_Succeeded;
/**
 *  The Task has not been executed when the Job finishes.
 *
 *  Value: "UNEXECUTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRCloudBatch_TaskStatus_State_Unexecuted;

/**
 *  Accelerator describes Compute Engine accelerators to be attached to the VM.
 */
@interface GTLRCloudBatch_Accelerator : GTLRObject

/**
 *  The number of accelerators of this type.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  Optional. The NVIDIA GPU driver version that should be installed for this
 *  type. You can define the specific driver version such as "470.103.01",
 *  following the driver version requirements in
 *  https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver.
 *  Batch will install the specific accelerator driver if qualified.
 */
@property(nonatomic, copy, nullable) NSString *driverVersion;

/**
 *  Deprecated: please use instances[0].install_gpu_drivers instead.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installGpuDrivers GTLR_DEPRECATED;

/**
 *  The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute
 *  accelerator-types list`.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Conditions for actions to deal with task failures.
 */
@interface GTLRCloudBatch_ActionCondition : GTLRObject

/**
 *  Exit codes of a task execution. If there are more than 1 exit codes, when
 *  task executes with any of the exit code in the list, the condition is met
 *  and the action will be executed.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *exitCodes;

@end


/**
 *  Container runnable representation on the agent side.
 */
@interface GTLRCloudBatch_AgentContainer : GTLRObject

/**
 *  Overrides the `CMD` specified in the container. If there is an ENTRYPOINT
 *  (either in the container image or with the entrypoint field below) then
 *  commands are appended as arguments to the ENTRYPOINT.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *commands;

/** Overrides the `ENTRYPOINT` specified in the container. */
@property(nonatomic, copy, nullable) NSString *entrypoint;

/** The URI to pull the container image from. */
@property(nonatomic, copy, nullable) NSString *imageUri;

/**
 *  Arbitrary additional options to include in the "docker run" command when
 *  running this container, e.g. "--network host".
 */
@property(nonatomic, copy, nullable) NSString *options;

/**
 *  Volumes to mount (bind mount) from the host machine files or directories
 *  into the container, formatted to match docker run's --volume option, e.g.
 *  /foo:/bar, or /foo:/bar:ro
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *volumes;

@end


/**
 *  AgentEnvironment is the Environment representation between Agent and CLH
 *  communication. The environment is used in both task level and agent level.
 */
@interface GTLRCloudBatch_AgentEnvironment : GTLRObject

/**
 *  An encrypted JSON dictionary where the key/value pairs correspond to
 *  environment variable names and their values.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentKMSEnvMap *encryptedVariables;

/**
 *  A map of environment variable names to Secret Manager secret names. The VM
 *  will access the named secrets to set the value of each environment variable.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentEnvironment_SecretVariables *secretVariables;

/** A map of environment variable names to values. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentEnvironment_Variables *variables;

@end


/**
 *  A map of environment variable names to Secret Manager secret names. The VM
 *  will access the named secrets to set the value of each environment variable.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_AgentEnvironment_SecretVariables : GTLRObject
@end


/**
 *  A map of environment variable names to values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_AgentEnvironment_Variables : GTLRObject
@end


/**
 *  VM Agent Info.
 */
@interface GTLRCloudBatch_AgentInfo : GTLRObject

/** Optional. The assigned Job ID */
@property(nonatomic, copy, nullable) NSString *jobId;

/** When the AgentInfo is generated. */
@property(nonatomic, strong, nullable) GTLRDateTime *reportTime;

/**
 *  Agent state.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_AgentInfo_State_AgentRunning The agent is running.
 *        The agent in the RUNNING state can never go back to the STARTING
 *        state. (Value: "AGENT_RUNNING")
 *    @arg @c kGTLRCloudBatch_AgentInfo_State_AgentStarting The agent is
 *        starting on the VM instance. (Value: "AGENT_STARTING")
 *    @arg @c kGTLRCloudBatch_AgentInfo_State_AgentStateUnspecified Unspecified
 *        state. (Value: "AGENT_STATE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_AgentInfo_State_AgentStopped The agent has
 *        stopped, either on request or due to a failure. (Value:
 *        "AGENT_STOPPED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** The assigned task group ID. */
@property(nonatomic, copy, nullable) NSString *taskGroupId;

/** Task Info. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_AgentTaskInfo *> *tasks;

@end


/**
 *  AgentKMSEnvMap contains the encrypted key/value pair to be used in the
 *  environment on the Agent side.
 */
@interface GTLRCloudBatch_AgentKMSEnvMap : GTLRObject

/** The value of the cipherText response from the `encrypt` method. */
@property(nonatomic, copy, nullable) NSString *cipherText;

/** The name of the KMS key that will be used to decrypt the cipher text. */
@property(nonatomic, copy, nullable) NSString *keyName;

@end


/**
 *  VM Agent Metadata.
 */
@interface GTLRCloudBatch_AgentMetadata : GTLRObject

/** When the VM agent started. Use agent_startup_time instead. */
@property(nonatomic, strong, nullable) GTLRDateTime *creationTime GTLR_DEPRECATED;

/**
 *  Full name of the entity that created this vm. For MIG, this path is:
 *  projects/{project}/regions/{region}/InstanceGroupManagers/{igm} The value is
 *  retrieved from the vm metadata key of "created-by".
 */
@property(nonatomic, copy, nullable) NSString *creator;

/** image version for the VM that this agent is installed on. */
@property(nonatomic, copy, nullable) NSString *imageVersion;

/** GCP instance name (go/instance-name). */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  GCP instance ID (go/instance-id).
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *instanceId;

/**
 *  If the GCP instance has received preemption notice.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *instancePreemptionNoticeReceived;

/** parsed contents of /etc/os-release */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentMetadata_OsRelease *osRelease;

/** agent binary version running on VM */
@property(nonatomic, copy, nullable) NSString *version;

/**
 *  Agent zone.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  parsed contents of /etc/os-release
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_AgentMetadata_OsRelease : GTLRObject
@end


/**
 *  Script runnable representation on the agent side.
 */
@interface GTLRCloudBatch_AgentScript : GTLRObject

/**
 *  Script file path on the host VM. To specify an interpreter, please add a
 *  `#!`(also known as [shebang
 *  line](https://en.wikipedia.org/wiki/Shebang_(Unix))) as the first line of
 *  the file.(For example, to execute the script using bash, `#!/bin/bash`
 *  should be the first line of the file. To execute the script using`Python3`,
 *  `#!/usr/bin/env python3` should be the first line of the file.) Otherwise,
 *  the file will by default be executed by `/bin/sh`.
 */
@property(nonatomic, copy, nullable) NSString *path;

/**
 *  Shell script text. To specify an interpreter, please add a `#!\\n` at the
 *  beginning of the text.(For example, to execute the script using bash,
 *  `#!/bin/bash\\n` should be added. To execute the script using`Python3`,
 *  `#!/usr/bin/env python3\\n` should be added.) Otherwise, the script will by
 *  default be executed by `/bin/sh`.
 */
@property(nonatomic, copy, nullable) NSString *text;

@end


/**
 *  TODO(b/182501497) The message needs to be redefined when the Agent API
 *  server updates data in storage per the backend design.
 */
@interface GTLRCloudBatch_AgentTask : GTLRObject

/**
 *  AgentTaskSpec is the taskSpec representation between Agent and CLH
 *  communication. This field will replace the TaskSpec field above in future to
 *  have a better separation between user-facaing API and internal API.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentTaskSpec *agentTaskSpec;

/**
 *  The intended state of the task.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_AgentTask_IntendedState_Assigned Assigned state
 *        (includes running and finished). (Value: "ASSIGNED")
 *    @arg @c kGTLRCloudBatch_AgentTask_IntendedState_Cancelled The agent should
 *        cancel the execution of this task. (Value: "CANCELLED")
 *    @arg @c kGTLRCloudBatch_AgentTask_IntendedState_Deleted Delete task from
 *        agent storage, stop reporting its state. (Value: "DELETED")
 *    @arg @c kGTLRCloudBatch_AgentTask_IntendedState_IntendedStateUnspecified
 *        Unspecified state. (Value: "INTENDED_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *intendedState;

/**
 *  The highest barrier reached by all tasks in the task's TaskGroup.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reachedBarrier;

/**
 *  Task Spec. This field will be replaced by agent_task_spec below in future.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskSpec *spec;

/** Task status. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskStatus *status;

/** Task name. */
@property(nonatomic, copy, nullable) NSString *task;

/**
 *  TaskSource represents the source of the task.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_AgentTask_TaskSource_BatchInternal The AgentTask
 *        from this source is generated by Batch server. E.g. all the VMActions
 *        are from this source. When Batch Agent execute AgentTask from
 *        BATCH_INTERNAL, it will log stdout/err with "batch_agent_logs" log
 *        name. (Value: "BATCH_INTERNAL")
 *    @arg @c kGTLRCloudBatch_AgentTask_TaskSource_TaskSourceUnspecified
 *        Unspecified task source. (Value: "TASK_SOURCE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_AgentTask_TaskSource_User The AgentTask from this
 *        source is provided by Batch users. When Batch Agent execute AgentTask
 *        from USER, it will log stdout/err with "batch_task_logs" log name.
 *        (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *taskSource;

@end


/**
 *  Task Info
 */
@interface GTLRCloudBatch_AgentTaskInfo : GTLRObject

/**
 *  The highest index of a runnable started by the agent for this task. The
 *  runnables are indexed from 1. Value 0 is undefined.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *runnable;

/** ID of the Task */
@property(nonatomic, copy, nullable) NSString *taskId;

/**
 *  The status of the Task. If we need agent specific fields we should fork the
 *  public TaskStatus into an agent specific one. Or add them below.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskStatus *taskStatus;

@end


/**
 *  AgentTaskRunnable is the Runnable representation between Agent and CLH
 *  communication.
 */
@interface GTLRCloudBatch_AgentTaskRunnable : GTLRObject

/**
 *  By default, after a Runnable fails, no further Runnable are executed. This
 *  flag indicates that this Runnable must be run even if the Task has already
 *  failed. This is useful for Runnables that copy output files off of the VM or
 *  for debugging. The always_run flag does not override the Task's overall
 *  max_run_duration. If the max_run_duration has expired then no further
 *  Runnables will execute, not even always_run Runnables.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *alwaysRun;

/**
 *  This flag allows a Runnable to continue running in the background while the
 *  Task executes subsequent Runnables. This is useful to provide services to
 *  other Runnables (or to provide debugging support tools like SSH servers).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *background;

/** Container runnable. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentContainer *container;

/**
 *  Environment variables for this Runnable (overrides variables set for the
 *  whole Task or TaskGroup).
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentEnvironment *environment;

/**
 *  Normally, a non-zero exit status causes the Task to fail. This flag allows
 *  execution of other Runnables to continue instead.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ignoreExitStatus;

/** Script runnable. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentScript *script;

/** Timeout for this Runnable. */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

@end


/**
 *  AgentTaskSpec is the user's TaskSpec representation between Agent and CLH
 *  communication.
 */
@interface GTLRCloudBatch_AgentTaskSpec : GTLRObject

/** Environment variables to set before running the Task. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentEnvironment *environment;

/**
 *  Maximum duration the task should run. The task will be killed and marked as
 *  FAILED if over this limit. The valid value range for max_run_duration in
 *  seconds is [0, 315576000000.999999999],
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxRunDuration;

/** AgentTaskRunnable is runanbles that will be executed on the agent. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_AgentTaskRunnable *> *runnables;

/**
 *  User account on the VM to run the runnables in the agentTaskSpec. If not
 *  set, the runnable will be run under root user.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentTaskUserAccount *userAccount;

@end


/**
 *  AgentTaskUserAccount contains the information of a POSIX account on the
 *  guest os which is used to execute the runnables.
 */
@interface GTLRCloudBatch_AgentTaskUserAccount : GTLRObject

/**
 *  gid id an unique identifier of the POSIX account group corresponding to the
 *  user account.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gid;

/**
 *  uid is an unique identifier of the POSIX account corresponding to the user
 *  account.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *uid;

@end


/**
 *  VM timing information
 */
@interface GTLRCloudBatch_AgentTimingInfo : GTLRObject

/** Agent startup time */
@property(nonatomic, strong, nullable) GTLRDateTime *agentStartupTime;

/** Boot timestamp of the VM OS */
@property(nonatomic, strong, nullable) GTLRDateTime *bootTime;

/** Startup time of the Batch VM script. */
@property(nonatomic, strong, nullable) GTLRDateTime *scriptStartupTime;

@end


/**
 *  A Job's resource allocation policy describes when, where, and how compute
 *  resources should be allocated for the Job.
 */
@interface GTLRCloudBatch_AllocationPolicy : GTLRObject

/**
 *  Describe instances that can be created by this AllocationPolicy. Only
 *  instances[0] is supported now.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_InstancePolicyOrTemplate *> *instances;

/**
 *  Labels applied to all VM instances and other resources created by
 *  AllocationPolicy. Labels could be user provided or system generated. You can
 *  assign up to 64 labels. [Google Compute Engine label
 *  restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions)
 *  apply. Label names that start with "goog-" or "google-" are reserved.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AllocationPolicy_Labels *labels;

/** Location where compute resources should be allocated for the Job. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_LocationPolicy *location;

/**
 *  The network policy. If you define an instance template in the
 *  `InstancePolicyOrTemplate` field, Batch will use the network settings in the
 *  instance template instead of this field.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_NetworkPolicy *network;

/** The placement policy. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_PlacementPolicy *placement;

/**
 *  Defines the service account for Batch-created VMs. If omitted, the [default
 *  Compute Engine service
 *  account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
 *  is used. Must match the service account specified in any used instance
 *  template configured in the Batch job. Includes the following fields: *
 *  email: The service account's email address. If not set, the default Compute
 *  Engine service account is used. * scopes: Additional OAuth scopes to grant
 *  the service account, beyond the default cloud-platform scope. (list of
 *  strings)
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_ServiceAccount *serviceAccount;

/**
 *  Optional. Tags applied to the VM instances. The tags identify valid sources
 *  or targets for network firewalls. Each tag must be 1-63 characters long, and
 *  comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  Labels applied to all VM instances and other resources created by
 *  AllocationPolicy. Labels could be user provided or system generated. You can
 *  assign up to 64 labels. [Google Compute Engine label
 *  restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions)
 *  apply. Label names that start with "goog-" or "google-" are reserved.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_AllocationPolicy_Labels : GTLRObject
@end


/**
 *  A new or an existing persistent disk (PD) or a local ssd attached to a VM
 *  instance.
 */
@interface GTLRCloudBatch_AttachedDisk : GTLRObject

/**
 *  Device name that the guest operating system will see. It is used by
 *  Runnable.volumes field to mount disks. So please specify the device_name if
 *  you want Batch to help mount the disk, and it should match the device_name
 *  field in volumes.
 */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** Name of an existing PD. */
@property(nonatomic, copy, nullable) NSString *existingDisk;

@property(nonatomic, strong, nullable) GTLRCloudBatch_Disk *newDisk NS_RETURNS_NOT_RETAINED;

@end


/**
 *  Barrier runnable blocks until all tasks in a taskgroup reach it.
 */
@interface GTLRCloudBatch_Barrier : GTLRObject

/**
 *  Barriers are identified by their index in runnable list. Names are not
 *  required, but if present should be an identifier.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRCloudBatch_CancelOperationRequest : GTLRObject
@end


/**
 *  `CloudLoggingOption` contains additional settings for Cloud Logging logs
 *  generated by Batch job.
 */
@interface GTLRCloudBatch_CloudLoggingOption : GTLRObject

/**
 *  Optional. Set this flag to true to change the [monitored resource
 *  type](https://cloud.google.com/monitoring/api/resources) for Cloud Logging
 *  logs generated by this Batch job from the
 *  [`batch.googleapis.com/Job`](https://cloud.google.com/monitoring/api/resources#tag_batch.googleapis.com/Job)
 *  type to the formerly used
 *  [`generic_task`](https://cloud.google.com/monitoring/api/resources#tag_generic_task)
 *  type.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useGenericTaskMonitoredResource;

@end


/**
 *  Compute resource requirements. ComputeResource defines the amount of
 *  resources required for each task. Make sure your tasks have enough resources
 *  to successfully run. If you also define the types of resources for a job to
 *  use with the
 *  [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate)
 *  field, make sure both fields are compatible with each other.
 */
@interface GTLRCloudBatch_ComputeResource : GTLRObject

/**
 *  Extra boot disk size in MiB for each task.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bootDiskMib;

/**
 *  The milliCPU count. `cpuMilli` defines the amount of CPU resources per task
 *  in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If
 *  undefined, the default value is `2000`. If you also define the VM's machine
 *  type using the `machineType` in
 *  [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy)
 *  field or inside the `instanceTemplate` in the
 *  [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate)
 *  field, make sure the CPU resources for both fields are compatible with each
 *  other and with how many tasks you want to allow to run on the same VM at the
 *  same time. For example, if you specify the `n2-standard-2` machine type,
 *  which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than
 *  `2000`, or you are recommended to run two tasks on the same VM if you set
 *  `cpuMilli` to `1000` or less.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cpuMilli;

/**
 *  Memory in MiB. `memoryMib` defines the amount of memory per task in MiB
 *  units. If undefined, the default value is `2000`. If you also define the
 *  VM's machine type using the `machineType` in
 *  [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy)
 *  field or inside the `instanceTemplate` in the
 *  [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate)
 *  field, make sure the memory resources for both fields are compatible with
 *  each other and with how many tasks you want to allow to run on the same VM
 *  at the same time. For example, if you specify the `n2-standard-2` machine
 *  type, which has 8 GiB each, you are recommended to set `memoryMib` to no
 *  more than `8192`, or you are recommended to run two tasks on the same VM if
 *  you set `memoryMib` to `4096` or less.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryMib;

@end


/**
 *  Container runnable.
 */
@interface GTLRCloudBatch_Container : GTLRObject

/**
 *  If set to true, external network access to and from container will be
 *  blocked, containers that are with block_external_network as true can still
 *  communicate with each other, network cannot be specified in the
 *  `container.options` field.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockExternalNetwork;

/**
 *  Overrides the `CMD` specified in the container. If there is an ENTRYPOINT
 *  (either in the container image or with the entrypoint field below) then
 *  commands are appended as arguments to the ENTRYPOINT.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *commands;

/**
 *  Optional. If set to true, this container runnable uses Image streaming. Use
 *  Image streaming to allow the runnable to initialize without waiting for the
 *  entire container image to download, which can significantly reduce startup
 *  time for large container images. When `enableImageStreaming` is set to true,
 *  the container runtime is [containerd](https://containerd.io/) instead of
 *  Docker. Additionally, this container runnable only supports the following
 *  `container` subfields: `imageUri`, `commands[]`, `entrypoint`, and
 *  `volumes[]`; any other `container` subfields are ignored. For more
 *  information about the requirements and limitations for using Image streaming
 *  with Batch, see the [`image-streaming` sample on
 *  GitHub](https://github.com/GoogleCloudPlatform/batch-samples/tree/main/api-samples/image-streaming).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableImageStreaming;

/** Overrides the `ENTRYPOINT` specified in the container. */
@property(nonatomic, copy, nullable) NSString *entrypoint;

/** The URI to pull the container image from. */
@property(nonatomic, copy, nullable) NSString *imageUri;

/**
 *  Arbitrary additional options to include in the "docker run" command when
 *  running this container, e.g. "--network host".
 */
@property(nonatomic, copy, nullable) NSString *options;

/**
 *  Required if the container image is from a private Docker registry. The
 *  password to login to the Docker registry that contains the image. For
 *  security, it is strongly recommended to specify an encrypted password by
 *  using a Secret Manager secret: `projects/ * /secrets/ * /versions/ *`.
 *  Warning: If you specify the password using plain text, you risk the password
 *  being exposed to any users who can view the job or its logs. To avoid this
 *  risk, specify a secret that contains the password instead. Learn more about
 *  [Secret Manager](https://cloud.google.com/secret-manager/docs/) and [using
 *  Secret Manager with
 *  Batch](https://cloud.google.com/batch/docs/create-run-job-secret-manager).
 */
@property(nonatomic, copy, nullable) NSString *password;

/**
 *  Required if the container image is from a private Docker registry. The
 *  username to login to the Docker registry that contains the image. You can
 *  either specify the username directly by using plain text or specify an
 *  encrypted username by using a Secret Manager secret: `projects/ * /secrets/
 *  * /versions/ *`. However, using a secret is recommended for enhanced
 *  security. Caution: If you specify the username using plain text, you risk
 *  the username being exposed to any users who can view the job or its logs. To
 *  avoid this risk, specify a secret that contains the username instead. Learn
 *  more about [Secret Manager](https://cloud.google.com/secret-manager/docs/)
 *  and [using Secret Manager with
 *  Batch](https://cloud.google.com/batch/docs/create-run-job-secret-manager).
 */
@property(nonatomic, copy, nullable) NSString *username;

/**
 *  Volumes to mount (bind mount) from the host machine files or directories
 *  into the container, formatted to match docker run's --volume option, e.g.
 *  /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but
 *  this field is not, Batch will mount each volume from the host machine to the
 *  container with the same mount path by default. In this case, the default
 *  mount option for containers will be read-only (ro) for existing persistent
 *  disks and read-write (rw) for other volume types, regardless of the original
 *  mount options specified in `TaskSpec.Volumes`. If you need different mount
 *  settings, you can explicitly configure them in this field.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *volumes;

@end


/**
 *  A new persistent disk or a local ssd. A VM can only have one local SSD
 *  setting but multiple local SSD partitions. See
 *  https://cloud.google.com/compute/docs/disks#pdspecs and
 *  https://cloud.google.com/compute/docs/disks#localssds.
 */
@interface GTLRCloudBatch_Disk : GTLRObject

/**
 *  Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not
 *  indicated, "NVMe" will be the default one for local ssds. This field is
 *  ignored for persistent disks as the interface is chosen automatically. See
 *  https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
 */
@property(nonatomic, copy, nullable) NSString *diskInterface;

/**
 *  URL for a VM image to use as the data source for this disk. For example, the
 *  following are all valid URLs: * Specify the image by its family name:
 *  projects/{project}/global/images/family/{image_family} * Specify the image
 *  version: projects/{project}/global/images/{image_version} You can also use
 *  Batch customized image in short names. The following image values are
 *  supported for a boot disk: * `batch-debian`: use Batch Debian images. *
 *  `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch
 *  Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS
 *  images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
 */
@property(nonatomic, copy, nullable) NSString *image;

/**
 *  Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent
 *  disk, this field is ignored if `data_source` is set as `image` or
 *  `snapshot`. If the `type` specifies a local SSD, this field should be a
 *  multiple of 375 GB, otherwise, the final size will be the next greater
 *  multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size
 *  based on source image and task requirements if you do not speicify the size.
 *  If both this field and the `boot_disk_mib` field in task spec's
 *  `compute_resource` are defined, Batch will only honor this field. Also, this
 *  field should be no smaller than the source disk's size when the
 *  `data_source` is set as `snapshot` or `image`. For example, if you set an
 *  image as the `data_source` field and the image's default disk size 30 GB,
 *  you can only use this field to make the disk larger or equal to 30 GB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeGb;

/**
 *  Name of a snapshot used as the data source. Snapshot is not supported as
 *  boot disk now.
 */
@property(nonatomic, copy, nullable) NSString *snapshot;

/**
 *  Disk type as shown in `gcloud compute disk-types list`. For example, local
 *  SSD uses type "local-ssd". Persistent disks and boot disks use
 *  "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
 */
@interface GTLRCloudBatch_Empty : GTLRObject
@end


/**
 *  An Environment describes a collection of environment variables to set when
 *  executing Tasks.
 */
@interface GTLRCloudBatch_Environment : GTLRObject

/**
 *  An encrypted JSON dictionary where the key/value pairs correspond to
 *  environment variable names and their values.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_KMSEnvMap *encryptedVariables;

/**
 *  A map of environment variable names to Secret Manager secret names. The VM
 *  will access the named secrets to set the value of each environment variable.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Environment_SecretVariables *secretVariables;

/** A map of environment variable names to values. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Environment_Variables *variables;

@end


/**
 *  A map of environment variable names to Secret Manager secret names. The VM
 *  will access the named secrets to set the value of each environment variable.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_Environment_SecretVariables : GTLRObject
@end


/**
 *  A map of environment variable names to values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_Environment_Variables : GTLRObject
@end


/**
 *  Represents a Google Cloud Storage volume.
 */
@interface GTLRCloudBatch_GCS : GTLRObject

/**
 *  Remote path, either a bucket name or a subdirectory of a bucket, e.g.:
 *  bucket_name, bucket_name/subdirectory/
 */
@property(nonatomic, copy, nullable) NSString *remotePath;

@end


/**
 *  InstancePolicy describes an instance type and resources attached to each VM
 *  created by this InstancePolicy.
 */
@interface GTLRCloudBatch_InstancePolicy : GTLRObject

/** The accelerators attached to each VM instance. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Accelerator *> *accelerators;

/**
 *  Boot disk to be created and attached to each VM by this InstancePolicy. Boot
 *  disk will be deleted when the VM is deleted. Batch API now only supports
 *  booting from image.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Disk *bootDisk;

/**
 *  Non-boot disks to be attached for each VM created by this InstancePolicy.
 *  New disks will be deleted when the VM is deleted. A non-boot disk is a disk
 *  that can be of a device with a file system or a raw storage drive that is
 *  not ready for data storage and accessing.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_AttachedDisk *> *disks;

/** The Compute Engine machine type. */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  The minimum CPU platform. See
 *  https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
 */
@property(nonatomic, copy, nullable) NSString *minCpuPlatform;

/**
 *  The provisioning model.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_InstancePolicy_ProvisioningModel_Preemptible
 *        Preemptible VM (PVM). Above SPOT VM is the preferable model for
 *        preemptible VM instances: the old preemptible VM model (indicated by
 *        this field) is the older model, and has been migrated to use the SPOT
 *        model as the underlying technology. This old model will still be
 *        supported. (Value: "PREEMPTIBLE")
 *    @arg @c kGTLRCloudBatch_InstancePolicy_ProvisioningModel_ProvisioningModelUnspecified
 *        Unspecified. (Value: "PROVISIONING_MODEL_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_InstancePolicy_ProvisioningModel_Spot SPOT VM.
 *        (Value: "SPOT")
 *    @arg @c kGTLRCloudBatch_InstancePolicy_ProvisioningModel_Standard Standard
 *        VM. (Value: "STANDARD")
 */
@property(nonatomic, copy, nullable) NSString *provisioningModel;

/**
 *  Optional. If specified, VMs will consume only the specified reservation. If
 *  not specified (default), VMs will consume any applicable reservation.
 */
@property(nonatomic, copy, nullable) NSString *reservation;

@end


/**
 *  InstancePolicyOrTemplate lets you define the type of resources to use for
 *  this job either with an InstancePolicy or an instance template. If
 *  undefined, Batch picks the type of VM to use and doesn't include optional VM
 *  resources such as GPUs and extra disks.
 */
@interface GTLRCloudBatch_InstancePolicyOrTemplate : GTLRObject

/**
 *  Set this field true if users want Batch to help fetch drivers from a third
 *  party location and install them for GPUs specified in policy.accelerators or
 *  instance_template on their behalf. Default is false. For Container-Optimized
 *  Image cases, Batch will install the accelerator driver following milestones
 *  of https://cloud.google.com/container-optimized-os/docs/release-notes. For
 *  non Container-Optimized Image cases, following
 *  https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installGpuDrivers;

/**
 *  Name of an instance template used to create VMs. Named the field as
 *  'instance_template' instead of 'template' to avoid c++ keyword conflict.
 */
@property(nonatomic, copy, nullable) NSString *instanceTemplate;

/** InstancePolicy. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_InstancePolicy *policy;

@end


/**
 *  VM instance status.
 */
@interface GTLRCloudBatch_InstanceStatus : GTLRObject

/** The VM boot disk. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Disk *bootDisk;

/** The Compute Engine machine type. */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  The VM instance provisioning model.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_InstanceStatus_ProvisioningModel_Preemptible
 *        Preemptible VM (PVM). Above SPOT VM is the preferable model for
 *        preemptible VM instances: the old preemptible VM model (indicated by
 *        this field) is the older model, and has been migrated to use the SPOT
 *        model as the underlying technology. This old model will still be
 *        supported. (Value: "PREEMPTIBLE")
 *    @arg @c kGTLRCloudBatch_InstanceStatus_ProvisioningModel_ProvisioningModelUnspecified
 *        Unspecified. (Value: "PROVISIONING_MODEL_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_InstanceStatus_ProvisioningModel_Spot SPOT VM.
 *        (Value: "SPOT")
 *    @arg @c kGTLRCloudBatch_InstanceStatus_ProvisioningModel_Standard Standard
 *        VM. (Value: "STANDARD")
 */
@property(nonatomic, copy, nullable) NSString *provisioningModel;

/**
 *  The max number of tasks can be assigned to this instance type.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *taskPack;

@end


/**
 *  The Cloud Batch Job description.
 */
@interface GTLRCloudBatch_Job : GTLRObject

/** Compute resource allocation for all TaskGroups in the Job. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AllocationPolicy *allocationPolicy;

/** Output only. When the Job was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Labels for the Job. Labels could be user provided or system generated. For
 *  example, "labels": { "department": "finance", "environment": "test" } You
 *  can assign up to 64 labels. [Google Compute Engine label
 *  restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions)
 *  apply. Label names that start with "goog-" or "google-" are reserved.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Job_Labels *labels;

/** Log preservation policy for the Job. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_LogsPolicy *logsPolicy;

/**
 *  Output only. Job name. For example:
 *  "projects/123456/locations/us-central1/jobs/job01".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Notification configurations. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_JobNotification *> *notifications;

/**
 *  Priority of the Job. The valid value range is [0, 100). Default value is 0.
 *  Higher value indicates higher priority. A job with higher priority value is
 *  more likely to run earlier if all other requirements are satisfied.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/** Output only. Job status. It is read only for users. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_JobStatus *status;

/** Required. TaskGroups in the Job. Only one TaskGroup is supported now. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_TaskGroup *> *taskGroups;

/** Output only. A system generated unique ID for the Job. */
@property(nonatomic, copy, nullable) NSString *uid;

/** Output only. The last time the Job was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Labels for the Job. Labels could be user provided or system generated. For
 *  example, "labels": { "department": "finance", "environment": "test" } You
 *  can assign up to 64 labels. [Google Compute Engine label
 *  restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions)
 *  apply. Label names that start with "goog-" or "google-" are reserved.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_Job_Labels : GTLRObject
@end


/**
 *  Notification configurations.
 */
@interface GTLRCloudBatch_JobNotification : GTLRObject

/**
 *  The attribute requirements of messages to be sent to this Pub/Sub topic.
 *  Without this field, no message will be sent.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Message *message;

/**
 *  The Pub/Sub topic where notifications like the job state changes will be
 *  published. The topic must exist in the same project as the job and billings
 *  will be charged to this project. If not specified, no Pub/Sub messages will
 *  be sent. Topic format: `projects/{project}/topics/{topic}`.
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

@end


/**
 *  Job status.
 */
@interface GTLRCloudBatch_JobStatus : GTLRObject

/** The duration of time that the Job spent in status RUNNING. */
@property(nonatomic, strong, nullable) GTLRDuration *runDuration;

/**
 *  Job state
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_JobStatus_State_DeletionInProgress The Job will be
 *        deleted, but has not been deleted yet. Typically this is because
 *        resources used by the Job are still being cleaned up. (Value:
 *        "DELETION_IN_PROGRESS")
 *    @arg @c kGTLRCloudBatch_JobStatus_State_Failed At least one Task in the
 *        Job has failed. (Value: "FAILED")
 *    @arg @c kGTLRCloudBatch_JobStatus_State_Queued Job is admitted (validated
 *        and persisted) and waiting for resources. (Value: "QUEUED")
 *    @arg @c kGTLRCloudBatch_JobStatus_State_Running Resource allocation has
 *        been successful. At least one Task in the Job is RUNNING. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRCloudBatch_JobStatus_State_Scheduled Job is scheduled to run
 *        as soon as resource allocation is ready. The resource allocation may
 *        happen at a later time but with a high chance to succeed. (Value:
 *        "SCHEDULED")
 *    @arg @c kGTLRCloudBatch_JobStatus_State_StateUnspecified Job state
 *        unspecified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_JobStatus_State_Succeeded All Tasks in the Job
 *        have finished successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Job status events */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_StatusEvent *> *statusEvents;

/**
 *  Aggregated task status for each TaskGroup in the Job. The map key is
 *  TaskGroup ID.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_JobStatus_TaskGroups *taskGroups;

@end


/**
 *  Aggregated task status for each TaskGroup in the Job. The map key is
 *  TaskGroup ID.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudBatch_TaskGroupStatus. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudBatch_JobStatus_TaskGroups : GTLRObject
@end


/**
 *  GTLRCloudBatch_KMSEnvMap
 */
@interface GTLRCloudBatch_KMSEnvMap : GTLRObject

/** The value of the cipherText response from the `encrypt` method. */
@property(nonatomic, copy, nullable) NSString *cipherText;

/** The name of the KMS key that will be used to decrypt the cipher text. */
@property(nonatomic, copy, nullable) NSString *keyName;

@end


/**
 *  LifecyclePolicy describes how to deal with task failures based on different
 *  conditions.
 */
@interface GTLRCloudBatch_LifecyclePolicy : GTLRObject

/**
 *  Action to execute when ActionCondition is true. When RETRY_TASK is
 *  specified, we will retry failed tasks if we notice any exit code match and
 *  fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we
 *  will fail tasks if we notice any exit code match and retry tasks if no match
 *  is found.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_LifecyclePolicy_Action_ActionUnspecified Action
 *        unspecified. (Value: "ACTION_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_LifecyclePolicy_Action_FailTask Action that tasks
 *        in the group will be stopped immediately. (Value: "FAIL_TASK")
 *    @arg @c kGTLRCloudBatch_LifecyclePolicy_Action_RetryTask Action that tasks
 *        in the group will be scheduled to re-execute. (Value: "RETRY_TASK")
 */
@property(nonatomic, copy, nullable) NSString *action;

/**
 *  Conditions that decide why a task failure is dealt with a specific action.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_ActionCondition *actionCondition;

@end


/**
 *  ListJob Response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobs" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudBatch_ListJobsResponse : GTLRCollectionObject

/**
 *  Jobs.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Job *> *jobs;

/** Next page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudBatch_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudBatch_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Operation *> *operations;

@end


/**
 *  ListTasks Response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "tasks" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudBatch_ListTasksResponse : GTLRCollectionObject

/** Next page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Tasks.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Task *> *tasks;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  A resource that represents a Google Cloud location.
 */
@interface GTLRCloudBatch_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudBatch_Location_Metadata : GTLRObject
@end


/**
 *  GTLRCloudBatch_LocationPolicy
 */
@interface GTLRCloudBatch_LocationPolicy : GTLRObject

/**
 *  A list of allowed location names represented by internal URLs. Each location
 *  can be a region or a zone. Only one region or multiple zones in one region
 *  is supported now. For example, ["regions/us-central1"] allow VMs in any
 *  zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"]
 *  only allow VMs in zones us-central1-a and us-central1-c. All locations end
 *  up in different regions would cause errors. For example,
 *  ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b",
 *  "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An
 *  error is expected in this case.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *allowedLocations;

@end


/**
 *  LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be
 *  preserved.
 */
@interface GTLRCloudBatch_LogsPolicy : GTLRObject

/**
 *  Optional. Additional settings for Cloud Logging. It will only take effect
 *  when the destination of `LogsPolicy` is set to `CLOUD_LOGGING`.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_CloudLoggingOption *cloudLoggingOption;

/**
 *  Where logs should be saved.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_LogsPolicy_Destination_CloudLogging Logs are
 *        streamed to Cloud Logging. (Value: "CLOUD_LOGGING")
 *    @arg @c kGTLRCloudBatch_LogsPolicy_Destination_DestinationUnspecified Logs
 *        are not preserved. (Value: "DESTINATION_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_LogsPolicy_Destination_Path Logs are saved to a
 *        file path. (Value: "PATH")
 */
@property(nonatomic, copy, nullable) NSString *destination;

/**
 *  The path to which logs are saved when the destination = PATH. This can be a
 *  local file path on the VM, or under the mount point of a Persistent Disk or
 *  Filestore, or a Cloud Storage path.
 */
@property(nonatomic, copy, nullable) NSString *logsPath;

@end


/**
 *  Message details. Describe the conditions under which messages will be sent.
 *  If no attribute is defined, no message will be sent by default. One message
 *  should specify either the job or the task level attributes, but not both.
 *  For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state;
 *  task level: TASK_STATE_CHANGED and/or a specified new_task_state.
 */
@interface GTLRCloudBatch_Message : GTLRObject

/**
 *  The new job state.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_DeletionInProgress The Job
 *        will be deleted, but has not been deleted yet. Typically this is
 *        because resources used by the Job are still being cleaned up. (Value:
 *        "DELETION_IN_PROGRESS")
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_Failed At least one Task in
 *        the Job has failed. (Value: "FAILED")
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_Queued Job is admitted
 *        (validated and persisted) and waiting for resources. (Value: "QUEUED")
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_Running Resource allocation
 *        has been successful. At least one Task in the Job is RUNNING. (Value:
 *        "RUNNING")
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_Scheduled Job is scheduled to
 *        run as soon as resource allocation is ready. The resource allocation
 *        may happen at a later time but with a high chance to succeed. (Value:
 *        "SCHEDULED")
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_StateUnspecified Job state
 *        unspecified. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_Message_NewJobState_Succeeded All Tasks in the Job
 *        have finished successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *newJobState NS_RETURNS_NOT_RETAINED;

/**
 *  The new task state.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_Assigned The Task is assigned
 *        to at least one VM. (Value: "ASSIGNED")
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_Failed The Task has failed.
 *        (Value: "FAILED")
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_Pending The Task is created
 *        and waiting for resources. (Value: "PENDING")
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_Running The Task is running.
 *        (Value: "RUNNING")
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_StateUnspecified Unknown
 *        state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_Succeeded The Task has
 *        succeeded. (Value: "SUCCEEDED")
 *    @arg @c kGTLRCloudBatch_Message_NewTaskState_Unexecuted The Task has not
 *        been executed when the Job finishes. (Value: "UNEXECUTED")
 */
@property(nonatomic, copy, nullable) NSString *newTaskState NS_RETURNS_NOT_RETAINED;

/**
 *  The message type.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_Message_Type_JobStateChanged Notify users that the
 *        job state has changed. (Value: "JOB_STATE_CHANGED")
 *    @arg @c kGTLRCloudBatch_Message_Type_TaskStateChanged Notify users that
 *        the task state has changed. (Value: "TASK_STATE_CHANGED")
 *    @arg @c kGTLRCloudBatch_Message_Type_TypeUnspecified Unspecified. (Value:
 *        "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A network interface.
 */
@interface GTLRCloudBatch_NetworkInterface : GTLRObject

/**
 *  The URL of an existing network resource. You can specify the network as a
 *  full or partial URL. For example, the following are all valid URLs: *
 *  https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
 *  * projects/{project}/global/networks/{network} * global/networks/{network}
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Default is false (with an external IP address). Required if no external
 *  public IP address is attached to the VM. If no external public IP address,
 *  additional configuration is required to allow the VM to access Google
 *  Services. See
 *  https://cloud.google.com/vpc/docs/configure-private-google-access and
 *  https://cloud.google.com/nat/docs/gce-example#create-nat for more
 *  information.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *noExternalIpAddress;

/**
 *  The URL of an existing subnetwork resource in the network. You can specify
 *  the subnetwork as a full or partial URL. For example, the following are all
 *  valid URLs: *
 *  https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork}
 *  * projects/{project}/regions/{region}/subnetworks/{subnetwork} *
 *  regions/{region}/subnetworks/{subnetwork}
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

@end


/**
 *  NetworkPolicy describes VM instance network configurations.
 */
@interface GTLRCloudBatch_NetworkPolicy : GTLRObject

/** Network configurations. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_NetworkInterface *> *networkInterfaces;

@end


/**
 *  Represents an NFS volume.
 */
@interface GTLRCloudBatch_NFS : GTLRObject

/** Remote source path exported from the NFS, e.g., "/share". */
@property(nonatomic, copy, nullable) NSString *remotePath;

/** The IP address of the NFS. */
@property(nonatomic, copy, nullable) NSString *server;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRCloudBatch_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudBatch_Operation_Metadata : GTLRObject
@end


/**
 *  The normal, successful response of the operation. If the original method
 *  returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudBatch_Operation_Response : GTLRObject
@end


/**
 *  Represents the metadata of the long-running operation.
 */
@interface GTLRCloudBatch_OperationMetadata : GTLRObject

/** Output only. API version used to start the operation. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** Output only. The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. Identifies whether the user has requested cancellation of the
 *  operation. Operations that have successfully been cancelled have
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedCancellation;

/** Output only. Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  Output only. Server-defined resource path for the target of the operation.
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Output only. Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  PlacementPolicy describes a group placement policy for the VMs controlled by
 *  this AllocationPolicy.
 */
@interface GTLRCloudBatch_PlacementPolicy : GTLRObject

/**
 *  UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you
 *  want VMs to be located close to each other for low network latency between
 *  the VMs. No placement policy will be generated when collocation is
 *  UNSPECIFIED.
 */
@property(nonatomic, copy, nullable) NSString *collocation;

/**
 *  When specified, causes the job to fail if more than max_distance logical
 *  switches are required between VMs. Batch uses the most compact possible
 *  placement of VMs even when max_distance is not specified. An explicit
 *  max_distance makes that level of compactness a strict requirement. Not yet
 *  implemented
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxDistance;

@end


/**
 *  Request to report agent's state. The Request itself implies the agent is
 *  healthy.
 */
@interface GTLRCloudBatch_ReportAgentStateRequest : GTLRObject

/** Agent info. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentInfo *agentInfo;

/** Agent timing info. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentTimingInfo *agentTimingInfo;

/** Agent metadata. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_AgentMetadata *metadata;

@end


/**
 *  Response to ReportAgentStateRequest.
 */
@interface GTLRCloudBatch_ReportAgentStateResponse : GTLRObject

/** Default report interval override */
@property(nonatomic, strong, nullable) GTLRDuration *defaultReportInterval;

/** Minimum report interval override */
@property(nonatomic, strong, nullable) GTLRDuration *minReportInterval;

/** Tasks assigned to the agent */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_AgentTask *> *tasks;

/**
 *  If true, the cloud logging for batch agent will use batch.googleapis.com/Job
 *  as monitored resource for Batch job related logging.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useBatchMonitoredResource;

@end


/**
 *  Runnable describes instructions for executing a specific script or container
 *  as part of a Task.
 */
@interface GTLRCloudBatch_Runnable : GTLRObject

/**
 *  By default, after a Runnable fails, no further Runnable are executed. This
 *  flag indicates that this Runnable must be run even if the Task has already
 *  failed. This is useful for Runnables that copy output files off of the VM or
 *  for debugging. The always_run flag does not override the Task's overall
 *  max_run_duration. If the max_run_duration has expired then no further
 *  Runnables will execute, not even always_run Runnables.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *alwaysRun;

/**
 *  This flag allows a Runnable to continue running in the background while the
 *  Task executes subsequent Runnables. This is useful to provide services to
 *  other Runnables (or to provide debugging support tools like SSH servers).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *background;

/** Barrier runnable. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Barrier *barrier;

/** Container runnable. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Container *container;

/**
 *  Optional. DisplayName is an optional field that can be provided by the
 *  caller. If provided, it will be used in logs and other outputs to identify
 *  the script, making it easier for users to understand the logs. If not
 *  provided the index of the runnable will be used for outputs.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Environment variables for this Runnable (overrides variables set for the
 *  whole Task or TaskGroup).
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Environment *environment;

/**
 *  Normally, a non-zero exit status causes the Task to fail. This flag allows
 *  execution of other Runnables to continue instead.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ignoreExitStatus;

/** Labels for this Runnable. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Runnable_Labels *labels;

/** Script runnable. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Script *script;

/** Timeout for this Runnable. */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

@end


/**
 *  Labels for this Runnable.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudBatch_Runnable_Labels : GTLRObject
@end


/**
 *  Script runnable.
 */
@interface GTLRCloudBatch_Script : GTLRObject

/**
 *  Script file path on the host VM. To specify an interpreter, please add a
 *  `#!`(also known as [shebang
 *  line](https://en.wikipedia.org/wiki/Shebang_(Unix))) as the first line of
 *  the file.(For example, to execute the script using bash, `#!/bin/bash`
 *  should be the first line of the file. To execute the script using`Python3`,
 *  `#!/usr/bin/env python3` should be the first line of the file.) Otherwise,
 *  the file will by default be executed by `/bin/sh`.
 */
@property(nonatomic, copy, nullable) NSString *path;

/**
 *  Shell script text. To specify an interpreter, please add a `#!\\n` at the
 *  beginning of the text.(For example, to execute the script using bash,
 *  `#!/bin/bash\\n` should be added. To execute the script using`Python3`,
 *  `#!/usr/bin/env python3\\n` should be added.) Otherwise, the script will by
 *  default be executed by `/bin/sh`.
 */
@property(nonatomic, copy, nullable) NSString *text;

@end


/**
 *  Carries information about a Google Cloud service account.
 */
@interface GTLRCloudBatch_ServiceAccount : GTLRObject

/** Email address of the service account. */
@property(nonatomic, copy, nullable) NSString *email;

/** List of scopes to be enabled for this service account. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *scopes;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRCloudBatch_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRCloudBatch_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudBatch_Status_Details_Item : GTLRObject
@end


/**
 *  Status event
 */
@interface GTLRCloudBatch_StatusEvent : GTLRObject

/**
 *  Description of the event.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The time this event occurred. */
@property(nonatomic, strong, nullable) GTLRDateTime *eventTime;

/** Task Execution */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskExecution *taskExecution;

/**
 *  Task State
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_Assigned The Task is
 *        assigned to at least one VM. (Value: "ASSIGNED")
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_Failed The Task has failed.
 *        (Value: "FAILED")
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_Pending The Task is created
 *        and waiting for resources. (Value: "PENDING")
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_Running The Task is running.
 *        (Value: "RUNNING")
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_StateUnspecified Unknown
 *        state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_Succeeded The Task has
 *        succeeded. (Value: "SUCCEEDED")
 *    @arg @c kGTLRCloudBatch_StatusEvent_TaskState_Unexecuted The Task has not
 *        been executed when the Job finishes. (Value: "UNEXECUTED")
 */
@property(nonatomic, copy, nullable) NSString *taskState;

/** Type of the event. */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A Cloud Batch task.
 */
@interface GTLRCloudBatch_Task : GTLRObject

/**
 *  Task name. The name is generated from the parent TaskGroup name and 'id'
 *  field. For example:
 *  "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01/tasks/task01".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Task Status. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskStatus *status;

@end


/**
 *  This Task Execution field includes detail information for task execution
 *  procedures, based on StatusEvent types.
 */
@interface GTLRCloudBatch_TaskExecution : GTLRObject

/**
 *  When task is completed as the status of FAILED or SUCCEEDED, exit code is
 *  for one task execution result, default is 0 as success.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exitCode;

@end


/**
 *  A TaskGroup defines one or more Tasks that all share the same TaskSpec.
 */
@interface GTLRCloudBatch_TaskGroup : GTLRObject

/**
 *  Output only. TaskGroup name. The system generates this field based on parent
 *  Job name. For example:
 *  "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Max number of tasks that can run in parallel. Default to min(task_count,
 *  parallel tasks per job limit). See: [Job
 *  Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism
 *  must be 1 if the scheduling_policy is IN_ORDER.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *parallelism;

/**
 *  When true, Batch will configure SSH to allow passwordless login between VMs
 *  running the Batch tasks in the same TaskGroup.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *permissiveSsh;

/**
 *  When true, Batch will populate a file with a list of all VMs assigned to the
 *  TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of
 *  that file. Defaults to false. The host file supports up to 1000 VMs.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requireHostsFile;

/**
 *  Optional. If not set or set to false, Batch uses the root user to execute
 *  runnables. If set to true, Batch runs the runnables using a non-root user.
 *  Currently, the non-root user Batch used is generated by OS Login. For more
 *  information, see [About OS
 *  Login](https://cloud.google.com/compute/docs/oslogin).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *runAsNonRoot;

/**
 *  Scheduling policy for Tasks in the TaskGroup. The default value is
 *  AS_SOON_AS_POSSIBLE.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_TaskGroup_SchedulingPolicy_AsSoonAsPossible Run
 *        Tasks as soon as resources are available. Tasks might be executed in
 *        parallel depending on parallelism and task_count values. (Value:
 *        "AS_SOON_AS_POSSIBLE")
 *    @arg @c kGTLRCloudBatch_TaskGroup_SchedulingPolicy_InOrder Run Tasks
 *        sequentially with increased task index. (Value: "IN_ORDER")
 *    @arg @c kGTLRCloudBatch_TaskGroup_SchedulingPolicy_SchedulingPolicyUnspecified
 *        Unspecified. (Value: "SCHEDULING_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schedulingPolicy;

/**
 *  Number of Tasks in the TaskGroup. Default is 1.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *taskCount;

/**
 *  Max number of tasks that can be run on a VM at the same time. If not
 *  specified, the system will decide a value based on available compute
 *  resources on a VM and task requirements.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *taskCountPerNode;

/**
 *  An array of environment variable mappings, which are passed to Tasks with
 *  matching indices. If task_environments is used then task_count should not be
 *  specified in the request (and will be ignored). Task count will be the
 *  length of task_environments. Tasks get a BATCH_TASK_INDEX and
 *  BATCH_TASK_COUNT environment variable, in addition to any environment
 *  variables set in task_environments, specifying the number of Tasks in the
 *  Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0
 *  through BATCH_TASK_COUNT - 1).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Environment *> *taskEnvironments;

/** Required. Tasks in the group share the same task spec. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskSpec *taskSpec;

@end


/**
 *  Aggregated task status for a TaskGroup.
 */
@interface GTLRCloudBatch_TaskGroupStatus : GTLRObject

/**
 *  Count of task in each state in the TaskGroup. The map key is task state
 *  name.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskGroupStatus_Counts *counts;

/** Status of instances allocated for the TaskGroup. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_InstanceStatus *> *instances;

@end


/**
 *  Count of task in each state in the TaskGroup. The map key is task state
 *  name.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of longLongValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudBatch_TaskGroupStatus_Counts : GTLRObject
@end


/**
 *  Spec of a task
 */
@interface GTLRCloudBatch_TaskSpec : GTLRObject

/** ComputeResource requirements. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_ComputeResource *computeResource;

/** Environment variables to set before running the Task. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_Environment *environment;

/** Deprecated: please use environment(non-plural) instead. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_TaskSpec_Environments *environments GTLR_DEPRECATED;

/**
 *  Lifecycle management schema when any task in a task group is failed.
 *  Currently we only support one lifecycle policy. When the lifecycle policy
 *  condition is met, the action in the policy will execute. If task execution
 *  result does not meet with the defined lifecycle policy, we consider it as
 *  the default policy. Default policy means if the exit code is 0, exit task.
 *  If task ends with non-zero exit code, retry the task with max_retry_count.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_LifecyclePolicy *> *lifecyclePolicies;

/**
 *  Maximum number of retries on failures. The default, 0, which means never
 *  retry. The valid value range is [0, 10].
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxRetryCount;

/**
 *  Maximum duration the task should run. The task will be killed and marked as
 *  FAILED if over this limit. The valid value range for max_run_duration in
 *  seconds is [0, 315576000000.999999999],
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxRunDuration;

/**
 *  The sequence of scripts or containers to run for this Task. Each Task using
 *  this TaskSpec executes its list of runnables in order. The Task succeeds if
 *  all of its runnables either exit with a zero status or any that exit with a
 *  non-zero status have the ignore_exit_status flag. Background runnables are
 *  killed automatically (if they have not already exited) a short time after
 *  all foreground runnables have completed. Even though this is likely to
 *  result in a non-zero exit status for the background runnable, these
 *  automatic kills are not treated as Task failures.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Runnable *> *runnables;

/** Volumes to mount before running Tasks using this TaskSpec. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_Volume *> *volumes;

@end


/**
 *  Deprecated: please use environment(non-plural) instead.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
GTLR_DEPRECATED
@interface GTLRCloudBatch_TaskSpec_Environments : GTLRObject
@end


/**
 *  Status of a task
 */
@interface GTLRCloudBatch_TaskStatus : GTLRObject

/**
 *  Task state
 *
 *  Likely values:
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_Assigned The Task is assigned to
 *        at least one VM. (Value: "ASSIGNED")
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_Failed The Task has failed.
 *        (Value: "FAILED")
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_Pending The Task is created and
 *        waiting for resources. (Value: "PENDING")
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_Running The Task is running.
 *        (Value: "RUNNING")
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_StateUnspecified Unknown state.
 *        (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_Succeeded The Task has succeeded.
 *        (Value: "SUCCEEDED")
 *    @arg @c kGTLRCloudBatch_TaskStatus_State_Unexecuted The Task has not been
 *        executed when the Job finishes. (Value: "UNEXECUTED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Detailed info about why the state is reached. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudBatch_StatusEvent *> *statusEvents;

@end


/**
 *  Volume describes a volume and parameters for it to be mounted to a VM.
 */
@interface GTLRCloudBatch_Volume : GTLRObject

/**
 *  Device name of an attached disk volume, which should align with a
 *  device_name specified by
 *  job.allocation_policy.instances[0].policy.disks[i].device_name or defined by
 *  the given instance template in
 *  job.allocation_policy.instances[0].instance_template.
 */
@property(nonatomic, copy, nullable) NSString *deviceName;

/** A Google Cloud Storage (GCS) volume. */
@property(nonatomic, strong, nullable) GTLRCloudBatch_GCS *gcs;

/**
 *  For Google Cloud Storage (GCS), mount options are the options supported by
 *  the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For
 *  existing persistent disks, mount options provided by the mount command
 *  (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are
 *  supported. This is due to restrictions of multi-writer mode
 *  (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For
 *  other attached disks and Network File System (NFS), mount options are these
 *  supported by the mount command
 *  (https://man7.org/linux/man-pages/man8/mount.8.html).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *mountOptions;

/** The mount path for the volume, e.g. /mnt/disks/share. */
@property(nonatomic, copy, nullable) NSString *mountPath;

/**
 *  A Network File System (NFS) volume. For example, a Filestore file share.
 */
@property(nonatomic, strong, nullable) GTLRCloudBatch_NFS *nfs;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
