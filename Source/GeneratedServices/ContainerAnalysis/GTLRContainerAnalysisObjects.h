// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Container Analysis API (containeranalysis/v1alpha1)
// Description:
//   An implementation of the Grafeas API, which stores, and enables querying
//   and retrieval of critical metadata about all of your software artifacts.
// Documentation:
//   https://cloud.google.com/container-analysis/api/reference/rest/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRContainerAnalysis_Artifact;
@class GTLRContainerAnalysis_Attestation;
@class GTLRContainerAnalysis_AttestationAuthority;
@class GTLRContainerAnalysis_AttestationAuthorityHint;
@class GTLRContainerAnalysis_AuditConfig;
@class GTLRContainerAnalysis_AuditLogConfig;
@class GTLRContainerAnalysis_Basis;
@class GTLRContainerAnalysis_Binding;
@class GTLRContainerAnalysis_BuildDetails;
@class GTLRContainerAnalysis_BuildProvenance;
@class GTLRContainerAnalysis_BuildProvenance_BuildOptions;
@class GTLRContainerAnalysis_BuildSignature;
@class GTLRContainerAnalysis_BuildType;
@class GTLRContainerAnalysis_Command;
@class GTLRContainerAnalysis_Deployable;
@class GTLRContainerAnalysis_Deployment;
@class GTLRContainerAnalysis_Derived;
@class GTLRContainerAnalysis_Detail;
@class GTLRContainerAnalysis_Discovered;
@class GTLRContainerAnalysis_Discovery;
@class GTLRContainerAnalysis_Distribution;
@class GTLRContainerAnalysis_Expr;
@class GTLRContainerAnalysis_FileHashes;
@class GTLRContainerAnalysis_Fingerprint;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1CloudRepoSourceContext;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1GerritSourceContext;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1GitSourceContext;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1ProjectRepoId;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1RepoId;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext;
@class GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext_Labels;
@class GTLRContainerAnalysis_Hash;
@class GTLRContainerAnalysis_Installation;
@class GTLRContainerAnalysis_Layer;
@class GTLRContainerAnalysis_Location;
@class GTLRContainerAnalysis_Note;
@class GTLRContainerAnalysis_Occurrence;
@class GTLRContainerAnalysis_Operation;
@class GTLRContainerAnalysis_Operation_Metadata;
@class GTLRContainerAnalysis_Operation_Response;
@class GTLRContainerAnalysis_Package;
@class GTLRContainerAnalysis_PackageIssue;
@class GTLRContainerAnalysis_PgpSignedAttestation;
@class GTLRContainerAnalysis_Policy;
@class GTLRContainerAnalysis_RelatedUrl;
@class GTLRContainerAnalysis_RepoSource;
@class GTLRContainerAnalysis_Resource;
@class GTLRContainerAnalysis_ScanConfig;
@class GTLRContainerAnalysis_SeverityCount;
@class GTLRContainerAnalysis_Source;
@class GTLRContainerAnalysis_Source_FileHashes;
@class GTLRContainerAnalysis_Status;
@class GTLRContainerAnalysis_Status_Details_Item;
@class GTLRContainerAnalysis_StorageSource;
@class GTLRContainerAnalysis_Version;
@class GTLRContainerAnalysis_VulnerabilityDetails;
@class GTLRContainerAnalysis_VulnerabilityLocation;
@class GTLRContainerAnalysis_VulnerabilityType;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_BuildSignature.keyType

/**
 *  `KeyType` is not set.
 *
 *  Value: "KEY_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_BuildSignature_KeyType_KeyTypeUnspecified;
/**
 *  `PGP ASCII Armored` public key.
 *
 *  Value: "PGP_ASCII_ARMORED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_BuildSignature_KeyType_PgpAsciiArmored;
/**
 *  `PKIX PEM` public key.
 *
 *  Value: "PKIX_PEM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_BuildSignature_KeyType_PkixPem;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Deployment.platform

/**
 *  Custom user-defined platform
 *
 *  Value: "CUSTOM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_Custom;
/**
 *  Google App Engine: Flexible Environment
 *
 *  Value: "FLEX"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_Flex;
/**
 *  Google Container Engine
 *
 *  Value: "GKE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_Gke;
/**
 *  Unknown
 *
 *  Value: "PLATFORM_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_PlatformUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Discovered.analysisStatus

/**
 *  Unknown
 *
 *  Value: "ANALYSIS_STATUS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_AnalysisStatusUnspecified;
/**
 *  Analysis has finished unsuccessfully, the analysis itself is in a bad
 *  state.
 *
 *  Value: "FINISHED_FAILED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedFailed;
/**
 *  Analysis has finished successfully.
 *
 *  Value: "FINISHED_SUCCESS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedSuccess;
/**
 *  The resource is known not to be supported.
 *
 *  Value: "FINISHED_UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedUnsupported;
/**
 *  Resource is known but no action has been taken yet.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_Pending;
/**
 *  Resource is being analyzed.
 *
 *  Value: "SCANNING"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_Scanning;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Discovered.continuousAnalysis

/**
 *  The resource is continuously analyzed.
 *
 *  Value: "ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Active;
/**
 *  Unknown
 *
 *  Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_ContinuousAnalysisUnspecified;
/**
 *  The resource is ignored for continuous analysis.
 *
 *  Value: "INACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Inactive;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Discovery.analysisKind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION_AUTHORITY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_AttestationAuthority;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD_DETAILS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_BuildDetails;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYABLE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Deployable;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE_BASIS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_ImageBasis;
/**
 *  Unknown
 *
 *  Value: "KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_KindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE_MANAGER"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_PackageManager;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "PACKAGE_VULNERABILITY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_PackageVulnerability;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Distribution.architecture

/**
 *  Unknown architecture
 *
 *  Value: "ARCHITECTURE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Distribution_Architecture_ArchitectureUnspecified;
/**
 *  X64 architecture
 *
 *  Value: "X64"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Distribution_Architecture_X64;
/**
 *  X86 architecture
 *
 *  Value: "X86"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Distribution_Architecture_X86;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext.kind

/**
 *  Git tag.
 *
 *  Value: "FIXED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_Fixed;
/**
 *  Unknown.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_KindUnspecified;
/**
 *  Git branch.
 *
 *  Value: "MOVABLE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_Movable;
/**
 *  Used to specify non-standard aliases. For example, if a Git repo has a
 *  ref named "refs/foo/bar".
 *
 *  Value: "OTHER"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_Other;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Hash.type

/**
 *  No hash requested.
 *
 *  Value: "NONE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Hash_Type_None;
/**
 *  A sha256 hash.
 *
 *  Value: "SHA256"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Hash_Type_Sha256;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Layer.directive

/**
 *  https://docs.docker.com/reference/builder/#add
 *
 *  Value: "ADD"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Add;
/**
 *  https://docs.docker.com/reference/builder/#arg
 *
 *  Value: "ARG"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Arg;
/**
 *  https://docs.docker.com/reference/builder/#cmd
 *
 *  Value: "CMD"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Cmd;
/**
 *  https://docs.docker.com/reference/builder/#copy
 *
 *  Value: "COPY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Copy;
/**
 *  Default value for unsupported/missing directive
 *
 *  Value: "DIRECTIVE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_DirectiveUnspecified;
/**
 *  https://docs.docker.com/reference/builder/#entrypoint
 *
 *  Value: "ENTRYPOINT"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Entrypoint;
/**
 *  https://docs.docker.com/reference/builder/#env
 *
 *  Value: "ENV"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Env;
/**
 *  https://docs.docker.com/reference/builder/#expose
 *
 *  Value: "EXPOSE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Expose;
/**
 *  https://docs.docker.com/reference/builder/#healthcheck
 *
 *  Value: "HEALTHCHECK"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Healthcheck;
/**
 *  https://docs.docker.com/reference/builder/#label
 *
 *  Value: "LABEL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Label;
/**
 *  https://docs.docker.com/reference/builder/#maintainer
 *
 *  Value: "MAINTAINER"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Maintainer;
/**
 *  https://docs.docker.com/reference/builder/#onbuild
 *
 *  Value: "ONBUILD"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Onbuild;
/**
 *  https://docs.docker.com/reference/builder/#run
 *
 *  Value: "RUN"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Run;
/**
 *  https://docs.docker.com/reference/builder/#shell
 *
 *  Value: "SHELL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Shell;
/**
 *  https://docs.docker.com/reference/builder/#stopsignal
 *
 *  Value: "STOPSIGNAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Stopsignal;
/**
 *  https://docs.docker.com/reference/builder/#user
 *
 *  Value: "USER"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_User;
/**
 *  https://docs.docker.com/reference/builder/#volume
 *
 *  Value: "VOLUME"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Volume;
/**
 *  https://docs.docker.com/reference/builder/#workdir
 *
 *  Value: "WORKDIR"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Workdir;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Note.kind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION_AUTHORITY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_AttestationAuthority;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD_DETAILS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_BuildDetails;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYABLE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Deployable;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE_BASIS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_ImageBasis;
/**
 *  Unknown
 *
 *  Value: "KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_KindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE_MANAGER"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_PackageManager;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "PACKAGE_VULNERABILITY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_PackageVulnerability;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Occurrence.kind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION_AUTHORITY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_AttestationAuthority;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD_DETAILS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_BuildDetails;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYABLE"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Deployable;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE_BASIS"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_ImageBasis;
/**
 *  Unknown
 *
 *  Value: "KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_KindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE_MANAGER"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_PackageManager;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "PACKAGE_VULNERABILITY"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_PackageVulnerability;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_PgpSignedAttestation.contentType

/**
 *  `ContentType` is not set.
 *
 *  Value: "CONTENT_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_ContentTypeUnspecified;
/**
 *  Atomic format attestation signature. See
 *  https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
 *  The payload extracted from `signature` is a JSON blob conforming to the
 *  linked schema.
 *
 *  Value: "SIMPLE_SIGNING_JSON"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_SimpleSigningJson;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_SeverityCount.severity

/**
 *  Critical Impact
 *
 *  Value: "CRITICAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_SeverityCount_Severity_Critical;
/**
 *  High Impact
 *
 *  Value: "HIGH"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_SeverityCount_Severity_High;
/**
 *  Low Impact
 *
 *  Value: "LOW"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_SeverityCount_Severity_Low;
/**
 *  Medium Impact
 *
 *  Value: "MEDIUM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_SeverityCount_Severity_Medium;
/**
 *  Minimal Impact
 *
 *  Value: "MINIMAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_SeverityCount_Severity_Minimal;
/**
 *  Unknown Impact
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_SeverityCount_Severity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Version.kind

/**
 *  A special version representing positive infinity,
 *  other fields are ignored.
 *
 *  Value: "MAXIMUM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_Maximum;
/**
 *  A special version representing negative infinity,
 *  other fields are ignored.
 *
 *  Value: "MINIMUM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_Minimum;
/**
 *  A standard package version, defined by the other fields.
 *
 *  Value: "NORMAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_Normal;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_VulnerabilityDetails.severity

/**
 *  Critical Impact
 *
 *  Value: "CRITICAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Critical;
/**
 *  High Impact
 *
 *  Value: "HIGH"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityDetails_Severity_High;
/**
 *  Low Impact
 *
 *  Value: "LOW"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Low;
/**
 *  Medium Impact
 *
 *  Value: "MEDIUM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Medium;
/**
 *  Minimal Impact
 *
 *  Value: "MINIMAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Minimal;
/**
 *  Unknown Impact
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityDetails_Severity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_VulnerabilityType.severity

/**
 *  Critical Impact
 *
 *  Value: "CRITICAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityType_Severity_Critical;
/**
 *  High Impact
 *
 *  Value: "HIGH"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityType_Severity_High;
/**
 *  Low Impact
 *
 *  Value: "LOW"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityType_Severity_Low;
/**
 *  Medium Impact
 *
 *  Value: "MEDIUM"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityType_Severity_Medium;
/**
 *  Minimal Impact
 *
 *  Value: "MINIMAL"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityType_Severity_Minimal;
/**
 *  Unknown Impact
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainerAnalysis_VulnerabilityType_Severity_SeverityUnspecified;

/**
 *  Artifact describes a build product.
 */
@interface GTLRContainerAnalysis_Artifact : GTLRObject

/**
 *  Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
 *  container.
 */
@property(nonatomic, copy, nullable) NSString *checksum;

/**
 *  Artifact ID, if any; for container images, this will be a URL by digest
 *  like gcr.io/projectID/imagename\@sha256:123456
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Name of the artifact. This may be the path to a binary or jar file, or in
 *  the case of a container build, the name used to push the container image to
 *  Google Container Registry, as presented to `docker push`.
 *  This field is deprecated in favor of the plural `names` field; it continues
 *  to exist here to allow existing BuildProvenance serialized to json in
 *  google.devtools.containeranalysis.v1alpha1.BuildDetails.provenance_bytes to
 *  deserialize back into proto.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Related artifact names. This may be the path to a binary or jar file, or in
 *  the case of a container build, the name used to push the container image to
 *  Google Container Registry, as presented to `docker push`. Note that a
 *  single Artifact ID can have multiple names, for example if two tags are
 *  applied to one image.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *names;

@end


/**
 *  Occurrence that represents a single "attestation". The authenticity of an
 *  Attestation can be verified using the attached signature. If the verifier
 *  trusts the public key of the signer, then verifying the signature is
 *  sufficient to establish trust. In this circumstance, the
 *  AttestationAuthority to which this Attestation is attached is primarily
 *  useful for look-up (how to find this Attestation if you already know the
 *  Authority and artifact to be verified) and intent (which authority was this
 *  attestation intended to sign for).
 */
@interface GTLRContainerAnalysis_Attestation : GTLRObject

@property(nonatomic, strong, nullable) GTLRContainerAnalysis_PgpSignedAttestation *pgpSignedAttestation;

@end


/**
 *  Note kind that represents a logical attestation "role" or "authority". For
 *  example, an organization might have one `AttestationAuthority` for "QA" and
 *  one for "build". This Note is intended to act strictly as a grouping
 *  mechanism for the attached Occurrences (Attestations). This grouping
 *  mechanism also provides a security boundary, since IAM ACLs gate the ability
 *  for a principle to attach an Occurrence to a given Note. It also provides a
 *  single point of lookup to find all attached Attestation Occurrences, even if
 *  they don't all live in the same project.
 */
@interface GTLRContainerAnalysis_AttestationAuthority : GTLRObject

@property(nonatomic, strong, nullable) GTLRContainerAnalysis_AttestationAuthorityHint *hint;

@end


/**
 *  This submessage provides human-readable hints about the purpose of the
 *  AttestationAuthority. Because the name of a Note acts as its resource
 *  reference, it is important to disambiguate the canonical name of the Note
 *  (which might be a UUID for security purposes) from "readable" names more
 *  suitable for debug output. Note that these hints should NOT be used to
 *  look up AttestationAuthorities in security sensitive contexts, such as when
 *  looking up Attestations to verify.
 */
@interface GTLRContainerAnalysis_AttestationAuthorityHint : GTLRObject

/**
 *  The human readable name of this Attestation Authority, for example "qa".
 */
@property(nonatomic, copy, nullable) NSString *humanReadableName;

@end


/**
 *  Specifies the audit configuration for a service.
 *  The configuration determines which permission types are logged, and what
 *  identities, if any, are exempted from logging.
 *  An AuditConfig must have one or more AuditLogConfigs.
 *  If there are AuditConfigs for both `allServices` and a specific service,
 *  the union of the two AuditConfigs is used for that service: the log_types
 *  specified in each AuditConfig are enabled, and the exempted_members in each
 *  AuditLogConfig are exempted.
 *  Example Policy with multiple AuditConfigs:
 *  {
 *  "audit_configs": [
 *  {
 *  "service": "allServices"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:foo\@gmail.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  },
 *  {
 *  "log_type": "ADMIN_READ",
 *  }
 *  ]
 *  },
 *  {
 *  "service": "fooservice.googleapis.com"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  "exempted_members": [
 *  "user:bar\@gmail.com"
 *  ]
 *  }
 *  ]
 *  }
 *  ]
 *  }
 *  For fooservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts foo\@gmail.com from DATA_READ logging, and
 *  bar\@gmail.com from DATA_WRITE logging.
 */
@interface GTLRContainerAnalysis_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging.
 *  For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
 *  `allServices` is a special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions.
 *  Example:
 *  {
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:foo\@gmail.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  }
 *  ]
 *  }
 *  This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
 *  foo\@gmail.com from DATA_READ logging.
 */
@interface GTLRContainerAnalysis_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission.
 *  Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_AuditLogConfig_LogType_AdminRead Admin
 *        reads. Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRContainerAnalysis_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRContainerAnalysis_AuditLogConfig_LogType_DataWrite Data
 *        writes. Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRContainerAnalysis_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Basis describes the base image portion (Note) of the DockerImage
 *  relationship. Linked occurrences are derived from this or an
 *  equivalent image via:
 *  FROM <Basis.resource_url>
 *  Or an equivalent reference, e.g. a tag of the resource_url.
 */
@interface GTLRContainerAnalysis_Basis : GTLRObject

/** The fingerprint of the base image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Fingerprint *fingerprint;

/**
 *  The resource_url for the resource representing the basis of
 *  associated occurrence images.
 */
@property(nonatomic, copy, nullable) NSString *resourceUrl;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRContainerAnalysis_Binding : GTLRObject

/**
 *  Unimplemented. The condition that is associated with this binding.
 *  NOTE: an unsatisfied condition will not allow user access via current
 *  binding. Different bindings, including their conditions, are examined
 *  independently.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values:
 *  * `allUsers`: A special identifier that represents anyone who is
 *  on the internet; with or without a Google account.
 *  * `allAuthenticatedUsers`: A special identifier that represents anyone
 *  who is authenticated with a Google account or a service account.
 *  * `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@gmail.com` .
 *  * `serviceAccount:{emailid}`: An email address that represents a service
 *  account. For example, `my-other-app\@appspot.gserviceaccount.com`.
 *  * `group:{emailid}`: An email address that represents a Google group.
 *  For example, `admins\@example.com`.
 *  * `domain:{domain}`: A Google Apps domain name that represents all the
 *  users of that domain. For example, `google.com` or `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`.
 *  For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Message encapsulating build provenance details.
 */
@interface GTLRContainerAnalysis_BuildDetails : GTLRObject

/** The actual provenance */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildProvenance *provenance;

/**
 *  Serialized JSON representation of the provenance, used in generating the
 *  `BuildSignature` in the corresponding Result. After verifying the
 *  signature, `provenance_bytes` can be unmarshalled and compared to the
 *  provenance to confirm that it is unchanged. A base64-encoded string
 *  representation of the provenance bytes is used for the signature in order
 *  to interoperate with openssl which expects this format for signature
 *  verification.
 *  The serialized form is captured both to avoid ambiguity in how the
 *  provenance is marshalled to json as well to prevent incompatibilities with
 *  future changes.
 */
@property(nonatomic, copy, nullable) NSString *provenanceBytes;

@end


/**
 *  Provenance of a build. Contains all information needed to verify the full
 *  details about the build from source to completion.
 */
@interface GTLRContainerAnalysis_BuildProvenance : GTLRObject

/** Version string of the builder at the time this build was executed. */
@property(nonatomic, copy, nullable) NSString *builderVersion;

/**
 *  Special options applied to this build. This is a catch-all field where
 *  build providers can enter any desired additional details.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildProvenance_BuildOptions *buildOptions;

/** Output of the build. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Artifact *> *builtArtifacts;

/** Commands requested by the build. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Command *> *commands;

/** Time at which the build was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  E-mail address of the user who initiated this build. Note that this was the
 *  user's e-mail address at the time the build was initiated; this address may
 *  not represent the same end-user for all time.
 */
@property(nonatomic, copy, nullable) NSString *creator;

/** Time at which execution of the build was finished. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  Unique identifier of the build.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Google Cloud Storage bucket where logs were written. */
@property(nonatomic, copy, nullable) NSString *logsBucket;

/** ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Details of the Source input to the build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Source *sourceProvenance;

/** Time at which execution of the build was started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Trigger identifier if the build was triggered automatically; empty if not.
 */
@property(nonatomic, copy, nullable) NSString *triggerId;

@end


/**
 *  Special options applied to this build. This is a catch-all field where
 *  build providers can enter any desired additional details.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainerAnalysis_BuildProvenance_BuildOptions : GTLRObject
@end


/**
 *  Message encapsulating the signature of the verified build.
 */
@interface GTLRContainerAnalysis_BuildSignature : GTLRObject

/**
 *  An Id for the key used to sign. This could be either an Id for the key
 *  stored in `public_key` (such as the Id or fingerprint for a PGP key, or the
 *  CN for a cert), or a reference to an external key (such as a reference to a
 *  key in Cloud Key Management Service).
 */
@property(nonatomic, copy, nullable) NSString *keyId;

/**
 *  The type of the key, either stored in `public_key` or referenced in
 *  `key_id`
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_BuildSignature_KeyType_KeyTypeUnspecified
 *        `KeyType` is not set. (Value: "KEY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_BuildSignature_KeyType_PgpAsciiArmored `PGP
 *        ASCII Armored` public key. (Value: "PGP_ASCII_ARMORED")
 *    @arg @c kGTLRContainerAnalysis_BuildSignature_KeyType_PkixPem `PKIX PEM`
 *        public key. (Value: "PKIX_PEM")
 */
@property(nonatomic, copy, nullable) NSString *keyType;

/**
 *  Public key of the builder which can be used to verify that the related
 *  findings are valid and unchanged. If `key_type` is empty, this defaults
 *  to PEM encoded public keys.
 *  This field may be empty if `key_id` references an external key.
 *  For Cloud Build based signatures, this is a PEM encoded public
 *  key. To verify the Cloud Build signature, place the contents of
 *  this field into a file (public.pem). The signature field is base64-decoded
 *  into its binary representation in signature.bin, and the provenance bytes
 *  from `BuildDetails` are base64-decoded into a binary representation in
 *  signed.bin. OpenSSL can then verify the signature:
 *  `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
 */
@property(nonatomic, copy, nullable) NSString *publicKey;

/** Signature of the related `BuildProvenance`, encoded in a base64 string. */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  Note holding the version of the provider's builder and the signature of
 *  the provenance message in linked BuildDetails.
 */
@interface GTLRContainerAnalysis_BuildType : GTLRObject

/** Version of the builder which produced this Note. */
@property(nonatomic, copy, nullable) NSString *builderVersion;

/**
 *  Signature of the build in Occurrences pointing to the Note containing this
 *  `BuilderDetails`.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildSignature *signature;

@end


/**
 *  Command describes a step performed as part of the build pipeline.
 */
@interface GTLRContainerAnalysis_Command : GTLRObject

/** Command-line arguments used when executing this Command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

/**
 *  Working directory (relative to project source root) used when running
 *  this Command.
 */
@property(nonatomic, copy, nullable) NSString *dir;

/** Environment variables set before running this Command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *env;

/**
 *  Optional unique identifier for this Command, used in wait_for to reference
 *  this Command as a dependency.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Name of the command, as presented on the command line, or if the command is
 *  packaged as a Docker container, as presented to `docker pull`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The ID(s) of the Command(s) that this Command depends on. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *waitFor;

@end


/**
 *  Request for creating an operation
 */
@interface GTLRContainerAnalysis_CreateOperationRequest : GTLRObject

/** The operation to create. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Operation *operation;

/** The ID to use for this operation. */
@property(nonatomic, copy, nullable) NSString *operationId;

@end


/**
 *  An artifact that can be deployed in some runtime.
 */
@interface GTLRContainerAnalysis_Deployable : GTLRObject

/** Resource URI for the artifact being deployed. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceUri;

@end


/**
 *  The period during which some deployable was active in a runtime.
 */
@interface GTLRContainerAnalysis_Deployment : GTLRObject

/** Address of the runtime element hosting this deployment. */
@property(nonatomic, copy, nullable) NSString *address;

/** Configuration used to create this deployment. */
@property(nonatomic, copy, nullable) NSString *config;

/** Beginning of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *deployTime;

/**
 *  Platform hosting this deployment.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_Custom Custom
 *        user-defined platform (Value: "CUSTOM")
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_Flex Google App Engine:
 *        Flexible Environment (Value: "FLEX")
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_Gke Google Container
 *        Engine (Value: "GKE")
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_PlatformUnspecified
 *        Unknown (Value: "PLATFORM_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *platform;

/**
 *  Output only. Resource URI for the artifact being deployed taken from the
 *  deployable field with the same name.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceUri;

/** End of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *undeployTime;

/** Identity of the user that triggered this deployment. */
@property(nonatomic, copy, nullable) NSString *userEmail;

@end


/**
 *  Derived describes the derived image portion (Occurrence) of the
 *  DockerImage relationship. This image would be produced from a Dockerfile
 *  with FROM <DockerImage.Basis in attached Note>.
 */
@interface GTLRContainerAnalysis_Derived : GTLRObject

/**
 *  Output only. This contains the base image URL for the derived image
 *  occurrence.
 */
@property(nonatomic, copy, nullable) NSString *baseResourceUrl;

/**
 *  Output only. The number of layers by which this image differs from the
 *  associated image basis.
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *distance;

/** The fingerprint of the derived image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Fingerprint *fingerprint;

/**
 *  This contains layer-specific metadata, if populated it has length
 *  "distance" and is ordered with [distance] being the layer immediately
 *  following the base image and [1] being the final layer.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Layer *> *layerInfo;

@end


/**
 *  Identifies all occurrences of this vulnerability in the package for a
 *  specific distro/location
 *  For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
 */
@interface GTLRContainerAnalysis_Detail : GTLRObject

/**
 *  The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in
 *  which the vulnerability manifests. Examples include distro or storage
 *  location for vulnerable jar.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  A vendor-specific description of this note.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The fix for this specific package version. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityLocation *fixedLocation;

/**
 *  Whether this Detail is obsolete. Occurrences are expected not to point to
 *  obsolete details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isObsolete;

/**
 *  The max version of the package in which the vulnerability exists.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *maxAffectedVersion;

/** The min version of the package in which the vulnerability exists. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *minAffectedVersion;

/**
 *  The name of the package where the vulnerability was found.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *package;

/**
 *  The type of package; whether native or non native(ruby gems,
 *  node.js packages etc)
 */
@property(nonatomic, copy, nullable) NSString *packageType;

/** The severity (eg: distro assigned severity) for this vulnerability. */
@property(nonatomic, copy, nullable) NSString *severityName;

@end


/**
 *  Provides information about the scan status of a discovered resource.
 */
@interface GTLRContainerAnalysis_Discovered : GTLRObject

/**
 *  The status of discovery for the resource.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_AnalysisStatusUnspecified
 *        Unknown (Value: "ANALYSIS_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedFailed
 *        Analysis has finished unsuccessfully, the analysis itself is in a bad
 *        state. (Value: "FINISHED_FAILED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedSuccess
 *        Analysis has finished successfully. (Value: "FINISHED_SUCCESS")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedUnsupported
 *        The resource is known not to be supported. (Value:
 *        "FINISHED_UNSUPPORTED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_Pending Resource
 *        is known but no action has been taken yet. (Value: "PENDING")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_Scanning Resource
 *        is being analyzed. (Value: "SCANNING")
 */
@property(nonatomic, copy, nullable) NSString *analysisStatus;

/**
 *  When an error is encountered this will contain a LocalizedMessage under
 *  details to show to the user. The LocalizedMessage output only and
 *  populated by the API.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Status *analysisStatusError;

/**
 *  Whether the resource is continuously analyzed.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Active The
 *        resource is continuously analyzed. (Value: "ACTIVE")
 *    @arg @c kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_ContinuousAnalysisUnspecified
 *        Unknown (Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Inactive The
 *        resource is ignored for continuous analysis. (Value: "INACTIVE")
 */
@property(nonatomic, copy, nullable) NSString *continuousAnalysis;

/**
 *  Output only. An operation that indicates the status of the current scan.
 *  This field is deprecated, do not use.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Operation *operation;

@end


/**
 *  A note that indicates a type of analysis a provider would perform. This note
 *  exists in a provider's project. A `Discovery` occurrence is created in a
 *  consumer's project at the start of analysis. The occurrence's operation will
 *  indicate the status of the analysis. Absence of an occurrence linked to this
 *  note for a resource indicates that analysis hasn't started.
 */
@interface GTLRContainerAnalysis_Discovery : GTLRObject

/**
 *  The kind of analysis that is handled by this discovery.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_AttestationAuthority
 *        This represents a logical "role" that can attest to artifacts. (Value:
 *        "ATTESTATION_AUTHORITY")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_BuildDetails The
 *        note and occurrence assert build provenance. (Value: "BUILD_DETAILS")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Deployable The note
 *        and occurrence track deployment events. (Value: "DEPLOYABLE")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Discovery The note
 *        and occurrence track the initial discovery status of a resource.
 *        (Value: "DISCOVERY")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_ImageBasis This
 *        represents an image basis relationship. (Value: "IMAGE_BASIS")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_KindUnspecified
 *        Unknown (Value: "KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_PackageManager This
 *        represents a package installed via a package manager. (Value:
 *        "PACKAGE_MANAGER")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_PackageVulnerability
 *        The note and occurrence represent a package vulnerability. (Value:
 *        "PACKAGE_VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *analysisKind;

@end


/**
 *  This represents a particular channel of distribution for a given package.
 *  e.g. Debian's jessie-backports dpkg mirror
 */
@interface GTLRContainerAnalysis_Distribution : GTLRObject

/**
 *  The CPU architecture for which packages in this distribution
 *  channel were built
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Distribution_Architecture_ArchitectureUnspecified
 *        Unknown architecture (Value: "ARCHITECTURE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Distribution_Architecture_X64 X64
 *        architecture (Value: "X64")
 *    @arg @c kGTLRContainerAnalysis_Distribution_Architecture_X86 X86
 *        architecture (Value: "X86")
 */
@property(nonatomic, copy, nullable) NSString *architecture;

/**
 *  The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
 *  denoting the package manager version distributing a package.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  The distribution channel-specific description of this package.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The latest available version of this package in
 *  this distribution channel.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *latestVersion;

/** A freeform string denoting the maintainer of this package. */
@property(nonatomic, copy, nullable) NSString *maintainer;

/** The distribution channel-specific homepage for this package. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRContainerAnalysis_Empty : GTLRObject
@end


/**
 *  Represents an expression text. Example:
 *  title: "User account presence"
 *  description: "Determines whether the request has a user account"
 *  expression: "size(request.user) > 0"
 */
@interface GTLRContainerAnalysis_Expr : GTLRObject

/**
 *  An optional description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in
 *  Common Expression Language syntax.
 *  The application context of the containing message determines which
 *  well-known feature set of CEL is supported.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  An optional string indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  An optional title for the expression, i.e. a short string describing
 *  its purpose. This can be used e.g. in UIs which allow to enter the
 *  expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Container message for hashes of byte content of files, used in Source
 *  messages to verify integrity of source input to the build.
 */
@interface GTLRContainerAnalysis_FileHashes : GTLRObject

/** Collection of file hashes. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Hash *> *fileHash;

@end


/**
 *  A set of properties that uniquely identify a given Docker image.
 */
@interface GTLRContainerAnalysis_Fingerprint : GTLRObject

/**
 *  The layer-id of the final layer in the Docker image's v1
 *  representation.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *v1Name;

/** The ordered list of v2 blobs that represent a given image. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *v2Blob;

/**
 *  Output only. The name of the image's v2 blobs computed via:
 *  [bottom] := v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1])
 *  Only the name of the final blob is kept.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *v2Name;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRContainerAnalysis_GetIamPolicyRequest : GTLRObject
@end


/**
 *  A summary of how many vulnz occurrences there are per severity type.
 *  counts by groups, or if we should have different summary messages
 *  like this.
 */
@interface GTLRContainerAnalysis_GetVulnzOccurrencesSummaryResponse : GTLRObject

/** A map of how many occurrences were found for each severity. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_SeverityCount *> *counts;

@end


/**
 *  An alias to a repo revision.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext : GTLRObject

/**
 *  The alias kind.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_Fixed
 *        Git tag. (Value: "FIXED")
 *    @arg @c kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_KindUnspecified
 *        Unknown. (Value: "KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_Movable
 *        Git branch. (Value: "MOVABLE")
 *    @arg @c kGTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext_Kind_Other
 *        Used to specify non-standard aliases. For example, if a Git repo has a
 *        ref named "refs/foo/bar". (Value: "OTHER")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The alias name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A CloudRepoSourceContext denotes a particular revision in a Google Cloud
 *  Source Repo.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1CloudRepoSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext *aliasContext;

/** The ID of the repo. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1RepoId *repoId;

/** A revision ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  A SourceContext referring to a Gerrit project.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1GerritSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1AliasContext *aliasContext;

/**
 *  The full project name within the host. Projects may be nested, so
 *  "project/subproject" is a valid project name. The "repo name" is
 *  the hostURI/project.
 */
@property(nonatomic, copy, nullable) NSString *gerritProject;

/** The URI of a running Gerrit instance. */
@property(nonatomic, copy, nullable) NSString *hostUri;

/** A revision (commit) ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  A GitSourceContext denotes a particular revision in a third party Git
 *  repository (e.g., GitHub).
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1GitSourceContext : GTLRObject

/**
 *  Required.
 *  Git commit hash.
 */
@property(nonatomic, copy, nullable) NSString *revisionId;

/** Git repository URL. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Metadata for all operations used and required for all operations
 *  that created by Container Analysis Providers
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1OperationMetadata : GTLRObject

/** Output only. The time this operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The time that this operation was marked completed or failed.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

@end


/**
 *  Selects a repo using a Google Cloud Platform project ID (e.g.,
 *  winged-cargo-31) and a repo name within that project.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1ProjectRepoId : GTLRObject

/** The ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The name of the repo. Leave empty for the default repo. */
@property(nonatomic, copy, nullable) NSString *repoName;

@end


/**
 *  A unique identifier for a Cloud Repo.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1RepoId : GTLRObject

/** A combination of a project ID and a repo name. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1ProjectRepoId *projectRepoId;

/** A server-assigned, globally unique identifier. */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  A SourceContext is a reference to a tree of files. A SourceContext together
 *  with a path point to a unique revision of a single file or directory.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext : GTLRObject

/** A SourceContext referring to a revision in a Google Cloud Source Repo. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1CloudRepoSourceContext *cloudRepo;

/** A SourceContext referring to a Gerrit project. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1GerritSourceContext *gerrit;

/** A SourceContext referring to any third party Git repo (e.g., GitHub). */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1GitSourceContext *git;

/** Labels with user defined metadata. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext_Labels *labels;

@end


/**
 *  Labels with user defined metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext_Labels : GTLRObject
@end


/**
 *  Container message for hash values.
 */
@interface GTLRContainerAnalysis_Hash : GTLRObject

/**
 *  The type of hash that was performed.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Hash_Type_None No hash requested. (Value:
 *        "NONE")
 *    @arg @c kGTLRContainerAnalysis_Hash_Type_Sha256 A sha256 hash. (Value:
 *        "SHA256")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The hash value.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  This represents how a particular software package may be installed on
 *  a system.
 */
@interface GTLRContainerAnalysis_Installation : GTLRObject

/**
 *  All of the places within the filesystem versions of this package
 *  have been found.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Location *> *location;

/** Output only. The name of the installed package. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Layer holds metadata specific to a layer of a Docker image.
 */
@interface GTLRContainerAnalysis_Layer : GTLRObject

/** The recovered arguments to the Dockerfile directive. */
@property(nonatomic, copy, nullable) NSString *arguments;

/**
 *  The recovered Dockerfile directive used to construct this layer.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Add
 *        https://docs.docker.com/reference/builder/#add (Value: "ADD")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Arg
 *        https://docs.docker.com/reference/builder/#arg (Value: "ARG")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Cmd
 *        https://docs.docker.com/reference/builder/#cmd (Value: "CMD")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Copy
 *        https://docs.docker.com/reference/builder/#copy (Value: "COPY")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_DirectiveUnspecified
 *        Default value for unsupported/missing directive (Value:
 *        "DIRECTIVE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Entrypoint
 *        https://docs.docker.com/reference/builder/#entrypoint (Value:
 *        "ENTRYPOINT")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Env
 *        https://docs.docker.com/reference/builder/#env (Value: "ENV")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Expose
 *        https://docs.docker.com/reference/builder/#expose (Value: "EXPOSE")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Healthcheck
 *        https://docs.docker.com/reference/builder/#healthcheck (Value:
 *        "HEALTHCHECK")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Label
 *        https://docs.docker.com/reference/builder/#label (Value: "LABEL")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Maintainer
 *        https://docs.docker.com/reference/builder/#maintainer (Value:
 *        "MAINTAINER")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Onbuild
 *        https://docs.docker.com/reference/builder/#onbuild (Value: "ONBUILD")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Run
 *        https://docs.docker.com/reference/builder/#run (Value: "RUN")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Shell
 *        https://docs.docker.com/reference/builder/#shell (Value: "SHELL")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Stopsignal
 *        https://docs.docker.com/reference/builder/#stopsignal (Value:
 *        "STOPSIGNAL")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_User
 *        https://docs.docker.com/reference/builder/#user (Value: "USER")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Volume
 *        https://docs.docker.com/reference/builder/#volume (Value: "VOLUME")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Workdir
 *        https://docs.docker.com/reference/builder/#workdir (Value: "WORKDIR")
 */
@property(nonatomic, copy, nullable) NSString *directive;

@end


/**
 *  Response including listed occurrences for a note.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "occurrences" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListNoteOccurrencesResponse : GTLRCollectionObject

/** Token to receive the next page of notes. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The occurrences attached to the specified note.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Occurrence *> *occurrences;

@end


/**
 *  Response including listed notes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "notes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListNotesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the list response. It should be used as
 *  page_token for the following request. An empty value means no more result.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The occurrences requested
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Note *> *notes;

@end


/**
 *  Response including listed active occurrences.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "occurrences" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListOccurrencesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the list response. It should be used as
 *  `page_token` for the following request. An empty value means no more
 *  results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The occurrences requested.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Occurrence *> *occurrences;

@end


/**
 *  A list of scan configs for the project.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scanConfigs" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListScanConfigsResponse : GTLRCollectionObject

/** A page token to pass in order to get more scan configs. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The set of scan configs.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_ScanConfig *> *scanConfigs;

@end


/**
 *  An occurrence of a particular package installation found within a
 *  system's filesystem.
 *  e.g. glibc was found in /var/lib/dpkg/status
 */
@interface GTLRContainerAnalysis_Location : GTLRObject

/**
 *  The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
 *  denoting the package manager version distributing a package.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The path from which we gathered that this package/version is installed. */
@property(nonatomic, copy, nullable) NSString *path;

/** The version installed at this location. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *version;

@end


/**
 *  Provides a detailed description of a `Note`.
 */
@interface GTLRContainerAnalysis_Note : GTLRObject

/** A note describing an attestation role. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_AttestationAuthority *attestationAuthority;

/** A note describing a base image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Basis *baseImage;

/** Build provenance type for a verifiable build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildType *buildType;

/**
 *  Output only. The time this note was created. This field can be used as a
 *  filter in list requests.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** A note describing something that can be deployed. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Deployable *deployable;

/** A note describing a provider/analysis type. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Discovery *discovery;

/** Time of expiration for this note, null if note does not expire. */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTime;

/**
 *  Output only. This explicitly denotes which kind of note is specified. This
 *  field can be used as a filter in list requests.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_AttestationAuthority This
 *        represents a logical "role" that can attest to artifacts. (Value:
 *        "ATTESTATION_AUTHORITY")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_BuildDetails The note and
 *        occurrence assert build provenance. (Value: "BUILD_DETAILS")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Deployable The note and
 *        occurrence track deployment events. (Value: "DEPLOYABLE")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Discovery The note and occurrence
 *        track the initial discovery status of a resource. (Value: "DISCOVERY")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_ImageBasis This represents an
 *        image basis relationship. (Value: "IMAGE_BASIS")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_KindUnspecified Unknown (Value:
 *        "KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_PackageManager This represents a
 *        package installed via a package manager. (Value: "PACKAGE_MANAGER")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_PackageVulnerability The note and
 *        occurrence represent a package vulnerability. (Value:
 *        "PACKAGE_VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** A detailed description of this `Note`. */
@property(nonatomic, copy, nullable) NSString *longDescription;

/**
 *  The name of the note in the form
 *  "providers/{provider_id}/notes/{NOTE_ID}"
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A note describing a package hosted by various package managers. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Package *package;

/** URLs associated with this note */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_RelatedUrl *> *relatedUrl;

/** A one sentence description of this `Note`. */
@property(nonatomic, copy, nullable) NSString *shortDescription;

/**
 *  Output only. The time this note was last updated. This field can be used as
 *  a filter in list requests.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** A package vulnerability type of note. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityType *vulnerabilityType;

@end


/**
 *  `Occurrence` includes information about analysis occurrences for an image.
 */
@interface GTLRContainerAnalysis_Occurrence : GTLRObject

/** Describes an attestation of an artifact. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Attestation *attestation;

/** Build details for a verifiable build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildDetails *buildDetails;

/** Output only. The time this `Occurrence` was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Describes the deployment of an artifact on a runtime. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Deployment *deployment;

/**
 *  Describes how this resource derives from the basis
 *  in the associated note.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Derived *derivedImage;

/** Describes the initial scan status for this resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Discovered *discovered;

/** Describes the installation of a package on the linked resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Installation *installation;

/**
 *  Output only. This explicitly denotes which of the `Occurrence` details are
 *  specified. This field can be used as a filter in list requests.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_AttestationAuthority This
 *        represents a logical "role" that can attest to artifacts. (Value:
 *        "ATTESTATION_AUTHORITY")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_BuildDetails The note and
 *        occurrence assert build provenance. (Value: "BUILD_DETAILS")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Deployable The note and
 *        occurrence track deployment events. (Value: "DEPLOYABLE")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Discovery The note and
 *        occurrence track the initial discovery status of a resource. (Value:
 *        "DISCOVERY")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_ImageBasis This represents
 *        an image basis relationship. (Value: "IMAGE_BASIS")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_KindUnspecified Unknown
 *        (Value: "KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_PackageManager This
 *        represents a package installed via a package manager. (Value:
 *        "PACKAGE_MANAGER")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_PackageVulnerability The
 *        note and occurrence represent a package vulnerability. (Value:
 *        "PACKAGE_VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Output only. The name of the `Occurrence` in the form
 *  "projects/{project_id}/occurrences/{OCCURRENCE_ID}"
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  An analysis note associated with this image, in the form
 *  "providers/{provider_id}/notes/{NOTE_ID}"
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *noteName;

/** A description of actions that can be taken to remedy the `Note` */
@property(nonatomic, copy, nullable) NSString *remediation;

/** The resource for which the `Occurrence` applies. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Resource *resource;

/**
 *  The unique URL of the image or the container for which the `Occurrence`
 *  applies. For example, https://gcr.io/project/image\@sha256:foo This field
 *  can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *resourceUrl;

/** Output only. The time this `Occurrence` was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Details of a security vulnerability note. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityDetails *vulnerabilityDetails;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRContainerAnalysis_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress.
 *  If `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the
 *  `name` should have the format of `operations/some/unique/name`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_Operation_Response : GTLRObject
@end


/**
 *  This represents a particular package that is distributed over
 *  various channels.
 *  e.g. glibc (aka libc6) is distributed by many, at various versions.
 */
@interface GTLRContainerAnalysis_Package : GTLRObject

/** The various channels by which a package is distributed. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Distribution *> *distribution;

/** The name of the package. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  This message wraps a location affected by a vulnerability and its
 *  associated fix (if one is available).
 */
@interface GTLRContainerAnalysis_PackageIssue : GTLRObject

/** The location of the vulnerability. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityLocation *affectedLocation;

/** The location of the available fix for vulnerability. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityLocation *fixedLocation;

/** The severity (eg: distro assigned severity) for this vulnerability. */
@property(nonatomic, copy, nullable) NSString *severityName;

@end


/**
 *  An attestation wrapper with a PGP-compatible signature.
 *  This message only supports `ATTACHED` signatures, where the payload that is
 *  signed is included alongside the signature itself in the same file.
 */
@interface GTLRContainerAnalysis_PgpSignedAttestation : GTLRObject

/**
 *  Type (for example schema) of the attestation payload that was signed.
 *  The verifier must ensure that the provided type is one that the verifier
 *  supports, and that the attestation payload is a valid instantiation of that
 *  type (for example by validating a JSON schema).
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_ContentTypeUnspecified
 *        `ContentType` is not set. (Value: "CONTENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_SimpleSigningJson
 *        Atomic format attestation signature. See
 *        https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
 *        The payload extracted from `signature` is a JSON blob conforming to
 *        the
 *        linked schema. (Value: "SIMPLE_SIGNING_JSON")
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The cryptographic fingerprint of the key used to generate the signature,
 *  as output by, e.g. `gpg --list-keys`. This should be the version 4, full
 *  160-bit fingerprint, expressed as a 40 character hexadecimal string. See
 *  https://tools.ietf.org/html/rfc4880#section-12.2 for details.
 *  Implementations may choose to acknowledge "LONG", "SHORT", or other
 *  abbreviated key IDs, but only the full fingerprint is guaranteed to work.
 *  In gpg, the full fingerprint can be retrieved from the `fpr` field
 *  returned when calling --list-keys with --with-colons. For example:
 *  ```
 *  gpg --with-colons --with-fingerprint --force-v4-certs \\
 *  --list-keys attester\@example.com
 *  tru::1:1513631572:0:3:1:5
 *  pub:...<SNIP>...
 *  fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
 *  ```
 *  Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
 */
@property(nonatomic, copy, nullable) NSString *pgpKeyId;

/**
 *  The raw content of the signature, as output by GNU Privacy Guard (GPG) or
 *  equivalent. Since this message only supports attached signatures, the
 *  payload that was signed must be attached. While the signature format
 *  supported is dependent on the verification implementation, currently only
 *  ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
 *  `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
 *  --output=signature.gpg payload.json` will create the signature content
 *  expected in this field in `signature.gpg` for the `payload.json`
 *  attestation payload.
 */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  Defines an Identity and Access Management (IAM) policy. It is used to
 *  specify access control policies for Cloud Platform resources.
 *  A `Policy` consists of a list of `bindings`. A `binding` binds a list of
 *  `members` to a `role`, where the members can be user accounts, Google
 *  groups,
 *  Google domains, and service accounts. A `role` is a named list of
 *  permissions
 *  defined by IAM.
 *  **JSON Example**
 *  {
 *  "bindings": [
 *  {
 *  "role": "roles/owner",
 *  "members": [
 *  "user:mike\@example.com",
 *  "group:admins\@example.com",
 *  "domain:google.com",
 *  "serviceAccount:my-other-app\@appspot.gserviceaccount.com"
 *  ]
 *  },
 *  {
 *  "role": "roles/viewer",
 *  "members": ["user:sean\@example.com"]
 *  }
 *  ]
 *  }
 *  **YAML Example**
 *  bindings:
 *  - members:
 *  - user:mike\@example.com
 *  - group:admins\@example.com
 *  - domain:google.com
 *  - serviceAccount:my-other-app\@appspot.gserviceaccount.com
 *  role: roles/owner
 *  - members:
 *  - user:sean\@example.com
 *  role: roles/viewer
 *  For a description of IAM and its features, see the
 *  [IAM developer's guide](https://cloud.google.com/iam/docs).
 */
@interface GTLRContainerAnalysis_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members` to a `role`.
 *  `bindings` with no members will result in an error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help
 *  prevent simultaneous updates of a policy from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform policy updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `getIamPolicy`, and
 *  systems are expected to put that etag in the request to `setIamPolicy` to
 *  ensure that their change will be applied to the same version of the policy.
 *  If no `etag` is provided in the call to `setIamPolicy`, then the existing
 *  policy is overwritten blindly.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Deprecated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Metadata for any related URL information
 */
@interface GTLRContainerAnalysis_RelatedUrl : GTLRObject

/** Label to describe usage of the URL */
@property(nonatomic, copy, nullable) NSString *label;

/** Specific URL to associate with the note */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  RepoSource describes the location of the source in a Google Cloud Source
 *  Repository.
 */
@interface GTLRContainerAnalysis_RepoSource : GTLRObject

/** Name of the branch to build. */
@property(nonatomic, copy, nullable) NSString *branchName;

/** Explicit commit SHA to build. */
@property(nonatomic, copy, nullable) NSString *commitSha;

/** ID of the project that owns the repo. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Name of the repo. */
@property(nonatomic, copy, nullable) NSString *repoName;

/** Name of the tag to build. */
@property(nonatomic, copy, nullable) NSString *tagName;

@end


/**
 *  Resource is an entity that can have metadata. E.g., a Docker image.
 */
@interface GTLRContainerAnalysis_Resource : GTLRObject

/** The hash of the resource content. E.g., the Docker digest. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Hash *contentHash;

/** The name of the resource. E.g., the name of a Docker image - "Debian". */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The unique URI of the resource. E.g.,
 *  "https://gcr.io/project/image\@sha256:foo" for a Docker image.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Indicates various scans and whether they are turned on or off.
 */
@interface GTLRContainerAnalysis_ScanConfig : GTLRObject

/** Output only. The time this scan config was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. A human-readable description of what the `ScanConfig` does.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Indicates whether the Scan is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Output only. The name of the ScanConfig in the form
 *  “projects/{project_id}/scanConfigs/{scan_config_id}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. The time this scan config was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRContainerAnalysis_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a
 *  valid policy but certain Cloud Platform services (such as Projects)
 *  might reject them.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used:
 *  paths: "bindings, etag"
 *  This field is only used by Cloud IAM.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  The number of occurrences created for a specific severity.
 */
@interface GTLRContainerAnalysis_SeverityCount : GTLRObject

/**
 *  The number of occurrences with the severity.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The severity of the occurrences.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_SeverityCount_Severity_Critical Critical
 *        Impact (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_SeverityCount_Severity_High High Impact
 *        (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_SeverityCount_Severity_Low Low Impact
 *        (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_SeverityCount_Severity_Medium Medium Impact
 *        (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_SeverityCount_Severity_Minimal Minimal
 *        Impact (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_SeverityCount_Severity_SeverityUnspecified
 *        Unknown Impact (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  Source describes the location of the source used for the build.
 */
@interface GTLRContainerAnalysis_Source : GTLRObject

/**
 *  If provided, some of the source code used for the build may be found in
 *  these locations, in the case where the source repository had multiple
 *  remotes or submodules. This list will not include the context specified in
 *  the context field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext *> *additionalContexts;

/**
 *  If provided, the input binary artifacts for the build came from this
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_StorageSource *artifactStorageSource;

/**
 *  If provided, the source code used for the build came from this location.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1SourceContext *context;

/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build.
 *  The keys to this map are file paths used as build source and the values
 *  contain the hash values for those files.
 *  If the build source came in a single package such as a gzipped tarfile
 *  (.tar.gz), the FileHash will be for the single path to that file.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Source_FileHashes *fileHashes;

/** If provided, get source from this location in a Cloud Repo. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_RepoSource *repoSource;

/**
 *  If provided, get the source from this location in in Google Cloud
 *  Storage.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_StorageSource *storageSource;

@end


/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build.
 *  The keys to this map are file paths used as build source and the values
 *  contain the hash values for those files.
 *  If the build source came in a single package such as a gzipped tarfile
 *  (.tar.gz), the FileHash will be for the single path to that file.
 *
 *  @note This class is documented as having more properties of
 *        GTLRContainerAnalysis_FileHashes. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_Source_FileHashes : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` that can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRContainerAnalysis_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRContainerAnalysis_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_Status_Details_Item : GTLRObject
@end


/**
 *  StorageSource describes the location of the source in an archive file in
 *  Google Cloud Storage.
 */
@interface GTLRContainerAnalysis_StorageSource : GTLRObject

/**
 *  Google Cloud Storage bucket containing source (see [Bucket Name
 *  Requirements]
 *  (https://cloud.google.com/storage/docs/bucket-naming#requirements)).
 */
@property(nonatomic, copy, nullable) NSString *bucket;

/**
 *  Google Cloud Storage generation for the object.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *generation;

/** Google Cloud Storage object containing source. */
@property(nonatomic, copy, nullable) NSString *object;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRContainerAnalysis_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as '*' or 'storage.*') are not allowed. For more
 *  information see
 *  [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRContainerAnalysis_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is
 *  allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Request for updating an existing operation
 */
@interface GTLRContainerAnalysis_UpdateOperationRequest : GTLRObject

/** The operation to create. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Operation *operation;

/**
 *  The fields to update.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Version contains structured information about the version of the package.
 *  For a discussion of this in Debian/Ubuntu:
 *  http://serverfault.com/questions/604541/debian-packages-version-convention
 *  For a discussion of this in Redhat/Fedora/Centos:
 *  http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
 */
@interface GTLRContainerAnalysis_Version : GTLRObject

/**
 *  Used to correct mistakes in the version numbering scheme.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *epoch;

/**
 *  Distinguish between sentinel MIN/MAX versions and normal versions.
 *  If kind is not NORMAL, then the other fields are ignored.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_Maximum A special version
 *        representing positive infinity,
 *        other fields are ignored. (Value: "MAXIMUM")
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_Minimum A special version
 *        representing negative infinity,
 *        other fields are ignored. (Value: "MINIMUM")
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_Normal A standard package
 *        version, defined by the other fields. (Value: "NORMAL")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The main part of the version name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The iteration of the package build from the above version. */
@property(nonatomic, copy, nullable) NSString *revision;

@end


/**
 *  Used by Occurrence to point to where the vulnerability exists and how
 *  to fix it.
 */
@interface GTLRContainerAnalysis_VulnerabilityDetails : GTLRObject

/**
 *  Output only. The CVSS score of this vulnerability. CVSS score is on a
 *  scale of 0-10 where 0 indicates low severity and 10 indicates high
 *  severity.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssScore;

/**
 *  The set of affected locations and their fixes (if available) within
 *  the associated resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_PackageIssue *> *packageIssue;

/**
 *  Output only. The note provider assigned Severity of the vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Critical
 *        Critical Impact (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityDetails_Severity_High High
 *        Impact (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Low Low
 *        Impact (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Medium Medium
 *        Impact (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityDetails_Severity_Minimal
 *        Minimal Impact (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityDetails_Severity_SeverityUnspecified
 *        Unknown Impact (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/**
 *  The type of package; whether native or non native(ruby gems,
 *  node.js packages etc)
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The location of the vulnerability
 */
@interface GTLRContainerAnalysis_VulnerabilityLocation : GTLRObject

/**
 *  The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/)
 *  format. Examples include distro or storage location for vulnerable jar.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The package being described. */
@property(nonatomic, copy, nullable) NSString *package;

/**
 *  The version of the package being described.
 *  This field can be used as a filter in list requests.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *version;

@end


/**
 *  VulnerabilityType provides metadata about a security vulnerability.
 */
@interface GTLRContainerAnalysis_VulnerabilityType : GTLRObject

/**
 *  The CVSS score for this Vulnerability.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssScore;

/**
 *  All information about the package to specifically identify this
 *  vulnerability. One entry per (version range and cpe_uri) the
 *  package vulnerability has manifested in.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Detail *> *details;

/**
 *  Note provider assigned impact of the vulnerability
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityType_Severity_Critical
 *        Critical Impact (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityType_Severity_High High Impact
 *        (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityType_Severity_Low Low Impact
 *        (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityType_Severity_Medium Medium
 *        Impact (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityType_Severity_Minimal Minimal
 *        Impact (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_VulnerabilityType_Severity_SeverityUnspecified
 *        Unknown Impact (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
