// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Container Analysis API (containeranalysis/v1beta1)
// Description:
//   An implementation of the Grafeas API, which stores, and enables querying
//   and retrieval of critical metadata about all of your software artifacts.
// Documentation:
//   https://cloud.google.com/container-analysis/api/reference/rest/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRContainerAnalysis_AliasContext;
@class GTLRContainerAnalysis_Artifact;
@class GTLRContainerAnalysis_ArtifactHashes;
@class GTLRContainerAnalysis_ArtifactRule;
@class GTLRContainerAnalysis_Attestation;
@class GTLRContainerAnalysis_Authority;
@class GTLRContainerAnalysis_Basis;
@class GTLRContainerAnalysis_BatchCreateNotesRequest_Notes;
@class GTLRContainerAnalysis_Binding;
@class GTLRContainerAnalysis_Build;
@class GTLRContainerAnalysis_BuildProvenance;
@class GTLRContainerAnalysis_BuildProvenance_BuildOptions;
@class GTLRContainerAnalysis_BuildSignature;
@class GTLRContainerAnalysis_ByProducts;
@class GTLRContainerAnalysis_ByProducts_CustomValues;
@class GTLRContainerAnalysis_CloudRepoSourceContext;
@class GTLRContainerAnalysis_Command;
@class GTLRContainerAnalysis_CVSSv3;
@class GTLRContainerAnalysis_Deployable;
@class GTLRContainerAnalysis_Deployment;
@class GTLRContainerAnalysis_Derived;
@class GTLRContainerAnalysis_Detail;
@class GTLRContainerAnalysis_Details;
@class GTLRContainerAnalysis_Discovered;
@class GTLRContainerAnalysis_Discovery;
@class GTLRContainerAnalysis_Distribution;
@class GTLRContainerAnalysis_DocumentNote;
@class GTLRContainerAnalysis_DocumentOccurrence;
@class GTLRContainerAnalysis_Environment;
@class GTLRContainerAnalysis_Environment_CustomValues;
@class GTLRContainerAnalysis_Expr;
@class GTLRContainerAnalysis_ExternalRef;
@class GTLRContainerAnalysis_FileHashes;
@class GTLRContainerAnalysis_FileNote;
@class GTLRContainerAnalysis_FileOccurrence;
@class GTLRContainerAnalysis_Fingerprint;
@class GTLRContainerAnalysis_FixableTotalByDigest;
@class GTLRContainerAnalysis_GenericSignedAttestation;
@class GTLRContainerAnalysis_GerritSourceContext;
@class GTLRContainerAnalysis_GetPolicyOptions;
@class GTLRContainerAnalysis_GitSourceContext;
@class GTLRContainerAnalysis_GrafeasV1beta1BuildDetails;
@class GTLRContainerAnalysis_GrafeasV1beta1DeploymentDetails;
@class GTLRContainerAnalysis_GrafeasV1beta1DiscoveryDetails;
@class GTLRContainerAnalysis_GrafeasV1beta1ImageDetails;
@class GTLRContainerAnalysis_GrafeasV1beta1IntotoArtifact;
@class GTLRContainerAnalysis_GrafeasV1beta1IntotoDetails;
@class GTLRContainerAnalysis_GrafeasV1beta1IntotoSignature;
@class GTLRContainerAnalysis_GrafeasV1beta1PackageDetails;
@class GTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails;
@class GTLRContainerAnalysis_Hash;
@class GTLRContainerAnalysis_Hint;
@class GTLRContainerAnalysis_Installation;
@class GTLRContainerAnalysis_InToto;
@class GTLRContainerAnalysis_KnowledgeBase;
@class GTLRContainerAnalysis_Layer;
@class GTLRContainerAnalysis_Link;
@class GTLRContainerAnalysis_Location;
@class GTLRContainerAnalysis_Note;
@class GTLRContainerAnalysis_Occurrence;
@class GTLRContainerAnalysis_Package;
@class GTLRContainerAnalysis_PackageIssue;
@class GTLRContainerAnalysis_PackageNote;
@class GTLRContainerAnalysis_PackageOccurrence;
@class GTLRContainerAnalysis_PgpSignedAttestation;
@class GTLRContainerAnalysis_Policy;
@class GTLRContainerAnalysis_ProjectRepoId;
@class GTLRContainerAnalysis_RelatedUrl;
@class GTLRContainerAnalysis_RelationshipNote;
@class GTLRContainerAnalysis_RelationshipOccurrence;
@class GTLRContainerAnalysis_RepoId;
@class GTLRContainerAnalysis_Resource;
@class GTLRContainerAnalysis_ScanConfig;
@class GTLRContainerAnalysis_Signature;
@class GTLRContainerAnalysis_SigningKey;
@class GTLRContainerAnalysis_Source;
@class GTLRContainerAnalysis_Source_FileHashes;
@class GTLRContainerAnalysis_SourceContext;
@class GTLRContainerAnalysis_SourceContext_Labels;
@class GTLRContainerAnalysis_Status;
@class GTLRContainerAnalysis_Status_Details_Item;
@class GTLRContainerAnalysis_TimeSpan;
@class GTLRContainerAnalysis_Version;
@class GTLRContainerAnalysis_Volume;
@class GTLRContainerAnalysis_Vulnerability;
@class GTLRContainerAnalysis_VulnerabilityLocation;
@class GTLRContainerAnalysis_WindowsDetail;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_AliasContext.kind

/**
 *  Git tag.
 *
 *  Value: "FIXED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_AliasContext_Kind_Fixed;
/**
 *  Unknown.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_AliasContext_Kind_KindUnspecified;
/**
 *  Git branch.
 *
 *  Value: "MOVABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_AliasContext_Kind_Movable;
/**
 *  Used to specify non-standard aliases. For example, if a Git repo has a ref
 *  named "refs/foo/bar".
 *
 *  Value: "OTHER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_AliasContext_Kind_Other;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_BuildSignature.keyType

/**
 *  `KeyType` is not set.
 *
 *  Value: "KEY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildSignature_KeyType_KeyTypeUnspecified;
/**
 *  `PGP ASCII Armored` public key.
 *
 *  Value: "PGP_ASCII_ARMORED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildSignature_KeyType_PgpAsciiArmored;
/**
 *  `PKIX PEM` public key.
 *
 *  Value: "PKIX_PEM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildSignature_KeyType_PkixPem;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_BuildStep.status

/**
 *  Build or step was canceled by a user.
 *
 *  Value: "CANCELLED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Cancelled;
/**
 *  Build was enqueued for longer than the value of `queue_ttl`.
 *
 *  Value: "EXPIRED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Expired;
/**
 *  Build or step failed to complete successfully.
 *
 *  Value: "FAILURE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Failure;
/**
 *  Build or step failed due to an internal cause.
 *
 *  Value: "INTERNAL_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_InternalError;
/**
 *  Build has been created and is pending execution and queuing. It has not been
 *  queued.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Pending;
/**
 *  Build or step is queued; work has not yet begun.
 *
 *  Value: "QUEUED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Queued;
/**
 *  Status of the build is unknown.
 *
 *  Value: "STATUS_UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_StatusUnknown;
/**
 *  Build or step finished successfully.
 *
 *  Value: "SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Success;
/**
 *  Build or step took longer than was allowed.
 *
 *  Value: "TIMEOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Timeout;
/**
 *  Build or step is being executed.
 *
 *  Value: "WORKING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_BuildStep_Status_Working;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.attackComplexity

/** Value: "ATTACK_COMPLEXITY_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackComplexity_AttackComplexityHigh;
/** Value: "ATTACK_COMPLEXITY_LOW" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackComplexity_AttackComplexityLow;
/** Value: "ATTACK_COMPLEXITY_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackComplexity_AttackComplexityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.attackVector

/** Value: "ATTACK_VECTOR_ADJACENT" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorAdjacent;
/** Value: "ATTACK_VECTOR_LOCAL" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorLocal;
/** Value: "ATTACK_VECTOR_NETWORK" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorNetwork;
/** Value: "ATTACK_VECTOR_PHYSICAL" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorPhysical;
/** Value: "ATTACK_VECTOR_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.availabilityImpact

/** Value: "IMPACT_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactHigh;
/** Value: "IMPACT_LOW" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactLow;
/** Value: "IMPACT_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactNone;
/** Value: "IMPACT_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.confidentialityImpact

/** Value: "IMPACT_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactHigh;
/** Value: "IMPACT_LOW" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactLow;
/** Value: "IMPACT_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactNone;
/** Value: "IMPACT_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.integrityImpact

/** Value: "IMPACT_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactHigh;
/** Value: "IMPACT_LOW" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactLow;
/** Value: "IMPACT_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactNone;
/** Value: "IMPACT_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.privilegesRequired

/** Value: "PRIVILEGES_REQUIRED_HIGH" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredHigh;
/** Value: "PRIVILEGES_REQUIRED_LOW" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredLow;
/** Value: "PRIVILEGES_REQUIRED_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredNone;
/** Value: "PRIVILEGES_REQUIRED_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.scope

/** Value: "SCOPE_CHANGED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_Scope_ScopeChanged;
/** Value: "SCOPE_UNCHANGED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_Scope_ScopeUnchanged;
/** Value: "SCOPE_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_Scope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_CVSSv3.userInteraction

/** Value: "USER_INTERACTION_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_UserInteraction_UserInteractionNone;
/** Value: "USER_INTERACTION_REQUIRED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_UserInteraction_UserInteractionRequired;
/** Value: "USER_INTERACTION_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_CVSSv3_UserInteraction_UserInteractionUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Deployment.platform

/**
 *  Custom user-defined platform.
 *
 *  Value: "CUSTOM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_Custom;
/**
 *  Google App Engine: Flexible Environment.
 *
 *  Value: "FLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_Flex;
/**
 *  Google Container Engine.
 *
 *  Value: "GKE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_Gke;
/**
 *  Unknown.
 *
 *  Value: "PLATFORM_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Deployment_Platform_PlatformUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Discovered.analysisStatus

/**
 *  Unknown.
 *
 *  Value: "ANALYSIS_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_AnalysisStatusUnspecified;
/**
 *  Analysis has finished unsuccessfully, the analysis itself is in a bad state.
 *
 *  Value: "FINISHED_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedFailed;
/**
 *  Analysis has finished successfully.
 *
 *  Value: "FINISHED_SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedSuccess;
/**
 *  The resource is known not to be supported
 *
 *  Value: "FINISHED_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedUnsupported;
/**
 *  Resource is known but no action has been taken yet.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_Pending;
/**
 *  Resource is being analyzed.
 *
 *  Value: "SCANNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_AnalysisStatus_Scanning;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Discovered.continuousAnalysis

/**
 *  The resource is continuously analyzed.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Active;
/**
 *  Unknown.
 *
 *  Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_ContinuousAnalysisUnspecified;
/**
 *  The resource is ignored for continuous analysis.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Inactive;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Discovery.analysisKind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Attestation;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Build;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Deployment;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Image;
/**
 *  This represents an in-toto link.
 *
 *  Value: "INTOTO"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Intoto;
/**
 *  Default value. This value is unused.
 *
 *  Value: "NOTE_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_NoteKindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Package;
/**
 *  This represents a software bill of materials.
 *
 *  Value: "SBOM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Sbom;
/**
 *  This represents an SPDX File.
 *
 *  Value: "SPDX_FILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_SpdxFile;
/**
 *  This represents an SPDX Package.
 *
 *  Value: "SPDX_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_SpdxPackage;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "VULNERABILITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Discovery_AnalysisKind_Vulnerability;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Distribution.architecture

/**
 *  Unknown architecture.
 *
 *  Value: "ARCHITECTURE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Distribution_Architecture_ArchitectureUnspecified;
/**
 *  X64 architecture.
 *
 *  Value: "X64"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Distribution_Architecture_X64;
/**
 *  X86 architecture.
 *
 *  Value: "X86"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Distribution_Architecture_X86;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_ExternalRef.category

/**
 *  Unspecified
 *
 *  Value: "CATEGORY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_ExternalRef_Category_CategoryUnspecified;
/**
 *  Other
 *
 *  Value: "OTHER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_ExternalRef_Category_Other;
/**
 *  Package Manager (e.g. maven-central, npm, nuget, bower, purl)
 *
 *  Value: "PACKAGE_MANAGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_ExternalRef_Category_PackageManager;
/**
 *  Persistent-Id (e.g. swh)
 *
 *  Value: "PERSISTENT_ID"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_ExternalRef_Category_PersistentId;
/**
 *  Security (e.g. cpe22Type, cpe23Type)
 *
 *  Value: "SECURITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_ExternalRef_Category_Security;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_FileNote.fileType

/**
 *  The file is associated with a specific application type (MIME type of
 *  application/ *)
 *
 *  Value: "APPLICATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Application;
/**
 *  The file represents an archive (.tar, .jar, etc.)
 *
 *  Value: "ARCHIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Archive;
/**
 *  The file is associated with an audio file (MIME type of audio/ * , e.g.
 *  .mp3)
 *
 *  Value: "AUDIO"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Audio;
/**
 *  The file is a compiled object, target image or binary executable (.o, .a,
 *  etc.)
 *
 *  Value: "BINARY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Binary;
/**
 *  The file serves as documentation
 *
 *  Value: "DOCUMENTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Documentation;
/**
 *  Unspecified
 *
 *  Value: "FILE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_FileTypeUnspecified;
/**
 *  The file is associated with an picture image file (MIME type of image/ *,
 *  e.g., .jpg, .gif)
 *
 *  Value: "IMAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Image;
/**
 *  The file doesn't fit into the above categories (generated artifacts, data
 *  files, etc.)
 *
 *  Value: "OTHER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Other;
/**
 *  The file is human readable source code (.c, .html, etc.)
 *
 *  Value: "SOURCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Source;
/**
 *  The file is an SPDX document
 *
 *  Value: "SPDX"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Spdx;
/**
 *  The file is human readable text file (MIME type of text/ *)
 *
 *  Value: "TEXT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Text;
/**
 *  The file is associated with a video file type (MIME type of video/ *)
 *
 *  Value: "VIDEO"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FileNote_FileType_Video;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_FixableTotalByDigest.severity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FixableTotalByDigest_Severity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_FixableTotalByDigest_Severity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_GenericSignedAttestation.contentType

/**
 *  `ContentType` is not set.
 *
 *  Value: "CONTENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GenericSignedAttestation_ContentType_ContentTypeUnspecified;
/**
 *  Atomic format attestation signature. See
 *  https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
 *  The payload extracted in `plaintext` is a JSON blob conforming to the linked
 *  schema.
 *
 *  Value: "SIMPLE_SIGNING_JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GenericSignedAttestation_ContentType_SimpleSigningJson;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails.effectiveSeverity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails.severity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Hash.type

/**
 *  Unknown.
 *
 *  Value: "HASH_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Hash_Type_HashTypeUnspecified;
/**
 *  A SHA-256 hash.
 *
 *  Value: "SHA256"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Hash_Type_Sha256;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Layer.directive

/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "ADD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Add;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "ARG"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Arg;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "CMD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Cmd;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "COPY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Copy;
/**
 *  Default value for unsupported/missing directive.
 *
 *  Value: "DIRECTIVE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_DirectiveUnspecified;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "ENTRYPOINT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Entrypoint;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "ENV"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Env;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "EXPOSE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Expose;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "HEALTHCHECK"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Healthcheck;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "LABEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Label;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "MAINTAINER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Maintainer;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "ONBUILD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Onbuild;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "RUN"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Run;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "SHELL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Shell;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "STOPSIGNAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Stopsignal;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_User;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "VOLUME"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Volume;
/**
 *  https://docs.docker.com/engine/reference/builder/
 *
 *  Value: "WORKDIR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Layer_Directive_Workdir;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Note.kind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Attestation;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Build;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Deployment;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Image;
/**
 *  This represents an in-toto link.
 *
 *  Value: "INTOTO"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Intoto;
/**
 *  Default value. This value is unused.
 *
 *  Value: "NOTE_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_NoteKindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Package;
/**
 *  This represents a software bill of materials.
 *
 *  Value: "SBOM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Sbom;
/**
 *  This represents an SPDX File.
 *
 *  Value: "SPDX_FILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_SpdxFile;
/**
 *  This represents an SPDX Package.
 *
 *  Value: "SPDX_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_SpdxPackage;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "VULNERABILITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Note_Kind_Vulnerability;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Occurrence.kind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Attestation;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Build;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Deployment;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Image;
/**
 *  This represents an in-toto link.
 *
 *  Value: "INTOTO"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Intoto;
/**
 *  Default value. This value is unused.
 *
 *  Value: "NOTE_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_NoteKindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Package;
/**
 *  This represents a software bill of materials.
 *
 *  Value: "SBOM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Sbom;
/**
 *  This represents an SPDX File.
 *
 *  Value: "SPDX_FILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_SpdxFile;
/**
 *  This represents an SPDX Package.
 *
 *  Value: "SPDX_PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_SpdxPackage;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "VULNERABILITY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Occurrence_Kind_Vulnerability;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_PackageIssue.effectiveSeverity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_PgpSignedAttestation.contentType

/**
 *  `ContentType` is not set.
 *
 *  Value: "CONTENT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_ContentTypeUnspecified;
/**
 *  Atomic format attestation signature. See
 *  https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
 *  The payload extracted from `signature` is a JSON blob conforming to the
 *  linked schema.
 *
 *  Value: "SIMPLE_SIGNING_JSON"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_SimpleSigningJson;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_RelationshipOccurrence.type

/**
 *  Is to be used when (current) SPDXRef-DOCUMENT amends the SPDX information in
 *  SPDXRef-B
 *
 *  Value: "AMENDS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_Amends;
/**
 *  Is to be used when SPDXRef-A is an ancestor (same lineage but pre-dates)
 *  SPDXRef-B
 *
 *  Value: "ANCESTOR_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_AncestorOf;
/**
 *  Is to be used when SPDXRef-A is a build dependency of SPDXRef-B
 *
 *  Value: "BUILD_DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_BuildDependencyOf;
/**
 *  Is to be used when SPDXRef-A is used to build SPDXRef-B
 *
 *  Value: "BUILD_TOOL_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_BuildToolOf;
/**
 *  Is to be used when SPDXRef-A is contained by SPDXRef-B
 *
 *  Value: "CONTAINED_BY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_ContainedBy;
/**
 *  Is to be used when SPDXRef-A contains SPDXRef-B
 *
 *  Value: "CONTAINS"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_Contains;
/**
 *  Is to be used when SPDXRef-A is an exact copy of SPDXRef-B
 *
 *  Value: "COPY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_CopyOf;
/**
 *  Is to be used when SPDXRef-A is a data file used in SPDXRef-B
 *
 *  Value: "DATA_FILE_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DataFileOf;
/**
 *  Is to be used when SPDXRef-A is a manifest file that lists a set of
 *  dependencies for SPDXRef-B
 *
 *  Value: "DEPENDENCY_MANIFEST_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DependencyManifestOf;
/**
 *  Is to be used when SPDXRef-A is dependency of SPDXRef-B
 *
 *  Value: "DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DependencyOf;
/**
 *  Is to be used when SPDXRef-A depends on SPDXRef-B
 *
 *  Value: "DEPENDS_ON"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DependsOn;
/**
 *  Is to be used when SPDXRef-A is a descendant of (same lineage but postdates)
 *  SPDXRef-B
 *
 *  Value: "DESCENDANT_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DescendantOf;
/**
 *  Is to be used when SPDXRef-A is described by SPDXREF-Document
 *
 *  Value: "DESCRIBED_BY"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DescribedBy;
/**
 *  Is to be used when SPDXRef-DOCUMENT describes SPDXRef-A
 *
 *  Value: "DESCRIBES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_Describes;
/**
 *  Is to be used when SPDXRef-A is a development dependency of SPDXRef-B
 *
 *  Value: "DEV_DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DevDependencyOf;
/**
 *  Is to be used when SPDXRef-A is used as a development tool for SPDXRef-B
 *
 *  Value: "DEV_TOOL_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DevToolOf;
/**
 *  Is to be used when distributing SPDXRef-A requires that SPDXRef-B also be
 *  distributed
 *
 *  Value: "DISTRIBUTION_ARTIFACT"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DistributionArtifact;
/**
 *  Is to be used when SPDXRef-A provides documentation of SPDXRef-B
 *
 *  Value: "DOCUMENTATION_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DocumentationOf;
/**
 *  Is to be used when SPDXRef-A dynamically links to SPDXRef-B
 *
 *  Value: "DYNAMIC_LINK"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_DynamicLink;
/**
 *  Is to be used when SPDXRef-A is an example of SPDXRef-B
 *
 *  Value: "EXAMPLE_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_ExampleOf;
/**
 *  Is to be used when SPDXRef-A is expanded from the archive SPDXRef-B
 *
 *  Value: "EXPANDED_FROM_ARCHIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_ExpandedFromArchive;
/**
 *  Is to be used when SPDXRef-A is a file that was added to SPDXRef-B
 *
 *  Value: "FILE_ADDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_FileAdded;
/**
 *  Is to be used when SPDXRef-A is a file that was deleted from SPDXRef-B
 *
 *  Value: "FILE_DELETED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_FileDeleted;
/**
 *  Is to be used when SPDXRef-A is a file that was modified from SPDXRef-B
 *
 *  Value: "FILE_MODIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_FileModified;
/**
 *  Is to be used when SPDXRef-A was generated from SPDXRef-B
 *
 *  Value: "GENERATED_FROM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_GeneratedFrom;
/**
 *  Is to be used when SPDXRef-A generates SPDXRef-B
 *
 *  Value: "GENERATES"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_Generates;
/**
 *  Is to be used when SPDXRef-A has as a prerequisite SPDXRef-B
 *
 *  Value: "HAS_PREREQUISITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_HasPrerequisite;
/**
 *  Is to be used when SPDXRef-A is a metafile of SPDXRef-B
 *
 *  Value: "METAFILE_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_MetafileOf;
/**
 *  Is to be used when SPDXRef-A is an optional component of SPDXRef-B
 *
 *  Value: "OPTIONAL_COMPONENT_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_OptionalComponentOf;
/**
 *  Is to be used when SPDXRef-A is an optional dependency of SPDXRef-B
 *
 *  Value: "OPTIONAL_DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_OptionalDependencyOf;
/**
 *  Is to be used for a relationship which has not been defined in the formal
 *  SPDX specification. A description of the relationship should be included in
 *  the Relationship comments field
 *
 *  Value: "OTHER"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_Other;
/**
 *  Is to be used when SPDXRef-A is used as a package as part of SPDXRef-B
 *
 *  Value: "PACKAGE_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_PackageOf;
/**
 *  Is to be used when SPDXRef-A is a patch file that has been applied to
 *  SPDXRef-B
 *
 *  Value: "PATCH_APPLIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_PatchApplied;
/**
 *  Is to be used when SPDXRef-A is a patch file for (to be applied to)
 *  SPDXRef-B
 *
 *  Value: "PATCH_FOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_PatchFor;
/**
 *  Is to be used when SPDXRef-A is a prerequisite for SPDXRef-B
 *
 *  Value: "PREREQUISITE_FOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_PrerequisiteFor;
/**
 *  Is to be used when SPDXRef-A is a to be provided dependency of SPDXRef-B
 *
 *  Value: "PROVIDED_DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_ProvidedDependencyOf;
/**
 *  Is to be used when SPDXRef-A is a dependency required for the execution of
 *  SPDXRef-B
 *
 *  Value: "RUNTIME_DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_RuntimeDependencyOf;
/**
 *  Is to be used when SPDXRef-A statically links to SPDXRef-B
 *
 *  Value: "STATIC_LINK"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_StaticLink;
/**
 *  Is to be used when SPDXRef-A is a test case used in testing SPDXRef-B
 *
 *  Value: "TEST_CASE_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestCaseOf;
/**
 *  Is to be used when SPDXRef-A is a test dependency of SPDXRef-B
 *
 *  Value: "TEST_DEPENDENCY_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestDependencyOf;
/**
 *  Is to be used when SPDXRef-A is used for testing SPDXRef-B
 *
 *  Value: "TEST_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestOf;
/**
 *  Is to be used when SPDXRef-A is used as a test tool for SPDXRef-B
 *
 *  Value: "TEST_TOOL_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestToolOf;
/**
 *  Unspecified
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_TypeUnspecified;
/**
 *  Is to be used when SPDXRef-A is a variant of (same lineage but not clear
 *  which came first) SPDXRef-B
 *
 *  Value: "VARIANT_OF"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_RelationshipOccurrence_Type_VariantOf;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Version.kind

/**
 *  A special version representing positive infinity.
 *
 *  Value: "MAXIMUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_Maximum;
/**
 *  A special version representing negative infinity.
 *
 *  Value: "MINIMUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_Minimum;
/**
 *  A standard package version.
 *
 *  Value: "NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_Normal;
/**
 *  Unknown.
 *
 *  Value: "VERSION_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Version_Kind_VersionKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainerAnalysis_Vulnerability.severity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Vulnerability_Severity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Vulnerability_Severity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Vulnerability_Severity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Vulnerability_Severity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Vulnerability_Severity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRContainerAnalysis_Vulnerability_Severity_SeverityUnspecified;

/**
 *  An alias to a repo revision.
 */
@interface GTLRContainerAnalysis_AliasContext : GTLRObject

/**
 *  The alias kind.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_AliasContext_Kind_Fixed Git tag. (Value:
 *        "FIXED")
 *    @arg @c kGTLRContainerAnalysis_AliasContext_Kind_KindUnspecified Unknown.
 *        (Value: "KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_AliasContext_Kind_Movable Git branch.
 *        (Value: "MOVABLE")
 *    @arg @c kGTLRContainerAnalysis_AliasContext_Kind_Other Used to specify
 *        non-standard aliases. For example, if a Git repo has a ref named
 *        "refs/foo/bar". (Value: "OTHER")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The alias name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Artifact describes a build product.
 */
@interface GTLRContainerAnalysis_Artifact : GTLRObject

/**
 *  Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
 *  container.
 */
@property(nonatomic, copy, nullable) NSString *checksum;

/**
 *  Artifact ID, if any; for container images, this will be a URL by digest like
 *  `gcr.io/projectID/imagename\@sha256:123456`.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Related artifact names. This may be the path to a binary or jar file, or in
 *  the case of a container build, the name used to push the container image to
 *  Google Container Registry, as presented to `docker push`. Note that a single
 *  Artifact ID can have multiple names, for example if two tags are applied to
 *  one image.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *names;

@end


/**
 *  Defines a hash object for use in Materials and Products.
 */
@interface GTLRContainerAnalysis_ArtifactHashes : GTLRObject

@property(nonatomic, copy, nullable) NSString *sha256;

@end


/**
 *  Defines an object to declare an in-toto artifact rule
 */
@interface GTLRContainerAnalysis_ArtifactRule : GTLRObject

@property(nonatomic, strong, nullable) NSArray<NSString *> *artifactRule;

@end


/**
 *  Occurrence that represents a single "attestation". The authenticity of an
 *  attestation can be verified using the attached signature. If the verifier
 *  trusts the public key of the signer, then verifying the signature is
 *  sufficient to establish trust. In this circumstance, the authority to which
 *  this attestation is attached is primarily useful for look-up (how to find
 *  this attestation if you already know the authority and artifact to be
 *  verified) and intent (which authority was this attestation intended to sign
 *  for).
 */
@interface GTLRContainerAnalysis_Attestation : GTLRObject

@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GenericSignedAttestation *genericSignedAttestation;

/** A PGP signed attestation. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_PgpSignedAttestation *pgpSignedAttestation;

@end


/**
 *  Note kind that represents a logical attestation "role" or "authority". For
 *  example, an organization might have one `Authority` for "QA" and one for
 *  "build". This note is intended to act strictly as a grouping mechanism for
 *  the attached occurrences (Attestations). This grouping mechanism also
 *  provides a security boundary, since IAM ACLs gate the ability for a
 *  principle to attach an occurrence to a given note. It also provides a single
 *  point of lookup to find all attached attestation occurrences, even if they
 *  don't all live in the same project.
 */
@interface GTLRContainerAnalysis_Authority : GTLRObject

/** Hint hints at the purpose of the attestation authority. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Hint *hint;

@end


/**
 *  Basis describes the base image portion (Note) of the DockerImage
 *  relationship. Linked occurrences are derived from this or an equivalent
 *  image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
 */
@interface GTLRContainerAnalysis_Basis : GTLRObject

/** Required. Immutable. The fingerprint of the base image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Fingerprint *fingerprint;

/**
 *  Required. Immutable. The resource_url for the resource representing the
 *  basis of associated occurrence images.
 */
@property(nonatomic, copy, nullable) NSString *resourceUrl;

@end


/**
 *  Request to create notes in batch.
 */
@interface GTLRContainerAnalysis_BatchCreateNotesRequest : GTLRObject

/**
 *  Required. The notes to create, the key is expected to be the note ID. Max
 *  allowed length is 1000.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BatchCreateNotesRequest_Notes *notes;

@end


/**
 *  Required. The notes to create, the key is expected to be the note ID. Max
 *  allowed length is 1000.
 *
 *  @note This class is documented as having more properties of
 *        GTLRContainerAnalysis_Note. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_BatchCreateNotesRequest_Notes : GTLRObject
@end


/**
 *  Response for creating notes in batch.
 */
@interface GTLRContainerAnalysis_BatchCreateNotesResponse : GTLRObject

/** The notes that were created. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Note *> *notes;

@end


/**
 *  Request to create occurrences in batch.
 */
@interface GTLRContainerAnalysis_BatchCreateOccurrencesRequest : GTLRObject

/** Required. The occurrences to create. Max allowed length is 1000. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Occurrence *> *occurrences;

@end


/**
 *  Response for creating occurrences in batch.
 */
@interface GTLRContainerAnalysis_BatchCreateOccurrencesResponse : GTLRObject

/** The occurrences that were created. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Occurrence *> *occurrences;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRContainerAnalysis_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the members in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. *
 *  `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@example.com` . * `serviceAccount:{emailid}`:
 *  An email address that represents a service account. For example,
 *  `my-other-app\@appspot.gserviceaccount.com`. * `group:{emailid}`: An email
 *  address that represents a Google group. For example, `admins\@example.com`.
 *  * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`. For example, `roles/viewer`,
 *  `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Note holding the version of the provider's builder and the signature of the
 *  provenance message in the build details occurrence.
 */
@interface GTLRContainerAnalysis_Build : GTLRObject

/** Required. Immutable. Version of the builder which produced this build. */
@property(nonatomic, copy, nullable) NSString *builderVersion;

/**
 *  Signature of the build in occurrences pointing to this build note containing
 *  build details.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildSignature *signature;

@end


/**
 *  Provenance of a build. Contains all information needed to verify the full
 *  details about the build from source to completion.
 */
@interface GTLRContainerAnalysis_BuildProvenance : GTLRObject

/** Version string of the builder at the time this build was executed. */
@property(nonatomic, copy, nullable) NSString *builderVersion;

/**
 *  Special options applied to this build. This is a catch-all field where build
 *  providers can enter any desired additional details.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildProvenance_BuildOptions *buildOptions;

/** Output of the build. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Artifact *> *builtArtifacts;

/** Commands requested by the build. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Command *> *commands;

/** Time at which the build was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  E-mail address of the user who initiated this build. Note that this was the
 *  user's e-mail address at the time the build was initiated; this address may
 *  not represent the same end-user for all time.
 */
@property(nonatomic, copy, nullable) NSString *creator;

/** Time at which execution of the build was finished. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Required. Unique identifier of the build.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** URI where any logs for this provenance were written. */
@property(nonatomic, copy, nullable) NSString *logsUri;

/** ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Details of the Source input to the build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Source *sourceProvenance;

/** Time at which execution of the build was started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Trigger identifier if the build was triggered automatically; empty if not.
 */
@property(nonatomic, copy, nullable) NSString *triggerId;

@end


/**
 *  Special options applied to this build. This is a catch-all field where build
 *  providers can enter any desired additional details.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainerAnalysis_BuildProvenance_BuildOptions : GTLRObject
@end


/**
 *  Message encapsulating the signature of the verified build.
 */
@interface GTLRContainerAnalysis_BuildSignature : GTLRObject

/**
 *  An ID for the key used to sign. This could be either an ID for the key
 *  stored in `public_key` (such as the ID or fingerprint for a PGP key, or the
 *  CN for a cert), or a reference to an external key (such as a reference to a
 *  key in Cloud Key Management Service).
 */
@property(nonatomic, copy, nullable) NSString *keyId;

/**
 *  The type of the key, either stored in `public_key` or referenced in
 *  `key_id`.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_BuildSignature_KeyType_KeyTypeUnspecified
 *        `KeyType` is not set. (Value: "KEY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_BuildSignature_KeyType_PgpAsciiArmored `PGP
 *        ASCII Armored` public key. (Value: "PGP_ASCII_ARMORED")
 *    @arg @c kGTLRContainerAnalysis_BuildSignature_KeyType_PkixPem `PKIX PEM`
 *        public key. (Value: "PKIX_PEM")
 */
@property(nonatomic, copy, nullable) NSString *keyType;

/**
 *  Public key of the builder which can be used to verify that the related
 *  findings are valid and unchanged. If `key_type` is empty, this defaults to
 *  PEM encoded public keys. This field may be empty if `key_id` references an
 *  external key. For Cloud Build based signatures, this is a PEM encoded public
 *  key. To verify the Cloud Build signature, place the contents of this field
 *  into a file (public.pem). The signature field is base64-decoded into its
 *  binary representation in signature.bin, and the provenance bytes from
 *  `BuildDetails` are base64-decoded into a binary representation in
 *  signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify
 *  public.pem -signature signature.bin signed.bin`
 */
@property(nonatomic, copy, nullable) NSString *publicKey;

/**
 *  Required. Signature of the related `BuildProvenance`. In JSON, this is
 *  base-64 encoded.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  A step in the build pipeline.
 */
@interface GTLRContainerAnalysis_BuildStep : GTLRObject

/**
 *  A list of arguments that will be presented to the step when it is started.
 *  If the image used to run the step's container has an entrypoint, the `args`
 *  are used as arguments to that entrypoint. If the image does not define an
 *  entrypoint, the first element in args is used as the entrypoint, and the
 *  remainder will be used as arguments.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

/**
 *  Working directory to use when running this step's container. If this value
 *  is a relative path, it is relative to the build's working directory. If this
 *  value is absolute, it may be outside the build's working directory, in which
 *  case the contents of the path may not be persisted across build step
 *  executions, unless a `volume` for that path is specified. If the build
 *  specifies a `RepoSource` with `dir` and a step with a `dir`, which specifies
 *  an absolute path, the `RepoSource` `dir` is ignored for the step's
 *  execution.
 */
@property(nonatomic, copy, nullable) NSString *dir;

/**
 *  Entrypoint to be used instead of the build step image's default entrypoint.
 *  If unset, the image's default entrypoint is used.
 */
@property(nonatomic, copy, nullable) NSString *entrypoint;

/**
 *  A list of environment variable definitions to be used when running a step.
 *  The elements are of the form "KEY=VALUE" for the environment variable "KEY"
 *  being given the value "VALUE".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *env;

/**
 *  Unique identifier for this build step, used in `wait_for` to reference this
 *  build step as a dependency.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Required. The name of the container image that will run this particular
 *  build step. If the image is available in the host's Docker daemon's cache,
 *  it will be run directly. If not, the host will attempt to pull the image
 *  first, using the builder service account's credentials if necessary. The
 *  Docker daemon's cache will already have the latest versions of all of the
 *  officially supported build steps
 *  ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
 *  The Docker daemon will also have cached many of the layers for some popular
 *  images, like "ubuntu", "debian", but they will be refreshed at the time you
 *  attempt to use them. If you built an image in a previous build step, it will
 *  be stored in the host's Docker daemon's cache and is available to use as the
 *  name for a later build step.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Stores timing information for pulling this build step's builder
 *  image only.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_TimeSpan *pullTiming;

/**
 *  A shell script to be executed in the step. When script is provided, the user
 *  cannot specify the entrypoint or args.
 */
@property(nonatomic, copy, nullable) NSString *script;

/**
 *  A list of environment variables which are encrypted using a Cloud Key
 *  Management Service crypto key. These values must be specified in the build's
 *  `Secret`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *secretEnv;

/**
 *  Output only. Status of the build step. At this time, build step status is
 *  only updated on build completion; step status is not updated in real-time as
 *  the build progresses.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Cancelled Build or step
 *        was canceled by a user. (Value: "CANCELLED")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Expired Build was enqueued
 *        for longer than the value of `queue_ttl`. (Value: "EXPIRED")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Failure Build or step
 *        failed to complete successfully. (Value: "FAILURE")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_InternalError Build or
 *        step failed due to an internal cause. (Value: "INTERNAL_ERROR")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Pending Build has been
 *        created and is pending execution and queuing. It has not been queued.
 *        (Value: "PENDING")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Queued Build or step is
 *        queued; work has not yet begun. (Value: "QUEUED")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_StatusUnknown Status of
 *        the build is unknown. (Value: "STATUS_UNKNOWN")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Success Build or step
 *        finished successfully. (Value: "SUCCESS")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Timeout Build or step took
 *        longer than was allowed. (Value: "TIMEOUT")
 *    @arg @c kGTLRContainerAnalysis_BuildStep_Status_Working Build or step is
 *        being executed. (Value: "WORKING")
 */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  Time limit for executing this build step. If not defined, the step has no
 *  time limit and will be allowed to continue to run until either it completes
 *  or the build itself times out.
 */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

/** Output only. Stores timing information for executing this build step. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_TimeSpan *timing;

/**
 *  List of volumes to mount into the build step. Each volume is created as an
 *  empty volume prior to execution of the build step. Upon completion of the
 *  build, volumes and their contents are discarded. Using a named volume in
 *  only one step is not valid as it is indicative of a build request with an
 *  incorrect configuration.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Volume *> *volumes;

/**
 *  The ID(s) of the step(s) that this build step depends on. This build step
 *  will not start until all the build steps in `wait_for` have completed
 *  successfully. If `wait_for` is empty, this build step will start when all
 *  previous build steps in the `Build.Steps` list have completed successfully.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *waitFor;

@end


/**
 *  Defines an object for the byproducts field in in-toto links. The suggested
 *  fields are "stderr", "stdout", and "return-value".
 */
@interface GTLRContainerAnalysis_ByProducts : GTLRObject

@property(nonatomic, strong, nullable) GTLRContainerAnalysis_ByProducts_CustomValues *customValues;

@end


/**
 *  GTLRContainerAnalysis_ByProducts_CustomValues
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainerAnalysis_ByProducts_CustomValues : GTLRObject
@end


/**
 *  A CloudRepoSourceContext denotes a particular revision in a Google Cloud
 *  Source Repo.
 */
@interface GTLRContainerAnalysis_CloudRepoSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_AliasContext *aliasContext;

/** The ID of the repo. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_RepoId *repoId;

/** A revision ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  Command describes a step performed as part of the build pipeline.
 */
@interface GTLRContainerAnalysis_Command : GTLRObject

/** Command-line arguments used when executing this command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

/**
 *  Working directory (relative to project source root) used when running this
 *  command.
 */
@property(nonatomic, copy, nullable) NSString *dir;

/** Environment variables set before running this command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *env;

/**
 *  Optional unique identifier for this command, used in wait_for to reference
 *  this command as a dependency.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Required. Name of the command, as presented on the command line, or if the
 *  command is packaged as a Docker container, as presented to `docker pull`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The ID(s) of the command(s) that this command depends on. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *waitFor;

@end


/**
 *  Common Vulnerability Scoring System version 3. For details, see
 *  https://www.first.org/cvss/specification-document
 */
@interface GTLRContainerAnalysis_CVSSv3 : GTLRObject

/**
 *  attackComplexity
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackComplexity_AttackComplexityHigh
 *        Value "ATTACK_COMPLEXITY_HIGH"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackComplexity_AttackComplexityLow
 *        Value "ATTACK_COMPLEXITY_LOW"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackComplexity_AttackComplexityUnspecified
 *        Value "ATTACK_COMPLEXITY_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *attackComplexity;

/**
 *  Base Metrics Represents the intrinsic characteristics of a vulnerability
 *  that are constant over time and across user environments.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorAdjacent
 *        Value "ATTACK_VECTOR_ADJACENT"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorLocal Value
 *        "ATTACK_VECTOR_LOCAL"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorNetwork
 *        Value "ATTACK_VECTOR_NETWORK"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorPhysical
 *        Value "ATTACK_VECTOR_PHYSICAL"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AttackVector_AttackVectorUnspecified
 *        Value "ATTACK_VECTOR_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *attackVector;

/**
 *  availabilityImpact
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactHigh Value
 *        "IMPACT_HIGH"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactLow Value
 *        "IMPACT_LOW"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactNone Value
 *        "IMPACT_NONE"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_AvailabilityImpact_ImpactUnspecified
 *        Value "IMPACT_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *availabilityImpact;

/**
 *  The base score is a function of the base metric scores.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *baseScore;

/**
 *  confidentialityImpact
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactHigh
 *        Value "IMPACT_HIGH"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactLow
 *        Value "IMPACT_LOW"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactNone
 *        Value "IMPACT_NONE"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_ConfidentialityImpact_ImpactUnspecified
 *        Value "IMPACT_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *confidentialityImpact;

/**
 *  exploitabilityScore
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exploitabilityScore;

/**
 *  impactScore
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *impactScore;

/**
 *  integrityImpact
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactHigh Value
 *        "IMPACT_HIGH"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactLow Value
 *        "IMPACT_LOW"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactNone Value
 *        "IMPACT_NONE"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_IntegrityImpact_ImpactUnspecified
 *        Value "IMPACT_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *integrityImpact;

/**
 *  privilegesRequired
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredHigh
 *        Value "PRIVILEGES_REQUIRED_HIGH"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredLow
 *        Value "PRIVILEGES_REQUIRED_LOW"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredNone
 *        Value "PRIVILEGES_REQUIRED_NONE"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_PrivilegesRequired_PrivilegesRequiredUnspecified
 *        Value "PRIVILEGES_REQUIRED_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *privilegesRequired;

/**
 *  scope
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_Scope_ScopeChanged Value
 *        "SCOPE_CHANGED"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_Scope_ScopeUnchanged Value
 *        "SCOPE_UNCHANGED"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_Scope_ScopeUnspecified Value
 *        "SCOPE_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *scope;

/**
 *  userInteraction
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_UserInteraction_UserInteractionNone
 *        Value "USER_INTERACTION_NONE"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_UserInteraction_UserInteractionRequired
 *        Value "USER_INTERACTION_REQUIRED"
 *    @arg @c kGTLRContainerAnalysis_CVSSv3_UserInteraction_UserInteractionUnspecified
 *        Value "USER_INTERACTION_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *userInteraction;

@end


/**
 *  An artifact that can be deployed in some runtime.
 */
@interface GTLRContainerAnalysis_Deployable : GTLRObject

/** Required. Resource URI for the artifact being deployed. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceUri;

@end


/**
 *  The period during which some deployable was active in a runtime.
 */
@interface GTLRContainerAnalysis_Deployment : GTLRObject

/** Address of the runtime element hosting this deployment. */
@property(nonatomic, copy, nullable) NSString *address;

/** Configuration used to create this deployment. */
@property(nonatomic, copy, nullable) NSString *config;

/** Required. Beginning of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *deployTime;

/**
 *  Platform hosting this deployment.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_Custom Custom
 *        user-defined platform. (Value: "CUSTOM")
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_Flex Google App Engine:
 *        Flexible Environment. (Value: "FLEX")
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_Gke Google Container
 *        Engine. (Value: "GKE")
 *    @arg @c kGTLRContainerAnalysis_Deployment_Platform_PlatformUnspecified
 *        Unknown. (Value: "PLATFORM_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *platform;

/**
 *  Output only. Resource URI for the artifact being deployed taken from the
 *  deployable field with the same name.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceUri;

/** End of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *undeployTime;

/** Identity of the user that triggered this deployment. */
@property(nonatomic, copy, nullable) NSString *userEmail;

@end


/**
 *  Derived describes the derived image portion (Occurrence) of the DockerImage
 *  relationship. This image would be produced from a Dockerfile with FROM .
 */
@interface GTLRContainerAnalysis_Derived : GTLRObject

/**
 *  Output only. This contains the base image URL for the derived image
 *  occurrence.
 */
@property(nonatomic, copy, nullable) NSString *baseResourceUrl;

/**
 *  Output only. The number of layers by which this image differs from the
 *  associated image basis.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *distance;

/** Required. The fingerprint of the derived image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Fingerprint *fingerprint;

/**
 *  This contains layer-specific metadata, if populated it has length "distance"
 *  and is ordered with [distance] being the layer immediately following the
 *  base image and [1] being the final layer.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Layer *> *layerInfo;

@end


/**
 *  Identifies all appearances of this vulnerability in the package for a
 *  specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8
 *  for versions 2.1 - 2.2
 */
@interface GTLRContainerAnalysis_Detail : GTLRObject

/**
 *  Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
 *  in which the vulnerability manifests. Examples include distro or storage
 *  location for vulnerable jar.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  A vendor-specific description of this note.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The fix for this specific package version. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityLocation *fixedLocation;

/**
 *  Whether this detail is obsolete. Occurrences are expected not to point to
 *  obsolete details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isObsolete;

/** The max version of the package in which the vulnerability exists. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *maxAffectedVersion;

/** The min version of the package in which the vulnerability exists. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *minAffectedVersion;

/** Required. The name of the package where the vulnerability was found. */
@property(nonatomic, copy, nullable) NSString *package;

/**
 *  The type of package; whether native or non native(ruby gems, node.js
 *  packages etc).
 */
@property(nonatomic, copy, nullable) NSString *packageType;

/** The severity (eg: distro assigned severity) for this vulnerability. */
@property(nonatomic, copy, nullable) NSString *severityName;

/** The source from which the information in this Detail was obtained. */
@property(nonatomic, copy, nullable) NSString *source;

/**
 *  The time this information was last changed at the source. This is an
 *  upstream timestamp from the underlying information source - e.g. Ubuntu
 *  security tracker.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *sourceUpdateTime;

/** The name of the vendor of the product. */
@property(nonatomic, copy, nullable) NSString *vendor;

@end


/**
 *  Details of an attestation occurrence.
 */
@interface GTLRContainerAnalysis_Details : GTLRObject

/** Required. Attestation for the resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Attestation *attestation;

@end


/**
 *  Provides information about the analysis status of a discovered resource.
 */
@interface GTLRContainerAnalysis_Discovered : GTLRObject

/**
 *  The status of discovery for the resource.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_AnalysisStatusUnspecified
 *        Unknown. (Value: "ANALYSIS_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedFailed
 *        Analysis has finished unsuccessfully, the analysis itself is in a bad
 *        state. (Value: "FINISHED_FAILED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedSuccess
 *        Analysis has finished successfully. (Value: "FINISHED_SUCCESS")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_FinishedUnsupported
 *        The resource is known not to be supported (Value:
 *        "FINISHED_UNSUPPORTED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_Pending Resource
 *        is known but no action has been taken yet. (Value: "PENDING")
 *    @arg @c kGTLRContainerAnalysis_Discovered_AnalysisStatus_Scanning Resource
 *        is being analyzed. (Value: "SCANNING")
 */
@property(nonatomic, copy, nullable) NSString *analysisStatus;

/**
 *  When an error is encountered this will contain a LocalizedMessage under
 *  details to show to the user. The LocalizedMessage is output only and
 *  populated by the API.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Status *analysisStatusError;

/**
 *  Whether the resource is continuously analyzed.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Active The
 *        resource is continuously analyzed. (Value: "ACTIVE")
 *    @arg @c kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_ContinuousAnalysisUnspecified
 *        Unknown. (Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Discovered_ContinuousAnalysis_Inactive The
 *        resource is ignored for continuous analysis. (Value: "INACTIVE")
 */
@property(nonatomic, copy, nullable) NSString *continuousAnalysis;

/**
 *  The last time continuous analysis was done for this resource. Deprecated, do
 *  not use.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastAnalysisTime;

@end


/**
 *  A note that indicates a type of analysis a provider would perform. This note
 *  exists in a provider's project. A `Discovery` occurrence is created in a
 *  consumer's project at the start of analysis.
 */
@interface GTLRContainerAnalysis_Discovery : GTLRObject

/**
 *  Required. Immutable. The kind of analysis that is handled by this discovery.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Attestation This
 *        represents a logical "role" that can attest to artifacts. (Value:
 *        "ATTESTATION")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Build The note and
 *        occurrence assert build provenance. (Value: "BUILD")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Deployment The note
 *        and occurrence track deployment events. (Value: "DEPLOYMENT")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Discovery The note
 *        and occurrence track the initial discovery status of a resource.
 *        (Value: "DISCOVERY")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Image This
 *        represents an image basis relationship. (Value: "IMAGE")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Intoto This
 *        represents an in-toto link. (Value: "INTOTO")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_NoteKindUnspecified
 *        Default value. This value is unused. (Value: "NOTE_KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Package This
 *        represents a package installed via a package manager. (Value:
 *        "PACKAGE")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Sbom This represents
 *        a software bill of materials. (Value: "SBOM")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_SpdxFile This
 *        represents an SPDX File. (Value: "SPDX_FILE")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_SpdxPackage This
 *        represents an SPDX Package. (Value: "SPDX_PACKAGE")
 *    @arg @c kGTLRContainerAnalysis_Discovery_AnalysisKind_Vulnerability The
 *        note and occurrence represent a package vulnerability. (Value:
 *        "VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *analysisKind;

@end


/**
 *  This represents a particular channel of distribution for a given package.
 *  E.g., Debian's jessie-backports dpkg mirror.
 */
@interface GTLRContainerAnalysis_Distribution : GTLRObject

/**
 *  The CPU architecture for which packages in this distribution channel were
 *  built.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Distribution_Architecture_ArchitectureUnspecified
 *        Unknown architecture. (Value: "ARCHITECTURE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Distribution_Architecture_X64 X64
 *        architecture. (Value: "X64")
 *    @arg @c kGTLRContainerAnalysis_Distribution_Architecture_X86 X86
 *        architecture. (Value: "X86")
 */
@property(nonatomic, copy, nullable) NSString *architecture;

/**
 *  Required. The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
 *  denoting the package manager version distributing a package.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  The distribution channel-specific description of this package.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The latest available version of this package in this distribution channel.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *latestVersion;

/** A freeform string denoting the maintainer of this package. */
@property(nonatomic, copy, nullable) NSString *maintainer;

/** The distribution channel-specific homepage for this package. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  DocumentNote represents an SPDX Document Creation Infromation section:
 *  https://spdx.github.io/spdx-spec/2-document-creation-information/
 */
@interface GTLRContainerAnalysis_DocumentNote : GTLRObject

/**
 *  Compliance with the SPDX specification includes populating the SPDX fields
 *  therein with data related to such fields ("SPDX-Metadata")
 */
@property(nonatomic, copy, nullable) NSString *dataLicence;

/**
 *  Provide a reference number that can be used to understand how to parse and
 *  interpret the rest of the file
 */
@property(nonatomic, copy, nullable) NSString *spdxVersion;

@end


/**
 *  DocumentOccurrence represents an SPDX Document Creation Information section:
 *  https://spdx.github.io/spdx-spec/2-document-creation-information/
 */
@interface GTLRContainerAnalysis_DocumentOccurrence : GTLRObject

/**
 *  Identify when the SPDX file was originally created. The date is to be
 *  specified according to combined date and time in UTC format as specified in
 *  ISO 8601 standard
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  A field for creators of the SPDX file to provide general comments about the
 *  creation of the SPDX file or any other relevant comment not included in the
 *  other fields
 */
@property(nonatomic, copy, nullable) NSString *creatorComment;

/**
 *  Identify who (or what, in the case of a tool) created the SPDX file. If the
 *  SPDX file was created by an individual, indicate the person's name
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *creators;

/**
 *  A field for creators of the SPDX file content to provide comments to the
 *  consumers of the SPDX document
 */
@property(nonatomic, copy, nullable) NSString *documentComment;

/**
 *  Identify any external SPDX documents referenced within this SPDX document
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *externalDocumentRefs;

/**
 *  Identify the current SPDX document which may be referenced in relationships
 *  by other files, packages internally and documents externally
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  A field for creators of the SPDX file to provide the version of the SPDX
 *  License List used when the SPDX file was created
 */
@property(nonatomic, copy, nullable) NSString *licenseListVersion;

/**
 *  Provide an SPDX document specific namespace as a unique absolute Uniform
 *  Resource Identifier (URI) as specified in RFC-3986, with the exception of
 *  the # delimiter
 *
 *  Remapped to 'namespaceProperty' to avoid language reserved word 'namespace'.
 */
@property(nonatomic, copy, nullable) NSString *namespaceProperty;

/** Identify name of this document as designated by creator */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
 *  representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRContainerAnalysis_Empty : GTLRObject
@end


/**
 *  Defines an object for the environment field in in-toto links. The suggested
 *  fields are "variables", "filesystem", and "workdir".
 */
@interface GTLRContainerAnalysis_Environment : GTLRObject

@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Environment_CustomValues *customValues;

@end


/**
 *  GTLRContainerAnalysis_Environment_CustomValues
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainerAnalysis_Environment_CustomValues : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRContainerAnalysis_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  An External Reference allows a Package to reference an external source of
 *  additional information, metadata, enumerations, asset identifiers, or
 *  downloadable content believed to be relevant to the Package
 */
@interface GTLRContainerAnalysis_ExternalRef : GTLRObject

/**
 *  An External Reference allows a Package to reference an external source of
 *  additional information, metadata, enumerations, asset identifiers, or
 *  downloadable content believed to be relevant to the Package
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_ExternalRef_Category_CategoryUnspecified
 *        Unspecified (Value: "CATEGORY_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_ExternalRef_Category_Other Other (Value:
 *        "OTHER")
 *    @arg @c kGTLRContainerAnalysis_ExternalRef_Category_PackageManager Package
 *        Manager (e.g. maven-central, npm, nuget, bower, purl) (Value:
 *        "PACKAGE_MANAGER")
 *    @arg @c kGTLRContainerAnalysis_ExternalRef_Category_PersistentId
 *        Persistent-Id (e.g. swh) (Value: "PERSISTENT_ID")
 *    @arg @c kGTLRContainerAnalysis_ExternalRef_Category_Security Security
 *        (e.g. cpe22Type, cpe23Type) (Value: "SECURITY")
 */
@property(nonatomic, copy, nullable) NSString *category;

/**
 *  Human-readable information about the purpose and target of the reference
 */
@property(nonatomic, copy, nullable) NSString *comment;

/**
 *  The unique string with no spaces necessary to access the package-specific
 *  information, metadata, or content within the target location
 */
@property(nonatomic, copy, nullable) NSString *locator;

/** Type of category (e.g. 'npm' for the PACKAGE_MANAGER category) */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Container message for hashes of byte content of files, used in source
 *  messages to verify integrity of source input to the build.
 */
@interface GTLRContainerAnalysis_FileHashes : GTLRObject

/** Required. Collection of file hashes. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Hash *> *fileHash;

@end


/**
 *  FileNote represents an SPDX File Information section:
 *  https://spdx.github.io/spdx-spec/4-file-information/
 */
@interface GTLRContainerAnalysis_FileNote : GTLRObject

/**
 *  Provide a unique identifier to match analysis information on each specific
 *  file in a package
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *checksum;

/**
 *  This field provides information about the type of file identified
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Application The file is
 *        associated with a specific application type (MIME type of application/
 *        *) (Value: "APPLICATION")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Archive The file
 *        represents an archive (.tar, .jar, etc.) (Value: "ARCHIVE")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Audio The file is
 *        associated with an audio file (MIME type of audio/ * , e.g. .mp3)
 *        (Value: "AUDIO")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Binary The file is a
 *        compiled object, target image or binary executable (.o, .a, etc.)
 *        (Value: "BINARY")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Documentation The file
 *        serves as documentation (Value: "DOCUMENTATION")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_FileTypeUnspecified
 *        Unspecified (Value: "FILE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Image The file is
 *        associated with an picture image file (MIME type of image/ *, e.g.,
 *        .jpg, .gif) (Value: "IMAGE")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Other The file doesn't
 *        fit into the above categories (generated artifacts, data files, etc.)
 *        (Value: "OTHER")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Source The file is human
 *        readable source code (.c, .html, etc.) (Value: "SOURCE")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Spdx The file is an SPDX
 *        document (Value: "SPDX")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Text The file is human
 *        readable text file (MIME type of text/ *) (Value: "TEXT")
 *    @arg @c kGTLRContainerAnalysis_FileNote_FileType_Video The file is
 *        associated with a video file type (MIME type of video/ *) (Value:
 *        "VIDEO")
 */
@property(nonatomic, copy, nullable) NSString *fileType;

/**
 *  Identify the full path and filename that corresponds to the file information
 *  in this section
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  FileOccurrence represents an SPDX File Information section:
 *  https://spdx.github.io/spdx-spec/4-file-information/
 */
@interface GTLRContainerAnalysis_FileOccurrence : GTLRObject

/**
 *  This field provides a place for the SPDX data creator to record, at the file
 *  level, acknowledgements that may be needed to be communicated in some
 *  contexts
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *attributions;

/**
 *  This field provides a place for the SPDX file creator to record any general
 *  comments about the file
 */
@property(nonatomic, copy, nullable) NSString *comment;

/**
 *  This field provides a place for the SPDX file creator to record file
 *  contributors
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *contributors;

/** Identify the copyright holder of the file, as well as any dates present */
@property(nonatomic, copy, nullable) NSString *copyright;

/**
 *  This field contains the license information actually found in the file, if
 *  any
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *filesLicenseInfo;

/**
 *  Uniquely identify any element in an SPDX document which may be referenced by
 *  other elements
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  This field provides a place for the SPDX file creator to record any relevant
 *  background references or analysis that went in to arriving at the Concluded
 *  License for a file
 */
@property(nonatomic, copy, nullable) NSString *licenseComments;

/**
 *  This field contains the license the SPDX file creator has concluded as
 *  governing the file or alternative values if the governing license cannot be
 *  determined
 */
@property(nonatomic, copy, nullable) NSString *licenseConcluded;

/**
 *  This field provides a place for the SPDX file creator to record license
 *  notices or other such related notices found in the file
 */
@property(nonatomic, copy, nullable) NSString *notice;

@end


/**
 *  A set of properties that uniquely identify a given Docker image.
 */
@interface GTLRContainerAnalysis_Fingerprint : GTLRObject

/**
 *  Required. The layer ID of the final layer in the Docker image's v1
 *  representation.
 */
@property(nonatomic, copy, nullable) NSString *v1Name;

/** Required. The ordered list of v2 blobs that represent a given image. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *v2Blob;

/**
 *  Output only. The name of the image's v2 blobs computed via: [bottom] :=
 *  v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of
 *  the final blob is kept.
 */
@property(nonatomic, copy, nullable) NSString *v2Name;

@end


/**
 *  Per resource and severity counts of fixable and total vulnerabilities.
 */
@interface GTLRContainerAnalysis_FixableTotalByDigest : GTLRObject

/**
 *  The number of fixable vulnerabilities associated with this resource.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fixableCount;

/** The affected resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Resource *resource;

/**
 *  The severity for this count. SEVERITY_UNSPECIFIED indicates total across all
 *  severities.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_FixableTotalByDigest_Severity_High High
 *        severity. (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Low Low
 *        severity. (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Medium Medium
 *        severity. (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_FixableTotalByDigest_Severity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_FixableTotalByDigest_Severity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/**
 *  The total number of vulnerabilities associated with this resource.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalCount;

@end


/**
 *  An attestation wrapper that uses the Grafeas `Signature` message. This
 *  attestation must define the `serialized_payload` that the `signatures`
 *  verify and any metadata necessary to interpret that plaintext. The
 *  signatures should always be over the `serialized_payload` bytestring.
 */
@interface GTLRContainerAnalysis_GenericSignedAttestation : GTLRObject

/**
 *  Type (for example schema) of the attestation payload that was signed. The
 *  verifier must ensure that the provided type is one that the verifier
 *  supports, and that the attestation payload is a valid instantiation of that
 *  type (for example by validating a JSON schema).
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_GenericSignedAttestation_ContentType_ContentTypeUnspecified
 *        `ContentType` is not set. (Value: "CONTENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_GenericSignedAttestation_ContentType_SimpleSigningJson
 *        Atomic format attestation signature. See
 *        https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
 *        The payload extracted in `plaintext` is a JSON blob conforming to the
 *        linked schema. (Value: "SIMPLE_SIGNING_JSON")
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The serialized payload that is verified by one or more `signatures`. The
 *  encoding and semantic meaning of this payload must match what is set in
 *  `content_type`.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *serializedPayload;

/**
 *  One or more signatures over `serialized_payload`. Verifier implementations
 *  should consider this attestation message verified if at least one
 *  `signature` verifies `serialized_payload`. See `Signature` in common.proto
 *  for more details on signature structure and verification.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Signature *> *signatures;

@end


/**
 *  A SourceContext referring to a Gerrit project.
 */
@interface GTLRContainerAnalysis_GerritSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_AliasContext *aliasContext;

/**
 *  The full project name within the host. Projects may be nested, so
 *  "project/subproject" is a valid project name. The "repo name" is the
 *  hostURI/project.
 */
@property(nonatomic, copy, nullable) NSString *gerritProject;

/** The URI of a running Gerrit instance. */
@property(nonatomic, copy, nullable) NSString *hostUri;

/** A revision (commit) ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRContainerAnalysis_GetIamPolicyRequest : GTLRObject

/**
 *  OPTIONAL: A `GetPolicyOptions` object for specifying options to
 *  `GetIamPolicy`.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GetPolicyOptions *options;

@end


/**
 *  Encapsulates settings provided to GetIamPolicy.
 */
@interface GTLRContainerAnalysis_GetPolicyOptions : GTLRObject

/**
 *  Optional. The policy format version to be returned. Valid values are 0, 1,
 *  and 3. Requests specifying an invalid value will be rejected. Requests for
 *  policies with any conditional bindings must specify version 3. Policies
 *  without any conditional bindings may specify any valid value or leave the
 *  field unset. To learn which resources support conditions in their IAM
 *  policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedPolicyVersion;

@end


/**
 *  A GitSourceContext denotes a particular revision in a third party Git
 *  repository (e.g., GitHub).
 */
@interface GTLRContainerAnalysis_GitSourceContext : GTLRObject

/** Git commit hash. */
@property(nonatomic, copy, nullable) NSString *revisionId;

/** Git repository URL. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Metadata for all operations used and required for all operations that
 *  created by Container Analysis Providers
 */
@interface GTLRContainerAnalysis_GoogleDevtoolsContaineranalysisV1alpha1OperationMetadata : GTLRObject

/** Output only. The time this operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. The time that this operation was marked completed or failed.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

@end


/**
 *  Details of a build occurrence.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1BuildDetails : GTLRObject

/** Required. The actual provenance for the build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_BuildProvenance *provenance;

/**
 *  Serialized JSON representation of the provenance, used in generating the
 *  build signature in the corresponding build note. After verifying the
 *  signature, `provenance_bytes` can be unmarshalled and compared to the
 *  provenance to confirm that it is unchanged. A base64-encoded string
 *  representation of the provenance bytes is used for the signature in order to
 *  interoperate with openssl which expects this format for signature
 *  verification. The serialized form is captured both to avoid ambiguity in how
 *  the provenance is marshalled to json as well to prevent incompatibilities
 *  with future changes.
 */
@property(nonatomic, copy, nullable) NSString *provenanceBytes;

@end


/**
 *  Details of a deployment occurrence.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1DeploymentDetails : GTLRObject

/** Required. Deployment history for the resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Deployment *deployment;

@end


/**
 *  Details of a discovery occurrence.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1DiscoveryDetails : GTLRObject

/** Required. Analysis status for the discovered resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Discovered *discovered;

@end


/**
 *  Details of an image occurrence.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1ImageDetails : GTLRObject

/** Required. Immutable. The child image derived from the base image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Derived *derivedImage;

@end


/**
 *  GTLRContainerAnalysis_GrafeasV1beta1IntotoArtifact
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1IntotoArtifact : GTLRObject

@property(nonatomic, strong, nullable) GTLRContainerAnalysis_ArtifactHashes *hashes;
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  This corresponds to a signed in-toto link - it is made up of one or more
 *  signatures and the in-toto link itself. This is used for occurrences of a
 *  Grafeas in-toto note.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1IntotoDetails : GTLRObject

@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_GrafeasV1beta1IntotoSignature *> *signatures;

/**
 *  signedProperty
 *
 *  Remapped to 'signedProperty' to avoid language reserved word 'signed'.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Link *signedProperty;

@end


/**
 *  A signature object consists of the KeyID used and the signature itself.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1IntotoSignature : GTLRObject

@property(nonatomic, copy, nullable) NSString *keyid;
@property(nonatomic, copy, nullable) NSString *sig;

@end


/**
 *  Details of a package occurrence.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1PackageDetails : GTLRObject

/** Required. Where the package was installed. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Installation *installation;

@end


/**
 *  Details of a vulnerability Occurrence.
 */
@interface GTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails : GTLRObject

/**
 *  Output only. The CVSS score of this vulnerability. CVSS score is on a scale
 *  of 0-10 where 0 indicates low severity and 10 indicates high severity.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssScore;

/**
 *  The distro assigned severity for this vulnerability when it is available,
 *  and note provider assigned severity when distro has not yet assigned a
 *  severity for this vulnerability. When there are multiple PackageIssues for
 *  this vulnerability, they can have different effective severities because
 *  some might be provided by the distro while others are provided by the
 *  language ecosystem for a language pack. For this reason, it is advised to
 *  use the effective severity on the PackageIssue level. In the case where
 *  multiple PackageIssues have differing effective severities, this field
 *  should be the highest severity for any of the PackageIssues.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_High
 *        High severity. (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Low
 *        Low severity. (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_EffectiveSeverity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *effectiveSeverity;

/** Output only. A detailed description of this vulnerability. */
@property(nonatomic, copy, nullable) NSString *longDescription;

/**
 *  Required. The set of affected locations and their fixes (if available)
 *  within the associated resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_PackageIssue *> *packageIssue;

/** Output only. URLs related to this vulnerability. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_RelatedUrl *> *relatedUrls;

/**
 *  Output only. The note provider assigned Severity of the vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_High
 *        High severity. (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Low
 *        Low severity. (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails_Severity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** Output only. A one sentence description of this vulnerability. */
@property(nonatomic, copy, nullable) NSString *shortDescription;

/**
 *  The type of package; whether native or non native(ruby gems, node.js
 *  packages etc)
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Container message for hash values.
 */
@interface GTLRContainerAnalysis_Hash : GTLRObject

/**
 *  Required. The type of hash that was performed.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Hash_Type_HashTypeUnspecified Unknown.
 *        (Value: "HASH_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Hash_Type_Sha256 A SHA-256 hash. (Value:
 *        "SHA256")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Required. The hash value.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  This submessage provides human-readable hints about the purpose of the
 *  authority. Because the name of a note acts as its resource reference, it is
 *  important to disambiguate the canonical name of the Note (which might be a
 *  UUID for security purposes) from "readable" names more suitable for debug
 *  output. Note that these hints should not be used to look up authorities in
 *  security sensitive contexts, such as when looking up attestations to verify.
 */
@interface GTLRContainerAnalysis_Hint : GTLRObject

/**
 *  Required. The human readable name of this attestation authority, for example
 *  "qa".
 */
@property(nonatomic, copy, nullable) NSString *humanReadableName;

@end


/**
 *  This represents how a particular software package may be installed on a
 *  system.
 */
@interface GTLRContainerAnalysis_Installation : GTLRObject

/**
 *  Required. All of the places within the filesystem versions of this package
 *  have been found.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Location *> *location;

/** Output only. The name of the installed package. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  This contains the fields corresponding to the definition of a software
 *  supply chain step in an in-toto layout. This information goes into a Grafeas
 *  note.
 */
@interface GTLRContainerAnalysis_InToto : GTLRObject

/** This field contains the expected command used to perform the step. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *expectedCommand;

/**
 *  The following fields contain in-toto artifact rules identifying the
 *  artifacts that enter this supply chain step, and exit the supply chain step,
 *  i.e. materials and products of the step.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_ArtifactRule *> *expectedMaterials;

@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_ArtifactRule *> *expectedProducts;

/**
 *  This field contains the public keys that can be used to verify the
 *  signatures on the step metadata.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_SigningKey *> *signingKeys;

/** This field identifies the name of the step in the supply chain. */
@property(nonatomic, copy, nullable) NSString *stepName;

/**
 *  This field contains a value that indicates the minimum number of keys that
 *  need to be used to sign the step's in-toto link.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *threshold;

@end


/**
 *  GTLRContainerAnalysis_KnowledgeBase
 */
@interface GTLRContainerAnalysis_KnowledgeBase : GTLRObject

/** The KB name (generally of the form KB[0-9]+ i.e. KB123456). */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A link to the KB in the Windows update catalog -
 *  https://www.catalog.update.microsoft.com/
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Layer holds metadata specific to a layer of a Docker image.
 */
@interface GTLRContainerAnalysis_Layer : GTLRObject

/** The recovered arguments to the Dockerfile directive. */
@property(nonatomic, copy, nullable) NSString *arguments;

/**
 *  Required. The recovered Dockerfile directive used to construct this layer.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Add
 *        https://docs.docker.com/engine/reference/builder/ (Value: "ADD")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Arg
 *        https://docs.docker.com/engine/reference/builder/ (Value: "ARG")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Cmd
 *        https://docs.docker.com/engine/reference/builder/ (Value: "CMD")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Copy
 *        https://docs.docker.com/engine/reference/builder/ (Value: "COPY")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_DirectiveUnspecified
 *        Default value for unsupported/missing directive. (Value:
 *        "DIRECTIVE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Entrypoint
 *        https://docs.docker.com/engine/reference/builder/ (Value:
 *        "ENTRYPOINT")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Env
 *        https://docs.docker.com/engine/reference/builder/ (Value: "ENV")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Expose
 *        https://docs.docker.com/engine/reference/builder/ (Value: "EXPOSE")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Healthcheck
 *        https://docs.docker.com/engine/reference/builder/ (Value:
 *        "HEALTHCHECK")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Label
 *        https://docs.docker.com/engine/reference/builder/ (Value: "LABEL")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Maintainer
 *        https://docs.docker.com/engine/reference/builder/ (Value:
 *        "MAINTAINER")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Onbuild
 *        https://docs.docker.com/engine/reference/builder/ (Value: "ONBUILD")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Run
 *        https://docs.docker.com/engine/reference/builder/ (Value: "RUN")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Shell
 *        https://docs.docker.com/engine/reference/builder/ (Value: "SHELL")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Stopsignal
 *        https://docs.docker.com/engine/reference/builder/ (Value:
 *        "STOPSIGNAL")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_User
 *        https://docs.docker.com/engine/reference/builder/ (Value: "USER")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Volume
 *        https://docs.docker.com/engine/reference/builder/ (Value: "VOLUME")
 *    @arg @c kGTLRContainerAnalysis_Layer_Directive_Workdir
 *        https://docs.docker.com/engine/reference/builder/ (Value: "WORKDIR")
 */
@property(nonatomic, copy, nullable) NSString *directive;

@end


/**
 *  This corresponds to an in-toto link.
 */
@interface GTLRContainerAnalysis_Link : GTLRObject

/**
 *  ByProducts are data generated as part of a software supply chain step, but
 *  are not the actual result of the step.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_ByProducts *byproducts;

/**
 *  This field contains the full command executed for the step. This can also be
 *  empty if links are generated for operations that aren't directly mapped to a
 *  specific command. Each term in the command is an independent string in the
 *  list. An example of a command in the in-toto metadata field is: "command":
 *  ["git", "clone", "https://github.com/in-toto/demo-project.git"]
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *command;

/**
 *  This is a field that can be used to capture information about the
 *  environment. It is suggested for this field to contain information that
 *  details environment variables, filesystem information, and the present
 *  working directory. The recommended structure of this field is:
 *  "environment": { "custom_values": { "variables": "", "filesystem": "",
 *  "workdir": "", "": "..." } }
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Environment *environment;

/**
 *  Materials are the supply chain artifacts that go into the step and are used
 *  for the operation performed. The key of the map is the path of the artifact
 *  and the structure contains the recorded hash information. An example is:
 *  "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256":
 *  "ebebf...", : } } ]
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_GrafeasV1beta1IntotoArtifact *> *materials;

/**
 *  Products are the supply chain artifacts generated as a result of the step.
 *  The structure is identical to that of materials.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_GrafeasV1beta1IntotoArtifact *> *products;

@end


/**
 *  Response for listing occurrences for a note.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "occurrences" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListNoteOccurrencesResponse : GTLRCollectionObject

/** Token to provide to skip to a particular spot in the list. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The occurrences attached to the specified note.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Occurrence *> *occurrences;

@end


/**
 *  Response for listing notes.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "notes" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListNotesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the list response. It should be used as
 *  `page_token` for the following request. An empty value means no more
 *  results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The notes requested.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Note *> *notes;

@end


/**
 *  Response for listing occurrences.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "occurrences" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListOccurrencesResponse : GTLRCollectionObject

/**
 *  The next pagination token in the list response. It should be used as
 *  `page_token` for the following request. An empty value means no more
 *  results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The occurrences requested.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Occurrence *> *occurrences;

@end


/**
 *  Response for listing scan configurations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "scanConfigs" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRContainerAnalysis_ListScanConfigsResponse : GTLRCollectionObject

/**
 *  The next pagination token in the list response. It should be used as
 *  `page_token` for the following request. An empty value means no more
 *  results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The scan configurations requested.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_ScanConfig *> *scanConfigs;

@end


/**
 *  An occurrence of a particular package installation found within a system's
 *  filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
 */
@interface GTLRContainerAnalysis_Location : GTLRObject

/**
 *  Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
 *  denoting the package manager version distributing a package.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The path from which we gathered that this package/version is installed. */
@property(nonatomic, copy, nullable) NSString *path;

/** The version installed at this location. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *version;

@end


/**
 *  A type of analysis that can be done for a resource.
 */
@interface GTLRContainerAnalysis_Note : GTLRObject

/** A note describing an attestation role. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Authority *attestationAuthority;

/** A note describing a base image. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Basis *baseImage;

/** A note describing build provenance for a verifiable build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Build *build;

/**
 *  Output only. The time this note was created. This field can be used as a
 *  filter in list requests.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** A note describing something that can be deployed. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Deployable *deployable;

/** A note describing the initial analysis of a resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Discovery *discovery;

/** Time of expiration for this note. Empty if note does not expire. */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTime;

/** A note describing an in-toto link. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_InToto *intoto;

/**
 *  Output only. The type of analysis. This field can be used as a filter in
 *  list requests.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Attestation This represents a
 *        logical "role" that can attest to artifacts. (Value: "ATTESTATION")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Build The note and occurrence
 *        assert build provenance. (Value: "BUILD")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Deployment The note and
 *        occurrence track deployment events. (Value: "DEPLOYMENT")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Discovery The note and occurrence
 *        track the initial discovery status of a resource. (Value: "DISCOVERY")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Image This represents an image
 *        basis relationship. (Value: "IMAGE")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Intoto This represents an in-toto
 *        link. (Value: "INTOTO")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_NoteKindUnspecified Default
 *        value. This value is unused. (Value: "NOTE_KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Package This represents a package
 *        installed via a package manager. (Value: "PACKAGE")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Sbom This represents a software
 *        bill of materials. (Value: "SBOM")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_SpdxFile This represents an SPDX
 *        File. (Value: "SPDX_FILE")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_SpdxPackage This represents an
 *        SPDX Package. (Value: "SPDX_PACKAGE")
 *    @arg @c kGTLRContainerAnalysis_Note_Kind_Vulnerability The note and
 *        occurrence represent a package vulnerability. (Value: "VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** A detailed description of this note. */
@property(nonatomic, copy, nullable) NSString *longDescription;

/**
 *  Output only. The name of the note in the form of
 *  `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A note describing a package hosted by various package managers. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Package *package;

/** Other notes related to this note. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *relatedNoteNames;

/** URLs associated with this note. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_RelatedUrl *> *relatedUrl;

/** A note describing SPDX Document which represents SBOM. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_DocumentNote *sbom;

/** A one sentence description of this note. */
@property(nonatomic, copy, nullable) NSString *shortDescription;

/** A note describing SPDX File. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_FileNote *spdxFile;

/** A note describing SPDX Package. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_PackageNote *spdxPackage;

/** A note describing SPDX Relationship. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_RelationshipNote *spdxRelationship;

/**
 *  Output only. The time this note was last updated. This field can be used as
 *  a filter in list requests.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** A note describing a package vulnerability. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Vulnerability *vulnerability;

@end


/**
 *  An instance of an analysis type that has been found on a resource.
 */
@interface GTLRContainerAnalysis_Occurrence : GTLRObject

/** Describes an attestation of an artifact. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Details *attestation;

/** Describes a verifiable build. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1BuildDetails *build;

/** Output only. The time this occurrence was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Describes the deployment of an artifact on a runtime. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1DeploymentDetails *deployment;

/**
 *  Describes how this resource derives from the basis in the associated note.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1ImageDetails *derivedImage;

/** Describes when a resource was discovered. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1DiscoveryDetails *discovered;

/** Describes the installation of a package on the linked resource. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1PackageDetails *installation;

/** Describes a specific in-toto link. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1IntotoDetails *intoto;

/**
 *  Output only. This explicitly denotes which of the occurrence details are
 *  specified. This field can be used as a filter in list requests.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Attestation This represents
 *        a logical "role" that can attest to artifacts. (Value: "ATTESTATION")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Build The note and
 *        occurrence assert build provenance. (Value: "BUILD")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Deployment The note and
 *        occurrence track deployment events. (Value: "DEPLOYMENT")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Discovery The note and
 *        occurrence track the initial discovery status of a resource. (Value:
 *        "DISCOVERY")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Image This represents an
 *        image basis relationship. (Value: "IMAGE")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Intoto This represents an
 *        in-toto link. (Value: "INTOTO")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_NoteKindUnspecified Default
 *        value. This value is unused. (Value: "NOTE_KIND_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Package This represents a
 *        package installed via a package manager. (Value: "PACKAGE")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Sbom This represents a
 *        software bill of materials. (Value: "SBOM")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_SpdxFile This represents an
 *        SPDX File. (Value: "SPDX_FILE")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_SpdxPackage This represents
 *        an SPDX Package. (Value: "SPDX_PACKAGE")
 *    @arg @c kGTLRContainerAnalysis_Occurrence_Kind_Vulnerability The note and
 *        occurrence represent a package vulnerability. (Value: "VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Output only. The name of the occurrence in the form of
 *  `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Immutable. The analysis note associated with this occurrence, in
 *  the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be used
 *  as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *noteName;

/** A description of actions that can be taken to remedy the note. */
@property(nonatomic, copy, nullable) NSString *remediation;

/** Required. Immutable. The resource for which the occurrence applies. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Resource *resource;

/** Describes a specific SPDX Document. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_DocumentOccurrence *sbom;

/** Describes a specific SPDX File. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_FileOccurrence *spdxFile;

/** Describes a specific SPDX Package. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_PackageOccurrence *spdxPackage;

/** Describes a specific SPDX Relationship. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_RelationshipOccurrence *spdxRelationship;

/** Output only. The time this occurrence was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Describes a security vulnerability. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GrafeasV1beta1VulnerabilityDetails *vulnerability;

@end


/**
 *  This represents a particular package that is distributed over various
 *  channels. E.g., glibc (aka libc6) is distributed by many, at various
 *  versions.
 */
@interface GTLRContainerAnalysis_Package : GTLRObject

/** The various channels by which a package is distributed. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Distribution *> *distribution;

/** Required. Immutable. The name of the package. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  This message wraps a location affected by a vulnerability and its associated
 *  fix (if one is available).
 */
@interface GTLRContainerAnalysis_PackageIssue : GTLRObject

/** Required. The location of the vulnerability. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityLocation *affectedLocation;

/**
 *  Output only. The distro or language system assigned severity for this
 *  vulnerability when that is available and note provider assigned severity
 *  when it is not available.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_High High
 *        severity. (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Low Low
 *        severity. (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_PackageIssue_EffectiveSeverity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *effectiveSeverity;

/** The location of the available fix for vulnerability. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_VulnerabilityLocation *fixedLocation;

/** The type of package (e.g. OS, MAVEN, GO). */
@property(nonatomic, copy, nullable) NSString *packageType;

/**
 *  Deprecated, use Details.effective_severity instead The severity (e.g.,
 *  distro assigned severity) for this vulnerability.
 */
@property(nonatomic, copy, nullable) NSString *severityName;

@end


/**
 *  PackageNote represents an SPDX Package Information section:
 *  https://spdx.github.io/spdx-spec/3-package-information/
 */
@interface GTLRContainerAnalysis_PackageNote : GTLRObject

/**
 *  Indicates whether the file content of this package has been available for or
 *  subjected to analysis when creating the SPDX document
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *analyzed;

/**
 *  A place for the SPDX data creator to record, at the package level,
 *  acknowledgements that may be needed to be communicated in some contexts
 */
@property(nonatomic, copy, nullable) NSString *attribution;

/**
 *  Provide an independently reproducible mechanism that permits unique
 *  identification of a specific package that correlates to the data in this
 *  SPDX file
 */
@property(nonatomic, copy, nullable) NSString *checksum;

/**
 *  Identify the copyright holders of the package, as well as any dates present
 */
@property(nonatomic, copy, nullable) NSString *copyright;

/** A more detailed description of the package */
@property(nonatomic, copy, nullable) NSString *detailedDescription;

/**
 *  This section identifies the download Universal Resource Locator (URL), or a
 *  specific location within a version control system (VCS) for the package at
 *  the time that the SPDX file was created
 */
@property(nonatomic, copy, nullable) NSString *downloadLocation;

/** ExternalRef */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_ExternalRef *> *externalRefs;

/**
 *  Contain the license the SPDX file creator has concluded as governing the
 *  This field is to contain a list of all licenses found in the package. The
 *  relationship between licenses (i.e., conjunctive, disjunctive) is not
 *  specified in this field  it is simply a listing of all licenses found
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *filesLicenseInfo;

/**
 *  Provide a place for the SPDX file creator to record a web site that serves
 *  as the package's home page
 */
@property(nonatomic, copy, nullable) NSString *homePage;

/** List the licenses that have been declared by the authors of the package */
@property(nonatomic, copy, nullable) NSString *licenseDeclared;

/**
 *  If the package identified in the SPDX file originated from a different
 *  person or organization than identified as Package Supplier, this field
 *  identifies from where or whom the package originally came
 */
@property(nonatomic, copy, nullable) NSString *originator;

/** A short description of the package */
@property(nonatomic, copy, nullable) NSString *summaryDescription;

/**
 *  Identify the actual distribution source for the package/directory identified
 *  in the SPDX file
 */
@property(nonatomic, copy, nullable) NSString *supplier;

/**
 *  Identify the full name of the package as given by the Package Originator
 */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  This field provides an independently reproducible mechanism identifying
 *  specific contents of a package based on the actual files (except the SPDX
 *  file itself, if it is included in the package) that make up each package and
 *  that correlates to the data in this SPDX file
 */
@property(nonatomic, copy, nullable) NSString *verificationCode;

/** Identify the version of the package */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  PackageOccurrence represents an SPDX Package Information section:
 *  https://spdx.github.io/spdx-spec/3-package-information/
 */
@interface GTLRContainerAnalysis_PackageOccurrence : GTLRObject

/**
 *  A place for the SPDX file creator to record any general comments about the
 *  package being described
 */
@property(nonatomic, copy, nullable) NSString *comment;

/**
 *  Provide the actual file name of the package, or path of the directory being
 *  treated as a package
 */
@property(nonatomic, copy, nullable) NSString *filename;

/**
 *  Uniquely identify any element in an SPDX document which may be referenced by
 *  other elements
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  This field provides a place for the SPDX file creator to record any relevant
 *  background information or analysis that went in to arriving at the Concluded
 *  License for a package
 */
@property(nonatomic, copy, nullable) NSString *licenseComments;

/**
 *  package or alternative values, if the governing license cannot be determined
 */
@property(nonatomic, copy, nullable) NSString *licenseConcluded;

/**
 *  Provide a place for the SPDX file creator to record any relevant background
 *  information or additional comments about the origin of the package
 */
@property(nonatomic, copy, nullable) NSString *sourceInfo;

@end


/**
 *  An attestation wrapper with a PGP-compatible signature. This message only
 *  supports `ATTACHED` signatures, where the payload that is signed is included
 *  alongside the signature itself in the same file.
 */
@interface GTLRContainerAnalysis_PgpSignedAttestation : GTLRObject

/**
 *  Type (for example schema) of the attestation payload that was signed. The
 *  verifier must ensure that the provided type is one that the verifier
 *  supports, and that the attestation payload is a valid instantiation of that
 *  type (for example by validating a JSON schema).
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_ContentTypeUnspecified
 *        `ContentType` is not set. (Value: "CONTENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_PgpSignedAttestation_ContentType_SimpleSigningJson
 *        Atomic format attestation signature. See
 *        https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
 *        The payload extracted from `signature` is a JSON blob conforming to
 *        the linked schema. (Value: "SIMPLE_SIGNING_JSON")
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The cryptographic fingerprint of the key used to generate the signature, as
 *  output by, e.g. `gpg --list-keys`. This should be the version 4, full
 *  160-bit fingerprint, expressed as a 40 character hexidecimal string. See
 *  https://tools.ietf.org/html/rfc4880#section-12.2 for details.
 *  Implementations may choose to acknowledge "LONG", "SHORT", or other
 *  abbreviated key IDs, but only the full fingerprint is guaranteed to work. In
 *  gpg, the full fingerprint can be retrieved from the `fpr` field returned
 *  when calling --list-keys with --with-colons. For example: ``` gpg
 *  --with-colons --with-fingerprint --force-v4-certs \\ --list-keys
 *  attester\@example.com tru::1:1513631572:0:3:1:5 pub:......
 *  fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB: ``` Above, the
 *  fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
 */
@property(nonatomic, copy, nullable) NSString *pgpKeyId;

/**
 *  Required. The raw content of the signature, as output by GNU Privacy Guard
 *  (GPG) or equivalent. Since this message only supports attached signatures,
 *  the payload that was signed must be attached. While the signature format
 *  supported is dependent on the verification implementation, currently only
 *  ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
 *  `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
 *  --output=signature.gpg payload.json` will create the signature content
 *  expected in this field in `signature.gpg` for the `payload.json` attestation
 *  payload.
 */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members` to a single `role`.
 *  Members can be user accounts, service accounts, Google groups, and domains
 *  (such as G Suite). A `role` is a named list of permissions; each `role` can
 *  be an IAM predefined role or a user-created custom role. For some types of
 *  Google Cloud resources, a `binding` can also specify a `condition`, which is
 *  a logical expression that allows access to a resource only if the expression
 *  evaluates to `true`. A condition can add constraints based on attributes of
 *  the request, the resource, or both. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRContainerAnalysis_Policy : GTLRObject

/**
 *  Associates a list of `members` to a `role`. Optionally, may specify a
 *  `condition` that determines how and when the `bindings` are applied. Each of
 *  the `bindings` must contain at least one member.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Selects a repo using a Google Cloud Platform project ID (e.g.,
 *  winged-cargo-31) and a repo name within that project.
 */
@interface GTLRContainerAnalysis_ProjectRepoId : GTLRObject

/** The ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The name of the repo. Leave empty for the default repo. */
@property(nonatomic, copy, nullable) NSString *repoName;

@end


/**
 *  Metadata for any related URL information.
 */
@interface GTLRContainerAnalysis_RelatedUrl : GTLRObject

/** Label to describe usage of the URL. */
@property(nonatomic, copy, nullable) NSString *label;

/** Specific URL associated with the resource. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  RelationshipNote represents an SPDX Relationship section:
 *  https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
 */
@interface GTLRContainerAnalysis_RelationshipNote : GTLRObject
@end


/**
 *  RelationshipOccurrence represents an SPDX Relationship section:
 *  https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
 */
@interface GTLRContainerAnalysis_RelationshipOccurrence : GTLRObject

/**
 *  A place for the SPDX file creator to record any general comments about the
 *  relationship
 */
@property(nonatomic, copy, nullable) NSString *comment;

/**
 *  Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
 */
@property(nonatomic, copy, nullable) NSString *source;

/**
 *  Also referred to as SPDXRef-B The target SPDC element (file, package, etc)
 *  In cases where there are "known unknowns", the use of the keyword
 *  NOASSERTION can be used The keywords NONE can be used to indicate that an
 *  SPDX element (package/file/snippet) has no other elements connected by some
 *  relationship to it
 */
@property(nonatomic, copy, nullable) NSString *target;

/**
 *  The type of relationship between the source and target SPDX elements
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_Amends Is to be
 *        used when (current) SPDXRef-DOCUMENT amends the SPDX information in
 *        SPDXRef-B (Value: "AMENDS")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_AncestorOf Is
 *        to be used when SPDXRef-A is an ancestor (same lineage but pre-dates)
 *        SPDXRef-B (Value: "ANCESTOR_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_BuildDependencyOf
 *        Is to be used when SPDXRef-A is a build dependency of SPDXRef-B
 *        (Value: "BUILD_DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_BuildToolOf Is
 *        to be used when SPDXRef-A is used to build SPDXRef-B (Value:
 *        "BUILD_TOOL_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_ContainedBy Is
 *        to be used when SPDXRef-A is contained by SPDXRef-B (Value:
 *        "CONTAINED_BY")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_Contains Is to
 *        be used when SPDXRef-A contains SPDXRef-B (Value: "CONTAINS")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_CopyOf Is to be
 *        used when SPDXRef-A is an exact copy of SPDXRef-B (Value: "COPY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DataFileOf Is
 *        to be used when SPDXRef-A is a data file used in SPDXRef-B (Value:
 *        "DATA_FILE_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DependencyManifestOf
 *        Is to be used when SPDXRef-A is a manifest file that lists a set of
 *        dependencies for SPDXRef-B (Value: "DEPENDENCY_MANIFEST_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DependencyOf Is
 *        to be used when SPDXRef-A is dependency of SPDXRef-B (Value:
 *        "DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DependsOn Is to
 *        be used when SPDXRef-A depends on SPDXRef-B (Value: "DEPENDS_ON")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DescendantOf Is
 *        to be used when SPDXRef-A is a descendant of (same lineage but
 *        postdates) SPDXRef-B (Value: "DESCENDANT_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DescribedBy Is
 *        to be used when SPDXRef-A is described by SPDXREF-Document (Value:
 *        "DESCRIBED_BY")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_Describes Is to
 *        be used when SPDXRef-DOCUMENT describes SPDXRef-A (Value: "DESCRIBES")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DevDependencyOf
 *        Is to be used when SPDXRef-A is a development dependency of SPDXRef-B
 *        (Value: "DEV_DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DevToolOf Is to
 *        be used when SPDXRef-A is used as a development tool for SPDXRef-B
 *        (Value: "DEV_TOOL_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DistributionArtifact
 *        Is to be used when distributing SPDXRef-A requires that SPDXRef-B also
 *        be distributed (Value: "DISTRIBUTION_ARTIFACT")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DocumentationOf
 *        Is to be used when SPDXRef-A provides documentation of SPDXRef-B
 *        (Value: "DOCUMENTATION_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_DynamicLink Is
 *        to be used when SPDXRef-A dynamically links to SPDXRef-B (Value:
 *        "DYNAMIC_LINK")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_ExampleOf Is to
 *        be used when SPDXRef-A is an example of SPDXRef-B (Value:
 *        "EXAMPLE_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_ExpandedFromArchive
 *        Is to be used when SPDXRef-A is expanded from the archive SPDXRef-B
 *        (Value: "EXPANDED_FROM_ARCHIVE")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_FileAdded Is to
 *        be used when SPDXRef-A is a file that was added to SPDXRef-B (Value:
 *        "FILE_ADDED")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_FileDeleted Is
 *        to be used when SPDXRef-A is a file that was deleted from SPDXRef-B
 *        (Value: "FILE_DELETED")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_FileModified Is
 *        to be used when SPDXRef-A is a file that was modified from SPDXRef-B
 *        (Value: "FILE_MODIFIED")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_GeneratedFrom
 *        Is to be used when SPDXRef-A was generated from SPDXRef-B (Value:
 *        "GENERATED_FROM")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_Generates Is to
 *        be used when SPDXRef-A generates SPDXRef-B (Value: "GENERATES")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_HasPrerequisite
 *        Is to be used when SPDXRef-A has as a prerequisite SPDXRef-B (Value:
 *        "HAS_PREREQUISITE")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_MetafileOf Is
 *        to be used when SPDXRef-A is a metafile of SPDXRef-B (Value:
 *        "METAFILE_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_OptionalComponentOf
 *        Is to be used when SPDXRef-A is an optional component of SPDXRef-B
 *        (Value: "OPTIONAL_COMPONENT_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_OptionalDependencyOf
 *        Is to be used when SPDXRef-A is an optional dependency of SPDXRef-B
 *        (Value: "OPTIONAL_DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_Other Is to be
 *        used for a relationship which has not been defined in the formal SPDX
 *        specification. A description of the relationship should be included in
 *        the Relationship comments field (Value: "OTHER")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_PackageOf Is to
 *        be used when SPDXRef-A is used as a package as part of SPDXRef-B
 *        (Value: "PACKAGE_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_PatchApplied Is
 *        to be used when SPDXRef-A is a patch file that has been applied to
 *        SPDXRef-B (Value: "PATCH_APPLIED")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_PatchFor Is to
 *        be used when SPDXRef-A is a patch file for (to be applied to)
 *        SPDXRef-B (Value: "PATCH_FOR")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_PrerequisiteFor
 *        Is to be used when SPDXRef-A is a prerequisite for SPDXRef-B (Value:
 *        "PREREQUISITE_FOR")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_ProvidedDependencyOf
 *        Is to be used when SPDXRef-A is a to be provided dependency of
 *        SPDXRef-B (Value: "PROVIDED_DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_RuntimeDependencyOf
 *        Is to be used when SPDXRef-A is a dependency required for the
 *        execution of SPDXRef-B (Value: "RUNTIME_DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_StaticLink Is
 *        to be used when SPDXRef-A statically links to SPDXRef-B (Value:
 *        "STATIC_LINK")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestCaseOf Is
 *        to be used when SPDXRef-A is a test case used in testing SPDXRef-B
 *        (Value: "TEST_CASE_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestDependencyOf
 *        Is to be used when SPDXRef-A is a test dependency of SPDXRef-B (Value:
 *        "TEST_DEPENDENCY_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestOf Is to be
 *        used when SPDXRef-A is used for testing SPDXRef-B (Value: "TEST_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_TestToolOf Is
 *        to be used when SPDXRef-A is used as a test tool for SPDXRef-B (Value:
 *        "TEST_TOOL_OF")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_TypeUnspecified
 *        Unspecified (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainerAnalysis_RelationshipOccurrence_Type_VariantOf Is to
 *        be used when SPDXRef-A is a variant of (same lineage but not clear
 *        which came first) SPDXRef-B (Value: "VARIANT_OF")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A unique identifier for a Cloud Repo.
 */
@interface GTLRContainerAnalysis_RepoId : GTLRObject

/** A combination of a project ID and a repo name. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_ProjectRepoId *projectRepoId;

/** A server-assigned, globally unique identifier. */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  An entity that can have metadata. For example, a Docker image.
 */
@interface GTLRContainerAnalysis_Resource : GTLRObject

/**
 *  Deprecated, do not use. Use uri instead. The hash of the resource content.
 *  For example, the Docker digest.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Hash *contentHash;

/**
 *  Deprecated, do not use. Use uri instead. The name of the resource. For
 *  example, the name of a Docker image - "Debian".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The unique URI of the resource. For example,
 *  `https://gcr.io/project/image\@sha256:foo` for a Docker image.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A scan configuration specifies whether Cloud components in a project have a
 *  particular type of analysis being run. For example, it can configure whether
 *  vulnerability scanning is being done on Docker images or not.
 */
@interface GTLRContainerAnalysis_ScanConfig : GTLRObject

/** Output only. The time this scan config was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Output only. A human-readable description of what the scan configuration
 *  does.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Whether the scan is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Output only. The name of the scan configuration in the form of
 *  `projects/[PROJECT_ID]/scanConfigs/[SCAN_CONFIG_ID]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. The time this scan config was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRContainerAnalysis_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Cloud Platform services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Policy *policy;

@end


/**
 *  Verifiers (e.g. Kritis implementations) MUST verify signatures with respect
 *  to the trust anchors defined in policy (e.g. a Kritis policy). Typically
 *  this means that the verifier has been configured with a map from
 *  `public_key_id` to public key material (and any required parameters, e.g.
 *  signing algorithm). In particular, verification implementations MUST NOT
 *  treat the signature `public_key_id` as anything more than a key lookup hint.
 *  The `public_key_id` DOES NOT validate or authenticate a public key; it only
 *  provides a mechanism for quickly selecting a public key ALREADY CONFIGURED
 *  on the verifier through a trusted channel. Verification implementations MUST
 *  reject signatures in any of the following circumstances: * The
 *  `public_key_id` is not recognized by the verifier. * The public key that
 *  `public_key_id` refers to does not verify the signature with respect to the
 *  payload. The `signature` contents SHOULD NOT be "attached" (where the
 *  payload is included with the serialized `signature` bytes). Verifiers MUST
 *  ignore any "attached" payload and only verify signatures with respect to
 *  explicitly provided payload (e.g. a `payload` field on the proto message
 *  that holds this Signature, or the canonical serialization of the proto
 *  message that holds this signature).
 */
@interface GTLRContainerAnalysis_Signature : GTLRObject

/**
 *  The identifier for the public key that verifies this signature. * The
 *  `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986
 *  conformant URI. * When possible, the `public_key_id` SHOULD be an immutable
 *  reference, such as a cryptographic digest. Examples of valid
 *  `public_key_id`s: OpenPGP V4 public key fingerprint: *
 *  "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See
 *  https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
 *  details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of
 *  the DER serialization): *
 *  "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" *
 *  "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
 */
@property(nonatomic, copy, nullable) NSString *publicKeyId;

/**
 *  The content of the signature, an opaque bytestring. The payload that this
 *  signature verifies MUST be unambiguously provided with the Signature during
 *  verification. A wrapper message might provide the payload explicitly.
 *  Alternatively, a message might have a canonical serialization that can
 *  always be unambiguously computed to derive the payload.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  This defines the format used to record keys used in the software supply
 *  chain. An in-toto link is attested using one or more keys defined in the
 *  in-toto layout. An example of this is: { "key_id":
 *  "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type":
 *  "rsa", "public_key_value": "-----BEGIN PUBLIC
 *  KEY-----\\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The
 *  format for in-toto's key definition can be found in section 4.2 of the
 *  in-toto specification.
 */
@interface GTLRContainerAnalysis_SigningKey : GTLRObject

/** key_id is an identifier for the signing key. */
@property(nonatomic, copy, nullable) NSString *keyId;

/**
 *  This field contains the corresponding signature scheme. Eg:
 *  "rsassa-pss-sha256".
 */
@property(nonatomic, copy, nullable) NSString *keyScheme;

/**
 *  This field identifies the specific signing method. Eg: "rsa", "ed25519", and
 *  "ecdsa".
 */
@property(nonatomic, copy, nullable) NSString *keyType;

/** This field contains the actual public key. */
@property(nonatomic, copy, nullable) NSString *publicKeyValue;

@end


/**
 *  Source describes the location of the source used for the build.
 */
@interface GTLRContainerAnalysis_Source : GTLRObject

/**
 *  If provided, some of the source code used for the build may be found in
 *  these locations, in the case where the source repository had multiple
 *  remotes or submodules. This list will not include the context specified in
 *  the context field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_SourceContext *> *additionalContexts;

/**
 *  If provided, the input binary artifacts for the build came from this
 *  location.
 */
@property(nonatomic, copy, nullable) NSString *artifactStorageSourceUri;

/**
 *  If provided, the source code used for the build came from this location.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_SourceContext *context;

/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build. The keys to this map are file
 *  paths used as build source and the values contain the hash values for those
 *  files. If the build source came in a single package such as a gzipped
 *  tarfile (.tar.gz), the FileHash will be for the single path to that file.
 */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Source_FileHashes *fileHashes;

@end


/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build. The keys to this map are file
 *  paths used as build source and the values contain the hash values for those
 *  files. If the build source came in a single package such as a gzipped
 *  tarfile (.tar.gz), the FileHash will be for the single path to that file.
 *
 *  @note This class is documented as having more properties of
 *        GTLRContainerAnalysis_FileHashes. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_Source_FileHashes : GTLRObject
@end


/**
 *  A SourceContext is a reference to a tree of files. A SourceContext together
 *  with a path point to a unique revision of a single file or directory.
 */
@interface GTLRContainerAnalysis_SourceContext : GTLRObject

/** A SourceContext referring to a revision in a Google Cloud Source Repo. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_CloudRepoSourceContext *cloudRepo;

/** A SourceContext referring to a Gerrit project. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GerritSourceContext *gerrit;

/** A SourceContext referring to any third party Git repo (e.g., GitHub). */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_GitSourceContext *git;

/** Labels with user defined metadata. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_SourceContext_Labels *labels;

@end


/**
 *  Labels with user defined metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainerAnalysis_SourceContext_Labels : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRContainerAnalysis_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRContainerAnalysis_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRContainerAnalysis_Status_Details_Item : GTLRObject
@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRContainerAnalysis_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as '*' or 'storage.*') are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRContainerAnalysis_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Start and end times for a build execution phase.
 */
@interface GTLRContainerAnalysis_TimeSpan : GTLRObject

/** End of time span. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Start of time span. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Version contains structured information about the version of a package.
 */
@interface GTLRContainerAnalysis_Version : GTLRObject

/**
 *  Used to correct mistakes in the version numbering scheme.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *epoch;

/**
 *  Whether this version is specifying part of an inclusive range. Grafeas does
 *  not have the capability to specify version ranges; instead we have fields
 *  that specify start version and end versions. At times this is insufficient -
 *  we also need to specify whether the version is included in the range or is
 *  excluded from the range. This boolean is expected to be set to true when the
 *  version is included in a range.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inclusive;

/**
 *  Required. Distinguishes between sentinel MIN/MAX versions and normal
 *  versions.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_Maximum A special version
 *        representing positive infinity. (Value: "MAXIMUM")
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_Minimum A special version
 *        representing negative infinity. (Value: "MINIMUM")
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_Normal A standard package
 *        version. (Value: "NORMAL")
 *    @arg @c kGTLRContainerAnalysis_Version_Kind_VersionKindUnspecified
 *        Unknown. (Value: "VERSION_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Required only when version kind is NORMAL. The main part of the version
 *  name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The iteration of the package build from the above version. */
@property(nonatomic, copy, nullable) NSString *revision;

@end


/**
 *  Volume describes a Docker container volume which is mounted into build steps
 *  in order to persist files across build step execution.
 */
@interface GTLRContainerAnalysis_Volume : GTLRObject

/**
 *  Name of the volume to mount. Volume names must be unique per build step and
 *  must be valid names for Docker volumes. Each named volume must be used by at
 *  least two build steps.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Path at which to mount the volume. Paths must be absolute and cannot
 *  conflict with other volume paths on the same build step or with certain
 *  reserved volume paths.
 */
@property(nonatomic, copy, nullable) NSString *path;

@end


/**
 *  Vulnerability provides metadata about a security vulnerability in a Note.
 */
@interface GTLRContainerAnalysis_Vulnerability : GTLRObject

/**
 *  The CVSS score for this vulnerability.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssScore;

/** The full description of the CVSSv3. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_CVSSv3 *cvssV3;

/**
 *  All information about the package to specifically identify this
 *  vulnerability. One entry per (version range and cpe_uri) the package
 *  vulnerability has manifested in.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_Detail *> *details;

/**
 *  Note provider assigned impact of the vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLRContainerAnalysis_Vulnerability_Severity_Critical Critical
 *        severity. (Value: "CRITICAL")
 *    @arg @c kGTLRContainerAnalysis_Vulnerability_Severity_High High severity.
 *        (Value: "HIGH")
 *    @arg @c kGTLRContainerAnalysis_Vulnerability_Severity_Low Low severity.
 *        (Value: "LOW")
 *    @arg @c kGTLRContainerAnalysis_Vulnerability_Severity_Medium Medium
 *        severity. (Value: "MEDIUM")
 *    @arg @c kGTLRContainerAnalysis_Vulnerability_Severity_Minimal Minimal
 *        severity. (Value: "MINIMAL")
 *    @arg @c kGTLRContainerAnalysis_Vulnerability_Severity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/**
 *  The time this information was last changed at the source. This is an
 *  upstream timestamp from the underlying information source - e.g. Ubuntu
 *  security tracker.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *sourceUpdateTime;

/**
 *  Windows details get their own format because the information format and
 *  model don't match a normal detail. Specifically Windows updates are done as
 *  patches, thus Windows vulnerabilities really are a missing package, rather
 *  than a package being at an incorrect version.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_WindowsDetail *> *windowsDetails;

@end


/**
 *  The location of the vulnerability.
 */
@interface GTLRContainerAnalysis_VulnerabilityLocation : GTLRObject

/**
 *  Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
 *  format. Examples include distro or storage location for vulnerable jar.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** Required. The package being described. */
@property(nonatomic, copy, nullable) NSString *package;

/** Required. The version of the package being described. */
@property(nonatomic, strong, nullable) GTLRContainerAnalysis_Version *version;

@end


/**
 *  A summary of how many vulnerability occurrences there are per resource and
 *  severity type.
 */
@interface GTLRContainerAnalysis_VulnerabilityOccurrencesSummary : GTLRObject

/**
 *  A listing by resource of the number of fixable and total vulnerabilities.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_FixableTotalByDigest *> *counts;

@end


/**
 *  GTLRContainerAnalysis_WindowsDetail
 */
@interface GTLRContainerAnalysis_WindowsDetail : GTLRObject

/**
 *  Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
 *  in which the vulnerability manifests. Examples include distro or storage
 *  location for vulnerable jar.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  The description of the vulnerability.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. The names of the KBs which have hotfixes to mitigate this
 *  vulnerability. Note that there may be multiple hotfixes (and thus multiple
 *  KBs) that mitigate a given vulnerability. Currently any listed kb's presence
 *  is considered a fix.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainerAnalysis_KnowledgeBase *> *fixingKbs;

/** Required. The name of the vulnerability. */
@property(nonatomic, copy, nullable) NSString *name;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
