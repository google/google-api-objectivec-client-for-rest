// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Healthcare API (healthcare/v1alpha2)
// Description:
//   Manage, store, and access healthcare data in Google Cloud Platform.
// Documentation:
//   https://cloud.google.com/healthcare

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCloudHealthcare_AnnotationSource;
@class GTLRCloudHealthcare_AnnotationStore;
@class GTLRCloudHealthcare_AnnotationStore_Labels;
@class GTLRCloudHealthcare_AuditConfig;
@class GTLRCloudHealthcare_AuditLogConfig;
@class GTLRCloudHealthcare_Binding;
@class GTLRCloudHealthcare_BoundingPoly;
@class GTLRCloudHealthcare_CharacterMaskConfig;
@class GTLRCloudHealthcare_CryptoHashConfig;
@class GTLRCloudHealthcare_Dataset;
@class GTLRCloudHealthcare_DateShiftConfig;
@class GTLRCloudHealthcare_DeidentifyConfig;
@class GTLRCloudHealthcare_Detail;
@class GTLRCloudHealthcare_DicomConfig;
@class GTLRCloudHealthcare_DicomStore;
@class GTLRCloudHealthcare_DicomStore_Labels;
@class GTLRCloudHealthcare_ErrorDetail;
@class GTLRCloudHealthcare_Expr;
@class GTLRCloudHealthcare_FhirConfig;
@class GTLRCloudHealthcare_FhirStore;
@class GTLRCloudHealthcare_FhirStore_Labels;
@class GTLRCloudHealthcare_FieldMetadata;
@class GTLRCloudHealthcare_Finding;
@class GTLRCloudHealthcare_GetPolicyOptions;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomBigQueryDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomGcsDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomGcsSource;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirBigQueryDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsErrorDestination;
@class GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsSource;
@class GTLRCloudHealthcare_Hl7V2Store;
@class GTLRCloudHealthcare_Hl7V2Store_Labels;
@class GTLRCloudHealthcare_HttpBody_Extensions_Item;
@class GTLRCloudHealthcare_ImageAnnotation;
@class GTLRCloudHealthcare_ImageConfig;
@class GTLRCloudHealthcare_InfoTypeTransformation;
@class GTLRCloudHealthcare_Location;
@class GTLRCloudHealthcare_Location_Labels;
@class GTLRCloudHealthcare_Location_Metadata;
@class GTLRCloudHealthcare_Message;
@class GTLRCloudHealthcare_Message_Labels;
@class GTLRCloudHealthcare_NotificationConfig;
@class GTLRCloudHealthcare_Operation;
@class GTLRCloudHealthcare_Operation_Metadata;
@class GTLRCloudHealthcare_Operation_Response;
@class GTLRCloudHealthcare_ParsedData;
@class GTLRCloudHealthcare_ParserConfig;
@class GTLRCloudHealthcare_PatientId;
@class GTLRCloudHealthcare_Policy;
@class GTLRCloudHealthcare_ProgressCounter;
@class GTLRCloudHealthcare_RedactConfig;
@class GTLRCloudHealthcare_ReplaceWithInfoTypeConfig;
@class GTLRCloudHealthcare_ResourceAnnotation;
@class GTLRCloudHealthcare_SchemaConfig;
@class GTLRCloudHealthcare_Segment;
@class GTLRCloudHealthcare_Segment_Fields;
@class GTLRCloudHealthcare_SensitiveTextAnnotation;
@class GTLRCloudHealthcare_SensitiveTextAnnotation_Details;
@class GTLRCloudHealthcare_Source;
@class GTLRCloudHealthcare_Status;
@class GTLRCloudHealthcare_Status_Details_Item;
@class GTLRCloudHealthcare_StreamConfig;
@class GTLRCloudHealthcare_SubscriptionConfig;
@class GTLRCloudHealthcare_SubscriptionRestHookEndpoint;
@class GTLRCloudHealthcare_TagFilterList;
@class GTLRCloudHealthcare_TextConfig;
@class GTLRCloudHealthcare_ValidationConfig;
@class GTLRCloudHealthcare_Vertex;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_DicomConfig.filterProfile

/**
 *  Remove tags based on DICOM Standard's Attribute Confidentiality Basic
 *  Profile (DICOM Standard Edition 2018e)
 *  http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html.
 *
 *  Value: "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_AttributeConfidentialityBasicProfile;
/**
 *  Inspects within tag contents and replaces sensitive text. The process
 *  can be configured using the TextConfig.
 *  Applies to all tags with the following Value Representation names:
 *  AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
 *
 *  Value: "DEIDENTIFY_TAG_CONTENTS"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_DeidentifyTagContents;
/**
 *  Keep all tags.
 *
 *  Value: "KEEP_ALL_PROFILE"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_KeepAllProfile;
/**
 *  Keep only tags required to produce valid DICOM.
 *
 *  Value: "MINIMAL_KEEP_LIST_PROFILE"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_MinimalKeepListProfile;
/**
 *  No tag filtration profile provided. Same as KEEP_ALL_PROFILE.
 *
 *  Value: "TAG_FILTER_PROFILE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_DicomConfig_FilterProfile_TagFilterProfileUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_FieldMetadata.action

/**
 *  No action specified.
 *
 *  Value: "ACTION_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_ActionUnspecified;
/**
 *  Do not transform.
 *
 *  Value: "DO_NOT_TRANSFORM"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_DoNotTransform;
/**
 *  Inspect and transform any found PHI. When `AnnotationConfig` is
 *  provided, annotations of PHI will be generated, except for Date and
 *  Datetime.
 *
 *  Value: "INSPECT_AND_TRANSFORM"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_InspectAndTransform;
/**
 *  Transform the entire field.
 *
 *  Value: "TRANSFORM"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_FieldMetadata_Action_Transform;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_ImageConfig.textRedactionMode

/**
 *  Redact all text.
 *
 *  Value: "REDACT_ALL_TEXT"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactAllText;
/**
 *  Do not redact text.
 *
 *  Value: "REDACT_NO_TEXT"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactNoText;
/**
 *  Redact sensitive text.
 *
 *  Value: "REDACT_SENSITIVE_TEXT"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactSensitiveText;
/**
 *  No text redaction specified. Same as REDACT_NO_TEXT.
 *
 *  Value: "TEXT_REDACTION_MODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_TextRedactionModeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_ImportResourcesRequest.contentStructure

/**
 *  The source file contains one or more lines of newline-delimited JSON
 *  (ndjson). Each line is a bundle, which contains one or more resources.
 *  Set the bundle type to `history` to import resource versions.
 *
 *  Value: "BUNDLE"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Bundle;
/**
 *  The entire file is one JSON bundle. The JSON can span multiple lines.
 *
 *  Value: "BUNDLE_PRETTY"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_BundlePretty;
/**
 *  If the content structure is not specified, the default value `BUNDLE`
 *  will be used.
 *
 *  Value: "CONTENT_STRUCTURE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ContentStructureUnspecified;
/**
 *  The source file contains one or more lines of newline-delimited JSON
 *  (ndjson). Each line is a single resource.
 *
 *  Value: "RESOURCE"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Resource;
/**
 *  The entire file is one JSON resource. The JSON can span multiple lines.
 *
 *  Value: "RESOURCE_PRETTY"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ResourcePretty;

// ----------------------------------------------------------------------------
// GTLRCloudHealthcare_SchemaConfig.schemaType

/**
 *  Analytics schema defined by the FHIR community.
 *  See https://github.com/FHIR/sql-on-fhir/blob/master/sql-on-fhir.md.
 *
 *  Value: "ANALYTICS"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_SchemaConfig_SchemaType_Analytics;
/**
 *  A data-driven schema generated from the fields present in the FHIR data
 *  being exported, with no additional simplification.
 *
 *  Value: "LOSSLESS"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_SchemaConfig_SchemaType_Lossless;
/**
 *  No schema type specified. Same as `LOSSLESS`.
 *
 *  Value: "SCHEMA_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudHealthcare_SchemaConfig_SchemaType_SchemaTypeUnspecified;

/**
 *  An annotation record.
 */
@interface GTLRCloudHealthcare_Annotation : GTLRObject

/** Details of the source. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_AnnotationSource *annotationSource;

/** Annotations for images, e.g., bounding polygons. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ImageAnnotation *imageAnnotation;

/**
 *  Output only. Resource name of the Annotation, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}/annotations/{annotation_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Annotations for resource, e.g., classification tags. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ResourceAnnotation *resourceAnnotation;

/** Annotations for sensitive texts, e.g., range of such texts. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SensitiveTextAnnotation *textAnnotation;

@end


/**
 *  AnnotationSource holds the source information of the annotation.
 */
@interface GTLRCloudHealthcare_AnnotationSource : GTLRObject

/** Cloud Healthcare API resource. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Source *cloudHealthcareSource;

@end


/**
 *  An Annotation store that can store annotation resources such as
 *  labels and tags for text, image and audio.
 */
@interface GTLRCloudHealthcare_AnnotationStore : GTLRObject

/**
 *  User-supplied key-value pairs used to organize Annotation stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_AnnotationStore_Labels *labels;

/**
 *  Output only. Resource name of the Annotation store, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  User-supplied key-value pairs used to organize Annotation stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_AnnotationStore_Labels : GTLRObject
@end


/**
 *  Specifies the audit configuration for a service.
 *  The configuration determines which permission types are logged, and what
 *  identities, if any, are exempted from logging.
 *  An AuditConfig must have one or more AuditLogConfigs.
 *  If there are AuditConfigs for both `allServices` and a specific service,
 *  the union of the two AuditConfigs is used for that service: the log_types
 *  specified in each AuditConfig are enabled, and the exempted_members in each
 *  AuditLogConfig are exempted.
 *  Example Policy with multiple AuditConfigs:
 *  {
 *  "audit_configs": [
 *  {
 *  "service": "allServices"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:jose\@example.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  },
 *  {
 *  "log_type": "ADMIN_READ",
 *  }
 *  ]
 *  },
 *  {
 *  "service": "sampleservice.googleapis.com"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  "exempted_members": [
 *  "user:aliya\@example.com"
 *  ]
 *  }
 *  ]
 *  }
 *  ]
 *  }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts jose\@example.com from DATA_READ logging, and
 *  aliya\@example.com from DATA_WRITE logging.
 */
@interface GTLRCloudHealthcare_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging.
 *  For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
 *  `allServices` is a special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions.
 *  Example:
 *  {
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:jose\@example.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  }
 *  ]
 *  }
 *  This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
 *  jose\@example.com from DATA_READ logging.
 */
@interface GTLRCloudHealthcare_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission.
 *  Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRCloudHealthcare_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRCloudHealthcare_Binding : GTLRObject

/**
 *  The condition that is associated with this binding.
 *  NOTE: An unsatisfied condition will not allow user access via current
 *  binding. Different bindings, including their conditions, are examined
 *  independently.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values:
 *  * `allUsers`: A special identifier that represents anyone who is
 *  on the internet; with or without a Google account.
 *  * `allAuthenticatedUsers`: A special identifier that represents anyone
 *  who is authenticated with a Google account or a service account.
 *  * `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@example.com` .
 *  * `serviceAccount:{emailid}`: An email address that represents a service
 *  account. For example, `my-other-app\@appspot.gserviceaccount.com`.
 *  * `group:{emailid}`: An email address that represents a Google group.
 *  For example, `admins\@example.com`.
 *  * `domain:{domain}`: The G Suite domain (primary) that represents all the
 *  users of that domain. For example, `google.com` or `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`.
 *  For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  A bounding polygon for the detected image annotation.
 */
@interface GTLRCloudHealthcare_BoundingPoly : GTLRObject

@property(nonatomic, copy, nullable) NSString *label;
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Vertex *> *vertices;

@end


/**
 *  Mask a string by replacing its characters with a fixed character.
 */
@interface GTLRCloudHealthcare_CharacterMaskConfig : GTLRObject

/**
 *  Character to mask the sensitive values. If not supplied, defaults to "*".
 */
@property(nonatomic, copy, nullable) NSString *maskingCharacter;

@end


/**
 *  Creates a new message.
 */
@interface GTLRCloudHealthcare_CreateMessageRequest : GTLRObject

/** HL7v2 message. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message *message;

@end


/**
 *  Pseudonymization method that generates surrogates via cryptographic hashing.
 *  Uses SHA-256.
 *  Outputs a base64-encoded representation of the hashed output
 *  (for example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`).
 */
@interface GTLRCloudHealthcare_CryptoHashConfig : GTLRObject

/**
 *  An AES 128/192/256 bit key. Causes the hash to be computed based on this
 *  key. A default key is generated for each Deidentify operation and is used
 *  wherever crypto_key is not specified.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *cryptoKey;

@end


/**
 *  A message representing a health dataset.
 *  A health dataset represents a collection of healthcare data pertaining to
 *  one
 *  or more patients. This may include multiple modalities of healthcare data,
 *  such as electronic medical records or medical imaging data.
 */
@interface GTLRCloudHealthcare_Dataset : GTLRObject

/**
 *  Output only. Resource name of the dataset, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The default timezone used by this dataset. Must be a either a valid IANA
 *  time zone name such as "America/New_York" or empty, which defaults to UTC.
 *  This is used for parsing times in resources (e.g., HL7 messages) where no
 *  explicit timezone is specified.
 */
@property(nonatomic, copy, nullable) NSString *timeZone;

@end


/**
 *  Shift a date forward or backward in time by a random amount which is
 *  consistent for a given patient and crypto key combination.
 */
@interface GTLRCloudHealthcare_DateShiftConfig : GTLRObject

/**
 *  An AES 128/192/256 bit key. Causes the shift to be computed based on this
 *  key and the patient ID. A default key is generated for each
 *  Deidentify operation and is used wherever crypto_key is not specified.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *cryptoKey;

@end


/**
 *  Configures de-id options specific to different types of content.
 *  Each submessage customizes the handling of an
 *  https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are
 *  applied in a nested manner at runtime.
 */
@interface GTLRCloudHealthcare_DeidentifyConfig : GTLRObject

/** Configures de-id of application/DICOM content. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DicomConfig *dicom;

/** Configures de-id of application/FHIR content. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_FhirConfig *fhir;

/**
 *  Configures de-identification of image pixels wherever they are found in the
 *  source_dataset.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ImageConfig *image;

/**
 *  Configures de-identification of text wherever it is found in the
 *  source_dataset.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TextConfig *text;

@end


/**
 *  Redacts identifying information from the specified dataset.
 */
@interface GTLRCloudHealthcare_DeidentifyDatasetRequest : GTLRObject

/** Deidentify configuration. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DeidentifyConfig *config;

/**
 *  The name of the dataset resource to create and write the redacted data to
 *  (e.g.,
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}`).
 *  * The destination dataset must not exist.
 *  * The destination dataset must be in the same project as the source
 *  dataset. De-identifying data across multiple projects is not supported.
 */
@property(nonatomic, copy, nullable) NSString *destinationDataset;

@end


/**
 *  Contains the status of the Deidentify operation.
 */
@interface GTLRCloudHealthcare_DeidentifyErrorDetails : GTLRObject

/**
 *  Number of resources failed to process.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *failureResourceCount;

/**
 *  Number of stores failed to process.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *failureStoreCount;

/**
 *  Number of resources successfully processed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successResourceCount;

/**
 *  Number of stores successfully processed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successStoreCount;

@end


/**
 *  Contains a detailed summary of the Deidentify operation.
 */
@interface GTLRCloudHealthcare_DeidentifySummary : GTLRObject

/**
 *  Number of resources successfully processed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successResourceCount;

/**
 *  Number of stores successfully processed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successStoreCount;

@end


/**
 *  Contains multiple sensitive information findings for each resource slice.
 */
@interface GTLRCloudHealthcare_Detail : GTLRObject

@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Finding *> *findings;

@end


/**
 *  Specifies the parameters needed for de-identification of DICOM stores.
 */
@interface GTLRCloudHealthcare_DicomConfig : GTLRObject

/**
 *  Tag filtering profile that determines which tags to keep/remove.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_AttributeConfidentialityBasicProfile
 *        Remove tags based on DICOM Standard's Attribute Confidentiality Basic
 *        Profile (DICOM Standard Edition 2018e)
 *        http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html.
 *        (Value: "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_DeidentifyTagContents
 *        Inspects within tag contents and replaces sensitive text. The process
 *        can be configured using the TextConfig.
 *        Applies to all tags with the following Value Representation names:
 *        AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS (Value:
 *        "DEIDENTIFY_TAG_CONTENTS")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_KeepAllProfile Keep
 *        all tags. (Value: "KEEP_ALL_PROFILE")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_MinimalKeepListProfile
 *        Keep only tags required to produce valid DICOM. (Value:
 *        "MINIMAL_KEEP_LIST_PROFILE")
 *    @arg @c kGTLRCloudHealthcare_DicomConfig_FilterProfile_TagFilterProfileUnspecified
 *        No tag filtration profile provided. Same as KEEP_ALL_PROFILE. (Value:
 *        "TAG_FILTER_PROFILE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *filterProfile;

/** List of tags to keep. Remove all other tags. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TagFilterList *keepList;

/** List of tags to remove. Keep all other tags. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_TagFilterList *removeList;

@end


/**
 *  Represents a DICOM store.
 */
@interface GTLRCloudHealthcare_DicomStore : GTLRObject

/**
 *  User-supplied key-value pairs used to organize DICOM stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DicomStore_Labels *labels;

/**
 *  Output only. Resource name of the DICOM store, of the form
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Notification destination for new DICOM instances.
 *  Supplied by the client.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_NotificationConfig *notificationConfig;

@end


/**
 *  User-supplied key-value pairs used to organize DICOM stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_DicomStore_Labels : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRCloudHealthcare_Empty : GTLRObject
@end


/**
 *  Structure to describe the error encountered during batch operation on one
 *  resource. This is used both for sample errors in operation response, and
 *  for format of errors in error reports.
 */
@interface GTLRCloudHealthcare_ErrorDetail : GTLRObject

/** The status of the error. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Status *error;

/** The identifier of the resource. */
@property(nonatomic, copy, nullable) NSString *resource;

@end


/**
 *  Exports data from the specified DICOM store.
 *  If a given resource (e.g., a DICOM object with the same SOPInstance UID)
 *  already exists in the output, it is overwritten with the version
 *  in the source dataset.
 *  Exported DICOM data will persist when the DICOM store from which it was
 *  exported is deleted.
 */
@interface GTLRCloudHealthcare_ExportDicomDataRequest : GTLRObject

/**
 *  The BigQuery output destination.
 *  You can only export to a BigQuery dataset that's in the same project as
 *  the DICOM store you're exporting from.
 *  The BigQuery location requires two IAM roles:
 *  `roles/bigquery.dataEditor` and `roles/bigquery.jobUser`.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomBigQueryDestination *bigqueryDestination;

/**
 *  The Cloud Storage output destination.
 *  The Cloud Storage location requires the `roles/storage.objectAdmin` Cloud
 *  IAM role.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomGcsDestination *gcsDestination;

@end


/**
 *  Request to export resources.
 */
@interface GTLRCloudHealthcare_ExportResourcesRequest : GTLRObject

/**
 *  The BigQuery output destination.
 *  The BigQuery location requires two IAM roles:
 *  `roles/bigquery.dataEditor` and `roles/bigquery.jobUser`.
 *  The output will be one BigQuery table per resource type.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirBigQueryDestination *bigqueryDestination;

/**
 *  The Cloud Storage output destination.
 *  The Cloud Storage location requires the `roles/storage.objectAdmin` Cloud
 *  IAM role.
 *  The exported outputs are
 *  organized by FHIR resource types. The server will create one object per
 *  resource type. Each object contains newline delimited JSON, and each line
 *  is a FHIR resource.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsDestination *gcsDestination;

@end


/**
 *  Represents an expression text. Example:
 *  title: "User account presence"
 *  description: "Determines whether the request has a user account"
 *  expression: "size(request.user) > 0"
 */
@interface GTLRCloudHealthcare_Expr : GTLRObject

/**
 *  An optional description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in
 *  Common Expression Language syntax.
 *  The application context of the containing message determines which
 *  well-known feature set of CEL is supported.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  An optional string indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  An optional title for the expression, i.e. a short string describing
 *  its purpose. This can be used e.g. in UIs which allow to enter the
 *  expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Specifies how de-identification of a FHIR store should be handled.
 */
@interface GTLRCloudHealthcare_FhirConfig : GTLRObject

/**
 *  Specifies FHIR paths to match and how to transform them. Any field that
 *  is not matched by a FieldMetadata will be passed through to the output
 *  dataset unmodified. All extensions are removed in the output.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_FieldMetadata *> *fieldMetadataList;

@end


/**
 *  Represents a FHIR store.
 */
@interface GTLRCloudHealthcare_FhirStore : GTLRObject

/**
 *  Whether to disable referential integrity in this FHIR store. This field is
 *  immutable after FHIR store creation.
 *  The default value is false, meaning that the API will enforce referential
 *  integrity and fail the requests that will result in inconsistent state in
 *  the FHIR store.
 *  When this field is set to true, the API will skip referential integrity
 *  check. Consequently, operations that rely on references, such as
 *  GetPatientEverything, will not return all the results if broken references
 *  exist.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableReferentialIntegrity;

/**
 *  Whether to disable resource versioning for this FHIR store. This field can
 *  not be changed after the creation of FHIR store.
 *  If set to false, which is the default behavior, all write operations will
 *  cause historical versions to be recorded automatically. The historical
 *  versions can be fetched through the history APIs, but cannot be updated.
 *  If set to true, no historical versions will be kept. The server will send
 *  back errors for attempts to read the historical versions.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableResourceVersioning;

/**
 *  Whether to allow the bulk import API to accept history bundles and directly
 *  insert historical resource versions into the FHIR store. Importing resource
 *  histories creates resource interactions that appear to have occurred in the
 *  past, which clients may not want to allow. If set to false, history bundles
 *  within an import will fail with an error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableHistoryImport;

/**
 *  Whether this FHIR store has the [updateCreate
 *  capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate).
 *  This determines if the client can use an Update operation to create a new
 *  resource with a client-specified ID. If false, all IDs are server-assigned
 *  through the Create operation and attempts to Update a non-existent resource
 *  will return errors. Please treat the audit logs with appropriate levels of
 *  care if client-specified resource IDs contain sensitive data such as
 *  patient identifiers, those IDs will be part of the FHIR resource path
 *  recorded in Cloud audit logs and Cloud Pub/Sub notifications.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableUpdateCreate;

/**
 *  User-supplied key-value pairs used to organize FHIR stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_FhirStore_Labels *labels;

/**
 *  Output only. Resource name of the FHIR store, of the form
 *  `projects/{project_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If non-empty, publish all resource modifications of this FHIR store to
 *  this destination. The Cloud Pub/Sub message attributes will contain a map
 *  with a string describing the action that has triggered the notification,
 *  e.g. "action":"CreateResource".
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_NotificationConfig *notificationConfig;

/**
 *  A list of streaming configs that configure the destinations of streaming
 *  export for every resource mutation in this FHIR store. Each store is
 *  allowed to have up to 10 streaming configs.
 *  After a new config is added, the next resource mutation will be streamed to
 *  the new location in addition to the existing ones.
 *  When a location is removed from the list, the server will simply stop
 *  streaming to that location. Before adding a new config, you must add the
 *  required
 *  [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor)
 *  role to your project's **Cloud Healthcare Service Agent**
 *  [service account](https://cloud.google.com/iam/docs/service-accounts).
 *  Some lag (typically on the order of dozens of seconds) is expected before
 *  the results show up in the streaming destination.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_StreamConfig *> *streamConfigs;

/**
 *  Configuration of FHIR Subscription:
 *  https://www.hl7.org/fhir/subscription.html.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SubscriptionConfig *subscriptionConfig;

/**
 *  Configuration for how incoming FHIR resources will be validated against
 *  configured profiles.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ValidationConfig *validationConfig;

@end


/**
 *  User-supplied key-value pairs used to organize FHIR stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_FhirStore_Labels : GTLRObject
@end


/**
 *  Specifies FHIR paths to match, and how to handle de-identification of
 *  matching fields.
 */
@interface GTLRCloudHealthcare_FieldMetadata : GTLRObject

/**
 *  Deidentify action for one field.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_ActionUnspecified No
 *        action specified. (Value: "ACTION_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_DoNotTransform Do not
 *        transform. (Value: "DO_NOT_TRANSFORM")
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_InspectAndTransform
 *        Inspect and transform any found PHI. When `AnnotationConfig` is
 *        provided, annotations of PHI will be generated, except for Date and
 *        Datetime. (Value: "INSPECT_AND_TRANSFORM")
 *    @arg @c kGTLRCloudHealthcare_FieldMetadata_Action_Transform Transform the
 *        entire field. (Value: "TRANSFORM")
 */
@property(nonatomic, copy, nullable) NSString *action;

/**
 *  List of paths to FHIR fields to be redacted. Each path is a
 *  period-separated list where each component is either a field name or
 *  FHIR type name, for example: Patient, HumanName.
 *  For "choice" types (those defined in the FHIR spec with the form:
 *  field[x]) we use two separate components. e.g. "deceasedAge.unit" is
 *  matched by "Deceased.Age.unit".
 *  Supported types are: AdministrativeGenderCode, Code, Date, DateTime,
 *  Decimal, HumanName, Id, LanguageCode, Markdown, MimeTypeCode, Oid,
 *  String, Uri, Uuid, Xhtml.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *paths;

@end


/**
 *  GTLRCloudHealthcare_Finding
 */
@interface GTLRCloudHealthcare_Finding : GTLRObject

/**
 *  Zero-based ending index of the found text, exclusively.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *end;

/**
 *  The type of information stored in this text range (e.g. HumanName,
 *  BirthDate, Address, etc.)
 */
@property(nonatomic, copy, nullable) NSString *infoType;

/**
 *  Zero-based starting index of the found text, inclusively.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *start;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRCloudHealthcare_GetIamPolicyRequest : GTLRObject

/**
 *  OPTIONAL: A `GetPolicyOptions` object for specifying options to
 *  `GetIamPolicy`. This field is only used by Cloud IAM.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GetPolicyOptions *options;

@end


/**
 *  Encapsulates settings provided to GetIamPolicy.
 */
@interface GTLRCloudHealthcare_GetPolicyOptions : GTLRObject

/**
 *  Optional. The policy format version to be returned.
 *  Acceptable values are 0, 1, and 3.
 *  If the value is 0, or the field is omitted, policy format version 1 will be
 *  returned.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedPolicyVersion;

@end


/**
 *  The BigQuery table where the output should be written.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomBigQueryDestination : GTLRObject

/**
 *  If the destination table already exists and this flag is `TRUE`, the table
 *  will be overwritten by the contents of the DICOM store. If the flag is not
 *  set and the destination table already exists, the export call returns an
 *  error.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *force;

/**
 *  BigQuery URI to a table, up to 2000 characters long, in the format
 *  `bq://projectId.bqDatasetId.tableId`
 */
@property(nonatomic, copy, nullable) NSString *tableUri;

@end


/**
 *  The Cloud Storage location where the output should be written, and the
 *  export
 *  configuration.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomGcsDestination : GTLRObject

/**
 *  MIME types supported by DICOM spec.
 *  Each file will be written in the following format:
 *  `.../{study_id}/{series_id}/{instance_id}[/{frame_number}].{extension}`
 *  The frame_number component will exist only for multi-frame instances.
 *  Refer to the DICOM conformance statement for permissible MIME types:
 *  https://cloud.google.com/healthcare/docs/dicom#wado-rs
 *  The following extensions will be used for output files:
 *  application/dicom -> .dcm
 *  image/jpeg -> .jpg
 *  image/png -> .png
 *  If unspecified, the instances will be exported in their original
 *  DICOM format.
 */
@property(nonatomic, copy, nullable) NSString *mimeType;

/**
 *  The Cloud Storage destination to export to.
 *  URI for a Cloud Storage directory where result files should be written (in
 *  the format `gs://{bucket-id}/{path/to/destination/dir}`). If there is no
 *  trailing slash, the service will append one when composing the object path.
 *  The user is responsible for creating the Cloud Storage bucket referenced in
 *  `uri_prefix`.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Specifies the configuration for importing data from Cloud Storage.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomGcsSource : GTLRObject

/**
 *  Points to a Cloud Storage URI containing file(s) with
 *  content only. The URI must be in the following format:
 *  `gs://{bucket_id}/{object_id}`. The URI can include wildcards in
 *  `object_id` and thus identify multiple files. Supported wildcards:
 *  '*' to match 0 or more non-separator characters
 *  '**' to match 0 or more characters (including separators). Must be used at
 *  the end of a path and with no other wildcards in the
 *  path. Can also be used with a file extension (such as .dcm), which
 *  imports all files with the extension in the specified directory and
 *  its sub-directories. For example,
 *  `gs://my-bucket/my-directory/ **.dcm` imports all files with .dcm
 *  extensions in `my-directory/` and its sub-directories.
 *  '?' to match 1 character
 *  All other URI formats are invalid.
 *  Files matching the wildcard are expected to contain content only, no
 *  metadata.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  The configuration for exporting to BigQuery.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirBigQueryDestination : GTLRObject

/**
 *  BigQuery URI to a dataset, up to 2000 characters long, in the format
 *  `bq://projectId.bqDatasetId`
 */
@property(nonatomic, copy, nullable) NSString *datasetUri;

/** The configuration for the exported BigQuery schema. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SchemaConfig *schemaConfig;

@end


/**
 *  Final response of exporting resources.
 *  This structure will be included in the
 *  response to describe the detailed
 *  outcome. It will only be included when the operation finishes.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestExportResourcesResponse : GTLRObject

/**
 *  The name of the FHIR store where resources have been exported, in the
 *  format
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *fhirStore;

/**
 *  The total number of resources exported from the requested FHIR store.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *resourceCount;

@end


/**
 *  The configuration for exporting to Cloud Storage.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsDestination : GTLRObject

/**
 *  URI for a Cloud Storage directory where result files should be written (in
 *  the format `gs://{bucket-id}/{path/to/destination/dir}`). If there is no
 *  trailing slash, the service will append one when composing the object path.
 *  The user is responsible for creating the Cloud Storage bucket referenced in
 *  `uri_prefix`.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Specifies the Cloud Storage destination where errors will be recorded.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsErrorDestination : GTLRObject

/**
 *  URI for a Cloud Storage directory to which error report files should be
 *  written (in the format `gs://{bucket-id}/{path/to/destination/dir}`). If
 *  there is no trailing slash, the service will append one when composing the
 *  object path. The user is responsible for creating the Cloud Storage bucket
 *  referenced in `uri_prefix`.
 */
@property(nonatomic, copy, nullable) NSString *uriPrefix;

@end


/**
 *  Specifies the configuration for importing data from Cloud Storage.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsSource : GTLRObject

/**
 *  Points to a Cloud Storage URI containing file(s) to import.
 *  The URI must be in the following format: `gs://{bucket_id}/{object_id}`.
 *  The URI can include wildcards in `object_id` and thus identify multiple
 *  files. Supported wildcards:
 *  * `*` to match 0 or more non-separator characters
 *  * `**` to match 0 or more characters (including separators). Must be used
 *  at the end of a path and with no other wildcards in the
 *  path. Can also be used with a file extension (such as .ndjson), which
 *  imports all files with the extension in the specified directory and
 *  its sub-directories. For example, `gs://my-bucket/my-directory/ **.ndjson`
 *  imports all files with `.ndjson` extensions in `my-directory/` and its
 *  sub-directories.
 *  * `?` to match 1 character
 *  Files matching the wildcard are expected to contain content only, no
 *  metadata.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Error response of importing resources.
 *  This structure will be included in the
 *  error details to describe the
 *  detailed error. It will only be included when the operation finishes with
 *  some failure.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestImportResourcesErrorDetails : GTLRObject

/**
 *  The number of resources that had errors.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *errorCount;

/**
 *  The name of the FHIR store where resources have been imported, in the
 *  format
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *fhirStore;

/**
 *  The total number of resources included in the source data. This is the sum
 *  of the success and error counts.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputSize;

/**
 *  The number of resources that have been imported.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successCount;

@end


/**
 *  Final response of importing resources.
 *  This structure will be included in the
 *  response to describe the detailed
 *  outcome. It will only be included when the operation finishes successfully.
 */
@interface GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestImportResourcesResponse : GTLRObject

/**
 *  The name of the FHIR store where the resources have been imported, in the
 *  format
 *  `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *fhirStore;

/**
 *  The total number of resources included in the source data.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputSize;

@end


/**
 *  Represents an HL7v2 store.
 */
@interface GTLRCloudHealthcare_Hl7V2Store : GTLRObject

/**
 *  User-supplied key-value pairs used to organize HL7v2 stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Hl7V2Store_Labels *labels;

/**
 *  Output only. Resource name of the HL7v2 store, of the form
 *  `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7v2_store_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The notification destination all messages (both Ingest & Create) are
 *  published on. Only the message name is sent as part of the notification. If
 *  this is unset, no notifications will be sent. Supplied by the client.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_NotificationConfig *notificationConfig;

/**
 *  The configuration for the parser. It determines how the server parses the
 *  messages.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ParserConfig *parserConfig;

@end


/**
 *  User-supplied key-value pairs used to organize HL7v2 stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Hl7V2Store_Labels : GTLRObject
@end


/**
 *  Message that represents an arbitrary HTTP body. It should only be used for
 *  payload formats that can't be represented as JSON, such as raw binary or
 *  an HTML page.
 *  This message can be used both in streaming and non-streaming API methods in
 *  the request as well as the response.
 *  It can be used as a top-level request field, which is convenient if one
 *  wants to extract parameters from either the URL or HTTP template into the
 *  request fields and also want access to the raw HTTP body.
 *  Example:
 *  message GetResourceRequest {
 *  // A unique request id.
 *  string request_id = 1;
 *  // The raw HTTP body is bound to this field.
 *  google.api.HttpBody http_body = 2;
 *  }
 *  service ResourceService {
 *  rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);
 *  rpc UpdateResource(google.api.HttpBody) returns
 *  (google.protobuf.Empty);
 *  }
 *  Example with streaming methods:
 *  service CaldavService {
 *  rpc GetCalendar(stream google.api.HttpBody)
 *  returns (stream google.api.HttpBody);
 *  rpc UpdateCalendar(stream google.api.HttpBody)
 *  returns (stream google.api.HttpBody);
 *  }
 *  Use of this type only changes how the request and response bodies are
 *  handled, all other features will continue to work unchanged.
 */
@interface GTLRCloudHealthcare_HttpBody : GTLRObject

/**
 *  The HTTP Content-Type header value specifying the content type of the body.
 */
@property(nonatomic, copy, nullable) NSString *contentType;

/**
 *  The HTTP request/response body as raw binary.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  Application specific response metadata. Must be set in the first response
 *  for streaming APIs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_HttpBody_Extensions_Item *> *extensions;

@end


/**
 *  GTLRCloudHealthcare_HttpBody_Extensions_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_HttpBody_Extensions_Item : GTLRObject
@end


/**
 *  Image annotation.
 */
@interface GTLRCloudHealthcare_ImageAnnotation : GTLRObject

/** The list of polygons outlining the sensitive regions in the image. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_BoundingPoly *> *boundingPolys;

@end


/**
 *  Specifies how de-identification of image pixel should be handled.
 */
@interface GTLRCloudHealthcare_ImageConfig : GTLRObject

/**
 *  Determines how to redact text from image.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactAllText
 *        Redact all text. (Value: "REDACT_ALL_TEXT")
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactNoText Do
 *        not redact text. (Value: "REDACT_NO_TEXT")
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_RedactSensitiveText
 *        Redact sensitive text. (Value: "REDACT_SENSITIVE_TEXT")
 *    @arg @c kGTLRCloudHealthcare_ImageConfig_TextRedactionMode_TextRedactionModeUnspecified
 *        No text redaction specified. Same as REDACT_NO_TEXT. (Value:
 *        "TEXT_REDACTION_MODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *textRedactionMode;

@end


/**
 *  Returns the errors encountered during DICOM store import.
 */
@interface GTLRCloudHealthcare_ImportDicomDataErrorDetails : GTLRObject

/**
 *  Deprecated. Use only for debugging purposes.
 *  Contains sample errors encountered in imports of individual resources
 *  (for example, a Cloud Storage object).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_ErrorDetail *> *sampleErrors;

@end


/**
 *  Imports data into the specified DICOM store.
 *  Returns an error if any of the files to import are not DICOM files. This
 *  API will accept duplicate DICOM instances, by simply ignoring the newly
 *  pushed instance (it will not overwrite).
 */
@interface GTLRCloudHealthcare_ImportDicomDataRequest : GTLRObject

/**
 *  Cloud Storage source data location and import configuration.
 *  The Cloud Storage location requires the `roles/storage.objectViewer`
 *  Cloud IAM role.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2DicomGcsSource *gcsSource;

@end


/**
 *  Request to import resources.
 */
@interface GTLRCloudHealthcare_ImportResourcesRequest : GTLRObject

/**
 *  The content structure in the source location. If not specified, the server
 *  treats the input source files as BUNDLE.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Bundle
 *        The source file contains one or more lines of newline-delimited JSON
 *        (ndjson). Each line is a bundle, which contains one or more resources.
 *        Set the bundle type to `history` to import resource versions. (Value:
 *        "BUNDLE")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_BundlePretty
 *        The entire file is one JSON bundle. The JSON can span multiple lines.
 *        (Value: "BUNDLE_PRETTY")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ContentStructureUnspecified
 *        If the content structure is not specified, the default value `BUNDLE`
 *        will be used. (Value: "CONTENT_STRUCTURE_UNSPECIFIED")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_Resource
 *        The source file contains one or more lines of newline-delimited JSON
 *        (ndjson). Each line is a single resource. (Value: "RESOURCE")
 *    @arg @c kGTLRCloudHealthcare_ImportResourcesRequest_ContentStructure_ResourcePretty
 *        The entire file is one JSON resource. The JSON can span multiple
 *        lines. (Value: "RESOURCE_PRETTY")
 */
@property(nonatomic, copy, nullable) NSString *contentStructure;

/**
 *  The Cloud Storage destination to write the error report to.
 *  The Cloud Storage location requires the `roles/storage.objectAdmin` Cloud
 *  IAM role.
 *  Note that writing a file to the same destination multiple times will
 *  result in the previous version of the file being overwritten.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsErrorDestination *gcsErrorDestination;

/**
 *  Cloud Storage source data location and import configuration.
 *  The Cloud Storage location requires the `roles/storage.objectViewer`
 *  Cloud IAM role.
 *  Each Cloud Storage object should be a text file that contains the format
 *  specified in ContentStructu.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirRestGcsSource *gcsSource;

@end


/**
 *  A transformation to apply to text that is identified as a specific
 *  info_type.
 */
@interface GTLRCloudHealthcare_InfoTypeTransformation : GTLRObject

/** Config for character mask. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_CharacterMaskConfig *characterMaskConfig;

/** Config for crypto hash. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_CryptoHashConfig *cryptoHashConfig;

/** Config for date shift. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_DateShiftConfig *dateShiftConfig;

/**
 *  InfoTypes to apply this transformation to. If this is not specified, the
 *  transformation applies to any info_type.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *infoTypes;

/** Config for text redaction. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_RedactConfig *redactConfig;

/** Config for replace with InfoType. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ReplaceWithInfoTypeConfig *replaceWithInfoTypeConfig;

@end


/**
 *  Ingests a message into the specified HL7v2 store.
 */
@interface GTLRCloudHealthcare_IngestMessageRequest : GTLRObject

/** HL7v2 message to ingest. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message *message;

@end


/**
 *  Acknowledges that a message has been ingested into the specified
 *  HL7v2 store.
 */
@interface GTLRCloudHealthcare_IngestMessageResponse : GTLRObject

/**
 *  HL7v2 ACK message.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *hl7Ack;

/** Created message resource. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message *message;

@end


/**
 *  Lists the Annotations in the specified
 *  Annotation store.
 */
@interface GTLRCloudHealthcare_ListAnnotationsResponse : GTLRObject

/**
 *  The returned Annotations names. Won't be more values than the value of
 *  page_size in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *annotations;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the Annotation stores
 *  in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "annotationStores" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRCloudHealthcare_ListAnnotationStoresResponse : GTLRCollectionObject

/**
 *  The returned Annotation stores. Won't be more Annotation stores than the
 *  value of page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_AnnotationStore *> *annotationStores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the available datasets.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "datasets" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListDatasetsResponse : GTLRCollectionObject

/**
 *  The first page of datasets.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Dataset *> *datasets;

/**
 *  Token to retrieve the next page of results, or empty if there are no
 *  more results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the DICOM stores in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "dicomStores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListDicomStoresResponse : GTLRCollectionObject

/**
 *  The returned DICOM stores. Won't be more DICOM stores than the value of
 *  page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_DicomStore *> *dicomStores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the FHIR stores in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "fhirStores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListFhirStoresResponse : GTLRCollectionObject

/**
 *  The returned FHIR stores. Won't be more FHIR stores than the value of
 *  page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_FhirStore *> *fhirStores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the HL7v2 stores in the given dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "hl7V2Stores" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListHl7V2StoresResponse : GTLRCollectionObject

/**
 *  The returned HL7v2 stores. Won't be more HL7v2 stores than the value of
 *  page_size in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Hl7V2Store *> *hl7V2Stores;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Lists the messages in the specified HL7v2 store.
 */
@interface GTLRCloudHealthcare_ListMessagesResponse : GTLRObject

/**
 *  The returned message names. Won't be more values than the value of
 *  page_size in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *messages;

/**
 *  Token to retrieve the next page of results or empty if there are no more
 *  results in the list.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudHealthcare_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Operation *> *operations;

@end


/**
 *  A resource that represents Google Cloud Platform location.
 */
@interface GTLRCloudHealthcare_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name.
 *  For example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations.
 *  For example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Location_Metadata : GTLRObject
@end


/**
 *  A complete HL7v2 message.
 *  See http://www.hl7.org/implement/standards/index.cfm?ref=common for details
 *  on the standard.
 */
@interface GTLRCloudHealthcare_Message : GTLRObject

/**
 *  Output only. The datetime when the message was created. Set by the server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Raw message bytes.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *data;

/**
 *  User-supplied key-value pairs used to organize HL7v2 stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Message_Labels *labels;

/** The message type and trigger event for this message. MSH-9. */
@property(nonatomic, copy, nullable) NSString *messageType;

/**
 *  Resource name of the Message, of the form
 *  `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`.
 *  Assigned by the server.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Output only. The parsed version of the raw message data. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ParsedData *parsedData;

/**
 *  All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this
 *  message.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_PatientId *> *patientIds;

/** The hospital that this message came from. MSH-4. */
@property(nonatomic, copy, nullable) NSString *sendFacility;

/** The datetime the sending application sent this message. MSH-7. */
@property(nonatomic, strong, nullable) GTLRDateTime *sendTime;

@end


/**
 *  User-supplied key-value pairs used to organize HL7v2 stores.
 *  Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
 *  of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression:
 *  \\p{Ll}\\p{Lo}{0,62}
 *  Label values are optional, must be between 1 and 63 characters long, have
 *  a UTF-8 encoding of maximum 128 bytes, and must conform to the
 *  following PCRE regular expression: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  No more than 64 labels can be associated with a given store.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Message_Labels : GTLRObject
@end


/**
 *  Specifies where notifications should be sent upon changes to a data store.
 */
@interface GTLRCloudHealthcare_NotificationConfig : GTLRObject

/**
 *  The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that
 *  notifications of changes are published on. Supplied by the client.
 *  PubsubMessage.Data will contain the resource name.
 *  PubsubMessage.MessageId is the ID of this message. It is guaranteed to be
 *  unique within the topic.
 *  PubsubMessage.PublishTime is the time at which the message was published.
 *  Notifications are only sent if the topic is
 *  non-empty. [Topic
 *  names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped
 *  to a project. cloud-healthcare\@system.gserviceaccount.com must have
 *  publisher permissions on the given Cloud Pub/Sub topic. Not having adequate
 *  permissions will cause the calls that send notifications to fail.
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRCloudHealthcare_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress.
 *  If `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the
 *  `name` should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Operation_Response : GTLRObject
@end


/**
 *  OperationMetadata provides information about the operation execution.
 *  Returned in the long-running operation's metadata field.
 */
@interface GTLRCloudHealthcare_OperationMetadata : GTLRObject

/** The name of the API method that initiated the operation. */
@property(nonatomic, copy, nullable) NSString *apiMethodName;

@property(nonatomic, strong, nullable) GTLRCloudHealthcare_ProgressCounter *counter;

/** The time at which the operation was created by the API. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The time at which execution was completed. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

@end


/**
 *  The content of a HL7v2 message in a structured format.
 */
@interface GTLRCloudHealthcare_ParsedData : GTLRObject

@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Segment *> *segments;

@end


/**
 *  The configuration for the parser. It determines how the server parses the
 *  messages.
 */
@interface GTLRCloudHealthcare_ParserConfig : GTLRObject

/**
 *  Determines whether messages with no header are allowed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowNullHeader;

/**
 *  Byte(s) to be used as the segment terminator. If this is unset, '\\r' will
 *  be used as the segment terminator, matching the HL7 version 2
 *  specification.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *segmentTerminator;

@end


/**
 *  A patient identifier and associated type.
 */
@interface GTLRCloudHealthcare_PatientId : GTLRObject

/** ID type, e.g. MRN or NHS. */
@property(nonatomic, copy, nullable) NSString *type;

/** The patient's unique identifier. */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  Defines an Identity and Access Management (IAM) policy. It is used to
 *  specify access control policies for Cloud Platform resources.
 *  A `Policy` consists of a list of `bindings`. A `binding` binds a list of
 *  `members` to a `role`, where the members can be user accounts, Google
 *  groups,
 *  Google domains, and service accounts. A `role` is a named list of
 *  permissions
 *  defined by IAM.
 *  **JSON Example**
 *  {
 *  "bindings": [
 *  {
 *  "role": "roles/owner",
 *  "members": [
 *  "user:mike\@example.com",
 *  "group:admins\@example.com",
 *  "domain:google.com",
 *  "serviceAccount:my-other-app\@appspot.gserviceaccount.com"
 *  ]
 *  },
 *  {
 *  "role": "roles/viewer",
 *  "members": ["user:sean\@example.com"]
 *  }
 *  ]
 *  }
 *  **YAML Example**
 *  bindings:
 *  - members:
 *  - user:mike\@example.com
 *  - group:admins\@example.com
 *  - domain:google.com
 *  - serviceAccount:my-other-app\@appspot.gserviceaccount.com
 *  role: roles/owner
 *  - members:
 *  - user:sean\@example.com
 *  role: roles/viewer
 *  For a description of IAM and its features, see the
 *  [IAM developer's guide](https://cloud.google.com/iam/docs).
 */
@interface GTLRCloudHealthcare_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members` to a `role`.
 *  `bindings` with no members will result in an error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help
 *  prevent simultaneous updates of a policy from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform policy updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `getIamPolicy`, and
 *  systems are expected to put that etag in the request to `setIamPolicy` to
 *  ensure that their change will be applied to the same version of the policy.
 *  If no `etag` is provided in the call to `setIamPolicy`, then the existing
 *  policy is overwritten.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Deprecated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  ProgressCounter provides counters to describe an operation's progress.
 */
@interface GTLRCloudHealthcare_ProgressCounter : GTLRObject

/**
 *  The number of units that failed in the operation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *failure;

/**
 *  The number of units that are pending in the operation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pending;

/**
 *  The number of units that succeeded in the operation.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *success;

@end


/**
 *  Define how to redact sensitive values. Default behaviour is erase,
 *  e.g. "My name is Jake." becomes "My name is ."
 */
@interface GTLRCloudHealthcare_RedactConfig : GTLRObject
@end


/**
 *  When using the INSPECT_AND_TRANSFORM action, each match is replaced with
 *  the name of the info_type. For example, "My name is Jake" becomes "My name
 *  is
 *  [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
 */
@interface GTLRCloudHealthcare_ReplaceWithInfoTypeConfig : GTLRObject
@end


/**
 *  Resource level annotation.
 */
@interface GTLRCloudHealthcare_ResourceAnnotation : GTLRObject

@property(nonatomic, copy, nullable) NSString *label;

@end


/**
 *  Configuration for the FHIR BigQuery and Cloud Storage schema. Determines
 *  how the server generates the schema.
 */
@interface GTLRCloudHealthcare_SchemaConfig : GTLRObject

/**
 *  The depth for all recursive structures in the output analytics
 *  schema. For example, `concept` in the CodeSystem resource is a recursive
 *  structure; when the depth is 2, the CodeSystem table will have a column
 *  called `concept.concept` but not `concept.concept.concept`. If not
 *  specified or set to 0, the server will use the default value 2.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *recursiveStructureDepth;

/**
 *  Specifies the output schema type. If unspecified, the default is
 *  `LOSSLESS`.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudHealthcare_SchemaConfig_SchemaType_Analytics Analytics
 *        schema defined by the FHIR community.
 *        See https://github.com/FHIR/sql-on-fhir/blob/master/sql-on-fhir.md.
 *        (Value: "ANALYTICS")
 *    @arg @c kGTLRCloudHealthcare_SchemaConfig_SchemaType_Lossless A
 *        data-driven schema generated from the fields present in the FHIR data
 *        being exported, with no additional simplification. (Value: "LOSSLESS")
 *    @arg @c kGTLRCloudHealthcare_SchemaConfig_SchemaType_SchemaTypeUnspecified
 *        No schema type specified. Same as `LOSSLESS`. (Value:
 *        "SCHEMA_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *schemaType;

@end


/**
 *  Request to search the resources in the specified FHIR store.
 */
@interface GTLRCloudHealthcare_SearchResourcesRequest : GTLRObject

/**
 *  The FHIR resource type to search, such as Patient or Observation. For a
 *  complete list, see the [FHIR Resource
 *  Index](http://hl7.org/implement/standards/fhir/STU3/resourcelist.html).
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  A segment in a structured format.
 */
@interface GTLRCloudHealthcare_Segment : GTLRObject

/**
 *  A mapping from the positional location to the value.
 *  The key string uses zero-based indexes separated by dots to identify
 *  Fields, components and sub-components. A bracket notation is also used to
 *  identify different instances of a repeated field.
 *  Regex for key: (\\d+)(\\[\\d+\\])?(.\\d+)?(.\\d+)?
 *  Examples of (key, value) pairs:
 *  - (0.1, "foo"): Component 1 of Field 0 has the value "foo".
 *  - (1.1.2, "bar"): Sub-component 2 of Component 1 of field 1 has the value
 *  "bar".
 *  - (1[2].1, "baz"): Component 1 of Instance 2 of Field 1, which is repeated,
 *  has the value "baz".
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Segment_Fields *fields;

/** A string that indicates the type of segment, e.g., EVN, PID. */
@property(nonatomic, copy, nullable) NSString *segmentId;

/**
 *  Set ID for segments that can be in a set. This can be empty if it is
 *  missing or it is not applicable.
 */
@property(nonatomic, copy, nullable) NSString *setId;

@end


/**
 *  A mapping from the positional location to the value.
 *  The key string uses zero-based indexes separated by dots to identify
 *  Fields, components and sub-components. A bracket notation is also used to
 *  identify different instances of a repeated field.
 *  Regex for key: (\\d+)(\\[\\d+\\])?(.\\d+)?(.\\d+)?
 *  Examples of (key, value) pairs:
 *  - (0.1, "foo"): Component 1 of Field 0 has the value "foo".
 *  - (1.1.2, "bar"): Sub-component 2 of Component 1 of field 1 has the value
 *  "bar".
 *  - (1[2].1, "baz"): Component 1 of Instance 2 of Field 1, which is repeated,
 *  has the value "baz".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudHealthcare_Segment_Fields : GTLRObject
@end


/**
 *  A TextAnnotation specifies a text range that includes sensitive information.
 */
@interface GTLRCloudHealthcare_SensitiveTextAnnotation : GTLRObject

/**
 *  Maps from a resource slice (e.g. FHIR resource field path) to a set of
 *  sensitive text findings. For example,
 *  Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_SensitiveTextAnnotation_Details *details;

@end


/**
 *  Maps from a resource slice (e.g. FHIR resource field path) to a set of
 *  sensitive text findings. For example,
 *  Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
 *
 *  @note This class is documented as having more properties of
 *        GTLRCloudHealthcare_Detail. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_SensitiveTextAnnotation_Details : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRCloudHealthcare_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a
 *  valid policy but certain Cloud Platform services (such as Projects)
 *  might reject them.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used:
 *  paths: "bindings, etag"
 *  This field is only used by Cloud IAM.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Cloud Healthcare API resource.
 */
@interface GTLRCloudHealthcare_Source : GTLRObject

/** Full path of a Cloud Healthcare API resource. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details.
 *  You can find out more about this error model and how to work with it in the
 *  [API Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRCloudHealthcare_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRCloudHealthcare_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudHealthcare_Status_Details_Item : GTLRObject
@end


/**
 *  This structure contains configuration for streaming FHIR export.
 */
@interface GTLRCloudHealthcare_StreamConfig : GTLRObject

/**
 *  The destination BigQuery structure that contains both the dataset
 *  location and corresponding schema config.
 *  The output will be organized in one table per resource type.
 *  The server will inspect and potentially create new tables (if they
 *  don't exist) in the given BigQuery dataset.
 *  Results will be appended to the corresponding BigQuery tables.
 *  The views of the latest snapshot will also be automatically created in
 *  the dataset.
 */
@property(nonatomic, strong, nullable) GTLRCloudHealthcare_GoogleCloudHealthcareV1alpha2FhirBigQueryDestination *bigqueryDestination;

/**
 *  Supply a FHIR resource type (such as "Patient" or "Observation").
 *  See https://www.hl7.org/fhir/valueset-resource-types.html for a list of
 *  all FHIR resource types.
 *  The server will treat an empty list as an intent to stream all the
 *  supported resource types in this FHIR store.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceTypes;

@end


/**
 *  Configuration of FHIR Subscription:
 *  https://www.hl7.org/fhir/subscription.html.
 */
@interface GTLRCloudHealthcare_SubscriptionConfig : GTLRObject

/**
 *  REST hook endpoints that are allowed to receive subscription notifications.
 *  The create or update operation on a FHIR Subscription resource will fail if
 *  the FHIR Subscription resource contains a REST hook endpoint that is not in
 *  this list.
 *  A subscription notification push will fail if the FHIR Subscription
 *  resource contains a REST hook endpoint that is not in this list.
 *  The REST hook endpoint in a subscription resource will be compared with the
 *  endpoints in this list by exact matching.
 *  Users must verify their ownership of the domain of an endpoint before
 *  adding it to this list. To verify domain ownership, go to
 *  https://search.google.com/search-console/welcome.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_SubscriptionRestHookEndpoint *> *allowedRestHookEndpoints;

@end


/**
 *  REST hook endpoint of FHIR Subscription.
 */
@interface GTLRCloudHealthcare_SubscriptionRestHookEndpoint : GTLRObject

/**
 *  Whether this endpoint is allowed to receive full resource payloads. If set
 *  to false, the subscription notificiation sending to this endpoint with full
 *  resource payload will be blocked.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowResourcePayload;

/**
 *  Address of the REST hook endpoint. It must be a valid HTTPS URL with TLS
 *  certificate.
 */
@property(nonatomic, copy, nullable) NSString *endpoint;

@end


/**
 *  List of tags to be filtered.
 */
@interface GTLRCloudHealthcare_TagFilterList : GTLRObject

/**
 *  Tags to be filtered. Tags must be DICOM Data Elements, File Meta
 *  Elements, or Directory Structuring Elements, as defined at:
 *  http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,.
 *  They may be provided by "Keyword" or "Tag". For example "PatientID",
 *  "00100010".
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRCloudHealthcare_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as '*' or 'storage.*') are not allowed. For more
 *  information see
 *  [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRCloudHealthcare_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is
 *  allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  GTLRCloudHealthcare_TextConfig
 */
@interface GTLRCloudHealthcare_TextConfig : GTLRObject

/** The transformations to apply to the detected data. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudHealthcare_InfoTypeTransformation *> *transformations;

@end


/**
 *  This structure contains the configuration for FHIR profiles and validation.
 */
@interface GTLRCloudHealthcare_ValidationConfig : GTLRObject

/**
 *  Whether profile validation should be disabled for this FHIR store. Set
 *  this to true to disable checking incoming resources for conformance
 *  against StructureDefinitions in this FHIR store.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableProfileValidation;

/**
 *  A list of ImplementationGuide IDs in this FHIR store that will be used to
 *  configure which profiles are used for validation. For example, to enable
 *  an implementation guide with ID 1 set `enabled_implementation_guides` to
 *  `["1"]`. If `enabled_implementation_guides` is empty or omitted then
 *  incoming resources will only be required to conform to the base FHIR
 *  profiles. Otherwise, a resource must conform to at least one profile
 *  listed in the `global` property of one of the enabled
 *  ImplementationGuides.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledImplementationGuides;

@end


/**
 *  A 2D coordinate in an image. The origin is the top-left.
 */
@interface GTLRCloudHealthcare_Vertex : GTLRObject

/**
 *  X coordinate.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *x;

/**
 *  Y coordinate.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *y;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
