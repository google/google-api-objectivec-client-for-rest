// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Cloud RuntimeConfig API (runtimeconfig/v1beta1)
// Description:
//   Provides capabilities for dynamic configuration and coordination for
//   applications running on Google Cloud Platform.
// Documentation:
//   https://cloud.google.com/deployment-manager/runtime-configurator/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCloudRuntimeConfig_Cardinality;
@class GTLRCloudRuntimeConfig_EndCondition;
@class GTLRCloudRuntimeConfig_OperationMetadata;
@class GTLRCloudRuntimeConfig_OperationResponse;
@class GTLRCloudRuntimeConfig_RuntimeConfig;
@class GTLRCloudRuntimeConfig_Status;
@class GTLRCloudRuntimeConfig_StatusDetailsItem;
@class GTLRCloudRuntimeConfig_Variable;
@class GTLRCloudRuntimeConfig_Waiter;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCloudRuntimeConfig_Variable.state

/**
 *  The variable was deleted, while `variables().watch` was executing.
 *
 *  Value: "DELETED"
 */
GTLR_EXTERN NSString * const kGTLRCloudRuntimeConfig_Variable_State_Deleted;
/**
 *  The variable was updated, while `variables().watch` was executing.
 *
 *  Value: "UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRCloudRuntimeConfig_Variable_State_Updated;
/**
 *  Default variable state.
 *
 *  Value: "VARIABLE_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudRuntimeConfig_Variable_State_VariableStateUnspecified;

/**
 *  A Cardinality condition for the Waiter resource. A cardinality condition is
 *  met when the number of variables under a specified path prefix reaches a
 *  predefined number. For example, if you set a Cardinality condition where
 *  the `path` is set to `/foo` and the number of paths is set to 2, the
 *  following variables would meet the condition in a RuntimeConfig resource:
 *  + `/foo/variable1 = "value1"`
 *  + `/foo/variable2 = "value2"`
 *  + `/bar/variable3 = "value3"`
 *  It would not would not satisify the same condition with the `number` set to
 *  3, however, because there is only 2 paths that start with `/foo`.
 *  Cardinality conditions are recursive; all subtrees under the specific
 *  path prefix are counted.
 */
@interface GTLRCloudRuntimeConfig_Cardinality : GTLRObject

/**
 *  The number variables under the `path` that must exist to meet this
 *  condition. Defaults to 1 if not specified.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *number;

/** The root of the variable subtree to monitor. For example, `/foo`. */
@property(nonatomic, copy, nullable) NSString *path;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRCloudRuntimeConfig_Empty : GTLRObject
@end


/**
 *  The condition that a Waiter resource is waiting for.
 */
@interface GTLRCloudRuntimeConfig_EndCondition : GTLRObject

/** The cardinality of the `EndCondition`. */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_Cardinality *cardinality;

@end


/**
 *  `ListConfigs()` returns the following response. The order of returned
 *  objects is arbitrary; that is, it is not ordered in any particular way.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "configs" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudRuntimeConfig_ListConfigsResponse : GTLRCollectionObject

/**
 *  A list of the configurations in the project. The order of returned
 *  objects is arbitrary; that is, it is not ordered in any particular way.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRuntimeConfig_RuntimeConfig *> *configs;

/**
 *  This token allows you to get the next page of results for list requests.
 *  If the number of results is larger than `pageSize`, use the `nextPageToken`
 *  as a value for the query parameter `pageToken` in the next list request.
 *  Subsequent list requests will have their own `nextPageToken` to continue
 *  paging through the results
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response for the `ListVariables()` method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "variables" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudRuntimeConfig_ListVariablesResponse : GTLRCollectionObject

/**
 *  This token allows you to get the next page of results for list requests.
 *  If the number of results is larger than `pageSize`, use the `nextPageToken`
 *  as a value for the query parameter `pageToken` in the next list request.
 *  Subsequent list requests will have their own `nextPageToken` to continue
 *  paging through the results
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of variables and their values. The order of returned variable
 *  objects is arbitrary.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRuntimeConfig_Variable *> *variables;

@end


/**
 *  Response for the `ListWaiters()` method.
 *  Order of returned waiter objects is arbitrary.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "waiters" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudRuntimeConfig_ListWaitersResponse : GTLRCollectionObject

/**
 *  This token allows you to get the next page of results for list requests.
 *  If the number of results is larger than `pageSize`, use the `nextPageToken`
 *  as a value for the query parameter `pageToken` in the next list request.
 *  Subsequent list requests will have their own `nextPageToken` to continue
 *  paging through the results
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Found waiters in the project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRuntimeConfig_Waiter *> *waiters;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRCloudRuntimeConfig_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress.
 *  If true, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure. */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_OperationMetadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the
 *  `name` should have the format of `operations/some/unique/name`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_OperationResponse *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudRuntimeConfig_OperationMetadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudRuntimeConfig_OperationResponse : GTLRObject
@end


/**
 *  A RuntimeConfig resource is the primary resource in the Cloud RuntimeConfig
 *  service. A RuntimeConfig resource consists of metadata and a hierarchy of
 *  variables.
 */
@interface GTLRCloudRuntimeConfig_RuntimeConfig : GTLRObject

/**
 *  An optional description of the RuntimeConfig object.
 *  The length of the description must be less than 256 bytes.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  The resource name of a runtime config. The name must have the format:
 *  projects/[PROJECT_ID]/configs/[CONFIG_NAME]
 *  The `[PROJECT_ID]` must be a valid project ID, and `[CONFIG_NAME]` is an
 *  arbitrary name that matches RFC 1035 segment specification. The length of
 *  `[CONFIG_NAME]` must be less than 64 bytes.
 *  You pick the RuntimeConfig resource name, but the server will validate that
 *  the name adheres to this format. After you create the resource, you cannot
 *  change the resource's name.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` which can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting purpose.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRCloudRuntimeConfig_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There will be a
 *  common set of message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRuntimeConfig_StatusDetailsItem *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRCloudRuntimeConfig_StatusDetailsItem
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudRuntimeConfig_StatusDetailsItem : GTLRObject
@end


/**
 *  Describes a single variable within a RuntimeConfig resource.
 *  The name denotes the hierarchical variable name. For example,
 *  `ports/serving_port` is a valid variable name. The variable value is an
 *  opaque string and only leaf variables can have values (that is, variables
 *  that do not have any child variables).
 */
@interface GTLRCloudRuntimeConfig_Variable : GTLRObject

/**
 *  The name of the variable resource, in the format:
 *  projects/[PROJECT_ID]/configs/[CONFIG_NAME]/variables/[VARIABLE_NAME]
 *  The `[PROJECT_ID]` must be a valid project ID, `[CONFIG_NAME]` must be a
 *  valid RuntimeConfig reource and `[VARIABLE_NAME]` follows Unix file system
 *  file path naming.
 *  The `[VARIABLE_NAME]` can contain ASCII letters, numbers, slashes and
 *  dashes. Slashes are used as path element separators and are not part of the
 *  `[VARIABLE_NAME]` itself, so `[VARIABLE_NAME]` must contain at least one
 *  non-slash character. Multiple slashes are coalesced into single slash
 *  character. Each path segment should follow RFC 1035 segment specification.
 *  The length of a `[VARIABLE_NAME]` must be less than 256 bytes.
 *  Once you create a variable, you cannot change the variable name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  [Ouput only] The current state of the variable. The variable state indicates
 *  the outcome of the `variables().watch` call and is visible through the
 *  `get` and `list` calls.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudRuntimeConfig_Variable_State_Deleted The variable was
 *        deleted, while `variables().watch` was executing. (Value: "DELETED")
 *    @arg @c kGTLRCloudRuntimeConfig_Variable_State_Updated The variable was
 *        updated, while `variables().watch` was executing. (Value: "UPDATED")
 *    @arg @c kGTLRCloudRuntimeConfig_Variable_State_VariableStateUnspecified
 *        Default variable state. (Value: "VARIABLE_STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The textual value of the variable. The length of the value must be less
 *  than 4096 bytes. Empty values are also accepted.
 *  NB: Only one of value and string_value can be set at the same time.
 */
@property(nonatomic, copy, nullable) NSString *text;

/** [Output Only] The time of the last variable update. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/**
 *  The binary value of the variable. The length of the value must be less
 *  than 4096 bytes. Empty values are also accepted. The value must be
 *  Base64 encoded.
 *  NB: Only one of value and string_value can be set at the same time.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  A Waiter resource waits for some end condition within a RuntimeConfig
 *  resource
 *  to be met before it returns. For example, assume you have a distributed
 *  system where each node writes to a Variable resource indidicating the node's
 *  readiness as part of the startup process.
 *  You then configure a Waiter resource with the success condition set to wait
 *  until some number of nodes have checked in. Afterwards, your application
 *  runs some arbitrary code after the condition has been met and the waiter
 *  returns successfully.
 *  Once created, a Waiter resource is immutable.
 *  To learn more about using waiters, read the
 *  [Creating a
 *  Waiter](/deployment-manager/runtime-configurator/creating-a-waiter)
 *  documentation.
 */
@interface GTLRCloudRuntimeConfig_Waiter : GTLRObject

/**
 *  [Output Only] The instant at which this Waiter resource was created. Adding
 *  the value of `timeout` to this instant yields the timeout deadline for the
 *  waiter.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  [Output Only] If the value is `false`, it means the waiter is still waiting
 *  for one of its conditions to be met.
 *  If true, the waiter has finished. If the waiter finished due to a timeout
 *  or failure, `error` will be set.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/**
 *  [Output Only] If the waiter ended due to a failure or timeout, this value
 *  will be set.
 */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_Status *error;

/**
 *  [Optional] The failure condition of this waiter. If this condition is met,
 *  `done` will be set to `true` and the `error` code will be set to `ABORTED`.
 *  The failure condition takes precedence over the success condition. If both
 *  conditions are met, a failure will be indicated. This value is optional; if
 *  no failure condition is set, the only failure scenario will be a timeout.
 */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_EndCondition *failure;

/**
 *  The name of the Waiter resource, in the format:
 *  projects/[PROJECT_ID]/configs/[CONFIG_NAME]/waiters/[WAITER_NAME]
 *  The `[PROJECT_ID]` must be a valid Google Cloud project ID,
 *  the `[CONFIG_NAME]` must be a valid RuntimeConfig resource, the
 *  `[WAITER_NAME]` must match RFC 1035 segment specification, and the length
 *  of `[WAITER_NAME]` must be less than 64 bytes.
 *  After you create a Waiter resource, you cannot change the resource name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  [Required] The success condition. If this condition is met, `done` will be
 *  set to `true` and the `error` value will remain unset. The failure condition
 *  takes precedence over the success condition. If both conditions are met, a
 *  failure will be indicated.
 */
@property(nonatomic, strong, nullable) GTLRCloudRuntimeConfig_EndCondition *success;

/**
 *  [Required] Specifies the timeout of the waiter in seconds, beginning from
 *  the instant that `waiters().create` method is called. If this time elapses
 *  before the success or failure conditions are met, the waiter fails and sets
 *  the `error` code to `DEADLINE_EXCEEDED`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

@end


/**
 *  Request for the `WatchVariable()` method.
 */
@interface GTLRCloudRuntimeConfig_WatchVariableRequest : GTLRObject

/**
 *  If specified, checks the current timestamp of the variable and if the
 *  current timestamp is newer than `newerThan` timestamp, the method returns
 *  immediately.
 *  If not specified or the variable has an older timestamp, the watcher waits
 *  for a the value to change before returning.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *newerThan;

@end

NS_ASSUME_NONNULL_END
