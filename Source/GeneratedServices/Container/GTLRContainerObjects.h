// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Container Engine API (container/v1)
// Description:
//   The Google Kubernetes Engine API is used for building and managing
//   container based applications, powered by the open source Kubernetes
//   technology.
// Documentation:
//   https://cloud.google.com/container-engine/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRContainer_AcceleratorConfig;
@class GTLRContainer_AddonsConfig;
@class GTLRContainer_AutoUpgradeOptions;
@class GTLRContainer_CidrBlock;
@class GTLRContainer_ClientCertificateConfig;
@class GTLRContainer_Cluster;
@class GTLRContainer_Cluster_ResourceLabels;
@class GTLRContainer_ClusterUpdate;
@class GTLRContainer_DailyMaintenanceWindow;
@class GTLRContainer_HorizontalPodAutoscaling;
@class GTLRContainer_HttpLoadBalancing;
@class GTLRContainer_IPAllocationPolicy;
@class GTLRContainer_KubernetesDashboard;
@class GTLRContainer_LegacyAbac;
@class GTLRContainer_MaintenancePolicy;
@class GTLRContainer_MaintenanceWindow;
@class GTLRContainer_MasterAuth;
@class GTLRContainer_MasterAuthorizedNetworksConfig;
@class GTLRContainer_NetworkPolicy;
@class GTLRContainer_NetworkPolicyConfig;
@class GTLRContainer_NodeConfig;
@class GTLRContainer_NodeConfig_Labels;
@class GTLRContainer_NodeConfig_Metadata;
@class GTLRContainer_NodeManagement;
@class GTLRContainer_NodePool;
@class GTLRContainer_NodePoolAutoscaling;
@class GTLRContainer_Operation;
@class GTLRContainer_SetLabelsRequest_ResourceLabels;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRContainer_Cluster.status

/**
 *  The ERROR state indicates the cluster may be unusable. Details
 *  can be found in the `statusMessage` field.
 *
 *  Value: "ERROR"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Cluster_Status_Error;
/**
 *  The PROVISIONING state indicates the cluster is being created.
 *
 *  Value: "PROVISIONING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Cluster_Status_Provisioning;
/**
 *  The RECONCILING state indicates that some work is actively being done on
 *  the cluster, such as upgrading the master or node software. Details can
 *  be found in the `statusMessage` field.
 *
 *  Value: "RECONCILING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Cluster_Status_Reconciling;
/**
 *  The RUNNING state indicates the cluster has been created and is fully
 *  usable.
 *
 *  Value: "RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Cluster_Status_Running;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Cluster_Status_StatusUnspecified;
/**
 *  The STOPPING state indicates the cluster is being deleted.
 *
 *  Value: "STOPPING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Cluster_Status_Stopping;

// ----------------------------------------------------------------------------
// GTLRContainer_NetworkPolicy.provider

/**
 *  Tigera (Calico Felix).
 *
 *  Value: "CALICO"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NetworkPolicy_Provider_Calico;
/**
 *  Not set
 *
 *  Value: "PROVIDER_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NetworkPolicy_Provider_ProviderUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_NodePool.status

/**
 *  The ERROR state indicates the node pool may be unusable. Details
 *  can be found in the `statusMessage` field.
 *
 *  Value: "ERROR"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_Error;
/**
 *  The PROVISIONING state indicates the node pool is being created.
 *
 *  Value: "PROVISIONING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_Provisioning;
/**
 *  The RECONCILING state indicates that some work is actively being done on
 *  the node pool, such as upgrading node software. Details can
 *  be found in the `statusMessage` field.
 *
 *  Value: "RECONCILING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_Reconciling;
/**
 *  The RUNNING state indicates the node pool has been created
 *  and is fully usable.
 *
 *  Value: "RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_Running;
/**
 *  The RUNNING_WITH_ERROR state indicates the node pool has been created
 *  and is partially usable. Some error state has occurred and some
 *  functionality may be impaired. Customer may need to reissue a request
 *  or trigger a new update.
 *
 *  Value: "RUNNING_WITH_ERROR"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_RunningWithError;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_StatusUnspecified;
/**
 *  The STOPPING state indicates the node pool is being deleted.
 *
 *  Value: "STOPPING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_NodePool_Status_Stopping;

// ----------------------------------------------------------------------------
// GTLRContainer_Operation.operationType

/**
 *  Automatic node pool repair.
 *
 *  Value: "AUTO_REPAIR_NODES"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_AutoRepairNodes;
/**
 *  Automatic node upgrade.
 *
 *  Value: "AUTO_UPGRADE_NODES"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_AutoUpgradeNodes;
/**
 *  Cluster create.
 *
 *  Value: "CREATE_CLUSTER"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_CreateCluster;
/**
 *  Node pool create.
 *
 *  Value: "CREATE_NODE_POOL"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_CreateNodePool;
/**
 *  Cluster delete.
 *
 *  Value: "DELETE_CLUSTER"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_DeleteCluster;
/**
 *  Node pool delete.
 *
 *  Value: "DELETE_NODE_POOL"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_DeleteNodePool;
/**
 *  Cluster repair.
 *
 *  Value: "REPAIR_CLUSTER"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_RepairCluster;
/**
 *  Set labels.
 *
 *  Value: "SET_LABELS"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetLabels;
/**
 *  Set the maintenance policy.
 *
 *  Value: "SET_MAINTENANCE_POLICY"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetMaintenancePolicy;
/**
 *  Set/generate master auth materials
 *
 *  Value: "SET_MASTER_AUTH"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetMasterAuth;
/**
 *  Updates network policy for a cluster.
 *
 *  Value: "SET_NETWORK_POLICY"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetNetworkPolicy;
/**
 *  Set node pool management.
 *
 *  Value: "SET_NODE_POOL_MANAGEMENT"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetNodePoolManagement;
/**
 *  Set node pool size.
 *
 *  Value: "SET_NODE_POOL_SIZE"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_SetNodePoolSize;
/**
 *  Not set.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_TypeUnspecified;
/**
 *  Cluster update.
 *
 *  Value: "UPDATE_CLUSTER"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_UpdateCluster;
/**
 *  A master upgrade.
 *
 *  Value: "UPGRADE_MASTER"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_UpgradeMaster;
/**
 *  A node upgrade.
 *
 *  Value: "UPGRADE_NODES"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_OperationType_UpgradeNodes;

// ----------------------------------------------------------------------------
// GTLRContainer_Operation.status

/**
 *  The operation is aborting.
 *
 *  Value: "ABORTING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_Status_Aborting;
/**
 *  The operation is done, either cancelled or completed.
 *
 *  Value: "DONE"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_Status_Done;
/**
 *  The operation has been created.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_Status_Pending;
/**
 *  The operation is currently running.
 *
 *  Value: "RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_Status_Running;
/**
 *  Not set.
 *
 *  Value: "STATUS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRContainer_Operation_Status_StatusUnspecified;

// ----------------------------------------------------------------------------
// GTLRContainer_SetMasterAuthRequest.action

/**
 *  Generate a new password and set it to that.
 *
 *  Value: "GENERATE_PASSWORD"
 */
GTLR_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_GeneratePassword;
/**
 *  Set the password to a user generated value.
 *
 *  Value: "SET_PASSWORD"
 */
GTLR_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_SetPassword;
/**
 *  Set the username. If an empty username is provided, basic authentication
 *  is disabled for the cluster. If a non-empty username is provided, basic
 *  authentication is enabled, with either a provided password or a generated
 *  one.
 *
 *  Value: "SET_USERNAME"
 */
GTLR_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_SetUsername;
/**
 *  Operation is unknown and will error out.
 *
 *  Value: "UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRContainer_SetMasterAuthRequest_Action_Unknown;

/**
 *  AcceleratorConfig represents a Hardware Accelerator request.
 */
@interface GTLRContainer_AcceleratorConfig : GTLRObject

/**
 *  The number of the accelerator cards exposed to an instance.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *acceleratorCount;

/**
 *  The accelerator type resource name. List of supported accelerators
 *  [here](/compute/docs/gpus/#Introduction)
 */
@property(nonatomic, copy, nullable) NSString *acceleratorType;

@end


/**
 *  Configuration for the addons that can be automatically spun up in the
 *  cluster, enabling additional functionality.
 */
@interface GTLRContainer_AddonsConfig : GTLRObject

/**
 *  Configuration for the horizontal pod autoscaling feature, which
 *  increases or decreases the number of replica pods a replication controller
 *  has based on the resource usage of the existing pods.
 */
@property(nonatomic, strong, nullable) GTLRContainer_HorizontalPodAutoscaling *horizontalPodAutoscaling;

/**
 *  Configuration for the HTTP (L7) load balancing controller addon, which
 *  makes it easy to set up HTTP load balancers for services in a cluster.
 */
@property(nonatomic, strong, nullable) GTLRContainer_HttpLoadBalancing *httpLoadBalancing;

/** Configuration for the Kubernetes Dashboard. */
@property(nonatomic, strong, nullable) GTLRContainer_KubernetesDashboard *kubernetesDashboard;

/**
 *  Configuration for NetworkPolicy. This only tracks whether the addon
 *  is enabled or not on the Master, it does not track whether network policy
 *  is enabled for the nodes.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPolicyConfig *networkPolicyConfig;

@end


/**
 *  AutoUpgradeOptions defines the set of options for the user to control how
 *  the Auto Upgrades will proceed.
 */
@interface GTLRContainer_AutoUpgradeOptions : GTLRObject

/**
 *  [Output only] This field is set when upgrades are about to commence
 *  with the approximate start time for the upgrades, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *autoUpgradeStartTime;

/**
 *  [Output only] This field is set when upgrades are about to commence
 *  with the description of the upgrade.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

@end


/**
 *  CancelOperationRequest cancels a single operation.
 */
@interface GTLRContainer_CancelOperationRequest : GTLRObject
@end


/**
 *  CidrBlock contains an optional name and one CIDR block.
 */
@interface GTLRContainer_CidrBlock : GTLRObject

/** cidr_block must be specified in CIDR notation. */
@property(nonatomic, copy, nullable) NSString *cidrBlock;

/** display_name is an optional field for users to identify CIDR blocks. */
@property(nonatomic, copy, nullable) NSString *displayName;

@end


/**
 *  Configuration for client certificates on the cluster.
 */
@interface GTLRContainer_ClientCertificateConfig : GTLRObject

/**
 *  Issue a client certificate.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *issueClientCertificate;

@end


/**
 *  A Google Kubernetes Engine cluster.
 */
@interface GTLRContainer_Cluster : GTLRObject

/** Configurations for the various addons available to run in the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_AddonsConfig *addonsConfig;

/**
 *  The IP address range of the container pods in this cluster, in
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
 *  notation (e.g. `10.96.0.0/14`). Leave blank to have
 *  one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
 */
@property(nonatomic, copy, nullable) NSString *clusterIpv4Cidr;

/**
 *  [Output only] The time the cluster was created, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *createTime;

/** [Output only] The current software version of the master endpoint. */
@property(nonatomic, copy, nullable) NSString *currentMasterVersion;

/**
 *  [Output only] The number of nodes currently in the cluster.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *currentNodeCount;

/**
 *  [Output only] The current version of the node software components.
 *  If they are currently at multiple versions because they're in the process
 *  of being upgraded, this reflects the minimum version of all nodes.
 */
@property(nonatomic, copy, nullable) NSString *currentNodeVersion;

/**
 *  An optional description of this cluster.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Kubernetes alpha features are enabled on this cluster. This includes alpha
 *  API groups (e.g. v1alpha1) and features that may not be production ready in
 *  the kubernetes version of the master and nodes.
 *  The cluster has no SLA for uptime and master/node upgrades are disabled.
 *  Alpha enabled clusters are automatically deleted thirty days after
 *  creation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableKubernetesAlpha;

/**
 *  [Output only] The IP address of this cluster's master endpoint.
 *  The endpoint can be accessed from the internet at
 *  `https://username:password\@endpoint/`.
 *  See the `masterAuth` property of this resource for username and
 *  password information.
 */
@property(nonatomic, copy, nullable) NSString *endpoint;

/**
 *  [Output only] The time the cluster will be automatically
 *  deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *expireTime;

/**
 *  The initial Kubernetes version for this cluster. Valid versions are those
 *  found in validMasterVersions returned by getServerConfig. The version can
 *  be upgraded over time; such upgrades are reflected in
 *  currentMasterVersion and currentNodeVersion.
 */
@property(nonatomic, copy, nullable) NSString *initialClusterVersion;

/**
 *  The number of nodes to create in this cluster. You must ensure that your
 *  Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
 *  is sufficient for this number of instances. You must also have available
 *  firewall and routes quota.
 *  For requests, this field should only be used in lieu of a
 *  "node_pool" object, since this configuration (along with the
 *  "node_config") will be used to create a "NodePool" object with an
 *  auto-generated name. Do not use this and a node_pool at the same time.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialNodeCount;

/** Deprecated. Use node_pools.instance_group_urls. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instanceGroupUrls;

/** Configuration for cluster IP allocation. */
@property(nonatomic, strong, nullable) GTLRContainer_IPAllocationPolicy *ipAllocationPolicy;

/** The fingerprint of the set of labels for this cluster. */
@property(nonatomic, copy, nullable) NSString *labelFingerprint;

/** Configuration for the legacy ABAC authorization mode. */
@property(nonatomic, strong, nullable) GTLRContainer_LegacyAbac *legacyAbac;

/**
 *  The list of Google Compute Engine
 *  [locations](/compute/docs/zones#available) in which the cluster's nodes
 *  should be located.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locations;

/**
 *  The logging service the cluster should use to write logs.
 *  Currently available options:
 *  * `logging.googleapis.com` - the Google Cloud Logging service.
 *  * `none` - no logs will be exported from the cluster.
 *  * if left as an empty string,`logging.googleapis.com` will be used.
 */
@property(nonatomic, copy, nullable) NSString *loggingService;

/** Configure the maintenance policy for this cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenancePolicy *maintenancePolicy;

/** The authentication information for accessing the master endpoint. */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuth *masterAuth;

/**
 *  Master authorized networks is a Beta feature.
 *  The configuration options for master authorized networks feature.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuthorizedNetworksConfig *masterAuthorizedNetworksConfig;

/**
 *  The monitoring service the cluster should use to write metrics.
 *  Currently available options:
 *  * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
 *  * `none` - no metrics will be exported from the cluster.
 *  * if left as an empty string, `monitoring.googleapis.com` will be used.
 */
@property(nonatomic, copy, nullable) NSString *monitoringService;

/**
 *  The name of this cluster. The name must be unique within this project
 *  and zone, and can be up to 40 characters with the following restrictions:
 *  * Lowercase letters, numbers, and hyphens only.
 *  * Must start with a letter.
 *  * Must end with a number or a letter.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the Google Compute Engine
 *  [network](/compute/docs/networks-and-firewalls#networks) to which the
 *  cluster is connected. If left unspecified, the `default` network
 *  will be used.
 */
@property(nonatomic, copy, nullable) NSString *network;

/** Configuration options for the NetworkPolicy feature. */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPolicy *networkPolicy;

/**
 *  Parameters used in creating the cluster's nodes.
 *  See `nodeConfig` for the description of its properties.
 *  For requests, this field should only be used in lieu of a
 *  "node_pool" object, since this configuration (along with the
 *  "initial_node_count") will be used to create a "NodePool" object with an
 *  auto-generated name. Do not use this and a node_pool at the same time.
 *  For responses, this field will be populated with the node configuration of
 *  the first node pool.
 *  If unspecified, the defaults are used.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig *nodeConfig;

/**
 *  [Output only] The size of the address space on each node for hosting
 *  containers. This is provisioned from within the `container_ipv4_cidr`
 *  range.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeIpv4CidrSize;

/**
 *  The node pools associated with this cluster.
 *  This field should not be set if "node_config" or "initial_node_count" are
 *  specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodePool *> *nodePools;

/**
 *  The resource labels for the cluster to use to annotate any related
 *  Google Compute Engine resources.
 */
@property(nonatomic, strong, nullable) GTLRContainer_Cluster_ResourceLabels *resourceLabels;

/** [Output only] Server-defined URL for the resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  [Output only] The IP address range of the Kubernetes services in
 *  this cluster, in
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
 *  notation (e.g. `1.2.3.4/29`). Service addresses are
 *  typically put in the last `/16` from the container CIDR.
 */
@property(nonatomic, copy, nullable) NSString *servicesIpv4Cidr;

/**
 *  [Output only] The current status of this cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_Cluster_Status_Error The ERROR state indicates the
 *        cluster may be unusable. Details
 *        can be found in the `statusMessage` field. (Value: "ERROR")
 *    @arg @c kGTLRContainer_Cluster_Status_Provisioning The PROVISIONING state
 *        indicates the cluster is being created. (Value: "PROVISIONING")
 *    @arg @c kGTLRContainer_Cluster_Status_Reconciling The RECONCILING state
 *        indicates that some work is actively being done on
 *        the cluster, such as upgrading the master or node software. Details
 *        can
 *        be found in the `statusMessage` field. (Value: "RECONCILING")
 *    @arg @c kGTLRContainer_Cluster_Status_Running The RUNNING state indicates
 *        the cluster has been created and is fully
 *        usable. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_Cluster_Status_StatusUnspecified Not set. (Value:
 *        "STATUS_UNSPECIFIED")
 *    @arg @c kGTLRContainer_Cluster_Status_Stopping The STOPPING state
 *        indicates the cluster is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  [Output only] Additional information about the current status of this
 *  cluster, if available.
 */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/**
 *  The name of the Google Compute Engine
 *  [subnetwork](/compute/docs/subnetworks) to which the
 *  cluster is connected.
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  [Output only] The name of the Google Compute Engine
 *  [zone](/compute/docs/zones#available) in which the cluster
 *  resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  The resource labels for the cluster to use to annotate any related
 *  Google Compute Engine resources.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_Cluster_ResourceLabels : GTLRObject
@end


/**
 *  ClusterUpdate describes an update to the cluster. Exactly one update can
 *  be applied to a cluster with each request, so at most one field can be
 *  provided.
 */
@interface GTLRContainer_ClusterUpdate : GTLRObject

/** Configurations for the various addons available to run in the cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_AddonsConfig *desiredAddonsConfig;

/**
 *  The desired image type for the node pool.
 *  NOTE: Set the "desired_node_pool" field as well.
 */
@property(nonatomic, copy, nullable) NSString *desiredImageType;

/**
 *  The desired list of Google Compute Engine
 *  [locations](/compute/docs/zones#available) in which the cluster's nodes
 *  should be located. Changing the locations a cluster is in will result
 *  in nodes being either created or removed from the cluster, depending on
 *  whether locations are being added or removed.
 *  This list must always include the cluster's primary zone.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *desiredLocations;

/**
 *  Master authorized networks is a Beta feature.
 *  The desired configuration options for master authorized networks feature.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuthorizedNetworksConfig *desiredMasterAuthorizedNetworksConfig;

/**
 *  The Kubernetes version to change the master to. The only valid value is the
 *  latest supported version. Use "-" to have the server automatically select
 *  the latest version.
 */
@property(nonatomic, copy, nullable) NSString *desiredMasterVersion;

/**
 *  The monitoring service the cluster should use to write metrics.
 *  Currently available options:
 *  * "monitoring.googleapis.com" - the Google Cloud Monitoring service
 *  * "none" - no metrics will be exported from the cluster
 */
@property(nonatomic, copy, nullable) NSString *desiredMonitoringService;

/**
 *  Autoscaler configuration for the node pool specified in
 *  desired_node_pool_id. If there is only one pool in the
 *  cluster and desired_node_pool_id is not provided then
 *  the change applies to that single node pool.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoscaling *desiredNodePoolAutoscaling;

/**
 *  The node pool to be upgraded. This field is mandatory if
 *  "desired_node_version", "desired_image_family" or
 *  "desired_node_pool_autoscaling" is specified and there is more than one
 *  node pool on the cluster.
 */
@property(nonatomic, copy, nullable) NSString *desiredNodePoolId;

/**
 *  The Kubernetes version to change the nodes to (typically an
 *  upgrade). Use `-` to upgrade to the latest version supported by
 *  the server.
 */
@property(nonatomic, copy, nullable) NSString *desiredNodeVersion;

@end


/**
 *  CompleteIPRotationRequest moves the cluster master back into single-IP mode.
 */
@interface GTLRContainer_CompleteIPRotationRequest : GTLRObject
@end


/**
 *  CreateClusterRequest creates a cluster.
 */
@interface GTLRContainer_CreateClusterRequest : GTLRObject

/**
 *  A [cluster
 *  resource](/container-engine/reference/rest/v1/projects.zones.clusters)
 */
@property(nonatomic, strong, nullable) GTLRContainer_Cluster *cluster;

@end


/**
 *  CreateNodePoolRequest creates a node pool for a cluster.
 */
@interface GTLRContainer_CreateNodePoolRequest : GTLRObject

/** The node pool to create. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePool *nodePool;

@end


/**
 *  Time window specified for daily maintenance operations.
 */
@interface GTLRContainer_DailyMaintenanceWindow : GTLRObject

/**
 *  [Output only] Duration of the time window, automatically chosen to be
 *  smallest possible in the given scenario.
 *  Duration will be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
 *  format "PTnHnMnS".
 */
@property(nonatomic, copy, nullable) NSString *duration;

/**
 *  Time within the maintenance window to start the maintenance operations.
 *  Time format should be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
 *  format "HH:MM‚Äù, where HH : [00-23] and MM : [00-59] GMT.
 */
@property(nonatomic, copy, nullable) NSString *startTime;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRContainer_Empty : GTLRObject
@end


/**
 *  Configuration options for the horizontal pod autoscaling feature, which
 *  increases or decreases the number of replica pods a replication controller
 *  has based on the resource usage of the existing pods.
 */
@interface GTLRContainer_HorizontalPodAutoscaling : GTLRObject

/**
 *  Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
 *  When enabled, it ensures that a Heapster pod is running in the cluster,
 *  which is also used by the Cloud Monitoring service.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Configuration options for the HTTP (L7) load balancing controller addon,
 *  which makes it easy to set up HTTP load balancers for services in a cluster.
 */
@interface GTLRContainer_HttpLoadBalancing : GTLRObject

/**
 *  Whether the HTTP Load Balancing controller is enabled in the cluster.
 *  When enabled, it runs a small pod in the cluster that manages the load
 *  balancers.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Configuration for controlling how IPs are allocated in the cluster.
 */
@interface GTLRContainer_IPAllocationPolicy : GTLRObject

/** This field is deprecated, use cluster_ipv4_cidr_block. */
@property(nonatomic, copy, nullable) NSString *clusterIpv4Cidr;

/**
 *  The IP address range for the cluster pod IPs. If this field is set, then
 *  `cluster.cluster_ipv4_cidr` must be left blank.
 *  This field is only applicable when `use_ip_aliases` is true.
 *  Set to blank to have a range chosen with the default size.
 *  Set to /netmask (e.g. `/14`) to have a range chosen with a specific
 *  netmask.
 *  Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
 *  notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
 *  `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
 *  to use.
 */
@property(nonatomic, copy, nullable) NSString *clusterIpv4CidrBlock;

/**
 *  The name of the secondary range to be used for the cluster CIDR
 *  block. The secondary range will be used for pod IP
 *  addresses. This must be an existing secondary range associated
 *  with the cluster subnetwork.
 *  This field is only applicable with use_ip_aliases is true and
 *  create_subnetwork is false.
 */
@property(nonatomic, copy, nullable) NSString *clusterSecondaryRangeName;

/**
 *  Whether a new subnetwork will be created automatically for the cluster.
 *  This field is only applicable when `use_ip_aliases` is true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *createSubnetwork;

/** This field is deprecated, use node_ipv4_cidr_block. */
@property(nonatomic, copy, nullable) NSString *nodeIpv4Cidr;

/**
 *  The IP address range of the instance IPs in this cluster.
 *  This is applicable only if `create_subnetwork` is true.
 *  Set to blank to have a range chosen with the default size.
 *  Set to /netmask (e.g. `/14`) to have a range chosen with a specific
 *  netmask.
 *  Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
 *  notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
 *  `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
 *  to use.
 */
@property(nonatomic, copy, nullable) NSString *nodeIpv4CidrBlock;

/** This field is deprecated, use services_ipv4_cidr_block. */
@property(nonatomic, copy, nullable) NSString *servicesIpv4Cidr;

/**
 *  The IP address range of the services IPs in this cluster. If blank, a range
 *  will be automatically chosen with the default size.
 *  This field is only applicable when `use_ip_aliases` is true.
 *  Set to blank to have a range chosen with the default size.
 *  Set to /netmask (e.g. `/14`) to have a range chosen with a specific
 *  netmask.
 *  Set to a
 *  [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
 *  notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
 *  `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
 *  to use.
 */
@property(nonatomic, copy, nullable) NSString *servicesIpv4CidrBlock;

/**
 *  The name of the secondary range to be used as for the services
 *  CIDR block. The secondary range will be used for service
 *  ClusterIPs. This must be an existing secondary range associated
 *  with the cluster subnetwork.
 *  This field is only applicable with use_ip_aliases is true and
 *  create_subnetwork is false.
 */
@property(nonatomic, copy, nullable) NSString *servicesSecondaryRangeName;

/**
 *  A custom subnetwork name to be used if `create_subnetwork` is true. If
 *  this field is empty, then an automatic name will be chosen for the new
 *  subnetwork.
 */
@property(nonatomic, copy, nullable) NSString *subnetworkName;

/**
 *  Whether alias IPs will be used for pod IPs in the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useIpAliases;

@end


/**
 *  Configuration for the Kubernetes Dashboard.
 */
@interface GTLRContainer_KubernetesDashboard : GTLRObject

/**
 *  Whether the Kubernetes Dashboard is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Configuration for the legacy Attribute Based Access Control authorization
 *  mode.
 */
@interface GTLRContainer_LegacyAbac : GTLRObject

/**
 *  Whether the ABAC authorizer is enabled for this cluster. When enabled,
 *  identities in the system, including service accounts, nodes, and
 *  controllers, will have statically granted permissions beyond those
 *  provided by the RBAC configuration or IAM.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  ListClustersResponse is the result of ListClustersRequest.
 */
@interface GTLRContainer_ListClustersResponse : GTLRObject

/**
 *  A list of clusters in the project in the specified zone, or
 *  across all ones.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Cluster *> *clusters;

/**
 *  If any zones are listed here, the list of clusters returned
 *  may be missing those zones.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *missingZones;

@end


/**
 *  ListNodePoolsResponse is the result of ListNodePoolsRequest.
 */
@interface GTLRContainer_ListNodePoolsResponse : GTLRObject

/** A list of node pools for a cluster. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_NodePool *> *nodePools;

@end


/**
 *  ListOperationsResponse is the result of ListOperationsRequest.
 */
@interface GTLRContainer_ListOperationsResponse : GTLRObject

/**
 *  If any zones are listed here, the list of operations returned
 *  may be missing the operations from those zones.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *missingZones;

/** A list of operations in the project in the specified zone. */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_Operation *> *operations;

@end


/**
 *  MaintenancePolicy defines the maintenance policy to be used for the cluster.
 */
@interface GTLRContainer_MaintenancePolicy : GTLRObject

/** Specifies the maintenance window in which maintenance may be performed. */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenanceWindow *window;

@end


/**
 *  MaintenanceWindow defines the maintenance window to be used for the cluster.
 */
@interface GTLRContainer_MaintenanceWindow : GTLRObject

/** DailyMaintenanceWindow specifies a daily maintenance operation window. */
@property(nonatomic, strong, nullable) GTLRContainer_DailyMaintenanceWindow *dailyMaintenanceWindow;

@end


/**
 *  The authentication information for accessing the master endpoint.
 *  Authentication can be done using HTTP basic auth or using client
 *  certificates.
 */
@interface GTLRContainer_MasterAuth : GTLRObject

/**
 *  [Output only] Base64-encoded public certificate used by clients to
 *  authenticate to the cluster endpoint.
 */
@property(nonatomic, copy, nullable) NSString *clientCertificate;

/**
 *  Configuration for client certificate authentication on the cluster. If no
 *  configuration is specified, a client certificate is issued.
 */
@property(nonatomic, strong, nullable) GTLRContainer_ClientCertificateConfig *clientCertificateConfig;

/**
 *  [Output only] Base64-encoded private key used by clients to authenticate
 *  to the cluster endpoint.
 */
@property(nonatomic, copy, nullable) NSString *clientKey;

/**
 *  [Output only] Base64-encoded public certificate that is the root of
 *  trust for the cluster.
 */
@property(nonatomic, copy, nullable) NSString *clusterCaCertificate;

/**
 *  The password to use for HTTP basic authentication to the master endpoint.
 *  Because the master endpoint is open to the Internet, you should create a
 *  strong password. If a password is provided for cluster creation, username
 *  must be non-empty.
 */
@property(nonatomic, copy, nullable) NSString *password;

/**
 *  The username to use for HTTP basic authentication to the master endpoint.
 *  For clusters v1.6.0 and later, you can disable basic authentication by
 *  providing an empty username.
 */
@property(nonatomic, copy, nullable) NSString *username;

@end


/**
 *  Master authorized networks is a Beta feature.
 *  Configuration options for the master authorized networks feature. Enabled
 *  master authorized networks will disallow all external traffic to access
 *  Kubernetes master through HTTPS except traffic from the given CIDR blocks,
 *  Google Compute Engine Public IPs and Google Prod IPs.
 */
@interface GTLRContainer_MasterAuthorizedNetworksConfig : GTLRObject

/**
 *  cidr_blocks define up to 10 external networks that could access
 *  Kubernetes master through HTTPS.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_CidrBlock *> *cidrBlocks;

/**
 *  Whether or not master authorized networks is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  Configuration options for the NetworkPolicy feature.
 *  https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
 */
@interface GTLRContainer_NetworkPolicy : GTLRObject

/**
 *  Whether network policy is enabled on the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  The selected network policy provider.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NetworkPolicy_Provider_Calico Tigera (Calico
 *        Felix). (Value: "CALICO")
 *    @arg @c kGTLRContainer_NetworkPolicy_Provider_ProviderUnspecified Not set
 *        (Value: "PROVIDER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *provider;

@end


/**
 *  Configuration for NetworkPolicy. This only tracks whether the addon
 *  is enabled or not on the Master, it does not track whether network policy
 *  is enabled for the nodes.
 */
@interface GTLRContainer_NetworkPolicyConfig : GTLRObject

/**
 *  Whether NetworkPolicy is enabled for this cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

@end


/**
 *  Parameters that describe the nodes in a cluster.
 */
@interface GTLRContainer_NodeConfig : GTLRObject

/**
 *  A list of hardware accelerators to be attached to each node.
 *  See https://cloud.google.com/compute/docs/gpus for more information about
 *  support for GPUs.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRContainer_AcceleratorConfig *> *accelerators;

/**
 *  Size of the disk attached to each node, specified in GB.
 *  The smallest allowed disk size is 10GB.
 *  If unspecified, the default disk size is 100GB.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskSizeGb;

/**
 *  The image type to use for this node. Note that for a given image type,
 *  the latest version of it will be used.
 */
@property(nonatomic, copy, nullable) NSString *imageType;

/**
 *  The map of Kubernetes labels (key/value pairs) to be applied to each node.
 *  These will added in addition to any default label(s) that
 *  Kubernetes may apply to the node.
 *  In case of conflict in label keys, the applied set may differ depending on
 *  the Kubernetes version -- it's best to assume the behavior is undefined
 *  and conflicts should be avoided.
 *  For more information, including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig_Labels *labels;

/**
 *  The number of local SSD disks to be attached to the node.
 *  The limit for this value is dependant upon the maximum number of
 *  disks available on a machine per zone. See:
 *  https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
 *  for more information.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *localSsdCount;

/**
 *  The name of a Google Compute Engine [machine
 *  type](/compute/docs/machine-types) (e.g.
 *  `n1-standard-1`).
 *  If unspecified, the default machine type is
 *  `n1-standard-1`.
 */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  The metadata key/value pairs assigned to instances in the cluster.
 *  Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
 *  in length. These are reflected as part of a URL in the metadata server.
 *  Additionally, to avoid ambiguity, keys must not conflict with any other
 *  metadata keys for the project or be one of the four reserved keys:
 *  "instance-template", "kube-env", "startup-script", and "user-data"
 *  Values are free-form strings, and only have meaning as interpreted by
 *  the image running in the instance. The only restriction placed on them is
 *  that each value's size must be less than or equal to 32 KB.
 *  The total size of all keys and values must be less than 512 KB.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig_Metadata *metadata;

/**
 *  Minimum CPU platform to be used by this instance. The instance may be
 *  scheduled on the specified or newer CPU platform. Applicable values are the
 *  friendly names of CPU platforms, such as
 *  <code>minCpuPlatform: &quot;Intel Haswell&quot;</code> or
 *  <code>minCpuPlatform: &quot;Intel Sandy Bridge&quot;</code>. For more
 *  information, read [how to specify min CPU
 *  platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
 */
@property(nonatomic, copy, nullable) NSString *minCpuPlatform;

/**
 *  The set of Google API scopes to be made available on all of the
 *  node VMs under the "default" service account.
 *  The following scopes are recommended, but not required, and by default are
 *  not included:
 *  * `https://www.googleapis.com/auth/compute` is required for mounting
 *  persistent storage on your nodes.
 *  * `https://www.googleapis.com/auth/devstorage.read_only` is required for
 *  communicating with **gcr.io**
 *  (the [Google Container Registry](/container-registry/)).
 *  If unspecified, no scopes are added, unless Cloud Logging or Cloud
 *  Monitoring are enabled, in which case their required scopes will be added.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oauthScopes;

/**
 *  Whether the nodes are created as preemptible VM instances. See:
 *  https://cloud.google.com/compute/docs/instances/preemptible for more
 *  information about preemptible VM instances.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *preemptible;

/**
 *  The Google Cloud Platform Service Account to be used by the node VMs. If
 *  no Service Account is specified, the "default" service account is used.
 */
@property(nonatomic, copy, nullable) NSString *serviceAccount;

/**
 *  The list of instance tags applied to all nodes. Tags are used to identify
 *  valid sources or targets for network firewalls and are specified by
 *  the client during cluster or node pool creation. Each tag within the list
 *  must comply with RFC1035.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tags;

@end


/**
 *  The map of Kubernetes labels (key/value pairs) to be applied to each node.
 *  These will added in addition to any default label(s) that
 *  Kubernetes may apply to the node.
 *  In case of conflict in label keys, the applied set may differ depending on
 *  the Kubernetes version -- it's best to assume the behavior is undefined
 *  and conflicts should be avoided.
 *  For more information, including usage and the valid values, see:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_NodeConfig_Labels : GTLRObject
@end


/**
 *  The metadata key/value pairs assigned to instances in the cluster.
 *  Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
 *  in length. These are reflected as part of a URL in the metadata server.
 *  Additionally, to avoid ambiguity, keys must not conflict with any other
 *  metadata keys for the project or be one of the four reserved keys:
 *  "instance-template", "kube-env", "startup-script", and "user-data"
 *  Values are free-form strings, and only have meaning as interpreted by
 *  the image running in the instance. The only restriction placed on them is
 *  that each value's size must be less than or equal to 32 KB.
 *  The total size of all keys and values must be less than 512 KB.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_NodeConfig_Metadata : GTLRObject
@end


/**
 *  NodeManagement defines the set of node management services turned on for the
 *  node pool.
 */
@interface GTLRContainer_NodeManagement : GTLRObject

/**
 *  A flag that specifies whether the node auto-repair is enabled for the node
 *  pool. If enabled, the nodes in this node pool will be monitored and, if
 *  they fail health checks too many times, an automatic repair action will be
 *  triggered.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoRepair;

/**
 *  A flag that specifies whether node auto-upgrade is enabled for the node
 *  pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
 *  up to date with the latest release version of Kubernetes.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoUpgrade;

/** Specifies the Auto Upgrade knobs for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_AutoUpgradeOptions *upgradeOptions;

@end


/**
 *  NodePool contains the name and configuration for a cluster's node pool.
 *  Node pools are a set of nodes (i.e. VM's), with a common configuration and
 *  specification, under the control of the cluster master. They may have a set
 *  of Kubernetes labels applied to them, which may be used to reference them
 *  during pod scheduling. They may also be resized up or down, to accommodate
 *  the workload.
 */
@interface GTLRContainer_NodePool : GTLRObject

/**
 *  Autoscaler configuration for this NodePool. Autoscaler is enabled
 *  only if a valid configuration is present.
 */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoscaling *autoscaling;

/** The node configuration of the pool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeConfig *config;

/**
 *  The initial node count for the pool. You must ensure that your
 *  Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
 *  is sufficient for this number of instances. You must also have available
 *  firewall and routes quota.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialNodeCount;

/**
 *  [Output only] The resource URLs of the [managed instance
 *  groups](/compute/docs/instance-groups/creating-groups-of-managed-instances)
 *  associated with this node pool.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instanceGroupUrls;

/** NodeManagement configuration for this NodePool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeManagement *management;

/** The name of the node pool. */
@property(nonatomic, copy, nullable) NSString *name;

/** [Output only] Server-defined URL for the resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  [Output only] The status of the nodes in this pool instance.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_NodePool_Status_Error The ERROR state indicates the
 *        node pool may be unusable. Details
 *        can be found in the `statusMessage` field. (Value: "ERROR")
 *    @arg @c kGTLRContainer_NodePool_Status_Provisioning The PROVISIONING state
 *        indicates the node pool is being created. (Value: "PROVISIONING")
 *    @arg @c kGTLRContainer_NodePool_Status_Reconciling The RECONCILING state
 *        indicates that some work is actively being done on
 *        the node pool, such as upgrading node software. Details can
 *        be found in the `statusMessage` field. (Value: "RECONCILING")
 *    @arg @c kGTLRContainer_NodePool_Status_Running The RUNNING state indicates
 *        the node pool has been created
 *        and is fully usable. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_NodePool_Status_RunningWithError The
 *        RUNNING_WITH_ERROR state indicates the node pool has been created
 *        and is partially usable. Some error state has occurred and some
 *        functionality may be impaired. Customer may need to reissue a request
 *        or trigger a new update. (Value: "RUNNING_WITH_ERROR")
 *    @arg @c kGTLRContainer_NodePool_Status_StatusUnspecified Not set. (Value:
 *        "STATUS_UNSPECIFIED")
 *    @arg @c kGTLRContainer_NodePool_Status_Stopping The STOPPING state
 *        indicates the node pool is being deleted. (Value: "STOPPING")
 */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  [Output only] Additional information about the current status of this
 *  node pool instance, if available.
 */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/** The version of the Kubernetes of this node. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  NodePoolAutoscaling contains information required by cluster autoscaler to
 *  adjust the size of the node pool to the current cluster usage.
 */
@interface GTLRContainer_NodePoolAutoscaling : GTLRObject

/**
 *  Is autoscaling enabled for this node pool.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Maximum number of nodes in the NodePool. Must be >= min_node_count. There
 *  has to enough quota to scale up the cluster.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxNodeCount;

/**
 *  Minimum number of nodes in the NodePool. Must be >= 1 and <=
 *  max_node_count.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minNodeCount;

@end


/**
 *  This operation resource represents operations that may have happened or are
 *  happening on the cluster. All fields are output only.
 */
@interface GTLRContainer_Operation : GTLRObject

/** Detailed operation progress, if available. */
@property(nonatomic, copy, nullable) NSString *detail;

/**
 *  [Output only] The time the operation completed, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *endTime;

/** The server-assigned ID for the operation. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The operation type.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_Operation_OperationType_AutoRepairNodes Automatic
 *        node pool repair. (Value: "AUTO_REPAIR_NODES")
 *    @arg @c kGTLRContainer_Operation_OperationType_AutoUpgradeNodes Automatic
 *        node upgrade. (Value: "AUTO_UPGRADE_NODES")
 *    @arg @c kGTLRContainer_Operation_OperationType_CreateCluster Cluster
 *        create. (Value: "CREATE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_CreateNodePool Node pool
 *        create. (Value: "CREATE_NODE_POOL")
 *    @arg @c kGTLRContainer_Operation_OperationType_DeleteCluster Cluster
 *        delete. (Value: "DELETE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_DeleteNodePool Node pool
 *        delete. (Value: "DELETE_NODE_POOL")
 *    @arg @c kGTLRContainer_Operation_OperationType_RepairCluster Cluster
 *        repair. (Value: "REPAIR_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetLabels Set labels.
 *        (Value: "SET_LABELS")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetMaintenancePolicy Set
 *        the maintenance policy. (Value: "SET_MAINTENANCE_POLICY")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetMasterAuth Set/generate
 *        master auth materials (Value: "SET_MASTER_AUTH")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetNetworkPolicy Updates
 *        network policy for a cluster. (Value: "SET_NETWORK_POLICY")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetNodePoolManagement Set
 *        node pool management. (Value: "SET_NODE_POOL_MANAGEMENT")
 *    @arg @c kGTLRContainer_Operation_OperationType_SetNodePoolSize Set node
 *        pool size. (Value: "SET_NODE_POOL_SIZE")
 *    @arg @c kGTLRContainer_Operation_OperationType_TypeUnspecified Not set.
 *        (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRContainer_Operation_OperationType_UpdateCluster Cluster
 *        update. (Value: "UPDATE_CLUSTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_UpgradeMaster A master
 *        upgrade. (Value: "UPGRADE_MASTER")
 *    @arg @c kGTLRContainer_Operation_OperationType_UpgradeNodes A node
 *        upgrade. (Value: "UPGRADE_NODES")
 */
@property(nonatomic, copy, nullable) NSString *operationType;

/** Server-defined URL for the resource. */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  [Output only] The time the operation started, in
 *  [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
@property(nonatomic, copy, nullable) NSString *startTime;

/**
 *  The current status of the operation.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_Operation_Status_Aborting The operation is
 *        aborting. (Value: "ABORTING")
 *    @arg @c kGTLRContainer_Operation_Status_Done The operation is done, either
 *        cancelled or completed. (Value: "DONE")
 *    @arg @c kGTLRContainer_Operation_Status_Pending The operation has been
 *        created. (Value: "PENDING")
 *    @arg @c kGTLRContainer_Operation_Status_Running The operation is currently
 *        running. (Value: "RUNNING")
 *    @arg @c kGTLRContainer_Operation_Status_StatusUnspecified Not set. (Value:
 *        "STATUS_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *status;

/** If an error has occurred, a textual description of the error. */
@property(nonatomic, copy, nullable) NSString *statusMessage;

/** Server-defined URL for the target of the operation. */
@property(nonatomic, copy, nullable) NSString *targetLink;

/**
 *  The name of the Google Compute Engine
 *  [zone](/compute/docs/zones#available) in which the operation
 *  is taking place.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
 *  NodePool upgrade. This will be an no-op if the last upgrade successfully
 *  completed.
 */
@interface GTLRContainer_RollbackNodePoolUpgradeRequest : GTLRObject
@end


/**
 *  Kubernetes Engine service configuration.
 */
@interface GTLRContainer_ServerConfig : GTLRObject

/** Version of Kubernetes the service deploys by default. */
@property(nonatomic, copy, nullable) NSString *defaultClusterVersion;

/** Default image type. */
@property(nonatomic, copy, nullable) NSString *defaultImageType;

/** List of valid image types. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validImageTypes;

/** List of valid master versions. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validMasterVersions;

/** List of valid node upgrade target versions. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *validNodeVersions;

@end


/**
 *  SetAddonsConfigRequest sets the addons associated with the cluster.
 */
@interface GTLRContainer_SetAddonsConfigRequest : GTLRObject

/**
 *  The desired configurations for the various addons available to run in the
 *  cluster.
 */
@property(nonatomic, strong, nullable) GTLRContainer_AddonsConfig *addonsConfig;

@end


/**
 *  SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
 *  Engine cluster, which will in turn set them for Google Compute Engine
 *  resources used by that cluster
 */
@interface GTLRContainer_SetLabelsRequest : GTLRObject

/**
 *  The fingerprint of the previous set of labels for this resource,
 *  used to detect conflicts. The fingerprint is initially generated by
 *  Kubernetes Engine and changes after every request to modify or update
 *  labels. You must always provide an up-to-date fingerprint hash when
 *  updating or changing labels. Make a <code>get()</code> request to the
 *  resource to get the latest fingerprint.
 */
@property(nonatomic, copy, nullable) NSString *labelFingerprint;

/** The labels to set for that cluster. */
@property(nonatomic, strong, nullable) GTLRContainer_SetLabelsRequest_ResourceLabels *resourceLabels;

@end


/**
 *  The labels to set for that cluster.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRContainer_SetLabelsRequest_ResourceLabels : GTLRObject
@end


/**
 *  SetLegacyAbacRequest enables or disables the ABAC authorization mechanism
 *  for
 *  a cluster.
 */
@interface GTLRContainer_SetLegacyAbacRequest : GTLRObject

/**
 *  Whether ABAC authorization will be enabled in the cluster.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

@end


/**
 *  SetLocationsRequest sets the locations of the cluster.
 */
@interface GTLRContainer_SetLocationsRequest : GTLRObject

/**
 *  The desired list of Google Compute Engine
 *  [locations](/compute/docs/zones#available) in which the cluster's nodes
 *  should be located. Changing the locations a cluster is in will result
 *  in nodes being either created or removed from the cluster, depending on
 *  whether locations are being added or removed.
 *  This list must always include the cluster's primary zone.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *locations;

@end


/**
 *  SetLoggingServiceRequest sets the logging service of a cluster.
 */
@interface GTLRContainer_SetLoggingServiceRequest : GTLRObject

/**
 *  The logging service the cluster should use to write metrics.
 *  Currently available options:
 *  * "logging.googleapis.com" - the Google Cloud Logging service
 *  * "none" - no metrics will be exported from the cluster
 */
@property(nonatomic, copy, nullable) NSString *loggingService;

@end


/**
 *  SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
 */
@interface GTLRContainer_SetMaintenancePolicyRequest : GTLRObject

/**
 *  The maintenance policy to be set for the cluster. An empty field
 *  clears the existing maintenance policy.
 */
@property(nonatomic, strong, nullable) GTLRContainer_MaintenancePolicy *maintenancePolicy;

@end


/**
 *  SetMasterAuthRequest updates the admin password of a cluster.
 */
@interface GTLRContainer_SetMasterAuthRequest : GTLRObject

/**
 *  The exact form of action to be taken on the master auth.
 *
 *  Likely values:
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_GeneratePassword
 *        Generate a new password and set it to that. (Value:
 *        "GENERATE_PASSWORD")
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_SetPassword Set the
 *        password to a user generated value. (Value: "SET_PASSWORD")
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_SetUsername Set the
 *        username. If an empty username is provided, basic authentication
 *        is disabled for the cluster. If a non-empty username is provided,
 *        basic
 *        authentication is enabled, with either a provided password or a
 *        generated
 *        one. (Value: "SET_USERNAME")
 *    @arg @c kGTLRContainer_SetMasterAuthRequest_Action_Unknown Operation is
 *        unknown and will error out. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *action;

/** A description of the update. */
@property(nonatomic, strong, nullable) GTLRContainer_MasterAuth *update;

@end


/**
 *  SetMonitoringServiceRequest sets the monitoring service of a cluster.
 */
@interface GTLRContainer_SetMonitoringServiceRequest : GTLRObject

/**
 *  The monitoring service the cluster should use to write metrics.
 *  Currently available options:
 *  * "monitoring.googleapis.com" - the Google Cloud Monitoring service
 *  * "none" - no metrics will be exported from the cluster
 */
@property(nonatomic, copy, nullable) NSString *monitoringService;

@end


/**
 *  SetNetworkPolicyRequest enables/disables network policy for a cluster.
 */
@interface GTLRContainer_SetNetworkPolicyRequest : GTLRObject

/** Configuration options for the NetworkPolicy feature. */
@property(nonatomic, strong, nullable) GTLRContainer_NetworkPolicy *networkPolicy;

@end


/**
 *  SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
 */
@interface GTLRContainer_SetNodePoolAutoscalingRequest : GTLRObject

/** Autoscaling configuration for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodePoolAutoscaling *autoscaling;

@end


/**
 *  SetNodePoolManagementRequest sets the node management properties of a node
 *  pool.
 */
@interface GTLRContainer_SetNodePoolManagementRequest : GTLRObject

/** NodeManagement configuration for the node pool. */
@property(nonatomic, strong, nullable) GTLRContainer_NodeManagement *management;

@end


/**
 *  SetNodePoolSizeRequest sets the size a node
 *  pool.
 */
@interface GTLRContainer_SetNodePoolSizeRequest : GTLRObject

/**
 *  The desired node count for the pool.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

@end


/**
 *  StartIPRotationRequest creates a new IP for the cluster and then performs
 *  a node upgrade on each node pool to point to the new IP.
 */
@interface GTLRContainer_StartIPRotationRequest : GTLRObject
@end


/**
 *  UpdateClusterRequest updates the settings of a cluster.
 */
@interface GTLRContainer_UpdateClusterRequest : GTLRObject

/** A description of the update. */
@property(nonatomic, strong, nullable) GTLRContainer_ClusterUpdate *update;

@end


/**
 *  UpdateMasterRequest updates the master of the cluster.
 */
@interface GTLRContainer_UpdateMasterRequest : GTLRObject

/**
 *  The Kubernetes version to change the master to. Use "-" to have the server
 *  automatically select the default version.
 */
@property(nonatomic, copy, nullable) NSString *masterVersion;

@end


/**
 *  UpdateNodePoolRequests update a node pool's image and/or version.
 */
@interface GTLRContainer_UpdateNodePoolRequest : GTLRObject

/** The desired image type for the node pool. */
@property(nonatomic, copy, nullable) NSString *imageType;

/**
 *  The Kubernetes version to change the nodes to (typically an
 *  upgrade). Use `-` to upgrade to the latest version supported by
 *  the server.
 */
@property(nonatomic, copy, nullable) NSString *nodeVersion;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
