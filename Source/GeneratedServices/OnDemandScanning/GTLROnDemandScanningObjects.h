// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   On-Demand Scanning API (ondemandscanning/v1)
// Description:
//   A service to scan container images for vulnerabilities.
// Documentation:
//   https://cloud.google.com/container-analysis/docs/on-demand-scanning/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLROnDemandScanning_AliasContext;
@class GTLROnDemandScanning_Artifact;
@class GTLROnDemandScanning_AttestationOccurrence;
@class GTLROnDemandScanning_BuildOccurrence;
@class GTLROnDemandScanning_BuildProvenance;
@class GTLROnDemandScanning_BuildProvenance_BuildOptions;
@class GTLROnDemandScanning_Category;
@class GTLROnDemandScanning_CloudRepoSourceContext;
@class GTLROnDemandScanning_Command;
@class GTLROnDemandScanning_DeploymentOccurrence;
@class GTLROnDemandScanning_DiscoveryOccurrence;
@class GTLROnDemandScanning_FileHashes;
@class GTLROnDemandScanning_Fingerprint;
@class GTLROnDemandScanning_GerritSourceContext;
@class GTLROnDemandScanning_GitSourceContext;
@class GTLROnDemandScanning_Hash;
@class GTLROnDemandScanning_Identity;
@class GTLROnDemandScanning_ImageOccurrence;
@class GTLROnDemandScanning_Jwt;
@class GTLROnDemandScanning_Layer;
@class GTLROnDemandScanning_Location;
@class GTLROnDemandScanning_Occurrence;
@class GTLROnDemandScanning_Operation;
@class GTLROnDemandScanning_Operation_Metadata;
@class GTLROnDemandScanning_Operation_Response;
@class GTLROnDemandScanning_PackageData;
@class GTLROnDemandScanning_PackageIssue;
@class GTLROnDemandScanning_PackageOccurrence;
@class GTLROnDemandScanning_ProjectRepoId;
@class GTLROnDemandScanning_RelatedUrl;
@class GTLROnDemandScanning_RepoId;
@class GTLROnDemandScanning_Signature;
@class GTLROnDemandScanning_Source;
@class GTLROnDemandScanning_Source_FileHashes;
@class GTLROnDemandScanning_SourceContext;
@class GTLROnDemandScanning_SourceContext_Labels;
@class GTLROnDemandScanning_Status;
@class GTLROnDemandScanning_Status_Details_Item;
@class GTLROnDemandScanning_UpgradeDistribution;
@class GTLROnDemandScanning_UpgradeOccurrence;
@class GTLROnDemandScanning_Version;
@class GTLROnDemandScanning_VulnerabilityOccurrence;
@class GTLROnDemandScanning_WindowsUpdate;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_AliasContext.kind

/**
 *  Git tag.
 *
 *  Value: "FIXED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_Fixed;
/**
 *  Unknown.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_KindUnspecified;
/**
 *  Git branch.
 *
 *  Value: "MOVABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_Movable;
/**
 *  Used to specify non-standard aliases. For example, if a Git repo has a ref
 *  named "refs/foo/bar".
 *
 *  Value: "OTHER"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_AliasContext_Kind_Other;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_DeploymentOccurrence.platform

/**
 *  Custom user-defined platform.
 *
 *  Value: "CUSTOM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_Custom;
/**
 *  Google App Engine: Flexible Environment.
 *
 *  Value: "FLEX"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_Flex;
/**
 *  Google Container Engine.
 *
 *  Value: "GKE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_Gke;
/**
 *  Unknown.
 *
 *  Value: "PLATFORM_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DeploymentOccurrence_Platform_PlatformUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_DiscoveryOccurrence.analysisStatus

/**
 *  Unknown.
 *
 *  Value: "ANALYSIS_STATUS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_AnalysisStatusUnspecified;
/**
 *  Analysis has finished unsuccessfully, the analysis itself is in a bad state.
 *
 *  Value: "FINISHED_FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedFailed;
/**
 *  Analysis has finished successfully.
 *
 *  Value: "FINISHED_SUCCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedSuccess;
/**
 *  The resource is known not to be supported
 *
 *  Value: "FINISHED_UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedUnsupported;
/**
 *  Resource is known but no action has been taken yet.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Pending;
/**
 *  Resource is being analyzed.
 *
 *  Value: "SCANNING"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Scanning;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_DiscoveryOccurrence.continuousAnalysis

/**
 *  The resource is continuously analyzed.
 *
 *  Value: "ACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Active;
/**
 *  Unknown.
 *
 *  Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_ContinuousAnalysisUnspecified;
/**
 *  The resource is ignored for continuous analysis.
 *
 *  Value: "INACTIVE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Inactive;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_Occurrence.kind

/**
 *  This represents a logical "role" that can attest to artifacts.
 *
 *  Value: "ATTESTATION"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Attestation;
/**
 *  The note and occurrence assert build provenance.
 *
 *  Value: "BUILD"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Build;
/**
 *  The note and occurrence track deployment events.
 *
 *  Value: "DEPLOYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Deployment;
/**
 *  The note and occurrence track the initial discovery status of a resource.
 *
 *  Value: "DISCOVERY"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Discovery;
/**
 *  This represents an image basis relationship.
 *
 *  Value: "IMAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Image;
/**
 *  Default value. This value is unused.
 *
 *  Value: "NOTE_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_NoteKindUnspecified;
/**
 *  This represents a package installed via a package manager.
 *
 *  Value: "PACKAGE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Package;
/**
 *  This represents an available package upgrade.
 *
 *  Value: "UPGRADE"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Upgrade;
/**
 *  The note and occurrence represent a package vulnerability.
 *
 *  Value: "VULNERABILITY"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Occurrence_Kind_Vulnerability;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_Version.kind

/**
 *  A special version representing positive infinity.
 *
 *  Value: "MAXIMUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_Maximum;
/**
 *  A special version representing negative infinity.
 *
 *  Value: "MINIMUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_Minimum;
/**
 *  A standard package version.
 *
 *  Value: "NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_Normal;
/**
 *  Unknown.
 *
 *  Value: "VERSION_KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_Version_Kind_VersionKindUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_VulnerabilityOccurrence.effectiveSeverity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_SeverityUnspecified;

// ----------------------------------------------------------------------------
// GTLROnDemandScanning_VulnerabilityOccurrence.severity

/**
 *  Critical severity.
 *
 *  Value: "CRITICAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Critical;
/**
 *  High severity.
 *
 *  Value: "HIGH"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_High;
/**
 *  Low severity.
 *
 *  Value: "LOW"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Low;
/**
 *  Medium severity.
 *
 *  Value: "MEDIUM"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Medium;
/**
 *  Minimal severity.
 *
 *  Value: "MINIMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Minimal;
/**
 *  Unknown.
 *
 *  Value: "SEVERITY_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_SeverityUnspecified;

/**
 *  An alias to a repo revision.
 */
@interface GTLROnDemandScanning_AliasContext : GTLRObject

/**
 *  The alias kind.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_Fixed Git tag. (Value:
 *        "FIXED")
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_KindUnspecified Unknown.
 *        (Value: "KIND_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_Movable Git branch.
 *        (Value: "MOVABLE")
 *    @arg @c kGTLROnDemandScanning_AliasContext_Kind_Other Used to specify
 *        non-standard aliases. For example, if a Git repo has a ref named
 *        "refs/foo/bar". (Value: "OTHER")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The alias name. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  AnalyzePackagesMetadata contains metadata for an active scan of a container
 *  image.
 */
@interface GTLROnDemandScanning_AnalyzePackagesMetadata : GTLRObject

/** When the scan was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The resource URI of the container image being scanned. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  AnalyzePackagesMetadata contains metadata for an active scan of a container
 *  image.
 */
@interface GTLROnDemandScanning_AnalyzePackagesMetadataV1 : GTLRObject

/** When the scan was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The resource URI of the container image being scanned. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  AnalyzePackagesRequest is the request to analyze a list of packages and
 *  create Vulnerability Occurrences for it.
 */
@interface GTLROnDemandScanning_AnalyzePackagesRequestV1 : GTLRObject

/** The packages to analyze. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_PackageData *> *packages;

/** Required. The resource URI of the container image being scanned. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  AnalyzePackagesResponse contains the information necessary to find results
 *  for the given scan.
 */
@interface GTLROnDemandScanning_AnalyzePackagesResponse : GTLRObject

/** The name of the scan resource created by this successful scan. */
@property(nonatomic, copy, nullable) NSString *scan;

@end


/**
 *  AnalyzePackagesResponse contains the information necessary to find results
 *  for the given scan.
 */
@interface GTLROnDemandScanning_AnalyzePackagesResponseV1 : GTLRObject

/** The name of the scan resource created by this successful scan. */
@property(nonatomic, copy, nullable) NSString *scan;

@end


/**
 *  Artifact describes a build product.
 */
@interface GTLROnDemandScanning_Artifact : GTLRObject

/**
 *  Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
 *  container.
 */
@property(nonatomic, copy, nullable) NSString *checksum;

/**
 *  Artifact ID, if any; for container images, this will be a URL by digest like
 *  `gcr.io/projectID/imagename\@sha256:123456`.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Related artifact names. This may be the path to a binary or jar file, or in
 *  the case of a container build, the name used to push the container image to
 *  Google Container Registry, as presented to `docker push`. Note that a single
 *  Artifact ID can have multiple names, for example if two tags are applied to
 *  one image.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *names;

@end


/**
 *  Occurrence that represents a single "attestation". The authenticity of an
 *  attestation can be verified using the attached signature. If the verifier
 *  trusts the public key of the signer, then verifying the signature is
 *  sufficient to establish trust. In this circumstance, the authority to which
 *  this attestation is attached is primarily useful for lookup (how to find
 *  this attestation if you already know the authority and artifact to be
 *  verified) and intent (for which authority this attestation was intended to
 *  sign.
 */
@interface GTLROnDemandScanning_AttestationOccurrence : GTLRObject

/**
 *  One or more JWTs encoding a self-contained attestation. Each JWT encodes the
 *  payload that it verifies within the JWT itself. Verifier implementation
 *  SHOULD ignore the `serialized_payload` field when verifying these JWTs. If
 *  only JWTs are present on this AttestationOccurrence, then the
 *  `serialized_payload` SHOULD be left empty. Each JWT SHOULD encode a claim
 *  specific to the `resource_uri` of this Occurrence, but this is not validated
 *  by Grafeas metadata API implementations. The JWT itself is opaque to
 *  Grafeas.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Jwt *> *jwts;

/**
 *  Required. The serialized payload that is verified by one or more
 *  `signatures`.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *serializedPayload;

/**
 *  One or more signatures over `serialized_payload`. Verifier implementations
 *  should consider this attestation message verified if at least one
 *  `signature` verifies `serialized_payload`. See `Signature` in common.proto
 *  for more details on signature structure and verification.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Signature *> *signatures;

@end


/**
 *  Details of a build occurrence.
 */
@interface GTLROnDemandScanning_BuildOccurrence : GTLRObject

/** Required. The actual provenance for the build. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildProvenance *provenance;

/**
 *  Serialized JSON representation of the provenance, used in generating the
 *  build signature in the corresponding build note. After verifying the
 *  signature, `provenance_bytes` can be unmarshalled and compared to the
 *  provenance to confirm that it is unchanged. A base64-encoded string
 *  representation of the provenance bytes is used for the signature in order to
 *  interoperate with openssl which expects this format for signature
 *  verification. The serialized form is captured both to avoid ambiguity in how
 *  the provenance is marshalled to json as well to prevent incompatibilities
 *  with future changes.
 */
@property(nonatomic, copy, nullable) NSString *provenanceBytes;

@end


/**
 *  Provenance of a build. Contains all information needed to verify the full
 *  details about the build from source to completion.
 */
@interface GTLROnDemandScanning_BuildProvenance : GTLRObject

/** Version string of the builder at the time this build was executed. */
@property(nonatomic, copy, nullable) NSString *builderVersion;

/**
 *  Special options applied to this build. This is a catch-all field where build
 *  providers can enter any desired additional details.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildProvenance_BuildOptions *buildOptions;

/** Output of the build. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Artifact *> *builtArtifacts;

/** Commands requested by the build. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Command *> *commands;

/** Time at which the build was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  E-mail address of the user who initiated this build. Note that this was the
 *  user's e-mail address at the time the build was initiated; this address may
 *  not represent the same end-user for all time.
 */
@property(nonatomic, copy, nullable) NSString *creator;

/** Time at which execution of the build was finished. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Required. Unique identifier of the build.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** URI where any logs for this provenance were written. */
@property(nonatomic, copy, nullable) NSString *logsUri;

/** ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Details of the Source input to the build. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Source *sourceProvenance;

/** Time at which execution of the build was started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Trigger identifier if the build was triggered automatically; empty if not.
 */
@property(nonatomic, copy, nullable) NSString *triggerId;

@end


/**
 *  Special options applied to this build. This is a catch-all field where build
 *  providers can enter any desired additional details.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_BuildProvenance_BuildOptions : GTLRObject
@end


/**
 *  The category to which the update belongs.
 */
@interface GTLROnDemandScanning_Category : GTLRObject

/** The identifier of the category. */
@property(nonatomic, copy, nullable) NSString *categoryId;

/** The localized name of the category. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A CloudRepoSourceContext denotes a particular revision in a Google Cloud
 *  Source Repo.
 */
@interface GTLROnDemandScanning_CloudRepoSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_AliasContext *aliasContext;

/** The ID of the repo. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_RepoId *repoId;

/** A revision ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  Command describes a step performed as part of the build pipeline.
 */
@interface GTLROnDemandScanning_Command : GTLRObject

/** Command-line arguments used when executing this command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

/**
 *  Working directory (relative to project source root) used when running this
 *  command.
 */
@property(nonatomic, copy, nullable) NSString *dir;

/** Environment variables set before running this command. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *env;

/**
 *  Optional unique identifier for this command, used in wait_for to reference
 *  this command as a dependency.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Required. Name of the command, as presented on the command line, or if the
 *  command is packaged as a Docker container, as presented to `docker pull`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The ID(s) of the command(s) that this command depends on. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *waitFor;

@end


/**
 *  The period during which some deployable was active in a runtime.
 */
@interface GTLROnDemandScanning_DeploymentOccurrence : GTLRObject

/** Address of the runtime element hosting this deployment. */
@property(nonatomic, copy, nullable) NSString *address;

/** Configuration used to create this deployment. */
@property(nonatomic, copy, nullable) NSString *config;

/** Required. Beginning of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *deployTime;

/**
 *  Platform hosting this deployment.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_Custom Custom
 *        user-defined platform. (Value: "CUSTOM")
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_Flex Google
 *        App Engine: Flexible Environment. (Value: "FLEX")
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_Gke Google
 *        Container Engine. (Value: "GKE")
 *    @arg @c kGTLROnDemandScanning_DeploymentOccurrence_Platform_PlatformUnspecified
 *        Unknown. (Value: "PLATFORM_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *platform;

/**
 *  Output only. Resource URI for the artifact being deployed taken from the
 *  deployable field with the same name.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resourceUri;

/** End of the lifetime of this deployment. */
@property(nonatomic, strong, nullable) GTLRDateTime *undeployTime;

/** Identity of the user that triggered this deployment. */
@property(nonatomic, copy, nullable) NSString *userEmail;

@end


/**
 *  Provides information about the analysis status of a discovered resource.
 */
@interface GTLROnDemandScanning_DiscoveryOccurrence : GTLRObject

/**
 *  The status of discovery for the resource.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_AnalysisStatusUnspecified
 *        Unknown. (Value: "ANALYSIS_STATUS_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedFailed
 *        Analysis has finished unsuccessfully, the analysis itself is in a bad
 *        state. (Value: "FINISHED_FAILED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedSuccess
 *        Analysis has finished successfully. (Value: "FINISHED_SUCCESS")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_FinishedUnsupported
 *        The resource is known not to be supported (Value:
 *        "FINISHED_UNSUPPORTED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Pending
 *        Resource is known but no action has been taken yet. (Value: "PENDING")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_AnalysisStatus_Scanning
 *        Resource is being analyzed. (Value: "SCANNING")
 */
@property(nonatomic, copy, nullable) NSString *analysisStatus;

/**
 *  When an error is encountered this will contain a LocalizedMessage under
 *  details to show to the user. The LocalizedMessage is output only and
 *  populated by the API.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Status *analysisStatusError;

/**
 *  Whether the resource is continuously analyzed.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Active
 *        The resource is continuously analyzed. (Value: "ACTIVE")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_ContinuousAnalysisUnspecified
 *        Unknown. (Value: "CONTINUOUS_ANALYSIS_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_DiscoveryOccurrence_ContinuousAnalysis_Inactive
 *        The resource is ignored for continuous analysis. (Value: "INACTIVE")
 */
@property(nonatomic, copy, nullable) NSString *continuousAnalysis;

/** The CPE of the resource being scanned. */
@property(nonatomic, copy, nullable) NSString *cpe;

/** The last time this resource was scanned. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastScanTime;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
 *  representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLROnDemandScanning_Empty : GTLRObject
@end


/**
 *  Container message for hashes of byte content of files, used in source
 *  messages to verify integrity of source input to the build.
 */
@interface GTLROnDemandScanning_FileHashes : GTLRObject

/** Required. Collection of file hashes. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Hash *> *fileHash;

@end


/**
 *  A set of properties that uniquely identify a given Docker image.
 */
@interface GTLROnDemandScanning_Fingerprint : GTLRObject

/**
 *  Required. The layer ID of the final layer in the Docker image's v1
 *  representation.
 */
@property(nonatomic, copy, nullable) NSString *v1Name;

/** Required. The ordered list of v2 blobs that represent a given image. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *v2Blob;

/**
 *  Output only. The name of the image's v2 blobs computed via: [bottom] :=
 *  v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of
 *  the final blob is kept.
 */
@property(nonatomic, copy, nullable) NSString *v2Name;

@end


/**
 *  A SourceContext referring to a Gerrit project.
 */
@interface GTLROnDemandScanning_GerritSourceContext : GTLRObject

/** An alias, which may be a branch or tag. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_AliasContext *aliasContext;

/**
 *  The full project name within the host. Projects may be nested, so
 *  "project/subproject" is a valid project name. The "repo name" is the
 *  hostURI/project.
 */
@property(nonatomic, copy, nullable) NSString *gerritProject;

/** The URI of a running Gerrit instance. */
@property(nonatomic, copy, nullable) NSString *hostUri;

/** A revision (commit) ID. */
@property(nonatomic, copy, nullable) NSString *revisionId;

@end


/**
 *  A GitSourceContext denotes a particular revision in a third party Git
 *  repository (e.g., GitHub).
 */
@interface GTLROnDemandScanning_GitSourceContext : GTLRObject

/** Git commit hash. */
@property(nonatomic, copy, nullable) NSString *revisionId;

/** Git repository URL. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Container message for hash values.
 */
@interface GTLROnDemandScanning_Hash : GTLRObject

/** Required. The type of hash that was performed, e.g. "SHA-256". */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Required. The hash value.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  The unique identifier of the update.
 */
@interface GTLROnDemandScanning_Identity : GTLRObject

/**
 *  The revision number of the update.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *revision;

/** The revision independent identifier of the update. */
@property(nonatomic, copy, nullable) NSString *updateId;

@end


/**
 *  Details of the derived image portion of the DockerImage relationship. This
 *  image would be produced from a Dockerfile with FROM .
 */
@interface GTLROnDemandScanning_ImageOccurrence : GTLRObject

/**
 *  Output only. This contains the base image URL for the derived image
 *  occurrence.
 */
@property(nonatomic, copy, nullable) NSString *baseResourceUrl;

/**
 *  Output only. The number of layers by which this image differs from the
 *  associated image basis.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *distance;

/** Required. The fingerprint of the derived image. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Fingerprint *fingerprint;

/**
 *  This contains layer-specific metadata, if populated it has length "distance"
 *  and is ordered with [distance] being the layer immediately following the
 *  base image and [1] being the final layer.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Layer *> *layerInfo;

@end


/**
 *  GTLROnDemandScanning_Jwt
 */
@interface GTLROnDemandScanning_Jwt : GTLRObject

/**
 *  The compact encoding of a JWS, which is always three base64 encoded strings
 *  joined by periods. For details, see:
 *  https://tools.ietf.org/html/rfc7515.html#section-3.1
 */
@property(nonatomic, copy, nullable) NSString *compactJwt;

@end


/**
 *  Layer holds metadata specific to a layer of a Docker image.
 */
@interface GTLROnDemandScanning_Layer : GTLRObject

/** The recovered arguments to the Dockerfile directive. */
@property(nonatomic, copy, nullable) NSString *arguments;

/**
 *  Required. The recovered Dockerfile directive used to construct this layer.
 *  See https://docs.docker.com/engine/reference/builder/ for more information.
 */
@property(nonatomic, copy, nullable) NSString *directive;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLROnDemandScanning_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Operation *> *operations;

@end


/**
 *  ListVulnerabilitiesResponse contains a single page of vulnerabilities
 *  resulting from a scan.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "occurrences" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLROnDemandScanning_ListVulnerabilitiesResponseV1 : GTLRCollectionObject

/**
 *  A page token that can be used in a subsequent call to ListVulnerabilities to
 *  continue retrieving results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of Vulnerability Occurrences resulting from a scan.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Occurrence *> *occurrences;

@end


/**
 *  An occurrence of a particular package installation found within a system's
 *  filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
 */
@interface GTLROnDemandScanning_Location : GTLRObject

/**
 *  Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
 *  denoting the package manager version distributing a package.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The path from which we gathered that this package/version is installed. */
@property(nonatomic, copy, nullable) NSString *path;

/** The version installed at this location. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *version;

@end


/**
 *  An instance of an analysis type that has been found on a resource.
 */
@interface GTLROnDemandScanning_Occurrence : GTLRObject

/** Describes an attestation of an artifact. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_AttestationOccurrence *attestation;

/** Describes a verifiable build. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_BuildOccurrence *build;

/** Output only. The time this occurrence was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Describes the deployment of an artifact on a runtime. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_DeploymentOccurrence *deployment;

/** Describes when a resource was discovered. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_DiscoveryOccurrence *discovery;

/**
 *  Describes how this resource derives from the basis in the associated note.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ImageOccurrence *image;

/**
 *  Output only. This explicitly denotes which of the occurrence details are
 *  specified. This field can be used as a filter in list requests.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Attestation This represents
 *        a logical "role" that can attest to artifacts. (Value: "ATTESTATION")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Build The note and
 *        occurrence assert build provenance. (Value: "BUILD")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Deployment The note and
 *        occurrence track deployment events. (Value: "DEPLOYMENT")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Discovery The note and
 *        occurrence track the initial discovery status of a resource. (Value:
 *        "DISCOVERY")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Image This represents an
 *        image basis relationship. (Value: "IMAGE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_NoteKindUnspecified Default
 *        value. This value is unused. (Value: "NOTE_KIND_UNSPECIFIED")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Package This represents a
 *        package installed via a package manager. (Value: "PACKAGE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Upgrade This represents an
 *        available package upgrade. (Value: "UPGRADE")
 *    @arg @c kGTLROnDemandScanning_Occurrence_Kind_Vulnerability The note and
 *        occurrence represent a package vulnerability. (Value: "VULNERABILITY")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Output only. The name of the occurrence in the form of
 *  `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Immutable. The analysis note associated with this occurrence, in
 *  the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be used
 *  as a filter in list requests.
 */
@property(nonatomic, copy, nullable) NSString *noteName;

/** Describes the installation of a package on the linked resource. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_PackageOccurrence *package;

/** A description of actions that can be taken to remedy the note. */
@property(nonatomic, copy, nullable) NSString *remediation;

/**
 *  Required. Immutable. A URI that represents the resource for which the
 *  occurrence applies. For example,
 *  `https://gcr.io/project/image\@sha256:123abc` for a Docker image.
 */
@property(nonatomic, copy, nullable) NSString *resourceUri;

/** Output only. The time this occurrence was last updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

/** Describes an available package upgrade on the linked resource. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_UpgradeOccurrence *upgrade;

/** Describes a security vulnerability. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_VulnerabilityOccurrence *vulnerability;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLROnDemandScanning_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Operation_Response : GTLRObject
@end


/**
 *  GTLROnDemandScanning_PackageData
 */
@interface GTLROnDemandScanning_PackageData : GTLRObject

/**
 *  The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in which
 *  the vulnerability may manifest. Examples include distro or storage location
 *  for vulnerable jar.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/**
 *  The OS affected by a vulnerability This field is deprecated and the
 *  information is in cpe_uri
 */
@property(nonatomic, copy, nullable) NSString *os;

/**
 *  The version of the OS This field is deprecated and the information is in
 *  cpe_uri
 */
@property(nonatomic, copy, nullable) NSString *osVersion;

/** The package being analysed for vulnerabilities */
@property(nonatomic, copy, nullable) NSString *package;

/** The version of the package being analysed */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  A detail for a distro and package this vulnerability occurrence was found in
 *  and its associated fix (if one is available).
 */
@interface GTLROnDemandScanning_PackageIssue : GTLRObject

/**
 *  Required. The [CPE URI](https://cpe.mitre.org/specification/) this
 *  vulnerability was found in.
 */
@property(nonatomic, copy, nullable) NSString *affectedCpeUri;

/** Required. The package this vulnerability was found in. */
@property(nonatomic, copy, nullable) NSString *affectedPackage;

/**
 *  Required. The version of the package that is installed on the resource
 *  affected by this vulnerability.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *affectedVersion;

/**
 *  Output only. Whether a fix is available for this package.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fixAvailable;

/**
 *  The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability was
 *  fixed in. It is possible for this to be different from the affected_cpe_uri.
 */
@property(nonatomic, copy, nullable) NSString *fixedCpeUri;

/**
 *  The package this vulnerability was fixed in. It is possible for this to be
 *  different from the affected_package.
 */
@property(nonatomic, copy, nullable) NSString *fixedPackage;

/**
 *  Required. The version of the package this vulnerability was fixed in.
 *  Setting this to VersionKind.MAXIMUM means no fix is yet available.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *fixedVersion;

@end


/**
 *  Details on how a particular software package was installed on a system.
 */
@interface GTLROnDemandScanning_PackageOccurrence : GTLRObject

/**
 *  Required. All of the places within the filesystem versions of this package
 *  have been found.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Location *> *location;

/** Output only. The name of the installed package. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Selects a repo using a Google Cloud Platform project ID (e.g.,
 *  winged-cargo-31) and a repo name within that project.
 */
@interface GTLROnDemandScanning_ProjectRepoId : GTLRObject

/** The ID of the project. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The name of the repo. Leave empty for the default repo. */
@property(nonatomic, copy, nullable) NSString *repoName;

@end


/**
 *  Metadata for any related URL information.
 */
@interface GTLROnDemandScanning_RelatedUrl : GTLRObject

/** Label to describe usage of the URL. */
@property(nonatomic, copy, nullable) NSString *label;

/** Specific URL associated with the resource. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  A unique identifier for a Cloud Repo.
 */
@interface GTLROnDemandScanning_RepoId : GTLRObject

/** A combination of a project ID and a repo name. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_ProjectRepoId *projectRepoId;

/** A server-assigned, globally unique identifier. */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  Verifiers (e.g. Kritis implementations) MUST verify signatures with respect
 *  to the trust anchors defined in policy (e.g. a Kritis policy). Typically
 *  this means that the verifier has been configured with a map from
 *  `public_key_id` to public key material (and any required parameters, e.g.
 *  signing algorithm). In particular, verification implementations MUST NOT
 *  treat the signature `public_key_id` as anything more than a key lookup hint.
 *  The `public_key_id` DOES NOT validate or authenticate a public key; it only
 *  provides a mechanism for quickly selecting a public key ALREADY CONFIGURED
 *  on the verifier through a trusted channel. Verification implementations MUST
 *  reject signatures in any of the following circumstances: * The
 *  `public_key_id` is not recognized by the verifier. * The public key that
 *  `public_key_id` refers to does not verify the signature with respect to the
 *  payload. The `signature` contents SHOULD NOT be "attached" (where the
 *  payload is included with the serialized `signature` bytes). Verifiers MUST
 *  ignore any "attached" payload and only verify signatures with respect to
 *  explicitly provided payload (e.g. a `payload` field on the proto message
 *  that holds this Signature, or the canonical serialization of the proto
 *  message that holds this signature).
 */
@interface GTLROnDemandScanning_Signature : GTLRObject

/**
 *  The identifier for the public key that verifies this signature. * The
 *  `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986
 *  conformant URI. * When possible, the `public_key_id` SHOULD be an immutable
 *  reference, such as a cryptographic digest. Examples of valid
 *  `public_key_id`s: OpenPGP V4 public key fingerprint: *
 *  "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See
 *  https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
 *  details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of
 *  the DER serialization): *
 *  "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" *
 *  "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
 */
@property(nonatomic, copy, nullable) NSString *publicKeyId;

/**
 *  The content of the signature, an opaque bytestring. The payload that this
 *  signature verifies MUST be unambiguously provided with the Signature during
 *  verification. A wrapper message might provide the payload explicitly.
 *  Alternatively, a message might have a canonical serialization that can
 *  always be unambiguously computed to derive the payload.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *signature;

@end


/**
 *  Source describes the location of the source used for the build.
 */
@interface GTLROnDemandScanning_Source : GTLRObject

/**
 *  If provided, some of the source code used for the build may be found in
 *  these locations, in the case where the source repository had multiple
 *  remotes or submodules. This list will not include the context specified in
 *  the context field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_SourceContext *> *additionalContexts;

/**
 *  If provided, the input binary artifacts for the build came from this
 *  location.
 */
@property(nonatomic, copy, nullable) NSString *artifactStorageSourceUri;

/**
 *  If provided, the source code used for the build came from this location.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SourceContext *context;

/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build. The keys to this map are file
 *  paths used as build source and the values contain the hash values for those
 *  files. If the build source came in a single package such as a gzipped
 *  tarfile (.tar.gz), the FileHash will be for the single path to that file.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Source_FileHashes *fileHashes;

@end


/**
 *  Hash(es) of the build source, which can be used to verify that the original
 *  source integrity was maintained in the build. The keys to this map are file
 *  paths used as build source and the values contain the hash values for those
 *  files. If the build source came in a single package such as a gzipped
 *  tarfile (.tar.gz), the FileHash will be for the single path to that file.
 *
 *  @note This class is documented as having more properties of
 *        GTLROnDemandScanning_FileHashes. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Source_FileHashes : GTLRObject
@end


/**
 *  A SourceContext is a reference to a tree of files. A SourceContext together
 *  with a path point to a unique revision of a single file or directory.
 */
@interface GTLROnDemandScanning_SourceContext : GTLRObject

/** A SourceContext referring to a revision in a Google Cloud Source Repo. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_CloudRepoSourceContext *cloudRepo;

/** A SourceContext referring to a Gerrit project. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GerritSourceContext *gerrit;

/** A SourceContext referring to any third party Git repo (e.g., GitHub). */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_GitSourceContext *git;

/** Labels with user defined metadata. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_SourceContext_Labels *labels;

@end


/**
 *  Labels with user defined metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLROnDemandScanning_SourceContext_Labels : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLROnDemandScanning_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLROnDemandScanning_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLROnDemandScanning_Status_Details_Item : GTLRObject
@end


/**
 *  The Upgrade Distribution represents metadata about the Upgrade for each
 *  operating system (CPE). Some distributions have additional metadata around
 *  updates, classifying them into various categories and severities.
 */
@interface GTLROnDemandScanning_UpgradeDistribution : GTLRObject

/**
 *  The operating system classification of this Upgrade, as specified by the
 *  upstream operating system upgrade feed. For Windows the classification is
 *  one of the category_ids listed at
 *  https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803(v=vs.85)
 */
@property(nonatomic, copy, nullable) NSString *classification;

/**
 *  Required - The specific operating system this metadata applies to. See
 *  https://cpe.mitre.org/specification/.
 */
@property(nonatomic, copy, nullable) NSString *cpeUri;

/** The cve tied to this Upgrade. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *cve;

/** The severity as specified by the upstream operating system. */
@property(nonatomic, copy, nullable) NSString *severity;

@end


/**
 *  An Upgrade Occurrence represents that a specific resource_url could install
 *  a specific upgrade. This presence is supplied via local sources (i.e. it is
 *  present in the mirror and the running system has noticed its availability).
 *  For Windows, both distribution and windows_update contain information for
 *  the Windows update.
 */
@interface GTLROnDemandScanning_UpgradeOccurrence : GTLRObject

/**
 *  Metadata about the upgrade for available for the specific operating system
 *  for the resource_url. This allows efficient filtering, as well as making it
 *  easier to use the occurrence.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_UpgradeDistribution *distribution;

/** Required for non-Windows OS. The package this Upgrade is for. */
@property(nonatomic, copy, nullable) NSString *package;

/**
 *  Required for non-Windows OS. The version of the package in a machine + human
 *  readable form.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Version *parsedVersion;

/**
 *  Required for Windows OS. Represents the metadata about the Windows update.
 */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_WindowsUpdate *windowsUpdate;

@end


/**
 *  Version contains structured information about the version of a package.
 */
@interface GTLROnDemandScanning_Version : GTLRObject

/**
 *  Used to correct mistakes in the version numbering scheme.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *epoch;

/**
 *  Human readable version string. This string is of the form :- and is only set
 *  when kind is NORMAL.
 */
@property(nonatomic, copy, nullable) NSString *fullName;

/**
 *  Whether this version is specifying part of an inclusive range. Grafeas does
 *  not have the capability to specify version ranges; instead we have fields
 *  that specify start version and end versions. At times this is insufficient -
 *  we also need to specify whether the version is included in the range or is
 *  excluded from the range. This boolean is expected to be set to true when the
 *  version is included in a range.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inclusive;

/**
 *  Required. Distinguishes between sentinel MIN/MAX versions and normal
 *  versions.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_Version_Kind_Maximum A special version
 *        representing positive infinity. (Value: "MAXIMUM")
 *    @arg @c kGTLROnDemandScanning_Version_Kind_Minimum A special version
 *        representing negative infinity. (Value: "MINIMUM")
 *    @arg @c kGTLROnDemandScanning_Version_Kind_Normal A standard package
 *        version. (Value: "NORMAL")
 *    @arg @c kGTLROnDemandScanning_Version_Kind_VersionKindUnspecified Unknown.
 *        (Value: "VERSION_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Required only when version kind is NORMAL. The main part of the version
 *  name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The iteration of the package build from the above version. */
@property(nonatomic, copy, nullable) NSString *revision;

@end


/**
 *  An occurrence of a severity vulnerability on a resource.
 */
@interface GTLROnDemandScanning_VulnerabilityOccurrence : GTLRObject

/**
 *  Output only. The CVSS score of this vulnerability. CVSS score is on a scale
 *  of 0 - 10 where 0 indicates low severity and 10 indicates high severity.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cvssScore;

/**
 *  The distro assigned severity for this vulnerability when it is available,
 *  otherwise this is the note provider assigned severity.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_High
 *        High severity. (Value: "HIGH")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Low
 *        Low severity. (Value: "LOW")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_EffectiveSeverity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *effectiveSeverity;

/**
 *  Output only. Whether at least one of the affected packages has a fix
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fixAvailable;

/** Output only. A detailed description of this vulnerability. */
@property(nonatomic, copy, nullable) NSString *longDescription;

/**
 *  Required. The set of affected locations and their fixes (if available)
 *  within the associated resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_PackageIssue *> *packageIssue;

/** Output only. URLs related to this vulnerability. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_RelatedUrl *> *relatedUrls;

/**
 *  Output only. The note provider assigned severity of this vulnerability.
 *
 *  Likely values:
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Critical
 *        Critical severity. (Value: "CRITICAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_High High
 *        severity. (Value: "HIGH")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Low Low
 *        severity. (Value: "LOW")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Medium
 *        Medium severity. (Value: "MEDIUM")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_Minimal
 *        Minimal severity. (Value: "MINIMAL")
 *    @arg @c kGTLROnDemandScanning_VulnerabilityOccurrence_Severity_SeverityUnspecified
 *        Unknown. (Value: "SEVERITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** Output only. A one sentence description of this vulnerability. */
@property(nonatomic, copy, nullable) NSString *shortDescription;

/**
 *  The type of package; whether native or non native (e.g., ruby gems, node.js
 *  packages, etc.).
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Windows Update represents the metadata about the update for the Windows
 *  operating system. The fields in this message come from the Windows Update
 *  API documented at
 *  https://docs.microsoft.com/en-us/windows/win32/api/wuapi/nn-wuapi-iupdate.
 */
@interface GTLROnDemandScanning_WindowsUpdate : GTLRObject

/** The list of categories to which the update belongs. */
@property(nonatomic, strong, nullable) NSArray<GTLROnDemandScanning_Category *> *categories;

/**
 *  The localized description of the update.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Required - The unique identifier for the update. */
@property(nonatomic, strong, nullable) GTLROnDemandScanning_Identity *identity;

/**
 *  The Microsoft Knowledge Base article IDs that are associated with the
 *  update.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *kbArticleIds;

/** The last published timestamp of the update. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPublishedTimestamp;

/** The hyperlink to the support information for the update. */
@property(nonatomic, copy, nullable) NSString *supportUrl;

/** The localized title of the update. */
@property(nonatomic, copy, nullable) NSString *title;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
