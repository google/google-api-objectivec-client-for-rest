// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Spanner API (spanner/v1)
// Description:
//   Cloud Spanner is a managed, mission-critical, globally consistent and
//   scalable relational database service.
// Documentation:
//   https://cloud.google.com/spanner/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRSpanner_Binding;
@class GTLRSpanner_ChildLink;
@class GTLRSpanner_Database;
@class GTLRSpanner_Delete;
@class GTLRSpanner_ExecuteSqlRequest_Params;
@class GTLRSpanner_ExecuteSqlRequest_ParamTypes;
@class GTLRSpanner_Expr;
@class GTLRSpanner_Field;
@class GTLRSpanner_Instance;
@class GTLRSpanner_Instance_Labels;
@class GTLRSpanner_InstanceConfig;
@class GTLRSpanner_KeyRange;
@class GTLRSpanner_KeySet;
@class GTLRSpanner_Mutation;
@class GTLRSpanner_Operation;
@class GTLRSpanner_Operation_Metadata;
@class GTLRSpanner_Operation_Response;
@class GTLRSpanner_Partition;
@class GTLRSpanner_PartitionedDml;
@class GTLRSpanner_PartitionOptions;
@class GTLRSpanner_PartitionQueryRequest_Params;
@class GTLRSpanner_PartitionQueryRequest_ParamTypes;
@class GTLRSpanner_PlanNode;
@class GTLRSpanner_PlanNode_ExecutionStats;
@class GTLRSpanner_PlanNode_Metadata;
@class GTLRSpanner_Policy;
@class GTLRSpanner_QueryPlan;
@class GTLRSpanner_ReadOnly;
@class GTLRSpanner_ReadWrite;
@class GTLRSpanner_ResultSetMetadata;
@class GTLRSpanner_ResultSetStats;
@class GTLRSpanner_ResultSetStats_QueryStats;
@class GTLRSpanner_Session;
@class GTLRSpanner_Session_Labels;
@class GTLRSpanner_ShortRepresentation;
@class GTLRSpanner_ShortRepresentation_Subqueries;
@class GTLRSpanner_Status;
@class GTLRSpanner_Status_Details_Item;
@class GTLRSpanner_StructType;
@class GTLRSpanner_Transaction;
@class GTLRSpanner_TransactionOptions;
@class GTLRSpanner_TransactionSelector;
@class GTLRSpanner_Type;
@class GTLRSpanner_Write;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRSpanner_Database.state

/**
 *  The database is still being created. Operations on the database may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Database_State_Creating;
/**
 *  The database is fully created and ready for use.
 *
 *  Value: "READY"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Database_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Database_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ExecuteSqlRequest.queryMode

/**
 *  The default mode. Only the statement results are returned.
 *
 *  Value: "NORMAL"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal;
/**
 *  This mode returns only the query plan, without any results or
 *  execution statistics information.
 *
 *  Value: "PLAN"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan;
/**
 *  This mode returns both the query plan and the execution statistics along
 *  with the results.
 *
 *  Value: "PROFILE"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.state

/**
 *  The instance is still being created. Resources may not be
 *  available yet, and operations such as database creation may not
 *  work.
 *
 *  Value: "CREATING"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Instance_State_Creating;
/**
 *  The instance is fully created and ready to do work such as
 *  creating databases.
 *
 *  Value: "READY"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Instance_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Instance_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_PlanNode.kind

/**
 *  Not specified.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_KindUnspecified;
/**
 *  Denotes a Relational operator node in the expression tree. Relational
 *  operators represent iterative processing of rows during query execution.
 *  For example, a `TableScan` operation that reads rows from a table.
 *
 *  Value: "RELATIONAL"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Relational;
/**
 *  Denotes a Scalar node in the expression tree. Scalar nodes represent
 *  non-iterable entities in the query plan. For example, constants or
 *  arithmetic operators appearing inside predicate expressions or references
 *  to column names.
 *
 *  Value: "SCALAR"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Scalar;

// ----------------------------------------------------------------------------
// GTLRSpanner_Type.code

/**
 *  Encoded as `list`, where the list elements are represented
 *  according to array_element_type.
 *
 *  Value: "ARRAY"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Array;
/**
 *  Encoded as JSON `true` or `false`.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Bool;
/**
 *  Encoded as a base64-encoded `string`, as described in RFC 4648,
 *  section 4.
 *
 *  Value: "BYTES"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Bytes;
/**
 *  Encoded as `string` in RFC 3339 date format.
 *
 *  Value: "DATE"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Date;
/**
 *  Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or
 *  `"-Infinity"`.
 *
 *  Value: "FLOAT64"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Float64;
/**
 *  Encoded as `string`, in decimal format.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Int64;
/**
 *  Encoded as `string`.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_String;
/**
 *  Encoded as `list`, where list element `i` is represented according
 *  to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
 *
 *  Value: "STRUCT"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Struct;
/**
 *  Encoded as `string` in RFC 3339 timestamp format. The time zone
 *  must be present, and must be `"Z"`.
 *  If the schema has the column option
 *  `allow_commit_timestamp=true`, the placeholder string
 *  `"spanner.commit_timestamp()"` can be used to instruct the system
 *  to insert the commit timestamp associated with the transaction
 *  commit.
 *
 *  Value: "TIMESTAMP"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_Timestamp;
/**
 *  Not specified.
 *
 *  Value: "TYPE_CODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRSpanner_Type_Code_TypeCodeUnspecified;

/**
 *  The request for BeginTransaction.
 */
@interface GTLRSpanner_BeginTransactionRequest : GTLRObject

/** Required. Options for the new transaction. */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *options;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRSpanner_Binding : GTLRObject

/**
 *  Unimplemented. The condition that is associated with this binding.
 *  NOTE: an unsatisfied condition will not allow user access via current
 *  binding. Different bindings, including their conditions, are examined
 *  independently.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values:
 *  * `allUsers`: A special identifier that represents anyone who is
 *  on the internet; with or without a Google account.
 *  * `allAuthenticatedUsers`: A special identifier that represents anyone
 *  who is authenticated with a Google account or a service account.
 *  * `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@gmail.com` .
 *  * `serviceAccount:{emailid}`: An email address that represents a service
 *  account. For example, `my-other-app\@appspot.gserviceaccount.com`.
 *  * `group:{emailid}`: An email address that represents a Google group.
 *  For example, `admins\@example.com`.
 *  * `domain:{domain}`: A Google Apps domain name that represents all the
 *  users of that domain. For example, `google.com` or `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`.
 *  For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Metadata associated with a parent-child relationship appearing in a
 *  PlanNode.
 */
@interface GTLRSpanner_ChildLink : GTLRObject

/**
 *  The node to which the link points.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *childIndex;

/**
 *  The type of the link. For example, in Hash Joins this could be used to
 *  distinguish between the build child and the probe child, or in the case
 *  of the child being an output variable, to represent the tag associated
 *  with the output variable.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Only present if the child node is SCALAR and corresponds
 *  to an output variable of the parent node. The field carries the name of
 *  the output variable.
 *  For example, a `TableScan` operator that reads rows from a table will
 *  have child links to the `SCALAR` nodes representing the output variables
 *  created for each column that is read by the operator. The corresponding
 *  `variable` fields will be set to the variable names assigned to the
 *  columns.
 */
@property(nonatomic, copy, nullable) NSString *variable;

@end


/**
 *  The request for Commit.
 */
@interface GTLRSpanner_CommitRequest : GTLRObject

/**
 *  The mutations to be executed when this transaction commits. All
 *  mutations are applied atomically, in the order they appear in
 *  this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Mutation *> *mutations;

/**
 *  Execute mutations in a temporary transaction. Note that unlike
 *  commit of a previously-started transaction, commit with a
 *  temporary transaction is non-idempotent. That is, if the
 *  `CommitRequest` is sent to Cloud Spanner more than once (for
 *  instance, due to retries in the application, or in the
 *  transport library), it is possible that the mutations are
 *  executed more than once. If this is undesirable, use
 *  BeginTransaction and
 *  Commit instead.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUseTransaction;

/**
 *  Commit a previously-started transaction.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  The response for Commit.
 */
@interface GTLRSpanner_CommitResponse : GTLRObject

/** The Cloud Spanner timestamp at which the transaction committed. */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

@end


/**
 *  Metadata type for the operation returned by
 *  CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseMetadata : GTLRObject

/** The database being created. */
@property(nonatomic, copy, nullable) NSString *database;

@end


/**
 *  The request for CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseRequest : GTLRObject

/**
 *  Required. A `CREATE DATABASE` statement, which specifies the ID of the
 *  new database. The database ID must conform to the regular expression
 *  `a-z*[a-z0-9]` and be between 2 and 30 characters in length.
 *  If the database ID is a reserved word or if it contains a hyphen, the
 *  database ID must be enclosed in backticks (`` ` ``).
 */
@property(nonatomic, copy, nullable) NSString *createStatement;

/**
 *  An optional list of DDL statements to run inside the newly created
 *  database. Statements can create tables, indexes, etc. These
 *  statements execute atomically with the creation of the database:
 *  if there is an error in any statement, the database is not created.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *extraStatements;

@end


/**
 *  Metadata type for the operation returned by
 *  CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is
 *  in the process of undoing itself (which is guaranteed to succeed) and
 *  cannot be cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The instance being created. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  The time at which the
 *  CreateInstance request was
 *  received.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceRequest : GTLRObject

/**
 *  Required. The instance to create. The name may be omitted, but if
 *  specified must be `<parent>/instances/<instance_id>`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  Required. The ID of the instance to create. Valid identifiers are of the
 *  form `a-z*[a-z0-9]` and must be between 6 and 30 characters in
 *  length.
 */
@property(nonatomic, copy, nullable) NSString *instanceId;

@end


/**
 *  The request for CreateSession.
 */
@interface GTLRSpanner_CreateSessionRequest : GTLRObject

/** The session to create. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *session;

@end


/**
 *  A Cloud Spanner database.
 */
@interface GTLRSpanner_Database : GTLRObject

/**
 *  Required. The name of the database. Values are of the form
 *  `projects/<project>/instances/<instance>/databases/<database>`,
 *  where `<database>` is as specified in the `CREATE DATABASE`
 *  statement. This name can be passed to other API methods to
 *  identify the database.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The current database state.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Database_State_Creating The database is still being
 *        created. Operations on the database may fail
 *        with `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Database_State_Ready The database is fully created
 *        and ready for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Database_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Arguments to delete operations.
 */
@interface GTLRSpanner_Delete : GTLRObject

/**
 *  Required. The primary keys of the rows within table to delete.
 *  Delete is idempotent. The transaction will succeed even if some or all
 *  rows do not exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Required. The table whose rows will be deleted. */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRSpanner_Empty : GTLRObject
@end


/**
 *  The request for ExecuteSql and
 *  ExecuteStreamingSql.
 */
@interface GTLRSpanner_ExecuteSqlRequest : GTLRObject

/**
 *  The SQL string can contain parameter placeholders. A parameter
 *  placeholder consists of `'\@'` followed by the parameter
 *  name. Parameter names consist of any combination of letters,
 *  numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute an SQL statement with unbound parameters.
 *  Parameter values are specified using `params`, which is a JSON
 *  object whose keys are parameter names, and whose values are the
 *  corresponding parameter values.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL statement parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_ParamTypes *paramTypes;

/**
 *  If present, results will be restricted to the specified partition
 *  previously created using PartitionQuery(). There must be an exact
 *  match for the values of fields common to this message and the
 *  PartitionQueryRequest message used to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  Used to control the amount of debugging information returned in
 *  ResultSetStats. If partition_token is set, query_mode can only
 *  be set to QueryMode.NORMAL.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal The default mode.
 *        Only the statement results are returned. (Value: "NORMAL")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan This mode returns
 *        only the query plan, without any results or
 *        execution statistics information. (Value: "PLAN")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile This mode returns
 *        both the query plan and the execution statistics along
 *        with the results. (Value: "PROFILE")
 */
@property(nonatomic, copy, nullable) NSString *queryMode;

/**
 *  If this request is resuming a previously interrupted SQL statement
 *  execution, `resume_token` should be copied from the last
 *  PartialResultSet yielded before the interruption. Doing this
 *  enables the new SQL statement execution to resume where the last one left
 *  off. The rest of the request parameters must exactly match the
 *  request that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  A per-transaction sequence number used to identify this request. This
 *  makes each request idempotent such that if the request is received multiple
 *  times, at most one will succeed.
 *  The sequence number must be monotonically increasing within the
 *  transaction. If a request arrives for the first time with an out-of-order
 *  sequence number, the transaction may be aborted. Replays of previously
 *  handled requests will yield the same response as the first execution.
 *  Required for DML statements. Ignored for queries.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/** Required. The SQL string. */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  The transaction to use. If none is provided, the default is a
 *  temporary read-only transaction with strong concurrency.
 *  The transaction to use.
 *  For queries, if none is provided, the default is a temporary read-only
 *  transaction with strong concurrency.
 *  Standard DML statements require a ReadWrite transaction. Single-use
 *  transactions are not supported (to avoid replay). The caller must
 *  either supply an existing transaction ID or begin a new transaction.
 *  Partitioned DML requires an existing PartitionedDml transaction ID.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The SQL string can contain parameter placeholders. A parameter
 *  placeholder consists of `'\@'` followed by the parameter
 *  name. Parameter names consist of any combination of letters,
 *  numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute an SQL statement with unbound parameters.
 *  Parameter values are specified using `params`, which is a JSON
 *  object whose keys are parameter names, and whose values are the
 *  corresponding parameter values.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL statement parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_ParamTypes : GTLRObject
@end


/**
 *  Represents an expression text. Example:
 *  title: "User account presence"
 *  description: "Determines whether the request has a user account"
 *  expression: "size(request.user) > 0"
 */
@interface GTLRSpanner_Expr : GTLRObject

/**
 *  An optional description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in
 *  Common Expression Language syntax.
 *  The application context of the containing message determines which
 *  well-known feature set of CEL is supported.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  An optional string indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  An optional title for the expression, i.e. a short string describing
 *  its purpose. This can be used e.g. in UIs which allow to enter the
 *  expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Message representing a single field of a struct.
 */
@interface GTLRSpanner_Field : GTLRObject

/**
 *  The name of the field. For reads, this is the column name. For
 *  SQL queries, it is the column alias (e.g., `"Word"` in the
 *  query `"SELECT 'hello' AS Word"`), or the column name (e.g.,
 *  `"ColName"` in the query `"SELECT ColName FROM Table"`). Some
 *  columns might have an empty name (e.g., !"SELECT
 *  UPPER(ColName)"`). Note that a query result can contain
 *  multiple fields with the same name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The type of the field. */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *type;

@end


/**
 *  The response for GetDatabaseDdl.
 */
@interface GTLRSpanner_GetDatabaseDdlResponse : GTLRObject

/**
 *  A list of formatted DDL statements defining the schema of the database
 *  specified in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRSpanner_GetIamPolicyRequest : GTLRObject
@end


/**
 *  An isolated set of Cloud Spanner resources on which databases can be hosted.
 */
@interface GTLRSpanner_Instance : GTLRObject

/**
 *  Required. The name of the instance's configuration. Values are of the form
 *  `projects/<project>/instanceConfigs/<configuration>`. See
 *  also InstanceConfig and
 *  ListInstanceConfigs.
 */
@property(nonatomic, copy, nullable) NSString *config;

/**
 *  Required. The descriptive name for this instance as it appears in UIs.
 *  Must be unique per project and between 4 and 30 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.).
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given resource.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 *  If you plan to use labels in your own code, please note that additional
 *  characters may be allowed in the future. And so you are advised to use an
 *  internal label representation, such as JSON, which doesn't rely upon
 *  specific characters being disallowed. For example, representing labels
 *  as the string: name + "_" + value would prove problematic if we were to
 *  allow "_" in a future release.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance_Labels *labels;

/**
 *  Required. A unique identifier for the instance, which cannot be changed
 *  after the instance is created. Values are of the form
 *  `projects/<project>/instances/a-z*[a-z0-9]`. The final
 *  segment of the name must be between 6 and 30 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The number of nodes allocated to this instance. This may be zero
 *  in API responses for instances that are not yet in state `READY`.
 *  See [the
 *  documentation](https://cloud.google.com/spanner/docs/instances#node_count)
 *  for more information about nodes.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  Output only. The current instance state. For
 *  CreateInstance, the state must be
 *  either omitted or set to `CREATING`. For
 *  UpdateInstance, the state must be
 *  either omitted or set to `READY`.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_State_Creating The instance is still being
 *        created. Resources may not be
 *        available yet, and operations such as database creation may not
 *        work. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Instance_State_Ready The instance is fully created
 *        and ready to do work such as
 *        creating databases. (Value: "READY")
 *    @arg @c kGTLRSpanner_Instance_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.).
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given resource.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 *  If you plan to use labels in your own code, please note that additional
 *  characters may be allowed in the future. And so you are advised to use an
 *  internal label representation, such as JSON, which doesn't rely upon
 *  specific characters being disallowed. For example, representing labels
 *  as the string: name + "_" + value would prove problematic if we were to
 *  allow "_" in a future release.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Instance_Labels : GTLRObject
@end


/**
 *  A possible configuration for a Cloud Spanner instance. Configurations
 *  define the geographic placement of nodes and their replication.
 */
@interface GTLRSpanner_InstanceConfig : GTLRObject

/** The name of this instance configuration as it appears in UIs. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  A unique identifier for the instance configuration. Values
 *  are of the form
 *  `projects/<project>/instanceConfigs/a-z*`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  KeyRange represents a range of rows in a table or index.
 *  A range has a start key and an end key. These keys can be open or
 *  closed, indicating if the range includes rows with that key.
 *  Keys are represented by lists, where the ith value in the list
 *  corresponds to the ith component of the table or index primary key.
 *  Individual values are encoded as described here.
 *  For example, consider the following table definition:
 *  CREATE TABLE UserEvents (
 *  UserName STRING(MAX),
 *  EventDate STRING(10)
 *  ) PRIMARY KEY(UserName, EventDate);
 *  The following keys name rows in this table:
 *  "Bob", "2014-09-23"
 *  Since the `UserEvents` table's `PRIMARY KEY` clause names two
 *  columns, each `UserEvents` key has two elements; the first is the
 *  `UserName`, and the second is the `EventDate`.
 *  Key ranges with multiple components are interpreted
 *  lexicographically by component using the table or index key's declared
 *  sort order. For example, the following range returns all events for
 *  user `"Bob"` that occurred in the year 2015:
 *  "start_closed": ["Bob", "2015-01-01"]
 *  "end_closed": ["Bob", "2015-12-31"]
 *  Start and end keys can omit trailing key components. This affects the
 *  inclusion and exclusion of rows that exactly match the provided key
 *  components: if the key is closed, then rows that exactly match the
 *  provided components are included; if the key is open, then rows
 *  that exactly match are not included.
 *  For example, the following range includes all events for `"Bob"` that
 *  occurred during and after the year 2000:
 *  "start_closed": ["Bob", "2000-01-01"]
 *  "end_closed": ["Bob"]
 *  The next example retrieves all events for `"Bob"`:
 *  "start_closed": ["Bob"]
 *  "end_closed": ["Bob"]
 *  To retrieve events before the year 2000:
 *  "start_closed": ["Bob"]
 *  "end_open": ["Bob", "2000-01-01"]
 *  The following range includes all rows in the table:
 *  "start_closed": []
 *  "end_closed": []
 *  This range returns all users whose `UserName` begins with any
 *  character from A to C:
 *  "start_closed": ["A"]
 *  "end_open": ["D"]
 *  This range returns all users whose `UserName` begins with B:
 *  "start_closed": ["B"]
 *  "end_open": ["C"]
 *  Key ranges honor column sort order. For example, suppose a table is
 *  defined as follows:
 *  CREATE TABLE DescendingSortedTable {
 *  Key INT64,
 *  ...
 *  ) PRIMARY KEY(Key DESC);
 *  The following range retrieves all rows with key values between 1
 *  and 100 inclusive:
 *  "start_closed": ["100"]
 *  "end_closed": ["1"]
 *  Note that 100 is passed as the start, and 1 is passed as the end,
 *  because `Key` is a descending column in the schema.
 */
@interface GTLRSpanner_KeyRange : GTLRObject

/**
 *  If the end is closed, then the range includes all rows whose
 *  first `len(end_closed)` key columns exactly match `end_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endClosed;

/**
 *  If the end is open, then the range excludes rows whose first
 *  `len(end_open)` key columns exactly match `end_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endOpen;

/**
 *  If the start is closed, then the range includes all rows whose
 *  first `len(start_closed)` key columns exactly match `start_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startClosed;

/**
 *  If the start is open, then the range excludes rows whose first
 *  `len(start_open)` key columns exactly match `start_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startOpen;

@end


/**
 *  `KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All
 *  the keys are expected to be in the same table or index. The keys need
 *  not be sorted in any particular way.
 *  If the same key is specified multiple times in the set (for example
 *  if two ranges, two keys, or a key and a range overlap), Cloud Spanner
 *  behaves as if the key were only specified once.
 */
@interface GTLRSpanner_KeySet : GTLRObject

/**
 *  For convenience `all` can be set to `true` to indicate that this
 *  `KeySet` matches all keys in the table or index. Note that any keys
 *  specified in `keys` or `ranges` are only yielded once.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *all;

/**
 *  A list of specific keys. Entries in `keys` should have exactly as
 *  many elements as there are columns in the primary or index key
 *  with which this `KeySet` is used. Individual key values are
 *  encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *keys;

/**
 *  A list of key ranges. See KeyRange for more information about
 *  key range specifications.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_KeyRange *> *ranges;

@end


/**
 *  The response for ListDatabases.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "databases" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabasesResponse : GTLRCollectionObject

/**
 *  Databases that matched the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Database *> *databases;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListDatabases call to fetch more
 *  of the matching databases.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstanceConfigs.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instanceConfigs" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRSpanner_ListInstanceConfigsResponse : GTLRCollectionObject

/**
 *  The list of requested instance configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_InstanceConfig *> *instanceConfigs;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListInstanceConfigs call to
 *  fetch more of the matching instance configurations.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstancesResponse : GTLRCollectionObject

/**
 *  The list of requested instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Instance *> *instances;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListInstances call to fetch more
 *  of the matching instances.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListSessions.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "sessions" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListSessionsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListSessions call to fetch more of the matching
 *  sessions.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of requested sessions.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *sessions;

@end


/**
 *  A modification to one or more Cloud Spanner rows. Mutations can be
 *  applied to a Cloud Spanner database by sending them in a
 *  Commit call.
 */
@interface GTLRSpanner_Mutation : GTLRObject

/**
 *  Delete rows from a table. Succeeds whether or not the named
 *  rows were present.
 *
 *  Remapped to 'deleteProperty' to avoid language reserved word 'delete'.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Delete *deleteProperty;

/**
 *  Insert new rows in a table. If any of the rows already exist,
 *  the write or transaction fails with error `ALREADY_EXISTS`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insert;

/**
 *  Like insert, except that if the row already exists, then
 *  its column values are overwritten with the ones provided. Any
 *  column values not explicitly written are preserved.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insertOrUpdate;

/**
 *  Like insert, except that if the row already exists, it is
 *  deleted, and the column values provided are inserted
 *  instead. Unlike insert_or_update, this means any values not
 *  explicitly written become `NULL`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *replace;

/**
 *  Update existing rows in a table. If any of the rows does not
 *  already exist, the transaction fails with error `NOT_FOUND`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *update;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRSpanner_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress.
 *  If `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the
 *  `name` should have the format of `operations/some/unique/name`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Response : GTLRObject
@end


/**
 *  Partial results from a streaming read or SQL query. Streaming reads and
 *  SQL queries better tolerate large result sets, large rows, and large
 *  values, but are a little trickier to consume.
 */
@interface GTLRSpanner_PartialResultSet : GTLRObject

/**
 *  If true, then the final value in values is chunked, and must
 *  be combined with more values from subsequent `PartialResultSet`s
 *  to obtain a complete field value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *chunkedValue;

/**
 *  Metadata about the result set, such as row type information.
 *  Only present in the first response.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Streaming calls might be interrupted for a variety of reasons, such
 *  as TCP connection loss. If this occurs, the stream of results can
 *  be resumed by re-sending the original request and including
 *  `resume_token`. Note that executing any other transaction in the
 *  same session invalidates the token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  Query plan and execution statistics for the statement that produced this
 *  streaming result set. These can be requested by setting
 *  ExecuteSqlRequest.query_mode and are sent
 *  only once with the last response in the stream.
 *  This field will also be present in the last response for DML
 *  statements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

/**
 *  A streamed result set consists of a stream of values, which might
 *  be split into many `PartialResultSet` messages to accommodate
 *  large rows and/or large values. Every N complete values defines a
 *  row, where N is equal to the number of entries in
 *  metadata.row_type.fields.
 *  Most values are encoded based on type as described
 *  here.
 *  It is possible that the last value in values is "chunked",
 *  meaning that the rest of the value is sent in subsequent
 *  `PartialResultSet`(s). This is denoted by the chunked_value
 *  field. Two or more chunked values can be merged to form a
 *  complete value as follows:
 *  * `bool/number/null`: cannot be chunked
 *  * `string`: concatenate the strings
 *  * `list`: concatenate the lists. If the last element in a list is a
 *  `string`, `list`, or `object`, merge it with the first element in
 *  the next list by applying these rules recursively.
 *  * `object`: concatenate the (field name, field value) pairs. If a
 *  field name is duplicated, then apply these rules recursively
 *  to merge the field values.
 *  Some examples of merging:
 *  # Strings are concatenated.
 *  "foo", "bar" => "foobar"
 *  # Lists of non-strings are concatenated.
 *  [2, 3], [4] => [2, 3, 4]
 *  # Lists are concatenated, but the last and first elements are merged
 *  # because they are strings.
 *  ["a", "b"], ["c", "d"] => ["a", "bc", "d"]
 *  # Lists are concatenated, but the last and first elements are merged
 *  # because they are lists. Recursively, the last and first elements
 *  # of the inner lists are merged because they are strings.
 *  ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"]
 *  # Non-overlapping object fields are combined.
 *  {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"}
 *  # Overlapping object fields are merged.
 *  {"a": "1"}, {"a": "2"} => {"a": "12"}
 *  # Examples of merging objects containing lists of strings.
 *  {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]}
 *  For a more complete example, suppose a streaming SQL query is
 *  yielding a result set whose rows contain a single string
 *  field. The following `PartialResultSet`s might be yielded:
 *  {
 *  "metadata": { ... }
 *  "values": ["Hello", "W"]
 *  "chunked_value": true
 *  "resume_token": "Af65..."
 *  }
 *  {
 *  "values": ["orl"]
 *  "chunked_value": true
 *  "resume_token": "Bqp2..."
 *  }
 *  {
 *  "values": ["d"]
 *  "resume_token": "Zx1B..."
 *  }
 *  This sequence of `PartialResultSet`s encodes two rows, one
 *  containing the field value `"Hello"`, and a second containing the
 *  field value `"World" = "W" + "orl" + "d"`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *values;

@end


/**
 *  Information returned for each partition returned in a
 *  PartitionResponse.
 */
@interface GTLRSpanner_Partition : GTLRObject

/**
 *  This token can be passed to Read, StreamingRead, ExecuteSql, or
 *  ExecuteStreamingSql requests to restrict the results to those identified by
 *  this partition token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

@end


/**
 *  Message type to initiate a Partitioned DML transaction.
 */
@interface GTLRSpanner_PartitionedDml : GTLRObject
@end


/**
 *  Options for a PartitionQueryRequest and
 *  PartitionReadRequest.
 */
@interface GTLRSpanner_PartitionOptions : GTLRObject

/**
 *  **Note:** This hint is currently ignored by PartitionQuery and
 *  PartitionRead requests.
 *  The desired maximum number of partitions to return. For example, this may
 *  be set to the number of workers available. The default for this option
 *  is currently 10,000. The maximum value is currently 200,000. This is only
 *  a hint. The actual number of partitions returned may be smaller or larger
 *  than this maximum count request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPartitions;

/**
 *  **Note:** This hint is currently ignored by PartitionQuery and
 *  PartitionRead requests.
 *  The desired data size for each partition generated. The default for this
 *  option is currently 1 GiB. This is only a hint. The actual size of each
 *  partition may be smaller or larger than this size request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionSizeBytes;

@end


/**
 *  The request for PartitionQuery
 */
@interface GTLRSpanner_PartitionQueryRequest : GTLRObject

/**
 *  The SQL query string can contain parameter placeholders. A parameter
 *  placeholder consists of `'\@'` followed by the parameter
 *  name. Parameter names consist of any combination of letters,
 *  numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute an SQL query with unbound parameters.
 *  Parameter values are specified using `params`, which is a JSON
 *  object whose keys are parameter names, and whose values are the
 *  corresponding parameter values.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL query parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_ParamTypes *paramTypes;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/**
 *  The query request to generate partitions for. The request will fail if
 *  the query is not root partitionable. The query plan of a root
 *  partitionable query has a single distributed union operator. A distributed
 *  union operator conceptually divides one or more tables into multiple
 *  splits, remotely evaluates a subquery independently on each split, and
 *  then unions all results.
 *  This must not contain DML commands, such as INSERT, UPDATE, or
 *  DELETE. Use ExecuteStreamingSql with a
 *  PartitionedDml transaction for large, partition-friendly DML operations.
 */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The SQL query string can contain parameter placeholders. A parameter
 *  placeholder consists of `'\@'` followed by the parameter
 *  name. Parameter names consist of any combination of letters,
 *  numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute an SQL query with unbound parameters.
 *  Parameter values are specified using `params`, which is a JSON
 *  object whose keys are parameter names, and whose values are the
 *  corresponding parameter values.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL query parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_ParamTypes : GTLRObject
@end


/**
 *  The request for PartitionRead
 */
@interface GTLRSpanner_PartitionReadRequest : GTLRObject

/**
 *  The columns of table to be returned for each row matching
 *  this request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is
 *  used instead of the table primary key when interpreting key_set
 *  and sorting result rows. See key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index
 *  is present. If index is present, then key_set instead names
 *  index keys in index.
 *  It is not an error for the `key_set` to name rows that do not
 *  exist in the database. Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for PartitionQuery
 *  or PartitionRead
 */
@interface GTLRSpanner_PartitionResponse : GTLRObject

/** Partitions created by this request. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Partition *> *partitions;

/** Transaction created by this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

@end


/**
 *  Node information for nodes appearing in a QueryPlan.plan_nodes.
 */
@interface GTLRSpanner_PlanNode : GTLRObject

/** List of child node `index`es and their relationship to this parent. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ChildLink *> *childLinks;

/** The display name for the node. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_ExecutionStats *executionStats;

/**
 *  The `PlanNode`'s index in node list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Used to determine the type of node. May be needed for visualizing
 *  different kinds of nodes differently. For example, If the node is a
 *  SCALAR node, it will have a condensed representation
 *  which can be used to directly embed a description of the node in its
 *  parent.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_PlanNode_Kind_KindUnspecified Not specified. (Value:
 *        "KIND_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Relational Denotes a Relational
 *        operator node in the expression tree. Relational
 *        operators represent iterative processing of rows during query
 *        execution.
 *        For example, a `TableScan` operation that reads rows from a table.
 *        (Value: "RELATIONAL")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Scalar Denotes a Scalar node in the
 *        expression tree. Scalar nodes represent
 *        non-iterable entities in the query plan. For example, constants or
 *        arithmetic operators appearing inside predicate expressions or
 *        references
 *        to column names. (Value: "SCALAR")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Attributes relevant to the node contained in a group of key-value pairs.
 *  For example, a Parameter Reference node could have the following
 *  information in its metadata:
 *  {
 *  "parameter_reference": "param1",
 *  "parameter_type": "array"
 *  }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_Metadata *metadata;

/** Condensed representation for SCALAR nodes. */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation *shortRepresentation;

@end


/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_ExecutionStats : GTLRObject
@end


/**
 *  Attributes relevant to the node contained in a group of key-value pairs.
 *  For example, a Parameter Reference node could have the following
 *  information in its metadata:
 *  {
 *  "parameter_reference": "param1",
 *  "parameter_type": "array"
 *  }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_Metadata : GTLRObject
@end


/**
 *  Defines an Identity and Access Management (IAM) policy. It is used to
 *  specify access control policies for Cloud Platform resources.
 *  A `Policy` consists of a list of `bindings`. A `binding` binds a list of
 *  `members` to a `role`, where the members can be user accounts, Google
 *  groups,
 *  Google domains, and service accounts. A `role` is a named list of
 *  permissions
 *  defined by IAM.
 *  **JSON Example**
 *  {
 *  "bindings": [
 *  {
 *  "role": "roles/owner",
 *  "members": [
 *  "user:mike\@example.com",
 *  "group:admins\@example.com",
 *  "domain:google.com",
 *  "serviceAccount:my-other-app\@appspot.gserviceaccount.com"
 *  ]
 *  },
 *  {
 *  "role": "roles/viewer",
 *  "members": ["user:sean\@example.com"]
 *  }
 *  ]
 *  }
 *  **YAML Example**
 *  bindings:
 *  - members:
 *  - user:mike\@example.com
 *  - group:admins\@example.com
 *  - domain:google.com
 *  - serviceAccount:my-other-app\@appspot.gserviceaccount.com
 *  role: roles/owner
 *  - members:
 *  - user:sean\@example.com
 *  role: roles/viewer
 *  For a description of IAM and its features, see the
 *  [IAM developer's guide](https://cloud.google.com/iam/docs).
 */
@interface GTLRSpanner_Policy : GTLRObject

/**
 *  Associates a list of `members` to a `role`.
 *  `bindings` with no members will result in an error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help
 *  prevent simultaneous updates of a policy from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform policy updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `getIamPolicy`, and
 *  systems are expected to put that etag in the request to `setIamPolicy` to
 *  ensure that their change will be applied to the same version of the policy.
 *  If no `etag` is provided in the call to `setIamPolicy`, then the existing
 *  policy is overwritten blindly.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Deprecated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Contains an ordered list of nodes appearing in the query plan.
 */
@interface GTLRSpanner_QueryPlan : GTLRObject

/**
 *  The nodes in the query plan. Plan nodes are returned in pre-order starting
 *  with the plan root. Each PlanNode's `id` corresponds to its index in
 *  `plan_nodes`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_PlanNode *> *planNodes;

@end


/**
 *  Message type to initiate a read-only transaction.
 */
@interface GTLRSpanner_ReadOnly : GTLRObject

/**
 *  Executes all reads at a timestamp that is `exact_staleness`
 *  old. The timestamp is chosen soon after the read is started.
 *  Guarantees that all writes that have committed more than the
 *  specified number of seconds ago are visible. Because Cloud Spanner
 *  chooses the exact timestamp, this mode works even if the client's
 *  local clock is substantially skewed from Cloud Spanner commit
 *  timestamps.
 *  Useful for reading at nearby replicas without the distributed
 *  timestamp negotiation overhead of `max_staleness`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *exactStaleness;

/**
 *  Read data at a timestamp >= `NOW - max_staleness`
 *  seconds. Guarantees that all writes that have committed more
 *  than the specified number of seconds ago are visible. Because
 *  Cloud Spanner chooses the exact timestamp, this mode works even if
 *  the client's local clock is substantially skewed from Cloud Spanner
 *  commit timestamps.
 *  Useful for reading the freshest data available at a nearby
 *  replica, while bounding the possible staleness if the local
 *  replica has fallen behind.
 *  Note that this option can only be used in single-use
 *  transactions.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxStaleness;

/**
 *  Executes all reads at a timestamp >= `min_read_timestamp`.
 *  This is useful for requesting fresher data than some previous
 *  read, or data that is fresh enough to observe the effects of some
 *  previously committed transaction whose timestamp is known.
 *  Note that this option can only be used in single-use transactions.
 *  A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to nanoseconds.
 *  Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *minReadTimestamp;

/**
 *  Executes all reads at the given timestamp. Unlike other modes,
 *  reads at a specific timestamp are repeatable; the same read at
 *  the same timestamp always returns the same data. If the
 *  timestamp is in the future, the read will block until the
 *  specified timestamp, modulo the read's deadline.
 *  Useful for large scale consistent reads such as mapreduces, or
 *  for coordinating many reads against a consistent snapshot of the
 *  data.
 *  A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to nanoseconds.
 *  Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

/**
 *  If true, the Cloud Spanner-selected read timestamp is included in
 *  the Transaction message that describes the transaction.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *returnReadTimestamp;

/**
 *  Read at a timestamp where all previously committed transactions
 *  are visible.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strong;

@end


/**
 *  The request for Read and
 *  StreamingRead.
 */
@interface GTLRSpanner_ReadRequest : GTLRObject

/**
 *  The columns of table to be returned for each row matching
 *  this request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is
 *  used instead of the table primary key when interpreting key_set
 *  and sorting result rows. See key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index
 *  is present. If index is present, then key_set instead names
 *  index keys in index.
 *  If the partition_token field is empty, rows are yielded
 *  in table primary key order (if index is empty) or index key order
 *  (if index is non-empty). If the partition_token field is not
 *  empty, rows will be yielded in an unspecified order.
 *  It is not an error for the `key_set` to name rows that do not
 *  exist in the database. Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/**
 *  If greater than zero, only the first `limit` rows are yielded. If `limit`
 *  is zero, the default is no limit. A limit cannot be specified if
 *  `partition_token` is set.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *limit;

/**
 *  If present, results will be restricted to the specified partition
 *  previously created using PartitionRead(). There must be an exact
 *  match for the values of fields common to this message and the
 *  PartitionReadRequest message used to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  If this request is resuming a previously interrupted read,
 *  `resume_token` should be copied from the last
 *  PartialResultSet yielded before the interruption. Doing this
 *  enables the new read to resume where the last read left off. The
 *  rest of the request parameters must exactly match the request
 *  that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The transaction to use. If none is provided, the default is a
 *  temporary read-only transaction with strong concurrency.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Message type to initiate a read-write transaction. Currently this
 *  transaction type has no options.
 */
@interface GTLRSpanner_ReadWrite : GTLRObject
@end


/**
 *  Results from Read or
 *  ExecuteSql.
 */
@interface GTLRSpanner_ResultSet : GTLRObject

/** Metadata about the result set, such as row type information. */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Each element in `rows` is a row whose format is defined by
 *  metadata.row_type. The ith element
 *  in each row matches the ith field in
 *  metadata.row_type. Elements are
 *  encoded based on type as described
 *  here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *rows;

/**
 *  Query plan and execution statistics for the SQL statement that
 *  produced this result set. These can be requested by setting
 *  ExecuteSqlRequest.query_mode.
 *  DML statements always produce stats containing the number of rows
 *  modified, unless executed using the
 *  ExecuteSqlRequest.QueryMode.PLAN ExecuteSqlRequest.query_mode.
 *  Other fields may or may not be populated, based on the
 *  ExecuteSqlRequest.query_mode.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

@end


/**
 *  Metadata about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetMetadata : GTLRObject

/**
 *  Indicates the field names and types for the rows in the result
 *  set. For example, a SQL query like `"SELECT UserId, UserName FROM
 *  Users"` could return a `row_type` value like:
 *  "fields": [
 *  { "name": "UserId", "type": { "code": "INT64" } },
 *  { "name": "UserName", "type": { "code": "STRING" } },
 *  ]
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *rowType;

/**
 *  If the read or SQL query began a transaction as a side-effect, the
 *  information about the new transaction is yielded here.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

@end


/**
 *  Additional statistics about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetStats : GTLRObject

/** QueryPlan for the query associated with this result. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryPlan *queryPlan;

/**
 *  Aggregated statistics from the execution of the query. Only present when
 *  the query is profiled. For example, a query could return the statistics as
 *  follows:
 *  {
 *  "rows_returned": "3",
 *  "elapsed_time": "1.22 secs",
 *  "cpu_time": "1.19 secs"
 *  }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats_QueryStats *queryStats;

/**
 *  Standard DML returns an exact count of rows that were modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountExact;

/**
 *  Partitioned DML does not offer exactly-once semantics, so it
 *  returns a lower bound of the rows modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountLowerBound;

@end


/**
 *  Aggregated statistics from the execution of the query. Only present when
 *  the query is profiled. For example, a query could return the statistics as
 *  follows:
 *  {
 *  "rows_returned": "3",
 *  "elapsed_time": "1.22 secs",
 *  "cpu_time": "1.19 secs"
 *  }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ResultSetStats_QueryStats : GTLRObject
@end


/**
 *  The request for Rollback.
 */
@interface GTLRSpanner_RollbackRequest : GTLRObject

/**
 *  Required. The transaction to roll back.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  A session in the Cloud Spanner API.
 */
@interface GTLRSpanner_Session : GTLRObject

/**
 *  Output only. The approximate timestamp when the session is last used. It is
 *  typically earlier than the actual last use time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *approximateLastUseTime;

/** Output only. The timestamp when the session is created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The labels for the session.
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given session.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Session_Labels *labels;

/**
 *  The name of the session. This is always system-assigned; values provided
 *  when creating a session are ignored.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The labels for the session.
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given session.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Session_Labels : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRSpanner_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a
 *  valid policy but certain Cloud Platform services (such as Projects)
 *  might reject them.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Policy *policy;

@end


/**
 *  Condensed representation of a node and its subtree. Only present for
 *  `SCALAR` PlanNode(s).
 */
@interface GTLRSpanner_ShortRepresentation : GTLRObject

/**
 *  A string representation of the expression subtree rooted at this node.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases
 *  where the `description` string of this node references a `SCALAR`
 *  subquery contained in the expression subtree rooted at this node. The
 *  referenced `SCALAR` subquery may not necessarily be a direct child of
 *  this node.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation_Subqueries *subqueries;

@end


/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases
 *  where the `description` string of this node references a `SCALAR`
 *  subquery contained in the expression subtree rooted at this node. The
 *  referenced `SCALAR` subquery may not necessarily be a direct child of
 *  this node.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ShortRepresentation_Subqueries : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` that can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRSpanner_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRSpanner_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Status_Details_Item : GTLRObject
@end


/**
 *  `StructType` defines the fields of a STRUCT type.
 */
@interface GTLRSpanner_StructType : GTLRObject

/**
 *  The list of fields that make up this struct. Order is
 *  significant, because values of this struct type are represented as
 *  lists, where the order of field values matches the order of
 *  fields in the StructType. In turn, the order of fields
 *  matches the order of columns in a read request, or the order of
 *  fields in the `SELECT` clause of a query.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Field *> *fields;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsRequest : GTLRObject

/**
 *  REQUIRED: The set of permissions to check for 'resource'.
 *  Permissions with wildcards (such as '*', 'spanner.*', 'spanner.instances.*')
 *  are not allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is
 *  allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  A transaction.
 */
@interface GTLRSpanner_Transaction : GTLRObject

/**
 *  `id` may be used to identify the transaction in subsequent
 *  Read,
 *  ExecuteSql,
 *  Commit, or
 *  Rollback calls.
 *  Single-use read-only transactions do not have IDs, because
 *  single-use transactions do not support multiple requests.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  For snapshot read-only transactions, the read timestamp chosen
 *  for the transaction. Not returned by default: see
 *  TransactionOptions.ReadOnly.return_read_timestamp.
 *  A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to nanoseconds.
 *  Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

@end


/**
 *  # Transactions
 *  Each session can have at most one active transaction at a time. After the
 *  active transaction is completed, the session can immediately be
 *  re-used for the next transaction. It is not necessary to create a
 *  new session for each transaction.
 *  # Transaction Modes
 *  Cloud Spanner supports three transaction modes:
 *  1. Locking read-write. This type of transaction is the only way
 *  to write data into Cloud Spanner. These transactions rely on
 *  pessimistic locking and, if necessary, two-phase commit.
 *  Locking read-write transactions may abort, requiring the
 *  application to retry.
 *  2. Snapshot read-only. This transaction type provides guaranteed
 *  consistency across several reads, but does not allow
 *  writes. Snapshot read-only transactions can be configured to
 *  read at timestamps in the past. Snapshot read-only
 *  transactions do not need to be committed.
 *  3. Partitioned DML. This type of transaction is used to execute
 *  a single Partitioned DML statement. Partitioned DML partitions
 *  the key space and runs the DML statement over each partition
 *  in parallel using separate, internal transactions that commit
 *  independently. Partitioned DML transactions do not need to be
 *  committed.
 *  For transactions that only read, snapshot read-only transactions
 *  provide simpler semantics and are almost always faster. In
 *  particular, read-only transactions do not take locks, so they do
 *  not conflict with read-write transactions. As a consequence of not
 *  taking locks, they also do not abort, so retry loops are not needed.
 *  Transactions may only read/write data in a single database. They
 *  may, however, read/write data in different tables within that
 *  database.
 *  ## Locking Read-Write Transactions
 *  Locking transactions may be used to atomically read-modify-write
 *  data anywhere in a database. This type of transaction is externally
 *  consistent.
 *  Clients should attempt to minimize the amount of time a transaction
 *  is active. Faster transactions commit with higher probability
 *  and cause less contention. Cloud Spanner attempts to keep read locks
 *  active as long as the transaction continues to do reads, and the
 *  transaction has not been terminated by
 *  Commit or
 *  Rollback. Long periods of
 *  inactivity at the client may cause Cloud Spanner to release a
 *  transaction's locks and abort it.
 *  Conceptually, a read-write transaction consists of zero or more
 *  reads or SQL statements followed by
 *  Commit. At any time before
 *  Commit, the client can send a
 *  Rollback request to abort the
 *  transaction.
 *  ### Semantics
 *  Cloud Spanner can commit the transaction if all read locks it acquired
 *  are still valid at commit time, and it is able to acquire write
 *  locks for all writes. Cloud Spanner can abort the transaction for any
 *  reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
 *  that the transaction has not modified any user data in Cloud Spanner.
 *  Unless the transaction commits, Cloud Spanner makes no guarantees about
 *  how long the transaction's locks were held for. It is an error to
 *  use Cloud Spanner locks for any sort of mutual exclusion other than
 *  between Cloud Spanner transactions themselves.
 *  ### Retrying Aborted Transactions
 *  When a transaction aborts, the application can choose to retry the
 *  whole transaction again. To maximize the chances of successfully
 *  committing the retry, the client should execute the retry in the
 *  same session as the original attempt. The original session's lock
 *  priority increases with each consecutive abort, meaning that each
 *  attempt has a slightly better chance of success than the previous.
 *  Under some circumstances (e.g., many transactions attempting to
 *  modify the same row(s)), a transaction can abort many times in a
 *  short period before successfully committing. Thus, it is not a good
 *  idea to cap the number of retries a transaction can attempt;
 *  instead, it is better to limit the total amount of wall time spent
 *  retrying.
 *  ### Idle Transactions
 *  A transaction is considered idle if it has no outstanding reads or
 *  SQL queries and has not started a read or SQL query within the last 10
 *  seconds. Idle transactions can be aborted by Cloud Spanner so that they
 *  don't hold on to locks indefinitely. In that case, the commit will
 *  fail with error `ABORTED`.
 *  If this behavior is undesirable, periodically executing a simple
 *  SQL query in the transaction (e.g., `SELECT 1`) prevents the
 *  transaction from becoming idle.
 *  ## Snapshot Read-Only Transactions
 *  Snapshot read-only transactions provides a simpler method than
 *  locking read-write transactions for doing several consistent
 *  reads. However, this type of transaction does not support writes.
 *  Snapshot transactions do not take locks. Instead, they work by
 *  choosing a Cloud Spanner timestamp, then executing all reads at that
 *  timestamp. Since they do not acquire locks, they do not block
 *  concurrent read-write transactions.
 *  Unlike locking read-write transactions, snapshot read-only
 *  transactions never abort. They can fail if the chosen read
 *  timestamp is garbage collected; however, the default garbage
 *  collection policy is generous enough that most applications do not
 *  need to worry about this in practice.
 *  Snapshot read-only transactions do not need to call
 *  Commit or
 *  Rollback (and in fact are not
 *  permitted to do so).
 *  To execute a snapshot transaction, the client specifies a timestamp
 *  bound, which tells Cloud Spanner how to choose a read timestamp.
 *  The types of timestamp bound are:
 *  - Strong (the default).
 *  - Bounded staleness.
 *  - Exact staleness.
 *  If the Cloud Spanner database to be read is geographically distributed,
 *  stale read-only transactions can execute more quickly than strong
 *  or read-write transaction, because they are able to execute far
 *  from the leader replica.
 *  Each type of timestamp bound is discussed in detail below.
 *  ### Strong
 *  Strong reads are guaranteed to see the effects of all transactions
 *  that have committed before the start of the read. Furthermore, all
 *  rows yielded by a single read are consistent with each other -- if
 *  any part of the read observes a transaction, all parts of the read
 *  see the transaction.
 *  Strong reads are not repeatable: two consecutive strong read-only
 *  transactions might return inconsistent results if there are
 *  concurrent writes. If consistency across reads is required, the
 *  reads should be executed within a transaction or at an exact read
 *  timestamp.
 *  See TransactionOptions.ReadOnly.strong.
 *  ### Exact Staleness
 *  These timestamp bounds execute reads at a user-specified
 *  timestamp. Reads at a timestamp are guaranteed to see a consistent
 *  prefix of the global transaction history: they observe
 *  modifications done by all transactions with a commit timestamp <=
 *  the read timestamp, and observe none of the modifications done by
 *  transactions with a larger commit timestamp. They will block until
 *  all conflicting transactions that may be assigned commit timestamps
 *  <= the read timestamp have finished.
 *  The timestamp can either be expressed as an absolute Cloud Spanner commit
 *  timestamp or a staleness relative to the current time.
 *  These modes do not require a "negotiation phase" to pick a
 *  timestamp. As a result, they execute slightly faster than the
 *  equivalent boundedly stale concurrency modes. On the other hand,
 *  boundedly stale reads usually return fresher results.
 *  See TransactionOptions.ReadOnly.read_timestamp and
 *  TransactionOptions.ReadOnly.exact_staleness.
 *  ### Bounded Staleness
 *  Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
 *  subject to a user-provided staleness bound. Cloud Spanner chooses the
 *  newest timestamp within the staleness bound that allows execution
 *  of the reads at the closest available replica without blocking.
 *  All rows yielded are consistent with each other -- if any part of
 *  the read observes a transaction, all parts of the read see the
 *  transaction. Boundedly stale reads are not repeatable: two stale
 *  reads, even if they use the same staleness bound, can execute at
 *  different timestamps and thus return inconsistent results.
 *  Boundedly stale reads execute in two phases: the first phase
 *  negotiates a timestamp among all replicas needed to serve the
 *  read. In the second phase, reads are executed at the negotiated
 *  timestamp.
 *  As a result of the two phase execution, bounded staleness reads are
 *  usually a little slower than comparable exact staleness
 *  reads. However, they are typically able to return fresher
 *  results, and are more likely to execute at the closest replica.
 *  Because the timestamp negotiation requires up-front knowledge of
 *  which rows will be read, it can only be used with single-use
 *  read-only transactions.
 *  See TransactionOptions.ReadOnly.max_staleness and
 *  TransactionOptions.ReadOnly.min_read_timestamp.
 *  ### Old Read Timestamps and Garbage Collection
 *  Cloud Spanner continuously garbage collects deleted and overwritten data
 *  in the background to reclaim storage space. This process is known
 *  as "version GC". By default, version GC reclaims versions after they
 *  are one hour old. Because of this, Cloud Spanner cannot perform reads
 *  at read timestamps more than one hour in the past. This
 *  restriction also applies to in-progress reads and/or SQL queries whose
 *  timestamp become too old while executing. Reads and SQL queries with
 *  too-old read timestamps fail with the error `FAILED_PRECONDITION`.
 *  ## Partitioned DML Transactions
 *  Partitioned DML transactions are used to execute DML statements with a
 *  different execution strategy that provides different, and often better,
 *  scalability properties for large, table-wide operations than DML in a
 *  ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
 *  should prefer using ReadWrite transactions.
 *  Partitioned DML partitions the keyspace and runs the DML statement on each
 *  partition in separate, internal transactions. These transactions commit
 *  automatically when complete, and run independently from one another.
 *  To reduce lock contention, this execution strategy only acquires read locks
 *  on rows that match the WHERE clause of the statement. Additionally, the
 *  smaller per-partition transactions hold locks for less time.
 *  That said, Partitioned DML is not a drop-in replacement for standard DML
 *  used
 *  in ReadWrite transactions.
 *  - The DML statement must be fully-partitionable. Specifically, the statement
 *  must be expressible as the union of many statements which each access only
 *  a single row of the table.
 *  - The statement is not applied atomically to all rows of the table. Rather,
 *  the statement is applied atomically to partitions of the table, in
 *  independent transactions. Secondary index rows are updated atomically
 *  with the base table rows.
 *  - Partitioned DML does not guarantee exactly-once execution semantics
 *  against a partition. The statement will be applied at least once to each
 *  partition. It is strongly recommended that the DML statement should be
 *  idempotent to avoid unexpected results. For instance, it is potentially
 *  dangerous to run a statement such as
 *  `UPDATE table SET column = column + 1` as it could be run multiple times
 *  against some rows.
 *  - The partitions are committed automatically - there is no support for
 *  Commit or Rollback. If the call returns an error, or if the client issuing
 *  the ExecuteSql call dies, it is possible that some rows had the statement
 *  executed on them successfully. It is also possible that statement was
 *  never executed against other rows.
 *  - Partitioned DML transactions may only contain the execution of a single
 *  DML statement via ExecuteSql or ExecuteStreamingSql.
 *  - If any error is encountered during the execution of the partitioned DML
 *  operation (for instance, a UNIQUE INDEX violation, division by zero, or a
 *  value that cannot be stored due to schema constraints), then the
 *  operation is stopped at that point and an error is returned. It is
 *  possible that at this point, some partitions have been committed (or even
 *  committed multiple times), and other partitions have not been run at all.
 *  Given the above, Partitioned DML is good fit for large, database-wide,
 *  operations that are idempotent, such as deleting old rows from a very large
 *  table.
 */
@interface GTLRSpanner_TransactionOptions : GTLRObject

/**
 *  Partitioned DML transaction.
 *  Authorization to begin a Partitioned DML transaction requires
 *  `spanner.databases.beginPartitionedDmlTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionedDml *partitionedDml;

/**
 *  Transaction will not write.
 *  Authorization to begin a read-only transaction requires
 *  `spanner.databases.beginReadOnlyTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadOnly *readOnly;

/**
 *  Transaction may write.
 *  Authorization to begin a read-write transaction requires
 *  `spanner.databases.beginOrRollbackReadWriteTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadWrite *readWrite;

@end


/**
 *  This message is used to select the transaction in which a
 *  Read or
 *  ExecuteSql call runs.
 *  See TransactionOptions for more information about transactions.
 */
@interface GTLRSpanner_TransactionSelector : GTLRObject

/**
 *  Begin a new transaction and execute this read or SQL query in
 *  it. The transaction ID of the new transaction is returned in
 *  ResultSetMetadata.transaction, which is a Transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *begin;

/**
 *  Execute the read or SQL query in a previously-started transaction.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Execute the read or SQL query in a temporary transaction.
 *  This is the most efficient way to execute a transaction that
 *  consists of a single SQL query.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUse;

@end


/**
 *  `Type` indicates the type of a Cloud Spanner value, as might be stored in a
 *  table cell or returned from an SQL query.
 */
@interface GTLRSpanner_Type : GTLRObject

/**
 *  If code == ARRAY, then `array_element_type`
 *  is the type of the array elements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *arrayElementType;

/**
 *  Required. The TypeCode for this type.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Type_Code_Array Encoded as `list`, where the list
 *        elements are represented
 *        according to array_element_type. (Value: "ARRAY")
 *    @arg @c kGTLRSpanner_Type_Code_Bool Encoded as JSON `true` or `false`.
 *        (Value: "BOOL")
 *    @arg @c kGTLRSpanner_Type_Code_Bytes Encoded as a base64-encoded `string`,
 *        as described in RFC 4648,
 *        section 4. (Value: "BYTES")
 *    @arg @c kGTLRSpanner_Type_Code_Date Encoded as `string` in RFC 3339 date
 *        format. (Value: "DATE")
 *    @arg @c kGTLRSpanner_Type_Code_Float64 Encoded as `number`, or the strings
 *        `"NaN"`, `"Infinity"`, or
 *        `"-Infinity"`. (Value: "FLOAT64")
 *    @arg @c kGTLRSpanner_Type_Code_Int64 Encoded as `string`, in decimal
 *        format. (Value: "INT64")
 *    @arg @c kGTLRSpanner_Type_Code_String Encoded as `string`. (Value:
 *        "STRING")
 *    @arg @c kGTLRSpanner_Type_Code_Struct Encoded as `list`, where list
 *        element `i` is represented according
 *        to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
 *        (Value: "STRUCT")
 *    @arg @c kGTLRSpanner_Type_Code_Timestamp Encoded as `string` in RFC 3339
 *        timestamp format. The time zone
 *        must be present, and must be `"Z"`.
 *        If the schema has the column option
 *        `allow_commit_timestamp=true`, the placeholder string
 *        `"spanner.commit_timestamp()"` can be used to instruct the system
 *        to insert the commit timestamp associated with the transaction
 *        commit. (Value: "TIMESTAMP")
 *    @arg @c kGTLRSpanner_Type_Code_TypeCodeUnspecified Not specified. (Value:
 *        "TYPE_CODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  If code == STRUCT, then `struct_type`
 *  provides type information for the struct's fields.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *structType;

@end


/**
 *  Metadata type for the operation returned by
 *  UpdateDatabaseDdl.
 */
@interface GTLRSpanner_UpdateDatabaseDdlMetadata : GTLRObject

/**
 *  Reports the commit timestamps of all statements that have
 *  succeeded so far, where `commit_timestamps[i]` is the commit
 *  timestamp for the statement `statements[i]`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDateTime *> *commitTimestamps;

/** The database being modified. */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  For an update this list contains all the statements. For an
 *  individual statement, this list contains only that statement.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Enqueues the given DDL statements to be applied, in order but not
 *  necessarily all at once, to the database schema at some point (or
 *  points) in the future. The server checks that the statements
 *  are executable (syntactically valid, name tables that exist, etc.)
 *  before enqueueing them, but they may still fail upon
 *  later execution (e.g., if a statement from another batch of
 *  statements is applied first and it conflicts in some way, or if
 *  there is some data-related problem like a `NULL` value in a column to
 *  which `NOT NULL` would be added). If a statement fails, all
 *  subsequent statements in the batch are automatically cancelled.
 *  Each batch of statements is assigned a name which can be used with
 *  the Operations API to monitor
 *  progress. See the
 *  operation_id field for more
 *  details.
 */
@interface GTLRSpanner_UpdateDatabaseDdlRequest : GTLRObject

/**
 *  If empty, the new update request is assigned an
 *  automatically-generated operation ID. Otherwise, `operation_id`
 *  is used to construct the name of the resulting
 *  Operation.
 *  Specifying an explicit operation ID simplifies determining
 *  whether the statements were executed in the event that the
 *  UpdateDatabaseDdl call is replayed,
 *  or the return value is otherwise lost: the database and
 *  `operation_id` fields can be combined to form the
 *  name of the resulting
 *  longrunning.Operation: `<database>/operations/<operation_id>`.
 *  `operation_id` should be unique within the database, and must be
 *  a valid identifier: `a-z*`. Note that
 *  automatically-generated operation IDs always begin with an
 *  underscore. If the named operation already exists,
 *  UpdateDatabaseDdl returns
 *  `ALREADY_EXISTS`.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** DDL statements to be applied to the database. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Metadata type for the operation returned by
 *  UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is
 *  in the process of undoing itself (which is guaranteed to succeed) and
 *  cannot be cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The desired end state of the update. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  The time at which UpdateInstance
 *  request was received.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceRequest : GTLRObject

/**
 *  Required. A mask specifying which fields in
 *  [][google.spanner.admin.instance.v1.UpdateInstanceRequest.instance] should
 *  be updated.
 *  The field mask must always be specified; this prevents any future fields in
 *  [][google.spanner.admin.instance.v1.Instance] from being erased accidentally
 *  by clients that do not know
 *  about them.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *fieldMask;

/**
 *  Required. The instance to update, which must always include the instance
 *  name. Otherwise, only fields mentioned in
 *  [][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask] need
 *  be included.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

@end


/**
 *  Arguments to insert, update, insert_or_update, and
 *  replace operations.
 */
@interface GTLRSpanner_Write : GTLRObject

/**
 *  The names of the columns in table to be written.
 *  The list of columns must contain enough columns to allow
 *  Cloud Spanner to derive values for all primary key columns in the
 *  row(s) to be modified.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/** Required. The table whose rows will be written. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The values to be written. `values` can contain more than one
 *  list of values. If it does, then multiple rows are written, one
 *  for each entry in `values`. Each list in `values` must have
 *  exactly as many entries as there are entries in columns
 *  above. Sending multiple lists is equivalent to sending multiple
 *  `Mutation`s, each containing one `values` entry and repeating
 *  table and columns. Individual values in each list are
 *  encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *values;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
