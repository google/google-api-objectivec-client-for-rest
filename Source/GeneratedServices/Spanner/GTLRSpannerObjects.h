// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Spanner API (spanner/v1)
// Description:
//   Cloud Spanner is a managed, mission-critical, globally consistent and
//   scalable relational database service.
// Documentation:
//   https://cloud.google.com/spanner/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRSpanner_Backup;
@class GTLRSpanner_BackupInfo;
@class GTLRSpanner_Binding;
@class GTLRSpanner_ChildLink;
@class GTLRSpanner_Database;
@class GTLRSpanner_Delete;
@class GTLRSpanner_ExecuteSqlRequest_Params;
@class GTLRSpanner_ExecuteSqlRequest_ParamTypes;
@class GTLRSpanner_Expr;
@class GTLRSpanner_Field;
@class GTLRSpanner_GetPolicyOptions;
@class GTLRSpanner_Instance;
@class GTLRSpanner_Instance_Labels;
@class GTLRSpanner_InstanceConfig;
@class GTLRSpanner_KeyRange;
@class GTLRSpanner_KeySet;
@class GTLRSpanner_Mutation;
@class GTLRSpanner_Operation;
@class GTLRSpanner_Operation_Metadata;
@class GTLRSpanner_Operation_Response;
@class GTLRSpanner_OperationProgress;
@class GTLRSpanner_Partition;
@class GTLRSpanner_PartitionedDml;
@class GTLRSpanner_PartitionOptions;
@class GTLRSpanner_PartitionQueryRequest_Params;
@class GTLRSpanner_PartitionQueryRequest_ParamTypes;
@class GTLRSpanner_PlanNode;
@class GTLRSpanner_PlanNode_ExecutionStats;
@class GTLRSpanner_PlanNode_Metadata;
@class GTLRSpanner_Policy;
@class GTLRSpanner_QueryOptions;
@class GTLRSpanner_QueryPlan;
@class GTLRSpanner_ReadOnly;
@class GTLRSpanner_ReadWrite;
@class GTLRSpanner_ReplicaInfo;
@class GTLRSpanner_RestoreInfo;
@class GTLRSpanner_ResultSet;
@class GTLRSpanner_ResultSetMetadata;
@class GTLRSpanner_ResultSetStats;
@class GTLRSpanner_ResultSetStats_QueryStats;
@class GTLRSpanner_Session;
@class GTLRSpanner_Session_Labels;
@class GTLRSpanner_ShortRepresentation;
@class GTLRSpanner_ShortRepresentation_Subqueries;
@class GTLRSpanner_Statement;
@class GTLRSpanner_Statement_Params;
@class GTLRSpanner_Statement_ParamTypes;
@class GTLRSpanner_Status;
@class GTLRSpanner_Status_Details_Item;
@class GTLRSpanner_StructType;
@class GTLRSpanner_Transaction;
@class GTLRSpanner_TransactionOptions;
@class GTLRSpanner_TransactionSelector;
@class GTLRSpanner_Type;
@class GTLRSpanner_Write;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRSpanner_Backup.state

/**
 *  The pending backup is still being created. Operations on the
 *  backup may fail with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_Creating;
/**
 *  The backup is complete and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Backup_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Database.state

/**
 *  The database is still being created. Operations on the database may fail
 *  with `FAILED_PRECONDITION` in this state.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_Creating;
/**
 *  The database is fully created and ready for use.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_Ready;
/**
 *  The database is fully created and ready for use, but is still
 *  being optimized for performance and cannot handle full load.
 *  In this state, the database still references the backup
 *  it was restore from, preventing the backup
 *  from being deleted. When optimizations are complete, the full performance
 *  of the database will be restored, and the database will transition to
 *  `READY` state.
 *
 *  Value: "READY_OPTIMIZING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_ReadyOptimizing;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Database_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_ExecuteSqlRequest.queryMode

/**
 *  The default mode. Only the statement results are returned.
 *
 *  Value: "NORMAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal;
/**
 *  This mode returns only the query plan, without any results or
 *  execution statistics information.
 *
 *  Value: "PLAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan;
/**
 *  This mode returns both the query plan and the execution statistics along
 *  with the results.
 *
 *  Value: "PROFILE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile;

// ----------------------------------------------------------------------------
// GTLRSpanner_Instance.state

/**
 *  The instance is still being created. Resources may not be
 *  available yet, and operations such as database creation may not
 *  work.
 *
 *  Value: "CREATING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_Creating;
/**
 *  The instance is fully created and ready to do work such as
 *  creating databases.
 *
 *  Value: "READY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_Ready;
/**
 *  Not specified.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Instance_State_StateUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_PlanNode.kind

/**
 *  Not specified.
 *
 *  Value: "KIND_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_KindUnspecified;
/**
 *  Denotes a Relational operator node in the expression tree. Relational
 *  operators represent iterative processing of rows during query execution.
 *  For example, a `TableScan` operation that reads rows from a table.
 *
 *  Value: "RELATIONAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Relational;
/**
 *  Denotes a Scalar node in the expression tree. Scalar nodes represent
 *  non-iterable entities in the query plan. For example, constants or
 *  arithmetic operators appearing inside predicate expressions or references
 *  to column names.
 *
 *  Value: "SCALAR"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_PlanNode_Kind_Scalar;

// ----------------------------------------------------------------------------
// GTLRSpanner_ReplicaInfo.type

/**
 *  Read-only replicas only support reads (not writes). Read-only replicas:
 *  * Maintain a full copy of your data.
 *  * Serve reads.
 *  * Do not participate in voting to commit writes.
 *  * Are not eligible to become a leader.
 *
 *  Value: "READ_ONLY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_ReadOnly;
/**
 *  Read-write replicas support both reads and writes. These replicas:
 *  * Maintain a full copy of your data.
 *  * Serve reads.
 *  * Can vote whether to commit a write.
 *  * Participate in leadership election.
 *  * Are eligible to become a leader.
 *
 *  Value: "READ_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_ReadWrite;
/**
 *  Not specified.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_TypeUnspecified;
/**
 *  Witness replicas don't support reads but do participate in voting to
 *  commit writes. Witness replicas:
 *  * Do not maintain a full copy of data.
 *  * Do not serve reads.
 *  * Vote whether to commit writes.
 *  * Participate in leader election but are not eligible to become leader.
 *
 *  Value: "WITNESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_ReplicaInfo_Type_Witness;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreDatabaseMetadata.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseMetadata_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreDatabaseMetadata_SourceType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_RestoreInfo.sourceType

/**
 *  A backup was used as the source of the restore.
 *
 *  Value: "BACKUP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreInfo_SourceType_Backup;
/**
 *  No restore associated.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_RestoreInfo_SourceType_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRSpanner_Type.code

/**
 *  Encoded as `list`, where the list elements are represented
 *  according to
 *  array_element_type.
 *
 *  Value: "ARRAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Array;
/**
 *  Encoded as JSON `true` or `false`.
 *
 *  Value: "BOOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Bool;
/**
 *  Encoded as a base64-encoded `string`, as described in RFC 4648,
 *  section 4.
 *
 *  Value: "BYTES"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Bytes;
/**
 *  Encoded as `string` in RFC 3339 date format.
 *
 *  Value: "DATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Date;
/**
 *  Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or
 *  `"-Infinity"`.
 *
 *  Value: "FLOAT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Float64;
/**
 *  Encoded as `string`, in decimal format.
 *
 *  Value: "INT64"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Int64;
/**
 *  Encoded as `string`.
 *
 *  Value: "STRING"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_String;
/**
 *  Encoded as `list`, where list element `i` is represented according
 *  to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
 *
 *  Value: "STRUCT"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Struct;
/**
 *  Encoded as `string` in RFC 3339 timestamp format. The time zone
 *  must be present, and must be `"Z"`.
 *  If the schema has the column option
 *  `allow_commit_timestamp=true`, the placeholder string
 *  `"spanner.commit_timestamp()"` can be used to instruct the system
 *  to insert the commit timestamp associated with the transaction
 *  commit.
 *
 *  Value: "TIMESTAMP"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_Timestamp;
/**
 *  Not specified.
 *
 *  Value: "TYPE_CODE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRSpanner_Type_Code_TypeCodeUnspecified;

/**
 *  A backup of a Cloud Spanner database.
 */
@interface GTLRSpanner_Backup : GTLRObject

/**
 *  Output only. The backup will contain an externally consistent
 *  copy of the database at the timestamp specified by
 *  `create_time`. `create_time` is approximately the time the
 *  CreateBackup request is received.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required for the CreateBackup operation.
 *  Name of the database from which this backup was
 *  created. This needs to be in the same instance as the backup.
 *  Values are of the form
 *  `projects/<project>/instances/<instance>/databases/<database>`.
 */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  Required for the CreateBackup
 *  operation. The expiration time of the backup, with microseconds
 *  granularity that must be at least 6 hours and at most 366 days
 *  from the time the CreateBackup request is processed. Once the `expire_time`
 *  has passed, the backup is eligible to be automatically deleted by Cloud
 *  Spanner to free the resources used by the backup.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

/**
 *  Output only for the CreateBackup operation.
 *  Required for the UpdateBackup operation.
 *  A globally unique identifier for the backup which cannot be
 *  changed. Values are of the form
 *  `projects/<project>/instances/<instance>/backups/a-z*[a-z0-9]`
 *  The final segment of the name must be between 2 and 60 characters
 *  in length.
 *  The backup is stored in the location(s) specified in the instance
 *  configuration of the instance containing the backup, identified
 *  by the prefix of the backup name of the form
 *  `projects/<project>/instances/<instance>`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. The names of the restored databases that reference the backup.
 *  The database names are of
 *  the form `projects/<project>/instances/<instance>/databases/<database>`.
 *  Referencing databases may exist in different instances. The existence of
 *  any referencing database prevents the backup from being deleted. When a
 *  restored database from the backup enters the `READY` state, the reference
 *  to the backup is removed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *referencingDatabases;

/**
 *  Output only. Size of the backup in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeBytes;

/**
 *  Output only. The current state of the backup.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Backup_State_Creating The pending backup is still
 *        being created. Operations on the
 *        backup may fail with `FAILED_PRECONDITION` in this state. (Value:
 *        "CREATING")
 *    @arg @c kGTLRSpanner_Backup_State_Ready The backup is complete and ready
 *        for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Backup_State_StateUnspecified Not specified. (Value:
 *        "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Information about a backup.
 */
@interface GTLRSpanner_BackupInfo : GTLRObject

/** Name of the backup. */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  The backup contains an externally consistent copy of `source_database` at
 *  the timestamp specified by `create_time`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Name of the database the backup was created from. */
@property(nonatomic, copy, nullable) NSString *sourceDatabase;

@end


/**
 *  The request for BatchCreateSessions.
 */
@interface GTLRSpanner_BatchCreateSessionsRequest : GTLRObject

/**
 *  Required. The number of sessions to be created in this batch call.
 *  The API may return fewer than the requested number of sessions. If a
 *  specific number of sessions are desired, the client can make additional
 *  calls to BatchCreateSessions (adjusting
 *  session_count as necessary).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sessionCount;

/** Parameters to be applied to each created session. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *sessionTemplate;

@end


/**
 *  The response for BatchCreateSessions.
 */
@interface GTLRSpanner_BatchCreateSessionsResponse : GTLRObject

/** The freshly created sessions. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *session;

@end


/**
 *  The request for BeginTransaction.
 */
@interface GTLRSpanner_BeginTransactionRequest : GTLRObject

/** Required. Options for the new transaction. */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *options;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRSpanner_Binding : GTLRObject

/**
 *  The condition that is associated with this binding.
 *  If the condition evaluates to `true`, then this binding applies to the
 *  current request.
 *  If the condition evaluates to `false`, then this binding does not apply to
 *  the current request. However, a different role binding might grant the same
 *  role to one or more of the members in this binding.
 *  To learn which resources support conditions in their IAM policies, see the
 *  [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values:
 *  * `allUsers`: A special identifier that represents anyone who is
 *  on the internet; with or without a Google account.
 *  * `allAuthenticatedUsers`: A special identifier that represents anyone
 *  who is authenticated with a Google account or a service account.
 *  * `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@example.com` .
 *  * `serviceAccount:{emailid}`: An email address that represents a service
 *  account. For example, `my-other-app\@appspot.gserviceaccount.com`.
 *  * `group:{emailid}`: An email address that represents a Google group.
 *  For example, `admins\@example.com`.
 *  * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For
 *  example, `alice\@example.com?uid=123456789012345678901`. If the user is
 *  recovered, this value reverts to `user:{emailid}` and the recovered user
 *  retains the role in the binding.
 *  * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
 *  unique identifier) representing a service account that has been recently
 *  deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`.
 *  If the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding.
 *  * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a Google group that has been recently
 *  deleted. For example, `admins\@example.com?uid=123456789012345678901`. If
 *  the group is recovered, this value reverts to `group:{emailid}` and the
 *  recovered group retains the role in the binding.
 *  * `domain:{domain}`: The G Suite domain (primary) that represents all the
 *  users of that domain. For example, `google.com` or `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`.
 *  For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Metadata associated with a parent-child relationship appearing in a
 *  PlanNode.
 */
@interface GTLRSpanner_ChildLink : GTLRObject

/**
 *  The node to which the link points.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *childIndex;

/**
 *  The type of the link. For example, in Hash Joins this could be used to
 *  distinguish between the build child and the probe child, or in the case
 *  of the child being an output variable, to represent the tag associated
 *  with the output variable.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Only present if the child node is SCALAR and corresponds
 *  to an output variable of the parent node. The field carries the name of
 *  the output variable.
 *  For example, a `TableScan` operator that reads rows from a table will
 *  have child links to the `SCALAR` nodes representing the output variables
 *  created for each column that is read by the operator. The corresponding
 *  `variable` fields will be set to the variable names assigned to the
 *  columns.
 */
@property(nonatomic, copy, nullable) NSString *variable;

@end


/**
 *  The request for Commit.
 */
@interface GTLRSpanner_CommitRequest : GTLRObject

/**
 *  The mutations to be executed when this transaction commits. All
 *  mutations are applied atomically, in the order they appear in
 *  this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Mutation *> *mutations;

/**
 *  Execute mutations in a temporary transaction. Note that unlike
 *  commit of a previously-started transaction, commit with a
 *  temporary transaction is non-idempotent. That is, if the
 *  `CommitRequest` is sent to Cloud Spanner more than once (for
 *  instance, due to retries in the application, or in the
 *  transport library), it is possible that the mutations are
 *  executed more than once. If this is undesirable, use
 *  BeginTransaction and
 *  Commit instead.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUseTransaction;

/**
 *  Commit a previously-started transaction.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  The response for Commit.
 */
@interface GTLRSpanner_CommitResponse : GTLRObject

/** The Cloud Spanner timestamp at which the transaction committed. */
@property(nonatomic, strong, nullable) GTLRDateTime *commitTimestamp;

@end


/**
 *  Metadata type for the operation returned by
 *  CreateBackup.
 */
@interface GTLRSpanner_CreateBackupMetadata : GTLRObject

/**
 *  The time at which cancellation of this operation was received.
 *  Operations.CancelOperation
 *  starts asynchronous cancellation on a long-running operation. The server
 *  makes a best effort to cancel the operation, but success is not guaranteed.
 *  Clients can use
 *  Operations.GetOperation or
 *  other methods to check whether the cancellation succeeded or whether the
 *  operation completed despite cancellation. On successful cancellation,
 *  the operation is not deleted; instead, it becomes an operation with
 *  an Operation.error value with a google.rpc.Status.code of 1,
 *  corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The name of the database the backup is created from. */
@property(nonatomic, copy, nullable) NSString *database;

/** The name of the backup being created. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The progress of the
 *  CreateBackup operation.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

@end


/**
 *  Metadata type for the operation returned by
 *  CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseMetadata : GTLRObject

/** The database being created. */
@property(nonatomic, copy, nullable) NSString *database;

@end


/**
 *  The request for CreateDatabase.
 */
@interface GTLRSpanner_CreateDatabaseRequest : GTLRObject

/**
 *  Required. A `CREATE DATABASE` statement, which specifies the ID of the
 *  new database. The database ID must conform to the regular expression
 *  `a-z*[a-z0-9]` and be between 2 and 30 characters in length.
 *  If the database ID is a reserved word or if it contains a hyphen, the
 *  database ID must be enclosed in backticks (`` ` ``).
 */
@property(nonatomic, copy, nullable) NSString *createStatement;

/**
 *  Optional. A list of DDL statements to run inside the newly created
 *  database. Statements can create tables, indexes, etc. These
 *  statements execute atomically with the creation of the database:
 *  if there is an error in any statement, the database is not created.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *extraStatements;

@end


/**
 *  Metadata type for the operation returned by
 *  CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is
 *  in the process of undoing itself (which is guaranteed to succeed) and
 *  cannot be cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The instance being created. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  The time at which the
 *  CreateInstance request was
 *  received.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for CreateInstance.
 */
@interface GTLRSpanner_CreateInstanceRequest : GTLRObject

/**
 *  Required. The instance to create. The name may be omitted, but if
 *  specified must be `<parent>/instances/<instance_id>`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  Required. The ID of the instance to create. Valid identifiers are of the
 *  form `a-z*[a-z0-9]` and must be between 2 and 64 characters in
 *  length.
 */
@property(nonatomic, copy, nullable) NSString *instanceId;

@end


/**
 *  The request for CreateSession.
 */
@interface GTLRSpanner_CreateSessionRequest : GTLRObject

/** Required. The session to create. */
@property(nonatomic, strong, nullable) GTLRSpanner_Session *session;

@end


/**
 *  A Cloud Spanner database.
 */
@interface GTLRSpanner_Database : GTLRObject

/**
 *  Output only. If exists, the time at which the database creation started.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Required. The name of the database. Values are of the form
 *  `projects/<project>/instances/<instance>/databases/<database>`,
 *  where `<database>` is as specified in the `CREATE DATABASE`
 *  statement. This name can be passed to other API methods to
 *  identify the database.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Output only. Applicable only for restored databases. Contains information
 *  about the restore source.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_RestoreInfo *restoreInfo;

/**
 *  Output only. The current database state.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Database_State_Creating The database is still being
 *        created. Operations on the database may fail
 *        with `FAILED_PRECONDITION` in this state. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Database_State_Ready The database is fully created
 *        and ready for use. (Value: "READY")
 *    @arg @c kGTLRSpanner_Database_State_ReadyOptimizing The database is fully
 *        created and ready for use, but is still
 *        being optimized for performance and cannot handle full load.
 *        In this state, the database still references the backup
 *        it was restore from, preventing the backup
 *        from being deleted. When optimizations are complete, the full
 *        performance
 *        of the database will be restored, and the database will transition to
 *        `READY` state. (Value: "READY_OPTIMIZING")
 *    @arg @c kGTLRSpanner_Database_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Arguments to delete operations.
 */
@interface GTLRSpanner_Delete : GTLRObject

/**
 *  Required. The primary keys of the rows within table to delete. The
 *  primary keys must be specified in the order in which they appear in the
 *  `PRIMARY KEY()` clause of the table's equivalent DDL statement (the DDL
 *  statement used to create the table).
 *  Delete is idempotent. The transaction will succeed even if some or all
 *  rows do not exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Required. The table whose rows will be deleted. */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRSpanner_Empty : GTLRObject
@end


/**
 *  The request for ExecuteBatchDml.
 */
@interface GTLRSpanner_ExecuteBatchDmlRequest : GTLRObject

/**
 *  Required. A per-transaction sequence number used to identify this request.
 *  This field
 *  makes each request idempotent such that if the request is received multiple
 *  times, at most one will succeed.
 *  The sequence number must be monotonically increasing within the
 *  transaction. If a request arrives for the first time with an out-of-order
 *  sequence number, the transaction may be aborted. Replays of previously
 *  handled requests will yield the same response as the first execution.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/**
 *  Required. The list of statements to execute in this batch. Statements are
 *  executed
 *  serially, such that the effects of statement `i` are visible to statement
 *  `i+1`. Each statement must be a DML statement. Execution stops at the
 *  first failed statement; the remaining statements are not executed.
 *  Callers must provide at least one statement.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Statement *> *statements;

/**
 *  Required. The transaction to use. Must be a read-write transaction.
 *  To protect against replays, single-use transactions are not supported. The
 *  caller must either supply an existing transaction ID or begin a new
 *  transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for ExecuteBatchDml. Contains a list
 *  of ResultSet messages, one for each DML statement that has successfully
 *  executed, in the same order as the statements in the request. If a statement
 *  fails, the status in the response body identifies the cause of the failure.
 *  To check for DML statements that failed, use the following approach:
 *  1. Check the status in the response message. The google.rpc.Code enum
 *  value `OK` indicates that all statements were executed successfully.
 *  2. If the status was not `OK`, check the number of result sets in the
 *  response. If the response contains `N` ResultSet messages, then
 *  statement `N+1` in the request failed.
 *  Example 1:
 *  * Request: 5 DML statements, all executed successfully.
 *  * Response: 5 ResultSet messages, with the status `OK`.
 *  Example 2:
 *  * Request: 5 DML statements. The third statement has a syntax error.
 *  * Response: 2 ResultSet messages, and a syntax error (`INVALID_ARGUMENT`)
 *  status. The number of ResultSet messages indicates that the third
 *  statement failed, and the fourth and fifth statements were not executed.
 */
@interface GTLRSpanner_ExecuteBatchDmlResponse : GTLRObject

/**
 *  One ResultSet for each statement in the request that ran successfully,
 *  in the same order as the statements in the request. Each ResultSet does
 *  not contain any rows. The ResultSetStats in each ResultSet contain
 *  the number of rows modified by the statement.
 *  Only the first ResultSet in the response contains valid
 *  ResultSetMetadata.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ResultSet *> *resultSets;

/**
 *  If all DML statements are executed successfully, the status is `OK`.
 *  Otherwise, the error status of the first failed statement.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *status;

@end


/**
 *  The request for ExecuteSql and
 *  ExecuteStreamingSql.
 */
@interface GTLRSpanner_ExecuteSqlRequest : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the SQL string.
 *  A parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL statement parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ExecuteSqlRequest_ParamTypes *paramTypes;

/**
 *  If present, results will be restricted to the specified partition
 *  previously created using PartitionQuery(). There must be an exact
 *  match for the values of fields common to this message and the
 *  PartitionQueryRequest message used to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  Used to control the amount of debugging information returned in
 *  ResultSetStats. If partition_token is set, query_mode can only
 *  be set to QueryMode.NORMAL.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Normal The default mode.
 *        Only the statement results are returned. (Value: "NORMAL")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Plan This mode returns
 *        only the query plan, without any results or
 *        execution statistics information. (Value: "PLAN")
 *    @arg @c kGTLRSpanner_ExecuteSqlRequest_QueryMode_Profile This mode returns
 *        both the query plan and the execution statistics along
 *        with the results. (Value: "PROFILE")
 */
@property(nonatomic, copy, nullable) NSString *queryMode;

/** Query optimizer configuration to use for the given query. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryOptions *queryOptions;

/**
 *  If this request is resuming a previously interrupted SQL statement
 *  execution, `resume_token` should be copied from the last
 *  PartialResultSet yielded before the interruption. Doing this
 *  enables the new SQL statement execution to resume where the last one left
 *  off. The rest of the request parameters must exactly match the
 *  request that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  A per-transaction sequence number used to identify this request. This field
 *  makes each request idempotent such that if the request is received multiple
 *  times, at most one will succeed.
 *  The sequence number must be monotonically increasing within the
 *  transaction. If a request arrives for the first time with an out-of-order
 *  sequence number, the transaction may be aborted. Replays of previously
 *  handled requests will yield the same response as the first execution.
 *  Required for DML statements. Ignored for queries.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *seqno;

/** Required. The SQL string. */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  The transaction to use.
 *  For queries, if none is provided, the default is a temporary read-only
 *  transaction with strong concurrency.
 *  Standard DML statements require a read-write transaction. To protect
 *  against replays, single-use transactions are not supported. The caller
 *  must either supply an existing transaction ID or begin a new transaction.
 *  Partitioned DML requires an existing Partitioned DML transaction ID.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Parameter names and values that bind to placeholders in the SQL string.
 *  A parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL statement parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ExecuteSqlRequest_ParamTypes : GTLRObject
@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec.
 *  Example (Comparison):
 *  title: "Summary size limit"
 *  description: "Determines if a summary is less than 100 chars"
 *  expression: "document.summary.size() < 100"
 *  Example (Equality):
 *  title: "Requestor is owner"
 *  description: "Determines if requestor is the document owner"
 *  expression: "document.owner == request.auth.claims.email"
 *  Example (Logic):
 *  title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation):
 *  title: "Notification string"
 *  description: "Create a notification string with a timestamp."
 *  expression: "'New message received at ' + string(document.create_time)"
 *  The exact variables and functions that may be referenced within an
 *  expression
 *  are determined by the service that evaluates it. See the service
 *  documentation for additional information.
 */
@interface GTLRSpanner_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing
 *  its purpose. This can be used e.g. in UIs which allow to enter the
 *  expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Message representing a single field of a struct.
 */
@interface GTLRSpanner_Field : GTLRObject

/**
 *  The name of the field. For reads, this is the column name. For
 *  SQL queries, it is the column alias (e.g., `"Word"` in the
 *  query `"SELECT 'hello' AS Word"`), or the column name (e.g.,
 *  `"ColName"` in the query `"SELECT ColName FROM Table"`). Some
 *  columns might have an empty name (e.g., !"SELECT
 *  UPPER(ColName)"`). Note that a query result can contain
 *  multiple fields with the same name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The type of the field. */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *type;

@end


/**
 *  The response for GetDatabaseDdl.
 */
@interface GTLRSpanner_GetDatabaseDdlResponse : GTLRObject

/**
 *  A list of formatted DDL statements defining the schema of the database
 *  specified in the request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRSpanner_GetIamPolicyRequest : GTLRObject

/**
 *  OPTIONAL: A `GetPolicyOptions` object for specifying options to
 *  `GetIamPolicy`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_GetPolicyOptions *options;

@end


/**
 *  Encapsulates settings provided to GetIamPolicy.
 */
@interface GTLRSpanner_GetPolicyOptions : GTLRObject

/**
 *  Optional. The policy format version to be returned.
 *  Valid values are 0, 1, and 3. Requests specifying an invalid value will be
 *  rejected.
 *  Requests for policies with any conditional bindings must specify version 3.
 *  Policies without any conditional bindings may specify any valid value or
 *  leave the field unset.
 *  To learn which resources support conditions in their IAM policies, see the
 *  [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestedPolicyVersion;

@end


/**
 *  An isolated set of Cloud Spanner resources on which databases can be hosted.
 */
@interface GTLRSpanner_Instance : GTLRObject

/**
 *  Required. The name of the instance's configuration. Values are of the form
 *  `projects/<project>/instanceConfigs/<configuration>`. See
 *  also InstanceConfig and
 *  ListInstanceConfigs.
 */
@property(nonatomic, copy, nullable) NSString *config;

/**
 *  Required. The descriptive name for this instance as it appears in UIs.
 *  Must be unique per project and between 4 and 30 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Deprecated. This field is not populated. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *endpointUris;

/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.).
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given resource.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 *  If you plan to use labels in your own code, please note that additional
 *  characters may be allowed in the future. And so you are advised to use an
 *  internal label representation, such as JSON, which doesn't rely upon
 *  specific characters being disallowed. For example, representing labels
 *  as the string: name + "_" + value would prove problematic if we were to
 *  allow "_" in a future release.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance_Labels *labels;

/**
 *  Required. A unique identifier for the instance, which cannot be changed
 *  after the instance is created. Values are of the form
 *  `projects/<project>/instances/a-z*[a-z0-9]`. The final
 *  segment of the name must be between 2 and 64 characters in length.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The number of nodes allocated to this instance. This
 *  may be zero in API responses for instances that are not yet in state
 *  `READY`.
 *  See [the
 *  documentation](https://cloud.google.com/spanner/docs/instances#node_count)
 *  for more information about nodes.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nodeCount;

/**
 *  Output only. The current instance state. For
 *  CreateInstance, the state must be
 *  either omitted or set to `CREATING`. For
 *  UpdateInstance, the state must be
 *  either omitted or set to `READY`.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Instance_State_Creating The instance is still being
 *        created. Resources may not be
 *        available yet, and operations such as database creation may not
 *        work. (Value: "CREATING")
 *    @arg @c kGTLRSpanner_Instance_State_Ready The instance is fully created
 *        and ready to do work such as
 *        creating databases. (Value: "READY")
 *    @arg @c kGTLRSpanner_Instance_State_StateUnspecified Not specified.
 *        (Value: "STATE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Cloud Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. Cloud Labels can be used to filter collections of
 *  resources. They can be used to control how resource metrics are aggregated.
 *  And they can be used as arguments to policy management rules (e.g. route,
 *  firewall, load balancing, etc.).
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given resource.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 *  If you plan to use labels in your own code, please note that additional
 *  characters may be allowed in the future. And so you are advised to use an
 *  internal label representation, such as JSON, which doesn't rely upon
 *  specific characters being disallowed. For example, representing labels
 *  as the string: name + "_" + value would prove problematic if we were to
 *  allow "_" in a future release.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Instance_Labels : GTLRObject
@end


/**
 *  A possible configuration for a Cloud Spanner instance. Configurations
 *  define the geographic placement of nodes and their replication.
 */
@interface GTLRSpanner_InstanceConfig : GTLRObject

/** The name of this instance configuration as it appears in UIs. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  A unique identifier for the instance configuration. Values
 *  are of the form
 *  `projects/<project>/instanceConfigs/a-z*`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The geographic placement of nodes in this instance configuration and their
 *  replication properties.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ReplicaInfo *> *replicas;

@end


/**
 *  KeyRange represents a range of rows in a table or index.
 *  A range has a start key and an end key. These keys can be open or
 *  closed, indicating if the range includes rows with that key.
 *  Keys are represented by lists, where the ith value in the list
 *  corresponds to the ith component of the table or index primary key.
 *  Individual values are encoded as described
 *  here.
 *  For example, consider the following table definition:
 *  CREATE TABLE UserEvents (
 *  UserName STRING(MAX),
 *  EventDate STRING(10)
 *  ) PRIMARY KEY(UserName, EventDate);
 *  The following keys name rows in this table:
 *  "Bob", "2014-09-23"
 *  Since the `UserEvents` table's `PRIMARY KEY` clause names two
 *  columns, each `UserEvents` key has two elements; the first is the
 *  `UserName`, and the second is the `EventDate`.
 *  Key ranges with multiple components are interpreted
 *  lexicographically by component using the table or index key's declared
 *  sort order. For example, the following range returns all events for
 *  user `"Bob"` that occurred in the year 2015:
 *  "start_closed": ["Bob", "2015-01-01"]
 *  "end_closed": ["Bob", "2015-12-31"]
 *  Start and end keys can omit trailing key components. This affects the
 *  inclusion and exclusion of rows that exactly match the provided key
 *  components: if the key is closed, then rows that exactly match the
 *  provided components are included; if the key is open, then rows
 *  that exactly match are not included.
 *  For example, the following range includes all events for `"Bob"` that
 *  occurred during and after the year 2000:
 *  "start_closed": ["Bob", "2000-01-01"]
 *  "end_closed": ["Bob"]
 *  The next example retrieves all events for `"Bob"`:
 *  "start_closed": ["Bob"]
 *  "end_closed": ["Bob"]
 *  To retrieve events before the year 2000:
 *  "start_closed": ["Bob"]
 *  "end_open": ["Bob", "2000-01-01"]
 *  The following range includes all rows in the table:
 *  "start_closed": []
 *  "end_closed": []
 *  This range returns all users whose `UserName` begins with any
 *  character from A to C:
 *  "start_closed": ["A"]
 *  "end_open": ["D"]
 *  This range returns all users whose `UserName` begins with B:
 *  "start_closed": ["B"]
 *  "end_open": ["C"]
 *  Key ranges honor column sort order. For example, suppose a table is
 *  defined as follows:
 *  CREATE TABLE DescendingSortedTable {
 *  Key INT64,
 *  ...
 *  ) PRIMARY KEY(Key DESC);
 *  The following range retrieves all rows with key values between 1
 *  and 100 inclusive:
 *  "start_closed": ["100"]
 *  "end_closed": ["1"]
 *  Note that 100 is passed as the start, and 1 is passed as the end,
 *  because `Key` is a descending column in the schema.
 */
@interface GTLRSpanner_KeyRange : GTLRObject

/**
 *  If the end is closed, then the range includes all rows whose
 *  first `len(end_closed)` key columns exactly match `end_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endClosed;

/**
 *  If the end is open, then the range excludes rows whose first
 *  `len(end_open)` key columns exactly match `end_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *endOpen;

/**
 *  If the start is closed, then the range includes all rows whose
 *  first `len(start_closed)` key columns exactly match `start_closed`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startClosed;

/**
 *  If the start is open, then the range excludes rows whose first
 *  `len(start_open)` key columns exactly match `start_open`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *startOpen;

@end


/**
 *  `KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All
 *  the keys are expected to be in the same table or index. The keys need
 *  not be sorted in any particular way.
 *  If the same key is specified multiple times in the set (for example
 *  if two ranges, two keys, or a key and a range overlap), Cloud Spanner
 *  behaves as if the key were only specified once.
 */
@interface GTLRSpanner_KeySet : GTLRObject

/**
 *  For convenience `all` can be set to `true` to indicate that this
 *  `KeySet` matches all keys in the table or index. Note that any keys
 *  specified in `keys` or `ranges` are only yielded once.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *all;

/**
 *  A list of specific keys. Entries in `keys` should have exactly as
 *  many elements as there are columns in the primary or index key
 *  with which this `KeySet` is used. Individual key values are
 *  encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *keys;

/**
 *  A list of key ranges. See KeyRange for more information about
 *  key range specifications.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_KeyRange *> *ranges;

@end


/**
 *  The response for
 *  ListBackupOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListBackupOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListBackupOperations
 *  call to fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching backup long-running
 *  operations. Each operation's name will be
 *  prefixed by the backup's name and the operation's
 *  metadata will be of type
 *  CreateBackupMetadata. Operations returned include those that are
 *  pending or have completed/failed/canceled within the last 7 days.
 *  Operations returned are ordered by
 *  `operation.metadata.value.progress.start_time` in descending order starting
 *  from the most recently started operation.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListBackups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "backups" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListBackupsResponse : GTLRCollectionObject

/**
 *  The list of matching backups. Backups returned are ordered by `create_time`
 *  in descending order, starting from the most recent `create_time`.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Backup *> *backups;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListBackups call to fetch more
 *  of the matching backups.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for
 *  ListDatabaseOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabaseOperationsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListDatabaseOperations
 *  call to fetch more of the matching metadata.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of matching database long-running
 *  operations. Each operation's name will be
 *  prefixed by the database's name. The operation's
 *  metadata field type
 *  `metadata.type_url` describes the type of the metadata.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListDatabases.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "databases" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListDatabasesResponse : GTLRCollectionObject

/**
 *  Databases that matched the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Database *> *databases;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListDatabases call to fetch more
 *  of the matching databases.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstanceConfigs.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instanceConfigs" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRSpanner_ListInstanceConfigsResponse : GTLRCollectionObject

/**
 *  The list of requested instance configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_InstanceConfig *> *instanceConfigs;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListInstanceConfigs call to
 *  fetch more of the matching instance configurations.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response for ListInstances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListInstancesResponse : GTLRCollectionObject

/**
 *  The list of requested instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Instance *> *instances;

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListInstances call to fetch more
 *  of the matching instances.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Operation *> *operations;

@end


/**
 *  The response for ListSessions.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "sessions" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRSpanner_ListSessionsResponse : GTLRCollectionObject

/**
 *  `next_page_token` can be sent in a subsequent
 *  ListSessions call to fetch more of the matching
 *  sessions.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of requested sessions.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Session *> *sessions;

@end


/**
 *  A modification to one or more Cloud Spanner rows. Mutations can be
 *  applied to a Cloud Spanner database by sending them in a
 *  Commit call.
 */
@interface GTLRSpanner_Mutation : GTLRObject

/**
 *  Delete rows from a table. Succeeds whether or not the named
 *  rows were present.
 *
 *  Remapped to 'deleteProperty' to avoid language reserved word 'delete'.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Delete *deleteProperty;

/**
 *  Insert new rows in a table. If any of the rows already exist,
 *  the write or transaction fails with error `ALREADY_EXISTS`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insert;

/**
 *  Like insert, except that if the row already exists, then
 *  its column values are overwritten with the ones provided. Any
 *  column values not explicitly written are preserved.
 *  When using insert_or_update, just as when using insert, all `NOT
 *  NULL` columns in the table must be given a value. This holds true
 *  even when the row already exists and will therefore actually be updated.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *insertOrUpdate;

/**
 *  Like insert, except that if the row already exists, it is
 *  deleted, and the column values provided are inserted
 *  instead. Unlike insert_or_update, this means any values not
 *  explicitly written become `NULL`.
 *  In an interleaved table, if you create the child table with the
 *  `ON DELETE CASCADE` annotation, then replacing a parent row
 *  also deletes the child rows. Otherwise, you must delete the
 *  child rows before you replace the parent row.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *replace;

/**
 *  Update existing rows in a table. If any of the rows does not
 *  already exist, the transaction fails with error `NOT_FOUND`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Write *update;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRSpanner_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress.
 *  If `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRSpanner_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the
 *  `name` should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Operation_Response : GTLRObject
@end


/**
 *  Encapsulates progress related information for a Cloud Spanner long
 *  running operation.
 */
@interface GTLRSpanner_OperationProgress : GTLRObject

/**
 *  If set, the time at which this operation failed or was completed
 *  successfully.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Percent completion of the operation.
 *  Values are between 0 and 100 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *progressPercent;

/** Time the request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Metadata type for the long-running operation used to track the progress
 *  of optimizations performed on a newly restored database. This long-running
 *  operation is automatically created by the system after the successful
 *  completion of a database restore, and cannot be cancelled.
 */
@interface GTLRSpanner_OptimizeRestoredDatabaseMetadata : GTLRObject

/** Name of the restored database being optimized. */
@property(nonatomic, copy, nullable) NSString *name;

/** The progress of the post-restore optimizations. */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

@end


/**
 *  Partial results from a streaming read or SQL query. Streaming reads and
 *  SQL queries better tolerate large result sets, large rows, and large
 *  values, but are a little trickier to consume.
 */
@interface GTLRSpanner_PartialResultSet : GTLRObject

/**
 *  If true, then the final value in values is chunked, and must
 *  be combined with more values from subsequent `PartialResultSet`s
 *  to obtain a complete field value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *chunkedValue;

/**
 *  Metadata about the result set, such as row type information.
 *  Only present in the first response.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Streaming calls might be interrupted for a variety of reasons, such
 *  as TCP connection loss. If this occurs, the stream of results can
 *  be resumed by re-sending the original request and including
 *  `resume_token`. Note that executing any other transaction in the
 *  same session invalidates the token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/**
 *  Query plan and execution statistics for the statement that produced this
 *  streaming result set. These can be requested by setting
 *  ExecuteSqlRequest.query_mode and are sent
 *  only once with the last response in the stream.
 *  This field will also be present in the last response for DML
 *  statements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

/**
 *  A streamed result set consists of a stream of values, which might
 *  be split into many `PartialResultSet` messages to accommodate
 *  large rows and/or large values. Every N complete values defines a
 *  row, where N is equal to the number of entries in
 *  metadata.row_type.fields.
 *  Most values are encoded based on type as described
 *  here.
 *  It is possible that the last value in values is "chunked",
 *  meaning that the rest of the value is sent in subsequent
 *  `PartialResultSet`(s). This is denoted by the chunked_value
 *  field. Two or more chunked values can be merged to form a
 *  complete value as follows:
 *  * `bool/number/null`: cannot be chunked
 *  * `string`: concatenate the strings
 *  * `list`: concatenate the lists. If the last element in a list is a
 *  `string`, `list`, or `object`, merge it with the first element in
 *  the next list by applying these rules recursively.
 *  * `object`: concatenate the (field name, field value) pairs. If a
 *  field name is duplicated, then apply these rules recursively
 *  to merge the field values.
 *  Some examples of merging:
 *  # Strings are concatenated.
 *  "foo", "bar" => "foobar"
 *  # Lists of non-strings are concatenated.
 *  [2, 3], [4] => [2, 3, 4]
 *  # Lists are concatenated, but the last and first elements are merged
 *  # because they are strings.
 *  ["a", "b"], ["c", "d"] => ["a", "bc", "d"]
 *  # Lists are concatenated, but the last and first elements are merged
 *  # because they are lists. Recursively, the last and first elements
 *  # of the inner lists are merged because they are strings.
 *  ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"]
 *  # Non-overlapping object fields are combined.
 *  {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"}
 *  # Overlapping object fields are merged.
 *  {"a": "1"}, {"a": "2"} => {"a": "12"}
 *  # Examples of merging objects containing lists of strings.
 *  {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]}
 *  For a more complete example, suppose a streaming SQL query is
 *  yielding a result set whose rows contain a single string
 *  field. The following `PartialResultSet`s might be yielded:
 *  {
 *  "metadata": { ... }
 *  "values": ["Hello", "W"]
 *  "chunked_value": true
 *  "resume_token": "Af65..."
 *  }
 *  {
 *  "values": ["orl"]
 *  "chunked_value": true
 *  "resume_token": "Bqp2..."
 *  }
 *  {
 *  "values": ["d"]
 *  "resume_token": "Zx1B..."
 *  }
 *  This sequence of `PartialResultSet`s encodes two rows, one
 *  containing the field value `"Hello"`, and a second containing the
 *  field value `"World" = "W" + "orl" + "d"`.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray *values;

@end


/**
 *  Information returned for each partition returned in a
 *  PartitionResponse.
 */
@interface GTLRSpanner_Partition : GTLRObject

/**
 *  This token can be passed to Read, StreamingRead, ExecuteSql, or
 *  ExecuteStreamingSql requests to restrict the results to those identified by
 *  this partition token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

@end


/**
 *  Message type to initiate a Partitioned DML transaction.
 */
@interface GTLRSpanner_PartitionedDml : GTLRObject
@end


/**
 *  Options for a PartitionQueryRequest and
 *  PartitionReadRequest.
 */
@interface GTLRSpanner_PartitionOptions : GTLRObject

/**
 *  **Note:** This hint is currently ignored by PartitionQuery and
 *  PartitionRead requests.
 *  The desired maximum number of partitions to return. For example, this may
 *  be set to the number of workers available. The default for this option
 *  is currently 10,000. The maximum value is currently 200,000. This is only
 *  a hint. The actual number of partitions returned may be smaller or larger
 *  than this maximum count request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxPartitions;

/**
 *  **Note:** This hint is currently ignored by PartitionQuery and
 *  PartitionRead requests.
 *  The desired data size for each partition generated. The default for this
 *  option is currently 1 GiB. This is only a hint. The actual size of each
 *  partition may be smaller or larger than this size request.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionSizeBytes;

@end


/**
 *  The request for PartitionQuery
 */
@interface GTLRSpanner_PartitionQueryRequest : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the SQL string.
 *  A parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL query parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionQueryRequest_ParamTypes *paramTypes;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/**
 *  Required. The query request to generate partitions for. The request will
 *  fail if
 *  the query is not root partitionable. The query plan of a root
 *  partitionable query has a single distributed union operator. A distributed
 *  union operator conceptually divides one or more tables into multiple
 *  splits, remotely evaluates a subquery independently on each split, and
 *  then unions all results.
 *  This must not contain DML commands, such as INSERT, UPDATE, or
 *  DELETE. Use ExecuteStreamingSql with a
 *  PartitionedDml transaction for large, partition-friendly DML operations.
 */
@property(nonatomic, copy, nullable) NSString *sql;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Parameter names and values that bind to placeholders in the SQL string.
 *  A parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The same
 *  parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL query parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PartitionQueryRequest_ParamTypes : GTLRObject
@end


/**
 *  The request for PartitionRead
 */
@interface GTLRSpanner_PartitionReadRequest : GTLRObject

/**
 *  The columns of table to be returned for each row matching
 *  this request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is
 *  used instead of the table primary key when interpreting key_set
 *  and sorting result rows. See key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index
 *  is present. If index is present, then key_set instead names
 *  index keys in index.
 *  It is not an error for the `key_set` to name rows that do not
 *  exist in the database. Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/** Additional options that affect how many partitions are created. */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionOptions *partitionOptions;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  Read only snapshot transactions are supported, read/write and single use
 *  transactions are not.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  The response for PartitionQuery
 *  or PartitionRead
 */
@interface GTLRSpanner_PartitionResponse : GTLRObject

/** Partitions created by this request. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Partition *> *partitions;

/** Transaction created by this request. */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

@end


/**
 *  Node information for nodes appearing in a QueryPlan.plan_nodes.
 */
@interface GTLRSpanner_PlanNode : GTLRObject

/** List of child node `index`es and their relationship to this parent. */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_ChildLink *> *childLinks;

/** The display name for the node. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_ExecutionStats *executionStats;

/**
 *  The `PlanNode`'s index in node list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Used to determine the type of node. May be needed for visualizing
 *  different kinds of nodes differently. For example, If the node is a
 *  SCALAR node, it will have a condensed representation
 *  which can be used to directly embed a description of the node in its
 *  parent.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_PlanNode_Kind_KindUnspecified Not specified. (Value:
 *        "KIND_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Relational Denotes a Relational
 *        operator node in the expression tree. Relational
 *        operators represent iterative processing of rows during query
 *        execution.
 *        For example, a `TableScan` operation that reads rows from a table.
 *        (Value: "RELATIONAL")
 *    @arg @c kGTLRSpanner_PlanNode_Kind_Scalar Denotes a Scalar node in the
 *        expression tree. Scalar nodes represent
 *        non-iterable entities in the query plan. For example, constants or
 *        arithmetic operators appearing inside predicate expressions or
 *        references
 *        to column names. (Value: "SCALAR")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Attributes relevant to the node contained in a group of key-value pairs.
 *  For example, a Parameter Reference node could have the following
 *  information in its metadata:
 *  {
 *  "parameter_reference": "param1",
 *  "parameter_type": "array"
 *  }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PlanNode_Metadata *metadata;

/** Condensed representation for SCALAR nodes. */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation *shortRepresentation;

@end


/**
 *  The execution statistics associated with the node, contained in a group of
 *  key-value pairs. Only present if the plan was returned as a result of a
 *  profile query. For example, number of executions, number of rows/time per
 *  execution etc.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_ExecutionStats : GTLRObject
@end


/**
 *  Attributes relevant to the node contained in a group of key-value pairs.
 *  For example, a Parameter Reference node could have the following
 *  information in its metadata:
 *  {
 *  "parameter_reference": "param1",
 *  "parameter_type": "array"
 *  }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_PlanNode_Metadata : GTLRObject
@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources.
 *  A `Policy` is a collection of `bindings`. A `binding` binds one or more
 *  `members` to a single `role`. Members can be user accounts, service
 *  accounts,
 *  Google groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions; each `role` can be an IAM predefined role or a user-created
 *  custom role.
 *  For some types of Google Cloud resources, a `binding` can also specify a
 *  `condition`, which is a logical expression that allows access to a resource
 *  only if the expression evaluates to `true`. A condition can add constraints
 *  based on attributes of the request, the resource, or both. To learn which
 *  resources support conditions in their IAM policies, see the
 *  [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:**
 *  {
 *  "bindings": [
 *  {
 *  "role": "roles/resourcemanager.organizationAdmin",
 *  "members": [
 *  "user:mike\@example.com",
 *  "group:admins\@example.com",
 *  "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com"
 *  ]
 *  },
 *  {
 *  "role": "roles/resourcemanager.organizationViewer",
 *  "members": [
 *  "user:eve\@example.com"
 *  ],
 *  "condition": {
 *  "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020",
 *  "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')",
 *  }
 *  }
 *  ],
 *  "etag": "BwWWja0YfJA=",
 *  "version": 3
 *  }
 *  **YAML example:**
 *  bindings:
 *  - members:
 *  - user:mike\@example.com
 *  - group:admins\@example.com
 *  - domain:google.com
 *  - serviceAccount:my-project-id\@appspot.gserviceaccount.com
 *  role: roles/resourcemanager.organizationAdmin
 *  - members:
 *  - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer
 *  condition:
 *  title: expirable access
 *  description: Does not grant access after Sep 2020
 *  expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
 *  - etag: BwWWja0YfJA=
 *  - version: 3
 *  For a description of IAM and its features, see the
 *  [IAM documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRSpanner_Policy : GTLRObject

/**
 *  Associates a list of `members` to a `role`. Optionally, may specify a
 *  `condition` that determines how and when the `bindings` are applied. Each
 *  of the `bindings` must contain at least one member.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help
 *  prevent simultaneous updates of a policy from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform policy updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `getIamPolicy`, and
 *  systems are expected to put that etag in the request to `setIamPolicy` to
 *  ensure that their change will be applied to the same version of the policy.
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy.
 *  Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
 *  are rejected.
 *  Any operation that affects conditional role bindings must specify version
 *  `3`. This requirement applies to the following operations:
 *  * Getting a policy that includes a conditional role binding
 *  * Adding a conditional role binding to a policy
 *  * Changing a conditional role binding in a policy
 *  * Removing any role binding, with or without a condition, from a policy
 *  that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost.
 *  If a policy does not include any conditions, operations on that policy may
 *  specify any valid version or leave the field unset.
 *  To learn which resources support conditions in their IAM policies, see the
 *  [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Query optimizer configuration.
 */
@interface GTLRSpanner_QueryOptions : GTLRObject

/**
 *  An option to control the selection of optimizer version.
 *  This parameter allows individual queries to pick different query
 *  optimizer versions.
 *  Specifying "latest" as a value instructs Cloud Spanner to use the
 *  latest supported query optimizer version. If not specified, Cloud Spanner
 *  uses optimizer version set at the database level options. Any other
 *  positive integer (from the list of supported optimizer versions)
 *  overrides the default optimizer version for query execution.
 *  The list of supported optimizer versions can be queried from
 *  SPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS. Executing a SQL statement
 *  with an invalid optimizer version will fail with a syntax error
 *  (`INVALID_ARGUMENT`) status.
 *  See
 *  https://cloud.google.com/spanner/docs/query-optimizer/manage-query-optimizer
 *  for more information on managing the query optimizer.
 *  The `optimizer_version` statement hint has precedence over this setting.
 */
@property(nonatomic, copy, nullable) NSString *optimizerVersion;

@end


/**
 *  Contains an ordered list of nodes appearing in the query plan.
 */
@interface GTLRSpanner_QueryPlan : GTLRObject

/**
 *  The nodes in the query plan. Plan nodes are returned in pre-order starting
 *  with the plan root. Each PlanNode's `id` corresponds to its index in
 *  `plan_nodes`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_PlanNode *> *planNodes;

@end


/**
 *  Message type to initiate a read-only transaction.
 */
@interface GTLRSpanner_ReadOnly : GTLRObject

/**
 *  Executes all reads at a timestamp that is `exact_staleness`
 *  old. The timestamp is chosen soon after the read is started.
 *  Guarantees that all writes that have committed more than the
 *  specified number of seconds ago are visible. Because Cloud Spanner
 *  chooses the exact timestamp, this mode works even if the client's
 *  local clock is substantially skewed from Cloud Spanner commit
 *  timestamps.
 *  Useful for reading at nearby replicas without the distributed
 *  timestamp negotiation overhead of `max_staleness`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *exactStaleness;

/**
 *  Read data at a timestamp >= `NOW - max_staleness`
 *  seconds. Guarantees that all writes that have committed more
 *  than the specified number of seconds ago are visible. Because
 *  Cloud Spanner chooses the exact timestamp, this mode works even if
 *  the client's local clock is substantially skewed from Cloud Spanner
 *  commit timestamps.
 *  Useful for reading the freshest data available at a nearby
 *  replica, while bounding the possible staleness if the local
 *  replica has fallen behind.
 *  Note that this option can only be used in single-use
 *  transactions.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxStaleness;

/**
 *  Executes all reads at a timestamp >= `min_read_timestamp`.
 *  This is useful for requesting fresher data than some previous
 *  read, or data that is fresh enough to observe the effects of some
 *  previously committed transaction whose timestamp is known.
 *  Note that this option can only be used in single-use transactions.
 *  A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to nanoseconds.
 *  Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *minReadTimestamp;

/**
 *  Executes all reads at the given timestamp. Unlike other modes,
 *  reads at a specific timestamp are repeatable; the same read at
 *  the same timestamp always returns the same data. If the
 *  timestamp is in the future, the read will block until the
 *  specified timestamp, modulo the read's deadline.
 *  Useful for large scale consistent reads such as mapreduces, or
 *  for coordinating many reads against a consistent snapshot of the
 *  data.
 *  A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to nanoseconds.
 *  Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

/**
 *  If true, the Cloud Spanner-selected read timestamp is included in
 *  the Transaction message that describes the transaction.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *returnReadTimestamp;

/**
 *  Read at a timestamp where all previously committed transactions
 *  are visible.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strong;

@end


/**
 *  The request for Read and
 *  StreamingRead.
 */
@interface GTLRSpanner_ReadRequest : GTLRObject

/**
 *  Required. The columns of table to be returned for each row matching
 *  this request.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/**
 *  If non-empty, the name of an index on table. This index is
 *  used instead of the table primary key when interpreting key_set
 *  and sorting result rows. See key_set for further information.
 */
@property(nonatomic, copy, nullable) NSString *index;

/**
 *  Required. `key_set` identifies the rows to be yielded. `key_set` names the
 *  primary keys of the rows in table to be yielded, unless index
 *  is present. If index is present, then key_set instead names
 *  index keys in index.
 *  If the partition_token field is empty, rows are yielded
 *  in table primary key order (if index is empty) or index key order
 *  (if index is non-empty). If the partition_token field is not
 *  empty, rows will be yielded in an unspecified order.
 *  It is not an error for the `key_set` to name rows that do not
 *  exist in the database. Read yields nothing for nonexistent rows.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_KeySet *keySet;

/**
 *  If greater than zero, only the first `limit` rows are yielded. If `limit`
 *  is zero, the default is no limit. A limit cannot be specified if
 *  `partition_token` is set.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *limit;

/**
 *  If present, results will be restricted to the specified partition
 *  previously created using PartitionRead(). There must be an exact
 *  match for the values of fields common to this message and the
 *  PartitionReadRequest message used to create this partition_token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *partitionToken;

/**
 *  If this request is resuming a previously interrupted read,
 *  `resume_token` should be copied from the last
 *  PartialResultSet yielded before the interruption. Doing this
 *  enables the new read to resume where the last read left off. The
 *  rest of the request parameters must exactly match the request
 *  that yielded this token.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *resumeToken;

/** Required. The name of the table in the database to be read. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The transaction to use. If none is provided, the default is a
 *  temporary read-only transaction with strong concurrency.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionSelector *transaction;

@end


/**
 *  Message type to initiate a read-write transaction. Currently this
 *  transaction type has no options.
 */
@interface GTLRSpanner_ReadWrite : GTLRObject
@end


/**
 *  GTLRSpanner_ReplicaInfo
 */
@interface GTLRSpanner_ReplicaInfo : GTLRObject

/**
 *  If true, this location is designated as the default leader location where
 *  leader replicas are placed. See the [region types
 *  documentation](https://cloud.google.com/spanner/docs/instances#region_types)
 *  for more details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultLeaderLocation;

/** The location of the serving resources, e.g. "us-central1". */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The type of replica.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_ReadOnly Read-only replicas only
 *        support reads (not writes). Read-only replicas:
 *        * Maintain a full copy of your data.
 *        * Serve reads.
 *        * Do not participate in voting to commit writes.
 *        * Are not eligible to become a leader. (Value: "READ_ONLY")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_ReadWrite Read-write replicas
 *        support both reads and writes. These replicas:
 *        * Maintain a full copy of your data.
 *        * Serve reads.
 *        * Can vote whether to commit a write.
 *        * Participate in leadership election.
 *        * Are eligible to become a leader. (Value: "READ_WRITE")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_TypeUnspecified Not specified.
 *        (Value: "TYPE_UNSPECIFIED")
 *    @arg @c kGTLRSpanner_ReplicaInfo_Type_Witness Witness replicas don't
 *        support reads but do participate in voting to
 *        commit writes. Witness replicas:
 *        * Do not maintain a full copy of data.
 *        * Do not serve reads.
 *        * Vote whether to commit writes.
 *        * Participate in leader election but are not eligible to become
 *        leader. (Value: "WITNESS")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Metadata type for the long-running operation returned by
 *  RestoreDatabase.
 */
@interface GTLRSpanner_RestoreDatabaseMetadata : GTLRObject

/** Information about the backup used to restore the database. */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupInfo *backupInfo;

/**
 *  The time at which cancellation of this operation was received.
 *  Operations.CancelOperation
 *  starts asynchronous cancellation on a long-running operation. The server
 *  makes a best effort to cancel the operation, but success is not guaranteed.
 *  Clients can use
 *  Operations.GetOperation or
 *  other methods to check whether the cancellation succeeded or whether the
 *  operation completed despite cancellation. On successful cancellation,
 *  the operation is not deleted; instead, it becomes an operation with
 *  an Operation.error value with a
 *  google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** Name of the database being created and restored to. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If exists, the name of the long-running operation that will be used to
 *  track the post-restore optimization process to optimize the performance of
 *  the restored database, and remove the dependency on the restore source.
 *  The name is of the form
 *  `projects/<project>/instances/<instance>/databases/<database>/operations/<operation>`
 *  where the <database> is the name of database being created and restored to.
 *  The metadata type of the long-running operation is
 *  OptimizeRestoredDatabaseMetadata. This long-running operation will be
 *  automatically created by the system after the RestoreDatabase long-running
 *  operation completes successfully. This operation will not be created if the
 *  restore was not successful.
 */
@property(nonatomic, copy, nullable) NSString *optimizeDatabaseOperationName;

/**
 *  The progress of the
 *  RestoreDatabase
 *  operation.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_OperationProgress *progress;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreDatabaseMetadata_SourceType_Backup A backup
 *        was used as the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRSpanner_RestoreDatabaseMetadata_SourceType_TypeUnspecified No
 *        restore associated. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  The request for
 *  RestoreDatabase.
 */
@interface GTLRSpanner_RestoreDatabaseRequest : GTLRObject

/**
 *  Name of the backup from which to restore. Values are of the form
 *  `projects/<project>/instances/<instance>/backups/<backup>`.
 */
@property(nonatomic, copy, nullable) NSString *backup;

/**
 *  Required. The id of the database to create and restore to. This
 *  database must not already exist. The `database_id` appended to
 *  `parent` forms the full database name of the form
 *  `projects/<project>/instances/<instance>/databases/<database_id>`.
 */
@property(nonatomic, copy, nullable) NSString *databaseId;

@end


/**
 *  Information about the database restore.
 */
@interface GTLRSpanner_RestoreInfo : GTLRObject

/**
 *  Information about the backup used to restore the database. The backup
 *  may no longer exist.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_BackupInfo *backupInfo;

/**
 *  The type of the restore source.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_RestoreInfo_SourceType_Backup A backup was used as
 *        the source of the restore. (Value: "BACKUP")
 *    @arg @c kGTLRSpanner_RestoreInfo_SourceType_TypeUnspecified No restore
 *        associated. (Value: "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sourceType;

@end


/**
 *  Results from Read or
 *  ExecuteSql.
 */
@interface GTLRSpanner_ResultSet : GTLRObject

/** Metadata about the result set, such as row type information. */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetMetadata *metadata;

/**
 *  Each element in `rows` is a row whose format is defined by
 *  metadata.row_type. The ith element
 *  in each row matches the ith field in
 *  metadata.row_type. Elements are
 *  encoded based on type as described
 *  here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *rows;

/**
 *  Query plan and execution statistics for the SQL statement that
 *  produced this result set. These can be requested by setting
 *  ExecuteSqlRequest.query_mode.
 *  DML statements always produce stats containing the number of rows
 *  modified, unless executed using the
 *  ExecuteSqlRequest.QueryMode.PLAN ExecuteSqlRequest.query_mode.
 *  Other fields may or may not be populated, based on the
 *  ExecuteSqlRequest.query_mode.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats *stats;

@end


/**
 *  Metadata about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetMetadata : GTLRObject

/**
 *  Indicates the field names and types for the rows in the result
 *  set. For example, a SQL query like `"SELECT UserId, UserName FROM
 *  Users"` could return a `row_type` value like:
 *  "fields": [
 *  { "name": "UserId", "type": { "code": "INT64" } },
 *  { "name": "UserName", "type": { "code": "STRING" } },
 *  ]
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *rowType;

/**
 *  If the read or SQL query began a transaction as a side-effect, the
 *  information about the new transaction is yielded here.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Transaction *transaction;

@end


/**
 *  Additional statistics about a ResultSet or PartialResultSet.
 */
@interface GTLRSpanner_ResultSetStats : GTLRObject

/** QueryPlan for the query associated with this result. */
@property(nonatomic, strong, nullable) GTLRSpanner_QueryPlan *queryPlan;

/**
 *  Aggregated statistics from the execution of the query. Only present when
 *  the query is profiled. For example, a query could return the statistics as
 *  follows:
 *  {
 *  "rows_returned": "3",
 *  "elapsed_time": "1.22 secs",
 *  "cpu_time": "1.19 secs"
 *  }
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ResultSetStats_QueryStats *queryStats;

/**
 *  Standard DML returns an exact count of rows that were modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountExact;

/**
 *  Partitioned DML does not offer exactly-once semantics, so it
 *  returns a lower bound of the rows modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCountLowerBound;

@end


/**
 *  Aggregated statistics from the execution of the query. Only present when
 *  the query is profiled. For example, a query could return the statistics as
 *  follows:
 *  {
 *  "rows_returned": "3",
 *  "elapsed_time": "1.22 secs",
 *  "cpu_time": "1.19 secs"
 *  }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ResultSetStats_QueryStats : GTLRObject
@end


/**
 *  The request for Rollback.
 */
@interface GTLRSpanner_RollbackRequest : GTLRObject

/**
 *  Required. The transaction to roll back.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

@end


/**
 *  A session in the Cloud Spanner API.
 */
@interface GTLRSpanner_Session : GTLRObject

/**
 *  Output only. The approximate timestamp when the session is last used. It is
 *  typically earlier than the actual last use time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *approximateLastUseTime;

/** Output only. The timestamp when the session is created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The labels for the session.
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given session.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Session_Labels *labels;

/** Output only. The name of the session. This is always system-assigned. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The labels for the session.
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
 *  * Label values must be between 0 and 63 characters long and must conform
 *  to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
 *  * No more than 64 labels can be associated with a given session.
 *  See https://goo.gl/xmQnxf for more information on and examples of labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRSpanner_Session_Labels : GTLRObject
@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRSpanner_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a
 *  valid policy but certain Cloud Platform services (such as Projects)
 *  might reject them.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Policy *policy;

@end


/**
 *  Condensed representation of a node and its subtree. Only present for
 *  `SCALAR` PlanNode(s).
 */
@interface GTLRSpanner_ShortRepresentation : GTLRObject

/**
 *  A string representation of the expression subtree rooted at this node.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases
 *  where the `description` string of this node references a `SCALAR`
 *  subquery contained in the expression subtree rooted at this node. The
 *  referenced `SCALAR` subquery may not necessarily be a direct child of
 *  this node.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ShortRepresentation_Subqueries *subqueries;

@end


/**
 *  A mapping of (subquery variable name) -> (subquery node id) for cases
 *  where the `description` string of this node references a `SCALAR`
 *  subquery contained in the expression subtree rooted at this node. The
 *  referenced `SCALAR` subquery may not necessarily be a direct child of
 *  this node.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_ShortRepresentation_Subqueries : GTLRObject
@end


/**
 *  A single DML statement.
 */
@interface GTLRSpanner_Statement : GTLRObject

/**
 *  Parameter names and values that bind to placeholders in the DML string.
 *  A parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The
 *  same parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute a SQL statement with unbound parameters.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Statement_Params *params;

/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL statement parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Statement_ParamTypes *paramTypes;

/** Required. The DML string. */
@property(nonatomic, copy, nullable) NSString *sql;

@end


/**
 *  Parameter names and values that bind to placeholders in the DML string.
 *  A parameter placeholder consists of the `\@` character followed by the
 *  parameter name (for example, `\@firstName`). Parameter names can contain
 *  letters, numbers, and underscores.
 *  Parameters can appear anywhere that a literal value is expected. The
 *  same parameter name can be used more than once, for example:
 *  `"WHERE id > \@msg_id AND id < \@msg_id + 100"`
 *  It is an error to execute a SQL statement with unbound parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Statement_Params : GTLRObject
@end


/**
 *  It is not always possible for Cloud Spanner to infer the right SQL type
 *  from a JSON value. For example, values of type `BYTES` and values
 *  of type `STRING` both appear in params as JSON strings.
 *  In these cases, `param_types` can be used to specify the exact
 *  SQL type for some or all of the SQL statement parameters. See the
 *  definition of Type for more information
 *  about SQL types.
 *
 *  @note This class is documented as having more properties of
 *        GTLRSpanner_Type. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Statement_ParamTypes : GTLRObject
@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details.
 *  You can find out more about this error model and how to work with it in the
 *  [API Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRSpanner_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRSpanner_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRSpanner_Status_Details_Item : GTLRObject
@end


/**
 *  `StructType` defines the fields of a STRUCT type.
 */
@interface GTLRSpanner_StructType : GTLRObject

/**
 *  The list of fields that make up this struct. Order is
 *  significant, because values of this struct type are represented as
 *  lists, where the order of field values matches the order of
 *  fields in the StructType. In turn, the order of fields
 *  matches the order of columns in a read request, or the order of
 *  fields in the `SELECT` clause of a query.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRSpanner_Field *> *fields;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsRequest : GTLRObject

/**
 *  REQUIRED: The set of permissions to check for 'resource'.
 *  Permissions with wildcards (such as '*', 'spanner.*', 'spanner.instances.*')
 *  are not allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRSpanner_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is
 *  allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  A transaction.
 */
@interface GTLRSpanner_Transaction : GTLRObject

/**
 *  `id` may be used to identify the transaction in subsequent
 *  Read,
 *  ExecuteSql,
 *  Commit, or
 *  Rollback calls.
 *  Single-use read-only transactions do not have IDs, because
 *  single-use transactions do not support multiple requests.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  For snapshot read-only transactions, the read timestamp chosen
 *  for the transaction. Not returned by default: see
 *  TransactionOptions.ReadOnly.return_read_timestamp.
 *  A timestamp in RFC3339 UTC \\"Zulu\\" format, accurate to nanoseconds.
 *  Example: `"2014-10-02T15:01:23.045123456Z"`.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *readTimestamp;

@end


/**
 *  # Transactions
 *  Each session can have at most one active transaction at a time (note that
 *  standalone reads and queries use a transaction internally and do count
 *  towards the one transaction limit). After the active transaction is
 *  completed, the session can immediately be re-used for the next transaction.
 *  It is not necessary to create a new session for each transaction.
 *  # Transaction Modes
 *  Cloud Spanner supports three transaction modes:
 *  1. Locking read-write. This type of transaction is the only way
 *  to write data into Cloud Spanner. These transactions rely on
 *  pessimistic locking and, if necessary, two-phase commit.
 *  Locking read-write transactions may abort, requiring the
 *  application to retry.
 *  2. Snapshot read-only. This transaction type provides guaranteed
 *  consistency across several reads, but does not allow
 *  writes. Snapshot read-only transactions can be configured to
 *  read at timestamps in the past. Snapshot read-only
 *  transactions do not need to be committed.
 *  3. Partitioned DML. This type of transaction is used to execute
 *  a single Partitioned DML statement. Partitioned DML partitions
 *  the key space and runs the DML statement over each partition
 *  in parallel using separate, internal transactions that commit
 *  independently. Partitioned DML transactions do not need to be
 *  committed.
 *  For transactions that only read, snapshot read-only transactions
 *  provide simpler semantics and are almost always faster. In
 *  particular, read-only transactions do not take locks, so they do
 *  not conflict with read-write transactions. As a consequence of not
 *  taking locks, they also do not abort, so retry loops are not needed.
 *  Transactions may only read/write data in a single database. They
 *  may, however, read/write data in different tables within that
 *  database.
 *  ## Locking Read-Write Transactions
 *  Locking transactions may be used to atomically read-modify-write
 *  data anywhere in a database. This type of transaction is externally
 *  consistent.
 *  Clients should attempt to minimize the amount of time a transaction
 *  is active. Faster transactions commit with higher probability
 *  and cause less contention. Cloud Spanner attempts to keep read locks
 *  active as long as the transaction continues to do reads, and the
 *  transaction has not been terminated by
 *  Commit or
 *  Rollback. Long periods of
 *  inactivity at the client may cause Cloud Spanner to release a
 *  transaction's locks and abort it.
 *  Conceptually, a read-write transaction consists of zero or more
 *  reads or SQL statements followed by
 *  Commit. At any time before
 *  Commit, the client can send a
 *  Rollback request to abort the
 *  transaction.
 *  ### Semantics
 *  Cloud Spanner can commit the transaction if all read locks it acquired
 *  are still valid at commit time, and it is able to acquire write
 *  locks for all writes. Cloud Spanner can abort the transaction for any
 *  reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
 *  that the transaction has not modified any user data in Cloud Spanner.
 *  Unless the transaction commits, Cloud Spanner makes no guarantees about
 *  how long the transaction's locks were held for. It is an error to
 *  use Cloud Spanner locks for any sort of mutual exclusion other than
 *  between Cloud Spanner transactions themselves.
 *  ### Retrying Aborted Transactions
 *  When a transaction aborts, the application can choose to retry the
 *  whole transaction again. To maximize the chances of successfully
 *  committing the retry, the client should execute the retry in the
 *  same session as the original attempt. The original session's lock
 *  priority increases with each consecutive abort, meaning that each
 *  attempt has a slightly better chance of success than the previous.
 *  Under some circumstances (e.g., many transactions attempting to
 *  modify the same row(s)), a transaction can abort many times in a
 *  short period before successfully committing. Thus, it is not a good
 *  idea to cap the number of retries a transaction can attempt;
 *  instead, it is better to limit the total amount of wall time spent
 *  retrying.
 *  ### Idle Transactions
 *  A transaction is considered idle if it has no outstanding reads or
 *  SQL queries and has not started a read or SQL query within the last 10
 *  seconds. Idle transactions can be aborted by Cloud Spanner so that they
 *  don't hold on to locks indefinitely. In that case, the commit will
 *  fail with error `ABORTED`.
 *  If this behavior is undesirable, periodically executing a simple
 *  SQL query in the transaction (e.g., `SELECT 1`) prevents the
 *  transaction from becoming idle.
 *  ## Snapshot Read-Only Transactions
 *  Snapshot read-only transactions provides a simpler method than
 *  locking read-write transactions for doing several consistent
 *  reads. However, this type of transaction does not support writes.
 *  Snapshot transactions do not take locks. Instead, they work by
 *  choosing a Cloud Spanner timestamp, then executing all reads at that
 *  timestamp. Since they do not acquire locks, they do not block
 *  concurrent read-write transactions.
 *  Unlike locking read-write transactions, snapshot read-only
 *  transactions never abort. They can fail if the chosen read
 *  timestamp is garbage collected; however, the default garbage
 *  collection policy is generous enough that most applications do not
 *  need to worry about this in practice.
 *  Snapshot read-only transactions do not need to call
 *  Commit or
 *  Rollback (and in fact are not
 *  permitted to do so).
 *  To execute a snapshot transaction, the client specifies a timestamp
 *  bound, which tells Cloud Spanner how to choose a read timestamp.
 *  The types of timestamp bound are:
 *  - Strong (the default).
 *  - Bounded staleness.
 *  - Exact staleness.
 *  If the Cloud Spanner database to be read is geographically distributed,
 *  stale read-only transactions can execute more quickly than strong
 *  or read-write transaction, because they are able to execute far
 *  from the leader replica.
 *  Each type of timestamp bound is discussed in detail below.
 *  ### Strong
 *  Strong reads are guaranteed to see the effects of all transactions
 *  that have committed before the start of the read. Furthermore, all
 *  rows yielded by a single read are consistent with each other -- if
 *  any part of the read observes a transaction, all parts of the read
 *  see the transaction.
 *  Strong reads are not repeatable: two consecutive strong read-only
 *  transactions might return inconsistent results if there are
 *  concurrent writes. If consistency across reads is required, the
 *  reads should be executed within a transaction or at an exact read
 *  timestamp.
 *  See TransactionOptions.ReadOnly.strong.
 *  ### Exact Staleness
 *  These timestamp bounds execute reads at a user-specified
 *  timestamp. Reads at a timestamp are guaranteed to see a consistent
 *  prefix of the global transaction history: they observe
 *  modifications done by all transactions with a commit timestamp <=
 *  the read timestamp, and observe none of the modifications done by
 *  transactions with a larger commit timestamp. They will block until
 *  all conflicting transactions that may be assigned commit timestamps
 *  <= the read timestamp have finished.
 *  The timestamp can either be expressed as an absolute Cloud Spanner commit
 *  timestamp or a staleness relative to the current time.
 *  These modes do not require a "negotiation phase" to pick a
 *  timestamp. As a result, they execute slightly faster than the
 *  equivalent boundedly stale concurrency modes. On the other hand,
 *  boundedly stale reads usually return fresher results.
 *  See TransactionOptions.ReadOnly.read_timestamp and
 *  TransactionOptions.ReadOnly.exact_staleness.
 *  ### Bounded Staleness
 *  Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
 *  subject to a user-provided staleness bound. Cloud Spanner chooses the
 *  newest timestamp within the staleness bound that allows execution
 *  of the reads at the closest available replica without blocking.
 *  All rows yielded are consistent with each other -- if any part of
 *  the read observes a transaction, all parts of the read see the
 *  transaction. Boundedly stale reads are not repeatable: two stale
 *  reads, even if they use the same staleness bound, can execute at
 *  different timestamps and thus return inconsistent results.
 *  Boundedly stale reads execute in two phases: the first phase
 *  negotiates a timestamp among all replicas needed to serve the
 *  read. In the second phase, reads are executed at the negotiated
 *  timestamp.
 *  As a result of the two phase execution, bounded staleness reads are
 *  usually a little slower than comparable exact staleness
 *  reads. However, they are typically able to return fresher
 *  results, and are more likely to execute at the closest replica.
 *  Because the timestamp negotiation requires up-front knowledge of
 *  which rows will be read, it can only be used with single-use
 *  read-only transactions.
 *  See TransactionOptions.ReadOnly.max_staleness and
 *  TransactionOptions.ReadOnly.min_read_timestamp.
 *  ### Old Read Timestamps and Garbage Collection
 *  Cloud Spanner continuously garbage collects deleted and overwritten data
 *  in the background to reclaim storage space. This process is known
 *  as "version GC". By default, version GC reclaims versions after they
 *  are one hour old. Because of this, Cloud Spanner cannot perform reads
 *  at read timestamps more than one hour in the past. This
 *  restriction also applies to in-progress reads and/or SQL queries whose
 *  timestamp become too old while executing. Reads and SQL queries with
 *  too-old read timestamps fail with the error `FAILED_PRECONDITION`.
 *  ## Partitioned DML Transactions
 *  Partitioned DML transactions are used to execute DML statements with a
 *  different execution strategy that provides different, and often better,
 *  scalability properties for large, table-wide operations than DML in a
 *  ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
 *  should prefer using ReadWrite transactions.
 *  Partitioned DML partitions the keyspace and runs the DML statement on each
 *  partition in separate, internal transactions. These transactions commit
 *  automatically when complete, and run independently from one another.
 *  To reduce lock contention, this execution strategy only acquires read locks
 *  on rows that match the WHERE clause of the statement. Additionally, the
 *  smaller per-partition transactions hold locks for less time.
 *  That said, Partitioned DML is not a drop-in replacement for standard DML
 *  used
 *  in ReadWrite transactions.
 *  - The DML statement must be fully-partitionable. Specifically, the statement
 *  must be expressible as the union of many statements which each access only
 *  a single row of the table.
 *  - The statement is not applied atomically to all rows of the table. Rather,
 *  the statement is applied atomically to partitions of the table, in
 *  independent transactions. Secondary index rows are updated atomically
 *  with the base table rows.
 *  - Partitioned DML does not guarantee exactly-once execution semantics
 *  against a partition. The statement will be applied at least once to each
 *  partition. It is strongly recommended that the DML statement should be
 *  idempotent to avoid unexpected results. For instance, it is potentially
 *  dangerous to run a statement such as
 *  `UPDATE table SET column = column + 1` as it could be run multiple times
 *  against some rows.
 *  - The partitions are committed automatically - there is no support for
 *  Commit or Rollback. If the call returns an error, or if the client issuing
 *  the ExecuteSql call dies, it is possible that some rows had the statement
 *  executed on them successfully. It is also possible that statement was
 *  never executed against other rows.
 *  - Partitioned DML transactions may only contain the execution of a single
 *  DML statement via ExecuteSql or ExecuteStreamingSql.
 *  - If any error is encountered during the execution of the partitioned DML
 *  operation (for instance, a UNIQUE INDEX violation, division by zero, or a
 *  value that cannot be stored due to schema constraints), then the
 *  operation is stopped at that point and an error is returned. It is
 *  possible that at this point, some partitions have been committed (or even
 *  committed multiple times), and other partitions have not been run at all.
 *  Given the above, Partitioned DML is good fit for large, database-wide,
 *  operations that are idempotent, such as deleting old rows from a very large
 *  table.
 */
@interface GTLRSpanner_TransactionOptions : GTLRObject

/**
 *  Partitioned DML transaction.
 *  Authorization to begin a Partitioned DML transaction requires
 *  `spanner.databases.beginPartitionedDmlTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_PartitionedDml *partitionedDml;

/**
 *  Transaction will not write.
 *  Authorization to begin a read-only transaction requires
 *  `spanner.databases.beginReadOnlyTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadOnly *readOnly;

/**
 *  Transaction may write.
 *  Authorization to begin a read-write transaction requires
 *  `spanner.databases.beginOrRollbackReadWriteTransaction` permission
 *  on the `session` resource.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_ReadWrite *readWrite;

@end


/**
 *  This message is used to select the transaction in which a
 *  Read or
 *  ExecuteSql call runs.
 *  See TransactionOptions for more information about transactions.
 */
@interface GTLRSpanner_TransactionSelector : GTLRObject

/**
 *  Begin a new transaction and execute this read or SQL query in
 *  it. The transaction ID of the new transaction is returned in
 *  ResultSetMetadata.transaction, which is a Transaction.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *begin;

/**
 *  Execute the read or SQL query in a previously-started transaction.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Execute the read or SQL query in a temporary transaction.
 *  This is the most efficient way to execute a transaction that
 *  consists of a single SQL query.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_TransactionOptions *singleUse;

@end


/**
 *  `Type` indicates the type of a Cloud Spanner value, as might be stored in a
 *  table cell or returned from an SQL query.
 */
@interface GTLRSpanner_Type : GTLRObject

/**
 *  If code == ARRAY, then `array_element_type`
 *  is the type of the array elements.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Type *arrayElementType;

/**
 *  Required. The TypeCode for this type.
 *
 *  Likely values:
 *    @arg @c kGTLRSpanner_Type_Code_Array Encoded as `list`, where the list
 *        elements are represented
 *        according to
 *        array_element_type. (Value: "ARRAY")
 *    @arg @c kGTLRSpanner_Type_Code_Bool Encoded as JSON `true` or `false`.
 *        (Value: "BOOL")
 *    @arg @c kGTLRSpanner_Type_Code_Bytes Encoded as a base64-encoded `string`,
 *        as described in RFC 4648,
 *        section 4. (Value: "BYTES")
 *    @arg @c kGTLRSpanner_Type_Code_Date Encoded as `string` in RFC 3339 date
 *        format. (Value: "DATE")
 *    @arg @c kGTLRSpanner_Type_Code_Float64 Encoded as `number`, or the strings
 *        `"NaN"`, `"Infinity"`, or
 *        `"-Infinity"`. (Value: "FLOAT64")
 *    @arg @c kGTLRSpanner_Type_Code_Int64 Encoded as `string`, in decimal
 *        format. (Value: "INT64")
 *    @arg @c kGTLRSpanner_Type_Code_String Encoded as `string`. (Value:
 *        "STRING")
 *    @arg @c kGTLRSpanner_Type_Code_Struct Encoded as `list`, where list
 *        element `i` is represented according
 *        to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
 *        (Value: "STRUCT")
 *    @arg @c kGTLRSpanner_Type_Code_Timestamp Encoded as `string` in RFC 3339
 *        timestamp format. The time zone
 *        must be present, and must be `"Z"`.
 *        If the schema has the column option
 *        `allow_commit_timestamp=true`, the placeholder string
 *        `"spanner.commit_timestamp()"` can be used to instruct the system
 *        to insert the commit timestamp associated with the transaction
 *        commit. (Value: "TIMESTAMP")
 *    @arg @c kGTLRSpanner_Type_Code_TypeCodeUnspecified Not specified. (Value:
 *        "TYPE_CODE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  If code == STRUCT, then `struct_type`
 *  provides type information for the struct's fields.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_StructType *structType;

@end


/**
 *  Metadata type for the operation returned by
 *  UpdateDatabaseDdl.
 */
@interface GTLRSpanner_UpdateDatabaseDdlMetadata : GTLRObject

/**
 *  Reports the commit timestamps of all statements that have
 *  succeeded so far, where `commit_timestamps[i]` is the commit
 *  timestamp for the statement `statements[i]`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDateTime *> *commitTimestamps;

/** The database being modified. */
@property(nonatomic, copy, nullable) NSString *database;

/**
 *  For an update this list contains all the statements. For an
 *  individual statement, this list contains only that statement.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Enqueues the given DDL statements to be applied, in order but not
 *  necessarily all at once, to the database schema at some point (or
 *  points) in the future. The server checks that the statements
 *  are executable (syntactically valid, name tables that exist, etc.)
 *  before enqueueing them, but they may still fail upon
 *  later execution (e.g., if a statement from another batch of
 *  statements is applied first and it conflicts in some way, or if
 *  there is some data-related problem like a `NULL` value in a column to
 *  which `NOT NULL` would be added). If a statement fails, all
 *  subsequent statements in the batch are automatically cancelled.
 *  Each batch of statements is assigned a name which can be used with
 *  the Operations API to monitor
 *  progress. See the
 *  operation_id field for more
 *  details.
 */
@interface GTLRSpanner_UpdateDatabaseDdlRequest : GTLRObject

/**
 *  If empty, the new update request is assigned an
 *  automatically-generated operation ID. Otherwise, `operation_id`
 *  is used to construct the name of the resulting
 *  Operation.
 *  Specifying an explicit operation ID simplifies determining
 *  whether the statements were executed in the event that the
 *  UpdateDatabaseDdl call is replayed,
 *  or the return value is otherwise lost: the database and
 *  `operation_id` fields can be combined to form the
 *  name of the resulting
 *  longrunning.Operation: `<database>/operations/<operation_id>`.
 *  `operation_id` should be unique within the database, and must be
 *  a valid identifier: `a-z*`. Note that
 *  automatically-generated operation IDs always begin with an
 *  underscore. If the named operation already exists,
 *  UpdateDatabaseDdl returns
 *  `ALREADY_EXISTS`.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Required. DDL statements to be applied to the database. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *statements;

@end


/**
 *  Metadata type for the operation returned by
 *  UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceMetadata : GTLRObject

/**
 *  The time at which this operation was cancelled. If set, this operation is
 *  in the process of undoing itself (which is guaranteed to succeed) and
 *  cannot be cancelled again.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *cancelTime;

/** The time at which this operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The desired end state of the update. */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

/**
 *  The time at which UpdateInstance
 *  request was received.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  The request for UpdateInstance.
 */
@interface GTLRSpanner_UpdateInstanceRequest : GTLRObject

/**
 *  Required. A mask specifying which fields in Instance should be updated.
 *  The field mask must always be specified; this prevents any future fields in
 *  Instance from being erased accidentally by clients that do not know
 *  about them.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *fieldMask;

/**
 *  Required. The instance to update, which must always include the instance
 *  name. Otherwise, only fields mentioned in field_mask need be included.
 */
@property(nonatomic, strong, nullable) GTLRSpanner_Instance *instance;

@end


/**
 *  Arguments to insert, update, insert_or_update, and
 *  replace operations.
 */
@interface GTLRSpanner_Write : GTLRObject

/**
 *  The names of the columns in table to be written.
 *  The list of columns must contain enough columns to allow
 *  Cloud Spanner to derive values for all primary key columns in the
 *  row(s) to be modified.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *columns;

/** Required. The table whose rows will be written. */
@property(nonatomic, copy, nullable) NSString *table;

/**
 *  The values to be written. `values` can contain more than one
 *  list of values. If it does, then multiple rows are written, one
 *  for each entry in `values`. Each list in `values` must have
 *  exactly as many entries as there are entries in columns
 *  above. Sending multiple lists is equivalent to sending multiple
 *  `Mutation`s, each containing one `values` entry and repeating
 *  table and columns. Individual values in each list are
 *  encoded as described here.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) NSArray<NSArray *> *values;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
