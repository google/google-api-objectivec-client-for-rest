// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Playable Locations API (playablelocations/v3)
// Documentation:
//   https://developers.google.com/maps/contact-sales/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleAreaFilter;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleCriterion;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleFilter;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocation;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationList;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationsResponse_LocationsPerGameObjectType;
@class GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions;
@class GTLRPlayableLocations_GoogleMapsUnityClientInfo;
@class GTLRPlayableLocations_GoogleTypeLatLng;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression.impressionType

/**
 *  Unspecified type. Do not use.
 *
 *  Value: "IMPRESSION_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression_ImpressionType_ImpressionTypeUnspecified;
/**
 *  A player interacted with the playable location.
 *
 *  Value: "INTERACTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression_ImpressionType_Interacted;
/**
 *  The playable location was presented to a player.
 *
 *  Value: "PRESENTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression_ImpressionType_Presented;

// ----------------------------------------------------------------------------
// GTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport.reasons

/** Value: "BAD_LOCATION_REASON_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport_Reasons_BadLocationReasonUnspecified;
/** Value: "NOT_OPEN_TO_PUBLIC" */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport_Reasons_NotOpenToPublic;
/** Value: "NOT_PEDESTRIAN_ACCESSIBLE" */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport_Reasons_NotPedestrianAccessible;
/** Value: "OTHER" */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport_Reasons_Other;
/** Value: "PERMANENTLY_CLOSED" */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport_Reasons_PermanentlyClosed;
/** Value: "TEMPORARILY_INACCESSIBLE" */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport_Reasons_TemporarilyInaccessible;

// ----------------------------------------------------------------------------
// GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions.pointType

/**
 *  The geographic coordinates correspond to the center of the location.
 *
 *  Value: "CENTER_POINT"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions_PointType_CenterPoint;
/**
 *  Unspecified point type. Do not use this value.
 *
 *  Value: "POINT_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions_PointType_PointTypeUnspecified;
/**
 *  The geographic coordinates correspond to the location snapped to the
 *  sidewalk of the nearest road (when a nearby road exists).
 *
 *  Value: "SNAPPED_POINT"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions_PointType_SnappedPoint;

// ----------------------------------------------------------------------------
// GTLRPlayableLocations_GoogleMapsUnityClientInfo.platform

/**
 *  Android
 *
 *  Value: "ANDROID"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Android;
/**
 *  Development environment.
 *
 *  Value: "EDITOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Editor;
/**
 *  iOS
 *
 *  Value: "IOS"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Ios;
/**
 *  Linux
 *
 *  Value: "LINUX"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Linux;
/**
 *  macOS.
 *
 *  Value: "MAC_OS"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_MacOs;
/**
 *  Unspecified or unknown OS.
 *
 *  Value: "PLATFORM_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_PlatformUnspecified;
/**
 *  WebGL.
 *
 *  Value: "WEB_GL"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_WebGl;
/**
 *  Windows.
 *
 *  Value: "WINDOWS"
 */
FOUNDATION_EXTERN NSString * const kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Windows;

/**
 *  Encapsulates impression event details.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression : GTLRObject

/**
 *  An arbitrary, developer-defined type identifier for each type of game
 *  object used in your game.
 *  Since players interact with differ types of game objects in different ways,
 *  this field allows you to segregate impression data by type for analysis.
 *  You should assign a unique `game_object_type` ID to represent a distinct
 *  type of game object in your game.
 *  For example, 1=monster location, 2=powerup location.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gameObjectType;

/**
 *  Required. The type of impression event.
 *
 *  Likely values:
 *    @arg @c kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression_ImpressionType_ImpressionTypeUnspecified
 *        Unspecified type. Do not use. (Value: "IMPRESSION_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression_ImpressionType_Interacted
 *        A player interacted with the playable location. (Value: "INTERACTED")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression_ImpressionType_Presented
 *        The playable location was presented to a player. (Value: "PRESENTED")
 */
@property(nonatomic, copy, nullable) NSString *impressionType;

/** Required. The name of the playable location. */
@property(nonatomic, copy, nullable) NSString *locationName;

@end


/**
 *  A request for logging impressions.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3LogImpressionsRequest : GTLRObject

/**
 *  Required. Information about the client device. For example, device model and
 *  operating system.
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleMapsUnityClientInfo *clientInfo;

/**
 *  Required. Impression event details. The maximum number of impression reports
 *  that you
 *  can log at once is 50.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRPlayableLocations_GoogleMapsPlayablelocationsV3Impression *> *impressions;

/**
 *  Required. A string that uniquely identifies the log impressions request.
 *  This allows
 *  you to detect duplicate requests. We recommend that you use UUIDs for this
 *  value. The value must not exceed 50 characters.
 *  You should reuse the `request_id` only when retrying a request in case of
 *  failure. In this case, the request must be identical to the one that
 *  failed.
 */
@property(nonatomic, copy, nullable) NSString *requestId;

@end


/**
 *  A response for the LogImpressions method.
 *  This method returns no data upon success.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3LogImpressionsResponse : GTLRObject
@end


/**
 *  A request for logging your player's bad location reports.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3LogPlayerReportsRequest : GTLRObject

/**
 *  Required. Information about the client device (for example, device model and
 *  operating system).
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleMapsUnityClientInfo *clientInfo;

/**
 *  Required. Player reports. The maximum number of player reports that you can
 *  log at
 *  once is 50.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport *> *playerReports;

/**
 *  Required. A string that uniquely identifies the log player reports request.
 *  This
 *  allows you to detect duplicate requests. We recommend that you use UUIDs
 *  for this value. The value must not exceed 50 characters.
 *  You should reuse the `request_id` only when retrying a request in the case
 *  of a failure. In that case, the request must be identical to the one that
 *  failed.
 */
@property(nonatomic, copy, nullable) NSString *requestId;

@end


/**
 *  A response for the LogPlayerReports
 *  method.
 *  This method returns no data upon success.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3LogPlayerReportsResponse : GTLRObject
@end


/**
 *  A report submitted by a player about a playable location that is considered
 *  inappropriate for use in the game.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3PlayerReport : GTLRObject

/**
 *  Language code (in BCP-47 format) indicating the language of the freeform
 *  description provided in `reason_details`. Examples are "en", "en-US" or
 *  "ja-Latn". For more information, see
 *  http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
 */
@property(nonatomic, copy, nullable) NSString *languageCode;

/** Required. The name of the playable location. */
@property(nonatomic, copy, nullable) NSString *locationName;

/**
 *  Required. A free-form description detailing why the playable location is
 *  considered bad.
 */
@property(nonatomic, copy, nullable) NSString *reasonDetails;

/**
 *  Required. One or more reasons why this playable location is considered bad.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *reasons;

@end


/**
 *  Specifies the area to search for playable locations.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleAreaFilter : GTLRObject

/**
 *  Required. The S2 cell ID of the area you want. This must be between cell
 *  level 11 and
 *  14 (inclusive).
 *  S2 cells are 64-bit integers that identify areas on the Earth. They are
 *  hierarchical, and can therefore be used for spatial indexing.
 *  The S2 geometry library is available in a number of languages:
 *  * [C++](https://github.com/google/s2geometry)
 *  * [Java](https://github.com/google/s2-geometry-library-java)
 *  * [Go](https://github.com/golang/geo)
 *  * [Python](https://github.com/google/s2geometry/tree/master/src/python)
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *s2CellId;

@end


/**
 *  Encapsulates a filter criterion for searching for a set of playable
 *  locations.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleCriterion : GTLRObject

/**
 *  Specifies which `PlayableLocation` fields are returned.
 *  `name` (which is used for logging impressions), `center_point` and
 *  `place_id` (or `plus_code`) are always returned.
 *  The following fields are omitted unless you specify them here:
 *  * snapped_point
 *  * types
 *  Note: The more fields you include, the more expensive in terms of data and
 *  associated latency your query will be.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *fieldsToReturn;

/**
 *  Specifies filtering options, and specifies what will be included in the
 *  result set.
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleFilter *filter;

/**
 *  Required. An arbitrary, developer-defined identifier of the type of game
 *  object that
 *  the playable location is used for. This field allows you to specify
 *  criteria per game object type when searching for playable locations.
 *  You should assign a unique `game_object_type` ID across all
 *  `request_criteria` to represent a distinct type of game object. For
 *  example, 1=monster location, 2=powerup location.
 *  The response contains a map<game_object_type, Response>.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gameObjectType;

@end


/**
 *  Specifies the filters to use when searching for playable locations.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleFilter : GTLRObject

/**
 *  Restricts the set of playable locations to just the
 *  [types](/maps/documentation/gaming/tt/types) that you want.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *includedTypes;

/**
 *  Specifies the maximum number of playable locations to return. This value
 *  must not be greater than 1000. The default value is 100.
 *  Only the top-ranking playable locations are returned.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxLocationCount;

/**
 *  A set of options that control the spacing between playable locations. By
 *  default the minimum distance between locations is 200m.
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions *spacing;

@end


/**
 *  A geographical point suitable for placing game objects in location-based
 *  games.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocation : GTLRObject

/**
 *  Required. The latitude and longitude associated with the center of the
 *  playable
 *  location.
 *  By default, the set of playable locations returned from
 *  SamplePlayableLocations use
 *  center-point coordinates.
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleTypeLatLng *centerPoint;

/** Required. The name of this playable location. */
@property(nonatomic, copy, nullable) NSString *name;

/** A [place ID] (https://developers.google.com/places/place-id) */
@property(nonatomic, copy, nullable) NSString *placeId;

/** A [plus code] (http://openlocationcode.com) */
@property(nonatomic, copy, nullable) NSString *plusCode;

/**
 *  The playable location's coordinates, snapped to the sidewalk of the
 *  nearest road, if a nearby road exists.
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleTypeLatLng *snappedPoint;

/**
 *  A collection of [Playable Location
 *  Types](/maps/documentation/gaming/tt/types) for this playable location. The
 *  first type in the collection is the primary type.
 *  Type information might not be available for all playable locations.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *types;

@end


/**
 *  A list of PlayableLocation objects that satisfies a single Criterion.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationList : GTLRObject

/** A list of playable locations for this game object type. */
@property(nonatomic, strong, nullable) NSArray<GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocation *> *locations;

@end


/**
 *  Life of a query:
 *  - When a game starts in a new location, your game server issues a
 *  SamplePlayableLocations
 *  request. The request specifies the S2 cell, and contains one or more
 *  "criteria" for filtering:
 *  - Criterion 0: i locations for long-lived bases, or level 0 monsters, or...
 *  - Criterion 1: j locations for short-lived bases, or level 1 monsters, ...
 *  - Criterion 2: k locations for random objects.
 *  - etc (up to 5 criterion may be specified).
 *  `PlayableLocationList` will then contain mutually
 *  exclusive lists of `PlayableLocation` objects that satisfy each of
 *  the criteria. Think of it as a collection of real-world locations that you
 *  can then associate with your game state.
 *  Note: These points are impermanent in nature. E.g, parks can close, and
 *  places can be removed.
 *  The response specifies how long you can expect the playable locations to
 *  last. Once they expire, you should query the `samplePlayableLocations` API
 *  again to get a fresh view of the real world.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest : GTLRObject

/** Required. Specifies the area to search within for playable locations. */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleAreaFilter *areaFilter;

/**
 *  Required. Specifies one or more (up to 5) criteria for filtering the
 *  returned playable locations.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleCriterion *> *criteria;

@end


/**
 *  Response for the
 *  SamplePlayableLocations
 *  method.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationsResponse : GTLRObject

/**
 *  Each PlayableLocation object corresponds to a game_object_type specified
 *  in the request.
 */
@property(nonatomic, strong, nullable) GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationsResponse_LocationsPerGameObjectType *locationsPerGameObjectType;

/**
 *  Required. Specifies the "time-to-live" for the set of playable locations.
 *  You can use
 *  this value to determine how long to cache the set of playable locations.
 *  After this length of time, your back-end game server should issue a new
 *  SamplePlayableLocations
 *  request to get a fresh set of playable locations (because for example, they
 *  might have been removed, a park might have closed for the day, a
 *  business might have closed permanently).
 */
@property(nonatomic, strong, nullable) GTLRDuration *ttl;

@end


/**
 *  Each PlayableLocation object corresponds to a game_object_type specified
 *  in the request.
 *
 *  @note This class is documented as having more properties of
 *        GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationList.
 *        Use @c -additionalJSONKeys and @c -additionalPropertyForName: to get
 *        the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SamplePlayableLocationsResponse_LocationsPerGameObjectType : GTLRObject
@end


/**
 *  A set of options that specifies the separation between playable locations.
 */
@interface GTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions : GTLRObject

/**
 *  Required. The minimum spacing between any two playable locations, measured
 *  in meters.
 *  The minimum value is 30.
 *  The maximum value is 1000.
 *  Inputs will be rounded up to the next 10 meter interval.
 *  The default value is 200m.
 *  Set this field to remove tight clusters of playable locations.
 *  Note:
 *  The spacing is a greedy algorithm. It optimizes for selecting the highest
 *  ranking locations first, not to maximize the number of locations selected.
 *  Consider the following scenario:
 *  * Rank: A: 2, B: 1, C: 3.
 *  * Distance: A--200m--B--200m--C
 *  If spacing=250, it will pick the highest ranked location [B], not [A, C].
 *  Note:
 *  Spacing works within the game object type itself, as well as the previous
 *  ones.
 *  Suppose three game object types, each with the following spacing:
 *  * X: 400m, Y: undefined, Z: 200m.
 *  1. Add locations for X, within 400m of each other.
 *  2. Add locations for Y, without any spacing.
 *  3. Finally, add locations for Z within 200m of each other as well X and Y.
 *  The distance diagram between those locations end up as:
 *  * From->To.
 *  * X->X: 400m
 *  * Y->X, Y->Y: unspecified.
 *  * Z->X, Z->Y, Z->Z: 200m.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minSpacingMeters;

/**
 *  Specifies whether the minimum spacing constraint applies to the
 *  center-point or to the snapped point of playable locations. The default
 *  value is `CENTER_POINT`.
 *  If a snapped point is not available for a playable location, its
 *  center-point is used instead.
 *  Set this to the point type used in your game.
 *
 *  Likely values:
 *    @arg @c kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions_PointType_CenterPoint
 *        The geographic coordinates correspond to the center of the location.
 *        (Value: "CENTER_POINT")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions_PointType_PointTypeUnspecified
 *        Unspecified point type. Do not use this value. (Value:
 *        "POINT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsPlayablelocationsV3SampleSpacingOptions_PointType_SnappedPoint
 *        The geographic coordinates correspond to the location snapped to the
 *        sidewalk of the nearest road (when a nearby road exists). (Value:
 *        "SNAPPED_POINT")
 */
@property(nonatomic, copy, nullable) NSString *pointType;

@end


/**
 *  Client information.
 */
@interface GTLRPlayableLocations_GoogleMapsUnityClientInfo : GTLRObject

/**
 *  API client name and version. For example, the SDK calling the API. The
 *  exact format is up to the client.
 */
@property(nonatomic, copy, nullable) NSString *apiClient;

/**
 *  Application ID, such as the package name on Android and the bundle
 *  identifier on iOS platforms.
 */
@property(nonatomic, copy, nullable) NSString *applicationId;

/**
 *  Application version number, such as "1.2.3". The exact format is
 *  application-dependent.
 */
@property(nonatomic, copy, nullable) NSString *applicationVersion;

/**
 *  Device model as reported by the device. The exact format is
 *  platform-dependent.
 */
@property(nonatomic, copy, nullable) NSString *deviceModel;

/**
 *  Language code (in BCP-47 format) indicating the UI language of the client.
 *  Examples are "en", "en-US" or "ja-Latn". For more information, see
 *  http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
 */
@property(nonatomic, copy, nullable) NSString *languageCode;

/**
 *  Operating system name and version as reported by the OS. For example,
 *  "Mac OS X 10.10.4". The exact format is platform-dependent.
 */
@property(nonatomic, copy, nullable) NSString *operatingSystem;

/**
 *  Build number/version of the operating system. e.g., the contents of
 *  android.os.Build.ID in Android, or the contents of sysctl "kern.osversion"
 *  in iOS.
 */
@property(nonatomic, copy, nullable) NSString *operatingSystemBuild;

/**
 *  Platform where the application is running.
 *
 *  Likely values:
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Android
 *        Android (Value: "ANDROID")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Editor
 *        Development environment. (Value: "EDITOR")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Ios iOS
 *        (Value: "IOS")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Linux
 *        Linux (Value: "LINUX")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_MacOs
 *        macOS. (Value: "MAC_OS")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_PlatformUnspecified
 *        Unspecified or unknown OS. (Value: "PLATFORM_UNSPECIFIED")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_WebGl
 *        WebGL. (Value: "WEB_GL")
 *    @arg @c kGTLRPlayableLocations_GoogleMapsUnityClientInfo_Platform_Windows
 *        Windows. (Value: "WINDOWS")
 */
@property(nonatomic, copy, nullable) NSString *platform;

@end


/**
 *  An object representing a latitude/longitude pair. This is expressed as a
 *  pair
 *  of doubles representing degrees latitude and degrees longitude. Unless
 *  specified otherwise, this must conform to the
 *  <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
 *  standard</a>. Values must be within normalized ranges.
 */
@interface GTLRPlayableLocations_GoogleTypeLatLng : GTLRObject

/**
 *  The latitude in degrees. It must be in the range [-90.0, +90.0].
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *latitude;

/**
 *  The longitude in degrees. It must be in the range [-180.0, +180.0].
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *longitude;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
