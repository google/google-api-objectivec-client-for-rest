// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Stackdriver Monitoring API (monitoring/v3)
// Description:
//   Manages your Stackdriver Monitoring data and configurations. Most projects
//   must be associated with a Stackdriver account, with a few exceptions as
//   noted on the individual method pages.
// Documentation:
//   https://cloud.google.com/monitoring/api/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_BucketOptions;
@class GTLRMonitoring_CollectdPayload;
@class GTLRMonitoring_CollectdPayload_Metadata;
@class GTLRMonitoring_CollectdValue;
@class GTLRMonitoring_Distribution;
@class GTLRMonitoring_Explicit;
@class GTLRMonitoring_Exponential;
@class GTLRMonitoring_Field;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_LabelDescriptor;
@class GTLRMonitoring_Linear;
@class GTLRMonitoring_Metric;
@class GTLRMonitoring_Metric_Labels;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_MonitoredResource;
@class GTLRMonitoring_MonitoredResource_Labels;
@class GTLRMonitoring_MonitoredResourceDescriptor;
@class GTLRMonitoring_Option;
@class GTLRMonitoring_Option_Value;
@class GTLRMonitoring_Point;
@class GTLRMonitoring_Range;
@class GTLRMonitoring_SourceContext;
@class GTLRMonitoring_TimeInterval;
@class GTLRMonitoring_TimeSeries;
@class GTLRMonitoring_TypedValue;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRMonitoring_CollectdValue.dataSourceType

/**
 *  An amount of change since the last measurement interval. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.DELTA.
 *
 *  Value: "ABSOLUTE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Absolute;
/**
 *  A cumulative value over time. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.CUMULATIVE.
 *
 *  Value: "COUNTER"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Counter;
/**
 *  A rate of change of the measurement.
 *
 *  Value: "DERIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Derive;
/**
 *  An instantaneous measurement of a varying quantity. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.GAUGE.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Gauge;
/**
 *  An unspecified data source type. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *
 *  Value: "UNSPECIFIED_DATA_SOURCE_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.cardinality

/**
 *  For optional fields.
 *
 *  Value: "CARDINALITY_OPTIONAL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityOptional;
/**
 *  For repeated fields.
 *
 *  Value: "CARDINALITY_REPEATED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRepeated;
/**
 *  For required fields. Proto2 syntax only.
 *
 *  Value: "CARDINALITY_REQUIRED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRequired;
/**
 *  For fields with unknown cardinality.
 *
 *  Value: "CARDINALITY_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.kind

/**
 *  Field type bool.
 *
 *  Value: "TYPE_BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBool;
/**
 *  Field type bytes.
 *
 *  Value: "TYPE_BYTES"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBytes;
/**
 *  Field type double.
 *
 *  Value: "TYPE_DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeDouble;
/**
 *  Field type enum.
 *
 *  Value: "TYPE_ENUM"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeEnum;
/**
 *  Field type fixed32.
 *
 *  Value: "TYPE_FIXED32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed32;
/**
 *  Field type fixed64.
 *
 *  Value: "TYPE_FIXED64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed64;
/**
 *  Field type float.
 *
 *  Value: "TYPE_FLOAT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFloat;
/**
 *  Field type group. Proto2 syntax only, and deprecated.
 *
 *  Value: "TYPE_GROUP"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeGroup;
/**
 *  Field type int32.
 *
 *  Value: "TYPE_INT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt32;
/**
 *  Field type int64.
 *
 *  Value: "TYPE_INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt64;
/**
 *  Field type message.
 *
 *  Value: "TYPE_MESSAGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeMessage;
/**
 *  Field type sfixed32.
 *
 *  Value: "TYPE_SFIXED32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed32;
/**
 *  Field type sfixed64.
 *
 *  Value: "TYPE_SFIXED64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed64;
/**
 *  Field type sint32.
 *
 *  Value: "TYPE_SINT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint32;
/**
 *  Field type sint64.
 *
 *  Value: "TYPE_SINT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint64;
/**
 *  Field type string.
 *
 *  Value: "TYPE_STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeString;
/**
 *  Field type uint32.
 *
 *  Value: "TYPE_UINT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint32;
/**
 *  Field type uint64.
 *
 *  Value: "TYPE_UINT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint64;
/**
 *  Field type unknown.
 *
 *  Value: "TYPE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_LabelDescriptor.valueType

/**
 *  Boolean; true or false.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Bool;
/**
 *  A 64-bit signed integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Int64;
/**
 *  A variable-length string. This is the default.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_String;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Type.syntax

/**
 *  Syntax proto2.
 *
 *  Value: "SYNTAX_PROTO2"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto2;
/**
 *  Syntax proto3.
 *
 *  Value: "SYNTAX_PROTO3"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto3;

/**
 *  BucketOptions describes the bucket boundaries used to create a histogram for
 *  the distribution. The buckets can be in a linear sequence, an exponential
 *  sequence, or each bucket can be specified explicitly. BucketOptions does not
 *  include the number of values in each bucket.A bucket has an inclusive lower
 *  bound and exclusive upper bound for the values that are counted for that
 *  bucket. The upper bound of a bucket must be strictly greater than the lower
 *  bound. The sequence of N buckets for a distribution consists of an underflow
 *  bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
 *  an overflow bucket (number N - 1). The buckets are contiguous: the lower
 *  bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
 *  The buckets span the whole range of finite values: lower bound of the
 *  underflow bucket is -infinity and the upper bound of the overflow bucket is
 *  +infinity. The finite buckets are so-called because both bounds are finite.
 */
@interface GTLRMonitoring_BucketOptions : GTLRObject

/** The explicit buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Explicit *explicitBuckets;

/** The exponential buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Exponential *exponentialBuckets;

/** The linear bucket. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Linear *linearBuckets;

@end


/**
 *  A collection of data points sent from a collectd-based plugin. See the
 *  collectd documentation for more information.
 */
@interface GTLRMonitoring_CollectdPayload : GTLRObject

/** The end time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The measurement metadata. Example: "process_id" -> 12345 */
@property(nonatomic, strong, nullable) GTLRMonitoring_CollectdPayload_Metadata *metadata;

/** The name of the plugin. Example: "disk". */
@property(nonatomic, copy, nullable) NSString *plugin;

/** The instance name of the plugin Example: "hdcl". */
@property(nonatomic, copy, nullable) NSString *pluginInstance;

/** The start time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** The measurement type. Example: "memory". */
@property(nonatomic, copy, nullable) NSString *type;

/** The measurement type instance. Example: "used". */
@property(nonatomic, copy, nullable) NSString *typeInstance;

/**
 *  The measured values during this time interval. Each value must have a
 *  different dataSourceName.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValue *> *values;

@end


/**
 *  The measurement metadata. Example: "process_id" -> 12345
 *
 *  @note This class is documented as having more properties of
 *        GTLRMonitoring_TypedValue. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_CollectdPayload_Metadata : GTLRObject
@end


/**
 *  A single data point from a collectd-based plugin.
 */
@interface GTLRMonitoring_CollectdValue : GTLRObject

/**
 *  The data source for the collectd value. For example there are two data
 *  sources for network measurements: "rx" and "tx".
 */
@property(nonatomic, copy, nullable) NSString *dataSourceName;

/**
 *  The type of measurement.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Absolute An amount of
 *        change since the last measurement interval. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.DELTA. (Value: "ABSOLUTE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Counter A cumulative
 *        value over time. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.CUMULATIVE. (Value: "COUNTER")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Derive A rate of
 *        change of the measurement. (Value: "DERIVE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Gauge An
 *        instantaneous measurement of a varying quantity. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.GAUGE. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType
 *        An unspecified data source type. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *        (Value: "UNSPECIFIED_DATA_SOURCE_TYPE")
 */
@property(nonatomic, copy, nullable) NSString *dataSourceType;

/** The measurement value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  The CreateCollectdTimeSeries request.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesRequest : GTLRObject

/**
 *  The collectd payloads representing the time series data. You must not
 *  include more than a single point for each time series, so no two payloads
 *  can have the same values for all of the fields plugin, plugin_instance,
 *  type, and type_instance.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayload *> *collectdPayloads;

/**
 *  The version of collectd that collected the data. Example: "5.3.0-192.el6".
 */
@property(nonatomic, copy, nullable) NSString *collectdVersion;

/** The monitored resource associated with the time series. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

@end


/**
 *  The CreateTimeSeries request.
 */
@interface GTLRMonitoring_CreateTimeSeriesRequest : GTLRObject

/**
 *  The new data to be added to a list of time series. Adds at most one data
 *  point to each of several time series. The new data point must be more recent
 *  than any other point in its time series. Each TimeSeries value must fully
 *  specify a unique time series by supplying all label values for the metric
 *  and the monitored resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  Distribution contains summary statistics for a population of values. It
 *  optionally contains a histogram representing the distribution of those
 *  values across a set of buckets.The summary statistics are the count, mean,
 *  sum of the squared deviation from the mean, the minimum, and the maximum of
 *  the set of population of values. The histogram is based on a sequence of
 *  buckets and gives a count of values that fall into each bucket. The
 *  boundaries of the buckets are given either explicitly or by formulas for
 *  buckets of fixed or exponentially increasing widths.Although it is not
 *  forbidden, it is generally a bad idea to include non-finite values
 *  (infinities or NaNs) in the population of values, as this will render the
 *  mean and sum_of_squared_deviation fields meaningless.
 */
@interface GTLRMonitoring_Distribution : GTLRObject

/**
 *  Required in the Stackdriver Monitoring API v3. The values for each bucket
 *  specified in bucket_options. The sum of the values in bucketCounts must
 *  equal the value in the count field of the Distribution object. The order of
 *  the bucket counts follows the numbering schemes described for the three
 *  bucket types. The underflow bucket has number 0; the finite buckets, if any,
 *  have numbers 1 through N-2; and the overflow bucket has number N-1. The size
 *  of bucket_counts must not be greater than N. If the size is less than N,
 *  then the remaining buckets are assigned values of zero.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  Required in the Stackdriver Monitoring API v3. Defines the histogram bucket
 *  boundaries.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BucketOptions *bucketOptions;

/**
 *  The number of values in the population. Must be non-negative. This value
 *  must equal the sum of the values in bucket_counts if a histogram is
 *  provided.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The arithmetic mean of the values in the population. If count is zero then
 *  this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  If specified, contains the range of the population values. The field must
 *  not be present if the count is zero. This field is presently ignored by the
 *  Stackdriver Monitoring API v3.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Range *range;

/**
 *  The sum of squared deviations from the mean of the values in the population.
 *  For values x_i this is:
 *  Sum[i=1..n]((x_i - mean)^2)
 *  Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
 *  describes Welford's method for accumulating this sum in one pass.If count is
 *  zero then this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for Empty is empty JSON object {}.
 */
@interface GTLRMonitoring_Empty : GTLRObject
@end


/**
 *  Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1
 *  (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i <
 *  N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must
 *  contain at least one element. If bounds has only one element, then there are
 *  no finite buckets, and that single element is the common boundary of the
 *  overflow and underflow buckets.
 */
@interface GTLRMonitoring_Explicit : GTLRObject

/**
 *  The values must be monotonically increasing.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Specifies an exponential sequence of buckets that have a width that is
 *  proportional to the value of the lower bound. Each bucket represents a
 *  constant relative uncertainty on a specific value in the bucket.There are
 *  num_finite_buckets + 2 (= N) buckets. Bucket i has the following
 *  boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower
 *  bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
 */
@interface GTLRMonitoring_Exponential : GTLRObject

/**
 *  Must be greater than 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  A single field of a message type.
 */
@interface GTLRMonitoring_Field : GTLRObject

/**
 *  The field cardinality.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityOptional For optional
 *        fields. (Value: "CARDINALITY_OPTIONAL")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRepeated For repeated
 *        fields. (Value: "CARDINALITY_REPEATED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRequired For required
 *        fields. Proto2 syntax only. (Value: "CARDINALITY_REQUIRED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityUnknown For fields
 *        with unknown cardinality. (Value: "CARDINALITY_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *cardinality;

/**
 *  The string value of the default value of this field. Proto2 syntax only.
 */
@property(nonatomic, copy, nullable) NSString *defaultValue;

/** The field JSON name. */
@property(nonatomic, copy, nullable) NSString *jsonName;

/**
 *  The field type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBool Field type bool. (Value:
 *        "TYPE_BOOL")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBytes Field type bytes. (Value:
 *        "TYPE_BYTES")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeDouble Field type double. (Value:
 *        "TYPE_DOUBLE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeEnum Field type enum. (Value:
 *        "TYPE_ENUM")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed32 Field type fixed32. (Value:
 *        "TYPE_FIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed64 Field type fixed64. (Value:
 *        "TYPE_FIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFloat Field type float. (Value:
 *        "TYPE_FLOAT")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeGroup Field type group. Proto2
 *        syntax only, and deprecated. (Value: "TYPE_GROUP")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt32 Field type int32. (Value:
 *        "TYPE_INT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt64 Field type int64. (Value:
 *        "TYPE_INT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeMessage Field type message. (Value:
 *        "TYPE_MESSAGE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed32 Field type sfixed32.
 *        (Value: "TYPE_SFIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed64 Field type sfixed64.
 *        (Value: "TYPE_SFIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint32 Field type sint32. (Value:
 *        "TYPE_SINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint64 Field type sint64. (Value:
 *        "TYPE_SINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeString Field type string. (Value:
 *        "TYPE_STRING")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint32 Field type uint32. (Value:
 *        "TYPE_UINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint64 Field type uint64. (Value:
 *        "TYPE_UINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUnknown Field type unknown. (Value:
 *        "TYPE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The field name. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The field number.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *number;

/**
 *  The index of the field type in Type.oneofs, for message or enumeration
 *  types. The first type has index 1; zero means the type is not in the list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneofIndex;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/**
 *  Whether to use alternative packed wire representation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packed;

/**
 *  The field type URL, without the scheme, for message or enumeration types.
 *  Example: "type.googleapis.com/google.protobuf.Timestamp".
 */
@property(nonatomic, copy, nullable) NSString *typeUrl;

@end


/**
 *  The description of a dynamic collection of monitored resources. Each group
 *  has a filter that is matched against monitored resources and their
 *  associated metadata. If a group's filter matches an available monitored
 *  resource, then that resource is a member of that group. Groups can contain
 *  any number of monitored resources, and each monitored resource can be a
 *  member of any number of groups.Groups can be nested in parent-child
 *  hierarchies. The parentName field identifies an optional parent for each
 *  group. If a group has a parent, then the only monitored resources available
 *  to be matched by the group's filter are the resources contained in the
 *  parent group. In other words, a group contains the monitored resources that
 *  match its filter and the filters of all the group's ancestors. A group
 *  without a parent can contain any monitored resource.For example, consider an
 *  infrastructure running a set of instances with two user-defined tags:
 *  "environment" and "role". A parent group has a filter,
 *  environment="production". A child of that parent group has a filter,
 *  role="transcoder". The parent group contains all instances in the production
 *  environment, regardless of their roles. The child group contains instances
 *  that have the transcoder role and are in the production environment.The
 *  monitored resources contained in a group can change at any moment, depending
 *  on what resources exist and what filters are associated with the group and
 *  its ancestors.
 */
@interface GTLRMonitoring_Group : GTLRObject

/** A user-assigned name for this group, used only for display purposes. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The filter used to determine which monitored resources belong to this group.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  If true, the members of this group are considered to be a cluster. The
 *  system can perform additional analysis on groups that are clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isCluster;

/**
 *  Output only. The name of this group. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". When creating a group,
 *  this field is ignored and a new name is created consisting of the project
 *  specified in the call to CreateGroup and a unique {group_id} that is
 *  generated automatically.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the group's parent, if it has one. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". For groups with no
 *  parent, parentName is the empty string, "".
 */
@property(nonatomic, copy, nullable) NSString *parentName;

@end


/**
 *  A description of a label.
 */
@interface GTLRMonitoring_LabelDescriptor : GTLRObject

/**
 *  A human-readable description for the label.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The label key. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  The type of data that can be assigned to the label.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Bool Boolean; true or
 *        false. (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Int64 A 64-bit signed
 *        integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_String A variable-length
 *        string. This is the default. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Specifies a linear sequence of buckets that all have the same width (except
 *  overflow and underflow). Each bucket represents a constant absolute
 *  uncertainty on the specific value in the bucket.There are num_finite_buckets
 *  + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i
 *  < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i
 *  - 1)).
 */
@interface GTLRMonitoring_Linear : GTLRObject

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Lower bound of the first bucket.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  The ListGroupMembers response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "members" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupMembersResponse : GTLRCollectionObject

/**
 *  A set of monitored resources in the group.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResource *> *members;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of elements matching this request.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The ListGroups response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "group" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupsResponse : GTLRCollectionObject

/**
 *  The groups that match the specified filters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Group *> *group;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMetricDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "metricDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMetricDescriptorsResponse : GTLRCollectionObject

/**
 *  The metric descriptors that are available to the project and that match the
 *  value of filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MetricDescriptor *> *metricDescriptors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMonitoredResourcDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resourceDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMonitoredResourceDescriptorsResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The monitored resource descriptors that are available to this project and
 *  that match filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResourceDescriptor *> *resourceDescriptors;

@end


/**
 *  The ListTimeSeries response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "timeSeries" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListTimeSeriesResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  One or more time series that match the filter included in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  A specific metric, identified by specifying values for all of the labels of
 *  a MetricDescriptor.
 */
@interface GTLRMonitoring_Metric : GTLRObject

/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric_Labels *labels;

/**
 *  An existing metric type, see google.api.MetricDescriptor. For example,
 *  custom.googleapis.com/invoice/paid/amount.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_Metric_Labels : GTLRObject
@end


/**
 *  Defines a metric type and its schema. Once a metric descriptor is created,
 *  deleting or altering it stops data collection and makes the metric type's
 *  existing data unusable.
 */
@interface GTLRMonitoring_MetricDescriptor : GTLRObject

/**
 *  A detailed description of the metric, which can be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A concise name for the metric, which can be displayed in user interfaces.
 *  Use sentence case without an ending period, for example "Request count".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that can be used to describe a specific instance of this
 *  metric type. For example, the
 *  appengine.googleapis.com/http/server/response_latencies metric type has a
 *  label for the HTTP response code, response_code, so you can look at
 *  latencies for successful responses or just for responses that failed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Whether the metric records instantaneous values, changes to a value, etc.
 *  Some combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Delta The change in a
 *        value during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified
 *        Do not use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The resource name of the metric descriptor. Depending on the implementation,
 *  the name typically includes: (1) the parent resource name that defines the
 *  scope of the metric type or of its data; and (2) the metric's URL-encoded
 *  type, which also appears in the type field of this descriptor. For example,
 *  following is the resource name of a custom metric within the GCP project
 *  my-project-id:
 *  "projects/my-project-id/metricDescriptors/custom.googleapis.com%2Finvoice%2Fpaid%2Famount"
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The metric type, including its DNS name prefix. The type is not URL-encoded.
 *  All user-defined custom metric types have the DNS name
 *  custom.googleapis.com. Metric types should use a natural hierarchical
 *  grouping. For example:
 *  "custom.googleapis.com/invoice/paid/amount"
 *  "appengine.googleapis.com/http/server/response_latencies"
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The unit in which the metric value is reported. It is only applicable if the
 *  value_type is INT64, DOUBLE, or DISTRIBUTION. The supported units are a
 *  subset of The Unified Code for Units of Measure
 *  (http://unitsofmeasure.org/ucum.html) standard:Basic units (UNIT)
 *  bit bit
 *  By byte
 *  s second
 *  min minute
 *  h hour
 *  d dayPrefixes (PREFIX)
 *  k kilo (10**3)
 *  M mega (10**6)
 *  G giga (10**9)
 *  T tera (10**12)
 *  P peta (10**15)
 *  E exa (10**18)
 *  Z zetta (10**21)
 *  Y yotta (10**24)
 *  m milli (10**-3)
 *  u micro (10**-6)
 *  n nano (10**-9)
 *  p pico (10**-12)
 *  f femto (10**-15)
 *  a atto (10**-18)
 *  z zepto (10**-21)
 *  y yocto (10**-24)
 *  Ki kibi (2**10)
 *  Mi mebi (2**20)
 *  Gi gibi (2**30)
 *  Ti tebi (2**40)GrammarThe grammar includes the dimensionless unit 1, such as
 *  1/s.The grammar also includes these connectors:
 *  / division (as an infix operator, e.g. 1/s).
 *  . multiplication (as an infix operator, e.g. GBy.d)The grammar for a unit is
 *  as follows:
 *  Expression = Component { "." Component } { "/" Component } ;
 *  Component = [ PREFIX ] UNIT [ Annotation ]
 *  | Annotation
 *  | "1"
 *  ;
 *  Annotation = "{" NAME "}" ;
 *  Notes:
 *  Annotation is just a comment if it follows a UNIT and is equivalent to 1 if
 *  it is used alone. For examples, {requests}/s == 1/s, By{transmitted}/s ==
 *  By/s.
 *  NAME is a sequence of non-blank printable ASCII characters not containing
 *  '{' or '}'.
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  Whether the measurement is an integer, a floating-point number, etc. Some
 *  combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Bool The value is a
 *        boolean. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Distribution The value
 *        is a Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Double The value is a
 *        double precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Int64 The value is a
 *        signed 64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Money The value is
 *        money. (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_String The value is a
 *        text string. This value type can be used only if the metric kind is
 *        GAUGE. (Value: "STRING")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified Do
 *        not use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  An object representing a resource that can be used for monitoring, logging,
 *  billing, or other purposes. Examples include virtual machine instances,
 *  databases, and storage devices such as disks. The type field identifies a
 *  MonitoredResourceDescriptor object that describes the resource's schema.
 *  Information in the labels field identifies the actual resource and its
 *  attributes according to the schema. For example, a particular Compute Engine
 *  VM instance could be represented by the following object, because the
 *  MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and
 *  "zone":
 *  { "type": "gce_instance",
 *  "labels": { "instance_id": "12345678901234",
 *  "zone": "us-central1-a" }}
 */
@interface GTLRMonitoring_MonitoredResource : GTLRObject

/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Cloud SQL databases use the labels
 *  "database_id" and "zone".
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource_Labels *labels;

/**
 *  Required. The monitored resource type. This field must match the type field
 *  of a MonitoredResourceDescriptor object. For example, the type of a Cloud
 *  SQL database is "cloudsql_database".
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Cloud SQL databases use the labels
 *  "database_id" and "zone".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResource_Labels : GTLRObject
@end


/**
 *  An object that describes the schema of a MonitoredResource object using a
 *  type name and a set of labels. For example, the monitored resource
 *  descriptor for Google Compute Engine VM instances has a type of
 *  "gce_instance" and specifies the use of the labels "instance_id" and "zone"
 *  to identify particular VM instances.Different APIs can support different
 *  monitored resource types. APIs generally provide a list method that returns
 *  the monitored resource descriptors used by the API.
 */
@interface GTLRMonitoring_MonitoredResourceDescriptor : GTLRObject

/**
 *  Optional. A detailed description of the monitored resource type that might
 *  be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. A concise name for the monitored resource type that might be
 *  displayed in user interfaces. It should be a Title Cased Noun Phrase,
 *  without any article or other determiners. For example, "Google Cloud SQL
 *  Database".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required. A set of labels used to describe instances of this monitored
 *  resource type. For example, an individual Google Cloud SQL database is
 *  identified by values for the labels "database_id" and "zone".
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Optional. The resource name of the monitored resource descriptor:
 *  "projects/{project_id}/monitoredResourceDescriptors/{type}" where {type} is
 *  the value of the type field in this object and {project_id} is a project ID
 *  that provides API-specific context for accessing the type. APIs that do not
 *  use project information can use the resource name format
 *  "monitoredResourceDescriptors/{type}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The monitored resource type. For example, the type
 *  "cloudsql_database" represents databases in Google Cloud SQL. The maximum
 *  length of this value is 256 characters.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A protocol buffer option, which can be attached to a message, field,
 *  enumeration, etc.
 */
@interface GTLRMonitoring_Option : GTLRObject

/**
 *  The option's name. For protobuf built-in options (options defined in
 *  descriptor.proto), this is the short name. For example, "map_entry". For
 *  custom options, it should be the fully-qualified name. For example,
 *  "google.api.http".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Option_Value *value;

@end


/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Option_Value : GTLRObject
@end


/**
 *  A single data point in a time series.
 */
@interface GTLRMonitoring_Point : GTLRObject

/**
 *  The time interval to which the data point applies. For GAUGE metrics, only
 *  the end time of the interval is used. For DELTA metrics, the start and end
 *  time should specify a non-zero interval, with subsequent points specifying
 *  contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start
 *  and end time should specify a non-zero interval, with subsequent points
 *  specifying the same start time and increasing end times, until an event
 *  resets the cumulative value to zero and sets a new start time for the
 *  following points.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeInterval *interval;

/** The value of the data point. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  The range of the population values.
 */
@interface GTLRMonitoring_Range : GTLRObject

/**
 *  The maximum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *max;

/**
 *  The minimum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *min;

@end


/**
 *  SourceContext represents information about the source of a protobuf element,
 *  like the file in which it is defined.
 */
@interface GTLRMonitoring_SourceContext : GTLRObject

/**
 *  The path-qualified name of the .proto file that contained the associated
 *  protobuf element. For example: "google/protobuf/source_context.proto".
 */
@property(nonatomic, copy, nullable) NSString *fileName;

@end


/**
 *  A time interval extending just after a start time through an end time. If
 *  the start time is the same as the end time, then the interval represents a
 *  single point in time.
 */
@interface GTLRMonitoring_TimeInterval : GTLRObject

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  A collection of data points that describes the time-varying values of a
 *  metric. A time series is identified by a combination of a fully-specified
 *  monitored resource and a fully-specified metric. This type is used for both
 *  listing and creating time series.
 */
@interface GTLRMonitoring_TimeSeries : GTLRObject

/**
 *  The associated metric. A fully-specified metric used to identify the time
 *  series.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric *metric;

/**
 *  The metric kind of the time series. When listing time series, this metric
 *  kind might be different from the metric kind of the associated metric if
 *  this time series is an alignment or reduction of other time series.When
 *  creating a time series, this field is optional. If present, it must be the
 *  same as the metric kind of the associated metric. If the associated metric's
 *  descriptor must be auto-created, then this field specifies the metric kind
 *  of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Delta The change in a value
 *        during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified Do not
 *        use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The data points of this time series. When listing time series, the order of
 *  the points is specified by the list method.When creating a time series, this
 *  field must contain exactly one point and the point's type must be the same
 *  as the value type of the associated metric. If the associated metric's
 *  descriptor must be auto-created, then the value type of the descriptor is
 *  determined by the point's type, which must be BOOL, INT64, DOUBLE, or
 *  DISTRIBUTION.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Point *> *points;

/**
 *  The associated resource. A fully-specified monitored resource used to
 *  identify the time series.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

/**
 *  The value type of the time series. When listing time series, this value type
 *  might be different from the value type of the associated metric if this time
 *  series is an alignment or reduction of other time series.When creating a
 *  time series, this field is optional. If present, it must be the same as the
 *  type of the data in the points field.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Bool The value is a boolean.
 *        This value type can be used only if the metric kind is GAUGE. (Value:
 *        "BOOL")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Distribution The value is a
 *        Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Double The value is a double
 *        precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Int64 The value is a signed
 *        64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Money The value is money.
 *        (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_String The value is a text
 *        string. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "STRING")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified Do not
 *        use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  A protocol buffer message type.
 */
@interface GTLRMonitoring_Type : GTLRObject

/** The list of fields. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Field *> *fields;

/** The fully qualified message name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The list of types appearing in oneof definitions in this type. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oneofs;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/** The source context. */
@property(nonatomic, strong, nullable) GTLRMonitoring_SourceContext *sourceContext;

/**
 *  The source syntax.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto2 Syntax proto2. (Value:
 *        "SYNTAX_PROTO2")
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto3 Syntax proto3. (Value:
 *        "SYNTAX_PROTO3")
 */
@property(nonatomic, copy, nullable) NSString *syntax;

@end


/**
 *  A single strongly-typed value.
 */
@interface GTLRMonitoring_TypedValue : GTLRObject

/**
 *  A Boolean value: true or false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Distribution *distributionValue;

/**
 *  A 64-bit double-precision floating-point number. Its magnitude is
 *  approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16 significant
 *  digits of precision.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** A variable-length string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end

NS_ASSUME_NONNULL_END
