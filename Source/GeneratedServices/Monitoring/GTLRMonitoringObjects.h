// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Stackdriver Monitoring API (monitoring/v3)
// Description:
//   Manages your Stackdriver Monitoring data and configurations. Most projects
//   must be associated with a Stackdriver account, with a few exceptions as
//   noted on the individual method pages.
// Documentation:
//   https://cloud.google.com/monitoring/api/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_BasicAuthentication;
@class GTLRMonitoring_BucketOptions;
@class GTLRMonitoring_CollectdPayload;
@class GTLRMonitoring_CollectdPayload_Metadata;
@class GTLRMonitoring_CollectdPayloadError;
@class GTLRMonitoring_CollectdValue;
@class GTLRMonitoring_CollectdValueError;
@class GTLRMonitoring_ContentMatcher;
@class GTLRMonitoring_Distribution;
@class GTLRMonitoring_Explicit;
@class GTLRMonitoring_Exponential;
@class GTLRMonitoring_Field;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_HttpCheck;
@class GTLRMonitoring_HttpCheck_Headers;
@class GTLRMonitoring_InternalChecker;
@class GTLRMonitoring_LabelDescriptor;
@class GTLRMonitoring_Linear;
@class GTLRMonitoring_Metric;
@class GTLRMonitoring_Metric_Labels;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_MonitoredResource;
@class GTLRMonitoring_MonitoredResource_Labels;
@class GTLRMonitoring_MonitoredResourceDescriptor;
@class GTLRMonitoring_MonitoredResourceMetadata;
@class GTLRMonitoring_MonitoredResourceMetadata_SystemLabels;
@class GTLRMonitoring_MonitoredResourceMetadata_UserLabels;
@class GTLRMonitoring_Option;
@class GTLRMonitoring_Option_Value;
@class GTLRMonitoring_Point;
@class GTLRMonitoring_Range;
@class GTLRMonitoring_ResourceGroup;
@class GTLRMonitoring_SourceContext;
@class GTLRMonitoring_Status;
@class GTLRMonitoring_Status_Details_Item;
@class GTLRMonitoring_TcpCheck;
@class GTLRMonitoring_TimeInterval;
@class GTLRMonitoring_TimeSeries;
@class GTLRMonitoring_TypedValue;
@class GTLRMonitoring_UptimeCheckConfig;
@class GTLRMonitoring_UptimeCheckIp;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRMonitoring_CollectdValue.dataSourceType

/**
 *  An amount of change since the last measurement interval. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.DELTA.
 *
 *  Value: "ABSOLUTE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Absolute;
/**
 *  A cumulative value over time. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.CUMULATIVE.
 *
 *  Value: "COUNTER"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Counter;
/**
 *  A rate of change of the measurement.
 *
 *  Value: "DERIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Derive;
/**
 *  An instantaneous measurement of a varying quantity. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.GAUGE.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Gauge;
/**
 *  An unspecified data source type. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *
 *  Value: "UNSPECIFIED_DATA_SOURCE_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.cardinality

/**
 *  For optional fields.
 *
 *  Value: "CARDINALITY_OPTIONAL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityOptional;
/**
 *  For repeated fields.
 *
 *  Value: "CARDINALITY_REPEATED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRepeated;
/**
 *  For required fields. Proto2 syntax only.
 *
 *  Value: "CARDINALITY_REQUIRED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRequired;
/**
 *  For fields with unknown cardinality.
 *
 *  Value: "CARDINALITY_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.kind

/**
 *  Field type bool.
 *
 *  Value: "TYPE_BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBool;
/**
 *  Field type bytes.
 *
 *  Value: "TYPE_BYTES"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBytes;
/**
 *  Field type double.
 *
 *  Value: "TYPE_DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeDouble;
/**
 *  Field type enum.
 *
 *  Value: "TYPE_ENUM"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeEnum;
/**
 *  Field type fixed32.
 *
 *  Value: "TYPE_FIXED32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed32;
/**
 *  Field type fixed64.
 *
 *  Value: "TYPE_FIXED64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed64;
/**
 *  Field type float.
 *
 *  Value: "TYPE_FLOAT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFloat;
/**
 *  Field type group. Proto2 syntax only, and deprecated.
 *
 *  Value: "TYPE_GROUP"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeGroup;
/**
 *  Field type int32.
 *
 *  Value: "TYPE_INT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt32;
/**
 *  Field type int64.
 *
 *  Value: "TYPE_INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt64;
/**
 *  Field type message.
 *
 *  Value: "TYPE_MESSAGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeMessage;
/**
 *  Field type sfixed32.
 *
 *  Value: "TYPE_SFIXED32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed32;
/**
 *  Field type sfixed64.
 *
 *  Value: "TYPE_SFIXED64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed64;
/**
 *  Field type sint32.
 *
 *  Value: "TYPE_SINT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint32;
/**
 *  Field type sint64.
 *
 *  Value: "TYPE_SINT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint64;
/**
 *  Field type string.
 *
 *  Value: "TYPE_STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeString;
/**
 *  Field type uint32.
 *
 *  Value: "TYPE_UINT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint32;
/**
 *  Field type uint64.
 *
 *  Value: "TYPE_UINT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint64;
/**
 *  Field type unknown.
 *
 *  Value: "TYPE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_LabelDescriptor.valueType

/**
 *  Boolean; true or false.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Bool;
/**
 *  A 64-bit signed integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Int64;
/**
 *  A variable-length string. This is the default.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_String;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ResourceGroup.resourceType

/**
 *  A group of Amazon ELB load balancers.
 *
 *  Value: "AWS_ELB_LOAD_BALANCER"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_AwsElbLoadBalancer;
/**
 *  A group of instances from Google Cloud Platform (GCP) or Amazon Web Services
 *  (AWS).
 *
 *  Value: "INSTANCE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_Instance;
/**
 *  Default value (not valid).
 *
 *  Value: "RESOURCE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_ResourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Type.syntax

/**
 *  Syntax proto2.
 *
 *  Value: "SYNTAX_PROTO2"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto2;
/**
 *  Syntax proto3.
 *
 *  Value: "SYNTAX_PROTO3"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto3;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckConfig.selectedRegions

/** Value: "ASIA_PACIFIC" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_AsiaPacific;
/** Value: "EUROPE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_Europe;
/** Value: "REGION_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_RegionUnspecified;
/** Value: "SOUTH_AMERICA" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_SouthAmerica;
/** Value: "USA" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_Usa;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckIp.region

/**
 *  Allows checks to run from locations within the Asia Pacific area (ex:
 *  Singapore).
 *
 *  Value: "ASIA_PACIFIC"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_AsiaPacific;
/**
 *  Allows checks to run from locations within the continent of Europe.
 *
 *  Value: "EUROPE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_Europe;
/**
 *  Default value if no region is specified. Will result in uptime checks
 *  running from all regions.
 *
 *  Value: "REGION_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_RegionUnspecified;
/**
 *  Allows checks to run from locations within the continent of South America.
 *
 *  Value: "SOUTH_AMERICA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_SouthAmerica;
/**
 *  Allows checks to run from locations within the United States of America.
 *
 *  Value: "USA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_Usa;

/**
 *  A type of authentication to perform against the specified resource or URL
 *  that uses username and password. Currently, only Basic authentication is
 *  supported in Uptime Monitoring.
 */
@interface GTLRMonitoring_BasicAuthentication : GTLRObject

/** The password to authenticate. */
@property(nonatomic, copy, nullable) NSString *password;

/** The username to authenticate. */
@property(nonatomic, copy, nullable) NSString *username;

@end


/**
 *  BucketOptions describes the bucket boundaries used to create a histogram for
 *  the distribution. The buckets can be in a linear sequence, an exponential
 *  sequence, or each bucket can be specified explicitly. BucketOptions does not
 *  include the number of values in each bucket.A bucket has an inclusive lower
 *  bound and exclusive upper bound for the values that are counted for that
 *  bucket. The upper bound of a bucket must be strictly greater than the lower
 *  bound. The sequence of N buckets for a distribution consists of an underflow
 *  bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
 *  an overflow bucket (number N - 1). The buckets are contiguous: the lower
 *  bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
 *  The buckets span the whole range of finite values: lower bound of the
 *  underflow bucket is -infinity and the upper bound of the overflow bucket is
 *  +infinity. The finite buckets are so-called because both bounds are finite.
 */
@interface GTLRMonitoring_BucketOptions : GTLRObject

/** The explicit buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Explicit *explicitBuckets;

/** The exponential buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Exponential *exponentialBuckets;

/** The linear bucket. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Linear *linearBuckets;

@end


/**
 *  A collection of data points sent from a collectd-based plugin. See the
 *  collectd documentation for more information.
 */
@interface GTLRMonitoring_CollectdPayload : GTLRObject

/** The end time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The measurement metadata. Example: "process_id" -> 12345 */
@property(nonatomic, strong, nullable) GTLRMonitoring_CollectdPayload_Metadata *metadata;

/** The name of the plugin. Example: "disk". */
@property(nonatomic, copy, nullable) NSString *plugin;

/** The instance name of the plugin Example: "hdcl". */
@property(nonatomic, copy, nullable) NSString *pluginInstance;

/** The start time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** The measurement type. Example: "memory". */
@property(nonatomic, copy, nullable) NSString *type;

/** The measurement type instance. Example: "used". */
@property(nonatomic, copy, nullable) NSString *typeInstance;

/**
 *  The measured values during this time interval. Each value must have a
 *  different dataSourceName.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValue *> *values;

@end


/**
 *  The measurement metadata. Example: "process_id" -> 12345
 *
 *  @note This class is documented as having more properties of
 *        GTLRMonitoring_TypedValue. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_CollectdPayload_Metadata : GTLRObject
@end


/**
 *  Describes the error status for payloads that were not written.
 */
@interface GTLRMonitoring_CollectdPayloadError : GTLRObject

/**
 *  Records the error status for the payload. If this field is present, the
 *  partial errors for nested values won't be populated.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *error;

/**
 *  The zero-based index in CreateCollectdTimeSeriesRequest.collectd_payloads.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Records the error status for values that were not written due to an
 *  error.Failed payloads for which nothing is written will not include partial
 *  value errors.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValueError *> *valueErrors;

@end


/**
 *  A single data point from a collectd-based plugin.
 */
@interface GTLRMonitoring_CollectdValue : GTLRObject

/**
 *  The data source for the collectd value. For example there are two data
 *  sources for network measurements: "rx" and "tx".
 */
@property(nonatomic, copy, nullable) NSString *dataSourceName;

/**
 *  The type of measurement.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Absolute An amount of
 *        change since the last measurement interval. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.DELTA. (Value: "ABSOLUTE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Counter A cumulative
 *        value over time. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.CUMULATIVE. (Value: "COUNTER")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Derive A rate of
 *        change of the measurement. (Value: "DERIVE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Gauge An
 *        instantaneous measurement of a varying quantity. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.GAUGE. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType
 *        An unspecified data source type. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *        (Value: "UNSPECIFIED_DATA_SOURCE_TYPE")
 */
@property(nonatomic, copy, nullable) NSString *dataSourceType;

/** The measurement value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  Describes the error status for values that were not written.
 */
@interface GTLRMonitoring_CollectdValueError : GTLRObject

/** Records the error status for the value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *error;

/**
 *  The zero-based index in CollectdPayload.values within the parent
 *  CreateCollectdTimeSeriesRequest.collectd_payloads.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

@end


/**
 *  Used to perform string matching. Currently, this matches on the exact
 *  content. In the future, it can be expanded to allow for regular expressions
 *  and more complex matching.
 */
@interface GTLRMonitoring_ContentMatcher : GTLRObject

/** String content to match (max 1024 bytes) */
@property(nonatomic, copy, nullable) NSString *content;

@end


/**
 *  The CreateCollectdTimeSeries request.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesRequest : GTLRObject

/**
 *  The collectd payloads representing the time series data. You must not
 *  include more than a single point for each time series, so no two payloads
 *  can have the same values for all of the fields plugin, plugin_instance,
 *  type, and type_instance.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayload *> *collectdPayloads;

/**
 *  The version of collectd that collected the data. Example: "5.3.0-192.el6".
 */
@property(nonatomic, copy, nullable) NSString *collectdVersion;

/** The monitored resource associated with the time series. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

@end


/**
 *  The CreateCollectdTimeSeries response.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesResponse : GTLRObject

/**
 *  Records the error status for points that were not written due to an
 *  error.Failed requests for which nothing is written will return an error
 *  response instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayloadError *> *payloadErrors;

@end


/**
 *  The CreateTimeSeries request.
 */
@interface GTLRMonitoring_CreateTimeSeriesRequest : GTLRObject

/**
 *  The new data to be added to a list of time series. Adds at most one data
 *  point to each of several time series. The new data point must be more recent
 *  than any other point in its time series. Each TimeSeries value must fully
 *  specify a unique time series by supplying all label values for the metric
 *  and the monitored resource.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  Distribution contains summary statistics for a population of values. It
 *  optionally contains a histogram representing the distribution of those
 *  values across a set of buckets.The summary statistics are the count, mean,
 *  sum of the squared deviation from the mean, the minimum, and the maximum of
 *  the set of population of values. The histogram is based on a sequence of
 *  buckets and gives a count of values that fall into each bucket. The
 *  boundaries of the buckets are given either explicitly or by formulas for
 *  buckets of fixed or exponentially increasing widths.Although it is not
 *  forbidden, it is generally a bad idea to include non-finite values
 *  (infinities or NaNs) in the population of values, as this will render the
 *  mean and sum_of_squared_deviation fields meaningless.
 */
@interface GTLRMonitoring_Distribution : GTLRObject

/**
 *  Required in the Stackdriver Monitoring API v3. The values for each bucket
 *  specified in bucket_options. The sum of the values in bucketCounts must
 *  equal the value in the count field of the Distribution object. The order of
 *  the bucket counts follows the numbering schemes described for the three
 *  bucket types. The underflow bucket has number 0; the finite buckets, if any,
 *  have numbers 1 through N-2; and the overflow bucket has number N-1. The size
 *  of bucket_counts must not be greater than N. If the size is less than N,
 *  then the remaining buckets are assigned values of zero.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  Required in the Stackdriver Monitoring API v3. Defines the histogram bucket
 *  boundaries.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BucketOptions *bucketOptions;

/**
 *  The number of values in the population. Must be non-negative. This value
 *  must equal the sum of the values in bucket_counts if a histogram is
 *  provided.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The arithmetic mean of the values in the population. If count is zero then
 *  this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  If specified, contains the range of the population values. The field must
 *  not be present if the count is zero. This field is presently ignored by the
 *  Stackdriver Monitoring API v3.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Range *range;

/**
 *  The sum of squared deviations from the mean of the values in the population.
 *  For values x_i this is:
 *  Sum[i=1..n]((x_i - mean)^2)
 *  Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
 *  describes Welford's method for accumulating this sum in one pass.If count is
 *  zero then this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for Empty is empty JSON object {}.
 */
@interface GTLRMonitoring_Empty : GTLRObject
@end


/**
 *  Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1
 *  (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i <
 *  N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must
 *  contain at least one element. If bounds has only one element, then there are
 *  no finite buckets, and that single element is the common boundary of the
 *  overflow and underflow buckets.
 */
@interface GTLRMonitoring_Explicit : GTLRObject

/**
 *  The values must be monotonically increasing.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Specifies an exponential sequence of buckets that have a width that is
 *  proportional to the value of the lower bound. Each bucket represents a
 *  constant relative uncertainty on a specific value in the bucket.There are
 *  num_finite_buckets + 2 (= N) buckets. Bucket i has the following
 *  boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower
 *  bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
 */
@interface GTLRMonitoring_Exponential : GTLRObject

/**
 *  Must be greater than 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  A single field of a message type.
 */
@interface GTLRMonitoring_Field : GTLRObject

/**
 *  The field cardinality.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityOptional For optional
 *        fields. (Value: "CARDINALITY_OPTIONAL")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRepeated For repeated
 *        fields. (Value: "CARDINALITY_REPEATED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRequired For required
 *        fields. Proto2 syntax only. (Value: "CARDINALITY_REQUIRED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityUnknown For fields
 *        with unknown cardinality. (Value: "CARDINALITY_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *cardinality;

/**
 *  The string value of the default value of this field. Proto2 syntax only.
 */
@property(nonatomic, copy, nullable) NSString *defaultValue;

/** The field JSON name. */
@property(nonatomic, copy, nullable) NSString *jsonName;

/**
 *  The field type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBool Field type bool. (Value:
 *        "TYPE_BOOL")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBytes Field type bytes. (Value:
 *        "TYPE_BYTES")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeDouble Field type double. (Value:
 *        "TYPE_DOUBLE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeEnum Field type enum. (Value:
 *        "TYPE_ENUM")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed32 Field type fixed32. (Value:
 *        "TYPE_FIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed64 Field type fixed64. (Value:
 *        "TYPE_FIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFloat Field type float. (Value:
 *        "TYPE_FLOAT")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeGroup Field type group. Proto2
 *        syntax only, and deprecated. (Value: "TYPE_GROUP")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt32 Field type int32. (Value:
 *        "TYPE_INT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt64 Field type int64. (Value:
 *        "TYPE_INT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeMessage Field type message. (Value:
 *        "TYPE_MESSAGE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed32 Field type sfixed32.
 *        (Value: "TYPE_SFIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed64 Field type sfixed64.
 *        (Value: "TYPE_SFIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint32 Field type sint32. (Value:
 *        "TYPE_SINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint64 Field type sint64. (Value:
 *        "TYPE_SINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeString Field type string. (Value:
 *        "TYPE_STRING")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint32 Field type uint32. (Value:
 *        "TYPE_UINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint64 Field type uint64. (Value:
 *        "TYPE_UINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUnknown Field type unknown. (Value:
 *        "TYPE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The field name. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The field number.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *number;

/**
 *  The index of the field type in Type.oneofs, for message or enumeration
 *  types. The first type has index 1; zero means the type is not in the list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneofIndex;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/**
 *  Whether to use alternative packed wire representation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packed;

/**
 *  The field type URL, without the scheme, for message or enumeration types.
 *  Example: "type.googleapis.com/google.protobuf.Timestamp".
 */
@property(nonatomic, copy, nullable) NSString *typeUrl;

@end


/**
 *  The description of a dynamic collection of monitored resources. Each group
 *  has a filter that is matched against monitored resources and their
 *  associated metadata. If a group's filter matches an available monitored
 *  resource, then that resource is a member of that group. Groups can contain
 *  any number of monitored resources, and each monitored resource can be a
 *  member of any number of groups.Groups can be nested in parent-child
 *  hierarchies. The parentName field identifies an optional parent for each
 *  group. If a group has a parent, then the only monitored resources available
 *  to be matched by the group's filter are the resources contained in the
 *  parent group. In other words, a group contains the monitored resources that
 *  match its filter and the filters of all the group's ancestors. A group
 *  without a parent can contain any monitored resource.For example, consider an
 *  infrastructure running a set of instances with two user-defined tags:
 *  "environment" and "role". A parent group has a filter,
 *  environment="production". A child of that parent group has a filter,
 *  role="transcoder". The parent group contains all instances in the production
 *  environment, regardless of their roles. The child group contains instances
 *  that have the transcoder role and are in the production environment.The
 *  monitored resources contained in a group can change at any moment, depending
 *  on what resources exist and what filters are associated with the group and
 *  its ancestors.
 */
@interface GTLRMonitoring_Group : GTLRObject

/** A user-assigned name for this group, used only for display purposes. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The filter used to determine which monitored resources belong to this group.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  If true, the members of this group are considered to be a cluster. The
 *  system can perform additional analysis on groups that are clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isCluster;

/**
 *  Output only. The name of this group. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". When creating a group,
 *  this field is ignored and a new name is created consisting of the project
 *  specified in the call to CreateGroup and a unique {group_id} that is
 *  generated automatically.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the group's parent, if it has one. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". For groups with no
 *  parent, parentName is the empty string, "".
 */
@property(nonatomic, copy, nullable) NSString *parentName;

@end


/**
 *  Information involved in an HTTP/HTTPS uptime check request.
 */
@interface GTLRMonitoring_HttpCheck : GTLRObject

/**
 *  The authentication information. Optional when creating an HTTP check;
 *  defaults to empty.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicAuthentication *authInfo;

/**
 *  The list of headers to send as part of the uptime check request. If two
 *  headers have the same key and different values, they should be entered as a
 *  single header, with the value being a comma-separated list of all the
 *  desired values as described at
 *  https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two
 *  separate headers with the same key in a Create call will cause the first to
 *  be overwritten by the second. The maximum number of headers allowed is 100.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_HttpCheck_Headers *headers;

/**
 *  Boolean specifiying whether to encrypt the header information. Encryption
 *  should be specified for any headers related to authentication that you do
 *  not wish to be seen when retrieving the configuration. The server will be
 *  responsible for encrypting the headers. On Get/List calls, if mask_headers
 *  is set to True then the headers will be obscured with ******.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maskHeaders;

/**
 *  The path to the page to run the check against. Will be combined with the
 *  host (specified within the MonitoredResource) and port to construct the full
 *  URL. Optional (defaults to "/").
 */
@property(nonatomic, copy, nullable) NSString *path;

/**
 *  The port to the page to run the check against. Will be combined with host
 *  (specified within the MonitoredResource) and path to construct the full URL.
 *  Optional (defaults to 80 without SSL, or 443 with SSL).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

/**
 *  If true, use HTTPS instead of HTTP to run the check.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useSsl;

@end


/**
 *  The list of headers to send as part of the uptime check request. If two
 *  headers have the same key and different values, they should be entered as a
 *  single header, with the value being a comma-separated list of all the
 *  desired values as described at
 *  https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two
 *  separate headers with the same key in a Create call will cause the first to
 *  be overwritten by the second. The maximum number of headers allowed is 100.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_HttpCheck_Headers : GTLRObject
@end


/**
 *  Nimbus InternalCheckers.
 */
@interface GTLRMonitoring_InternalChecker : GTLRObject

/** The checker ID. */
@property(nonatomic, copy, nullable) NSString *checkerId;

/** The checker's human-readable name. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The GCP zone the uptime check should egress from. Only respected for
 *  internal uptime checks, where internal_network is specified.
 */
@property(nonatomic, copy, nullable) NSString *gcpZone;

/** The internal network to perform this uptime check on. */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  The GCP project ID. Not necessarily the same as the project_id for the
 *  config.
 */
@property(nonatomic, copy, nullable) NSString *projectId;

@end


/**
 *  A description of a label.
 */
@interface GTLRMonitoring_LabelDescriptor : GTLRObject

/**
 *  A human-readable description for the label.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The label key. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  The type of data that can be assigned to the label.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Bool Boolean; true or
 *        false. (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Int64 A 64-bit signed
 *        integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_String A variable-length
 *        string. This is the default. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Specifies a linear sequence of buckets that all have the same width (except
 *  overflow and underflow). Each bucket represents a constant absolute
 *  uncertainty on the specific value in the bucket.There are num_finite_buckets
 *  + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i
 *  < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i
 *  - 1)).
 */
@interface GTLRMonitoring_Linear : GTLRObject

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Lower bound of the first bucket.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  The ListGroupMembers response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "members" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupMembersResponse : GTLRCollectionObject

/**
 *  A set of monitored resources in the group.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResource *> *members;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of elements matching this request.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The ListGroups response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "group" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupsResponse : GTLRCollectionObject

/**
 *  The groups that match the specified filters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Group *> *group;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMetricDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "metricDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMetricDescriptorsResponse : GTLRCollectionObject

/**
 *  The metric descriptors that are available to the project and that match the
 *  value of filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MetricDescriptor *> *metricDescriptors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMonitoredResourceDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resourceDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMonitoredResourceDescriptorsResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The monitored resource descriptors that are available to this project and
 *  that match filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResourceDescriptor *> *resourceDescriptors;

@end


/**
 *  The ListTimeSeries response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "timeSeries" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListTimeSeriesResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  One or more time series that match the filter included in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  The protocol for the ListUptimeCheckConfigs response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "uptimeCheckConfigs" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListUptimeCheckConfigsResponse : GTLRCollectionObject

/**
 *  This field represents the pagination token to retrieve the next page of
 *  results. If the value is empty, it means no further results for the request.
 *  To retrieve the next page of results, the value of the next_page_token is
 *  passed to the subsequent List method call (in the request message's
 *  page_token field).
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of uptime check configurations for the project,
 *  irrespective of any pagination.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

/**
 *  The returned uptime check configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_UptimeCheckConfig *> *uptimeCheckConfigs;

@end


/**
 *  The protocol for the ListUptimeCheckIps response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "uptimeCheckIps" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRMonitoring_ListUptimeCheckIpsResponse : GTLRCollectionObject

/**
 *  This field represents the pagination token to retrieve the next page of
 *  results. If the value is empty, it means no further results for the request.
 *  To retrieve the next page of results, the value of the next_page_token is
 *  passed to the subsequent List method call (in the request message's
 *  page_token field). NOTE: this field is not yet implemented
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The returned list of IP addresses (including region and location) that the
 *  checkers run from.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_UptimeCheckIp *> *uptimeCheckIps;

@end


/**
 *  A specific metric, identified by specifying values for all of the labels of
 *  a MetricDescriptor.
 */
@interface GTLRMonitoring_Metric : GTLRObject

/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric_Labels *labels;

/**
 *  An existing metric type, see google.api.MetricDescriptor. For example,
 *  custom.googleapis.com/invoice/paid/amount.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_Metric_Labels : GTLRObject
@end


/**
 *  Defines a metric type and its schema. Once a metric descriptor is created,
 *  deleting or altering it stops data collection and makes the metric type's
 *  existing data unusable.
 */
@interface GTLRMonitoring_MetricDescriptor : GTLRObject

/**
 *  A detailed description of the metric, which can be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A concise name for the metric, which can be displayed in user interfaces.
 *  Use sentence case without an ending period, for example "Request count".
 *  This field is optional but it is recommended to be set for any metrics
 *  associated with user-visible concepts, such as Quota.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that can be used to describe a specific instance of this
 *  metric type. For example, the
 *  appengine.googleapis.com/http/server/response_latencies metric type has a
 *  label for the HTTP response code, response_code, so you can look at
 *  latencies for successful responses or just for responses that failed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Whether the metric records instantaneous values, changes to a value, etc.
 *  Some combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Delta The change in a
 *        value during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified
 *        Do not use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/** The resource name of the metric descriptor. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The metric type, including its DNS name prefix. The type is not URL-encoded.
 *  All user-defined custom metric types have the DNS name
 *  custom.googleapis.com. Metric types should use a natural hierarchical
 *  grouping. For example:
 *  "custom.googleapis.com/invoice/paid/amount"
 *  "appengine.googleapis.com/http/server/response_latencies"
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  Optional. The unit in which the metric value is reported. For example, kBy/s
 *  means kilobytes/sec, and 1 is the dimensionless unit. The supported units
 *  are a subset of The Unified Code for Units of Measure standard
 *  (http://unitsofmeasure.org/ucum.html).<br><br> This field is part of the
 *  metric's documentation, but it is ignored by Stackdriver.
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  Whether the measurement is an integer, a floating-point number, etc. Some
 *  combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Bool The value is a
 *        boolean. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Distribution The value
 *        is a Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Double The value is a
 *        double precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Int64 The value is a
 *        signed 64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Money The value is
 *        money. (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_String The value is a
 *        text string. This value type can be used only if the metric kind is
 *        GAUGE. (Value: "STRING")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified Do
 *        not use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  An object representing a resource that can be used for monitoring, logging,
 *  billing, or other purposes. Examples include virtual machine instances,
 *  databases, and storage devices such as disks. The type field identifies a
 *  MonitoredResourceDescriptor object that describes the resource's schema.
 *  Information in the labels field identifies the actual resource and its
 *  attributes according to the schema. For example, a particular Compute Engine
 *  VM instance could be represented by the following object, because the
 *  MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and
 *  "zone":
 *  { "type": "gce_instance",
 *  "labels": { "instance_id": "12345678901234",
 *  "zone": "us-central1-a" }}
 */
@interface GTLRMonitoring_MonitoredResource : GTLRObject

/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Compute Engine VM instances use the labels
 *  "project_id", "instance_id", and "zone".
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource_Labels *labels;

/**
 *  Required. The monitored resource type. This field must match the type field
 *  of a MonitoredResourceDescriptor object. For example, the type of a Compute
 *  Engine VM instance is gce_instance.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Compute Engine VM instances use the labels
 *  "project_id", "instance_id", and "zone".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResource_Labels : GTLRObject
@end


/**
 *  An object that describes the schema of a MonitoredResource object using a
 *  type name and a set of labels. For example, the monitored resource
 *  descriptor for Google Compute Engine VM instances has a type of
 *  "gce_instance" and specifies the use of the labels "instance_id" and "zone"
 *  to identify particular VM instances.Different APIs can support different
 *  monitored resource types. APIs generally provide a list method that returns
 *  the monitored resource descriptors used by the API.
 */
@interface GTLRMonitoring_MonitoredResourceDescriptor : GTLRObject

/**
 *  Optional. A detailed description of the monitored resource type that might
 *  be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. A concise name for the monitored resource type that might be
 *  displayed in user interfaces. It should be a Title Cased Noun Phrase,
 *  without any article or other determiners. For example, "Google Cloud SQL
 *  Database".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required. A set of labels used to describe instances of this monitored
 *  resource type. For example, an individual Google Cloud SQL database is
 *  identified by values for the labels "database_id" and "zone".
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Optional. The resource name of the monitored resource descriptor:
 *  "projects/{project_id}/monitoredResourceDescriptors/{type}" where {type} is
 *  the value of the type field in this object and {project_id} is a project ID
 *  that provides API-specific context for accessing the type. APIs that do not
 *  use project information can use the resource name format
 *  "monitoredResourceDescriptors/{type}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The monitored resource type. For example, the type
 *  "cloudsql_database" represents databases in Google Cloud SQL. The maximum
 *  length of this value is 256 characters.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Auxiliary metadata for a MonitoredResource object. MonitoredResource objects
 *  contain the minimum set of information to uniquely identify a monitored
 *  resource instance. There is some other useful auxiliary metadata. Google
 *  Stackdriver Monitoring & Logging uses an ingestion pipeline to extract
 *  metadata for cloud resources of all types , and stores the metadata in this
 *  message.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata : GTLRObject

/**
 *  Output only. Values for predefined system metadata labels. System labels are
 *  a kind of metadata extracted by Google Stackdriver. Stackdriver determines
 *  what system labels are useful and how to obtain their values. Some examples:
 *  "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System
 *  label values can be only strings, Boolean values, or a list of strings. For
 *  example:
 *  { "name": "my-test-instance",
 *  "security_group": ["a", "b", "c"],
 *  "spot_instance": false }
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata_SystemLabels *systemLabels;

/** Output only. A map of user-defined metadata labels. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata_UserLabels *userLabels;

@end


/**
 *  Output only. Values for predefined system metadata labels. System labels are
 *  a kind of metadata extracted by Google Stackdriver. Stackdriver determines
 *  what system labels are useful and how to obtain their values. Some examples:
 *  "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System
 *  label values can be only strings, Boolean values, or a list of strings. For
 *  example:
 *  { "name": "my-test-instance",
 *  "security_group": ["a", "b", "c"],
 *  "spot_instance": false }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata_SystemLabels : GTLRObject
@end


/**
 *  Output only. A map of user-defined metadata labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata_UserLabels : GTLRObject
@end


/**
 *  A protocol buffer option, which can be attached to a message, field,
 *  enumeration, etc.
 */
@interface GTLRMonitoring_Option : GTLRObject

/**
 *  The option's name. For protobuf built-in options (options defined in
 *  descriptor.proto), this is the short name. For example, "map_entry". For
 *  custom options, it should be the fully-qualified name. For example,
 *  "google.api.http".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Option_Value *value;

@end


/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Option_Value : GTLRObject
@end


/**
 *  A single data point in a time series.
 */
@interface GTLRMonitoring_Point : GTLRObject

/**
 *  The time interval to which the data point applies. For GAUGE metrics, only
 *  the end time of the interval is used. For DELTA metrics, the start and end
 *  time should specify a non-zero interval, with subsequent points specifying
 *  contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start
 *  and end time should specify a non-zero interval, with subsequent points
 *  specifying the same start time and increasing end times, until an event
 *  resets the cumulative value to zero and sets a new start time for the
 *  following points.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeInterval *interval;

/** The value of the data point. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  The range of the population values.
 */
@interface GTLRMonitoring_Range : GTLRObject

/**
 *  The maximum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *max;

/**
 *  The minimum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *min;

@end


/**
 *  The resource submessage for group checks. It can be used instead of a
 *  monitored resource, when multiple resources are being monitored.
 */
@interface GTLRMonitoring_ResourceGroup : GTLRObject

/**
 *  The group of resources being monitored. Should be only the group_id, not
 *  projects/<project_id>/groups/<group_id>.
 */
@property(nonatomic, copy, nullable) NSString *groupId;

/**
 *  The resource type of the group members.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_AwsElbLoadBalancer A
 *        group of Amazon ELB load balancers. (Value: "AWS_ELB_LOAD_BALANCER")
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_Instance A group of
 *        instances from Google Cloud Platform (GCP) or Amazon Web Services
 *        (AWS). (Value: "INSTANCE")
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_ResourceTypeUnspecified
 *        Default value (not valid). (Value: "RESOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  SourceContext represents information about the source of a protobuf element,
 *  like the file in which it is defined.
 */
@interface GTLRMonitoring_SourceContext : GTLRObject

/**
 *  The path-qualified name of the .proto file that contained the associated
 *  protobuf element. For example: "google/protobuf/source_context.proto".
 */
@property(nonatomic, copy, nullable) NSString *fileName;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). The error model is designed to be:
 *  Simple to use and understand for most users
 *  Flexible enough to meet unexpected needsOverviewThe Status message contains
 *  three pieces of data: error code, error message, and error details. The
 *  error code should be an enum value of google.rpc.Code, but it may accept
 *  additional error codes if needed. The error message should be a
 *  developer-facing English message that helps developers understand and
 *  resolve the error. If a localized user-facing error message is needed, put
 *  the localized message in the error details or localize it in the client. The
 *  optional error details may contain arbitrary information about the error.
 *  There is a predefined set of error detail types in the package google.rpc
 *  that can be used for common error conditions.Language mappingThe Status
 *  message is the logical representation of the error model, but it is not
 *  necessarily the actual wire format. When the Status message is exposed in
 *  different client libraries and different wire protocols, it can be mapped
 *  differently. For example, it will likely be mapped to some exceptions in
 *  Java, but more likely mapped to some error codes in C.Other usesThe error
 *  model and the Status message can be used in a variety of environments,
 *  either with or without APIs, to provide a consistent developer experience
 *  across different environments.Example uses of this error model include:
 *  Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the Status in the normal response to indicate the partial
 *  errors.
 *  Workflow errors. A typical workflow has multiple steps. Each step may have a
 *  Status message for error reporting.
 *  Batch operations. If a client uses batch request and batch response, the
 *  Status message should be used directly inside batch response, one for each
 *  error sub-response.
 *  Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the Status message.
 *  Logging. If some API errors are stored in logs, the message Status could be
 *  used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRMonitoring_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRMonitoring_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Status_Details_Item : GTLRObject
@end


/**
 *  Information required for a TCP uptime check request.
 */
@interface GTLRMonitoring_TcpCheck : GTLRObject

/**
 *  The port to the page to run the check against. Will be combined with host
 *  (specified within the MonitoredResource) to construct the full URL.
 *  Required.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

@end


/**
 *  A time interval extending just after a start time through an end time. If
 *  the start time is the same as the end time, then the interval represents a
 *  single point in time.
 */
@interface GTLRMonitoring_TimeInterval : GTLRObject

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  A collection of data points that describes the time-varying values of a
 *  metric. A time series is identified by a combination of a fully-specified
 *  monitored resource and a fully-specified metric. This type is used for both
 *  listing and creating time series.
 */
@interface GTLRMonitoring_TimeSeries : GTLRObject

/**
 *  Output only. The associated monitored resource metadata. When reading a a
 *  timeseries, this field will include metadata labels that are explicitly
 *  named in the reduction. When creating a timeseries, this field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata *metadata;

/**
 *  The associated metric. A fully-specified metric used to identify the time
 *  series.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric *metric;

/**
 *  The metric kind of the time series. When listing time series, this metric
 *  kind might be different from the metric kind of the associated metric if
 *  this time series is an alignment or reduction of other time series.When
 *  creating a time series, this field is optional. If present, it must be the
 *  same as the metric kind of the associated metric. If the associated metric's
 *  descriptor must be auto-created, then this field specifies the metric kind
 *  of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Delta The change in a value
 *        during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified Do not
 *        use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The data points of this time series. When listing time series, points are
 *  returned in reverse time order.When creating a time series, this field must
 *  contain exactly one point and the point's type must be the same as the value
 *  type of the associated metric. If the associated metric's descriptor must be
 *  auto-created, then the value type of the descriptor is determined by the
 *  point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Point *> *points;

/**
 *  The associated monitored resource. Custom metrics can use only certain
 *  monitored resource types in their time series data.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

/**
 *  The value type of the time series. When listing time series, this value type
 *  might be different from the value type of the associated metric if this time
 *  series is an alignment or reduction of other time series.When creating a
 *  time series, this field is optional. If present, it must be the same as the
 *  type of the data in the points field.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Bool The value is a boolean.
 *        This value type can be used only if the metric kind is GAUGE. (Value:
 *        "BOOL")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Distribution The value is a
 *        Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Double The value is a double
 *        precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Int64 The value is a signed
 *        64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Money The value is money.
 *        (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_String The value is a text
 *        string. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "STRING")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified Do not
 *        use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  A protocol buffer message type.
 */
@interface GTLRMonitoring_Type : GTLRObject

/** The list of fields. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Field *> *fields;

/** The fully qualified message name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The list of types appearing in oneof definitions in this type. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oneofs;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/** The source context. */
@property(nonatomic, strong, nullable) GTLRMonitoring_SourceContext *sourceContext;

/**
 *  The source syntax.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto2 Syntax proto2. (Value:
 *        "SYNTAX_PROTO2")
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto3 Syntax proto3. (Value:
 *        "SYNTAX_PROTO3")
 */
@property(nonatomic, copy, nullable) NSString *syntax;

@end


/**
 *  A single strongly-typed value.
 */
@interface GTLRMonitoring_TypedValue : GTLRObject

/**
 *  A Boolean value: true or false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Distribution *distributionValue;

/**
 *  A 64-bit double-precision floating-point number. Its magnitude is
 *  approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16 significant
 *  digits of precision.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** A variable-length string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  This message configures which resources and services to monitor for
 *  availability.
 */
@interface GTLRMonitoring_UptimeCheckConfig : GTLRObject

/**
 *  The expected content on the page the check is run against. Currently, only
 *  the first entry in the list is supported, and other entries will be ignored.
 *  The server will look for an exact match of the string in the page response's
 *  content. This field is optional and should only be specified if a content
 *  match is required.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_ContentMatcher *> *contentMatchers;

/**
 *  A human-friendly name for the uptime check configuration. The display name
 *  should be unique within a Stackdriver Account in order to make it easier to
 *  identify; however, uniqueness is not enforced. Required.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Contains information needed to make an HTTP or HTTPS check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_HttpCheck *httpCheck;

/**
 *  The internal checkers that this check will egress from. If is_internal is
 *  true and this list is empty, the check will egress from all InternalCheckers
 *  configured for the project that owns this CheckConfig.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_InternalChecker *> *internalCheckers;

/**
 *  Denotes whether this is a check that egresses from InternalCheckers.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isInternal;

/**
 *  The monitored resource (https://cloud.google.com/monitoring/api/resources)
 *  associated with the configuration. The following monitored resource types
 *  are supported for uptime checks: uptime_url gce_instance gae_app
 *  aws_ec2_instance aws_elb_load_balancer
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *monitoredResource;

/**
 *  A unique resource name for this UptimeCheckConfig. The format
 *  is:projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].This field
 *  should be omitted when creating the uptime check configuration; on create,
 *  the resource name is assigned by the server and included in the response.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  How often, in seconds, the uptime check is performed. Currently, the only
 *  supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes),
 *  and 900s (15 minutes). Required.
 */
@property(nonatomic, strong, nullable) GTLRDuration *period;

/** The group resource associated with the configuration. */
@property(nonatomic, strong, nullable) GTLRMonitoring_ResourceGroup *resourceGroup;

/**
 *  The list of regions from which the check will be run. If this field is
 *  specified, enough regions to include a minimum of 3 locations must be
 *  provided, or an error message is returned. Not specifying this field will
 *  result in uptime checks running from all regions.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *selectedRegions;

/** Contains information needed to make a TCP check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TcpCheck *tcpCheck;

/**
 *  The maximum amount of time to wait for the request to complete (must be
 *  between 1 and 60 seconds). Required.
 */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

@end


/**
 *  Contains the region, location, and list of IP addresses where checkers in
 *  the location run from.
 */
@interface GTLRMonitoring_UptimeCheckIp : GTLRObject

/**
 *  The IP address from which the uptime check originates. This is a full IP
 *  address (not an IP address range). Most IP addresses, as of this
 *  publication, are in IPv4 format; however, one should not rely on the IP
 *  addresses being in IPv4 format indefinitely and should support interpreting
 *  this field in either IPv4 or IPv6 format.
 */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/**
 *  A more specific location within the region that typically encodes a
 *  particular city/town/metro (and its containing state/province or country)
 *  within the broader umbrella region category.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  A broad region category in which the IP address is located.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_AsiaPacific Allows checks to
 *        run from locations within the Asia Pacific area (ex: Singapore).
 *        (Value: "ASIA_PACIFIC")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_Europe Allows checks to run
 *        from locations within the continent of Europe. (Value: "EUROPE")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_RegionUnspecified Default
 *        value if no region is specified. Will result in uptime checks running
 *        from all regions. (Value: "REGION_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_SouthAmerica Allows checks to
 *        run from locations within the continent of South America. (Value:
 *        "SOUTH_AMERICA")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_Usa Allows checks to run from
 *        locations within the United States of America. (Value: "USA")
 */
@property(nonatomic, copy, nullable) NSString *region;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
