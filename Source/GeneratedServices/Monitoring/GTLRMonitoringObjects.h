// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Stackdriver Monitoring API (monitoring/v3)
// Description:
//   Manages your Stackdriver Monitoring data and configurations. Most projects
//   must be associated with a Stackdriver account, with a few exceptions as
//   noted on the individual method pages.
// Documentation:
//   https://cloud.google.com/monitoring/api/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_Aggregation;
@class GTLRMonitoring_AlertPolicy;
@class GTLRMonitoring_AlertPolicy_UserLabels;
@class GTLRMonitoring_BasicAuthentication;
@class GTLRMonitoring_BucketOptions;
@class GTLRMonitoring_CollectdPayload;
@class GTLRMonitoring_CollectdPayload_Metadata;
@class GTLRMonitoring_CollectdPayloadError;
@class GTLRMonitoring_CollectdValue;
@class GTLRMonitoring_CollectdValueError;
@class GTLRMonitoring_Condition;
@class GTLRMonitoring_ContentMatcher;
@class GTLRMonitoring_Distribution;
@class GTLRMonitoring_Documentation;
@class GTLRMonitoring_DroppedLabels_Label;
@class GTLRMonitoring_Exemplar;
@class GTLRMonitoring_Exemplar_Attachments_Item;
@class GTLRMonitoring_Explicit;
@class GTLRMonitoring_Exponential;
@class GTLRMonitoring_Field;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_HttpCheck;
@class GTLRMonitoring_HttpCheck_Headers;
@class GTLRMonitoring_InternalChecker;
@class GTLRMonitoring_LabelDescriptor;
@class GTLRMonitoring_Linear;
@class GTLRMonitoring_Metric;
@class GTLRMonitoring_Metric_Labels;
@class GTLRMonitoring_MetricAbsence;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_MetricDescriptorMetadata;
@class GTLRMonitoring_MetricThreshold;
@class GTLRMonitoring_MonitoredResource;
@class GTLRMonitoring_MonitoredResource_Labels;
@class GTLRMonitoring_MonitoredResourceDescriptor;
@class GTLRMonitoring_MonitoredResourceMetadata;
@class GTLRMonitoring_MonitoredResourceMetadata_SystemLabels;
@class GTLRMonitoring_MonitoredResourceMetadata_UserLabels;
@class GTLRMonitoring_MutationRecord;
@class GTLRMonitoring_NotificationChannel;
@class GTLRMonitoring_NotificationChannel_Labels;
@class GTLRMonitoring_NotificationChannel_UserLabels;
@class GTLRMonitoring_NotificationChannelDescriptor;
@class GTLRMonitoring_Option;
@class GTLRMonitoring_Option_Value;
@class GTLRMonitoring_Point;
@class GTLRMonitoring_Range;
@class GTLRMonitoring_ResourceGroup;
@class GTLRMonitoring_SourceContext;
@class GTLRMonitoring_Status;
@class GTLRMonitoring_Status_Details_Item;
@class GTLRMonitoring_TcpCheck;
@class GTLRMonitoring_TimeInterval;
@class GTLRMonitoring_TimeSeries;
@class GTLRMonitoring_Trigger;
@class GTLRMonitoring_TypedValue;
@class GTLRMonitoring_UptimeCheckConfig;
@class GTLRMonitoring_UptimeCheckIp;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRMonitoring_Aggregation.crossSeriesReducer

/**
 *  Reduce by computing the count of data points across time series for each
 *  alignment period. This reducer is valid for delta and gauge metrics of
 *  numeric, Boolean, distribution, and string value type. The value type of the
 *  output is INT64.
 *
 *  Value: "REDUCE_COUNT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCount;
/**
 *  Reduce by computing the count of False-valued data points across time series
 *  for each alignment period. This reducer is valid for delta and gauge metrics
 *  of Boolean value type. The value type of the output is INT64.
 *
 *  Value: "REDUCE_COUNT_FALSE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountFalse;
/**
 *  Reduce by computing the count of True-valued data points across time series
 *  for each alignment period. This reducer is valid for delta and gauge metrics
 *  of Boolean value type. The value type of the output is INT64.
 *
 *  Value: "REDUCE_COUNT_TRUE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountTrue;
/**
 *  Reduce by computing the fraction of True-valued data points across time
 *  series for each alignment period. This reducer is valid for delta and gauge
 *  metrics of Boolean value type. The output value is in the range 0, 1 and has
 *  value type DOUBLE.
 *
 *  Value: "REDUCE_FRACTION_TRUE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceFractionTrue;
/**
 *  Reduce by computing the maximum across time series for each alignment
 *  period. This reducer is valid for delta and gauge metrics with numeric
 *  values. The value type of the output is the same as the value type of the
 *  input.
 *
 *  Value: "REDUCE_MAX"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMax;
/**
 *  Reduce by computing the mean across time series for each alignment period.
 *  This reducer is valid for delta and gauge metrics with numeric or
 *  distribution values. The value type of the output is DOUBLE.
 *
 *  Value: "REDUCE_MEAN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMean;
/**
 *  Reduce by computing the minimum across time series for each alignment
 *  period. This reducer is valid for delta and gauge metrics with numeric
 *  values. The value type of the output is the same as the value type of the
 *  input.
 *
 *  Value: "REDUCE_MIN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMin;
/**
 *  No cross-time series reduction. The output of the aligner is returned.
 *
 *  Value: "REDUCE_NONE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceNone;
/**
 *  Reduce by computing 5th percentile of data points across time series for
 *  each alignment period. This reducer is valid for gauge and delta metrics of
 *  numeric and distribution type. The value of the output is DOUBLE
 *
 *  Value: "REDUCE_PERCENTILE_05"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile05;
/**
 *  Reduce by computing 50th percentile of data points across time series for
 *  each alignment period. This reducer is valid for gauge and delta metrics of
 *  numeric and distribution type. The value of the output is DOUBLE
 *
 *  Value: "REDUCE_PERCENTILE_50"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile50;
/**
 *  Reduce by computing 95th percentile of data points across time series for
 *  each alignment period. This reducer is valid for gauge and delta metrics of
 *  numeric and distribution type. The value of the output is DOUBLE
 *
 *  Value: "REDUCE_PERCENTILE_95"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile95;
/**
 *  Reduce by computing 99th percentile of data points across time series for
 *  each alignment period. This reducer is valid for gauge and delta metrics of
 *  numeric and distribution type. The value of the output is DOUBLE
 *
 *  Value: "REDUCE_PERCENTILE_99"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile99;
/**
 *  Reduce by computing the standard deviation across time series for each
 *  alignment period. This reducer is valid for delta and gauge metrics with
 *  numeric or distribution values. The value type of the output is DOUBLE.
 *
 *  Value: "REDUCE_STDDEV"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceStddev;
/**
 *  Reduce by computing the sum across time series for each alignment period.
 *  This reducer is valid for delta and gauge metrics with numeric and
 *  distribution values. The value type of the output is the same as the value
 *  type of the input.
 *
 *  Value: "REDUCE_SUM"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceSum;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Aggregation.perSeriesAligner

/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the count of all data points in the period. This alignment is
 *  valid for gauge and delta metrics with numeric or Boolean values. The value
 *  type of the output is INT64.
 *
 *  Value: "ALIGN_COUNT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCount;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the count of False-valued data points in the period. This
 *  alignment is valid for gauge metrics with Boolean values. The value type of
 *  the output is INT64.
 *
 *  Value: "ALIGN_COUNT_FALSE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountFalse;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the count of True-valued data points in the period. This alignment
 *  is valid for gauge metrics with Boolean values. The value type of the output
 *  is INT64.
 *
 *  Value: "ALIGN_COUNT_TRUE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountTrue;
/**
 *  Align and convert to delta metric type. This alignment is valid for
 *  cumulative metrics and delta metrics. Aligning an existing delta metric to a
 *  delta metric requires that the alignment period be increased. The value type
 *  of the result is the same as the value type of the input.One can think of
 *  this aligner as a rate but without time units; that is, the output is
 *  conceptually (second_point - first_point).
 *
 *  Value: "ALIGN_DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignDelta;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the fraction of True-valued data points in the period. This
 *  alignment is valid for gauge metrics with Boolean values. The output value
 *  is in the range 0, 1 and has value type DOUBLE.
 *
 *  Value: "ALIGN_FRACTION_TRUE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignFractionTrue;
/**
 *  Align by interpolating between adjacent points around the period boundary.
 *  This alignment is valid for gauge metrics with numeric values. The value
 *  type of the result is the same as the value type of the input.
 *
 *  Value: "ALIGN_INTERPOLATE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignInterpolate;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the maximum of all data points in the period. This alignment is
 *  valid for gauge and delta metrics with numeric values. The value type of the
 *  result is the same as the value type of the input.
 *
 *  Value: "ALIGN_MAX"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMax;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the average or arithmetic mean of all data points in the period.
 *  This alignment is valid for gauge and delta metrics with numeric values. The
 *  value type of the output is DOUBLE.
 *
 *  Value: "ALIGN_MEAN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMean;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the minimum of all data points in the period. This alignment is
 *  valid for gauge and delta metrics with numeric values. The value type of the
 *  result is the same as the value type of the input.
 *
 *  Value: "ALIGN_MIN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMin;
/**
 *  Align by shifting the oldest data point before the period boundary to the
 *  boundary. This alignment is valid for gauge metrics. The value type of the
 *  result is the same as the value type of the input.
 *
 *  Value: "ALIGN_NEXT_OLDER"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNextOlder;
/**
 *  No alignment. Raw data is returned. Not valid if cross-time series reduction
 *  is requested. The value type of the result is the same as the value type of
 *  the input.
 *
 *  Value: "ALIGN_NONE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNone;
/**
 *  Align and convert to a percentage change. This alignment is valid for gauge
 *  and delta metrics with numeric values. This alignment conceptually computes
 *  the equivalent of "((current - previous)/previous)*100" where previous value
 *  is determined based on the alignmentPeriod. In the event that previous is 0
 *  the calculated value is infinity with the exception that if both (current -
 *  previous) and previous are 0 the calculated value is 0. A 10 minute moving
 *  mean is computed at each point of the time window prior to the above
 *  calculation to smooth the metric and prevent false positives from very short
 *  lived spikes. Only applicable for data that is >= 0. Any values < 0 are
 *  treated as no data. While delta metrics are accepted by this alignment
 *  special care should be taken that the values for the metric will always be
 *  positive. The output is a gauge metric with value type DOUBLE.
 *
 *  Value: "ALIGN_PERCENT_CHANGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentChange;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the 5th percentile of all data points in the period. This
 *  alignment is valid for gauge and delta metrics with distribution values. The
 *  output is a gauge metric with value type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_05"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile05;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the 50th percentile of all data points in the period. This
 *  alignment is valid for gauge and delta metrics with distribution values. The
 *  output is a gauge metric with value type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_50"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile50;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the 95th percentile of all data points in the period. This
 *  alignment is valid for gauge and delta metrics with distribution values. The
 *  output is a gauge metric with value type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_95"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile95;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the 99th percentile of all data points in the period. This
 *  alignment is valid for gauge and delta metrics with distribution values. The
 *  output is a gauge metric with value type DOUBLE.
 *
 *  Value: "ALIGN_PERCENTILE_99"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile99;
/**
 *  Align and convert to a rate. This alignment is valid for cumulative metrics
 *  and delta metrics with numeric values. The output is a gauge metric with
 *  value type DOUBLE.One can think of this aligner as conceptually providing
 *  the slope of the line that passes through the value at the start and end of
 *  the window. In other words, this is conceptually ((y1 - y0)/(t1 - t0)), and
 *  the output unit is one that has a "/time" dimension.If, by rate, you are
 *  looking for percentage change, see the ALIGN_PERCENT_CHANGE aligner option.
 *
 *  Value: "ALIGN_RATE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignRate;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the standard deviation of all data points in the period. This
 *  alignment is valid for gauge and delta metrics with numeric values. The
 *  value type of the output is DOUBLE.
 *
 *  Value: "ALIGN_STDDEV"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignStddev;
/**
 *  Align time series via aggregation. The resulting data point in the alignment
 *  period is the sum of all data points in the period. This alignment is valid
 *  for gauge and delta metrics with numeric and distribution values. The value
 *  type of the output is the same as the value type of the input.
 *
 *  Value: "ALIGN_SUM"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignSum;

// ----------------------------------------------------------------------------
// GTLRMonitoring_AlertPolicy.combiner

/**
 *  Combine conditions using the logical AND operator. An incident is created
 *  only if all conditions are met simultaneously. This combiner is satisfied if
 *  all conditions are met, even if they are met on completely different
 *  resources.
 *
 *  Value: "AND"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_And;
/**
 *  Combine conditions using logical AND operator, but unlike the regular AND
 *  option, an incident is created only if all conditions are met simultaneously
 *  on at least one resource.
 *
 *  Value: "AND_WITH_MATCHING_RESOURCE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_AndWithMatchingResource;
/**
 *  An unspecified combiner.
 *
 *  Value: "COMBINE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_CombineUnspecified;
/**
 *  Combine conditions using the logical OR operator. An incident is created if
 *  any of the listed conditions is met.
 *
 *  Value: "OR"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_AlertPolicy_Combiner_Or;

// ----------------------------------------------------------------------------
// GTLRMonitoring_CollectdValue.dataSourceType

/**
 *  An amount of change since the last measurement interval. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.DELTA.
 *
 *  Value: "ABSOLUTE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Absolute;
/**
 *  A cumulative value over time. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.CUMULATIVE.
 *
 *  Value: "COUNTER"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Counter;
/**
 *  A rate of change of the measurement.
 *
 *  Value: "DERIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Derive;
/**
 *  An instantaneous measurement of a varying quantity. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.GAUGE.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_Gauge;
/**
 *  An unspecified data source type. This corresponds to
 *  google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *
 *  Value: "UNSPECIFIED_DATA_SOURCE_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.cardinality

/**
 *  For optional fields.
 *
 *  Value: "CARDINALITY_OPTIONAL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityOptional;
/**
 *  For repeated fields.
 *
 *  Value: "CARDINALITY_REPEATED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRepeated;
/**
 *  For required fields. Proto2 syntax only.
 *
 *  Value: "CARDINALITY_REQUIRED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityRequired;
/**
 *  For fields with unknown cardinality.
 *
 *  Value: "CARDINALITY_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Cardinality_CardinalityUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Field.kind

/**
 *  Field type bool.
 *
 *  Value: "TYPE_BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBool;
/**
 *  Field type bytes.
 *
 *  Value: "TYPE_BYTES"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeBytes;
/**
 *  Field type double.
 *
 *  Value: "TYPE_DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeDouble;
/**
 *  Field type enum.
 *
 *  Value: "TYPE_ENUM"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeEnum;
/**
 *  Field type fixed32.
 *
 *  Value: "TYPE_FIXED32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed32;
/**
 *  Field type fixed64.
 *
 *  Value: "TYPE_FIXED64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFixed64;
/**
 *  Field type float.
 *
 *  Value: "TYPE_FLOAT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeFloat;
/**
 *  Field type group. Proto2 syntax only, and deprecated.
 *
 *  Value: "TYPE_GROUP"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeGroup;
/**
 *  Field type int32.
 *
 *  Value: "TYPE_INT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt32;
/**
 *  Field type int64.
 *
 *  Value: "TYPE_INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeInt64;
/**
 *  Field type message.
 *
 *  Value: "TYPE_MESSAGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeMessage;
/**
 *  Field type sfixed32.
 *
 *  Value: "TYPE_SFIXED32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed32;
/**
 *  Field type sfixed64.
 *
 *  Value: "TYPE_SFIXED64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSfixed64;
/**
 *  Field type sint32.
 *
 *  Value: "TYPE_SINT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint32;
/**
 *  Field type sint64.
 *
 *  Value: "TYPE_SINT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeSint64;
/**
 *  Field type string.
 *
 *  Value: "TYPE_STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeString;
/**
 *  Field type uint32.
 *
 *  Value: "TYPE_UINT32"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint32;
/**
 *  Field type uint64.
 *
 *  Value: "TYPE_UINT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUint64;
/**
 *  Field type unknown.
 *
 *  Value: "TYPE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Field_Kind_TypeUnknown;

// ----------------------------------------------------------------------------
// GTLRMonitoring_InternalChecker.state

/**
 *  The checker is being created, provisioned, and configured. A checker in this
 *  state can be returned by ListInternalCheckers or GetInternalChecker, as well
 *  as by examining the longrunning.Operation that created it.
 *
 *  Value: "CREATING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_InternalChecker_State_Creating;
/**
 *  The checker is running and available for use. A checker in this state can be
 *  returned by ListInternalCheckers or GetInternalChecker as well as by
 *  examining the longrunning.Operation that created it. If a checker is being
 *  torn down, it is neither visible nor usable, so there is no "deleting" or
 *  "down" state.
 *
 *  Value: "RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_InternalChecker_State_Running;
/**
 *  An internal checker should never be in the unspecified state.
 *
 *  Value: "UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_InternalChecker_State_Unspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_LabelDescriptor.valueType

/**
 *  Boolean; true or false.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Bool;
/**
 *  A 64-bit signed integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_Int64;
/**
 *  A variable-length string. This is the default.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_LabelDescriptor_ValueType_String;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptor.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricDescriptorMetadata.launchStage

/**
 *  Alpha is a limited availability test for releases before they are cleared
 *  for widespread use. By Alpha, all significant design issues are resolved and
 *  we are in the process of verifying functionality. Alpha customers need to
 *  apply for access, agree to applicable terms, and have their projects
 *  whitelisted. Alpha releases don’t have to be feature complete, no SLAs are
 *  provided, and there are no technical support obligations, but they will be
 *  far enough along that customers can actually use them in test environments
 *  or for limited-use tests -- just like they would in normal production cases.
 *
 *  Value: "ALPHA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Alpha;
/**
 *  Beta is the point at which we are ready to open a release for any customer
 *  to use. There are no SLA or technical support obligations in a Beta release.
 *  Products will be complete from a feature perspective, but may have some open
 *  outstanding issues. Beta releases are suitable for limited production use
 *  cases.
 *
 *  Value: "BETA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Beta;
/**
 *  Deprecated features are scheduled to be shut down and removed. For more
 *  information, see the “Deprecation Policy” section of our Terms of Service
 *  (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to
 *  the Deprecation Policy (https://cloud.google.com/terms/deprecation)
 *  documentation.
 *
 *  Value: "DEPRECATED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Deprecated;
/**
 *  Early Access features are limited to a closed group of testers. To use these
 *  features, you must sign up in advance and sign a Trusted Tester agreement
 *  (which includes confidentiality provisions). These features may be unstable,
 *  changed in backward-incompatible ways, and are not guaranteed to be
 *  released.
 *
 *  Value: "EARLY_ACCESS"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_EarlyAccess;
/**
 *  GA features are open to all developers and are considered stable and fully
 *  qualified for production use.
 *
 *  Value: "GA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Ga;
/**
 *  Do not use this default value.
 *
 *  Value: "LAUNCH_STAGE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_LaunchStageUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_MetricThreshold.comparison

/**
 *  The left argument is equal to the right argument.
 *
 *  Value: "COMPARISON_EQ"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonEq;
/**
 *  The left argument is greater than or equal to the right argument.
 *
 *  Value: "COMPARISON_GE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGe;
/**
 *  The left argument is greater than the right argument.
 *
 *  Value: "COMPARISON_GT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGt;
/**
 *  The left argument is less than or equal to the right argument.
 *
 *  Value: "COMPARISON_LE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLe;
/**
 *  The left argument is less than the right argument.
 *
 *  Value: "COMPARISON_LT"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLt;
/**
 *  The left argument is not equal to the right argument.
 *
 *  Value: "COMPARISON_NE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonNe;
/**
 *  No ordering relationship is specified.
 *
 *  Value: "COMPARISON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_MetricThreshold_Comparison_ComparisonUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_NotificationChannel.verificationStatus

/**
 *  The channel has yet to be verified and requires verification to function.
 *  Note that this state also applies to the case where the verification process
 *  has been initiated by sending a verification code but where the verification
 *  code has not been submitted to complete the process.
 *
 *  Value: "UNVERIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_NotificationChannel_VerificationStatus_Unverified;
/**
 *  Sentinel value used to indicate that the state is unknown, omitted, or is
 *  not applicable (as in the case of channels that neither support nor require
 *  verification in order to function).
 *
 *  Value: "VERIFICATION_STATUS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_NotificationChannel_VerificationStatus_VerificationStatusUnspecified;
/**
 *  It has been proven that notifications can be received on this notification
 *  channel and that someone on the project has access to messages that are
 *  delivered to that channel.
 *
 *  Value: "VERIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_NotificationChannel_VerificationStatus_Verified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_NotificationChannelDescriptor.supportedTiers

/** Value: "SERVICE_TIER_BASIC" */
GTLR_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_SupportedTiers_ServiceTierBasic;
/** Value: "SERVICE_TIER_PREMIUM" */
GTLR_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_SupportedTiers_ServiceTierPremium;
/** Value: "SERVICE_TIER_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_NotificationChannelDescriptor_SupportedTiers_ServiceTierUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_ResourceGroup.resourceType

/**
 *  A group of Amazon ELB load balancers.
 *
 *  Value: "AWS_ELB_LOAD_BALANCER"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_AwsElbLoadBalancer;
/**
 *  A group of instances from Google Cloud Platform (GCP) or Amazon Web Services
 *  (AWS).
 *
 *  Value: "INSTANCE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_Instance;
/**
 *  Default value (not valid).
 *
 *  Value: "RESOURCE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_ResourceGroup_ResourceType_ResourceTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.metricKind

/**
 *  A value accumulated over a time interval. Cumulative measurements in a time
 *  series should have the same start time and increasing end times, until an
 *  event resets the cumulative value to zero and sets a new start time for the
 *  following points.
 *
 *  Value: "CUMULATIVE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Cumulative;
/**
 *  The change in a value during a time interval.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Delta;
/**
 *  An instantaneous measurement of a value.
 *
 *  Value: "GAUGE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_Gauge;
/**
 *  Do not use this default value.
 *
 *  Value: "METRIC_KIND_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_TimeSeries.valueType

/**
 *  The value is a boolean. This value type can be used only if the metric kind
 *  is GAUGE.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Bool;
/**
 *  The value is a Distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Distribution;
/**
 *  The value is a double precision floating point number.
 *
 *  Value: "DOUBLE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Double;
/**
 *  The value is a signed 64-bit integer.
 *
 *  Value: "INT64"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Int64;
/**
 *  The value is money.
 *
 *  Value: "MONEY"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_Money;
/**
 *  The value is a text string. This value type can be used only if the metric
 *  kind is GAUGE.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_String;
/**
 *  Do not use this default value.
 *
 *  Value: "VALUE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRMonitoring_Type.syntax

/**
 *  Syntax proto2.
 *
 *  Value: "SYNTAX_PROTO2"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto2;
/**
 *  Syntax proto3.
 *
 *  Value: "SYNTAX_PROTO3"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_Type_Syntax_SyntaxProto3;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckConfig.selectedRegions

/** Value: "ASIA_PACIFIC" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_AsiaPacific;
/** Value: "EUROPE" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_Europe;
/** Value: "REGION_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_RegionUnspecified;
/** Value: "SOUTH_AMERICA" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_SouthAmerica;
/** Value: "USA" */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckConfig_SelectedRegions_Usa;

// ----------------------------------------------------------------------------
// GTLRMonitoring_UptimeCheckIp.region

/**
 *  Allows checks to run from locations within the Asia Pacific area (ex:
 *  Singapore).
 *
 *  Value: "ASIA_PACIFIC"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_AsiaPacific;
/**
 *  Allows checks to run from locations within the continent of Europe.
 *
 *  Value: "EUROPE"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_Europe;
/**
 *  Default value if no region is specified. Will result in uptime checks
 *  running from all regions.
 *
 *  Value: "REGION_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_RegionUnspecified;
/**
 *  Allows checks to run from locations within the continent of South America.
 *
 *  Value: "SOUTH_AMERICA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_SouthAmerica;
/**
 *  Allows checks to run from locations within the United States of America.
 *
 *  Value: "USA"
 */
GTLR_EXTERN NSString * const kGTLRMonitoring_UptimeCheckIp_Region_Usa;

/**
 *  Describes how to combine multiple time series to provide different views of
 *  the data. Aggregation consists of an alignment step on individual time
 *  series (alignment_period and per_series_aligner) followed by an optional
 *  reduction step of the data across the aligned time series
 *  (cross_series_reducer and group_by_fields). For more details, see
 *  Aggregation.
 */
@interface GTLRMonitoring_Aggregation : GTLRObject

/**
 *  The alignment period for per-time series alignment. If present,
 *  alignmentPeriod must be at least 60 seconds. After per-time series
 *  alignment, each time series will contain data points only on the period
 *  boundaries. If perSeriesAligner is not specified or equals ALIGN_NONE, then
 *  this field is ignored. If perSeriesAligner is specified and does not equal
 *  ALIGN_NONE, then this field must be defined; otherwise an error is returned.
 */
@property(nonatomic, strong, nullable) GTLRDuration *alignmentPeriod;

/**
 *  The approach to be used to combine time series. Not all reducer functions
 *  may be applied to all time series, depending on the metric type and the
 *  value type of the original time series. Reduction may change the metric type
 *  of value type of the time series.Time series data must be aligned in order
 *  to perform cross-time series reduction. If crossSeriesReducer is specified,
 *  then perSeriesAligner must be specified and not equal ALIGN_NONE and
 *  alignmentPeriod must be specified; otherwise, an error is returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCount Reduce
 *        by computing the count of data points across time series for each
 *        alignment period. This reducer is valid for delta and gauge metrics of
 *        numeric, Boolean, distribution, and string value type. The value type
 *        of the output is INT64. (Value: "REDUCE_COUNT")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountFalse
 *        Reduce by computing the count of False-valued data points across time
 *        series for each alignment period. This reducer is valid for delta and
 *        gauge metrics of Boolean value type. The value type of the output is
 *        INT64. (Value: "REDUCE_COUNT_FALSE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceCountTrue
 *        Reduce by computing the count of True-valued data points across time
 *        series for each alignment period. This reducer is valid for delta and
 *        gauge metrics of Boolean value type. The value type of the output is
 *        INT64. (Value: "REDUCE_COUNT_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceFractionTrue
 *        Reduce by computing the fraction of True-valued data points across
 *        time series for each alignment period. This reducer is valid for delta
 *        and gauge metrics of Boolean value type. The output value is in the
 *        range 0, 1 and has value type DOUBLE. (Value: "REDUCE_FRACTION_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMax Reduce by
 *        computing the maximum across time series for each alignment period.
 *        This reducer is valid for delta and gauge metrics with numeric values.
 *        The value type of the output is the same as the value type of the
 *        input. (Value: "REDUCE_MAX")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMean Reduce
 *        by computing the mean across time series for each alignment period.
 *        This reducer is valid for delta and gauge metrics with numeric or
 *        distribution values. The value type of the output is DOUBLE. (Value:
 *        "REDUCE_MEAN")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceMin Reduce by
 *        computing the minimum across time series for each alignment period.
 *        This reducer is valid for delta and gauge metrics with numeric values.
 *        The value type of the output is the same as the value type of the
 *        input. (Value: "REDUCE_MIN")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceNone No
 *        cross-time series reduction. The output of the aligner is returned.
 *        (Value: "REDUCE_NONE")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile05
 *        Reduce by computing 5th percentile of data points across time series
 *        for each alignment period. This reducer is valid for gauge and delta
 *        metrics of numeric and distribution type. The value of the output is
 *        DOUBLE (Value: "REDUCE_PERCENTILE_05")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile50
 *        Reduce by computing 50th percentile of data points across time series
 *        for each alignment period. This reducer is valid for gauge and delta
 *        metrics of numeric and distribution type. The value of the output is
 *        DOUBLE (Value: "REDUCE_PERCENTILE_50")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile95
 *        Reduce by computing 95th percentile of data points across time series
 *        for each alignment period. This reducer is valid for gauge and delta
 *        metrics of numeric and distribution type. The value of the output is
 *        DOUBLE (Value: "REDUCE_PERCENTILE_95")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReducePercentile99
 *        Reduce by computing 99th percentile of data points across time series
 *        for each alignment period. This reducer is valid for gauge and delta
 *        metrics of numeric and distribution type. The value of the output is
 *        DOUBLE (Value: "REDUCE_PERCENTILE_99")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceStddev Reduce
 *        by computing the standard deviation across time series for each
 *        alignment period. This reducer is valid for delta and gauge metrics
 *        with numeric or distribution values. The value type of the output is
 *        DOUBLE. (Value: "REDUCE_STDDEV")
 *    @arg @c kGTLRMonitoring_Aggregation_CrossSeriesReducer_ReduceSum Reduce by
 *        computing the sum across time series for each alignment period. This
 *        reducer is valid for delta and gauge metrics with numeric and
 *        distribution values. The value type of the output is the same as the
 *        value type of the input. (Value: "REDUCE_SUM")
 */
@property(nonatomic, copy, nullable) NSString *crossSeriesReducer;

/**
 *  The set of fields to preserve when crossSeriesReducer is specified. The
 *  groupByFields determine how the time series are partitioned into subsets
 *  prior to applying the aggregation function. Each subset contains time series
 *  that have the same value for each of the grouping fields. Each individual
 *  time series is a member of exactly one subset. The crossSeriesReducer is
 *  applied to each subset of time series. It is not possible to reduce across
 *  different resource types, so this field implicitly contains resource.type.
 *  Fields not specified in groupByFields are aggregated away. If groupByFields
 *  is not specified and all the time series have the same resource type, then
 *  the time series are aggregated into a single output time series. If
 *  crossSeriesReducer is not defined, this field is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *groupByFields;

/**
 *  The approach to be used to align individual time series. Not all alignment
 *  functions may be applied to all time series, depending on the metric type
 *  and value type of the original time series. Alignment may change the metric
 *  type or the value type of the time series.Time series data must be aligned
 *  in order to perform cross-time series reduction. If crossSeriesReducer is
 *  specified, then perSeriesAligner must be specified and not equal ALIGN_NONE
 *  and alignmentPeriod must be specified; otherwise, an error is returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCount Align time
 *        series via aggregation. The resulting data point in the alignment
 *        period is the count of all data points in the period. This alignment
 *        is valid for gauge and delta metrics with numeric or Boolean values.
 *        The value type of the output is INT64. (Value: "ALIGN_COUNT")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountFalse Align
 *        time series via aggregation. The resulting data point in the alignment
 *        period is the count of False-valued data points in the period. This
 *        alignment is valid for gauge metrics with Boolean values. The value
 *        type of the output is INT64. (Value: "ALIGN_COUNT_FALSE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignCountTrue Align
 *        time series via aggregation. The resulting data point in the alignment
 *        period is the count of True-valued data points in the period. This
 *        alignment is valid for gauge metrics with Boolean values. The value
 *        type of the output is INT64. (Value: "ALIGN_COUNT_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignDelta Align and
 *        convert to delta metric type. This alignment is valid for cumulative
 *        metrics and delta metrics. Aligning an existing delta metric to a
 *        delta metric requires that the alignment period be increased. The
 *        value type of the result is the same as the value type of the
 *        input.One can think of this aligner as a rate but without time units;
 *        that is, the output is conceptually (second_point - first_point).
 *        (Value: "ALIGN_DELTA")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignFractionTrue
 *        Align time series via aggregation. The resulting data point in the
 *        alignment period is the fraction of True-valued data points in the
 *        period. This alignment is valid for gauge metrics with Boolean values.
 *        The output value is in the range 0, 1 and has value type DOUBLE.
 *        (Value: "ALIGN_FRACTION_TRUE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignInterpolate
 *        Align by interpolating between adjacent points around the period
 *        boundary. This alignment is valid for gauge metrics with numeric
 *        values. The value type of the result is the same as the value type of
 *        the input. (Value: "ALIGN_INTERPOLATE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMax Align time
 *        series via aggregation. The resulting data point in the alignment
 *        period is the maximum of all data points in the period. This alignment
 *        is valid for gauge and delta metrics with numeric values. The value
 *        type of the result is the same as the value type of the input. (Value:
 *        "ALIGN_MAX")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMean Align time
 *        series via aggregation. The resulting data point in the alignment
 *        period is the average or arithmetic mean of all data points in the
 *        period. This alignment is valid for gauge and delta metrics with
 *        numeric values. The value type of the output is DOUBLE. (Value:
 *        "ALIGN_MEAN")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignMin Align time
 *        series via aggregation. The resulting data point in the alignment
 *        period is the minimum of all data points in the period. This alignment
 *        is valid for gauge and delta metrics with numeric values. The value
 *        type of the result is the same as the value type of the input. (Value:
 *        "ALIGN_MIN")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNextOlder Align
 *        by shifting the oldest data point before the period boundary to the
 *        boundary. This alignment is valid for gauge metrics. The value type of
 *        the result is the same as the value type of the input. (Value:
 *        "ALIGN_NEXT_OLDER")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignNone No
 *        alignment. Raw data is returned. Not valid if cross-time series
 *        reduction is requested. The value type of the result is the same as
 *        the value type of the input. (Value: "ALIGN_NONE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentChange
 *        Align and convert to a percentage change. This alignment is valid for
 *        gauge and delta metrics with numeric values. This alignment
 *        conceptually computes the equivalent of "((current -
 *        previous)/previous)*100" where previous value is determined based on
 *        the alignmentPeriod. In the event that previous is 0 the calculated
 *        value is infinity with the exception that if both (current - previous)
 *        and previous are 0 the calculated value is 0. A 10 minute moving mean
 *        is computed at each point of the time window prior to the above
 *        calculation to smooth the metric and prevent false positives from very
 *        short lived spikes. Only applicable for data that is >= 0. Any values
 *        < 0 are treated as no data. While delta metrics are accepted by this
 *        alignment special care should be taken that the values for the metric
 *        will always be positive. The output is a gauge metric with value type
 *        DOUBLE. (Value: "ALIGN_PERCENT_CHANGE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile05
 *        Align time series via aggregation. The resulting data point in the
 *        alignment period is the 5th percentile of all data points in the
 *        period. This alignment is valid for gauge and delta metrics with
 *        distribution values. The output is a gauge metric with value type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_05")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile50
 *        Align time series via aggregation. The resulting data point in the
 *        alignment period is the 50th percentile of all data points in the
 *        period. This alignment is valid for gauge and delta metrics with
 *        distribution values. The output is a gauge metric with value type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_50")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile95
 *        Align time series via aggregation. The resulting data point in the
 *        alignment period is the 95th percentile of all data points in the
 *        period. This alignment is valid for gauge and delta metrics with
 *        distribution values. The output is a gauge metric with value type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_95")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignPercentile99
 *        Align time series via aggregation. The resulting data point in the
 *        alignment period is the 99th percentile of all data points in the
 *        period. This alignment is valid for gauge and delta metrics with
 *        distribution values. The output is a gauge metric with value type
 *        DOUBLE. (Value: "ALIGN_PERCENTILE_99")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignRate Align and
 *        convert to a rate. This alignment is valid for cumulative metrics and
 *        delta metrics with numeric values. The output is a gauge metric with
 *        value type DOUBLE.One can think of this aligner as conceptually
 *        providing the slope of the line that passes through the value at the
 *        start and end of the window. In other words, this is conceptually ((y1
 *        - y0)/(t1 - t0)), and the output unit is one that has a "/time"
 *        dimension.If, by rate, you are looking for percentage change, see the
 *        ALIGN_PERCENT_CHANGE aligner option. (Value: "ALIGN_RATE")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignStddev Align
 *        time series via aggregation. The resulting data point in the alignment
 *        period is the standard deviation of all data points in the period.
 *        This alignment is valid for gauge and delta metrics with numeric
 *        values. The value type of the output is DOUBLE. (Value:
 *        "ALIGN_STDDEV")
 *    @arg @c kGTLRMonitoring_Aggregation_PerSeriesAligner_AlignSum Align time
 *        series via aggregation. The resulting data point in the alignment
 *        period is the sum of all data points in the period. This alignment is
 *        valid for gauge and delta metrics with numeric and distribution
 *        values. The value type of the output is the same as the value type of
 *        the input. (Value: "ALIGN_SUM")
 */
@property(nonatomic, copy, nullable) NSString *perSeriesAligner;

@end


/**
 *  A description of the conditions under which some aspect of your system is
 *  considered to be "unhealthy" and the ways to notify people or services about
 *  this state. For an overview of alert policies, see Introduction to Alerting.
 */
@interface GTLRMonitoring_AlertPolicy : GTLRObject

/**
 *  How to combine the results of multiple conditions to determine if an
 *  incident should be opened.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_And Combine conditions using
 *        the logical AND operator. An incident is created only if all
 *        conditions are met simultaneously. This combiner is satisfied if all
 *        conditions are met, even if they are met on completely different
 *        resources. (Value: "AND")
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_AndWithMatchingResource
 *        Combine conditions using logical AND operator, but unlike the regular
 *        AND option, an incident is created only if all conditions are met
 *        simultaneously on at least one resource. (Value:
 *        "AND_WITH_MATCHING_RESOURCE")
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_CombineUnspecified An
 *        unspecified combiner. (Value: "COMBINE_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_AlertPolicy_Combiner_Or Combine conditions using
 *        the logical OR operator. An incident is created if any of the listed
 *        conditions is met. (Value: "OR")
 */
@property(nonatomic, copy, nullable) NSString *combiner;

/**
 *  A list of conditions for the policy. The conditions are combined by AND or
 *  OR according to the combiner field. If the combined conditions evaluate to
 *  true, then an incident is created. A policy can have from one to six
 *  conditions.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Condition *> *conditions;

/**
 *  A read-only record of the creation of the alerting policy. If provided in a
 *  call to create or update, this field will be ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MutationRecord *creationRecord;

/**
 *  A short name or phrase used to identify the policy in dashboards,
 *  notifications, and incidents. To avoid confusion, don't use the same display
 *  name for multiple policies in the same project. The name is limited to 512
 *  Unicode characters.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Documentation that is included with notifications and incidents related to
 *  this policy. Best practice is for the documentation to include information
 *  to help responders understand, mitigate, escalate, and correct the
 *  underlying problems detected by the alerting policy. Notification channels
 *  that have limited capacity might not show this documentation.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Documentation *documentation;

/**
 *  Whether or not the policy is enabled. On write, the default interpretation
 *  if unset is that the policy is enabled. On read, clients should not make any
 *  assumption about the state if it has not been populated. The field should
 *  always be populated on List and Get operations, unless a field projection
 *  has been specified that strips it out.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  A read-only record of the most recent change to the alerting policy. If
 *  provided in a call to create or update, this field will be ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MutationRecord *mutationRecord;

/**
 *  Required if the policy exists. The resource name for this policy. The syntax
 *  is:
 *  projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 *  [ALERT_POLICY_ID] is assigned by Stackdriver Monitoring when the policy is
 *  created. When calling the alertPolicies.create method, do not include the
 *  name field in the alerting policy passed as part of the request.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Identifies the notification channels to which notifications should be sent
 *  when incidents are opened or closed or when new violations occur on an
 *  already opened incident. Each element of this array corresponds to the name
 *  field in each of the NotificationChannel objects that are returned from the
 *  ListNotificationChannels method. The syntax of the entries in this field is:
 *  projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *notificationChannels;

/**
 *  User-supplied key/value data to be used for organizing and identifying the
 *  AlertPolicy objects.The field can contain up to 64 entries. Each key and
 *  value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_AlertPolicy_UserLabels *userLabels;

@end


/**
 *  User-supplied key/value data to be used for organizing and identifying the
 *  AlertPolicy objects.The field can contain up to 64 entries. Each key and
 *  value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_AlertPolicy_UserLabels : GTLRObject
@end


/**
 *  A type of authentication to perform against the specified resource or URL
 *  that uses username and password. Currently, only Basic authentication is
 *  supported in Uptime Monitoring.
 */
@interface GTLRMonitoring_BasicAuthentication : GTLRObject

/** The password to authenticate. */
@property(nonatomic, copy, nullable) NSString *password;

/** The username to authenticate. */
@property(nonatomic, copy, nullable) NSString *username;

@end


/**
 *  BucketOptions describes the bucket boundaries used to create a histogram for
 *  the distribution. The buckets can be in a linear sequence, an exponential
 *  sequence, or each bucket can be specified explicitly. BucketOptions does not
 *  include the number of values in each bucket.A bucket has an inclusive lower
 *  bound and exclusive upper bound for the values that are counted for that
 *  bucket. The upper bound of a bucket must be strictly greater than the lower
 *  bound. The sequence of N buckets for a distribution consists of an underflow
 *  bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
 *  an overflow bucket (number N - 1). The buckets are contiguous: the lower
 *  bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
 *  The buckets span the whole range of finite values: lower bound of the
 *  underflow bucket is -infinity and the upper bound of the overflow bucket is
 *  +infinity. The finite buckets are so-called because both bounds are finite.
 */
@interface GTLRMonitoring_BucketOptions : GTLRObject

/** The explicit buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Explicit *explicitBuckets;

/** The exponential buckets. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Exponential *exponentialBuckets;

/** The linear bucket. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Linear *linearBuckets;

@end


/**
 *  A collection of data points sent from a collectd-based plugin. See the
 *  collectd documentation for more information.
 */
@interface GTLRMonitoring_CollectdPayload : GTLRObject

/** The end time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** The measurement metadata. Example: "process_id" -> 12345 */
@property(nonatomic, strong, nullable) GTLRMonitoring_CollectdPayload_Metadata *metadata;

/** The name of the plugin. Example: "disk". */
@property(nonatomic, copy, nullable) NSString *plugin;

/** The instance name of the plugin Example: "hdcl". */
@property(nonatomic, copy, nullable) NSString *pluginInstance;

/** The start time of the interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** The measurement type. Example: "memory". */
@property(nonatomic, copy, nullable) NSString *type;

/** The measurement type instance. Example: "used". */
@property(nonatomic, copy, nullable) NSString *typeInstance;

/**
 *  The measured values during this time interval. Each value must have a
 *  different dataSourceName.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValue *> *values;

@end


/**
 *  The measurement metadata. Example: "process_id" -> 12345
 *
 *  @note This class is documented as having more properties of
 *        GTLRMonitoring_TypedValue. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_CollectdPayload_Metadata : GTLRObject
@end


/**
 *  Describes the error status for payloads that were not written.
 */
@interface GTLRMonitoring_CollectdPayloadError : GTLRObject

/**
 *  Records the error status for the payload. If this field is present, the
 *  partial errors for nested values won't be populated.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *error;

/**
 *  The zero-based index in CreateCollectdTimeSeriesRequest.collectd_payloads.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Records the error status for values that were not written due to an
 *  error.Failed payloads for which nothing is written will not include partial
 *  value errors.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdValueError *> *valueErrors;

@end


/**
 *  A single data point from a collectd-based plugin.
 */
@interface GTLRMonitoring_CollectdValue : GTLRObject

/**
 *  The data source for the collectd value. For example there are two data
 *  sources for network measurements: "rx" and "tx".
 */
@property(nonatomic, copy, nullable) NSString *dataSourceName;

/**
 *  The type of measurement.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Absolute An amount of
 *        change since the last measurement interval. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.DELTA. (Value: "ABSOLUTE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Counter A cumulative
 *        value over time. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.CUMULATIVE. (Value: "COUNTER")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Derive A rate of
 *        change of the measurement. (Value: "DERIVE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_Gauge An
 *        instantaneous measurement of a varying quantity. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.GAUGE. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_CollectdValue_DataSourceType_UnspecifiedDataSourceType
 *        An unspecified data source type. This corresponds to
 *        google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED.
 *        (Value: "UNSPECIFIED_DATA_SOURCE_TYPE")
 */
@property(nonatomic, copy, nullable) NSString *dataSourceType;

/** The measurement value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  Describes the error status for values that were not written.
 */
@interface GTLRMonitoring_CollectdValueError : GTLRObject

/** Records the error status for the value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Status *error;

/**
 *  The zero-based index in CollectdPayload.values within the parent
 *  CreateCollectdTimeSeriesRequest.collectd_payloads.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

@end


/**
 *  A condition is a true/false test that determines when an alerting policy
 *  should open an incident. If a condition evaluates to true, it signifies that
 *  something is wrong.
 */
@interface GTLRMonitoring_Condition : GTLRObject

/**
 *  A condition that checks that a time series continues to receive new data
 *  points.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricAbsence *conditionAbsent;

/** A condition that compares a time series against a threshold. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricThreshold *conditionThreshold;

/**
 *  A short name or phrase used to identify the condition in dashboards,
 *  notifications, and incidents. To avoid confusion, don't use the same display
 *  name for multiple conditions in the same policy.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required if the condition exists. The unique resource name for this
 *  condition. Its syntax is:
 *  projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
 *  [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is
 *  created as part of a new or updated alerting policy.When calling the
 *  alertPolicies.create method, do not include the name field in the conditions
 *  of the requested alerting policy. Stackdriver Monitoring creates the
 *  condition identifiers and includes them in the new policy.When calling the
 *  alertPolicies.update method to update a policy, including a condition name
 *  causes the existing condition to be updated. Conditions without names are
 *  added to the updated policy. Existing conditions are deleted if they are not
 *  updated.Best practice is to preserve [CONDITION_ID] if you make only small
 *  changes, such as those to condition thresholds, durations, or trigger
 *  values. Otherwise, treat the change as a new condition and let the existing
 *  condition be deleted.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Used to perform string matching. It allows substring and regular
 *  expressions, together with their negations.
 */
@interface GTLRMonitoring_ContentMatcher : GTLRObject

/** String or regex content to match (max 1024 bytes) */
@property(nonatomic, copy, nullable) NSString *content;

@end


/**
 *  The CreateCollectdTimeSeries request.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesRequest : GTLRObject

/**
 *  The collectd payloads representing the time series data. You must not
 *  include more than a single point for each time series, so no two payloads
 *  can have the same values for all of the fields plugin, plugin_instance,
 *  type, and type_instance.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayload *> *collectdPayloads;

/**
 *  The version of collectd that collected the data. Example: "5.3.0-192.el6".
 */
@property(nonatomic, copy, nullable) NSString *collectdVersion;

/** The monitored resource associated with the time series. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

@end


/**
 *  The CreateCollectdTimeSeries response.
 */
@interface GTLRMonitoring_CreateCollectdTimeSeriesResponse : GTLRObject

/**
 *  Records the error status for points that were not written due to an
 *  error.Failed requests for which nothing is written will return an error
 *  response instead.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_CollectdPayloadError *> *payloadErrors;

@end


/**
 *  The CreateTimeSeries request.
 */
@interface GTLRMonitoring_CreateTimeSeriesRequest : GTLRObject

/**
 *  The new data to be added to a list of time series. Adds at most one data
 *  point to each of several time series. The new data point must be more recent
 *  than any other point in its time series. Each TimeSeries value must fully
 *  specify a unique time series by supplying all label values for the metric
 *  and the monitored resource.The maximum number of TimeSeries objects per
 *  Create request is 200.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  Distribution contains summary statistics for a population of values. It
 *  optionally contains a histogram representing the distribution of those
 *  values across a set of buckets.The summary statistics are the count, mean,
 *  sum of the squared deviation from the mean, the minimum, and the maximum of
 *  the set of population of values. The histogram is based on a sequence of
 *  buckets and gives a count of values that fall into each bucket. The
 *  boundaries of the buckets are given either explicitly or by formulas for
 *  buckets of fixed or exponentially increasing widths.Although it is not
 *  forbidden, it is generally a bad idea to include non-finite values
 *  (infinities or NaNs) in the population of values, as this will render the
 *  mean and sum_of_squared_deviation fields meaningless.
 */
@interface GTLRMonitoring_Distribution : GTLRObject

/**
 *  Required in the Stackdriver Monitoring API v3. The values for each bucket
 *  specified in bucket_options. The sum of the values in bucketCounts must
 *  equal the value in the count field of the Distribution object. The order of
 *  the bucket counts follows the numbering schemes described for the three
 *  bucket types. The underflow bucket has number 0; the finite buckets, if any,
 *  have numbers 1 through N-2; and the overflow bucket has number N-1. The size
 *  of bucket_counts must not be greater than N. If the size is less than N,
 *  then the remaining buckets are assigned values of zero.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  Required in the Stackdriver Monitoring API v3. Defines the histogram bucket
 *  boundaries.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BucketOptions *bucketOptions;

/**
 *  The number of values in the population. Must be non-negative. This value
 *  must equal the sum of the values in bucket_counts if a histogram is
 *  provided.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/** Must be in increasing order of value field. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Exemplar *> *exemplars;

/**
 *  The arithmetic mean of the values in the population. If count is zero then
 *  this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  If specified, contains the range of the population values. The field must
 *  not be present if the count is zero. This field is presently ignored by the
 *  Stackdriver Monitoring API v3.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Range *range;

/**
 *  The sum of squared deviations from the mean of the values in the population.
 *  For values x_i this is:
 *  Sum[i=1..n]((x_i - mean)^2)
 *  Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
 *  describes Welford's method for accumulating this sum in one pass.If count is
 *  zero then this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  A content string and a MIME type that describes the content string's format.
 */
@interface GTLRMonitoring_Documentation : GTLRObject

/**
 *  The text of the documentation, interpreted according to mime_type. The
 *  content may not exceed 8,192 Unicode characters and may not exceed more than
 *  10,240 bytes when encoded in UTF-8 format, whichever is smaller.
 */
@property(nonatomic, copy, nullable) NSString *content;

/**
 *  The format of the content field. Presently, only the value "text/markdown"
 *  is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more
 *  information.
 */
@property(nonatomic, copy, nullable) NSString *mimeType;

@end


/**
 *  A set of (label, value) pairs which were dropped during aggregation,
 *  attached to google.api.Distribution.Exemplars in google.api.Distribution
 *  values during aggregation.These values are used in combination with the
 *  label values that remain on the aggregated Distribution timeseries to
 *  construct the full label set for the exemplar values. The resulting full
 *  label set may be used to identify the specific task/job/instance (for
 *  example) which may be contributing to a long-tail, while allowing the
 *  storage savings of only storing aggregated distribution values for a large
 *  group.Note that there are no guarantees on ordering of the labels from
 *  exemplar-to-exemplar and from distribution-to-distribution in the same
 *  stream, and there may be duplicates. It is up to clients to resolve any
 *  ambiguities.
 */
@interface GTLRMonitoring_DroppedLabels : GTLRObject

/** Map from label to its value, for all labels dropped in any aggregation. */
@property(nonatomic, strong, nullable) GTLRMonitoring_DroppedLabels_Label *label;

@end


/**
 *  Map from label to its value, for all labels dropped in any aggregation.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_DroppedLabels_Label : GTLRObject
@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for Empty is empty JSON object {}.
 */
@interface GTLRMonitoring_Empty : GTLRObject
@end


/**
 *  Exemplars are example points that may be used to annotate aggregated
 *  distribution values. They are metadata that gives information about a
 *  particular value added to a Distribution bucket, such as a trace ID that was
 *  active when a value was added. They may contain further information, such as
 *  a example values and timestamps, origin, etc.
 */
@interface GTLRMonitoring_Exemplar : GTLRObject

/**
 *  Contextual information about the example value. Examples are:Trace ID:
 *  type.googleapis.com/google.devtools.cloudtrace.v1.TraceLiteral string:
 *  type.googleapis.com/google.protobuf.StringValueLabels dropped during
 *  aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may
 *  be only a single attachment of any given message type in a single exemplar,
 *  and this is enforced by the system.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Exemplar_Attachments_Item *> *attachments;

/** The observation (sampling) time of the above value. */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

/**
 *  Value of the exemplar point. This value determines to which bucket the
 *  exemplar belongs.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  GTLRMonitoring_Exemplar_Attachments_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Exemplar_Attachments_Item : GTLRObject
@end


/**
 *  Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1
 *  (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i <
 *  N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must
 *  contain at least one element. If bounds has only one element, then there are
 *  no finite buckets, and that single element is the common boundary of the
 *  overflow and underflow buckets.
 */
@interface GTLRMonitoring_Explicit : GTLRObject

/**
 *  The values must be monotonically increasing.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Specifies an exponential sequence of buckets that have a width that is
 *  proportional to the value of the lower bound. Each bucket represents a
 *  constant relative uncertainty on a specific value in the bucket.There are
 *  num_finite_buckets + 2 (= N) buckets. Bucket i has the following
 *  boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower
 *  bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
 */
@interface GTLRMonitoring_Exponential : GTLRObject

/**
 *  Must be greater than 1.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  A single field of a message type.
 */
@interface GTLRMonitoring_Field : GTLRObject

/**
 *  The field cardinality.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityOptional For optional
 *        fields. (Value: "CARDINALITY_OPTIONAL")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRepeated For repeated
 *        fields. (Value: "CARDINALITY_REPEATED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityRequired For required
 *        fields. Proto2 syntax only. (Value: "CARDINALITY_REQUIRED")
 *    @arg @c kGTLRMonitoring_Field_Cardinality_CardinalityUnknown For fields
 *        with unknown cardinality. (Value: "CARDINALITY_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *cardinality;

/**
 *  The string value of the default value of this field. Proto2 syntax only.
 */
@property(nonatomic, copy, nullable) NSString *defaultValue;

/** The field JSON name. */
@property(nonatomic, copy, nullable) NSString *jsonName;

/**
 *  The field type.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBool Field type bool. (Value:
 *        "TYPE_BOOL")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeBytes Field type bytes. (Value:
 *        "TYPE_BYTES")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeDouble Field type double. (Value:
 *        "TYPE_DOUBLE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeEnum Field type enum. (Value:
 *        "TYPE_ENUM")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed32 Field type fixed32. (Value:
 *        "TYPE_FIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFixed64 Field type fixed64. (Value:
 *        "TYPE_FIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeFloat Field type float. (Value:
 *        "TYPE_FLOAT")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeGroup Field type group. Proto2
 *        syntax only, and deprecated. (Value: "TYPE_GROUP")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt32 Field type int32. (Value:
 *        "TYPE_INT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeInt64 Field type int64. (Value:
 *        "TYPE_INT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeMessage Field type message. (Value:
 *        "TYPE_MESSAGE")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed32 Field type sfixed32.
 *        (Value: "TYPE_SFIXED32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSfixed64 Field type sfixed64.
 *        (Value: "TYPE_SFIXED64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint32 Field type sint32. (Value:
 *        "TYPE_SINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeSint64 Field type sint64. (Value:
 *        "TYPE_SINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeString Field type string. (Value:
 *        "TYPE_STRING")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint32 Field type uint32. (Value:
 *        "TYPE_UINT32")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUint64 Field type uint64. (Value:
 *        "TYPE_UINT64")
 *    @arg @c kGTLRMonitoring_Field_Kind_TypeUnknown Field type unknown. (Value:
 *        "TYPE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** The field name. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The field number.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *number;

/**
 *  The index of the field type in Type.oneofs, for message or enumeration
 *  types. The first type has index 1; zero means the type is not in the list.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneofIndex;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/**
 *  Whether to use alternative packed wire representation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *packed;

/**
 *  The field type URL, without the scheme, for message or enumeration types.
 *  Example: "type.googleapis.com/google.protobuf.Timestamp".
 */
@property(nonatomic, copy, nullable) NSString *typeUrl;

@end


/**
 *  The GetNotificationChannelVerificationCode request.
 */
@interface GTLRMonitoring_GetNotificationChannelVerificationCodeRequest : GTLRObject

/**
 *  The desired expiration time. If specified, the API will guarantee that the
 *  returned code will not be valid after the specified timestamp; however, the
 *  API cannot guarantee that the returned code will be valid for at least as
 *  long as the requested time (the API puts an upper bound on the amount of
 *  time for which a code may be valid). If omitted, a default expiration will
 *  be used, which may be less than the max permissible expiration (so
 *  specifying an expiration may extend the code's lifetime over omitting an
 *  expiration, even though the API does impose an upper limit on the maximum
 *  expiration that is permitted).
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

@end


/**
 *  The GetNotificationChannelVerificationCode request.
 */
@interface GTLRMonitoring_GetNotificationChannelVerificationCodeResponse : GTLRObject

/**
 *  The verification code, which may be used to verify other channels that have
 *  an equivalent identity (i.e. other channels of the same type with the same
 *  fingerprint such as other email channels with the same email address or
 *  other sms channels with the same number).
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  The expiration time associated with the code that was returned. If an
 *  expiration was provided in the request, this is the minimum of the requested
 *  expiration in the request and the max permitted expiration.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expireTime;

@end


/**
 *  The description of a dynamic collection of monitored resources. Each group
 *  has a filter that is matched against monitored resources and their
 *  associated metadata. If a group's filter matches an available monitored
 *  resource, then that resource is a member of that group. Groups can contain
 *  any number of monitored resources, and each monitored resource can be a
 *  member of any number of groups.Groups can be nested in parent-child
 *  hierarchies. The parentName field identifies an optional parent for each
 *  group. If a group has a parent, then the only monitored resources available
 *  to be matched by the group's filter are the resources contained in the
 *  parent group. In other words, a group contains the monitored resources that
 *  match its filter and the filters of all the group's ancestors. A group
 *  without a parent can contain any monitored resource.For example, consider an
 *  infrastructure running a set of instances with two user-defined tags:
 *  "environment" and "role". A parent group has a filter,
 *  environment="production". A child of that parent group has a filter,
 *  role="transcoder". The parent group contains all instances in the production
 *  environment, regardless of their roles. The child group contains instances
 *  that have the transcoder role and are in the production environment.The
 *  monitored resources contained in a group can change at any moment, depending
 *  on what resources exist and what filters are associated with the group and
 *  its ancestors.
 */
@interface GTLRMonitoring_Group : GTLRObject

/** A user-assigned name for this group, used only for display purposes. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The filter used to determine which monitored resources belong to this group.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  If true, the members of this group are considered to be a cluster. The
 *  system can perform additional analysis on groups that are clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isCluster;

/**
 *  Output only. The name of this group. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". When creating a group,
 *  this field is ignored and a new name is created consisting of the project
 *  specified in the call to CreateGroup and a unique {group_id} that is
 *  generated automatically.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the group's parent, if it has one. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". For groups with no
 *  parent, parentName is the empty string, "".
 */
@property(nonatomic, copy, nullable) NSString *parentName;

@end


/**
 *  Information involved in an HTTP/HTTPS uptime check request.
 */
@interface GTLRMonitoring_HttpCheck : GTLRObject

/**
 *  The authentication information. Optional when creating an HTTP check;
 *  defaults to empty.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_BasicAuthentication *authInfo;

/**
 *  The list of headers to send as part of the uptime check request. If two
 *  headers have the same key and different values, they should be entered as a
 *  single header, with the value being a comma-separated list of all the
 *  desired values as described at
 *  https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two
 *  separate headers with the same key in a Create call will cause the first to
 *  be overwritten by the second. The maximum number of headers allowed is 100.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_HttpCheck_Headers *headers;

/**
 *  Boolean specifiying whether to encrypt the header information. Encryption
 *  should be specified for any headers related to authentication that you do
 *  not wish to be seen when retrieving the configuration. The server will be
 *  responsible for encrypting the headers. On Get/List calls, if mask_headers
 *  is set to True then the headers will be obscured with ******.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maskHeaders;

/**
 *  The path to the page to run the check against. Will be combined with the
 *  host (specified within the MonitoredResource) and port to construct the full
 *  URL. Optional (defaults to "/").
 */
@property(nonatomic, copy, nullable) NSString *path;

/**
 *  The port to the page to run the check against. Will be combined with host
 *  (specified within the MonitoredResource) and path to construct the full URL.
 *  Optional (defaults to 80 without SSL, or 443 with SSL).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

/**
 *  If true, use HTTPS instead of HTTP to run the check.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useSsl;

@end


/**
 *  The list of headers to send as part of the uptime check request. If two
 *  headers have the same key and different values, they should be entered as a
 *  single header, with the value being a comma-separated list of all the
 *  desired values as described at
 *  https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two
 *  separate headers with the same key in a Create call will cause the first to
 *  be overwritten by the second. The maximum number of headers allowed is 100.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_HttpCheck_Headers : GTLRObject
@end


/**
 *  An internal checker allows uptime checks to run on private/internal GCP
 *  resources.
 */
@interface GTLRMonitoring_InternalChecker : GTLRObject

/**
 *  The checker's human-readable name. The display name should be unique within
 *  a Stackdriver Workspace in order to make it easier to identify; however,
 *  uniqueness is not enforced.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The GCP zone the uptime check should egress from. Only respected for
 *  internal uptime checks, where internal_network is specified.
 */
@property(nonatomic, copy, nullable) NSString *gcpZone;

/**
 *  A unique resource name for this InternalChecker. The format
 *  is:projects/[PROJECT_ID]/internalCheckers/[INTERNAL_CHECKER_ID].PROJECT_ID
 *  is the stackdriver workspace project for the uptime check config associated
 *  with the internal checker.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the
 *  internal resource lives (ex: "default").
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  The GCP project_id where the internal checker lives. Not necessary the same
 *  as the workspace project.
 */
@property(nonatomic, copy, nullable) NSString *peerProjectId;

/**
 *  The current operational state of the internal checker.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_InternalChecker_State_Creating The checker is
 *        being created, provisioned, and configured. A checker in this state
 *        can be returned by ListInternalCheckers or GetInternalChecker, as well
 *        as by examining the longrunning.Operation that created it. (Value:
 *        "CREATING")
 *    @arg @c kGTLRMonitoring_InternalChecker_State_Running The checker is
 *        running and available for use. A checker in this state can be returned
 *        by ListInternalCheckers or GetInternalChecker as well as by examining
 *        the longrunning.Operation that created it. If a checker is being torn
 *        down, it is neither visible nor usable, so there is no "deleting" or
 *        "down" state. (Value: "RUNNING")
 *    @arg @c kGTLRMonitoring_InternalChecker_State_Unspecified An internal
 *        checker should never be in the unspecified state. (Value:
 *        "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  A description of a label.
 */
@interface GTLRMonitoring_LabelDescriptor : GTLRObject

/**
 *  A human-readable description for the label.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The label key. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  The type of data that can be assigned to the label.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Bool Boolean; true or
 *        false. (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_Int64 A 64-bit signed
 *        integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_LabelDescriptor_ValueType_String A variable-length
 *        string. This is the default. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Specifies a linear sequence of buckets that all have the same width (except
 *  overflow and underflow). Each bucket represents a constant absolute
 *  uncertainty on the specific value in the bucket.There are num_finite_buckets
 *  + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i
 *  < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i
 *  - 1)).
 */
@interface GTLRMonitoring_Linear : GTLRObject

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  Lower bound of the first bucket.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  Must be greater than 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  The protocol for the ListAlertPolicies response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "alertPolicies" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListAlertPoliciesResponse : GTLRCollectionObject

/**
 *  The returned alert policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_AlertPolicy *> *alertPolicies;

/**
 *  If there might be more results than were returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListGroupMembers response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "members" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupMembersResponse : GTLRCollectionObject

/**
 *  A set of monitored resources in the group.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResource *> *members;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of elements matching this request.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

@end


/**
 *  The ListGroups response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "group" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRMonitoring_ListGroupsResponse : GTLRCollectionObject

/**
 *  The groups that match the specified filters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Group *> *group;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMetricDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "metricDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMetricDescriptorsResponse : GTLRCollectionObject

/**
 *  The metric descriptors that are available to the project and that match the
 *  value of filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MetricDescriptor *> *metricDescriptors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListMonitoredResourceDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resourceDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListMonitoredResourceDescriptorsResponse : GTLRCollectionObject

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The monitored resource descriptors that are available to this project and
 *  that match filter, if present.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_MonitoredResourceDescriptor *> *resourceDescriptors;

@end


/**
 *  The ListNotificationChannelDescriptors response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "channelDescriptors" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListNotificationChannelDescriptorsResponse : GTLRCollectionObject

/**
 *  The monitored resource descriptors supported for the specified project,
 *  optionally filtered.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_NotificationChannelDescriptor *> *channelDescriptors;

/**
 *  If not empty, indicates that there may be more results that match the
 *  request. Use the value in the page_token field in a subsequent request to
 *  fetch the next set of results. If empty, all results have been returned.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The ListNotificationChannels response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "notificationChannels" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListNotificationChannelsResponse : GTLRCollectionObject

/**
 *  If not empty, indicates that there may be more results that match the
 *  request. Use the value in the page_token field in a subsequent request to
 *  fetch the next set of results. If empty, all results have been returned.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The notification channels defined for the specified project.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_NotificationChannel *> *notificationChannels;

@end


/**
 *  The ListTimeSeries response.
 */
@interface GTLRMonitoring_ListTimeSeriesResponse : GTLRObject

/**
 *  Query execution errors that may have caused the time series data returned to
 *  be incomplete.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Status *> *executionErrors;

/**
 *  If there are more results than have been returned, then this field is set to
 *  a non-empty value. To see the additional results, use that value as
 *  pageToken in the next call to this method.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** One or more time series that match the filter included in the request. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_TimeSeries *> *timeSeries;

@end


/**
 *  The protocol for the ListUptimeCheckConfigs response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "uptimeCheckConfigs" property. If returned as the result of a
 *        query, it should support automatic pagination (when @c
 *        shouldFetchNextPages is enabled).
 */
@interface GTLRMonitoring_ListUptimeCheckConfigsResponse : GTLRCollectionObject

/**
 *  This field represents the pagination token to retrieve the next page of
 *  results. If the value is empty, it means no further results for the request.
 *  To retrieve the next page of results, the value of the next_page_token is
 *  passed to the subsequent List method call (in the request message's
 *  page_token field).
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The total number of uptime check configurations for the project,
 *  irrespective of any pagination.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalSize;

/**
 *  The returned uptime check configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_UptimeCheckConfig *> *uptimeCheckConfigs;

@end


/**
 *  The protocol for the ListUptimeCheckIps response.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "uptimeCheckIps" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRMonitoring_ListUptimeCheckIpsResponse : GTLRCollectionObject

/**
 *  This field represents the pagination token to retrieve the next page of
 *  results. If the value is empty, it means no further results for the request.
 *  To retrieve the next page of results, the value of the next_page_token is
 *  passed to the subsequent List method call (in the request message's
 *  page_token field). NOTE: this field is not yet implemented
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The returned list of IP addresses (including region and location) that the
 *  checkers run from.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_UptimeCheckIp *> *uptimeCheckIps;

@end


/**
 *  A specific metric, identified by specifying values for all of the labels of
 *  a MetricDescriptor.
 */
@interface GTLRMonitoring_Metric : GTLRObject

/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric_Labels *labels;

/**
 *  An existing metric type, see google.api.MetricDescriptor. For example,
 *  custom.googleapis.com/invoice/paid/amount.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The set of label values that uniquely identify this metric. All labels
 *  listed in the MetricDescriptor must be assigned values.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_Metric_Labels : GTLRObject
@end


/**
 *  A condition type that checks that monitored resources are reporting data.
 *  The configuration defines a metric and a set of monitored resources. The
 *  predicate is considered in violation when a time series for the specified
 *  metric of a monitored resource does not include any data in the specified
 *  duration.
 */
@interface GTLRMonitoring_MetricAbsence : GTLRObject

/**
 *  Specifies the alignment of data points in individual time series as well as
 *  how to combine the retrieved time series together (such as when aggregating
 *  multiple streams on each resource to a single stream for each resource or
 *  when aggregating streams across all members of a group of resrouces).
 *  Multiple aggregations are applied in the order specified.This field is
 *  similar to the one in the MetricService.ListTimeSeries request. It is
 *  advisable to use the ListTimeSeries method when debugging this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Aggregation *> *aggregations;

/**
 *  The amount of time that a time series must fail to report new data to be
 *  considered failing. Currently, only values that are a multiple of a
 *  minute--e.g. 60, 120, or 300 seconds--are supported. If an invalid value is
 *  given, an error will be returned. The Duration.nanos field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  A filter that identifies which time series should be compared with the
 *  threshold.The filter is similar to the one that is specified in the
 *  MetricService.ListTimeSeries request (that call is useful to verify the time
 *  series that will be retrieved / processed) and must specify the metric type
 *  and optionally may contain restrictions on resource type, resource labels,
 *  and metric labels. This field may not exceed 2048 Unicode characters in
 *  length.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The number/percent of time series for which the comparison must hold in
 *  order for the condition to trigger. If unspecified, then the condition will
 *  trigger if the comparison is true for any of the time series that have been
 *  identified by filter and aggregations.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Trigger *trigger;

@end


/**
 *  Defines a metric type and its schema. Once a metric descriptor is created,
 *  deleting or altering it stops data collection and makes the metric type's
 *  existing data unusable.
 */
@interface GTLRMonitoring_MetricDescriptor : GTLRObject

/**
 *  A detailed description of the metric, which can be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A concise name for the metric, which can be displayed in user interfaces.
 *  Use sentence case without an ending period, for example "Request count".
 *  This field is optional but it is recommended to be set for any metrics
 *  associated with user-visible concepts, such as Quota.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that can be used to describe a specific instance of this
 *  metric type. For example, the
 *  appengine.googleapis.com/http/server/response_latencies metric type has a
 *  label for the HTTP response code, response_code, so you can look at
 *  latencies for successful responses or just for responses that failed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/** Optional. Metadata which can be used to guide usage of the metric. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MetricDescriptorMetadata *metadata;

/**
 *  Whether the metric records instantaneous values, changes to a value, etc.
 *  Some combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Delta The change in a
 *        value during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_MetricKind_MetricKindUnspecified
 *        Do not use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/** The resource name of the metric descriptor. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The metric type, including its DNS name prefix. The type is not URL-encoded.
 *  All user-defined metric types have the DNS name custom.googleapis.com or
 *  external.googleapis.com. Metric types should use a natural hierarchical
 *  grouping. For example:
 *  "custom.googleapis.com/invoice/paid/amount"
 *  "external.googleapis.com/prometheus/up"
 *  "appengine.googleapis.com/http/server/response_latencies"
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The unit in which the metric value is reported. It is only applicable if the
 *  value_type is INT64, DOUBLE, or DISTRIBUTION. The supported units are a
 *  subset of The Unified Code for Units of Measure
 *  (http://unitsofmeasure.org/ucum.html) standard:Basic units (UNIT)
 *  bit bit
 *  By byte
 *  s second
 *  min minute
 *  h hour
 *  d dayPrefixes (PREFIX)
 *  k kilo (10**3)
 *  M mega (10**6)
 *  G giga (10**9)
 *  T tera (10**12)
 *  P peta (10**15)
 *  E exa (10**18)
 *  Z zetta (10**21)
 *  Y yotta (10**24)
 *  m milli (10**-3)
 *  u micro (10**-6)
 *  n nano (10**-9)
 *  p pico (10**-12)
 *  f femto (10**-15)
 *  a atto (10**-18)
 *  z zepto (10**-21)
 *  y yocto (10**-24)
 *  Ki kibi (2**10)
 *  Mi mebi (2**20)
 *  Gi gibi (2**30)
 *  Ti tebi (2**40)GrammarThe grammar also includes these connectors:
 *  / division (as an infix operator, e.g. 1/s).
 *  . multiplication (as an infix operator, e.g. GBy.d)The grammar for a unit is
 *  as follows:
 *  Expression = Component { "." Component } { "/" Component } ;
 *  Component = ( [ PREFIX ] UNIT | "%" ) [ Annotation ]
 *  | Annotation
 *  | "1"
 *  ;
 *  Annotation = "{" NAME "}" ;
 *  Notes:
 *  Annotation is just a comment if it follows a UNIT and is equivalent to 1 if
 *  it is used alone. For examples, {requests}/s == 1/s, By{transmitted}/s ==
 *  By/s.
 *  NAME is a sequence of non-blank printable ASCII characters not containing
 *  '{' or '}'.
 *  1 represents dimensionless value 1, such as in 1/s.
 *  % represents dimensionless value 1/100, and annotates values giving a
 *  percentage.
 */
@property(nonatomic, copy, nullable) NSString *unit;

/**
 *  Whether the measurement is an integer, a floating-point number, etc. Some
 *  combinations of metric_kind and value_type might not be supported.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Bool The value is a
 *        boolean. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "BOOL")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Distribution The value
 *        is a Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Double The value is a
 *        double precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Int64 The value is a
 *        signed 64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_Money The value is
 *        money. (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_String The value is a
 *        text string. This value type can be used only if the metric kind is
 *        GAUGE. (Value: "STRING")
 *    @arg @c kGTLRMonitoring_MetricDescriptor_ValueType_ValueTypeUnspecified Do
 *        not use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Additional annotations that can be used to guide the usage of a metric.
 */
@interface GTLRMonitoring_MetricDescriptorMetadata : GTLRObject

/**
 *  The delay of data points caused by ingestion. Data points older than this
 *  age are guaranteed to be ingested and available to be read, excluding data
 *  loss due to errors.
 */
@property(nonatomic, strong, nullable) GTLRDuration *ingestDelay;

/**
 *  The launch stage of the metric definition.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Alpha Alpha
 *        is a limited availability test for releases before they are cleared
 *        for widespread use. By Alpha, all significant design issues are
 *        resolved and we are in the process of verifying functionality. Alpha
 *        customers need to apply for access, agree to applicable terms, and
 *        have their projects whitelisted. Alpha releases don’t have to be
 *        feature complete, no SLAs are provided, and there are no technical
 *        support obligations, but they will be far enough along that customers
 *        can actually use them in test environments or for limited-use tests --
 *        just like they would in normal production cases. (Value: "ALPHA")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Beta Beta is
 *        the point at which we are ready to open a release for any customer to
 *        use. There are no SLA or technical support obligations in a Beta
 *        release. Products will be complete from a feature perspective, but may
 *        have some open outstanding issues. Beta releases are suitable for
 *        limited production use cases. (Value: "BETA")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Deprecated
 *        Deprecated features are scheduled to be shut down and removed. For
 *        more information, see the “Deprecation Policy” section of our Terms of
 *        Service (https://cloud.google.com/terms/) and the Google Cloud
 *        Platform Subject to the Deprecation Policy
 *        (https://cloud.google.com/terms/deprecation) documentation. (Value:
 *        "DEPRECATED")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_EarlyAccess
 *        Early Access features are limited to a closed group of testers. To use
 *        these features, you must sign up in advance and sign a Trusted Tester
 *        agreement (which includes confidentiality provisions). These features
 *        may be unstable, changed in backward-incompatible ways, and are not
 *        guaranteed to be released. (Value: "EARLY_ACCESS")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_Ga GA
 *        features are open to all developers and are considered stable and
 *        fully qualified for production use. (Value: "GA")
 *    @arg @c kGTLRMonitoring_MetricDescriptorMetadata_LaunchStage_LaunchStageUnspecified
 *        Do not use this default value. (Value: "LAUNCH_STAGE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *launchStage;

/**
 *  The sampling period of metric data points. For metrics which are written
 *  periodically, consecutive data points are stored at this time interval,
 *  excluding data loss due to errors. Metrics with a higher granularity have a
 *  smaller sampling period.
 */
@property(nonatomic, strong, nullable) GTLRDuration *samplePeriod;

@end


/**
 *  A condition type that compares a collection of time series against a
 *  threshold.
 */
@interface GTLRMonitoring_MetricThreshold : GTLRObject

/**
 *  Specifies the alignment of data points in individual time series as well as
 *  how to combine the retrieved time series together (such as when aggregating
 *  multiple streams on each resource to a single stream for each resource or
 *  when aggregating streams across all members of a group of resrouces).
 *  Multiple aggregations are applied in the order specified.This field is
 *  similar to the one in the MetricService.ListTimeSeries request. It is
 *  advisable to use the ListTimeSeries method when debugging this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Aggregation *> *aggregations;

/**
 *  The comparison to apply between the time series (indicated by filter and
 *  aggregation) and the threshold (indicated by threshold_value). The
 *  comparison is applied on each time series, with the time series on the
 *  left-hand side and the threshold on the right-hand side.Only COMPARISON_LT
 *  and COMPARISON_GT are supported currently.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonEq The left
 *        argument is equal to the right argument. (Value: "COMPARISON_EQ")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGe The left
 *        argument is greater than or equal to the right argument. (Value:
 *        "COMPARISON_GE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonGt The left
 *        argument is greater than the right argument. (Value: "COMPARISON_GT")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLe The left
 *        argument is less than or equal to the right argument. (Value:
 *        "COMPARISON_LE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonLt The left
 *        argument is less than the right argument. (Value: "COMPARISON_LT")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonNe The left
 *        argument is not equal to the right argument. (Value: "COMPARISON_NE")
 *    @arg @c kGTLRMonitoring_MetricThreshold_Comparison_ComparisonUnspecified
 *        No ordering relationship is specified. (Value:
 *        "COMPARISON_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *comparison;

/**
 *  Specifies the alignment of data points in individual time series selected by
 *  denominatorFilter as well as how to combine the retrieved time series
 *  together (such as when aggregating multiple streams on each resource to a
 *  single stream for each resource or when aggregating streams across all
 *  members of a group of resources).When computing ratios, the aggregations and
 *  denominator_aggregations fields must use the same alignment period and
 *  produce time series that have the same periodicity and labels.This field is
 *  similar to the one in the MetricService.ListTimeSeries request. It is
 *  advisable to use the ListTimeSeries method when debugging this field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Aggregation *> *denominatorAggregations;

/**
 *  A filter that identifies a time series that should be used as the
 *  denominator of a ratio that will be compared with the threshold. If a
 *  denominator_filter is specified, the time series specified by the filter
 *  field will be used as the numerator.The filter is similar to the one that is
 *  specified in the MetricService.ListTimeSeries request (that call is useful
 *  to verify the time series that will be retrieved / processed) and must
 *  specify the metric type and optionally may contain restrictions on resource
 *  type, resource labels, and metric labels. This field may not exceed 2048
 *  Unicode characters in length.
 */
@property(nonatomic, copy, nullable) NSString *denominatorFilter;

/**
 *  The amount of time that a time series must violate the threshold to be
 *  considered failing. Currently, only values that are a multiple of a
 *  minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value
 *  is given, an error will be returned. When choosing a duration, it is useful
 *  to keep in mind the frequency of the underlying time series data (which may
 *  also be affected by any alignments specified in the aggregations field); a
 *  good duration is long enough so that a single outlier does not generate
 *  spurious alerts, but short enough that unhealthy states are detected and
 *  alerted on quickly.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  A filter that identifies which time series should be compared with the
 *  threshold.The filter is similar to the one that is specified in the
 *  MetricService.ListTimeSeries request (that call is useful to verify the time
 *  series that will be retrieved / processed) and must specify the metric type
 *  and optionally may contain restrictions on resource type, resource labels,
 *  and metric labels. This field may not exceed 2048 Unicode characters in
 *  length.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  A value against which to compare the time series.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *thresholdValue;

/**
 *  The number/percent of time series for which the comparison must hold in
 *  order for the condition to trigger. If unspecified, then the condition will
 *  trigger if the comparison is true for any of the time series that have been
 *  identified by filter and aggregations, or by the ratio, if
 *  denominator_filter and denominator_aggregations are specified.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Trigger *trigger;

@end


/**
 *  An object representing a resource that can be used for monitoring, logging,
 *  billing, or other purposes. Examples include virtual machine instances,
 *  databases, and storage devices such as disks. The type field identifies a
 *  MonitoredResourceDescriptor object that describes the resource's schema.
 *  Information in the labels field identifies the actual resource and its
 *  attributes according to the schema. For example, a particular Compute Engine
 *  VM instance could be represented by the following object, because the
 *  MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and
 *  "zone":
 *  { "type": "gce_instance",
 *  "labels": { "instance_id": "12345678901234",
 *  "zone": "us-central1-a" }}
 */
@interface GTLRMonitoring_MonitoredResource : GTLRObject

/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Compute Engine VM instances use the labels
 *  "project_id", "instance_id", and "zone".
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource_Labels *labels;

/**
 *  Required. The monitored resource type. This field must match the type field
 *  of a MonitoredResourceDescriptor object. For example, the type of a Compute
 *  Engine VM instance is gce_instance. For a list of types, see Monitoring
 *  resource types and Logging resource types.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Required. Values for all of the labels listed in the associated monitored
 *  resource descriptor. For example, Compute Engine VM instances use the labels
 *  "project_id", "instance_id", and "zone".
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResource_Labels : GTLRObject
@end


/**
 *  An object that describes the schema of a MonitoredResource object using a
 *  type name and a set of labels. For example, the monitored resource
 *  descriptor for Google Compute Engine VM instances has a type of
 *  "gce_instance" and specifies the use of the labels "instance_id" and "zone"
 *  to identify particular VM instances.Different APIs can support different
 *  monitored resource types. APIs generally provide a list method that returns
 *  the monitored resource descriptors used by the API.
 */
@interface GTLRMonitoring_MonitoredResourceDescriptor : GTLRObject

/**
 *  Optional. A detailed description of the monitored resource type that might
 *  be used in documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Optional. A concise name for the monitored resource type that might be
 *  displayed in user interfaces. It should be a Title Cased Noun Phrase,
 *  without any article or other determiners. For example, "Google Cloud SQL
 *  Database".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Required. A set of labels used to describe instances of this monitored
 *  resource type. For example, an individual Google Cloud SQL database is
 *  identified by values for the labels "database_id" and "zone".
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  Optional. The resource name of the monitored resource descriptor:
 *  "projects/{project_id}/monitoredResourceDescriptors/{type}" where {type} is
 *  the value of the type field in this object and {project_id} is a project ID
 *  that provides API-specific context for accessing the type. APIs that do not
 *  use project information can use the resource name format
 *  "monitoredResourceDescriptors/{type}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. The monitored resource type. For example, the type
 *  "cloudsql_database" represents databases in Google Cloud SQL. The maximum
 *  length of this value is 256 characters.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Auxiliary metadata for a MonitoredResource object. MonitoredResource objects
 *  contain the minimum set of information to uniquely identify a monitored
 *  resource instance. There is some other useful auxiliary metadata. Monitoring
 *  and Logging use an ingestion pipeline to extract metadata for cloud
 *  resources of all types, and store the metadata in this message.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata : GTLRObject

/**
 *  Output only. Values for predefined system metadata labels. System labels are
 *  a kind of metadata extracted by Google, including "machine_image", "vpc",
 *  "subnet_id", "security_group", "name", etc. System label values can be only
 *  strings, Boolean values, or a list of strings. For example:
 *  { "name": "my-test-instance",
 *  "security_group": ["a", "b", "c"],
 *  "spot_instance": false }
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata_SystemLabels *systemLabels;

/** Output only. A map of user-defined metadata labels. */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata_UserLabels *userLabels;

@end


/**
 *  Output only. Values for predefined system metadata labels. System labels are
 *  a kind of metadata extracted by Google, including "machine_image", "vpc",
 *  "subnet_id", "security_group", "name", etc. System label values can be only
 *  strings, Boolean values, or a list of strings. For example:
 *  { "name": "my-test-instance",
 *  "security_group": ["a", "b", "c"],
 *  "spot_instance": false }
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata_SystemLabels : GTLRObject
@end


/**
 *  Output only. A map of user-defined metadata labels.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_MonitoredResourceMetadata_UserLabels : GTLRObject
@end


/**
 *  Describes a change made to a configuration.
 */
@interface GTLRMonitoring_MutationRecord : GTLRObject

/** The email address of the user making the change. */
@property(nonatomic, copy, nullable) NSString *mutatedBy;

/** When the change occurred. */
@property(nonatomic, strong, nullable) GTLRDateTime *mutateTime;

@end


/**
 *  A NotificationChannel is a medium through which an alert is delivered when a
 *  policy violation is detected. Examples of channels include email, SMS, and
 *  third-party messaging applications. Fields containing sensitive information
 *  like authentication tokens or contact info are only partially populated on
 *  retrieval.
 */
@interface GTLRMonitoring_NotificationChannel : GTLRObject

/**
 *  An optional human-readable description of this notification channel. This
 *  description may provide additional details, beyond the display name, for the
 *  channel. This may not exceeed 1024 Unicode characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  An optional human-readable name for this notification channel. It is
 *  recommended that you specify a non-empty and unique name in order to make it
 *  easier to identify the channels in your project, though this is not
 *  enforced. The display name is limited to 512 Unicode characters.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Whether notifications are forwarded to the described channel. This makes it
 *  possible to disable delivery of notifications to a particular channel
 *  without removing the channel from all alerting policies that reference the
 *  channel. This is a more convenient approach when the change is temporary and
 *  you want to receive notifications from the same set of alerting policies on
 *  the channel at some point in the future.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Configuration fields that define the channel and its behavior. The
 *  permissible and required labels are specified in the
 *  NotificationChannelDescriptor.labels of the NotificationChannelDescriptor
 *  corresponding to the type field.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_NotificationChannel_Labels *labels;

/**
 *  The full REST resource name for this channel. The syntax is:
 *  projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
 *  The [CHANNEL_ID] is automatically assigned by the server on creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The type of the notification channel. This field matches the value of the
 *  NotificationChannelDescriptor.type field.
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  User-supplied key/value data that does not need to conform to the
 *  corresponding NotificationChannelDescriptor's schema, unlike the labels
 *  field. This field is intended to be used for organizing and identifying the
 *  NotificationChannel objects.The field can contain up to 64 entries. Each key
 *  and value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_NotificationChannel_UserLabels *userLabels;

/**
 *  Indicates whether this channel has been verified or not. On a
 *  ListNotificationChannels or GetNotificationChannel operation, this field is
 *  expected to be populated.If the value is UNVERIFIED, then it indicates that
 *  the channel is non-functioning (it both requires verification and lacks
 *  verification); otherwise, it is assumed that the channel works.If the
 *  channel is neither VERIFIED nor UNVERIFIED, it implies that the channel is
 *  of a type that does not require verification or that this specific channel
 *  has been exempted from verification because it was created prior to
 *  verification being required for channels of this type.This field cannot be
 *  modified using a standard UpdateNotificationChannel operation. To change the
 *  value of this field, you must call VerifyNotificationChannel.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_NotificationChannel_VerificationStatus_Unverified
 *        The channel has yet to be verified and requires verification to
 *        function. Note that this state also applies to the case where the
 *        verification process has been initiated by sending a verification code
 *        but where the verification code has not been submitted to complete the
 *        process. (Value: "UNVERIFIED")
 *    @arg @c kGTLRMonitoring_NotificationChannel_VerificationStatus_VerificationStatusUnspecified
 *        Sentinel value used to indicate that the state is unknown, omitted, or
 *        is not applicable (as in the case of channels that neither support nor
 *        require verification in order to function). (Value:
 *        "VERIFICATION_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_NotificationChannel_VerificationStatus_Verified It
 *        has been proven that notifications can be received on this
 *        notification channel and that someone on the project has access to
 *        messages that are delivered to that channel. (Value: "VERIFIED")
 */
@property(nonatomic, copy, nullable) NSString *verificationStatus;

@end


/**
 *  Configuration fields that define the channel and its behavior. The
 *  permissible and required labels are specified in the
 *  NotificationChannelDescriptor.labels of the NotificationChannelDescriptor
 *  corresponding to the type field.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_NotificationChannel_Labels : GTLRObject
@end


/**
 *  User-supplied key/value data that does not need to conform to the
 *  corresponding NotificationChannelDescriptor's schema, unlike the labels
 *  field. This field is intended to be used for organizing and identifying the
 *  NotificationChannel objects.The field can contain up to 64 entries. Each key
 *  and value is limited to 63 Unicode characters or 128 bytes, whichever is
 *  smaller. Labels and values can contain only lowercase letters, numerals,
 *  underscores, and dashes. Keys must begin with a letter.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRMonitoring_NotificationChannel_UserLabels : GTLRObject
@end


/**
 *  A description of a notification channel. The descriptor includes the
 *  properties of the channel and the set of labels or fields that must be
 *  specified to configure channels of a given type.
 */
@interface GTLRMonitoring_NotificationChannelDescriptor : GTLRObject

/**
 *  A human-readable description of the notification channel type. The
 *  description may include a description of the properties of the channel and
 *  pointers to external documentation.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  A human-readable name for the notification channel type. This form of the
 *  name is suitable for a user interface.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The set of labels that must be defined to identify a particular channel of
 *  the corresponding type. Each label includes a description for how that field
 *  should be populated.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_LabelDescriptor *> *labels;

/**
 *  The full REST resource name for this descriptor. The syntax is:
 *  projects/[PROJECT_ID]/notificationChannelDescriptors/[TYPE]
 *  In the above, [TYPE] is the value of the type field.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The tiers that support this notification channel; the project service tier
 *  must be one of the supported_tiers.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *supportedTiers;

/**
 *  The type of notification channel, such as "email", "sms", etc. Notification
 *  channel types are globally unique.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A protocol buffer option, which can be attached to a message, field,
 *  enumeration, etc.
 */
@interface GTLRMonitoring_Option : GTLRObject

/**
 *  The option's name. For protobuf built-in options (options defined in
 *  descriptor.proto), this is the short name. For example, "map_entry". For
 *  custom options, it should be the fully-qualified name. For example,
 *  "google.api.http".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Option_Value *value;

@end


/**
 *  The option's value packed in an Any message. If the value is a primitive,
 *  the corresponding wrapper type defined in google/protobuf/wrappers.proto
 *  should be used. If the value is an enum, it should be stored as an int32
 *  value using the google.protobuf.Int32Value type.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Option_Value : GTLRObject
@end


/**
 *  A single data point in a time series.
 */
@interface GTLRMonitoring_Point : GTLRObject

/**
 *  The time interval to which the data point applies. For GAUGE metrics, only
 *  the end time of the interval is used. For DELTA metrics, the start and end
 *  time should specify a non-zero interval, with subsequent points specifying
 *  contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start
 *  and end time should specify a non-zero interval, with subsequent points
 *  specifying the same start time and increasing end times, until an event
 *  resets the cumulative value to zero and sets a new start time for the
 *  following points.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_TimeInterval *interval;

/** The value of the data point. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TypedValue *value;

@end


/**
 *  The range of the population values.
 */
@interface GTLRMonitoring_Range : GTLRObject

/**
 *  The maximum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *max;

/**
 *  The minimum of the population values.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *min;

@end


/**
 *  The resource submessage for group checks. It can be used instead of a
 *  monitored resource, when multiple resources are being monitored.
 */
@interface GTLRMonitoring_ResourceGroup : GTLRObject

/**
 *  The group of resources being monitored. Should be only the group_id, not
 *  projects/<project_id>/groups/<group_id>.
 */
@property(nonatomic, copy, nullable) NSString *groupId;

/**
 *  The resource type of the group members.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_AwsElbLoadBalancer A
 *        group of Amazon ELB load balancers. (Value: "AWS_ELB_LOAD_BALANCER")
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_Instance A group of
 *        instances from Google Cloud Platform (GCP) or Amazon Web Services
 *        (AWS). (Value: "INSTANCE")
 *    @arg @c kGTLRMonitoring_ResourceGroup_ResourceType_ResourceTypeUnspecified
 *        Default value (not valid). (Value: "RESOURCE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *resourceType;

@end


/**
 *  The SendNotificationChannelVerificationCode request.
 */
@interface GTLRMonitoring_SendNotificationChannelVerificationCodeRequest : GTLRObject
@end


/**
 *  SourceContext represents information about the source of a protobuf element,
 *  like the file in which it is defined.
 */
@interface GTLRMonitoring_SourceContext : GTLRObject

/**
 *  The path-qualified name of the .proto file that contained the associated
 *  protobuf element. For example: "google/protobuf/source_context.proto".
 */
@property(nonatomic, copy, nullable) NSString *fileName;

@end


/**
 *  The context of a span, attached to google.api.Distribution.Exemplars in
 *  google.api.Distribution values during aggregation.It contains the name of a
 *  span with format: projects/PROJECT_ID/traces/TRACE_ID/spans/SPAN_ID
 */
@interface GTLRMonitoring_SpanContext : GTLRObject

/**
 *  The resource name of the span in the following format:
 *  projects/[PROJECT_ID]/traces/[TRACE_ID]/spans/[SPAN_ID]
 *  TRACE_ID is a unique identifier for a trace within a project; it is a
 *  32-character hexadecimal encoding of a 16-byte array.SPAN_ID is a unique
 *  identifier for a span within a trace; it is a 16-character hexadecimal
 *  encoding of an 8-byte array.
 */
@property(nonatomic, copy, nullable) NSString *spanName;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). The error model is designed to be:
 *  Simple to use and understand for most users
 *  Flexible enough to meet unexpected needsOverviewThe Status message contains
 *  three pieces of data: error code, error message, and error details. The
 *  error code should be an enum value of google.rpc.Code, but it may accept
 *  additional error codes if needed. The error message should be a
 *  developer-facing English message that helps developers understand and
 *  resolve the error. If a localized user-facing error message is needed, put
 *  the localized message in the error details or localize it in the client. The
 *  optional error details may contain arbitrary information about the error.
 *  There is a predefined set of error detail types in the package google.rpc
 *  that can be used for common error conditions.Language mappingThe Status
 *  message is the logical representation of the error model, but it is not
 *  necessarily the actual wire format. When the Status message is exposed in
 *  different client libraries and different wire protocols, it can be mapped
 *  differently. For example, it will likely be mapped to some exceptions in
 *  Java, but more likely mapped to some error codes in C.Other usesThe error
 *  model and the Status message can be used in a variety of environments,
 *  either with or without APIs, to provide a consistent developer experience
 *  across different environments.Example uses of this error model include:
 *  Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the Status in the normal response to indicate the partial
 *  errors.
 *  Workflow errors. A typical workflow has multiple steps. Each step may have a
 *  Status message for error reporting.
 *  Batch operations. If a client uses batch request and batch response, the
 *  Status message should be used directly inside batch response, one for each
 *  error sub-response.
 *  Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the Status message.
 *  Logging. If some API errors are stored in logs, the message Status could be
 *  used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRMonitoring_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRMonitoring_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRMonitoring_Status_Details_Item : GTLRObject
@end


/**
 *  Information required for a TCP uptime check request.
 */
@interface GTLRMonitoring_TcpCheck : GTLRObject

/**
 *  The port to the page to run the check against. Will be combined with host
 *  (specified within the MonitoredResource) to construct the full URL.
 *  Required.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

@end


/**
 *  A time interval extending just after a start time through an end time. The
 *  start time must not be later than the end time. The default start time is
 *  the end time, making the startTime value technically optional. Whether this
 *  is useful depends on the MetricKind. If the start and end times are the
 *  same, the interval represents a point in time. This is appropriate for GAUGE
 *  metrics, but not for DELTA and CUMULATIVE metrics, which cover a span of
 *  time.
 */
@interface GTLRMonitoring_TimeInterval : GTLRObject

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  A collection of data points that describes the time-varying values of a
 *  metric. A time series is identified by a combination of a fully-specified
 *  monitored resource and a fully-specified metric. This type is used for both
 *  listing and creating time series.
 */
@interface GTLRMonitoring_TimeSeries : GTLRObject

/**
 *  Output only. The associated monitored resource metadata. When reading a a
 *  timeseries, this field will include metadata labels that are explicitly
 *  named in the reduction. When creating a timeseries, this field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResourceMetadata *metadata;

/**
 *  The associated metric. A fully-specified metric used to identify the time
 *  series.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_Metric *metric;

/**
 *  The metric kind of the time series. When listing time series, this metric
 *  kind might be different from the metric kind of the associated metric if
 *  this time series is an alignment or reduction of other time series.When
 *  creating a time series, this field is optional. If present, it must be the
 *  same as the metric kind of the associated metric. If the associated metric's
 *  descriptor must be auto-created, then this field specifies the metric kind
 *  of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Cumulative A value
 *        accumulated over a time interval. Cumulative measurements in a time
 *        series should have the same start time and increasing end times, until
 *        an event resets the cumulative value to zero and sets a new start time
 *        for the following points. (Value: "CUMULATIVE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Delta The change in a value
 *        during a time interval. (Value: "DELTA")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_Gauge An instantaneous
 *        measurement of a value. (Value: "GAUGE")
 *    @arg @c kGTLRMonitoring_TimeSeries_MetricKind_MetricKindUnspecified Do not
 *        use this default value. (Value: "METRIC_KIND_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *metricKind;

/**
 *  The data points of this time series. When listing time series, points are
 *  returned in reverse time order.When creating a time series, this field must
 *  contain exactly one point and the point's type must be the same as the value
 *  type of the associated metric. If the associated metric's descriptor must be
 *  auto-created, then the value type of the descriptor is determined by the
 *  point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Point *> *points;

/**
 *  The associated monitored resource. Custom metrics can use only certain
 *  monitored resource types in their time series data.
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *resource;

/**
 *  The value type of the time series. When listing time series, this value type
 *  might be different from the value type of the associated metric if this time
 *  series is an alignment or reduction of other time series.When creating a
 *  time series, this field is optional. If present, it must be the same as the
 *  type of the data in the points field.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Bool The value is a boolean.
 *        This value type can be used only if the metric kind is GAUGE. (Value:
 *        "BOOL")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Distribution The value is a
 *        Distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Double The value is a double
 *        precision floating point number. (Value: "DOUBLE")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Int64 The value is a signed
 *        64-bit integer. (Value: "INT64")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_Money The value is money.
 *        (Value: "MONEY")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_String The value is a text
 *        string. This value type can be used only if the metric kind is GAUGE.
 *        (Value: "STRING")
 *    @arg @c kGTLRMonitoring_TimeSeries_ValueType_ValueTypeUnspecified Do not
 *        use this default value. (Value: "VALUE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *valueType;

@end


/**
 *  Specifies how many time series must fail a predicate to trigger a condition.
 *  If not specified, then a {count: 1} trigger is used.
 */
@interface GTLRMonitoring_Trigger : GTLRObject

/**
 *  The absolute number of time series that must fail the predicate for the
 *  condition to be triggered.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  The percentage of time series that must fail the predicate for the condition
 *  to be triggered.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percent;

@end


/**
 *  A protocol buffer message type.
 */
@interface GTLRMonitoring_Type : GTLRObject

/** The list of fields. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Field *> *fields;

/** The fully qualified message name. */
@property(nonatomic, copy, nullable) NSString *name;

/** The list of types appearing in oneof definitions in this type. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oneofs;

/** The protocol buffer options. */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_Option *> *options;

/** The source context. */
@property(nonatomic, strong, nullable) GTLRMonitoring_SourceContext *sourceContext;

/**
 *  The source syntax.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto2 Syntax proto2. (Value:
 *        "SYNTAX_PROTO2")
 *    @arg @c kGTLRMonitoring_Type_Syntax_SyntaxProto3 Syntax proto3. (Value:
 *        "SYNTAX_PROTO3")
 */
@property(nonatomic, copy, nullable) NSString *syntax;

@end


/**
 *  A single strongly-typed value.
 */
@interface GTLRMonitoring_TypedValue : GTLRObject

/**
 *  A Boolean value: true or false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRMonitoring_Distribution *distributionValue;

/**
 *  A 64-bit double-precision floating-point number. Its magnitude is
 *  approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16 significant
 *  digits of precision.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** A variable-length string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  This message configures which resources and services to monitor for
 *  availability.
 */
@interface GTLRMonitoring_UptimeCheckConfig : GTLRObject

/**
 *  The expected content on the page the check is run against. Currently, only
 *  the first entry in the list is supported, and other entries will be ignored.
 *  The server will look for an exact match of the string in the page response's
 *  content. This field is optional and should only be specified if a content
 *  match is required.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_ContentMatcher *> *contentMatchers;

/**
 *  A human-friendly name for the uptime check configuration. The display name
 *  should be unique within a Stackdriver Workspace in order to make it easier
 *  to identify; however, uniqueness is not enforced. Required.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Contains information needed to make an HTTP or HTTPS check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_HttpCheck *httpCheck;

/**
 *  The internal checkers that this check will egress from. If is_internal is
 *  true and this list is empty, the check will egress from all the
 *  InternalCheckers configured for the project that owns this CheckConfig.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRMonitoring_InternalChecker *> *internalCheckers;

/**
 *  If this is true, then checks are made only from the 'internal_checkers'. If
 *  it is false, then checks are made only from the 'selected_regions'. It is an
 *  error to provide 'selected_regions' when is_internal is true, or to provide
 *  'internal_checkers' when is_internal is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isInternal;

/**
 *  The monitored resource (https://cloud.google.com/monitoring/api/resources)
 *  associated with the configuration. The following monitored resource types
 *  are supported for uptime checks: uptime_url gce_instance gae_app
 *  aws_ec2_instance aws_elb_load_balancer
 */
@property(nonatomic, strong, nullable) GTLRMonitoring_MonitoredResource *monitoredResource;

/**
 *  A unique resource name for this UptimeCheckConfig. The format
 *  is:projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].This field
 *  should be omitted when creating the uptime check configuration; on create,
 *  the resource name is assigned by the server and included in the response.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  How often, in seconds, the uptime check is performed. Currently, the only
 *  supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes),
 *  and 900s (15 minutes). Optional, defaults to 300s.
 */
@property(nonatomic, strong, nullable) GTLRDuration *period;

/** The group resource associated with the configuration. */
@property(nonatomic, strong, nullable) GTLRMonitoring_ResourceGroup *resourceGroup;

/**
 *  The list of regions from which the check will be run. Some regions contain
 *  one location, and others contain more than one. If this field is specified,
 *  enough regions to include a minimum of 3 locations must be provided, or an
 *  error message is returned. Not specifying this field will result in uptime
 *  checks running from all regions.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *selectedRegions;

/** Contains information needed to make a TCP check. */
@property(nonatomic, strong, nullable) GTLRMonitoring_TcpCheck *tcpCheck;

/**
 *  The maximum amount of time to wait for the request to complete (must be
 *  between 1 and 60 seconds). Required.
 */
@property(nonatomic, strong, nullable) GTLRDuration *timeout;

@end


/**
 *  Contains the region, location, and list of IP addresses where checkers in
 *  the location run from.
 */
@interface GTLRMonitoring_UptimeCheckIp : GTLRObject

/**
 *  The IP address from which the uptime check originates. This is a full IP
 *  address (not an IP address range). Most IP addresses, as of this
 *  publication, are in IPv4 format; however, one should not rely on the IP
 *  addresses being in IPv4 format indefinitely and should support interpreting
 *  this field in either IPv4 or IPv6 format.
 */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/**
 *  A more specific location within the region that typically encodes a
 *  particular city/town/metro (and its containing state/province or country)
 *  within the broader umbrella region category.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  A broad region category in which the IP address is located.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_AsiaPacific Allows checks to
 *        run from locations within the Asia Pacific area (ex: Singapore).
 *        (Value: "ASIA_PACIFIC")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_Europe Allows checks to run
 *        from locations within the continent of Europe. (Value: "EUROPE")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_RegionUnspecified Default
 *        value if no region is specified. Will result in uptime checks running
 *        from all regions. (Value: "REGION_UNSPECIFIED")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_SouthAmerica Allows checks to
 *        run from locations within the continent of South America. (Value:
 *        "SOUTH_AMERICA")
 *    @arg @c kGTLRMonitoring_UptimeCheckIp_Region_Usa Allows checks to run from
 *        locations within the United States of America. (Value: "USA")
 */
@property(nonatomic, copy, nullable) NSString *region;

@end


/**
 *  The VerifyNotificationChannel request.
 */
@interface GTLRMonitoring_VerifyNotificationChannelRequest : GTLRObject

/**
 *  The verification code that was delivered to the channel as a result of
 *  invoking the SendNotificationChannelVerificationCode API method or that was
 *  retrieved from a verified channel via
 *  GetNotificationChannelVerificationCode. For example, one might have
 *  "G-123456" or "TKNZGhhd2EyN3I1MnRnMjRv" (in general, one is only guaranteed
 *  that the code is valid UTF-8; one should not make any assumptions regarding
 *  the structure or format of the code).
 */
@property(nonatomic, copy, nullable) NSString *code;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
