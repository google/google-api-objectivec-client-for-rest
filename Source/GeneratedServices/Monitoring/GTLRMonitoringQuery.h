// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Monitoring API (monitoring/v3)
// Description:
//   Manages your Cloud Monitoring data and configurations. Most projects must
//   be associated with a Workspace, with a few exceptions as noted on the
//   individual method pages. The table entries below are presented in
//   alphabetical order, not in order of common use. For explanations of the
//   concepts found in the table entries, read the Cloud Monitoring
//   documentation.
// Documentation:
//   https://cloud.google.com/monitoring/api/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRQuery.h"
#else
  #import "GTLRQuery.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_AlertPolicy;
@class GTLRMonitoring_CreateCollectdTimeSeriesRequest;
@class GTLRMonitoring_CreateTimeSeriesRequest;
@class GTLRMonitoring_GetNotificationChannelVerificationCodeRequest;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_NotificationChannel;
@class GTLRMonitoring_QueryTimeSeriesRequest;
@class GTLRMonitoring_SendNotificationChannelVerificationCodeRequest;
@class GTLRMonitoring_Service;
@class GTLRMonitoring_ServiceLevelObjective;
@class GTLRMonitoring_UptimeCheckConfig;
@class GTLRMonitoring_VerifyNotificationChannelRequest;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the query classes' properties below.

// ----------------------------------------------------------------------------
// aggregationCrossSeriesReducer

/** Value: "REDUCE_COUNT" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceCount;
/** Value: "REDUCE_COUNT_FALSE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceCountFalse;
/** Value: "REDUCE_COUNT_TRUE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceCountTrue;
/** Value: "REDUCE_FRACTION_TRUE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceFractionTrue;
/** Value: "REDUCE_MAX" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceMax;
/** Value: "REDUCE_MEAN" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceMean;
/** Value: "REDUCE_MIN" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceMin;
/** Value: "REDUCE_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceNone;
/** Value: "REDUCE_PERCENTILE_05" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile05;
/** Value: "REDUCE_PERCENTILE_50" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile50;
/** Value: "REDUCE_PERCENTILE_95" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile95;
/** Value: "REDUCE_PERCENTILE_99" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile99;
/** Value: "REDUCE_STDDEV" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceStddev;
/** Value: "REDUCE_SUM" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceSum;

// ----------------------------------------------------------------------------
// aggregationPerSeriesAligner

/** Value: "ALIGN_COUNT" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignCount;
/** Value: "ALIGN_COUNT_FALSE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignCountFalse;
/** Value: "ALIGN_COUNT_TRUE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignCountTrue;
/** Value: "ALIGN_DELTA" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignDelta;
/** Value: "ALIGN_FRACTION_TRUE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignFractionTrue;
/** Value: "ALIGN_INTERPOLATE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignInterpolate;
/** Value: "ALIGN_MAX" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignMax;
/** Value: "ALIGN_MEAN" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignMean;
/** Value: "ALIGN_MIN" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignMin;
/** Value: "ALIGN_NEXT_OLDER" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignNextOlder;
/** Value: "ALIGN_NONE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignNone;
/** Value: "ALIGN_PERCENT_CHANGE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentChange;
/** Value: "ALIGN_PERCENTILE_05" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile05;
/** Value: "ALIGN_PERCENTILE_50" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile50;
/** Value: "ALIGN_PERCENTILE_95" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile95;
/** Value: "ALIGN_PERCENTILE_99" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile99;
/** Value: "ALIGN_RATE" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignRate;
/** Value: "ALIGN_STDDEV" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignStddev;
/** Value: "ALIGN_SUM" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignSum;

// ----------------------------------------------------------------------------
// view

/** Value: "EXPLICIT" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringViewExplicit;
/** Value: "FULL" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringViewFull;
/** Value: "HEADERS" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringViewHeaders;
/** Value: "VIEW_UNSPECIFIED" */
FOUNDATION_EXTERN NSString * const kGTLRMonitoringViewViewUnspecified;

// ----------------------------------------------------------------------------
// Query Classes
//

/**
 *  Parent class for other Monitoring query classes.
 */
@interface GTLRMonitoringQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Creates a new alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesCreateWithObject:name:]

/**
 *  Required. The project in which to create the alerting policy. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 *  Note that this field names the parent container in which the alerting policy
 *  will be written, not the name of the created policy. |name| must be a host
 *  project of a workspace, otherwise INVALID_ARGUMENT error will return. The
 *  alerting policy that is returned will have a name that contains a normalized
 *  representation of this name as a prefix but adds a suffix of the form
 *  /alertPolicies/[ALERT_POLICY_ID], identifying the policy in the container.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_AlertPolicy.
 *
 *  Creates a new alerting policy.
 *
 *  @param object The @c GTLRMonitoring_AlertPolicy to include in the query.
 *  @param name Required. The project in which to create the alerting policy.
 *    The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *    Note that this field names the parent container in which the alerting
 *    policy will be written, not the name of the created policy. |name| must be
 *    a host project of a workspace, otherwise INVALID_ARGUMENT error will
 *    return. The alerting policy that is returned will have a name that
 *    contains a normalized representation of this name as a prefix but adds a
 *    suffix of the form /alertPolicies/[ALERT_POLICY_ID], identifying the
 *    policy in the container.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_AlertPolicy *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes an alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesDeleteWithname:]

/**
 *  Required. The alerting policy to delete. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 *  For more information, see AlertPolicy.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes an alerting policy.
 *
 *  @param name Required. The alerting policy to delete. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 *    For more information, see AlertPolicy.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesGetWithname:]

/**
 *  Required. The alerting policy to retrieve. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_AlertPolicy.
 *
 *  Gets a single alerting policy.
 *
 *  @param name Required. The alerting policy to retrieve. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the existing alerting policies for the workspace.
 *
 *  Method: monitoring.projects.alertPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesListWithname:]

/**
 *  If provided, this field specifies the criteria that must be met by alert
 *  policies to be included in the response.For more details, see sorting and
 *  filtering
 *  (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Required. The project whose alert policies are to be listed. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 *  Note that this field names the parent container in which the alerting
 *  policies to be listed are stored. To retrieve a single alerting policy by
 *  name, use the GetAlertPolicy operation, instead.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A comma-separated list of fields by which to sort the result. Supports the
 *  same set of field references as the filter field. Entries can be prefixed
 *  with a minus sign to sort by the field in descending order.For more details,
 *  see sorting and filtering
 *  (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/** The maximum number of results to return in a single response. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return more results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListAlertPoliciesResponse.
 *
 *  Lists the existing alerting policies for the workspace.
 *
 *  @param name Required. The project whose alert policies are to be listed. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *    Note that this field names the parent container in which the alerting
 *    policies to be listed are stored. To retrieve a single alerting policy by
 *    name, use the GetAlertPolicy operation, instead.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Updates an alerting policy. You can either replace the entire policy with a
 *  new one or replace only certain fields in the current alerting policy by
 *  specifying the fields to be updated via updateMask. Returns the updated
 *  alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesPatchWithObject:name:]

/**
 *  Required if the policy exists. The resource name for this policy. The format
 *  is:
 *  projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 *  [ALERT_POLICY_ID] is assigned by Stackdriver Monitoring when the policy is
 *  created. When calling the alertPolicies.create method, do not include the
 *  name field in the alerting policy passed as part of the request.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. A list of alerting policy field names. If this field is not empty,
 *  each listed field in the existing alerting policy is set to the value of the
 *  corresponding field in the supplied policy (alert_policy), or to the field's
 *  default value if the field is not in the supplied alerting policy. Fields
 *  not listed retain their previous value.Examples of valid field masks include
 *  display_name, documentation, documentation.content, documentation.mime_type,
 *  user_labels, user_label.nameofkey, enabled, conditions, combiner, etc.If
 *  this field is empty, then the supplied alerting policy replaces the existing
 *  policy. It is the same as deleting the existing policy and adding the
 *  supplied policy, except for the following:
 *  The new policy will have the same [ALERT_POLICY_ID] as the former policy.
 *  This gives you continuity with the former policy in your notifications and
 *  incidents.
 *  Conditions in the new policy will keep their former [CONDITION_ID] if the
 *  supplied condition includes the name field with that [CONDITION_ID]. If the
 *  supplied condition omits the name field, then a new [CONDITION_ID] is
 *  created.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_AlertPolicy.
 *
 *  Updates an alerting policy. You can either replace the entire policy with a
 *  new one or replace only certain fields in the current alerting policy by
 *  specifying the fields to be updated via updateMask. Returns the updated
 *  alerting policy.
 *
 *  @param object The @c GTLRMonitoring_AlertPolicy to include in the query.
 *  @param name Required if the policy exists. The resource name for this
 *    policy. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
 *    [ALERT_POLICY_ID] is assigned by Stackdriver Monitoring when the policy is
 *    created. When calling the alertPolicies.create method, do not include the
 *    name field in the alerting policy passed as part of the request.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_AlertPolicy *)object
                           name:(NSString *)name;

@end

/**
 *  Stackdriver Monitoring Agent only: Creates a new time
 *  series.<aside class="caution">This method is only for use by the Stackdriver
 *  Monitoring Agent. Use projects.timeSeries.create instead.</aside>
 *
 *  Method: monitoring.projects.collectdTimeSeries.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsCollectdTimeSeriesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsCollectdTimeSeriesCreateWithObject:name:]

/**
 *  The project in which to create the time series. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_CreateCollectdTimeSeriesResponse.
 *
 *  Stackdriver Monitoring Agent only: Creates a new time
 *  series.<aside class="caution">This method is only for use by the Stackdriver
 *  Monitoring Agent. Use projects.timeSeries.create instead.</aside>
 *
 *  @param object The @c GTLRMonitoring_CreateCollectdTimeSeriesRequest to
 *    include in the query.
 *  @param name The project in which to create the time series. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsCollectdTimeSeriesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_CreateCollectdTimeSeriesRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new group.
 *
 *  Method: monitoring.projects.groups.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsGroupsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsCreateWithObject:name:]

/**
 *  Required. The project in which to create the group. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/** If true, validate this request but do not create the group. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRMonitoring_Group.
 *
 *  Creates a new group.
 *
 *  @param object The @c GTLRMonitoring_Group to include in the query.
 *  @param name Required. The project in which to create the group. The format
 *    is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_Group *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes an existing group.
 *
 *  Method: monitoring.projects.groups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsGroupsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsDeleteWithname:]

/**
 *  Required. The group to delete. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If this field is true, then the request means to delete a group with all its
 *  descendants. Otherwise, the request means to delete a group only when it has
 *  no descendants. The default value is false.
 */
@property(nonatomic, assign) BOOL recursive;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes an existing group.
 *
 *  @param name Required. The group to delete. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single group.
 *
 *  Method: monitoring.projects.groups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsGroupsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsGetWithname:]

/**
 *  Required. The group to retrieve. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Group.
 *
 *  Gets a single group.
 *
 *  @param name Required. The group to retrieve. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the existing groups.
 *
 *  Method: monitoring.projects.groups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsGroupsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsListWithname:]

/**
 *  A group name. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *  Returns groups that are ancestors of the specified group. The groups are
 *  returned in order, starting with the immediate parent and ending with the
 *  most distant ancestor. If the specified group has no immediate parent, the
 *  results are empty.
 */
@property(nonatomic, copy, nullable) NSString *ancestorsOfGroup;

/**
 *  A group name. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *  Returns groups whose parent_name field contains the group name. If no groups
 *  have this parent, the results are empty.
 */
@property(nonatomic, copy, nullable) NSString *childrenOfGroup;

/**
 *  A group name. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *  Returns the descendants of the specified group. This is a superset of the
 *  results returned by the children_of_group filter, and includes
 *  children-of-children, and so forth.
 */
@property(nonatomic, copy, nullable) NSString *descendantsOfGroup;

/**
 *  Required. The project whose groups are to be listed. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the next_page_token value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListGroupsResponse.
 *
 *  Lists the existing groups.
 *
 *  @param name Required. The project whose groups are to be listed. The format
 *    is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the monitored resources that are members of a group.
 *
 *  Method: monitoring.projects.groups.members.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsGroupsMembersList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsMembersListWithname:]

/**
 *  An optional list filter
 *  (https://cloud.google.com/monitoring/api/learn_more#filtering) describing
 *  the members to be returned. The filter may reference the type, labels, and
 *  metadata of monitored resources that comprise the group. For example, to
 *  return only resources representing Compute Engine VM instances, use this
 *  filter:
 *  `resource.type = "gce_instance"`
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalEndTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalStartTime;

/**
 *  Required. The group whose members are listed. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the next_page_token value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListGroupMembersResponse.
 *
 *  Lists the monitored resources that are members of a group.
 *
 *  @param name Required. The group whose members are listed. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsMembersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Updates an existing group. You can change any group attributes except name.
 *
 *  Method: monitoring.projects.groups.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsGroupsUpdate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsUpdateWithObject:name:]

/**
 *  Output only. The name of this group. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *  When creating a group, this field is ignored and a new name is created
 *  consisting of the project specified in the call to CreateGroup and a unique
 *  [GROUP_ID] that is generated automatically.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** If true, validate this request but do not update the existing group. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRMonitoring_Group.
 *
 *  Updates an existing group. You can change any group attributes except name.
 *
 *  @param object The @c GTLRMonitoring_Group to include in the query.
 *  @param name Output only. The name of this group. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
 *    When creating a group, this field is ignored and a new name is created
 *    consisting of the project specified in the call to CreateGroup and a
 *    unique [GROUP_ID] that is generated automatically.
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsUpdate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_Group *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new metric descriptor. User-created metric descriptors define
 *  custom metrics (https://cloud.google.com/monitoring/custom-metrics).
 *
 *  Method: monitoring.projects.metricDescriptors.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsCreateWithObject:name:]

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_MetricDescriptor.
 *
 *  Creates a new metric descriptor. User-created metric descriptors define
 *  custom metrics (https://cloud.google.com/monitoring/custom-metrics).
 *
 *  @param object The @c GTLRMonitoring_MetricDescriptor to include in the
 *    query.
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_MetricDescriptor *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes a metric descriptor. Only user-created custom metrics
 *  (https://cloud.google.com/monitoring/custom-metrics) can be deleted.
 *
 *  Method: monitoring.projects.metricDescriptors.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsDeleteWithname:]

/**
 *  Required. The metric descriptor on which to execute the request. The format
 *  is:
 *  projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
 *  An example of [METRIC_ID] is: "custom.googleapis.com/my_test_metric".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes a metric descriptor. Only user-created custom metrics
 *  (https://cloud.google.com/monitoring/custom-metrics) can be deleted.
 *
 *  @param name Required. The metric descriptor on which to execute the request.
 *    The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
 *    An example of [METRIC_ID] is: "custom.googleapis.com/my_test_metric".
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single metric descriptor. This method does not require a Workspace.
 *
 *  Method: monitoring.projects.metricDescriptors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsGetWithname:]

/**
 *  Required. The metric descriptor on which to execute the request. The format
 *  is:
 *  projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
 *  An example value of [METRIC_ID] is
 *  "compute.googleapis.com/instance/disk/read_bytes_count".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_MetricDescriptor.
 *
 *  Gets a single metric descriptor. This method does not require a Workspace.
 *
 *  @param name Required. The metric descriptor on which to execute the request.
 *    The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
 *    An example value of [METRIC_ID] is
 *    "compute.googleapis.com/instance/disk/read_bytes_count".
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists metric descriptors that match a filter. This method does not require a
 *  Workspace.
 *
 *  Method: monitoring.projects.metricDescriptors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsListWithname:]

/**
 *  If this field is empty, all custom and system-defined metric descriptors are
 *  returned. Otherwise, the filter
 *  (https://cloud.google.com/monitoring/api/v3/filters) specifies which metric
 *  descriptors are to be returned. For example, the following filter matches
 *  all custom metrics (https://cloud.google.com/monitoring/custom-metrics):
 *  metric.type = starts_with("custom.googleapis.com/")
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListMetricDescriptorsResponse.
 *
 *  Lists metric descriptors that match a filter. This method does not require a
 *  Workspace.
 *
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single monitored resource descriptor. This method does not require a
 *  Workspace.
 *
 *  Method: monitoring.projects.monitoredResourceDescriptors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMonitoredResourceDescriptorsGetWithname:]

/**
 *  Required. The monitored resource descriptor to get. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE]
 *  The [RESOURCE_TYPE] is a predefined type, such as cloudsql_database.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_MonitoredResourceDescriptor.
 *
 *  Gets a single monitored resource descriptor. This method does not require a
 *  Workspace.
 *
 *  @param name Required. The monitored resource descriptor to get. The format
 *    is:
 *    projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE]
 *    The [RESOURCE_TYPE] is a predefined type, such as cloudsql_database.
 *
 *  @return GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists monitored resource descriptors that match a filter. This method does
 *  not require a Workspace.
 *
 *  Method: monitoring.projects.monitoredResourceDescriptors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMonitoredResourceDescriptorsListWithname:]

/**
 *  An optional filter (https://cloud.google.com/monitoring/api/v3/filters)
 *  describing the descriptors to be returned. The filter can reference the
 *  descriptor's type and labels. For example, the following filter returns only
 *  Google Compute Engine descriptors that have an id label:
 *  resource.type = starts_with("gce_") AND resource.label:id
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListMonitoredResourceDescriptorsResponse.
 *
 *  Lists monitored resource descriptors that match a filter. This method does
 *  not require a Workspace.
 *
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single channel descriptor. The descriptor indicates which fields are
 *  expected / permitted for a notification channel of the given type.
 *
 *  Method: monitoring.projects.notificationChannelDescriptors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelDescriptorsGetWithname:]

/**
 *  Required. The channel type for which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannelDescriptor.
 *
 *  Gets a single channel descriptor. The descriptor indicates which fields are
 *  expected / permitted for a notification channel of the given type.
 *
 *  @param name Required. The channel type for which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the descriptors for supported channel types. The use of descriptors
 *  makes it possible for new channel types to be dynamically added.
 *
 *  Method: monitoring.projects.notificationChannelDescriptors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelDescriptorsListWithname:]

/**
 *  Required. The REST resource name of the parent from which to retrieve the
 *  notification channel descriptors. The expected syntax is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 *  Note that this names the parent container in which to look for the
 *  descriptors; to retrieve a single descriptor by name, use the
 *  GetNotificationChannelDescriptor operation, instead.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The maximum number of results to return in a single response. If not set to
 *  a positive number, a reasonable value will be chosen by the service.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If non-empty, page_token must contain a value returned as the
 *  next_page_token in a previous response to request the next set of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListNotificationChannelDescriptorsResponse.
 *
 *  Lists the descriptors for supported channel types. The use of descriptors
 *  makes it possible for new channel types to be dynamically added.
 *
 *  @param name Required. The REST resource name of the parent from which to
 *    retrieve the notification channel descriptors. The expected syntax is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *    Note that this names the parent container in which to look for the
 *    descriptors; to retrieve a single descriptor by name, use the
 *    GetNotificationChannelDescriptor operation, instead.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Creates a new notification channel, representing a single notification
 *  endpoint such as an email address, SMS number, or PagerDuty service.
 *
 *  Method: monitoring.projects.notificationChannels.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsCreateWithObject:name:]

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 *  This names the container into which the channel will be written, this does
 *  not name the newly created channel. The resulting channel's name will have a
 *  normalized version of this field as a prefix, but will add
 *  /notificationChannels/[CHANNEL_ID] to identify the channel.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Creates a new notification channel, representing a single notification
 *  endpoint such as an email address, SMS number, or PagerDuty service.
 *
 *  @param object The @c GTLRMonitoring_NotificationChannel to include in the
 *    query.
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *    This names the container into which the channel will be written, this does
 *    not name the newly created channel. The resulting channel's name will have
 *    a normalized version of this field as a prefix, but will add
 *    /notificationChannels/[CHANNEL_ID] to identify the channel.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_NotificationChannel *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes a notification channel.
 *
 *  Method: monitoring.projects.notificationChannels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsDeleteWithname:]

/**
 *  If true, the notification channel will be deleted regardless of its use in
 *  alert policies (the policies will be updated to remove the channel). If
 *  false, channels that are still referenced by an existing alerting policy
 *  will fail to be deleted in a delete operation.
 */
@property(nonatomic, assign) BOOL force;

/**
 *  Required. The channel for which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes a notification channel.
 *
 *  @param name Required. The channel for which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single notification channel. The channel includes the relevant
 *  configuration details with which the channel was created. However, the
 *  response may truncate or omit passwords, API keys, or other private key
 *  matter and thus the response may not be 100% identical to the information
 *  that was supplied in the call to the create method.
 *
 *  Method: monitoring.projects.notificationChannels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsGetWithname:]

/**
 *  Required. The channel for which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Gets a single notification channel. The channel includes the relevant
 *  configuration details with which the channel was created. However, the
 *  response may truncate or omit passwords, API keys, or other private key
 *  matter and thus the response may not be 100% identical to the information
 *  that was supplied in the call to the create method.
 *
 *  @param name Required. The channel for which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Requests a verification code for an already verified channel that can then
 *  be used in a call to VerifyNotificationChannel() on a different channel with
 *  an equivalent identity in the same or in a different project. This makes it
 *  possible to copy a channel between projects without requiring manual
 *  reverification of the channel. If the channel is not in the verified state,
 *  this method will fail (in other words, this may only be used if the
 *  SendNotificationChannelVerificationCode and VerifyNotificationChannel paths
 *  have already been used to put the given channel into the verified
 *  state).There is no guarantee that the verification codes returned by this
 *  method will be of a similar structure or form as the ones that are delivered
 *  to the channel via SendNotificationChannelVerificationCode; while
 *  VerifyNotificationChannel() will recognize both the codes delivered via
 *  SendNotificationChannelVerificationCode() and returned from
 *  GetNotificationChannelVerificationCode(), it is typically the case that the
 *  verification codes delivered via SendNotificationChannelVerificationCode()
 *  will be shorter and also have a shorter expiration (e.g. codes such as
 *  "G-123456") whereas GetVerificationCode() will typically return a much
 *  longer, websafe base 64 encoded string that has a longer expiration time.
 *
 *  Method: monitoring.projects.notificationChannels.getVerificationCode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsGetVerificationCode : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsGetVerificationCodeWithObject:name:]

/**
 *  Required. The notification channel for which a verification code is to be
 *  generated and retrieved. This must name a channel that is already verified;
 *  if the specified channel is not verified, the request will fail.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_GetNotificationChannelVerificationCodeResponse.
 *
 *  Requests a verification code for an already verified channel that can then
 *  be used in a call to VerifyNotificationChannel() on a different channel with
 *  an equivalent identity in the same or in a different project. This makes it
 *  possible to copy a channel between projects without requiring manual
 *  reverification of the channel. If the channel is not in the verified state,
 *  this method will fail (in other words, this may only be used if the
 *  SendNotificationChannelVerificationCode and VerifyNotificationChannel paths
 *  have already been used to put the given channel into the verified
 *  state).There is no guarantee that the verification codes returned by this
 *  method will be of a similar structure or form as the ones that are delivered
 *  to the channel via SendNotificationChannelVerificationCode; while
 *  VerifyNotificationChannel() will recognize both the codes delivered via
 *  SendNotificationChannelVerificationCode() and returned from
 *  GetNotificationChannelVerificationCode(), it is typically the case that the
 *  verification codes delivered via SendNotificationChannelVerificationCode()
 *  will be shorter and also have a shorter expiration (e.g. codes such as
 *  "G-123456") whereas GetVerificationCode() will typically return a much
 *  longer, websafe base 64 encoded string that has a longer expiration time.
 *
 *  @param object The @c
 *    GTLRMonitoring_GetNotificationChannelVerificationCodeRequest to include in
 *    the query.
 *  @param name Required. The notification channel for which a verification code
 *    is to be generated and retrieved. This must name a channel that is already
 *    verified; if the specified channel is not verified, the request will fail.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsGetVerificationCode
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_GetNotificationChannelVerificationCodeRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Lists the notification channels that have been created for the project.
 *
 *  Method: monitoring.projects.notificationChannels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsListWithname:]

/**
 *  If provided, this field specifies the criteria that must be met by
 *  notification channels to be included in the response.For more details, see
 *  sorting and filtering
 *  (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 *  This names the container in which to look for the notification channels; it
 *  does not name a specific channel. To query a specific channel by REST
 *  resource name, use the GetNotificationChannel operation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A comma-separated list of fields by which to sort the result. Supports the
 *  same set of fields as in filter. Entries can be prefixed with a minus sign
 *  to sort in descending rather than ascending order.For more details, see
 *  sorting and filtering
 *  (https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  The maximum number of results to return in a single response. If not set to
 *  a positive number, a reasonable value will be chosen by the service.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If non-empty, page_token must contain a value returned as the
 *  next_page_token in a previous response to request the next set of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListNotificationChannelsResponse.
 *
 *  Lists the notification channels that have been created for the project.
 *
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *    This names the container in which to look for the notification channels;
 *    it does not name a specific channel. To query a specific channel by REST
 *    resource name, use the GetNotificationChannel operation.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Updates a notification channel. Fields not specified in the field mask
 *  remain unchanged.
 *
 *  Method: monitoring.projects.notificationChannels.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsPatchWithObject:name:]

/**
 *  The full REST resource name for this channel. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 *  The [CHANNEL_ID] is automatically assigned by the server on creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The fields to update.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Updates a notification channel. Fields not specified in the field mask
 *  remain unchanged.
 *
 *  @param object The @c GTLRMonitoring_NotificationChannel to include in the
 *    query.
 *  @param name The full REST resource name for this channel. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
 *    The [CHANNEL_ID] is automatically assigned by the server on creation.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_NotificationChannel *)object
                           name:(NSString *)name;

@end

/**
 *  Causes a verification code to be delivered to the channel. The code can then
 *  be supplied in VerifyNotificationChannel to verify the channel.
 *
 *  Method: monitoring.projects.notificationChannels.sendVerificationCode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsSendVerificationCode : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsSendVerificationCodeWithObject:name:]

/**
 *  Required. The notification channel to which to send a verification code.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Causes a verification code to be delivered to the channel. The code can then
 *  be supplied in VerifyNotificationChannel to verify the channel.
 *
 *  @param object The @c
 *    GTLRMonitoring_SendNotificationChannelVerificationCodeRequest to include
 *    in the query.
 *  @param name Required. The notification channel to which to send a
 *    verification code.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsSendVerificationCode
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_SendNotificationChannelVerificationCodeRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Verifies a NotificationChannel by proving receipt of the code delivered to
 *  the channel as a result of calling SendNotificationChannelVerificationCode.
 *
 *  Method: monitoring.projects.notificationChannels.verify
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsVerify : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsVerifyWithObject:name:]

/** Required. The notification channel to verify. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Verifies a NotificationChannel by proving receipt of the code delivered to
 *  the channel as a result of calling SendNotificationChannelVerificationCode.
 *
 *  @param object The @c GTLRMonitoring_VerifyNotificationChannelRequest to
 *    include in the query.
 *  @param name Required. The notification channel to verify.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsVerify
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_VerifyNotificationChannelRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Creates or adds data to one or more time series. The response is empty if
 *  all time series in the request were written. If any time series could not be
 *  written, a corresponding failure message is included in the error response.
 *
 *  Method: monitoring.projects.timeSeries.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsTimeSeriesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsTimeSeriesCreateWithObject:name:]

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Creates or adds data to one or more time series. The response is empty if
 *  all time series in the request were written. If any time series could not be
 *  written, a corresponding failure message is included in the error response.
 *
 *  @param object The @c GTLRMonitoring_CreateTimeSeriesRequest to include in
 *    the query.
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsTimeSeriesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_CreateTimeSeriesRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Lists time series that match a filter. This method does not require a
 *  Workspace.
 *
 *  Method: monitoring.projects.timeSeries.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsTimeSeriesList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsTimeSeriesListWithname:]

/**
 *  The alignment_period specifies a time interval, in seconds, that is used to
 *  divide the data in all the time series into consistent blocks of time. This
 *  will be done before the per-series aligner can be applied to the data.The
 *  value must be at least 60 seconds. If a per-series aligner other than
 *  ALIGN_NONE is specified, this field is required or an error is returned. If
 *  no per-series aligner is specified, or the aligner ALIGN_NONE is specified,
 *  then this field is ignored.
 */
@property(nonatomic, strong, nullable) GTLRDuration *aggregationAlignmentPeriod;

/**
 *  The reduction operation to be used to combine time series into a single time
 *  series, where the value of each data point in the resulting series is a
 *  function of all the already aligned values in the input time series.Not all
 *  reducer operations can be applied to all time series. The valid choices
 *  depend on the metric_kind and the value_type of the original time series.
 *  Reduction can yield a time series with a different metric_kind or value_type
 *  than the input time series.Time series data must first be aligned (see
 *  per_series_aligner) in order to perform cross-time series reduction. If
 *  cross_series_reducer is specified, then per_series_aligner must be
 *  specified, and must not be ALIGN_NONE. An alignment_period must also be
 *  specified; otherwise, an error is returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceNone Value
 *        "REDUCE_NONE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceMean Value
 *        "REDUCE_MEAN"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceMin Value
 *        "REDUCE_MIN"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceMax Value
 *        "REDUCE_MAX"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceSum Value
 *        "REDUCE_SUM"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceStddev Value
 *        "REDUCE_STDDEV"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceCount Value
 *        "REDUCE_COUNT"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceCountTrue Value
 *        "REDUCE_COUNT_TRUE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceCountFalse Value
 *        "REDUCE_COUNT_FALSE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceFractionTrue
 *        Value "REDUCE_FRACTION_TRUE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile99
 *        Value "REDUCE_PERCENTILE_99"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile95
 *        Value "REDUCE_PERCENTILE_95"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile50
 *        Value "REDUCE_PERCENTILE_50"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile05
 *        Value "REDUCE_PERCENTILE_05"
 */
@property(nonatomic, copy, nullable) NSString *aggregationCrossSeriesReducer;

/**
 *  The set of fields to preserve when cross_series_reducer is specified. The
 *  group_by_fields determine how the time series are partitioned into subsets
 *  prior to applying the aggregation operation. Each subset contains time
 *  series that have the same value for each of the grouping fields. Each
 *  individual time series is a member of exactly one subset. The
 *  cross_series_reducer is applied to each subset of time series. It is not
 *  possible to reduce across different resource types, so this field implicitly
 *  contains resource.type. Fields not specified in group_by_fields are
 *  aggregated away. If group_by_fields is not specified and all the time series
 *  have the same resource type, then the time series are aggregated into a
 *  single output time series. If cross_series_reducer is not defined, this
 *  field is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *aggregationGroupByFields;

/**
 *  An Aligner describes how to bring the data points in a single time series
 *  into temporal alignment. Except for ALIGN_NONE, all alignments cause all the
 *  data points in an alignment_period to be mathematically grouped together,
 *  resulting in a single data point for each alignment_period with end
 *  timestamp at the end of the period.Not all alignment operations may be
 *  applied to all time series. The valid choices depend on the metric_kind and
 *  value_type of the original time series. Alignment can change the metric_kind
 *  or the value_type of the time series.Time series data must be aligned in
 *  order to perform cross-time series reduction. If cross_series_reducer is
 *  specified, then per_series_aligner must be specified and not equal to
 *  ALIGN_NONE and alignment_period must be specified; otherwise, an error is
 *  returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignNone Value
 *        "ALIGN_NONE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignDelta Value
 *        "ALIGN_DELTA"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignRate Value
 *        "ALIGN_RATE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignInterpolate Value
 *        "ALIGN_INTERPOLATE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignNextOlder Value
 *        "ALIGN_NEXT_OLDER"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignMin Value
 *        "ALIGN_MIN"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignMax Value
 *        "ALIGN_MAX"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignMean Value
 *        "ALIGN_MEAN"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignCount Value
 *        "ALIGN_COUNT"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignSum Value
 *        "ALIGN_SUM"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignStddev Value
 *        "ALIGN_STDDEV"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignCountTrue Value
 *        "ALIGN_COUNT_TRUE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignCountFalse Value
 *        "ALIGN_COUNT_FALSE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignFractionTrue Value
 *        "ALIGN_FRACTION_TRUE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile99 Value
 *        "ALIGN_PERCENTILE_99"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile95 Value
 *        "ALIGN_PERCENTILE_95"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile50 Value
 *        "ALIGN_PERCENTILE_50"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile05 Value
 *        "ALIGN_PERCENTILE_05"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentChange Value
 *        "ALIGN_PERCENT_CHANGE"
 */
@property(nonatomic, copy, nullable) NSString *aggregationPerSeriesAligner;

/**
 *  Required. A monitoring filter
 *  (https://cloud.google.com/monitoring/api/v3/filters) that specifies which
 *  time series should be returned. The filter must specify a single metric
 *  type, and can additionally specify metric labels and other information. For
 *  example:
 *  metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
 *  metric.labels.instance_name = "my-instance-name"
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalEndTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalStartTime;

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Unsupported: must be left blank. The points in each time series are
 *  currently returned in reverse time order (most recent to oldest).
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  A positive number that is the maximum number of results to return. If
 *  page_size is empty or more than 100,000 results, the effective page_size is
 *  100,000 results. If view is set to FULL, this is the maximum number of
 *  Points returned. If view is set to HEADERS, this is the maximum number of
 *  TimeSeries returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Specifies which information is returned about the time series.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringViewFull Value "FULL"
 *    @arg @c kGTLRMonitoringViewHeaders Value "HEADERS"
 */
@property(nonatomic, copy, nullable) NSString *view;

/**
 *  Fetches a @c GTLRMonitoring_ListTimeSeriesResponse.
 *
 *  Lists time series that match a filter. This method does not require a
 *  Workspace.
 *
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsTimeSeriesList
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Queries time series using the time series query language. This method does
 *  not require a Workspace.
 *
 *  Method: monitoring.projects.timeSeries.query
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsTimeSeriesQuery : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsTimeSeriesQueryWithObject:name:]

/**
 *  Required. The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_QueryTimeSeriesResponse.
 *
 *  Queries time series using the time series query language. This method does
 *  not require a Workspace.
 *
 *  @param object The @c GTLRMonitoring_QueryTimeSeriesRequest to include in the
 *    query.
 *  @param name Required. The project on which to execute the request. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsTimeSeriesQuery
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_QueryTimeSeriesRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new Uptime check configuration.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsCreateWithObject:parent:]

/**
 *  Required. The project in which to create the Uptime check. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRMonitoring_UptimeCheckConfig.
 *
 *  Creates a new Uptime check configuration.
 *
 *  @param object The @c GTLRMonitoring_UptimeCheckConfig to include in the
 *    query.
 *  @param parent Required. The project in which to create the Uptime check. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_UptimeCheckConfig *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes an Uptime check configuration. Note that this method will fail if
 *  the Uptime check configuration is referenced by an alert policy or other
 *  dependent configs that would be rendered invalid by the deletion.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsDeleteWithname:]

/**
 *  Required. The Uptime check configuration to delete. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes an Uptime check configuration. Note that this method will fail if
 *  the Uptime check configuration is referenced by an alert policy or other
 *  dependent configs that would be rendered invalid by the deletion.
 *
 *  @param name Required. The Uptime check configuration to delete. The format
 *    is:
 *    projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single Uptime check configuration.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsGetWithname:]

/**
 *  Required. The Uptime check configuration to retrieve. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_UptimeCheckConfig.
 *
 *  Gets a single Uptime check configuration.
 *
 *  @param name Required. The Uptime check configuration to retrieve. The format
 *    is:
 *    projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the existing valid Uptime check configurations for the project
 *  (leaving out any invalid configurations).
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsListWithparent:]

/**
 *  The maximum number of results to return in a single response. The server may
 *  further constrain the maximum number of results returned in a single page.
 *  If the page_size is <=0, the server will decide the number of results to be
 *  returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return more results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. The project whose Uptime check configurations are listed. The
 *  format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRMonitoring_ListUptimeCheckConfigsResponse.
 *
 *  Lists the existing valid Uptime check configurations for the project
 *  (leaving out any invalid configurations).
 *
 *  @param parent Required. The project whose Uptime check configurations are
 *    listed. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates an Uptime check configuration. You can either replace the entire
 *  configuration with a new one or replace only certain fields in the current
 *  configuration by specifying the fields to be updated via updateMask. Returns
 *  the updated configuration.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsPatchWithObject:name:]

/**
 *  A unique resource name for this Uptime check configuration. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 *  This field should be omitted when creating the Uptime check configuration;
 *  on create, the resource name is assigned by the server and included in the
 *  response.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. If present, only the listed fields in the current Uptime check
 *  configuration are updated with values from the new configuration. If this
 *  field is empty, then the current configuration is completely replaced with
 *  the new configuration.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_UptimeCheckConfig.
 *
 *  Updates an Uptime check configuration. You can either replace the entire
 *  configuration with a new one or replace only certain fields in the current
 *  configuration by specifying the fields to be updated via updateMask. Returns
 *  the updated configuration.
 *
 *  @param object The @c GTLRMonitoring_UptimeCheckConfig to include in the
 *    query.
 *  @param name A unique resource name for this Uptime check configuration. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
 *    This field should be omitted when creating the Uptime check configuration;
 *    on create, the resource name is assigned by the server and included in the
 *    response.
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_UptimeCheckConfig *)object
                           name:(NSString *)name;

@end

/**
 *  Create a Service.
 *
 *  Method: monitoring.services.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ServicesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesCreateWithObject:parent:]

/**
 *  Required. Resource name of the parent workspace. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. The Service id to use for this Service. If omitted, an id will be
 *  generated instead. Must match the pattern [a-z0-9\\-]+
 */
@property(nonatomic, copy, nullable) NSString *serviceId;

/**
 *  Fetches a @c GTLRMonitoring_Service.
 *
 *  Create a Service.
 *
 *  @param object The @c GTLRMonitoring_Service to include in the query.
 *  @param parent Required. Resource name of the parent workspace. The format
 *    is:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ServicesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_Service *)object
                         parent:(NSString *)parent;

@end

/**
 *  Soft delete this Service.
 *
 *  Method: monitoring.services.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ServicesDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesDeleteWithname:]

/**
 *  Required. Resource name of the Service to delete. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Soft delete this Service.
 *
 *  @param name Required. Resource name of the Service to delete. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 *
 *  @return GTLRMonitoringQuery_ServicesDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get the named Service.
 *
 *  Method: monitoring.services.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ServicesGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesGetWithname:]

/**
 *  Required. Resource name of the Service. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Service.
 *
 *  Get the named Service.
 *
 *  @param name Required. Resource name of the Service. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 *
 *  @return GTLRMonitoringQuery_ServicesGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List Services for this workspace.
 *
 *  Method: monitoring.services.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ServicesList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesListWithparent:]

/**
 *  A filter specifying what Services to return. The filter currently supports
 *  the following fields:
 *  - `identifier_case`
 *  - `app_engine.module_id`
 *  - `cloud_endpoints.service`
 *  - `cluster_istio.location`
 *  - `cluster_istio.cluster_name`
 *  - `cluster_istio.service_namespace`
 *  - `cluster_istio.service_name`
 *  identifier_case refers to which option in the identifier oneof is populated.
 *  For example, the filter identifier_case = "CUSTOM" would match all services
 *  with a value for the custom field. Valid options are "CUSTOM", "APP_ENGINE",
 *  "CLOUD_ENDPOINTS", and "CLUSTER_ISTIO".
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  A non-negative number that is the maximum number of results to return. When
 *  0, use default page size.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Resource name of the parent containing the listed services, either
 *  a project or a Monitoring Workspace. The formats are:
 *  projects/[PROJECT_ID_OR_NUMBER]
 *  workspaces/[HOST_PROJECT_ID_OR_NUMBER]
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRMonitoring_ListServicesResponse.
 *
 *  List Services for this workspace.
 *
 *  @param parent Required. Resource name of the parent containing the listed
 *    services, either a project or a Monitoring Workspace. The formats are:
 *    projects/[PROJECT_ID_OR_NUMBER]
 *    workspaces/[HOST_PROJECT_ID_OR_NUMBER]
 *
 *  @return GTLRMonitoringQuery_ServicesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Update this Service.
 *
 *  Method: monitoring.services.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ServicesPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesPatchWithObject:name:]

/**
 *  Resource name for this Service. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A set of field paths defining which fields to use for the update.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_Service.
 *
 *  Update this Service.
 *
 *  @param object The @c GTLRMonitoring_Service to include in the query.
 *  @param name Resource name for this Service. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 *
 *  @return GTLRMonitoringQuery_ServicesPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_Service *)object
                           name:(NSString *)name;

@end

/**
 *  Create a ServiceLevelObjective for the given Service.
 *
 *  Method: monitoring.services.serviceLevelObjectives.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ServicesServiceLevelObjectivesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesServiceLevelObjectivesCreateWithObject:parent:]

/**
 *  Required. Resource name of the parent Service. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Optional. The ServiceLevelObjective id to use for this
 *  ServiceLevelObjective. If omitted, an id will be generated instead. Must
 *  match the pattern [a-z0-9\\-]+
 */
@property(nonatomic, copy, nullable) NSString *serviceLevelObjectiveId;

/**
 *  Fetches a @c GTLRMonitoring_ServiceLevelObjective.
 *
 *  Create a ServiceLevelObjective for the given Service.
 *
 *  @param object The @c GTLRMonitoring_ServiceLevelObjective to include in the
 *    query.
 *  @param parent Required. Resource name of the parent Service. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 *
 *  @return GTLRMonitoringQuery_ServicesServiceLevelObjectivesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_ServiceLevelObjective *)object
                         parent:(NSString *)parent;

@end

/**
 *  Delete the given ServiceLevelObjective.
 *
 *  Method: monitoring.services.serviceLevelObjectives.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ServicesServiceLevelObjectivesDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesServiceLevelObjectivesDeleteWithname:]

/**
 *  Required. Resource name of the ServiceLevelObjective to delete. The format
 *  is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Delete the given ServiceLevelObjective.
 *
 *  @param name Required. Resource name of the ServiceLevelObjective to delete.
 *    The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 *
 *  @return GTLRMonitoringQuery_ServicesServiceLevelObjectivesDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get a ServiceLevelObjective by name.
 *
 *  Method: monitoring.services.serviceLevelObjectives.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ServicesServiceLevelObjectivesGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesServiceLevelObjectivesGetWithname:]

/**
 *  Required. Resource name of the ServiceLevelObjective to get. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  View of the ServiceLevelObjective to return. If DEFAULT, return the
 *  ServiceLevelObjective as originally defined. If EXPLICIT and the
 *  ServiceLevelObjective is defined in terms of a BasicSli, replace the
 *  BasicSli with a RequestBasedSli spelling out how the SLI is computed.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringViewViewUnspecified Value "VIEW_UNSPECIFIED"
 *    @arg @c kGTLRMonitoringViewFull Value "FULL"
 *    @arg @c kGTLRMonitoringViewExplicit Value "EXPLICIT"
 */
@property(nonatomic, copy, nullable) NSString *view;

/**
 *  Fetches a @c GTLRMonitoring_ServiceLevelObjective.
 *
 *  Get a ServiceLevelObjective by name.
 *
 *  @param name Required. Resource name of the ServiceLevelObjective to get. The
 *    format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 *
 *  @return GTLRMonitoringQuery_ServicesServiceLevelObjectivesGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List the ServiceLevelObjectives for the given Service.
 *
 *  Method: monitoring.services.serviceLevelObjectives.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ServicesServiceLevelObjectivesList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesServiceLevelObjectivesListWithparent:]

/** A filter specifying what ServiceLevelObjectives to return. */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  A non-negative number that is the maximum number of results to return. When
 *  0, use default page size.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Resource name of the parent containing the listed SLOs, either a
 *  project or a Monitoring Workspace. The formats are:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 *  workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  View of the ServiceLevelObjectives to return. If DEFAULT, return each
 *  ServiceLevelObjective as originally defined. If EXPLICIT and the
 *  ServiceLevelObjective is defined in terms of a BasicSli, replace the
 *  BasicSli with a RequestBasedSli spelling out how the SLI is computed.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringViewViewUnspecified Value "VIEW_UNSPECIFIED"
 *    @arg @c kGTLRMonitoringViewFull Value "FULL"
 *    @arg @c kGTLRMonitoringViewExplicit Value "EXPLICIT"
 */
@property(nonatomic, copy, nullable) NSString *view;

/**
 *  Fetches a @c GTLRMonitoring_ListServiceLevelObjectivesResponse.
 *
 *  List the ServiceLevelObjectives for the given Service.
 *
 *  @param parent Required. Resource name of the parent containing the listed
 *    SLOs, either a project or a Monitoring Workspace. The formats are:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
 *    workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-
 *
 *  @return GTLRMonitoringQuery_ServicesServiceLevelObjectivesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Update the given ServiceLevelObjective.
 *
 *  Method: monitoring.services.serviceLevelObjectives.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ServicesServiceLevelObjectivesPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForServicesServiceLevelObjectivesPatchWithObject:name:]

/**
 *  Resource name for this ServiceLevelObjective. The format is:
 *  projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A set of field paths defining which fields to use for the update.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_ServiceLevelObjective.
 *
 *  Update the given ServiceLevelObjective.
 *
 *  @param object The @c GTLRMonitoring_ServiceLevelObjective to include in the
 *    query.
 *  @param name Resource name for this ServiceLevelObjective. The format is:
 *    projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
 *
 *  @return GTLRMonitoringQuery_ServicesServiceLevelObjectivesPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_ServiceLevelObjective *)object
                           name:(NSString *)name;

@end

/**
 *  Returns the list of IP addresses that checkers run from
 *
 *  Method: monitoring.uptimeCheckIps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_UptimeCheckIpsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForUptimeCheckIpsList]

/**
 *  The maximum number of results to return in a single response. The server may
 *  further constrain the maximum number of results returned in a single page.
 *  If the page_size is <=0, the server will decide the number of results to be
 *  returned. NOTE: this field is not yet implemented
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return more results from the previous method call. NOTE: this
 *  field is not yet implemented
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListUptimeCheckIpsResponse.
 *
 *  Returns the list of IP addresses that checkers run from
 *
 *  @return GTLRMonitoringQuery_UptimeCheckIpsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)query;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
