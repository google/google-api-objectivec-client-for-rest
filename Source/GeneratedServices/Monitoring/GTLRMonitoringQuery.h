// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Stackdriver Monitoring API (monitoring/v3)
// Description:
//   Manages your Stackdriver Monitoring data and configurations. Most projects
//   must be associated with a Stackdriver account, with a few exceptions as
//   noted on the individual method pages.
// Documentation:
//   https://cloud.google.com/monitoring/api/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRQuery.h"
#else
  #import "GTLRQuery.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRMonitoring_AlertPolicy;
@class GTLRMonitoring_CreateCollectdTimeSeriesRequest;
@class GTLRMonitoring_CreateTimeSeriesRequest;
@class GTLRMonitoring_GetNotificationChannelVerificationCodeRequest;
@class GTLRMonitoring_Group;
@class GTLRMonitoring_MetricDescriptor;
@class GTLRMonitoring_NotificationChannel;
@class GTLRMonitoring_SendNotificationChannelVerificationCodeRequest;
@class GTLRMonitoring_UptimeCheckConfig;
@class GTLRMonitoring_VerifyNotificationChannelRequest;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the query classes' properties below.

// ----------------------------------------------------------------------------
// aggregationCrossSeriesReducer

/** Value: "REDUCE_COUNT" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceCount;
/** Value: "REDUCE_COUNT_FALSE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceCountFalse;
/** Value: "REDUCE_COUNT_TRUE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceCountTrue;
/** Value: "REDUCE_FRACTION_TRUE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceFractionTrue;
/** Value: "REDUCE_MAX" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceMax;
/** Value: "REDUCE_MEAN" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceMean;
/** Value: "REDUCE_MIN" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceMin;
/** Value: "REDUCE_NONE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceNone;
/** Value: "REDUCE_PERCENTILE_05" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile05;
/** Value: "REDUCE_PERCENTILE_50" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile50;
/** Value: "REDUCE_PERCENTILE_95" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile95;
/** Value: "REDUCE_PERCENTILE_99" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile99;
/** Value: "REDUCE_STDDEV" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceStddev;
/** Value: "REDUCE_SUM" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationCrossSeriesReducerReduceSum;

// ----------------------------------------------------------------------------
// aggregationPerSeriesAligner

/** Value: "ALIGN_COUNT" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignCount;
/** Value: "ALIGN_COUNT_FALSE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignCountFalse;
/** Value: "ALIGN_COUNT_TRUE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignCountTrue;
/** Value: "ALIGN_DELTA" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignDelta;
/** Value: "ALIGN_FRACTION_TRUE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignFractionTrue;
/** Value: "ALIGN_INTERPOLATE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignInterpolate;
/** Value: "ALIGN_MAX" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignMax;
/** Value: "ALIGN_MEAN" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignMean;
/** Value: "ALIGN_MIN" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignMin;
/** Value: "ALIGN_NEXT_OLDER" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignNextOlder;
/** Value: "ALIGN_NONE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignNone;
/** Value: "ALIGN_PERCENT_CHANGE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentChange;
/** Value: "ALIGN_PERCENTILE_05" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile05;
/** Value: "ALIGN_PERCENTILE_50" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile50;
/** Value: "ALIGN_PERCENTILE_95" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile95;
/** Value: "ALIGN_PERCENTILE_99" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile99;
/** Value: "ALIGN_RATE" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignRate;
/** Value: "ALIGN_STDDEV" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignStddev;
/** Value: "ALIGN_SUM" */
GTLR_EXTERN NSString * const kGTLRMonitoringAggregationPerSeriesAlignerAlignSum;

// ----------------------------------------------------------------------------
// view

/** Value: "FULL" */
GTLR_EXTERN NSString * const kGTLRMonitoringViewFull;
/** Value: "HEADERS" */
GTLR_EXTERN NSString * const kGTLRMonitoringViewHeaders;

// ----------------------------------------------------------------------------
// Query Classes
//

/**
 *  Parent class for other Monitoring query classes.
 */
@interface GTLRMonitoringQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Creates a new alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesCreateWithObject:name:]

/**
 *  The project in which to create the alerting policy. The format is
 *  projects/[PROJECT_ID].Note that this field names the parent container in
 *  which the alerting policy will be written, not the name of the created
 *  policy. The alerting policy that is returned will have a name that contains
 *  a normalized representation of this name as a prefix but adds a suffix of
 *  the form /alertPolicies/[POLICY_ID], identifying the policy in the
 *  container.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_AlertPolicy.
 *
 *  Creates a new alerting policy.
 *
 *  @param object The @c GTLRMonitoring_AlertPolicy to include in the query.
 *  @param name The project in which to create the alerting policy. The format
 *    is projects/[PROJECT_ID].Note that this field names the parent container
 *    in which the alerting policy will be written, not the name of the created
 *    policy. The alerting policy that is returned will have a name that
 *    contains a normalized representation of this name as a prefix but adds a
 *    suffix of the form /alertPolicies/[POLICY_ID], identifying the policy in
 *    the container.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_AlertPolicy *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes an alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesDeleteWithname:]

/**
 *  The alerting policy to delete. The format is:
 *  projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 *  For more information, see AlertPolicy.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes an alerting policy.
 *
 *  @param name The alerting policy to delete. The format is:
 *    projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 *    For more information, see AlertPolicy.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesGetWithname:]

/**
 *  The alerting policy to retrieve. The format is
 *  projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_AlertPolicy.
 *
 *  Gets a single alerting policy.
 *
 *  @param name The alerting policy to retrieve. The format is
 *    projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the existing alerting policies for the project.
 *
 *  Method: monitoring.projects.alertPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesListWithname:]

/**
 *  If provided, this field specifies the criteria that must be met by alert
 *  policies to be included in the response.For more details, see sorting and
 *  filtering.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The project whose alert policies are to be listed. The format is
 *  projects/[PROJECT_ID]
 *  Note that this field names the parent container in which the alerting
 *  policies to be listed are stored. To retrieve a single alerting policy by
 *  name, use the GetAlertPolicy operation, instead.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A comma-separated list of fields by which to sort the result. Supports the
 *  same set of field references as the filter field. Entries can be prefixed
 *  with a minus sign to sort by the field in descending order.For more details,
 *  see sorting and filtering.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/** The maximum number of results to return in a single response. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return more results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListAlertPoliciesResponse.
 *
 *  Lists the existing alerting policies for the project.
 *
 *  @param name The project whose alert policies are to be listed. The format is
 *    projects/[PROJECT_ID]
 *    Note that this field names the parent container in which the alerting
 *    policies to be listed are stored. To retrieve a single alerting policy by
 *    name, use the GetAlertPolicy operation, instead.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Updates an alerting policy. You can either replace the entire policy with a
 *  new one or replace only certain fields in the current alerting policy by
 *  specifying the fields to be updated via updateMask. Returns the updated
 *  alerting policy.
 *
 *  Method: monitoring.projects.alertPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsAlertPoliciesPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsAlertPoliciesPatchWithObject:name:]

/**
 *  Required if the policy exists. The resource name for this policy. The syntax
 *  is:
 *  projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 *  [ALERT_POLICY_ID] is assigned by Stackdriver Monitoring when the policy is
 *  created. When calling the alertPolicies.create method, do not include the
 *  name field in the alerting policy passed as part of the request.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. A list of alerting policy field names. If this field is not empty,
 *  each listed field in the existing alerting policy is set to the value of the
 *  corresponding field in the supplied policy (alert_policy), or to the field's
 *  default value if the field is not in the supplied alerting policy. Fields
 *  not listed retain their previous value.Examples of valid field masks include
 *  display_name, documentation, documentation.content, documentation.mime_type,
 *  user_labels, user_label.nameofkey, enabled, conditions, combiner, etc.If
 *  this field is empty, then the supplied alerting policy replaces the existing
 *  policy. It is the same as deleting the existing policy and adding the
 *  supplied policy, except for the following:
 *  The new policy will have the same [ALERT_POLICY_ID] as the former policy.
 *  This gives you continuity with the former policy in your notifications and
 *  incidents.
 *  Conditions in the new policy will keep their former [CONDITION_ID] if the
 *  supplied condition includes the name field with that [CONDITION_ID]. If the
 *  supplied condition omits the name field, then a new [CONDITION_ID] is
 *  created.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_AlertPolicy.
 *
 *  Updates an alerting policy. You can either replace the entire policy with a
 *  new one or replace only certain fields in the current alerting policy by
 *  specifying the fields to be updated via updateMask. Returns the updated
 *  alerting policy.
 *
 *  @param object The @c GTLRMonitoring_AlertPolicy to include in the query.
 *  @param name Required if the policy exists. The resource name for this
 *    policy. The syntax is:
 *    projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
 *    [ALERT_POLICY_ID] is assigned by Stackdriver Monitoring when the policy is
 *    created. When calling the alertPolicies.create method, do not include the
 *    name field in the alerting policy passed as part of the request.
 *
 *  @return GTLRMonitoringQuery_ProjectsAlertPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_AlertPolicy *)object
                           name:(NSString *)name;

@end

/**
 *  Stackdriver Monitoring Agent only: Creates a new time
 *  series.<aside class="caution">This method is only for use by the Stackdriver
 *  Monitoring Agent. Use projects.timeSeries.create instead.</aside>
 *
 *  Method: monitoring.projects.collectdTimeSeries.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsCollectdTimeSeriesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsCollectdTimeSeriesCreateWithObject:name:]

/**
 *  The project in which to create the time series. The format is
 *  "projects/PROJECT_ID_OR_NUMBER".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_CreateCollectdTimeSeriesResponse.
 *
 *  Stackdriver Monitoring Agent only: Creates a new time
 *  series.<aside class="caution">This method is only for use by the Stackdriver
 *  Monitoring Agent. Use projects.timeSeries.create instead.</aside>
 *
 *  @param object The @c GTLRMonitoring_CreateCollectdTimeSeriesRequest to
 *    include in the query.
 *  @param name The project in which to create the time series. The format is
 *    "projects/PROJECT_ID_OR_NUMBER".
 *
 *  @return GTLRMonitoringQuery_ProjectsCollectdTimeSeriesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_CreateCollectdTimeSeriesRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new group.
 *
 *  Method: monitoring.projects.groups.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsGroupsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsCreateWithObject:name:]

/**
 *  The project in which to create the group. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** If true, validate this request but do not create the group. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRMonitoring_Group.
 *
 *  Creates a new group.
 *
 *  @param object The @c GTLRMonitoring_Group to include in the query.
 *  @param name The project in which to create the group. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_Group *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes an existing group.
 *
 *  Method: monitoring.projects.groups.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsGroupsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsDeleteWithname:]

/**
 *  The group to delete. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes an existing group.
 *
 *  @param name The group to delete. The format is
 *    "projects/{project_id_or_number}/groups/{group_id}".
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single group.
 *
 *  Method: monitoring.projects.groups.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsGroupsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsGetWithname:]

/**
 *  The group to retrieve. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Group.
 *
 *  Gets a single group.
 *
 *  @param name The group to retrieve. The format is
 *    "projects/{project_id_or_number}/groups/{group_id}".
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the existing groups.
 *
 *  Method: monitoring.projects.groups.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsGroupsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsListWithname:]

/**
 *  A group name: "projects/{project_id_or_number}/groups/{group_id}". Returns
 *  groups that are ancestors of the specified group. The groups are returned in
 *  order, starting with the immediate parent and ending with the most distant
 *  ancestor. If the specified group has no immediate parent, the results are
 *  empty.
 */
@property(nonatomic, copy, nullable) NSString *ancestorsOfGroup;

/**
 *  A group name: "projects/{project_id_or_number}/groups/{group_id}". Returns
 *  groups whose parentName field contains the group name. If no groups have
 *  this parent, the results are empty.
 */
@property(nonatomic, copy, nullable) NSString *childrenOfGroup;

/**
 *  A group name: "projects/{project_id_or_number}/groups/{group_id}". Returns
 *  the descendants of the specified group. This is a superset of the results
 *  returned by the childrenOfGroup filter, and includes children-of-children,
 *  and so forth.
 */
@property(nonatomic, copy, nullable) NSString *descendantsOfGroup;

/**
 *  The project whose groups are to be listed. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListGroupsResponse.
 *
 *  Lists the existing groups.
 *
 *  @param name The project whose groups are to be listed. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the monitored resources that are members of a group.
 *
 *  Method: monitoring.projects.groups.members.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsGroupsMembersList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsMembersListWithname:]

/**
 *  An optional list filter describing the members to be returned. The filter
 *  may reference the type, labels, and metadata of monitored resources that
 *  comprise the group. For example, to return only resources representing
 *  Compute Engine VM instances, use this filter:
 *  resource.type = "gce_instance"
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalEndTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalStartTime;

/**
 *  The group whose members are listed. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListGroupMembersResponse.
 *
 *  Lists the monitored resources that are members of a group.
 *
 *  @param name The group whose members are listed. The format is
 *    "projects/{project_id_or_number}/groups/{group_id}".
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsMembersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Updates an existing group. You can change any group attributes except name.
 *
 *  Method: monitoring.projects.groups.update
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsGroupsUpdate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsGroupsUpdateWithObject:name:]

/**
 *  Output only. The name of this group. The format is
 *  "projects/{project_id_or_number}/groups/{group_id}". When creating a group,
 *  this field is ignored and a new name is created consisting of the project
 *  specified in the call to CreateGroup and a unique {group_id} that is
 *  generated automatically.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** If true, validate this request but do not update the existing group. */
@property(nonatomic, assign) BOOL validateOnly;

/**
 *  Fetches a @c GTLRMonitoring_Group.
 *
 *  Updates an existing group. You can change any group attributes except name.
 *
 *  @param object The @c GTLRMonitoring_Group to include in the query.
 *  @param name Output only. The name of this group. The format is
 *    "projects/{project_id_or_number}/groups/{group_id}". When creating a
 *    group, this field is ignored and a new name is created consisting of the
 *    project specified in the call to CreateGroup and a unique {group_id} that
 *    is generated automatically.
 *
 *  @return GTLRMonitoringQuery_ProjectsGroupsUpdate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_Group *)object
                           name:(NSString *)name;

@end

/**
 *  Creates a new metric descriptor. User-created metric descriptors define
 *  custom metrics.
 *
 *  Method: monitoring.projects.metricDescriptors.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsCreateWithObject:name:]

/**
 *  The project on which to execute the request. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_MetricDescriptor.
 *
 *  Creates a new metric descriptor. User-created metric descriptors define
 *  custom metrics.
 *
 *  @param object The @c GTLRMonitoring_MetricDescriptor to include in the
 *    query.
 *  @param name The project on which to execute the request. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_MetricDescriptor *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes a metric descriptor. Only user-created custom metrics can be
 *  deleted.
 *
 *  Method: monitoring.projects.metricDescriptors.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsDeleteWithname:]

/**
 *  The metric descriptor on which to execute the request. The format is
 *  "projects/{project_id_or_number}/metricDescriptors/{metric_id}". An example
 *  of {metric_id} is: "custom.googleapis.com/my_test_metric".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes a metric descriptor. Only user-created custom metrics can be
 *  deleted.
 *
 *  @param name The metric descriptor on which to execute the request. The
 *    format is "projects/{project_id_or_number}/metricDescriptors/{metric_id}".
 *    An example of {metric_id} is: "custom.googleapis.com/my_test_metric".
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single metric descriptor. This method does not require a Stackdriver
 *  account.
 *
 *  Method: monitoring.projects.metricDescriptors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsGetWithname:]

/**
 *  The metric descriptor on which to execute the request. The format is
 *  "projects/{project_id_or_number}/metricDescriptors/{metric_id}". An example
 *  value of {metric_id} is
 *  "compute.googleapis.com/instance/disk/read_bytes_count".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_MetricDescriptor.
 *
 *  Gets a single metric descriptor. This method does not require a Stackdriver
 *  account.
 *
 *  @param name The metric descriptor on which to execute the request. The
 *    format is "projects/{project_id_or_number}/metricDescriptors/{metric_id}".
 *    An example value of {metric_id} is
 *    "compute.googleapis.com/instance/disk/read_bytes_count".
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists metric descriptors that match a filter. This method does not require a
 *  Stackdriver account.
 *
 *  Method: monitoring.projects.metricDescriptors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMetricDescriptorsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMetricDescriptorsListWithname:]

/**
 *  If this field is empty, all custom and system-defined metric descriptors are
 *  returned. Otherwise, the filter specifies which metric descriptors are to be
 *  returned. For example, the following filter matches all custom metrics:
 *  metric.type = starts_with("custom.googleapis.com/")
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The project on which to execute the request. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListMetricDescriptorsResponse.
 *
 *  Lists metric descriptors that match a filter. This method does not require a
 *  Stackdriver account.
 *
 *  @param name The project on which to execute the request. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsMetricDescriptorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single monitored resource descriptor. This method does not require a
 *  Stackdriver account.
 *
 *  Method: monitoring.projects.monitoredResourceDescriptors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMonitoredResourceDescriptorsGetWithname:]

/**
 *  The monitored resource descriptor to get. The format is
 *  "projects/{project_id_or_number}/monitoredResourceDescriptors/{resource_type}".
 *  The {resource_type} is a predefined type, such as cloudsql_database.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_MonitoredResourceDescriptor.
 *
 *  Gets a single monitored resource descriptor. This method does not require a
 *  Stackdriver account.
 *
 *  @param name The monitored resource descriptor to get. The format is
 *    "projects/{project_id_or_number}/monitoredResourceDescriptors/{resource_type}".
 *    The {resource_type} is a predefined type, such as cloudsql_database.
 *
 *  @return GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists monitored resource descriptors that match a filter. This method does
 *  not require a Stackdriver account.
 *
 *  Method: monitoring.projects.monitoredResourceDescriptors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsMonitoredResourceDescriptorsListWithname:]

/**
 *  An optional filter describing the descriptors to be returned. The filter can
 *  reference the descriptor's type and labels. For example, the following
 *  filter returns only Google Compute Engine descriptors that have an id label:
 *  resource.type = starts_with("gce_") AND resource.label:id
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The project on which to execute the request. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/** A positive number that is the maximum number of results to return. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListMonitoredResourceDescriptorsResponse.
 *
 *  Lists monitored resource descriptors that match a filter. This method does
 *  not require a Stackdriver account.
 *
 *  @param name The project on which to execute the request. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsMonitoredResourceDescriptorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single channel descriptor. The descriptor indicates which fields are
 *  expected / permitted for a notification channel of the given type.
 *
 *  Method: monitoring.projects.notificationChannelDescriptors.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelDescriptorsGetWithname:]

/**
 *  The channel type for which to execute the request. The format is
 *  projects/[PROJECT_ID]/notificationChannelDescriptors/{channel_type}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannelDescriptor.
 *
 *  Gets a single channel descriptor. The descriptor indicates which fields are
 *  expected / permitted for a notification channel of the given type.
 *
 *  @param name The channel type for which to execute the request. The format is
 *    projects/[PROJECT_ID]/notificationChannelDescriptors/{channel_type}.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the descriptors for supported channel types. The use of descriptors
 *  makes it possible for new channel types to be dynamically added.
 *
 *  Method: monitoring.projects.notificationChannelDescriptors.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelDescriptorsListWithname:]

/**
 *  The REST resource name of the parent from which to retrieve the notification
 *  channel descriptors. The expected syntax is:
 *  projects/[PROJECT_ID]
 *  Note that this names the parent container in which to look for the
 *  descriptors; to retrieve a single descriptor by name, use the
 *  GetNotificationChannelDescriptor operation, instead.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The maximum number of results to return in a single response. If not set to
 *  a positive number, a reasonable value will be chosen by the service.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If non-empty, page_token must contain a value returned as the
 *  next_page_token in a previous response to request the next set of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListNotificationChannelDescriptorsResponse.
 *
 *  Lists the descriptors for supported channel types. The use of descriptors
 *  makes it possible for new channel types to be dynamically added.
 *
 *  @param name The REST resource name of the parent from which to retrieve the
 *    notification channel descriptors. The expected syntax is:
 *    projects/[PROJECT_ID]
 *    Note that this names the parent container in which to look for the
 *    descriptors; to retrieve a single descriptor by name, use the
 *    GetNotificationChannelDescriptor operation, instead.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelDescriptorsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Creates a new notification channel, representing a single notification
 *  endpoint such as an email address, SMS number, or PagerDuty service.
 *
 *  Method: monitoring.projects.notificationChannels.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsCreateWithObject:name:]

/**
 *  The project on which to execute the request. The format is:
 *  projects/[PROJECT_ID]
 *  Note that this names the container into which the channel will be written.
 *  This does not name the newly created channel. The resulting channel's name
 *  will have a normalized version of this field as a prefix, but will add
 *  /notificationChannels/[CHANNEL_ID] to identify the channel.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Creates a new notification channel, representing a single notification
 *  endpoint such as an email address, SMS number, or PagerDuty service.
 *
 *  @param object The @c GTLRMonitoring_NotificationChannel to include in the
 *    query.
 *  @param name The project on which to execute the request. The format is:
 *    projects/[PROJECT_ID]
 *    Note that this names the container into which the channel will be written.
 *    This does not name the newly created channel. The resulting channel's name
 *    will have a normalized version of this field as a prefix, but will add
 *    /notificationChannels/[CHANNEL_ID] to identify the channel.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_NotificationChannel *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes a notification channel.
 *
 *  Method: monitoring.projects.notificationChannels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsDeleteWithname:]

/**
 *  If true, the notification channel will be deleted regardless of its use in
 *  alert policies (the policies will be updated to remove the channel). If
 *  false, channels that are still referenced by an existing alerting policy
 *  will fail to be deleted in a delete operation.
 */
@property(nonatomic, assign) BOOL force;

/**
 *  The channel for which to execute the request. The format is
 *  projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID].
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes a notification channel.
 *
 *  @param name The channel for which to execute the request. The format is
 *    projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID].
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single notification channel. The channel includes the relevant
 *  configuration details with which the channel was created. However, the
 *  response may truncate or omit passwords, API keys, or other private key
 *  matter and thus the response may not be 100% identical to the information
 *  that was supplied in the call to the create method.
 *
 *  Method: monitoring.projects.notificationChannels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsGetWithname:]

/**
 *  The channel for which to execute the request. The format is
 *  projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID].
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Gets a single notification channel. The channel includes the relevant
 *  configuration details with which the channel was created. However, the
 *  response may truncate or omit passwords, API keys, or other private key
 *  matter and thus the response may not be 100% identical to the information
 *  that was supplied in the call to the create method.
 *
 *  @param name The channel for which to execute the request. The format is
 *    projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID].
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Requests a verification code for an already verified channel that can then
 *  be used in a call to VerifyNotificationChannel() on a different channel with
 *  an equivalent identity in the same or in a different project. This makes it
 *  possible to copy a channel between projects without requiring manual
 *  reverification of the channel. If the channel is not in the verified state,
 *  this method will fail (in other words, this may only be used if the
 *  SendNotificationChannelVerificationCode and VerifyNotificationChannel paths
 *  have already been used to put the given channel into the verified
 *  state).There is no guarantee that the verification codes returned by this
 *  method will be of a similar structure or form as the ones that are delivered
 *  to the channel via SendNotificationChannelVerificationCode; while
 *  VerifyNotificationChannel() will recognize both the codes delivered via
 *  SendNotificationChannelVerificationCode() and returned from
 *  GetNotificationChannelVerificationCode(), it is typically the case that the
 *  verification codes delivered via SendNotificationChannelVerificationCode()
 *  will be shorter and also have a shorter expiration (e.g. codes such as
 *  "G-123456") whereas GetVerificationCode() will typically return a much
 *  longer, websafe base 64 encoded string that has a longer expiration time.
 *
 *  Method: monitoring.projects.notificationChannels.getVerificationCode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsGetVerificationCode : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsGetVerificationCodeWithObject:name:]

/**
 *  The notification channel for which a verification code is to be generated
 *  and retrieved. This must name a channel that is already verified; if the
 *  specified channel is not verified, the request will fail.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_GetNotificationChannelVerificationCodeResponse.
 *
 *  Requests a verification code for an already verified channel that can then
 *  be used in a call to VerifyNotificationChannel() on a different channel with
 *  an equivalent identity in the same or in a different project. This makes it
 *  possible to copy a channel between projects without requiring manual
 *  reverification of the channel. If the channel is not in the verified state,
 *  this method will fail (in other words, this may only be used if the
 *  SendNotificationChannelVerificationCode and VerifyNotificationChannel paths
 *  have already been used to put the given channel into the verified
 *  state).There is no guarantee that the verification codes returned by this
 *  method will be of a similar structure or form as the ones that are delivered
 *  to the channel via SendNotificationChannelVerificationCode; while
 *  VerifyNotificationChannel() will recognize both the codes delivered via
 *  SendNotificationChannelVerificationCode() and returned from
 *  GetNotificationChannelVerificationCode(), it is typically the case that the
 *  verification codes delivered via SendNotificationChannelVerificationCode()
 *  will be shorter and also have a shorter expiration (e.g. codes such as
 *  "G-123456") whereas GetVerificationCode() will typically return a much
 *  longer, websafe base 64 encoded string that has a longer expiration time.
 *
 *  @param object The @c
 *    GTLRMonitoring_GetNotificationChannelVerificationCodeRequest to include in
 *    the query.
 *  @param name The notification channel for which a verification code is to be
 *    generated and retrieved. This must name a channel that is already
 *    verified; if the specified channel is not verified, the request will fail.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsGetVerificationCode
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_GetNotificationChannelVerificationCodeRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Lists the notification channels that have been created for the project.
 *
 *  Method: monitoring.projects.notificationChannels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsListWithname:]

/**
 *  If provided, this field specifies the criteria that must be met by
 *  notification channels to be included in the response.For more details, see
 *  sorting and filtering.
 */
@property(nonatomic, copy, nullable) NSString *filter;

/**
 *  The project on which to execute the request. The format is
 *  projects/[PROJECT_ID]. That is, this names the container in which to look
 *  for the notification channels; it does not name a specific channel. To query
 *  a specific channel by REST resource name, use the GetNotificationChannel
 *  operation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A comma-separated list of fields by which to sort the result. Supports the
 *  same set of fields as in filter. Entries can be prefixed with a minus sign
 *  to sort in descending rather than ascending order.For more details, see
 *  sorting and filtering.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  The maximum number of results to return in a single response. If not set to
 *  a positive number, a reasonable value will be chosen by the service.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If non-empty, page_token must contain a value returned as the
 *  next_page_token in a previous response to request the next set of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListNotificationChannelsResponse.
 *
 *  Lists the notification channels that have been created for the project.
 *
 *  @param name The project on which to execute the request. The format is
 *    projects/[PROJECT_ID]. That is, this names the container in which to look
 *    for the notification channels; it does not name a specific channel. To
 *    query a specific channel by REST resource name, use the
 *    GetNotificationChannel operation.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Updates a notification channel. Fields not specified in the field mask
 *  remain unchanged.
 *
 *  Method: monitoring.projects.notificationChannels.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsPatchWithObject:name:]

/**
 *  The full REST resource name for this channel. The syntax is:
 *  projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
 *  The [CHANNEL_ID] is automatically assigned by the server on creation.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The fields to update.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Updates a notification channel. Fields not specified in the field mask
 *  remain unchanged.
 *
 *  @param object The @c GTLRMonitoring_NotificationChannel to include in the
 *    query.
 *  @param name The full REST resource name for this channel. The syntax is:
 *    projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
 *    The [CHANNEL_ID] is automatically assigned by the server on creation.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_NotificationChannel *)object
                           name:(NSString *)name;

@end

/**
 *  Causes a verification code to be delivered to the channel. The code can then
 *  be supplied in VerifyNotificationChannel to verify the channel.
 *
 *  Method: monitoring.projects.notificationChannels.sendVerificationCode
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsSendVerificationCode : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsSendVerificationCodeWithObject:name:]

/** The notification channel to which to send a verification code. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Causes a verification code to be delivered to the channel. The code can then
 *  be supplied in VerifyNotificationChannel to verify the channel.
 *
 *  @param object The @c
 *    GTLRMonitoring_SendNotificationChannelVerificationCodeRequest to include
 *    in the query.
 *  @param name The notification channel to which to send a verification code.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsSendVerificationCode
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_SendNotificationChannelVerificationCodeRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Verifies a NotificationChannel by proving receipt of the code delivered to
 *  the channel as a result of calling SendNotificationChannelVerificationCode.
 *
 *  Method: monitoring.projects.notificationChannels.verify
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsNotificationChannelsVerify : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsNotificationChannelsVerifyWithObject:name:]

/** The notification channel to verify. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_NotificationChannel.
 *
 *  Verifies a NotificationChannel by proving receipt of the code delivered to
 *  the channel as a result of calling SendNotificationChannelVerificationCode.
 *
 *  @param object The @c GTLRMonitoring_VerifyNotificationChannelRequest to
 *    include in the query.
 *  @param name The notification channel to verify.
 *
 *  @return GTLRMonitoringQuery_ProjectsNotificationChannelsVerify
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_VerifyNotificationChannelRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Creates or adds data to one or more time series. The response is empty if
 *  all time series in the request were written. If any time series could not be
 *  written, a corresponding failure message is included in the error response.
 *
 *  Method: monitoring.projects.timeSeries.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringWrite
 */
@interface GTLRMonitoringQuery_ProjectsTimeSeriesCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsTimeSeriesCreateWithObject:name:]

/**
 *  The project on which to execute the request. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Creates or adds data to one or more time series. The response is empty if
 *  all time series in the request were written. If any time series could not be
 *  written, a corresponding failure message is included in the error response.
 *
 *  @param object The @c GTLRMonitoring_CreateTimeSeriesRequest to include in
 *    the query.
 *  @param name The project on which to execute the request. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsTimeSeriesCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_CreateTimeSeriesRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Lists time series that match a filter. This method does not require a
 *  Stackdriver account.
 *
 *  Method: monitoring.projects.timeSeries.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsTimeSeriesList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsTimeSeriesListWithname:]

/**
 *  The alignment period for per-time series alignment. If present,
 *  alignmentPeriod must be at least 60 seconds. After per-time series
 *  alignment, each time series will contain data points only on the period
 *  boundaries. If perSeriesAligner is not specified or equals ALIGN_NONE, then
 *  this field is ignored. If perSeriesAligner is specified and does not equal
 *  ALIGN_NONE, then this field must be defined; otherwise an error is returned.
 */
@property(nonatomic, strong, nullable) GTLRDuration *aggregationAlignmentPeriod;

/**
 *  The approach to be used to combine time series. Not all reducer functions
 *  may be applied to all time series, depending on the metric type and the
 *  value type of the original time series. Reduction may change the metric type
 *  of value type of the time series.Time series data must be aligned in order
 *  to perform cross-time series reduction. If crossSeriesReducer is specified,
 *  then perSeriesAligner must be specified and not equal ALIGN_NONE and
 *  alignmentPeriod must be specified; otherwise, an error is returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceNone Value
 *        "REDUCE_NONE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceMean Value
 *        "REDUCE_MEAN"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceMin Value
 *        "REDUCE_MIN"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceMax Value
 *        "REDUCE_MAX"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceSum Value
 *        "REDUCE_SUM"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceStddev Value
 *        "REDUCE_STDDEV"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceCount Value
 *        "REDUCE_COUNT"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceCountTrue Value
 *        "REDUCE_COUNT_TRUE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceCountFalse Value
 *        "REDUCE_COUNT_FALSE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReduceFractionTrue
 *        Value "REDUCE_FRACTION_TRUE"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile99
 *        Value "REDUCE_PERCENTILE_99"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile95
 *        Value "REDUCE_PERCENTILE_95"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile50
 *        Value "REDUCE_PERCENTILE_50"
 *    @arg @c kGTLRMonitoringAggregationCrossSeriesReducerReducePercentile05
 *        Value "REDUCE_PERCENTILE_05"
 */
@property(nonatomic, copy, nullable) NSString *aggregationCrossSeriesReducer;

/**
 *  The set of fields to preserve when crossSeriesReducer is specified. The
 *  groupByFields determine how the time series are partitioned into subsets
 *  prior to applying the aggregation function. Each subset contains time series
 *  that have the same value for each of the grouping fields. Each individual
 *  time series is a member of exactly one subset. The crossSeriesReducer is
 *  applied to each subset of time series. It is not possible to reduce across
 *  different resource types, so this field implicitly contains resource.type.
 *  Fields not specified in groupByFields are aggregated away. If groupByFields
 *  is not specified and all the time series have the same resource type, then
 *  the time series are aggregated into a single output time series. If
 *  crossSeriesReducer is not defined, this field is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *aggregationGroupByFields;

/**
 *  The approach to be used to align individual time series. Not all alignment
 *  functions may be applied to all time series, depending on the metric type
 *  and value type of the original time series. Alignment may change the metric
 *  type or the value type of the time series.Time series data must be aligned
 *  in order to perform cross-time series reduction. If crossSeriesReducer is
 *  specified, then perSeriesAligner must be specified and not equal ALIGN_NONE
 *  and alignmentPeriod must be specified; otherwise, an error is returned.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignNone Value
 *        "ALIGN_NONE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignDelta Value
 *        "ALIGN_DELTA"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignRate Value
 *        "ALIGN_RATE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignInterpolate Value
 *        "ALIGN_INTERPOLATE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignNextOlder Value
 *        "ALIGN_NEXT_OLDER"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignMin Value
 *        "ALIGN_MIN"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignMax Value
 *        "ALIGN_MAX"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignMean Value
 *        "ALIGN_MEAN"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignCount Value
 *        "ALIGN_COUNT"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignSum Value
 *        "ALIGN_SUM"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignStddev Value
 *        "ALIGN_STDDEV"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignCountTrue Value
 *        "ALIGN_COUNT_TRUE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignCountFalse Value
 *        "ALIGN_COUNT_FALSE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignFractionTrue Value
 *        "ALIGN_FRACTION_TRUE"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile99 Value
 *        "ALIGN_PERCENTILE_99"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile95 Value
 *        "ALIGN_PERCENTILE_95"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile50 Value
 *        "ALIGN_PERCENTILE_50"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentile05 Value
 *        "ALIGN_PERCENTILE_05"
 *    @arg @c kGTLRMonitoringAggregationPerSeriesAlignerAlignPercentChange Value
 *        "ALIGN_PERCENT_CHANGE"
 */
@property(nonatomic, copy, nullable) NSString *aggregationPerSeriesAligner;

/**
 *  A monitoring filter that specifies which time series should be returned. The
 *  filter must specify a single metric type, and can additionally specify
 *  metric labels and other information. For example:
 *  metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
 *  metric.label.instance_name = "my-instance-name"
 */
@property(nonatomic, copy, nullable) NSString *filter;

/** Required. The end of the time interval. */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalEndTime;

/**
 *  Optional. The beginning of the time interval. The default value for the
 *  start time is the end time. The start time must not be later than the end
 *  time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *intervalStartTime;

/**
 *  The project on which to execute the request. The format is
 *  "projects/{project_id_or_number}".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Unsupported: must be left blank. The points in each time series are returned
 *  in reverse time order.
 */
@property(nonatomic, copy, nullable) NSString *orderBy;

/**
 *  A positive number that is the maximum number of results to return. If
 *  page_size is empty or more than 100,000 results, the effective page_size is
 *  100,000 results. If view is set to FULL, this is the maximum number of
 *  Points returned. If view is set to HEADERS, this is the maximum number of
 *  TimeSeries returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return additional results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Specifies which information is returned about the time series.
 *
 *  Likely values:
 *    @arg @c kGTLRMonitoringViewFull Value "FULL"
 *    @arg @c kGTLRMonitoringViewHeaders Value "HEADERS"
 */
@property(nonatomic, copy, nullable) NSString *view;

/**
 *  Fetches a @c GTLRMonitoring_ListTimeSeriesResponse.
 *
 *  Lists time series that match a filter. This method does not require a
 *  Stackdriver account.
 *
 *  @param name The project on which to execute the request. The format is
 *    "projects/{project_id_or_number}".
 *
 *  @return GTLRMonitoringQuery_ProjectsTimeSeriesList
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Creates a new uptime check configuration.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsCreate : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsCreateWithObject:parent:]

/**
 *  The project in which to create the uptime check. The format is
 *  projects/[PROJECT_ID].
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRMonitoring_UptimeCheckConfig.
 *
 *  Creates a new uptime check configuration.
 *
 *  @param object The @c GTLRMonitoring_UptimeCheckConfig to include in the
 *    query.
 *  @param parent The project in which to create the uptime check. The format is
 *    projects/[PROJECT_ID].
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsCreate
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_UptimeCheckConfig *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes an uptime check configuration. Note that this method will fail if
 *  the uptime check configuration is referenced by an alert policy or other
 *  dependent configs that would be rendered invalid by the deletion.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsDelete : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsDeleteWithname:]

/**
 *  The uptime check configuration to delete. The format is
 *  projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_Empty.
 *
 *  Deletes an uptime check configuration. Note that this method will fail if
 *  the uptime check configuration is referenced by an alert policy or other
 *  dependent configs that would be rendered invalid by the deletion.
 *
 *  @param name The uptime check configuration to delete. The format is
 *    projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets a single uptime check configuration.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsGet : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsGetWithname:]

/**
 *  The uptime check configuration to retrieve. The format is
 *  projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRMonitoring_UptimeCheckConfig.
 *
 *  Gets a single uptime check configuration.
 *
 *  @param name The uptime check configuration to retrieve. The format is
 *    projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists the existing valid uptime check configurations for the project,
 *  leaving out any invalid configurations.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsListWithparent:]

/**
 *  The maximum number of results to return in a single response. The server may
 *  further constrain the maximum number of results returned in a single page.
 *  If the page_size is <=0, the server will decide the number of results to be
 *  returned.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return more results from the previous method call.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  The project whose uptime check configurations are listed. The format is
 *  projects/[PROJECT_ID].
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRMonitoring_ListUptimeCheckConfigsResponse.
 *
 *  Lists the existing valid uptime check configurations for the project,
 *  leaving out any invalid configurations.
 *
 *  @param parent The project whose uptime check configurations are listed. The
 *    format is projects/[PROJECT_ID].
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates an uptime check configuration. You can either replace the entire
 *  configuration with a new one or replace only certain fields in the current
 *  configuration by specifying the fields to be updated via "updateMask".
 *  Returns the updated configuration.
 *
 *  Method: monitoring.projects.uptimeCheckConfigs.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 */
@interface GTLRMonitoringQuery_ProjectsUptimeCheckConfigsPatch : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForProjectsUptimeCheckConfigsPatchWithObject:name:]

/**
 *  A unique resource name for this UptimeCheckConfig. The format
 *  is:projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].This field
 *  should be omitted when creating the uptime check configuration; on create,
 *  the resource name is assigned by the server and included in the response.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Optional. If present, only the listed fields in the current uptime check
 *  configuration are updated with values from the new configuration. If this
 *  field is empty, then the current configuration is completely replaced with
 *  the new configuration.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRMonitoring_UptimeCheckConfig.
 *
 *  Updates an uptime check configuration. You can either replace the entire
 *  configuration with a new one or replace only certain fields in the current
 *  configuration by specifying the fields to be updated via "updateMask".
 *  Returns the updated configuration.
 *
 *  @param object The @c GTLRMonitoring_UptimeCheckConfig to include in the
 *    query.
 *  @param name A unique resource name for this UptimeCheckConfig. The format
 *    is:projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID].This field
 *    should be omitted when creating the uptime check configuration; on create,
 *    the resource name is assigned by the server and included in the response.
 *
 *  @return GTLRMonitoringQuery_ProjectsUptimeCheckConfigsPatch
 */
+ (instancetype)queryWithObject:(GTLRMonitoring_UptimeCheckConfig *)object
                           name:(NSString *)name;

@end

/**
 *  Returns the list of IPs that checkers run from
 *
 *  Method: monitoring.uptimeCheckIps.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeMonitoring
 *    @c kGTLRAuthScopeMonitoringCloudPlatform
 *    @c kGTLRAuthScopeMonitoringRead
 */
@interface GTLRMonitoringQuery_UptimeCheckIpsList : GTLRMonitoringQuery
// Previous library name was
//   +[GTLQueryMonitoring queryForUptimeCheckIpsList]

/**
 *  The maximum number of results to return in a single response. The server may
 *  further constrain the maximum number of results returned in a single page.
 *  If the page_size is <=0, the server will decide the number of results to be
 *  returned. NOTE: this field is not yet implemented
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  If this field is not empty then it must contain the nextPageToken value
 *  returned by a previous call to this method. Using this field causes the
 *  method to return more results from the previous method call. NOTE: this
 *  field is not yet implemented
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRMonitoring_ListUptimeCheckIpsResponse.
 *
 *  Returns the list of IPs that checkers run from
 *
 *  @return GTLRMonitoringQuery_UptimeCheckIpsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)query;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
