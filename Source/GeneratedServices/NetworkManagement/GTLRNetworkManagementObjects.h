// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Network Management API (networkmanagement/v1)
// Description:
//   The Network Management API provides a collection of network performance
//   monitoring and diagnostic capabilities.
// Documentation:
//   https://cloud.google.com/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRNetworkManagement_AbortInfo;
@class GTLRNetworkManagement_AuditConfig;
@class GTLRNetworkManagement_AuditLogConfig;
@class GTLRNetworkManagement_Binding;
@class GTLRNetworkManagement_CloudSQLInstanceInfo;
@class GTLRNetworkManagement_ConnectivityTest;
@class GTLRNetworkManagement_ConnectivityTest_Labels;
@class GTLRNetworkManagement_DeliverInfo;
@class GTLRNetworkManagement_DropInfo;
@class GTLRNetworkManagement_Endpoint;
@class GTLRNetworkManagement_EndpointInfo;
@class GTLRNetworkManagement_Expr;
@class GTLRNetworkManagement_FirewallInfo;
@class GTLRNetworkManagement_ForwardInfo;
@class GTLRNetworkManagement_ForwardingRuleInfo;
@class GTLRNetworkManagement_GKEMasterInfo;
@class GTLRNetworkManagement_InstanceInfo;
@class GTLRNetworkManagement_LoadBalancerBackend;
@class GTLRNetworkManagement_LoadBalancerInfo;
@class GTLRNetworkManagement_Location;
@class GTLRNetworkManagement_Location_Labels;
@class GTLRNetworkManagement_Location_Metadata;
@class GTLRNetworkManagement_NetworkInfo;
@class GTLRNetworkManagement_Operation;
@class GTLRNetworkManagement_Operation_Metadata;
@class GTLRNetworkManagement_Operation_Response;
@class GTLRNetworkManagement_Policy;
@class GTLRNetworkManagement_ReachabilityDetails;
@class GTLRNetworkManagement_RouteInfo;
@class GTLRNetworkManagement_Status;
@class GTLRNetworkManagement_Status_Details_Item;
@class GTLRNetworkManagement_Step;
@class GTLRNetworkManagement_Trace;
@class GTLRNetworkManagement_VpnGatewayInfo;
@class GTLRNetworkManagement_VpnTunnelInfo;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_AbortInfo.cause

/**
 *  Cause is unspecified.
 *
 *  Value: "CAUSE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_CauseUnspecified;
/**
 *  Aborted because the destination endpoint could not be found.
 *
 *  Value: "DESTINATION_ENDPOINT_NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_DestinationEndpointNotFound;
/**
 *  Aborted due to internal server error.
 *
 *  Value: "INTERNAL_ERROR"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_InternalError;
/**
 *  Aborted because the source and/or destination endpoint specified in the test
 *  are invalid. The possible reasons that an endpoint is invalid include:
 *  malformed IP address; nonexistent instance or network URI; IP address not in
 *  the range of specified network URI; and instance not owning the network
 *  interface in the specified network.
 *
 *  Value: "INVALID_ARGUMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_InvalidArgument;
/**
 *  Aborted because the destination network does not match the destination
 *  endpoint.
 *
 *  Value: "MISMATCHED_DESTINATION_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_MismatchedDestinationNetwork;
/**
 *  Aborted because the source network does not match the source endpoint.
 *
 *  Value: "MISMATCHED_SOURCE_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_MismatchedSourceNetwork;
/**
 *  Aborted because traffic is sent from a public IP to an instance without an
 *  external IP.
 *
 *  Value: "NO_EXTERNAL_IP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_NoExternalIp;
/**
 *  Aborted because no valid source endpoint is derived from the input test
 *  request.
 *
 *  Value: "NO_SOURCE_LOCATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_NoSourceLocation;
/**
 *  Aborted because the user lacks the permission to access all or part of the
 *  network configurations required to run the test.
 *
 *  Value: "PERMISSION_DENIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_PermissionDenied;
/**
 *  Aborted because the source endpoint could not be found.
 *
 *  Value: "SOURCE_ENDPOINT_NOT_FOUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_SourceEndpointNotFound;
/**
 *  Aborted because the number of steps in the trace exceeding a certain limit
 *  which may be caused by routing loop.
 *
 *  Value: "TRACE_TOO_LONG"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_TraceTooLong;
/**
 *  Aborted because none of the traces matches destination information specified
 *  in the input test request.
 *
 *  Value: "UNINTENDED_DESTINATION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnintendedDestination;
/**
 *  Aborted because the IP address(es) are unknown.
 *
 *  Value: "UNKNOWN_IP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownIp;
/**
 *  Aborted due to unknown network. The reachability analysis cannot proceed
 *  because the user does not have access to the host project's network
 *  configurations, including firewall rules and routes. This happens when the
 *  project is a service project and the endpoints being traced are in the host
 *  project's network.
 *
 *  Value: "UNKNOWN_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownNetwork;
/**
 *  Aborted because no project information can be derived from the test input.
 *
 *  Value: "UNKNOWN_PROJECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_UnknownProject;
/**
 *  Aborted because the test scenario is not supported.
 *
 *  Value: "UNSUPPORTED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AbortInfo_Cause_Unsupported;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_DeliverInfo.target

/**
 *  Target is a Cloud SQL instance.
 *
 *  Value: "CLOUD_SQL_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DeliverInfo_Target_CloudSqlInstance;
/**
 *  Target is a Google Kubernetes Engine cluster master.
 *
 *  Value: "GKE_MASTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DeliverInfo_Target_GkeMaster;
/**
 *  Target is a Google API.
 *
 *  Value: "GOOGLE_API"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DeliverInfo_Target_GoogleApi;
/**
 *  Target is a Compute Engine instance.
 *
 *  Value: "INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DeliverInfo_Target_Instance;
/**
 *  Target is the internet.
 *
 *  Value: "INTERNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DeliverInfo_Target_Internet;
/**
 *  Target not specified.
 *
 *  Value: "TARGET_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DeliverInfo_Target_TargetUnspecified;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_DropInfo.cause

/**
 *  Cause is unspecified.
 *
 *  Value: "CAUSE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_CauseUnspecified;
/**
 *  Packet was dropped because the Cloud SQL instance has neither a private nor
 *  a public IP address.
 *
 *  Value: "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceNoIpAddress;
/**
 *  Access to the Cloud SQL instance endpoint is not authorized. See
 *  [Authorizing with authorized
 *  networks](https://cloud.google.com/sql/docs/mysql/authorize-networks) for
 *  more details.
 *
 *  Value: "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceUnauthorizedAccess;
/**
 *  Packet was dropped inside Cloud SQL Service.
 *
 *  Value: "DROPPED_INSIDE_CLOUD_SQL_SERVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideCloudSqlService;
/**
 *  Packet was dropped inside Google Kubernetes Engine Service.
 *
 *  Value: "DROPPED_INSIDE_GKE_SERVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideGkeService;
/**
 *  Firewalls block the health check probes to the backends and cause the
 *  backends to be unavailable for traffic from the load balancer. For more
 *  details, see [Health check firewall
 *  rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
 *
 *  Value: "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_FirewallBlockingLoadBalancerBackendHealthCheck;
/**
 *  Dropped due to a firewall rule, unless allowed due to connection tracking.
 *
 *  Value: "FIREWALL_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_FirewallRule;
/**
 *  A Compute Engine instance can only send or receive a packet with a foreign
 *  IP address if ip_forward is enabled.
 *
 *  Value: "FOREIGN_IP_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForeignIpDisallowed;
/**
 *  Forwarding rule's protocol and ports do not match the packet header.
 *
 *  Value: "FORWARDING_RULE_MISMATCH"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleMismatch;
/**
 *  Forwarding rule does not have backends configured.
 *
 *  Value: "FORWARDING_RULE_NO_INSTANCES"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleNoInstances;
/**
 *  Access to Google Kubernetes Engine cluster master's endpoint is not
 *  authorized. See [Access to the cluster
 *  endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
 *  for more details.
 *
 *  Value: "GKE_MASTER_UNAUTHORIZED_ACCESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_GkeMasterUnauthorizedAccess;
/**
 *  Packet was dropped because there is no peering between the originating
 *  network and the Google Managed Services Network.
 *
 *  Value: "GOOGLE_MANAGED_SERVICE_NO_PEERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_GoogleManagedServiceNoPeering;
/**
 *  Packet is sent from or to a Compute Engine instance that is not in a running
 *  state.
 *
 *  Value: "INSTANCE_NOT_RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_InstanceNotRunning;
/**
 *  Instance with only an internal IP address tries to access external hosts,
 *  but Cloud NAT is not enabled in the subnet, unless special configurations on
 *  a VM allow this connection. For more details, see [Special configurations
 *  for VM instances](https://cloud.google.com/vpc/docs/special-configurations).
 *
 *  Value: "NO_EXTERNAL_ADDRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoExternalAddress;
/**
 *  Dropped due to no routes.
 *
 *  Value: "NO_ROUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_NoRoute;
/**
 *  Instance with only an internal IP address tries to access Google API and
 *  services, but private Google access is not enabled.
 *
 *  Value: "PRIVATE_GOOGLE_ACCESS_DISALLOWED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_PrivateGoogleAccessDisallowed;
/**
 *  Packet with internal destination address sent to the internet gateway.
 *
 *  Value: "PRIVATE_TRAFFIC_TO_INTERNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_PrivateTrafficToInternet;
/**
 *  Dropped due to invalid route. Route's next hop is a blackhole.
 *
 *  Value: "ROUTE_BLACKHOLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteBlackhole;
/**
 *  Packet is sent to a wrong (unintended) network. Example: you trace a packet
 *  from VM1:Network1 to VM2:Network2, however, the route configured in Network1
 *  sends the packet destined for VM2's IP addresss to Network3.
 *
 *  Value: "ROUTE_WRONG_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_RouteWrongNetwork;
/**
 *  The type of traffic is blocked and the user cannot configure a firewall rule
 *  to enable it. See [Always blocked
 *  traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic) for
 *  more details.
 *
 *  Value: "TRAFFIC_TYPE_BLOCKED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_TrafficTypeBlocked;
/**
 *  Destination external address cannot be resolved to a known target. If the
 *  address is used in a Google Cloud project, provide the project ID as test
 *  input.
 *
 *  Value: "UNKNOWN_EXTERNAL_ADDRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_UnknownExternalAddress;
/**
 *  Destination internal address cannot be resolved to a known target. If this
 *  is a shared VPC scenario, verify if the service project ID is provided as
 *  test input. Otherwise, verify if the IP address is being used in the
 *  project.
 *
 *  Value: "UNKNOWN_INTERNAL_ADDRESS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_DropInfo_Cause_UnknownInternalAddress;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_Endpoint.networkType

/**
 *  A network hosted within Google Cloud Platform. To receive more detailed
 *  output, specify the URI for the source or destination network.
 *
 *  Value: "GCP_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Endpoint_NetworkType_GcpNetwork;
/**
 *  Default type if unspecified.
 *
 *  Value: "NETWORK_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Endpoint_NetworkType_NetworkTypeUnspecified;
/**
 *  A network hosted outside of Google Cloud Platform. This can be an
 *  on-premises network, or a network hosted by another cloud provider.
 *
 *  Value: "NON_GCP_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Endpoint_NetworkType_NonGcpNetwork;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_FirewallInfo.firewallRuleType

/**
 *  Unspecified type.
 *
 *  Value: "FIREWALL_RULE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_FirewallRuleTypeUnspecified;
/**
 *  Hierarchical firewall policy rule. For details, see [Hierarchical firewall
 *  policies overview](https://cloud.google.com/vpc/docs/firewall-policies).
 *
 *  Value: "HIERARCHICAL_FIREWALL_POLICY_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_HierarchicalFirewallPolicyRule;
/**
 *  Implied VPC firewall rule. For details, see [Implied
 *  rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
 *
 *  Value: "IMPLIED_VPC_FIREWALL_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_ImpliedVpcFirewallRule;
/**
 *  VPC firewall rule. For details, see [VPC firewall rules
 *  overview](https://cloud.google.com/vpc/docs/firewalls).
 *
 *  Value: "VPC_FIREWALL_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_VpcFirewallRule;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_ForwardInfo.target

/**
 *  Forwarded to a Cloud SQL instance.
 *
 *  Value: "CLOUD_SQL_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_CloudSqlInstance;
/**
 *  Forwarded to a Google Kubernetes Engine Container cluster master.
 *
 *  Value: "GKE_MASTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_GkeMaster;
/**
 *  Forwarded to the next hop of a custom route imported from a peering VPC.
 *
 *  Value: "IMPORTED_CUSTOM_ROUTE_NEXT_HOP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_ImportedCustomRouteNextHop;
/**
 *  Forwarded to a Cloud Interconnect connection.
 *
 *  Value: "INTERCONNECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_Interconnect;
/**
 *  Forwarded to a VPC peering network.
 *
 *  Value: "PEERING_VPC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_PeeringVpc;
/**
 *  Target not specified.
 *
 *  Value: "TARGET_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_TargetUnspecified;
/**
 *  Forwarded to a Cloud VPN gateway.
 *
 *  Value: "VPN_GATEWAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ForwardInfo_Target_VpnGateway;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_LoadBalancerBackend.healthCheckFirewallState

/**
 *  There are configured firewall rules to allow health check probes to the
 *  backend.
 *
 *  Value: "CONFIGURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_Configured;
/**
 *  State is unspecified. Default state if not populated.
 *
 *  Value: "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_HealthCheckFirewallStateUnspecified;
/**
 *  There are firewall rules configured to allow partial health check ranges or
 *  block all health check ranges. If a health check probe is sent from denied
 *  IP ranges, the health check to the backend will fail. Then, the backend will
 *  be marked unhealthy and will not receive traffic sent to the load balancer.
 *
 *  Value: "MISCONFIGURED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_Misconfigured;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_LoadBalancerInfo.backendType

/**
 *  Backend Service as the load balancer's backend.
 *
 *  Value: "BACKEND_SERVICE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_BackendService;
/**
 *  Type is unspecified.
 *
 *  Value: "BACKEND_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_BackendTypeUnspecified;
/**
 *  Target Pool as the load balancer's backend.
 *
 *  Value: "TARGET_POOL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_BackendType_TargetPool;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_LoadBalancerInfo.loadBalancerType

/**
 *  HTTP(S) proxy load balancer.
 *
 *  Value: "HTTP_PROXY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_HttpProxy;
/**
 *  Internal TCP/UDP load balancer.
 *
 *  Value: "INTERNAL_TCP_UDP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_InternalTcpUdp;
/**
 *  Type is unspecified.
 *
 *  Value: "LOAD_BALANCER_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_LoadBalancerTypeUnspecified;
/**
 *  Network TCP/UDP load balancer.
 *
 *  Value: "NETWORK_TCP_UDP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_NetworkTcpUdp;
/**
 *  SSL proxy load balancer.
 *
 *  Value: "SSL_PROXY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_SslProxy;
/**
 *  TCP proxy load balancer.
 *
 *  Value: "TCP_PROXY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_TcpProxy;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_ReachabilityDetails.result

/**
 *  The source and destination endpoints do not uniquely identify the test
 *  location in the network, and the reachability result contains multiple
 *  traces. For some traces, a packet could be delivered, and for others, it
 *  would not be.
 *
 *  Value: "AMBIGUOUS"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Ambiguous;
/**
 *  Possible scenarios are: * The configuration analysis determined that a
 *  packet originating from the source is expected to reach the destination. *
 *  The analysis didn't complete because the user lacks permission for some of
 *  the resources in the trace. However, at the time the user's permission
 *  became insufficient, the trace had been successful so far.
 *
 *  Value: "REACHABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Reachable;
/**
 *  No result was specified.
 *
 *  Value: "RESULT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_ResultUnspecified;
/**
 *  The configuration analysis did not complete. Possible reasons are: * A
 *  permissions error occurred--for example, the user might not have read
 *  permission for all of the resources named in the test. * An internal error
 *  occurred. * The analyzer received an invalid or unsupported argument or was
 *  unable to identify a known endpoint.
 *
 *  Value: "UNDETERMINED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Undetermined;
/**
 *  A packet originating from the source is expected to be dropped before
 *  reaching the destination.
 *
 *  Value: "UNREACHABLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_ReachabilityDetails_Result_Unreachable;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_RouteInfo.nextHopType

/**
 *  Next hop is blackhole; that is, the next hop either does not exist or is not
 *  running.
 *
 *  Value: "NEXT_HOP_BLACKHOLE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopBlackhole;
/**
 *  Next hop is the forwarding rule of an Internal Load Balancer.
 *
 *  Value: "NEXT_HOP_ILB"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopIlb;
/**
 *  Next hop is a Compute Engine instance.
 *
 *  Value: "NEXT_HOP_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInstance;
/**
 *  Next hop is an interconnect.
 *
 *  Value: "NEXT_HOP_INTERCONNECT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInterconnect;
/**
 *  Next hop is an internet gateway.
 *
 *  Value: "NEXT_HOP_INTERNET_GATEWAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInternetGateway;
/**
 *  Next hop is an IP address.
 *
 *  Value: "NEXT_HOP_IP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopIp;
/**
 *  Next hop is a VPC network gateway.
 *
 *  Value: "NEXT_HOP_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopNetwork;
/**
 *  Next hop is a peering VPC.
 *
 *  Value: "NEXT_HOP_PEERING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopPeering;
/**
 *  Next hop is a [router appliance
 *  instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
 *
 *  Value: "NEXT_HOP_ROUTER_APPLIANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopRouterAppliance;
/**
 *  Unspecified type. Default value.
 *
 *  Value: "NEXT_HOP_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopTypeUnspecified;
/**
 *  Next hop is a VPN gateway. This scenario only happens when tracing
 *  connectivity from an on-premises network to Google Cloud through a VPN. The
 *  analysis simulates a packet departing from the on-premises network through a
 *  VPN tunnel and arriving at a Cloud VPN gateway.
 *
 *  Value: "NEXT_HOP_VPN_GATEWAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopVpnGateway;
/**
 *  Next hop is a VPN tunnel.
 *
 *  Value: "NEXT_HOP_VPN_TUNNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopVpnTunnel;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_RouteInfo.routeType

/**
 *  Dynamic route exchanged between BGP peers.
 *
 *  Value: "DYNAMIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_Dynamic;
/**
 *  A dynamic route received from peering network.
 *
 *  Value: "PEERING_DYNAMIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PeeringDynamic;
/**
 *  A static route received from peering network.
 *
 *  Value: "PEERING_STATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PeeringStatic;
/**
 *  A subnet route received from peering network.
 *
 *  Value: "PEERING_SUBNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_PeeringSubnet;
/**
 *  Unspecified type. Default value.
 *
 *  Value: "ROUTE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_RouteTypeUnspecified;
/**
 *  Static route created by the user, including the default route to the
 *  internet.
 *
 *  Value: "STATIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_Static;
/**
 *  Route is a subnet route automatically created by the system.
 *
 *  Value: "SUBNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_RouteInfo_RouteType_Subnet;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_Step.state

/**
 *  Final state: analysis is aborted.
 *
 *  Value: "ABORT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_Abort;
/**
 *  Config checking state: verify egress firewall rule.
 *
 *  Value: "APPLY_EGRESS_FIREWALL_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ApplyEgressFirewallRule;
/**
 *  Config checking state: match forwarding rule.
 *
 *  Value: "APPLY_FORWARDING_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ApplyForwardingRule;
/**
 *  Config checking state: verify ingress firewall rule.
 *
 *  Value: "APPLY_INGRESS_FIREWALL_RULE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ApplyIngressFirewallRule;
/**
 *  Config checking state: verify route.
 *
 *  Value: "APPLY_ROUTE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ApplyRoute;
/**
 *  Forwarding state: arriving at a Compute Engine external load balancer.
 *
 *  Value: "ARRIVE_AT_EXTERNAL_LOAD_BALANCER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ArriveAtExternalLoadBalancer;
/**
 *  Forwarding state: arriving at a Compute Engine instance.
 *
 *  Value: "ARRIVE_AT_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ArriveAtInstance;
/**
 *  Forwarding state: arriving at a Compute Engine internal load balancer.
 *
 *  Value: "ARRIVE_AT_INTERNAL_LOAD_BALANCER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ArriveAtInternalLoadBalancer;
/**
 *  Forwarding state: arriving at a Cloud VPN gateway.
 *
 *  Value: "ARRIVE_AT_VPN_GATEWAY"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ArriveAtVpnGateway;
/**
 *  Forwarding state: arriving at a Cloud VPN tunnel.
 *
 *  Value: "ARRIVE_AT_VPN_TUNNEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ArriveAtVpnTunnel;
/**
 *  Final state: packet could be delivered.
 *
 *  Value: "DELIVER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_Deliver;
/**
 *  Final state: packet could be dropped.
 *
 *  Value: "DROP"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_Drop;
/**
 *  Final state: packet could be forwarded to a network with an unknown
 *  configuration.
 *
 *  Value: "FORWARD"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_Forward;
/**
 *  Transition state: packet header translated.
 *
 *  Value: "NAT"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_Nat;
/**
 *  Transition state: original connection is terminated and a new proxied
 *  connection is initiated.
 *
 *  Value: "PROXY_CONNECTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ProxyConnection;
/**
 *  Config checking state: packet sent or received under foreign IP address and
 *  allowed.
 *
 *  Value: "SPOOFING_APPROVED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_SpoofingApproved;
/**
 *  Initial state: packet originating from a Cloud SQL instance. A
 *  CloudSQLInstanceInfo is populated with starting instance information.
 *
 *  Value: "START_FROM_CLOUD_SQL_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_StartFromCloudSqlInstance;
/**
 *  Initial state: packet originating from a Google Kubernetes Engine cluster
 *  master. A GKEMasterInfo is populated with starting instance information.
 *
 *  Value: "START_FROM_GKE_MASTER"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_StartFromGkeMaster;
/**
 *  Initial state: packet originating from a Compute Engine instance. An
 *  InstanceInfo is populated with starting instance information.
 *
 *  Value: "START_FROM_INSTANCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_StartFromInstance;
/**
 *  Initial state: packet originating from the internet. The endpoint
 *  information is populated.
 *
 *  Value: "START_FROM_INTERNET"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_StartFromInternet;
/**
 *  Initial state: packet originating from a VPC or on-premises network with
 *  internal source IP. If the source is a VPC network visible to the user, a
 *  NetworkInfo is populated with details of the network.
 *
 *  Value: "START_FROM_PRIVATE_NETWORK"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_StartFromPrivateNetwork;
/**
 *  Unspecified state.
 *
 *  Value: "STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_StateUnspecified;
/**
 *  Special state: viewer of the test result does not have permission to see the
 *  configuration in this step.
 *
 *  Value: "VIEWER_PERMISSION_MISSING"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_Step_State_ViewerPermissionMissing;

// ----------------------------------------------------------------------------
// GTLRNetworkManagement_VpnTunnelInfo.routingType

/**
 *  Dynamic (BGP) routing.
 *
 *  Value: "DYNAMIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_Dynamic;
/**
 *  Policy based routing.
 *
 *  Value: "POLICY_BASED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_PolicyBased;
/**
 *  Route based VPN.
 *
 *  Value: "ROUTE_BASED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_RouteBased;
/**
 *  Unspecified type. Default value.
 *
 *  Value: "ROUTING_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_RoutingTypeUnspecified;

/**
 *  Details of the final state "abort" and associated resource.
 */
@interface GTLRNetworkManagement_AbortInfo : GTLRObject

/**
 *  Causes that the analysis is aborted.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_CauseUnspecified Cause is
 *        unspecified. (Value: "CAUSE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_DestinationEndpointNotFound
 *        Aborted because the destination endpoint could not be found. (Value:
 *        "DESTINATION_ENDPOINT_NOT_FOUND")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_InternalError Aborted due
 *        to internal server error. (Value: "INTERNAL_ERROR")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_InvalidArgument Aborted
 *        because the source and/or destination endpoint specified in the test
 *        are invalid. The possible reasons that an endpoint is invalid include:
 *        malformed IP address; nonexistent instance or network URI; IP address
 *        not in the range of specified network URI; and instance not owning the
 *        network interface in the specified network. (Value:
 *        "INVALID_ARGUMENT")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_MismatchedDestinationNetwork
 *        Aborted because the destination network does not match the destination
 *        endpoint. (Value: "MISMATCHED_DESTINATION_NETWORK")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_MismatchedSourceNetwork
 *        Aborted because the source network does not match the source endpoint.
 *        (Value: "MISMATCHED_SOURCE_NETWORK")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_NoExternalIp Aborted
 *        because traffic is sent from a public IP to an instance without an
 *        external IP. (Value: "NO_EXTERNAL_IP")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_NoSourceLocation Aborted
 *        because no valid source endpoint is derived from the input test
 *        request. (Value: "NO_SOURCE_LOCATION")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_PermissionDenied Aborted
 *        because the user lacks the permission to access all or part of the
 *        network configurations required to run the test. (Value:
 *        "PERMISSION_DENIED")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_SourceEndpointNotFound
 *        Aborted because the source endpoint could not be found. (Value:
 *        "SOURCE_ENDPOINT_NOT_FOUND")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_TraceTooLong Aborted
 *        because the number of steps in the trace exceeding a certain limit
 *        which may be caused by routing loop. (Value: "TRACE_TOO_LONG")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_UnintendedDestination
 *        Aborted because none of the traces matches destination information
 *        specified in the input test request. (Value: "UNINTENDED_DESTINATION")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_UnknownIp Aborted because
 *        the IP address(es) are unknown. (Value: "UNKNOWN_IP")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_UnknownNetwork Aborted due
 *        to unknown network. The reachability analysis cannot proceed because
 *        the user does not have access to the host project's network
 *        configurations, including firewall rules and routes. This happens when
 *        the project is a service project and the endpoints being traced are in
 *        the host project's network. (Value: "UNKNOWN_NETWORK")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_UnknownProject Aborted
 *        because no project information can be derived from the test input.
 *        (Value: "UNKNOWN_PROJECT")
 *    @arg @c kGTLRNetworkManagement_AbortInfo_Cause_Unsupported Aborted because
 *        the test scenario is not supported. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *cause;

/** URI of the resource that caused the abort. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  Specifies the audit configuration for a service. The configuration
 *  determines which permission types are logged, and what identities, if any,
 *  are exempted from logging. An AuditConfig must have one or more
 *  AuditLogConfigs. If there are AuditConfigs for both `allServices` and a
 *  specific service, the union of the two AuditConfigs is used for that
 *  service: the log_types specified in each AuditConfig are enabled, and the
 *  exempted_members in each AuditLogConfig are exempted. Example Policy with
 *  multiple AuditConfigs: { "audit_configs": [ { "service": "allServices",
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type":
 *  "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com",
 *  "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type":
 *  "DATA_WRITE", "exempted_members": [ "user:aliya\@example.com" ] } ] } ] }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts jose\@example.com from DATA_READ logging, and
 *  aliya\@example.com from DATA_WRITE logging.
 */
@interface GTLRNetworkManagement_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging. For example,
 *  `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
 *  special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions. Example: {
 *  "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
 *  "user:jose\@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables
 *  'DATA_READ' and 'DATA_WRITE' logging, while exempting jose\@example.com from
 *  DATA_READ logging.
 */
@interface GTLRNetworkManagement_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission. Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_AuditLogConfig_LogType_AdminRead Admin
 *        reads. Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRNetworkManagement_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRNetworkManagement_AuditLogConfig_LogType_DataWrite Data
 *        writes. Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRNetworkManagement_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRNetworkManagement_Binding : GTLRObject

/**
 *  The condition that is associated with this binding. If the condition
 *  evaluates to `true`, then this binding applies to the current request. If
 *  the condition evaluates to `false`, then this binding does not apply to the
 *  current request. However, a different role binding might grant the same role
 *  to one or more of the members in this binding. To learn which resources
 *  support conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values: * `allUsers`: A special identifier
 *  that represents anyone who is on the internet; with or without a Google
 *  account. * `allAuthenticatedUsers`: A special identifier that represents
 *  anyone who is authenticated with a Google account or a service account. *
 *  `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@example.com` . * `serviceAccount:{emailid}`:
 *  An email address that represents a service account. For example,
 *  `my-other-app\@appspot.gserviceaccount.com`. * `group:{emailid}`: An email
 *  address that represents a Google group. For example, `admins\@example.com`.
 *  * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
 *  identifier) representing a user that has been recently deleted. For example,
 *  `alice\@example.com?uid=123456789012345678901`. If the user is recovered,
 *  this value reverts to `user:{emailid}` and the recovered user retains the
 *  role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An
 *  email address (plus unique identifier) representing a service account that
 *  has been recently deleted. For example,
 *  `my-other-app\@appspot.gserviceaccount.com?uid=123456789012345678901`. If
 *  the service account is undeleted, this value reverts to
 *  `serviceAccount:{emailid}` and the undeleted service account retains the
 *  role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
 *  address (plus unique identifier) representing a Google group that has been
 *  recently deleted. For example,
 *  `admins\@example.com?uid=123456789012345678901`. If the group is recovered,
 *  this value reverts to `group:{emailid}` and the recovered group retains the
 *  role in the binding. * `domain:{domain}`: The G Suite domain (primary) that
 *  represents all the users of that domain. For example, `google.com` or
 *  `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`. For example, `roles/viewer`,
 *  `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  The request message for Operations.CancelOperation.
 */
@interface GTLRNetworkManagement_CancelOperationRequest : GTLRObject
@end


/**
 *  For display only. Metadata associated with a Cloud SQL instance.
 */
@interface GTLRNetworkManagement_CloudSQLInstanceInfo : GTLRObject

/** Name of a Cloud SQL instance. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** External IP address of a Cloud SQL instance. */
@property(nonatomic, copy, nullable) NSString *externalIp;

/** Internal IP address of a Cloud SQL instance. */
@property(nonatomic, copy, nullable) NSString *internalIp;

/**
 *  URI of a Cloud SQL instance network or empty string if the instance does not
 *  have one.
 */
@property(nonatomic, copy, nullable) NSString *networkUri;

/** Region in which the Cloud SQL instance is running. */
@property(nonatomic, copy, nullable) NSString *region;

/** URI of a Cloud SQL instance. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  A Connectivity Test for a network reachability analysis.
 */
@interface GTLRNetworkManagement_ConnectivityTest : GTLRObject

/** Output only. The time the test was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The user-supplied description of the Connectivity Test. Maximum of 512
 *  characters.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Required. Destination specification of the Connectivity Test. You can use a
 *  combination of destination IP address, Compute Engine VM instance, or VPC
 *  network to uniquely identify the destination location. Even if the
 *  destination IP address is not unique, the source IP location is unique.
 *  Usually, the analysis can infer the destination endpoint from route
 *  information. If the destination you specify is a VM instance and the
 *  instance has multiple network interfaces, then you must also specify either
 *  a destination IP address or VPC network to identify the destination
 *  interface. A reachability analysis proceeds even if the destination location
 *  is ambiguous. However, the result can include endpoints that you don't
 *  intend to test.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Endpoint *destination;

/** Output only. The display name of a Connectivity Test. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Resource labels to represent user-provided metadata. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_ConnectivityTest_Labels *labels;

/**
 *  Required. Unique name of the resource using the form:
 *  `projects/{project_id}/locations/global/connectivityTests/{test_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/** IP Protocol of the test. When not provided, "TCP" is assumed. */
@property(nonatomic, copy, nullable) NSString *protocol;

/**
 *  Output only. The reachability details of this test from the latest run. The
 *  details are updated when creating a new test, updating an existing test, or
 *  triggering a one-time rerun of an existing test.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_ReachabilityDetails *reachabilityDetails;

/**
 *  Other projects that may be relevant for reachability analysis. This is
 *  applicable to scenarios where a test can cross project boundaries.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *relatedProjects;

/**
 *  Required. Source specification of the Connectivity Test. You can use a
 *  combination of source IP address, virtual machine (VM) instance, or Compute
 *  Engine network to uniquely identify the source location. Examples: If the
 *  source IP address is an internal IP address within a Google Cloud Virtual
 *  Private Cloud (VPC) network, then you must also specify the VPC network.
 *  Otherwise, specify the VM instance, which already contains its internal IP
 *  address and VPC network information. If the source of the test is within an
 *  on-premises network, then you must provide the destination VPC network. If
 *  the source endpoint is a Compute Engine VM instance with multiple network
 *  interfaces, the instance itself is not sufficient to identify the endpoint.
 *  So, you must also specify the source IP address or VPC network. A
 *  reachability analysis proceeds even if the source location is ambiguous.
 *  However, the test result may include endpoints that you don't intend to
 *  test.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Endpoint *source;

/** Output only. The time the test's configuration was updated. */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Resource labels to represent user-provided metadata.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkManagement_ConnectivityTest_Labels : GTLRObject
@end


/**
 *  Details of the final state "deliver" and associated resource.
 */
@interface GTLRNetworkManagement_DeliverInfo : GTLRObject

/** URI of the resource that the packet is delivered to. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

/**
 *  Target type where the packet is delivered to.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_DeliverInfo_Target_CloudSqlInstance Target
 *        is a Cloud SQL instance. (Value: "CLOUD_SQL_INSTANCE")
 *    @arg @c kGTLRNetworkManagement_DeliverInfo_Target_GkeMaster Target is a
 *        Google Kubernetes Engine cluster master. (Value: "GKE_MASTER")
 *    @arg @c kGTLRNetworkManagement_DeliverInfo_Target_GoogleApi Target is a
 *        Google API. (Value: "GOOGLE_API")
 *    @arg @c kGTLRNetworkManagement_DeliverInfo_Target_Instance Target is a
 *        Compute Engine instance. (Value: "INSTANCE")
 *    @arg @c kGTLRNetworkManagement_DeliverInfo_Target_Internet Target is the
 *        internet. (Value: "INTERNET")
 *    @arg @c kGTLRNetworkManagement_DeliverInfo_Target_TargetUnspecified Target
 *        not specified. (Value: "TARGET_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *target;

@end


/**
 *  Details of the final state "drop" and associated resource.
 */
@interface GTLRNetworkManagement_DropInfo : GTLRObject

/**
 *  Cause that the packet is dropped.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_CauseUnspecified Cause is
 *        unspecified. (Value: "CAUSE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceNoIpAddress
 *        Packet was dropped because the Cloud SQL instance has neither a
 *        private nor a public IP address. (Value:
 *        "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_CloudSqlInstanceUnauthorizedAccess
 *        Access to the Cloud SQL instance endpoint is not authorized. See
 *        [Authorizing with authorized
 *        networks](https://cloud.google.com/sql/docs/mysql/authorize-networks)
 *        for more details. (Value: "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideCloudSqlService
 *        Packet was dropped inside Cloud SQL Service. (Value:
 *        "DROPPED_INSIDE_CLOUD_SQL_SERVICE")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_DroppedInsideGkeService
 *        Packet was dropped inside Google Kubernetes Engine Service. (Value:
 *        "DROPPED_INSIDE_GKE_SERVICE")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_FirewallBlockingLoadBalancerBackendHealthCheck
 *        Firewalls block the health check probes to the backends and cause the
 *        backends to be unavailable for traffic from the load balancer. For
 *        more details, see [Health check firewall
 *        rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
 *        (Value: "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_FirewallRule Dropped due to
 *        a firewall rule, unless allowed due to connection tracking. (Value:
 *        "FIREWALL_RULE")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_ForeignIpDisallowed A
 *        Compute Engine instance can only send or receive a packet with a
 *        foreign IP address if ip_forward is enabled. (Value:
 *        "FOREIGN_IP_DISALLOWED")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleMismatch
 *        Forwarding rule's protocol and ports do not match the packet header.
 *        (Value: "FORWARDING_RULE_MISMATCH")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_ForwardingRuleNoInstances
 *        Forwarding rule does not have backends configured. (Value:
 *        "FORWARDING_RULE_NO_INSTANCES")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_GkeMasterUnauthorizedAccess
 *        Access to Google Kubernetes Engine cluster master's endpoint is not
 *        authorized. See [Access to the cluster
 *        endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
 *        for more details. (Value: "GKE_MASTER_UNAUTHORIZED_ACCESS")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_GoogleManagedServiceNoPeering
 *        Packet was dropped because there is no peering between the originating
 *        network and the Google Managed Services Network. (Value:
 *        "GOOGLE_MANAGED_SERVICE_NO_PEERING")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_InstanceNotRunning Packet is
 *        sent from or to a Compute Engine instance that is not in a running
 *        state. (Value: "INSTANCE_NOT_RUNNING")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_NoExternalAddress Instance
 *        with only an internal IP address tries to access external hosts, but
 *        Cloud NAT is not enabled in the subnet, unless special configurations
 *        on a VM allow this connection. For more details, see [Special
 *        configurations for VM
 *        instances](https://cloud.google.com/vpc/docs/special-configurations).
 *        (Value: "NO_EXTERNAL_ADDRESS")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_NoRoute Dropped due to no
 *        routes. (Value: "NO_ROUTE")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_PrivateGoogleAccessDisallowed
 *        Instance with only an internal IP address tries to access Google API
 *        and services, but private Google access is not enabled. (Value:
 *        "PRIVATE_GOOGLE_ACCESS_DISALLOWED")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_PrivateTrafficToInternet
 *        Packet with internal destination address sent to the internet gateway.
 *        (Value: "PRIVATE_TRAFFIC_TO_INTERNET")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_RouteBlackhole Dropped due
 *        to invalid route. Route's next hop is a blackhole. (Value:
 *        "ROUTE_BLACKHOLE")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_RouteWrongNetwork Packet is
 *        sent to a wrong (unintended) network. Example: you trace a packet from
 *        VM1:Network1 to VM2:Network2, however, the route configured in
 *        Network1 sends the packet destined for VM2's IP addresss to Network3.
 *        (Value: "ROUTE_WRONG_NETWORK")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_TrafficTypeBlocked The type
 *        of traffic is blocked and the user cannot configure a firewall rule to
 *        enable it. See [Always blocked
 *        traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic)
 *        for more details. (Value: "TRAFFIC_TYPE_BLOCKED")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_UnknownExternalAddress
 *        Destination external address cannot be resolved to a known target. If
 *        the address is used in a Google Cloud project, provide the project ID
 *        as test input. (Value: "UNKNOWN_EXTERNAL_ADDRESS")
 *    @arg @c kGTLRNetworkManagement_DropInfo_Cause_UnknownInternalAddress
 *        Destination internal address cannot be resolved to a known target. If
 *        this is a shared VPC scenario, verify if the service project ID is
 *        provided as test input. Otherwise, verify if the IP address is being
 *        used in the project. (Value: "UNKNOWN_INTERNAL_ADDRESS")
 */
@property(nonatomic, copy, nullable) NSString *cause;

/** URI of the resource that caused the drop. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
 *  representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRNetworkManagement_Empty : GTLRObject
@end


/**
 *  Source or destination of the Connectivity Test.
 */
@interface GTLRNetworkManagement_Endpoint : GTLRObject

/** A [Cloud SQL](https://cloud.google.com/sql) instance URI. */
@property(nonatomic, copy, nullable) NSString *cloudSqlInstance;

/**
 *  A cluster URI for [Google Kubernetes Engine
 *  master](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
 */
@property(nonatomic, copy, nullable) NSString *gkeMasterCluster;

/** A Compute Engine instance URI. */
@property(nonatomic, copy, nullable) NSString *instance;

/**
 *  The IP address of the endpoint, which can be an external or internal IP. An
 *  IPv6 address is only allowed when the test's destination is a [global load
 *  balancer VIP](/load-balancing/docs/load-balancing-overview).
 */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/** A Compute Engine network URI. */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  Type of the network where the endpoint is located. Applicable only to source
 *  endpoint, as destination network type can be inferred from the source.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_Endpoint_NetworkType_GcpNetwork A network
 *        hosted within Google Cloud Platform. To receive more detailed output,
 *        specify the URI for the source or destination network. (Value:
 *        "GCP_NETWORK")
 *    @arg @c kGTLRNetworkManagement_Endpoint_NetworkType_NetworkTypeUnspecified
 *        Default type if unspecified. (Value: "NETWORK_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_Endpoint_NetworkType_NonGcpNetwork A
 *        network hosted outside of Google Cloud Platform. This can be an
 *        on-premises network, or a network hosted by another cloud provider.
 *        (Value: "NON_GCP_NETWORK")
 */
@property(nonatomic, copy, nullable) NSString *networkType;

/**
 *  The IP protocol port of the endpoint. Only applicable when protocol is TCP
 *  or UDP.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

/**
 *  Project ID where the endpoint is located. The Project ID can be derived from
 *  the URI if you provide a VM instance or network URI. The following are two
 *  cases where you must provide the project ID: 1. Only the IP address is
 *  specified, and the IP address is within a GCP project. 2. When you are using
 *  Shared VPC and the IP address that you provide is from the service project.
 *  In this case, the network that the IP address resides in is defined in the
 *  host project.
 */
@property(nonatomic, copy, nullable) NSString *projectId;

@end


/**
 *  For display only. The specification of the endpoints for the test.
 *  EndpointInfo is derived from source and destination Endpoint and validated
 *  by the backend data plane model.
 */
@interface GTLRNetworkManagement_EndpointInfo : GTLRObject

/** Destination IP address. */
@property(nonatomic, copy, nullable) NSString *destinationIp;

/** URI of the network where this packet is sent to. */
@property(nonatomic, copy, nullable) NSString *destinationNetworkUri;

/**
 *  Destination port. Only valid when protocol is TCP or UDP.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *destinationPort;

/** IP protocol in string format, for example: "TCP", "UDP", "ICMP". */
@property(nonatomic, copy, nullable) NSString *protocol;

/** Source IP address. */
@property(nonatomic, copy, nullable) NSString *sourceIp;

/** URI of the network where this packet originates from. */
@property(nonatomic, copy, nullable) NSString *sourceNetworkUri;

/**
 *  Source port. Only valid when protocol is TCP or UDP.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sourcePort;

@end


/**
 *  Represents a textual expression in the Common Expression Language (CEL)
 *  syntax. CEL is a C-like expression language. The syntax and semantics of CEL
 *  are documented at https://github.com/google/cel-spec. Example (Comparison):
 *  title: "Summary size limit" description: "Determines if a summary is less
 *  than 100 chars" expression: "document.summary.size() < 100" Example
 *  (Equality): title: "Requestor is owner" description: "Determines if
 *  requestor is the document owner" expression: "document.owner ==
 *  request.auth.claims.email" Example (Logic): title: "Public documents"
 *  description: "Determine whether the document should be publicly visible"
 *  expression: "document.type != 'private' && document.type != 'internal'"
 *  Example (Data Manipulation): title: "Notification string" description:
 *  "Create a notification string with a timestamp." expression: "'New message
 *  received at ' + string(document.create_time)" The exact variables and
 *  functions that may be referenced within an expression are determined by the
 *  service that evaluates it. See the service documentation for additional
 *  information.
 */
@interface GTLRNetworkManagement_Expr : GTLRObject

/**
 *  Optional. Description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in Common Expression Language
 *  syntax.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Optional. String indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  Optional. Title for the expression, i.e. a short string describing its
 *  purpose. This can be used e.g. in UIs which allow to enter the expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  For display only. Metadata associated with a VPC firewall rule, an implied
 *  VPC firewall rule, or a hierarchical firewall policy rule.
 */
@interface GTLRNetworkManagement_FirewallInfo : GTLRObject

/** Possible values: ALLOW, DENY */
@property(nonatomic, copy, nullable) NSString *action;

/** Possible values: INGRESS, EGRESS */
@property(nonatomic, copy, nullable) NSString *direction;

/**
 *  The display name of the VPC firewall rule. This field is not applicable to
 *  hierarchical firewall policy rules.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  The firewall rule's type.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_FirewallRuleTypeUnspecified
 *        Unspecified type. (Value: "FIREWALL_RULE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_HierarchicalFirewallPolicyRule
 *        Hierarchical firewall policy rule. For details, see [Hierarchical
 *        firewall policies
 *        overview](https://cloud.google.com/vpc/docs/firewall-policies).
 *        (Value: "HIERARCHICAL_FIREWALL_POLICY_RULE")
 *    @arg @c kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_ImpliedVpcFirewallRule
 *        Implied VPC firewall rule. For details, see [Implied
 *        rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
 *        (Value: "IMPLIED_VPC_FIREWALL_RULE")
 *    @arg @c kGTLRNetworkManagement_FirewallInfo_FirewallRuleType_VpcFirewallRule
 *        VPC firewall rule. For details, see [VPC firewall rules
 *        overview](https://cloud.google.com/vpc/docs/firewalls). (Value:
 *        "VPC_FIREWALL_RULE")
 */
@property(nonatomic, copy, nullable) NSString *firewallRuleType;

/**
 *  The URI of the VPC network that the firewall rule is associated with. This
 *  field is not applicable to hierarchical firewall policy rules.
 */
@property(nonatomic, copy, nullable) NSString *networkUri;

/**
 *  The hierarchical firewall policy that this rule is associated with. This
 *  field is not applicable to VPC firewall rules.
 */
@property(nonatomic, copy, nullable) NSString *policy;

/**
 *  The priority of the firewall rule.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/** The target service accounts specified by the firewall rule. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *targetServiceAccounts;

/**
 *  The target tags defined by the VPC firewall rule. This field is not
 *  applicable to hierarchical firewall policy rules.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *targetTags;

/**
 *  The URI of the VPC firewall rule. This field is not applicable to implied
 *  firewall rules or hierarchical firewall policy rules.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Details of the final state "forward" and associated resource.
 */
@interface GTLRNetworkManagement_ForwardInfo : GTLRObject

/** URI of the resource that the packet is forwarded to. */
@property(nonatomic, copy, nullable) NSString *resourceUri;

/**
 *  Target type where this packet is forwarded to.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_CloudSqlInstance
 *        Forwarded to a Cloud SQL instance. (Value: "CLOUD_SQL_INSTANCE")
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_GkeMaster Forwarded to a
 *        Google Kubernetes Engine Container cluster master. (Value:
 *        "GKE_MASTER")
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_ImportedCustomRouteNextHop
 *        Forwarded to the next hop of a custom route imported from a peering
 *        VPC. (Value: "IMPORTED_CUSTOM_ROUTE_NEXT_HOP")
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_Interconnect Forwarded
 *        to a Cloud Interconnect connection. (Value: "INTERCONNECT")
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_PeeringVpc Forwarded to
 *        a VPC peering network. (Value: "PEERING_VPC")
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_TargetUnspecified Target
 *        not specified. (Value: "TARGET_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_ForwardInfo_Target_VpnGateway Forwarded to
 *        a Cloud VPN gateway. (Value: "VPN_GATEWAY")
 */
@property(nonatomic, copy, nullable) NSString *target;

@end


/**
 *  For display only. Metadata associated with a Compute Engine forwarding rule.
 */
@interface GTLRNetworkManagement_ForwardingRuleInfo : GTLRObject

/** Name of a Compute Engine forwarding rule. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Port range defined in the forwarding rule that matches the test. */
@property(nonatomic, copy, nullable) NSString *matchedPortRange;

/** Protocol defined in the forwarding rule that matches the test. */
@property(nonatomic, copy, nullable) NSString *matchedProtocol;

/** Network URI. Only valid for Internal Load Balancer. */
@property(nonatomic, copy, nullable) NSString *networkUri;

/** Target type of the forwarding rule. */
@property(nonatomic, copy, nullable) NSString *target;

/** URI of a Compute Engine forwarding rule. */
@property(nonatomic, copy, nullable) NSString *uri;

/** VIP of the forwarding rule. */
@property(nonatomic, copy, nullable) NSString *vip;

@end


/**
 *  For display only. Metadata associated with a Google Kubernetes Engine (GKE)
 *  cluster master.
 */
@interface GTLRNetworkManagement_GKEMasterInfo : GTLRObject

/** URI of a GKE cluster network. */
@property(nonatomic, copy, nullable) NSString *clusterNetworkUri;

/** URI of a GKE cluster. */
@property(nonatomic, copy, nullable) NSString *clusterUri;

/** External IP address of a GKE cluster master. */
@property(nonatomic, copy, nullable) NSString *externalIp;

/** Internal IP address of a GKE cluster master. */
@property(nonatomic, copy, nullable) NSString *internalIp;

@end


/**
 *  For display only. Metadata associated with a Compute Engine instance.
 */
@interface GTLRNetworkManagement_InstanceInfo : GTLRObject

/** Name of a Compute Engine instance. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** External IP address of the network interface. */
@property(nonatomic, copy, nullable) NSString *externalIp;

/** Name of the network interface of a Compute Engine instance. */
@property(nonatomic, copy, nullable) NSString *interface;

/** Internal IP address of the network interface. */
@property(nonatomic, copy, nullable) NSString *internalIp;

/** Network tags configured on the instance. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *networkTags;

/** URI of a Compute Engine network. */
@property(nonatomic, copy, nullable) NSString *networkUri;

/** Service account authorized for the instance. */
@property(nonatomic, copy, nullable) NSString *serviceAccount;

/** URI of a Compute Engine instance. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Response for the `ListConnectivityTests` method.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "resources" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkManagement_ListConnectivityTestsResponse : GTLRCollectionObject

/** Page token to fetch the next set of Connectivity Tests. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  List of Connectivity Tests.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_ConnectivityTest *> *resources;

/**
 *  Locations that could not be reached (when querying all locations with `-`).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkManagement_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRNetworkManagement_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_Operation *> *operations;

@end


/**
 *  For display only. Metadata associated with a specific load balancer backend.
 */
@interface GTLRNetworkManagement_LoadBalancerBackend : GTLRObject

/** Name of a Compute Engine instance or network endpoint. */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  A list of firewall rule URIs allowing probes from health check IP ranges.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *healthCheckAllowingFirewallRules;

/**
 *  A list of firewall rule URIs blocking probes from health check IP ranges.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *healthCheckBlockingFirewallRules;

/**
 *  State of the health check firewall configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_Configured
 *        There are configured firewall rules to allow health check probes to
 *        the backend. (Value: "CONFIGURED")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_HealthCheckFirewallStateUnspecified
 *        State is unspecified. Default state if not populated. (Value:
 *        "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerBackend_HealthCheckFirewallState_Misconfigured
 *        There are firewall rules configured to allow partial health check
 *        ranges or block all health check ranges. If a health check probe is
 *        sent from denied IP ranges, the health check to the backend will fail.
 *        Then, the backend will be marked unhealthy and will not receive
 *        traffic sent to the load balancer. (Value: "MISCONFIGURED")
 */
@property(nonatomic, copy, nullable) NSString *healthCheckFirewallState;

/** URI of a Compute Engine instance or network endpoint. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  For display only. Metadata associated with a load balancer.
 */
@interface GTLRNetworkManagement_LoadBalancerInfo : GTLRObject

/** Information for the loadbalancer backends. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_LoadBalancerBackend *> *backends;

/**
 *  Type of load balancer's backend configuration.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_BackendType_BackendService
 *        Backend Service as the load balancer's backend. (Value:
 *        "BACKEND_SERVICE")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_BackendType_BackendTypeUnspecified
 *        Type is unspecified. (Value: "BACKEND_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_BackendType_TargetPool
 *        Target Pool as the load balancer's backend. (Value: "TARGET_POOL")
 */
@property(nonatomic, copy, nullable) NSString *backendType;

/** Backend configuration URI. */
@property(nonatomic, copy, nullable) NSString *backendUri;

/** URI of the health check for the load balancer. */
@property(nonatomic, copy, nullable) NSString *healthCheckUri;

/**
 *  Type of the load balancer.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_HttpProxy
 *        HTTP(S) proxy load balancer. (Value: "HTTP_PROXY")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_InternalTcpUdp
 *        Internal TCP/UDP load balancer. (Value: "INTERNAL_TCP_UDP")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_LoadBalancerTypeUnspecified
 *        Type is unspecified. (Value: "LOAD_BALANCER_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_NetworkTcpUdp
 *        Network TCP/UDP load balancer. (Value: "NETWORK_TCP_UDP")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_SslProxy
 *        SSL proxy load balancer. (Value: "SSL_PROXY")
 *    @arg @c kGTLRNetworkManagement_LoadBalancerInfo_LoadBalancerType_TcpProxy
 *        TCP proxy load balancer. (Value: "TCP_PROXY")
 */
@property(nonatomic, copy, nullable) NSString *loadBalancerType;

@end


/**
 *  A resource that represents Google Cloud Platform location.
 */
@interface GTLRNetworkManagement_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name. For
 *  example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations. For
 *  example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRNetworkManagement_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkManagement_Location_Metadata : GTLRObject
@end


/**
 *  For display only. Metadata associated with a Compute Engine network.
 */
@interface GTLRNetworkManagement_NetworkInfo : GTLRObject

/** Name of a Compute Engine network. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** The IP range that matches the test. */
@property(nonatomic, copy, nullable) NSString *matchedIpRange;

/** URI of a Compute Engine network. */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRNetworkManagement_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress. If
 *  `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the `name`
 *  should be a resource name ending with `operations/{unique_id}`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkManagement_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx` is the
 *  original method name. For example, if the original method name is
 *  `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkManagement_Operation_Response : GTLRObject
@end


/**
 *  Metadata describing an Operation
 */
@interface GTLRNetworkManagement_OperationMetadata : GTLRObject

/** API version. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  Specifies if cancellation was requested for the operation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cancelRequested;

/** The time the operation was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** The time the operation finished running. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/** Human-readable status of the operation, if any. */
@property(nonatomic, copy, nullable) NSString *statusDetail;

/**
 *  Target of the operation - for example
 *  projects/project-1/locations/global/connectivityTests/test-1
 */
@property(nonatomic, copy, nullable) NSString *target;

/** Name of the verb executed by the operation. */
@property(nonatomic, copy, nullable) NSString *verb;

@end


/**
 *  An Identity and Access Management (IAM) policy, which specifies access
 *  controls for Google Cloud resources. A `Policy` is a collection of
 *  `bindings`. A `binding` binds one or more `members` to a single `role`.
 *  Members can be user accounts, service accounts, Google groups, and domains
 *  (such as G Suite). A `role` is a named list of permissions; each `role` can
 *  be an IAM predefined role or a user-created custom role. For some types of
 *  Google Cloud resources, a `binding` can also specify a `condition`, which is
 *  a logical expression that allows access to a resource only if the expression
 *  evaluates to `true`. A condition can add constraints based on attributes of
 *  the request, the resource, or both. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *  **JSON example:** { "bindings": [ { "role":
 *  "roles/resourcemanager.organizationAdmin", "members": [
 *  "user:mike\@example.com", "group:admins\@example.com", "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com" ] }, { "role":
 *  "roles/resourcemanager.organizationViewer", "members": [
 *  "user:eve\@example.com" ], "condition": { "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020", "expression":
 *  "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
 *  "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: -
 *  user:mike\@example.com - group:admins\@example.com - domain:google.com -
 *  serviceAccount:my-project-id\@appspot.gserviceaccount.com role:
 *  roles/resourcemanager.organizationAdmin - members: - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer condition: title: expirable
 *  access description: Does not grant access after Sep 2020 expression:
 *  request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA=
 *  version: 3 For a description of IAM and its features, see the [IAM
 *  documentation](https://cloud.google.com/iam/docs/).
 */
@interface GTLRNetworkManagement_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members` to a `role`. Optionally, may specify a
 *  `condition` that determines how and when the `bindings` are applied. Each of
 *  the `bindings` must contain at least one member.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help prevent
 *  simultaneous updates of a policy from overwriting each other. It is strongly
 *  suggested that systems make use of the `etag` in the read-modify-write cycle
 *  to perform policy updates in order to avoid race conditions: An `etag` is
 *  returned in the response to `getIamPolicy`, and systems are expected to put
 *  that etag in the request to `setIamPolicy` to ensure that their change will
 *  be applied to the same version of the policy. **Important:** If you use IAM
 *  Conditions, you must include the `etag` field whenever you call
 *  `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
 *  version `3` policy with a version `1` policy, and all of the conditions in
 *  the version `3` policy are lost.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy. Valid values are `0`, `1`, and `3`.
 *  Requests that specify an invalid value are rejected. Any operation that
 *  affects conditional role bindings must specify version `3`. This requirement
 *  applies to the following operations: * Getting a policy that includes a
 *  conditional role binding * Adding a conditional role binding to a policy *
 *  Changing a conditional role binding in a policy * Removing any role binding,
 *  with or without a condition, from a policy that includes conditions
 *  **Important:** If you use IAM Conditions, you must include the `etag` field
 *  whenever you call `setIamPolicy`. If you omit this field, then IAM allows
 *  you to overwrite a version `3` policy with a version `1` policy, and all of
 *  the conditions in the version `3` policy are lost. If a policy does not
 *  include any conditions, operations on that policy may specify any valid
 *  version or leave the field unset. To learn which resources support
 *  conditions in their IAM policies, see the [IAM
 *  documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Results of the configuration analysis from the last run of the test.
 */
@interface GTLRNetworkManagement_ReachabilityDetails : GTLRObject

/** The details of a failure or a cancellation of reachability analysis. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Status *error;

/**
 *  The overall result of the test's configuration analysis.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_ReachabilityDetails_Result_Ambiguous The
 *        source and destination endpoints do not uniquely identify the test
 *        location in the network, and the reachability result contains multiple
 *        traces. For some traces, a packet could be delivered, and for others,
 *        it would not be. (Value: "AMBIGUOUS")
 *    @arg @c kGTLRNetworkManagement_ReachabilityDetails_Result_Reachable
 *        Possible scenarios are: * The configuration analysis determined that a
 *        packet originating from the source is expected to reach the
 *        destination. * The analysis didn't complete because the user lacks
 *        permission for some of the resources in the trace. However, at the
 *        time the user's permission became insufficient, the trace had been
 *        successful so far. (Value: "REACHABLE")
 *    @arg @c kGTLRNetworkManagement_ReachabilityDetails_Result_ResultUnspecified
 *        No result was specified. (Value: "RESULT_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_ReachabilityDetails_Result_Undetermined The
 *        configuration analysis did not complete. Possible reasons are: * A
 *        permissions error occurred--for example, the user might not have read
 *        permission for all of the resources named in the test. * An internal
 *        error occurred. * The analyzer received an invalid or unsupported
 *        argument or was unable to identify a known endpoint. (Value:
 *        "UNDETERMINED")
 *    @arg @c kGTLRNetworkManagement_ReachabilityDetails_Result_Unreachable A
 *        packet originating from the source is expected to be dropped before
 *        reaching the destination. (Value: "UNREACHABLE")
 */
@property(nonatomic, copy, nullable) NSString *result;

/**
 *  Result may contain a list of traces if a test has multiple possible paths in
 *  the network, such as when destination endpoint is a load balancer with
 *  multiple backends.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_Trace *> *traces;

/** The time of the configuration analysis. */
@property(nonatomic, strong, nullable) GTLRDateTime *verifyTime;

@end


/**
 *  Request for the `RerunConnectivityTest` method.
 */
@interface GTLRNetworkManagement_RerunConnectivityTestRequest : GTLRObject
@end


/**
 *  For display only. Metadata associated with a Compute Engine route.
 */
@interface GTLRNetworkManagement_RouteInfo : GTLRObject

/** Destination IP range of the route. */
@property(nonatomic, copy, nullable) NSString *destIpRange;

/** Name of a Compute Engine route. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** Instance tags of the route. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *instanceTags;

/** URI of a Compute Engine network. */
@property(nonatomic, copy, nullable) NSString *networkUri;

/** Next hop of the route. */
@property(nonatomic, copy, nullable) NSString *nextHop;

/**
 *  Type of next hop.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopBlackhole Next
 *        hop is blackhole; that is, the next hop either does not exist or is
 *        not running. (Value: "NEXT_HOP_BLACKHOLE")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopIlb Next hop
 *        is the forwarding rule of an Internal Load Balancer. (Value:
 *        "NEXT_HOP_ILB")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInstance Next
 *        hop is a Compute Engine instance. (Value: "NEXT_HOP_INSTANCE")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInterconnect
 *        Next hop is an interconnect. (Value: "NEXT_HOP_INTERCONNECT")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopInternetGateway
 *        Next hop is an internet gateway. (Value: "NEXT_HOP_INTERNET_GATEWAY")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopIp Next hop is
 *        an IP address. (Value: "NEXT_HOP_IP")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopNetwork Next
 *        hop is a VPC network gateway. (Value: "NEXT_HOP_NETWORK")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopPeering Next
 *        hop is a peering VPC. (Value: "NEXT_HOP_PEERING")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopRouterAppliance
 *        Next hop is a [router appliance
 *        instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
 *        (Value: "NEXT_HOP_ROUTER_APPLIANCE")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopTypeUnspecified
 *        Unspecified type. Default value. (Value: "NEXT_HOP_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopVpnGateway
 *        Next hop is a VPN gateway. This scenario only happens when tracing
 *        connectivity from an on-premises network to Google Cloud through a
 *        VPN. The analysis simulates a packet departing from the on-premises
 *        network through a VPN tunnel and arriving at a Cloud VPN gateway.
 *        (Value: "NEXT_HOP_VPN_GATEWAY")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_NextHopType_NextHopVpnTunnel Next
 *        hop is a VPN tunnel. (Value: "NEXT_HOP_VPN_TUNNEL")
 */
@property(nonatomic, copy, nullable) NSString *nextHopType;

/**
 *  Priority of the route.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *priority;

/**
 *  Type of route.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_Dynamic Dynamic route
 *        exchanged between BGP peers. (Value: "DYNAMIC")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_PeeringDynamic A
 *        dynamic route received from peering network. (Value:
 *        "PEERING_DYNAMIC")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_PeeringStatic A static
 *        route received from peering network. (Value: "PEERING_STATIC")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_PeeringSubnet A subnet
 *        route received from peering network. (Value: "PEERING_SUBNET")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_RouteTypeUnspecified
 *        Unspecified type. Default value. (Value: "ROUTE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_Static Static route
 *        created by the user, including the default route to the internet.
 *        (Value: "STATIC")
 *    @arg @c kGTLRNetworkManagement_RouteInfo_RouteType_Subnet Route is a
 *        subnet route automatically created by the system. (Value: "SUBNET")
 */
@property(nonatomic, copy, nullable) NSString *routeType;

/**
 *  URI of a Compute Engine route. Dynamic route from cloud router does not have
 *  a URI. Advertised route from Google Cloud VPC to on-premises network also
 *  does not have a URI.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRNetworkManagement_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a valid policy
 *  but certain Cloud Platform services (such as Projects) might reject them.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used: `paths: "bindings, etag"`
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRNetworkManagement_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRNetworkManagement_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRNetworkManagement_Status_Details_Item : GTLRObject
@end


/**
 *  A simulated forwarding path is composed of multiple steps. Each step has a
 *  well-defined state and an associated configuration.
 */
@interface GTLRNetworkManagement_Step : GTLRObject

/** Display information of the final state "abort" and reason. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_AbortInfo *abort;

/**
 *  This is a step that leads to the final state Drop.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *causesDrop;

/** Display information of a Cloud SQL instance. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_CloudSQLInstanceInfo *cloudSqlInstance;

/** Display information of the final state "deliver" and reason. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_DeliverInfo *deliver;

/**
 *  A description of the step. Usually this is a summary of the state.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Display information of the final state "drop" and reason. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_DropInfo *drop;

/**
 *  Display information of the source and destination under analysis. The
 *  endpoint information in an intermediate state may differ with the initial
 *  input, as it might be modified by state like NAT, or Connection Proxy.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_EndpointInfo *endpoint;

/** Display information of a Compute Engine firewall rule. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_FirewallInfo *firewall;

/** Display information of the final state "forward" and reason. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_ForwardInfo *forward;

/** Display information of a Compute Engine forwarding rule. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_ForwardingRuleInfo *forwardingRule;

/** Display information of a Google Kubernetes Engine cluster master. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_GKEMasterInfo *gkeMaster;

/** Display information of a Compute Engine instance. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_InstanceInfo *instance;

/** Display information of the load balancers. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_LoadBalancerInfo *loadBalancer;

/** Display information of a Google Cloud network. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_NetworkInfo *network;

/** Project ID that contains the configuration this step is validating. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Display information of a Compute Engine route. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_RouteInfo *route;

/**
 *  Each step is in one of the pre-defined states.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_Step_State_Abort Final state: analysis is
 *        aborted. (Value: "ABORT")
 *    @arg @c kGTLRNetworkManagement_Step_State_ApplyEgressFirewallRule Config
 *        checking state: verify egress firewall rule. (Value:
 *        "APPLY_EGRESS_FIREWALL_RULE")
 *    @arg @c kGTLRNetworkManagement_Step_State_ApplyForwardingRule Config
 *        checking state: match forwarding rule. (Value:
 *        "APPLY_FORWARDING_RULE")
 *    @arg @c kGTLRNetworkManagement_Step_State_ApplyIngressFirewallRule Config
 *        checking state: verify ingress firewall rule. (Value:
 *        "APPLY_INGRESS_FIREWALL_RULE")
 *    @arg @c kGTLRNetworkManagement_Step_State_ApplyRoute Config checking
 *        state: verify route. (Value: "APPLY_ROUTE")
 *    @arg @c kGTLRNetworkManagement_Step_State_ArriveAtExternalLoadBalancer
 *        Forwarding state: arriving at a Compute Engine external load balancer.
 *        (Value: "ARRIVE_AT_EXTERNAL_LOAD_BALANCER")
 *    @arg @c kGTLRNetworkManagement_Step_State_ArriveAtInstance Forwarding
 *        state: arriving at a Compute Engine instance. (Value:
 *        "ARRIVE_AT_INSTANCE")
 *    @arg @c kGTLRNetworkManagement_Step_State_ArriveAtInternalLoadBalancer
 *        Forwarding state: arriving at a Compute Engine internal load balancer.
 *        (Value: "ARRIVE_AT_INTERNAL_LOAD_BALANCER")
 *    @arg @c kGTLRNetworkManagement_Step_State_ArriveAtVpnGateway Forwarding
 *        state: arriving at a Cloud VPN gateway. (Value:
 *        "ARRIVE_AT_VPN_GATEWAY")
 *    @arg @c kGTLRNetworkManagement_Step_State_ArriveAtVpnTunnel Forwarding
 *        state: arriving at a Cloud VPN tunnel. (Value: "ARRIVE_AT_VPN_TUNNEL")
 *    @arg @c kGTLRNetworkManagement_Step_State_Deliver Final state: packet
 *        could be delivered. (Value: "DELIVER")
 *    @arg @c kGTLRNetworkManagement_Step_State_Drop Final state: packet could
 *        be dropped. (Value: "DROP")
 *    @arg @c kGTLRNetworkManagement_Step_State_Forward Final state: packet
 *        could be forwarded to a network with an unknown configuration. (Value:
 *        "FORWARD")
 *    @arg @c kGTLRNetworkManagement_Step_State_Nat Transition state: packet
 *        header translated. (Value: "NAT")
 *    @arg @c kGTLRNetworkManagement_Step_State_ProxyConnection Transition
 *        state: original connection is terminated and a new proxied connection
 *        is initiated. (Value: "PROXY_CONNECTION")
 *    @arg @c kGTLRNetworkManagement_Step_State_SpoofingApproved Config checking
 *        state: packet sent or received under foreign IP address and allowed.
 *        (Value: "SPOOFING_APPROVED")
 *    @arg @c kGTLRNetworkManagement_Step_State_StartFromCloudSqlInstance
 *        Initial state: packet originating from a Cloud SQL instance. A
 *        CloudSQLInstanceInfo is populated with starting instance information.
 *        (Value: "START_FROM_CLOUD_SQL_INSTANCE")
 *    @arg @c kGTLRNetworkManagement_Step_State_StartFromGkeMaster Initial
 *        state: packet originating from a Google Kubernetes Engine cluster
 *        master. A GKEMasterInfo is populated with starting instance
 *        information. (Value: "START_FROM_GKE_MASTER")
 *    @arg @c kGTLRNetworkManagement_Step_State_StartFromInstance Initial state:
 *        packet originating from a Compute Engine instance. An InstanceInfo is
 *        populated with starting instance information. (Value:
 *        "START_FROM_INSTANCE")
 *    @arg @c kGTLRNetworkManagement_Step_State_StartFromInternet Initial state:
 *        packet originating from the internet. The endpoint information is
 *        populated. (Value: "START_FROM_INTERNET")
 *    @arg @c kGTLRNetworkManagement_Step_State_StartFromPrivateNetwork Initial
 *        state: packet originating from a VPC or on-premises network with
 *        internal source IP. If the source is a VPC network visible to the
 *        user, a NetworkInfo is populated with details of the network. (Value:
 *        "START_FROM_PRIVATE_NETWORK")
 *    @arg @c kGTLRNetworkManagement_Step_State_StateUnspecified Unspecified
 *        state. (Value: "STATE_UNSPECIFIED")
 *    @arg @c kGTLRNetworkManagement_Step_State_ViewerPermissionMissing Special
 *        state: viewer of the test result does not have permission to see the
 *        configuration in this step. (Value: "VIEWER_PERMISSION_MISSING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** Display information of a Compute Engine VPN gateway. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_VpnGatewayInfo *vpnGateway;

/** Display information of a Compute Engine VPN tunnel. */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_VpnTunnelInfo *vpnTunnel;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRNetworkManagement_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as '*' or 'storage.*') are not allowed. For more information
 *  see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRNetworkManagement_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Trace represents one simulated packet forwarding path. * Each trace contains
 *  multiple ordered steps. * Each step is in a particular state with associated
 *  configuration. * State is categorized as final or non-final states. * Each
 *  final state has a reason associated. * Each trace must end with a final
 *  state (the last step). ```
 *  |---------------------Trace----------------------| Step1(State) Step2(State)
 *  --- StepN(State(final)) ```
 */
@interface GTLRNetworkManagement_Trace : GTLRObject

/**
 *  Derived from the source and destination endpoints definition specified by
 *  user request, and validated by the data plane model. If there are multiple
 *  traces starting from different source locations, then the endpoint_info may
 *  be different between traces.
 */
@property(nonatomic, strong, nullable) GTLRNetworkManagement_EndpointInfo *endpointInfo;

/**
 *  A trace of a test contains multiple steps from the initial state to the
 *  final state (delivered, dropped, forwarded, or aborted). The steps are
 *  ordered by the processing sequence within the simulated network state
 *  machine. It is critical to preserve the order of the steps and avoid
 *  reordering or sorting them.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRNetworkManagement_Step *> *steps;

@end


/**
 *  For display only. Metadata associated with a Compute Engine VPN gateway.
 */
@interface GTLRNetworkManagement_VpnGatewayInfo : GTLRObject

/** Name of a VPN gateway. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** IP address of the VPN gateway. */
@property(nonatomic, copy, nullable) NSString *ipAddress;

/** URI of a Compute Engine network where the VPN gateway is configured. */
@property(nonatomic, copy, nullable) NSString *networkUri;

/** Name of a Google Cloud region where this VPN gateway is configured. */
@property(nonatomic, copy, nullable) NSString *region;

/** URI of a VPN gateway. */
@property(nonatomic, copy, nullable) NSString *uri;

/**
 *  A VPN tunnel that is associated with this VPN gateway. There may be multiple
 *  VPN tunnels configured on a VPN gateway, and only the one relevant to the
 *  test is displayed.
 */
@property(nonatomic, copy, nullable) NSString *vpnTunnelUri;

@end


/**
 *  For display only. Metadata associated with a Compute Engine VPN tunnel.
 */
@interface GTLRNetworkManagement_VpnTunnelInfo : GTLRObject

/** Name of a VPN tunnel. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** URI of a Compute Engine network where the VPN tunnel is configured. */
@property(nonatomic, copy, nullable) NSString *networkUri;

/** Name of a Google Cloud region where this VPN tunnel is configured. */
@property(nonatomic, copy, nullable) NSString *region;

/** URI of a VPN gateway at remote end of the tunnel. */
@property(nonatomic, copy, nullable) NSString *remoteGateway;

/** Remote VPN gateway's IP address. */
@property(nonatomic, copy, nullable) NSString *remoteGatewayIp;

/**
 *  Type of the routing policy.
 *
 *  Likely values:
 *    @arg @c kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_Dynamic Dynamic
 *        (BGP) routing. (Value: "DYNAMIC")
 *    @arg @c kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_PolicyBased
 *        Policy based routing. (Value: "POLICY_BASED")
 *    @arg @c kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_RouteBased Route
 *        based VPN. (Value: "ROUTE_BASED")
 *    @arg @c kGTLRNetworkManagement_VpnTunnelInfo_RoutingType_RoutingTypeUnspecified
 *        Unspecified type. Default value. (Value: "ROUTING_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *routingType;

/** URI of the VPN gateway at local end of the tunnel. */
@property(nonatomic, copy, nullable) NSString *sourceGateway;

/** Local VPN gateway's IP address. */
@property(nonatomic, copy, nullable) NSString *sourceGatewayIp;

/** URI of a VPN tunnel. */
@property(nonatomic, copy, nullable) NSString *uri;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
