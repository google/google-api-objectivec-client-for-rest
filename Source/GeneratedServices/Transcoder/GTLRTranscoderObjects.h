// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Transcoder API (transcoder/v1)
// Description:
//   This API converts video files into formats suitable for consumer
//   distribution.
// Documentation:
//   https://cloud.google.com/transcoder/docs/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRTranscoder_AdBreak;
@class GTLRTranscoder_Animation;
@class GTLRTranscoder_AnimationEnd;
@class GTLRTranscoder_AnimationFade;
@class GTLRTranscoder_AnimationStatic;
@class GTLRTranscoder_Audio;
@class GTLRTranscoder_AudioMapping;
@class GTLRTranscoder_AudioStream;
@class GTLRTranscoder_Color;
@class GTLRTranscoder_Crop;
@class GTLRTranscoder_Deblock;
@class GTLRTranscoder_Denoise;
@class GTLRTranscoder_EditAtom;
@class GTLRTranscoder_ElementaryStream;
@class GTLRTranscoder_H264CodecSettings;
@class GTLRTranscoder_H265CodecSettings;
@class GTLRTranscoder_Image;
@class GTLRTranscoder_Input;
@class GTLRTranscoder_Job;
@class GTLRTranscoder_JobConfig;
@class GTLRTranscoder_JobTemplate;
@class GTLRTranscoder_Manifest;
@class GTLRTranscoder_MuxStream;
@class GTLRTranscoder_NormalizedCoordinate;
@class GTLRTranscoder_Output;
@class GTLRTranscoder_Overlay;
@class GTLRTranscoder_Pad;
@class GTLRTranscoder_PreprocessingConfig;
@class GTLRTranscoder_PubsubDestination;
@class GTLRTranscoder_SegmentSettings;
@class GTLRTranscoder_SpriteSheet;
@class GTLRTranscoder_Status;
@class GTLRTranscoder_Status_Details_Item;
@class GTLRTranscoder_TextMapping;
@class GTLRTranscoder_TextStream;
@class GTLRTranscoder_VideoStream;
@class GTLRTranscoder_Vp9CodecSettings;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRTranscoder_AnimationFade.fadeType

/**
 *  Fade the overlay object into view.
 *
 *  Value: "FADE_IN"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_AnimationFade_FadeType_FadeIn;
/**
 *  Fade the overlay object out of view.
 *
 *  Value: "FADE_OUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_AnimationFade_FadeType_FadeOut;
/**
 *  The fade type is not specified.
 *
 *  Value: "FADE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_AnimationFade_FadeType_FadeTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Job.state

/**
 *  The job has failed. For additional information, see `failure_reason` and
 *  `failure_details`
 *
 *  Value: "FAILED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Failed;
/**
 *  The job is enqueued and will be picked up for processing soon.
 *
 *  Value: "PENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Pending;
/**
 *  The processing state is not specified.
 *
 *  Value: "PROCESSING_STATE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_ProcessingStateUnspecified;
/**
 *  The job is being processed.
 *
 *  Value: "RUNNING"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Running;
/**
 *  The job has been completed successfully.
 *
 *  Value: "SUCCEEDED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Job_State_Succeeded;

// ----------------------------------------------------------------------------
// GTLRTranscoder_Manifest.type

/**
 *  Create `DASH` manifest. The corresponding file extension is `.mpd`.
 *
 *  Value: "DASH"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Manifest_Type_Dash;
/**
 *  Create `HLS` manifest. The corresponding file extension is `.m3u8`.
 *
 *  Value: "HLS"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Manifest_Type_Hls;
/**
 *  The manifest type is not specified.
 *
 *  Value: "MANIFEST_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRTranscoder_Manifest_Type_ManifestTypeUnspecified;

/**
 *  Ad break.
 */
@interface GTLRTranscoder_AdBreak : GTLRObject

/**
 *  Start time in seconds for the ad break, relative to the output file
 *  timeline. The default is `0s`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

@end


/**
 *  Animation types.
 */
@interface GTLRTranscoder_Animation : GTLRObject

/** End previous animation. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AnimationEnd *animationEnd;

/** Display overlay object with fade animation. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AnimationFade *animationFade;

/** Display static overlay object. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AnimationStatic *animationStatic;

@end


/**
 *  End previous overlay animation from the video. Without AnimationEnd, the
 *  overlay object will keep the state of previous animation until the end of
 *  the video.
 */
@interface GTLRTranscoder_AnimationEnd : GTLRObject

/** The time to end overlay object, in seconds. Default: 0 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

@end


/**
 *  Display overlay object with fade animation.
 */
@interface GTLRTranscoder_AnimationFade : GTLRObject

/**
 *  The time to end the fade animation, in seconds. Default: `start_time_offset`
 *  + 1s
 */
@property(nonatomic, strong, nullable) GTLRDuration *endTimeOffset;

/**
 *  Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_AnimationFade_FadeType_FadeIn Fade the overlay
 *        object into view. (Value: "FADE_IN")
 *    @arg @c kGTLRTranscoder_AnimationFade_FadeType_FadeOut Fade the overlay
 *        object out of view. (Value: "FADE_OUT")
 *    @arg @c kGTLRTranscoder_AnimationFade_FadeType_FadeTypeUnspecified The
 *        fade type is not specified. (Value: "FADE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *fadeType;

/** The time to start the fade animation, in seconds. Default: 0 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

/**
 *  Normalized coordinates based on output video resolution. Valid values:
 *  `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay object. For
 *  example, use the x and y coordinates {0,0} to position the top-left corner
 *  of the overlay animation in the top-left corner of the output video.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_NormalizedCoordinate *xy;

@end


/**
 *  Display static overlay object.
 */
@interface GTLRTranscoder_AnimationStatic : GTLRObject

/** The time to start displaying the overlay object, in seconds. Default: 0 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

/**
 *  Normalized coordinates based on output video resolution. Valid values:
 *  `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay object. For
 *  example, use the x and y coordinates {0,0} to position the top-left corner
 *  of the overlay animation in the top-left corner of the output video.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_NormalizedCoordinate *xy;

@end


/**
 *  Audio preprocessing configuration.
 */
@interface GTLRTranscoder_Audio : GTLRObject

/**
 *  Enable boosting high frequency components. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *highBoost;

/**
 *  Enable boosting low frequency components. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lowBoost;

/**
 *  Specify audio loudness normalization in loudness units relative to full
 *  scale (LUFS). Enter a value between -24 and 0 (the default), where: * -24 is
 *  the Advanced Television Systems Committee (ATSC A/85) standard * -23 is the
 *  EU R128 broadcast standard * -19 is the prior standard for online mono audio
 *  * -18 is the ReplayGain standard * -16 is the prior standard for stereo
 *  audio * -14 is the new online audio standard recommended by Spotify, as well
 *  as Amazon Echo * 0 disables normalization
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lufs;

@end


/**
 *  The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`.
 */
@interface GTLRTranscoder_AudioMapping : GTLRObject

/**
 *  Required. The `EditAtom.key` that references the atom with audio inputs in
 *  the `Job.edit_list`.
 */
@property(nonatomic, copy, nullable) NSString *atomKey;

/**
 *  Audio volume control in dB. Negative values decrease volume, positive values
 *  increase. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gainDb;

/**
 *  Required. The zero-based index of the channel in the input audio stream.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputChannel;

/** Required. The `Input.key` that identifies the input file. */
@property(nonatomic, copy, nullable) NSString *inputKey;

/**
 *  Required. The zero-based index of the track in the input file.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputTrack;

/**
 *  Required. The zero-based index of the channel in the output audio stream.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outputChannel;

@end


/**
 *  Audio stream resource.
 */
@interface GTLRTranscoder_AudioStream : GTLRObject

/**
 *  Required. Audio bitrate in bits per second. Must be between 1 and
 *  10,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Number of audio channels. Must be between 1 and 6. The default is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *channelCount;

/**
 *  A list of channel names specifying layout of the audio channels. This only
 *  affects the metadata embedded in the container headers, if supported by the
 *  specified format. The default is `["fl", "fr"]`. Supported channel names: -
 *  `fl` - Front left channel - `fr` - Front right channel - `sl` - Side left
 *  channel - `sr` - Side right channel - `fc` - Front center channel - `lfe` -
 *  Low frequency
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *channelLayout;

/**
 *  The codec for this audio stream. The default is `aac`. Supported audio
 *  codecs: - `aac` - `aac-he` - `aac-he-v2` - `mp3` - `ac3` - `eac3`
 */
@property(nonatomic, copy, nullable) NSString *codec;

/** The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_AudioMapping *> *mapping;

/**
 *  The audio sample rate in Hertz. The default is 48000 Hertz.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sampleRateHertz;

@end


/**
 *  Color preprocessing configuration.
 */
@interface GTLRTranscoder_Color : GTLRObject

/**
 *  Control brightness of the video. Enter a value between -1 and 1, where -1 is
 *  minimum brightness and 1 is maximum brightness. 0 is no change. The default
 *  is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *brightness;

/**
 *  Control black and white contrast of the video. Enter a value between -1 and
 *  1, where -1 is minimum contrast and 1 is maximum contrast. 0 is no change.
 *  The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *contrast;

/**
 *  Control color saturation of the video. Enter a value between -1 and 1, where
 *  -1 is fully desaturated and 1 is maximum saturation. 0 is no change. The
 *  default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *saturation;

@end


/**
 *  Video cropping configuration for the input video. The cropped input video is
 *  scaled to match the output resolution.
 */
@interface GTLRTranscoder_Crop : GTLRObject

/**
 *  The number of pixels to crop from the bottom. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bottomPixels;

/**
 *  The number of pixels to crop from the left. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *leftPixels;

/**
 *  The number of pixels to crop from the right. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rightPixels;

/**
 *  The number of pixels to crop from the top. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *topPixels;

@end


/**
 *  Deblock preprocessing configuration.
 */
@interface GTLRTranscoder_Deblock : GTLRObject

/**
 *  Enable deblocker. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enabled;

/**
 *  Set strength of the deblocker. Enter a value between 0 and 1. The higher the
 *  value, the stronger the block removal. 0 is no deblocking. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strength;

@end


/**
 *  Denoise preprocessing configuration.
 */
@interface GTLRTranscoder_Denoise : GTLRObject

/**
 *  Set strength of the denoise. Enter a value between 0 and 1. The higher the
 *  value, the smoother the image. 0 is no denoising. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *strength;

/**
 *  Set the denoiser mode. The default is `standard`. Supported denoiser modes:
 *  - `standard` - `grain`
 */
@property(nonatomic, copy, nullable) NSString *tune;

@end


/**
 *  Edit atom.
 */
@interface GTLRTranscoder_EditAtom : GTLRObject

/**
 *  End time in seconds for the atom, relative to the input file timeline. When
 *  `end_time_offset` is not specified, the `inputs` are used until the end of
 *  the atom.
 */
@property(nonatomic, strong, nullable) GTLRDuration *endTimeOffset;

/**
 *  List of `Input.key`s identifying files that should be used in this atom. The
 *  listed `inputs` must have the same timeline.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *inputs;

/**
 *  A unique key for this atom. Must be specified when using advanced mapping.
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Start time in seconds for the atom, relative to the input file timeline. The
 *  default is `0s`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

@end


/**
 *  Encoding of an input file such as an audio, video, or text track. Elementary
 *  streams must be packaged before mapping and sharing between different output
 *  formats.
 */
@interface GTLRTranscoder_ElementaryStream : GTLRObject

/** Encoding of an audio stream. */
@property(nonatomic, strong, nullable) GTLRTranscoder_AudioStream *audioStream;

/** A unique key for this elementary stream. */
@property(nonatomic, copy, nullable) NSString *key;

/** Encoding of a text stream. For example, closed captions or subtitles. */
@property(nonatomic, strong, nullable) GTLRTranscoder_TextStream *textStream;

/** Encoding of a video stream. */
@property(nonatomic, strong, nullable) GTLRTranscoder_VideoStream *videoStream;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
 *  representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRTranscoder_Empty : GTLRObject
@end


/**
 *  H264 codec settings.
 */
@interface GTLRTranscoder_H264CodecSettings : GTLRObject

/**
 *  Specifies whether an open Group of Pictures (GOP) structure should be
 *  allowed or not. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowOpenGop;

/**
 *  Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and
 *  1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher
 *  value equals a lower bitrate but smoother image. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aqStrength;

/**
 *  The number of consecutive B-frames. Must be greater than or equal to zero.
 *  Must be less than `VideoStream.gop_frame_count` if set. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bFrameCount;

/**
 *  Required. The video bitrate in bits per second. The minimum value is 1,000.
 *  The maximum value is 800,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Allow B-pyramid for reference frame selection. This may not be supported on
 *  all decoders. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bPyramid;

/**
 *  Target CRF level. Must be between 10 and 36, where 10 is the highest quality
 *  and 36 is the most efficient compression. The default is 21.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crfLevel;

/**
 *  Use two-pass encoding strategy to achieve better video quality.
 *  `VideoStream.rate_control_mode` must be `vbr`. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableTwoPass;

/**
 *  The entropy coder to use. The default is `cabac`. Supported entropy coders:
 *  - `cavlc` - `cabac`
 */
@property(nonatomic, copy, nullable) NSString *entropyCoder;

/**
 *  Required. The target video frame rate in frames per second (FPS). Must be
 *  less than or equal to 120. Will default to the input frame rate if larger
 *  than the input frame rate. The API will generate an output FPS that is
 *  divisible by the input FPS, and smaller or equal to the target FPS. See
 *  [Calculating frame
 *  rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for more
 *  information.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *frameRate;

/**
 *  Select the GOP size based on the specified duration. The default is `3s`.
 *  Note that `gopDuration` must be less than or equal to
 *  [`segmentDuration`](#SegmentSettings), and
 *  [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *gopDuration;

/**
 *  Select the GOP size based on the specified frame count. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gopFrameCount;

/**
 *  The height of the video in pixels. Must be an even integer. When not
 *  specified, the height is adjusted to match the specified width and input
 *  aspect ratio. If both are omitted, the input height is used.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *heightPixels;

/**
 *  Pixel format to use. The default is `yuv420p`. Supported pixel formats: -
 *  `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format -
 *  `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format -
 *  `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format -
 *  `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 */
@property(nonatomic, copy, nullable) NSString *pixelFormat;

/**
 *  Enforces the specified codec preset. The default is `veryfast`. The
 *  available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Preset). Note
 *  that certain values for this field may cause the transcoder to override
 *  other fields you set in the `H264CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *preset;

/**
 *  Enforces the specified codec profile. The following profiles are supported:
 *  * `baseline` * `main` * `high` (default) The available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune). Note
 *  that certain values for this field may cause the transcoder to override
 *  other fields you set in the `H264CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *profile;

/**
 *  Specify the `rate_control_mode`. The default is `vbr`. Supported rate
 *  control modes: - `vbr` - variable bitrate - `crf` - constant rate factor
 */
@property(nonatomic, copy, nullable) NSString *rateControlMode;

/**
 *  Enforces the specified codec tune. The available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune). Note
 *  that certain values for this field may cause the transcoder to override
 *  other fields you set in the `H264CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *tune;

/**
 *  Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must
 *  be greater than zero. The default is equal to 90% of
 *  `VideoStream.vbv_size_bits`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvFullnessBits;

/**
 *  Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater
 *  than zero. The default is equal to `VideoStream.bitrate_bps`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvSizeBits;

/**
 *  The width of the video in pixels. Must be an even integer. When not
 *  specified, the width is adjusted to match the specified height and input
 *  aspect ratio. If both are omitted, the input width is used.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *widthPixels;

@end


/**
 *  H265 codec settings.
 */
@interface GTLRTranscoder_H265CodecSettings : GTLRObject

/**
 *  Specifies whether an open Group of Pictures (GOP) structure should be
 *  allowed or not. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowOpenGop;

/**
 *  Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and
 *  1, where 0 disables the quantizer and 1 maximizes the quantizer. A higher
 *  value equals a lower bitrate but smoother image. The default is 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *aqStrength;

/**
 *  The number of consecutive B-frames. Must be greater than or equal to zero.
 *  Must be less than `VideoStream.gop_frame_count` if set. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bFrameCount;

/**
 *  Required. The video bitrate in bits per second. The minimum value is 1,000.
 *  The maximum value is 800,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Allow B-pyramid for reference frame selection. This may not be supported on
 *  all decoders. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bPyramid;

/**
 *  Target CRF level. Must be between 10 and 36, where 10 is the highest quality
 *  and 36 is the most efficient compression. The default is 21.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crfLevel;

/**
 *  Use two-pass encoding strategy to achieve better video quality.
 *  `VideoStream.rate_control_mode` must be `vbr`. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *enableTwoPass;

/**
 *  Required. The target video frame rate in frames per second (FPS). Must be
 *  less than or equal to 120. Will default to the input frame rate if larger
 *  than the input frame rate. The API will generate an output FPS that is
 *  divisible by the input FPS, and smaller or equal to the target FPS. See
 *  [Calculating frame
 *  rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for more
 *  information.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *frameRate;

/**
 *  Select the GOP size based on the specified duration. The default is `3s`.
 *  Note that `gopDuration` must be less than or equal to
 *  [`segmentDuration`](#SegmentSettings), and
 *  [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *gopDuration;

/**
 *  Select the GOP size based on the specified frame count. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gopFrameCount;

/**
 *  The height of the video in pixels. Must be an even integer. When not
 *  specified, the height is adjusted to match the specified width and input
 *  aspect ratio. If both are omitted, the input height is used.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *heightPixels;

/**
 *  Pixel format to use. The default is `yuv420p`. Supported pixel formats: -
 *  `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format -
 *  `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format -
 *  `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format -
 *  `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 */
@property(nonatomic, copy, nullable) NSString *pixelFormat;

/**
 *  Enforces the specified codec preset. The default is `veryfast`. The
 *  available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265). Note that
 *  certain values for this field may cause the transcoder to override other
 *  fields you set in the `H265CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *preset;

/**
 *  Enforces the specified codec profile. The following profiles are supported:
 *  * 8-bit profiles * `main` (default) * `main-intra` * `mainstillpicture` *
 *  10-bit profiles * `main10` (default) * `main10-intra` * `main422-10` *
 *  `main422-10-intra` * `main444-10` * `main444-10-intra` * 12-bit profiles *
 *  `main12` (default) * `main12-intra` * `main422-12` * `main422-12-intra` *
 *  `main444-12` * `main444-12-intra` The available options are
 *  [FFmpeg-compatible](https://x265.readthedocs.io/). Note that certain values
 *  for this field may cause the transcoder to override other fields you set in
 *  the `H265CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *profile;

/**
 *  Specify the `rate_control_mode`. The default is `vbr`. Supported rate
 *  control modes: - `vbr` - variable bitrate - `crf` - constant rate factor
 */
@property(nonatomic, copy, nullable) NSString *rateControlMode;

/**
 *  Enforces the specified codec tune. The available options are
 *  [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265). Note that
 *  certain values for this field may cause the transcoder to override other
 *  fields you set in the `H265CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *tune;

/**
 *  Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must
 *  be greater than zero. The default is equal to 90% of
 *  `VideoStream.vbv_size_bits`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvFullnessBits;

/**
 *  Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater
 *  than zero. The default is equal to `VideoStream.bitrate_bps`.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vbvSizeBits;

/**
 *  The width of the video in pixels. Must be an even integer. When not
 *  specified, the width is adjusted to match the specified height and input
 *  aspect ratio. If both are omitted, the input width is used.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *widthPixels;

@end


/**
 *  Overlaid jpeg image.
 */
@interface GTLRTranscoder_Image : GTLRObject

/**
 *  Target image opacity. Valid values are from `1.0` (solid, default) to `0.0`
 *  (transparent), exclusive. Set this to a value greater than `0.0`.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *alpha;

/**
 *  Normalized image resolution, based on output video resolution. Valid values:
 *  `0.0`–`1.0`. To respect the original image aspect ratio, set either `x` or
 *  `y` to `0.0`. To use the original image resolution, set both `x` and `y` to
 *  `0.0`.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_NormalizedCoordinate *resolution;

/**
 *  Required. URI of the JPEG image in Cloud Storage. For example,
 *  `gs://bucket/inputs/image.jpeg`. JPEG is the only supported image type.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Input asset.
 */
@interface GTLRTranscoder_Input : GTLRObject

/**
 *  A unique key for this input. Must be specified when using advanced mapping
 *  and edit lists.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** Preprocessing configurations. */
@property(nonatomic, strong, nullable) GTLRTranscoder_PreprocessingConfig *preprocessingConfig;

/**
 *  URI of the media. Input files must be at least 5 seconds in duration and
 *  stored in Cloud Storage (for example, `gs://bucket/inputs/file.mp4`). If
 *  empty, the value will be populated from `Job.input_uri`.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Transcoding job resource.
 */
@interface GTLRTranscoder_Job : GTLRObject

/** The configuration for this job. */
@property(nonatomic, strong, nullable) GTLRTranscoder_JobConfig *config;

/** Output only. The time the job was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/** Output only. The time the transcoding finished. */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  Output only. An error object that describes the reason for the failure. This
 *  property is always present when `state` is `FAILED`.
 */
@property(nonatomic, strong, nullable) GTLRTranscoder_Status *error;

/**
 *  Input only. Specify the `input_uri` to populate empty `uri` fields in each
 *  element of `Job.config.inputs` or `JobTemplate.config.inputs` when using
 *  template. URI of the media. Input files must be at least 5 seconds in
 *  duration and stored in Cloud Storage (for example,
 *  `gs://bucket/inputs/file.mp4`).
 */
@property(nonatomic, copy, nullable) NSString *inputUri;

/**
 *  The resource name of the job. Format:
 *  `projects/{project_number}/locations/{location}/jobs/{job}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Input only. Specify the `output_uri` to populate an empty
 *  `Job.config.output.uri` or `JobTemplate.config.output.uri` when using
 *  template. URI for the output file(s). For example,
 *  `gs://my-bucket/outputs/`.
 */
@property(nonatomic, copy, nullable) NSString *outputUri;

/** Output only. The time the transcoding started. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Output only. The current state of the job.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Job_State_Failed The job has failed. For
 *        additional information, see `failure_reason` and `failure_details`
 *        (Value: "FAILED")
 *    @arg @c kGTLRTranscoder_Job_State_Pending The job is enqueued and will be
 *        picked up for processing soon. (Value: "PENDING")
 *    @arg @c kGTLRTranscoder_Job_State_ProcessingStateUnspecified The
 *        processing state is not specified. (Value:
 *        "PROCESSING_STATE_UNSPECIFIED")
 *    @arg @c kGTLRTranscoder_Job_State_Running The job is being processed.
 *        (Value: "RUNNING")
 *    @arg @c kGTLRTranscoder_Job_State_Succeeded The job has been completed
 *        successfully. (Value: "SUCCEEDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Input only. Specify the `template_id` to use for populating `Job.config`.
 *  The default is `preset/web-hd`. Preset Transcoder templates: -
 *  `preset/{preset_id}` - User defined JobTemplate: `{job_template_id}`
 */
@property(nonatomic, copy, nullable) NSString *templateId;

/**
 *  Job time to live value in days, which will be effective after job
 *  completion. Job should be deleted automatically after the given TTL. Enter a
 *  value between 1 and 90. The default is 30.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ttlAfterCompletionDays;

@end


/**
 *  Job configuration
 */
@interface GTLRTranscoder_JobConfig : GTLRObject

/**
 *  List of ad breaks. Specifies where to insert ad break tags in the output
 *  manifests.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_AdBreak *> *adBreaks;

/**
 *  List of `Edit atom`s. Defines the ultimate timeline of the resulting file or
 *  manifest.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_EditAtom *> *editList;

/** List of elementary streams. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_ElementaryStream *> *elementaryStreams;

/** List of input assets stored in Cloud Storage. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Input *> *inputs;

/** List of output manifests. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Manifest *> *manifests;

/** List of multiplexing settings for output streams. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_MuxStream *> *muxStreams;

/** Output configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Output *output;

/** List of overlays on the output video, in descending Z-order. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Overlay *> *overlays;

/** Destination on Pub/Sub. */
@property(nonatomic, strong, nullable) GTLRTranscoder_PubsubDestination *pubsubDestination;

/** List of output sprite sheets. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_SpriteSheet *> *spriteSheets;

@end


/**
 *  Transcoding job template resource.
 */
@interface GTLRTranscoder_JobTemplate : GTLRObject

/** The configuration for this template. */
@property(nonatomic, strong, nullable) GTLRTranscoder_JobConfig *config;

/**
 *  The resource name of the job template. Format:
 *  `projects/{project_number}/locations/{location}/jobTemplates/{job_template}`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Response message for `TranscoderService.ListJobs`.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobs" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRTranscoder_ListJobsResponse : GTLRCollectionObject

/**
 *  List of jobs in the specified region.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Job *> *jobs;

/** The pagination token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** List of regions that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Response message for `TranscoderService.ListJobTemplates`.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobTemplates" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRTranscoder_ListJobTemplatesResponse : GTLRCollectionObject

/**
 *  List of job templates in the specified region.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_JobTemplate *> *jobTemplates;

/** The pagination token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/** List of regions that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Manifest configuration.
 */
@interface GTLRTranscoder_Manifest : GTLRObject

/**
 *  The name of the generated file. The default is `manifest` with the extension
 *  suffix corresponding to the `Manifest.type`.
 */
@property(nonatomic, copy, nullable) NSString *fileName;

/**
 *  Required. List of user given `MuxStream.key`s that should appear in this
 *  manifest. When `Manifest.type` is `HLS`, a media manifest with name
 *  `MuxStream.key` and `.m3u8` extension is generated for each element of the
 *  `Manifest.mux_streams`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *muxStreams;

/**
 *  Required. Type of the manifest, can be `HLS` or `DASH`.
 *
 *  Likely values:
 *    @arg @c kGTLRTranscoder_Manifest_Type_Dash Create `DASH` manifest. The
 *        corresponding file extension is `.mpd`. (Value: "DASH")
 *    @arg @c kGTLRTranscoder_Manifest_Type_Hls Create `HLS` manifest. The
 *        corresponding file extension is `.m3u8`. (Value: "HLS")
 *    @arg @c kGTLRTranscoder_Manifest_Type_ManifestTypeUnspecified The manifest
 *        type is not specified. (Value: "MANIFEST_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Multiplexing settings for output stream.
 */
@interface GTLRTranscoder_MuxStream : GTLRObject

/**
 *  The container format. The default is `mp4` Supported container formats: -
 *  `ts` - `fmp4`- the corresponding file extension is `.m4s` - `mp4` - `vtt`
 */
@property(nonatomic, copy, nullable) NSString *container;

/** List of `ElementaryStream.key`s multiplexed in this stream. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *elementaryStreams;

/**
 *  The name of the generated file. The default is `MuxStream.key` with the
 *  extension suffix corresponding to the `MuxStream.container`. Individual
 *  segments also have an incremental 10-digit zero-padded suffix starting from
 *  0 before the extension, such as `mux_stream0000000123.ts`.
 */
@property(nonatomic, copy, nullable) NSString *fileName;

/**
 *  A unique key for this multiplexed stream. HLS media manifests will be named
 *  `MuxStream.key` with the `.m3u8` extension suffix.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** Segment settings for `ts`, `fmp4` and `vtt`. */
@property(nonatomic, strong, nullable) GTLRTranscoder_SegmentSettings *segmentSettings;

@end


/**
 *  2D normalized coordinates. Default: `{0.0, 0.0}`
 */
@interface GTLRTranscoder_NormalizedCoordinate : GTLRObject

/**
 *  Normalized x coordinate.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *x;

/**
 *  Normalized y coordinate.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *y;

@end


/**
 *  Location of output file(s) in a Cloud Storage bucket.
 */
@interface GTLRTranscoder_Output : GTLRObject

/**
 *  URI for the output file(s). For example, `gs://my-bucket/outputs/`. If empty
 *  the value is populated from `Job.output_uri`.
 */
@property(nonatomic, copy, nullable) NSString *uri;

@end


/**
 *  Overlay configuration.
 */
@interface GTLRTranscoder_Overlay : GTLRObject

/**
 *  List of Animations. The list should be chronological, without any time
 *  overlap.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Animation *> *animations;

/** Image overlay. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Image *image;

@end


/**
 *  Pad filter configuration for the input video. The padded input video is
 *  scaled after padding with black to match the output resolution.
 */
@interface GTLRTranscoder_Pad : GTLRObject

/**
 *  The number of pixels to add to the bottom. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bottomPixels;

/**
 *  The number of pixels to add to the left. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *leftPixels;

/**
 *  The number of pixels to add to the right. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rightPixels;

/**
 *  The number of pixels to add to the top. The default is 0.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *topPixels;

@end


/**
 *  Preprocessing configurations.
 */
@interface GTLRTranscoder_PreprocessingConfig : GTLRObject

/** Audio preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Audio *audio;

/** Color preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Color *color;

/** Specify the video cropping configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Crop *crop;

/** Deblock preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Deblock *deblock;

/** Denoise preprocessing configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Denoise *denoise;

/** Specify the video pad filter configuration. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Pad *pad;

@end


/**
 *  A Pub/Sub destination.
 */
@interface GTLRTranscoder_PubsubDestination : GTLRObject

/**
 *  The name of the Pub/Sub topic to publish job completion notification to. For
 *  example: `projects/{project}/topics/{topic}`.
 */
@property(nonatomic, copy, nullable) NSString *topic;

@end


/**
 *  Segment settings for `ts`, `fmp4` and `vtt`.
 */
@interface GTLRTranscoder_SegmentSettings : GTLRObject

/**
 *  Required. Create an individual segment file. The default is `false`.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *individualSegments;

/**
 *  Duration of the segments in seconds. The default is `6.0s`. Note that
 *  `segmentDuration` must be greater than or equal to
 *  [`gopDuration`](#videostream), and `segmentDuration` must be divisible by
 *  [`gopDuration`](#videostream).
 */
@property(nonatomic, strong, nullable) GTLRDuration *segmentDuration;

@end


/**
 *  Sprite sheet configuration.
 */
@interface GTLRTranscoder_SpriteSheet : GTLRObject

/**
 *  The maximum number of sprites per row in a sprite sheet. The default is 0,
 *  which indicates no maximum limit.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *columnCount;

/**
 *  End time in seconds, relative to the output file timeline. When
 *  `end_time_offset` is not specified, the sprites are generated until the end
 *  of the output file.
 */
@property(nonatomic, strong, nullable) GTLRDuration *endTimeOffset;

/**
 *  Required. File name prefix for the generated sprite sheets. Each sprite
 *  sheet has an incremental 10-digit zero-padded suffix starting from 0 before
 *  the extension, such as `sprite_sheet0000000123.jpeg`.
 */
@property(nonatomic, copy, nullable) NSString *filePrefix;

/** Format type. The default is `jpeg`. Supported formats: - `jpeg` */
@property(nonatomic, copy, nullable) NSString *format;

/**
 *  Starting from `0s`, create sprites at regular intervals. Specify the
 *  interval value in seconds.
 */
@property(nonatomic, strong, nullable) GTLRDuration *interval;

/**
 *  The quality of the generated sprite sheet. Enter a value between 1 and 100,
 *  where 1 is the lowest quality and 100 is the highest quality. The default is
 *  100. A high quality value corresponds to a low image data compression ratio.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *quality;

/**
 *  The maximum number of rows per sprite sheet. When the sprite sheet is full,
 *  a new sprite sheet is created. The default is 0, which indicates no maximum
 *  limit.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCount;

/**
 *  Required. The height of sprite in pixels. Must be an even integer. To
 *  preserve the source aspect ratio, set the SpriteSheet.sprite_height_pixels
 *  field or the SpriteSheet.sprite_width_pixels field, but not both (the API
 *  will automatically calculate the missing field).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *spriteHeightPixels;

/**
 *  Required. The width of sprite in pixels. Must be an even integer. To
 *  preserve the source aspect ratio, set the SpriteSheet.sprite_width_pixels
 *  field or the SpriteSheet.sprite_height_pixels field, but not both (the API
 *  will automatically calculate the missing field).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *spriteWidthPixels;

/**
 *  Start time in seconds, relative to the output file timeline. Determines the
 *  first sprite to pick. The default is `0s`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *startTimeOffset;

/**
 *  Total number of sprites. Create the specified number of sprites distributed
 *  evenly across the timeline of the output media. The default is 100.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalCount;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). Each `Status` message contains
 *  three pieces of data: error code, error message, and error details. You can
 *  find out more about this error model and how to work with it in the [API
 *  Design Guide](https://cloud.google.com/apis/design/errors).
 */
@interface GTLRTranscoder_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRTranscoder_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRTranscoder_Status_Details_Item : GTLRObject
@end


/**
 *  The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`.
 */
@interface GTLRTranscoder_TextMapping : GTLRObject

/**
 *  Required. The `EditAtom.key` that references atom with text inputs in the
 *  `Job.edit_list`.
 */
@property(nonatomic, copy, nullable) NSString *atomKey;

/** Required. The `Input.key` that identifies the input file. */
@property(nonatomic, copy, nullable) NSString *inputKey;

/**
 *  Required. The zero-based index of the track in the input file.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputTrack;

@end


/**
 *  Encoding of a text stream. For example, closed captions or subtitles.
 */
@interface GTLRTranscoder_TextStream : GTLRObject

/**
 *  The codec for this text stream. The default is `webvtt`. Supported text
 *  codecs: - `srt` - `ttml` - `cea608` - `cea708` - `webvtt`
 */
@property(nonatomic, copy, nullable) NSString *codec;

/** The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`. */
@property(nonatomic, strong, nullable) NSArray<GTLRTranscoder_TextMapping *> *mapping;

@end


/**
 *  Video stream resource.
 */
@interface GTLRTranscoder_VideoStream : GTLRObject

/** H264 codec settings. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H264CodecSettings *h264;

/** H265 codec settings. */
@property(nonatomic, strong, nullable) GTLRTranscoder_H265CodecSettings *h265;

/** VP9 codec settings. */
@property(nonatomic, strong, nullable) GTLRTranscoder_Vp9CodecSettings *vp9;

@end


/**
 *  VP9 codec settings.
 */
@interface GTLRTranscoder_Vp9CodecSettings : GTLRObject

/**
 *  Required. The video bitrate in bits per second. The minimum value is 1,000.
 *  The maximum value is 480,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bitrateBps;

/**
 *  Target CRF level. Must be between 10 and 36, where 10 is the highest quality
 *  and 36 is the most efficient compression. The default is 21.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *crfLevel;

/**
 *  Required. The target video frame rate in frames per second (FPS). Must be
 *  less than or equal to 120. Will default to the input frame rate if larger
 *  than the input frame rate. The API will generate an output FPS that is
 *  divisible by the input FPS, and smaller or equal to the target FPS. See
 *  [Calculating frame
 *  rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for more
 *  information.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *frameRate;

/**
 *  Select the GOP size based on the specified duration. The default is `3s`.
 *  Note that `gopDuration` must be less than or equal to
 *  [`segmentDuration`](#SegmentSettings), and
 *  [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *gopDuration;

/**
 *  Select the GOP size based on the specified frame count. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *gopFrameCount;

/**
 *  The height of the video in pixels. Must be an even integer. When not
 *  specified, the height is adjusted to match the specified width and input
 *  aspect ratio. If both are omitted, the input height is used.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *heightPixels;

/**
 *  Pixel format to use. The default is `yuv420p`. Supported pixel formats: -
 *  `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format -
 *  `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format -
 *  `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format -
 *  `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format
 */
@property(nonatomic, copy, nullable) NSString *pixelFormat;

/**
 *  Enforces the specified codec profile. The following profiles are supported:
 *  * `profile0` (default) * `profile1` * `profile2` * `profile3` The available
 *  options are [WebM-compatible](https://www.webmproject.org/vp9/profiles/).
 *  Note that certain values for this field may cause the transcoder to override
 *  other fields you set in the `Vp9CodecSettings` message.
 */
@property(nonatomic, copy, nullable) NSString *profile;

/**
 *  Specify the `rate_control_mode`. The default is `vbr`. Supported rate
 *  control modes: - `vbr` - variable bitrate - `crf` - constant rate factor
 */
@property(nonatomic, copy, nullable) NSString *rateControlMode;

/**
 *  The width of the video in pixels. Must be an even integer. When not
 *  specified, the width is adjusted to match the specified height and input
 *  aspect ratio. If both are omitted, the input width is used.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *widthPixels;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
