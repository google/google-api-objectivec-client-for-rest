// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Pub/Sub Lite API (pubsublite/v1)
// Documentation:
//   https://cloud.google.com/pubsub/lite/docs

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRPubsubLite_Capacity;
@class GTLRPubsubLite_Cursor;
@class GTLRPubsubLite_DeliveryConfig;
@class GTLRPubsubLite_PartitionConfig;
@class GTLRPubsubLite_PartitionCursor;
@class GTLRPubsubLite_RetentionConfig;
@class GTLRPubsubLite_Subscription;
@class GTLRPubsubLite_Topic;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRPubsubLite_DeliveryConfig.deliveryRequirement

/**
 *  The server will not deliver a published message to subscribers until the
 *  message has been successfully written to storage. This will result in higher
 *  end-to-end latency, but consistent delivery.
 *
 *  Value: "DELIVER_AFTER_STORED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPubsubLite_DeliveryConfig_DeliveryRequirement_DeliverAfterStored;
/**
 *  The server does not wait for a published message to be successfully written
 *  to storage before delivering it to subscribers.
 *
 *  Value: "DELIVER_IMMEDIATELY"
 */
FOUNDATION_EXTERN NSString * const kGTLRPubsubLite_DeliveryConfig_DeliveryRequirement_DeliverImmediately;
/**
 *  Default value. This value is unused.
 *
 *  Value: "DELIVERY_REQUIREMENT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRPubsubLite_DeliveryConfig_DeliveryRequirement_DeliveryRequirementUnspecified;

/**
 *  The throughput capacity configuration for each partition.
 */
@interface GTLRPubsubLite_Capacity : GTLRObject

/**
 *  Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *publishMibPerSec;

/**
 *  Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <=
 *  32.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *subscribeMibPerSec;

@end


/**
 *  Request for CommitCursor.
 */
@interface GTLRPubsubLite_CommitCursorRequest : GTLRObject

/** The new value for the committed cursor. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_Cursor *cursor;

/**
 *  The partition for which to update the cursor. Partitions are zero indexed,
 *  so `partition` must be in the range [0, topic.num_partitions).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partition;

@end


/**
 *  Response for CommitCursor.
 */
@interface GTLRPubsubLite_CommitCursorResponse : GTLRObject
@end


/**
 *  Compute the current head cursor for a partition.
 */
@interface GTLRPubsubLite_ComputeHeadCursorRequest : GTLRObject

/**
 *  Required. The partition for which we should compute the head cursor.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partition;

@end


/**
 *  Response containing the head cursor for the requested topic and partition.
 */
@interface GTLRPubsubLite_ComputeHeadCursorResponse : GTLRObject

/** The head cursor. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_Cursor *headCursor;

@end


/**
 *  Compute statistics about a range of messages in a given topic and partition.
 */
@interface GTLRPubsubLite_ComputeMessageStatsRequest : GTLRObject

/**
 *  The exclusive end of the range. The range is empty if end_cursor <=
 *  start_cursor. Specifying a start_cursor before the first message and an
 *  end_cursor after the last message will retrieve all messages.
 */
@property(nonatomic, strong, nullable) GTLRPubsubLite_Cursor *endCursor;

/**
 *  Required. The partition for which we should compute message stats.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partition;

/** The inclusive start of the range. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_Cursor *startCursor;

@end


/**
 *  Response containing stats for messages in the requested topic and partition.
 */
@interface GTLRPubsubLite_ComputeMessageStatsResponse : GTLRObject

/**
 *  The number of quota bytes accounted to these messages.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *messageBytes;

/**
 *  The count of messages.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *messageCount;

/**
 *  The minimum event timestamp across these messages. For the purposes of this
 *  computation, if a message does not have an event time, we use the publish
 *  time. The timestamp will be unset if there are no messages.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *minimumEventTime;

/**
 *  The minimum publish timestamp across these messages. Note that publish
 *  timestamps within a partition are not guaranteed to be non-decreasing. The
 *  timestamp will be unset if there are no messages.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *minimumPublishTime;

@end


/**
 *  A cursor that describes the position of a message within a topic partition.
 */
@interface GTLRPubsubLite_Cursor : GTLRObject

/**
 *  The offset of a message within a topic partition. Must be greater than or
 *  equal 0.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

@end


/**
 *  The settings for a subscription's message delivery.
 */
@interface GTLRPubsubLite_DeliveryConfig : GTLRObject

/**
 *  The DeliveryRequirement for this subscription.
 *
 *  Likely values:
 *    @arg @c kGTLRPubsubLite_DeliveryConfig_DeliveryRequirement_DeliverAfterStored
 *        The server will not deliver a published message to subscribers until
 *        the message has been successfully written to storage. This will result
 *        in higher end-to-end latency, but consistent delivery. (Value:
 *        "DELIVER_AFTER_STORED")
 *    @arg @c kGTLRPubsubLite_DeliveryConfig_DeliveryRequirement_DeliverImmediately
 *        The server does not wait for a published message to be successfully
 *        written to storage before delivering it to subscribers. (Value:
 *        "DELIVER_IMMEDIATELY")
 *    @arg @c kGTLRPubsubLite_DeliveryConfig_DeliveryRequirement_DeliveryRequirementUnspecified
 *        Default value. This value is unused. (Value:
 *        "DELIVERY_REQUIREMENT_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *deliveryRequirement;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance: service Foo { rpc
 *  Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON
 *  representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRPubsubLite_Empty : GTLRObject
@end


/**
 *  Response for ListPartitionCursors
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "partitionCursors" property. If returned as the result of a query,
 *        it should support automatic pagination (when @c shouldFetchNextPages
 *        is enabled).
 */
@interface GTLRPubsubLite_ListPartitionCursorsResponse : GTLRCollectionObject

/**
 *  A token, which can be sent as `page_token` to retrieve the next page. If
 *  this field is omitted, there are no subsequent pages.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The partition cursors from this request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRPubsubLite_PartitionCursor *> *partitionCursors;

@end


/**
 *  Response for ListSubscriptions.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "subscriptions" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRPubsubLite_ListSubscriptionsResponse : GTLRCollectionObject

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of subscriptions in the requested parent. The order of the
 *  subscriptions is unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRPubsubLite_Subscription *> *subscriptions;

@end


/**
 *  Response for ListTopics.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "topics" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRPubsubLite_ListTopicsResponse : GTLRCollectionObject

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of topic in the requested parent. The order of the topics is
 *  unspecified.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRPubsubLite_Topic *> *topics;

@end


/**
 *  Response for ListTopicSubscriptions.
 */
@interface GTLRPubsubLite_ListTopicSubscriptionsResponse : GTLRObject

/**
 *  A token that can be sent as `page_token` to retrieve the next page of
 *  results. If this field is omitted, there are no more results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The names of subscriptions attached to the topic. The order of the
 *  subscriptions is unspecified.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *subscriptions;

@end


/**
 *  The settings for a topic's partitions.
 */
@interface GTLRPubsubLite_PartitionConfig : GTLRObject

/** The capacity configuration. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_Capacity *capacity;

/**
 *  The number of partitions in the topic. Must be at least 1. Once a topic has
 *  been created the number of partitions can be increased but not decreased.
 *  Message ordering is not guaranteed across a topic resize. For more
 *  information see
 *  https://cloud.google.com/pubsub/lite/docs/topics#scaling_capacity
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/**
 *  DEPRECATED: Use capacity instead which can express a superset of
 *  configurations. Every partition in the topic is allocated throughput
 *  equivalent to `scale` times the standard partition throughput (4 MiB/s).
 *  This is also reflected in the cost of this topic; a topic with `scale` of 2
 *  and count of 10 is charged for 20 partitions. This value must be in the
 *  range [1,4].
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  A pair of a Cursor and the partition it is for.
 */
@interface GTLRPubsubLite_PartitionCursor : GTLRObject

/** The value of the cursor. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_Cursor *cursor;

/**
 *  The partition this is for.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partition;

@end


/**
 *  The settings for a topic's message retention.
 */
@interface GTLRPubsubLite_RetentionConfig : GTLRObject

/**
 *  How long a published message is retained. If unset, messages will be
 *  retained as long as the bytes retained for each partition is below
 *  `per_partition_bytes`.
 */
@property(nonatomic, strong, nullable) GTLRDuration *period;

/**
 *  The provisioned storage, in bytes, per partition. If the number of bytes
 *  stored in any of the topic's partitions grows beyond this value, older
 *  messages will be dropped to make room for newer ones, regardless of the
 *  value of `period`.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *perPartitionBytes;

@end


/**
 *  Metadata about a subscription resource.
 */
@interface GTLRPubsubLite_Subscription : GTLRObject

/** The settings for this subscription's message delivery. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_DeliveryConfig *deliveryConfig;

/**
 *  The name of the subscription. Structured like:
 *  projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the topic this subscription is attached to. Structured like:
 *  projects/{project_number}/locations/{location}/topics/{topic_id}
 */
@property(nonatomic, copy, nullable) NSString *topic;

@end


/**
 *  Metadata about a topic resource.
 */
@interface GTLRPubsubLite_Topic : GTLRObject

/**
 *  The name of the topic. Structured like:
 *  projects/{project_number}/locations/{location}/topics/{topic_id}
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The settings for this topic's partitions. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_PartitionConfig *partitionConfig;

/** The settings for this topic's message retention. */
@property(nonatomic, strong, nullable) GTLRPubsubLite_RetentionConfig *retentionConfig;

@end


/**
 *  Response for GetTopicPartitions.
 */
@interface GTLRPubsubLite_TopicPartitions : GTLRObject

/**
 *  The number of partitions in the topic.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *partitionCount;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
