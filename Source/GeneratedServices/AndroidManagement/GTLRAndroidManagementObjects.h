// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Android Management API (androidmanagement/v1)
// Description:
//   The Android Management API provides remote enterprise management of Android
//   devices and apps.
// Documentation:
//   https://developers.google.com/android/management

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAndroidManagement_AlwaysOnVpnPackage;
@class GTLRAndroidManagement_ApiLevelCondition;
@class GTLRAndroidManagement_ApplicationEvent;
@class GTLRAndroidManagement_ApplicationPermission;
@class GTLRAndroidManagement_ApplicationPolicy;
@class GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration;
@class GTLRAndroidManagement_ApplicationReport;
@class GTLRAndroidManagement_ChoosePrivateKeyRule;
@class GTLRAndroidManagement_ComplianceRule;
@class GTLRAndroidManagement_Device;
@class GTLRAndroidManagement_DeviceSettings;
@class GTLRAndroidManagement_Display;
@class GTLRAndroidManagement_ExternalData;
@class GTLRAndroidManagement_HardwareInfo;
@class GTLRAndroidManagement_HardwareStatus;
@class GTLRAndroidManagement_ManagedConfigurationTemplate;
@class GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables;
@class GTLRAndroidManagement_ManagedProperty;
@class GTLRAndroidManagement_ManagedPropertyEntry;
@class GTLRAndroidManagement_MemoryEvent;
@class GTLRAndroidManagement_MemoryInfo;
@class GTLRAndroidManagement_NetworkInfo;
@class GTLRAndroidManagement_NonComplianceDetail;
@class GTLRAndroidManagement_NonComplianceDetailCondition;
@class GTLRAndroidManagement_Operation;
@class GTLRAndroidManagement_Operation_Metadata;
@class GTLRAndroidManagement_Operation_Response;
@class GTLRAndroidManagement_PackageNameList;
@class GTLRAndroidManagement_PasswordRequirements;
@class GTLRAndroidManagement_PermissionGrant;
@class GTLRAndroidManagement_PersistentPreferredActivity;
@class GTLRAndroidManagement_Policy;
@class GTLRAndroidManagement_Policy_OpenNetworkConfiguration;
@class GTLRAndroidManagement_PowerManagementEvent;
@class GTLRAndroidManagement_ProxyInfo;
@class GTLRAndroidManagement_SigninDetail;
@class GTLRAndroidManagement_SoftwareInfo;
@class GTLRAndroidManagement_Status;
@class GTLRAndroidManagement_Status_Details_Item;
@class GTLRAndroidManagement_StatusReportingSettings;
@class GTLRAndroidManagement_SystemUpdate;
@class GTLRAndroidManagement_TermsAndConditions;
@class GTLRAndroidManagement_User;
@class GTLRAndroidManagement_UserFacingMessage;
@class GTLRAndroidManagement_UserFacingMessage_LocalizedMessages;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationEvent.eventType

/**
 *  This value is disallowed.
 *
 *  Value: "APPLICATION_EVENT_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_ApplicationEventTypeUnspecified;
/**
 *  The app was changed, for example, a component was enabled or disabled.
 *
 *  Value: "CHANGED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Changed;
/**
 *  The app data was cleared.
 *
 *  Value: "DATA_CLEARED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_DataCleared;
/**
 *  The app was installed.
 *
 *  Value: "INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Installed;
/**
 *  The app was pinned to the foreground.
 *
 *  Value: "PINNED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Pinned;
/**
 *  The app was removed.
 *
 *  Value: "REMOVED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Removed;
/**
 *  A new version of the app has been installed, replacing the old version.
 *
 *  Value: "REPLACED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Replaced;
/**
 *  The app was restarted.
 *
 *  Value: "RESTARTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Restarted;
/**
 *  The app was unpinned.
 *
 *  Value: "UNPINNED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationEvent_EventType_Unpinned;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.delegatedScopes

/** Value: "BLOCK_UNINSTALL" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_BlockUninstall;
/** Value: "CERT_INSTALL" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_CertInstall;
/** Value: "DELEGATED_SCOPE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_DelegatedScopeUnspecified;
/** Value: "ENABLE_SYSTEM_APP" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_EnableSystemApp;
/** Value: "MANAGED_CONFIGURATIONS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_ManagedConfigurations;
/** Value: "PACKAGE_ACCESS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_PackageAccess;
/** Value: "PERMISSION_GRANT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DelegatedScopes_PermissionGrant;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.installType

/**
 *  The app is available to install.
 *
 *  Value: "AVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Available;
/**
 *  The app is blocked and can't be installed. If the app was installed under a
 *  previous policy, it will be uninstalled.
 *
 *  Value: "BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Blocked;
/**
 *  The app is automatically installed and can't be removed by the user.
 *
 *  Value: "FORCE_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled;
/**
 *  Unspecified. Defaults to AVAILABLE.
 *
 *  Value: "INSTALL_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified;
/**
 *  The app is automatically installed and can be removed by the user.
 *
 *  Value: "PREINSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.applicationSource

/**
 *  The app was sideloaded from an unspecified source.
 *
 *  Value: "APPLICATION_SOURCE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_ApplicationSourceUnspecified;
/**
 *  The app was installed from the Google Play Store.
 *
 *  Value: "INSTALLED_FROM_PLAY_STORE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_InstalledFromPlayStore;
/**
 *  This is a system app from the device's factory image.
 *
 *  Value: "SYSTEM_APP_FACTORY_VERSION"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppFactoryVersion;
/**
 *  This is an updated system app.
 *
 *  Value: "SYSTEM_APP_UPDATED_VERSION"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppUpdatedVersion;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationReport.state

/**
 *  App is installed on the device
 *
 *  Value: "INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_Installed;
/**
 *  App was removed from the device
 *
 *  Value: "REMOVED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationReport_State_Removed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.errorCode

/**
 *  The API level of the device does not support this command.
 *
 *  Value: "API_LEVEL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_ApiLevel;
/**
 *  There was no error.
 *
 *  Value: "COMMAND_ERROR_CODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_CommandErrorCodeUnspecified;
/**
 *  The command has an invalid parameter value.
 *
 *  Value: "INVALID_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) does not support the
 *  command.
 *
 *  Value: "MANAGEMENT_MODE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_ManagementMode;
/**
 *  An unknown error occurred.
 *
 *  Value: "UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_Unknown;
/**
 *  The device doesn't support the command. Updating Android Device Policy to
 *  the latest version may resolve the issue.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ErrorCode_Unsupported;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.resetPasswordFlags

/** Value: "DO_NOT_ASK_CREDENTIALS_ON_BOOT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_DoNotAskCredentialsOnBoot;
/** Value: "LOCK_NOW" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_LockNow;
/** Value: "REQUIRE_ENTRY" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_RequireEntry;
/** Value: "RESET_PASSWORD_FLAG_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_ResetPasswordFlagUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.type

/**
 *  This value is disallowed.
 *
 *  Value: "COMMAND_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified;
/**
 *  Lock the device, as if the lock screen timeout had expired.
 *
 *  Value: "LOCK"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Lock;
/**
 *  Reboot the device. Only supported on API level 24+.
 *
 *  Value: "REBOOT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Reboot;
/**
 *  Reset the user's password.
 *
 *  Value: "RESET_PASSWORD"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_ResetPassword;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.appliedState

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Active;
/**
 *  The device was deleted. This state will never be returned by an API call,
 *  but is used in the final status report published to Cloud Pub/Sub when the
 *  device acknowledges the deletion.
 *
 *  Value: "DELETED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Disabled;
/**
 *  The device is being provisioned. Newly enrolled devices are in this state
 *  until they have a policy applied.
 *
 *  Value: "PROVISIONING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.managementMode

/**
 *  Device owner. Android Device Policy has full control over the device.
 *
 *  Value: "DEVICE_OWNER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_DeviceOwner;
/**
 *  This value is disallowed.
 *
 *  Value: "MANAGEMENT_MODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_ManagementModeUnspecified;
/**
 *  Profile owner. Android Device Policy has control over a managed profile on
 *  the device.
 *
 *  Value: "PROFILE_OWNER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_ManagementMode_ProfileOwner;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.state

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Active;
/**
 *  The device was deleted. This state will never be returned by an API call,
 *  but is used in the final status report published to Cloud Pub/Sub when the
 *  device acknowledges the deletion.
 *
 *  Value: "DELETED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Disabled;
/**
 *  The device is being provisioned. Newly enrolled devices are in this state
 *  until they have a policy applied.
 *
 *  Value: "PROVISIONING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_DeviceSettings.encryptionStatus

/**
 *  Encryption is not currently active, but is currently being activated.
 *
 *  Value: "ACTIVATING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Activating;
/**
 *  Encryption is active.
 *
 *  Value: "ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Active;
/**
 *  Encryption is active, but an encryption key is not set by the user.
 *
 *  Value: "ACTIVE_DEFAULT_KEY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActiveDefaultKey;
/**
 *  Encryption is active, and the encryption key is tied to the user profile.
 *
 *  Value: "ACTIVE_PER_USER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActivePerUser;
/**
 *  Unspecified. No device should have this type.
 *
 *  Value: "ENCRYPTION_STATUS_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_EncryptionStatusUnspecified;
/**
 *  Encryption is supported by the device, but is not currently active.
 *
 *  Value: "INACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Inactive;
/**
 *  Encryption is not supported by the device.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Unsupported;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Display.state

/**
 *  This value is disallowed.
 *
 *  Value: "DISPLAY_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_DisplayStateUnspecified;
/**
 *  Display is dozing in a low power state
 *
 *  Value: "DOZE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Doze;
/**
 *  Display is off.
 *
 *  Value: "OFF"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Off;
/**
 *  Display is on.
 *
 *  Value: "ON"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_On;
/**
 *  Display is dozing in a suspended low power state.
 *
 *  Value: "SUSPENDED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Suspended;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Enterprise.enabledNotificationTypes

/** Value: "COMMAND" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Command;
/** Value: "COMPLIANCE_REPORT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_ComplianceReport;
/** Value: "ENROLLMENT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Enrollment;
/** Value: "NOTIFICATION_TYPE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_NotificationTypeUnspecified;
/** Value: "STATUS_REPORT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_StatusReport;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ManagedProperty.type

/**
 *  A property of boolean type.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Bool;
/**
 *  An array of property bundles.
 *
 *  Value: "BUNDLE_ARRAY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_BundleArray;
/**
 *  A choice of one item from a set.
 *
 *  Value: "CHOICE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Choice;
/**
 *  A hidden restriction of string type (the default value can be used to pass
 *  along information that can't be modified, such as a version code).
 *
 *  Value: "HIDDEN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Hidden;
/**
 *  A property of integer type.
 *
 *  Value: "INTEGER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Integer;
/**
 *  Not used.
 *
 *  Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified;
/**
 *  A choice of multiple items from a set.
 *
 *  Value: "MULTISELECT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Multiselect;
/**
 *  A property of string type.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_String;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_MemoryEvent.eventType

/**
 *  A new external storage medium was detected. The reported byte count is the
 *  total capacity of the storage medium.
 *
 *  Value: "EXTERNAL_STORAGE_DETECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected;
/**
 *  Free space in an external storage medium was measured.
 *
 *  Value: "EXTERNAL_STORAGE_MEASURED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured;
/**
 *  An external storage medium was removed. The reported byte count is zero.
 *
 *  Value: "EXTERNAL_STORAGE_REMOVED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved;
/**
 *  Free space in internal storage was measured.
 *
 *  Value: "INTERNAL_STORAGE_MEASURED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "MEMORY_EVENT_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified;
/**
 *  Free space in RAM was measured.
 *
 *  Value: "RAM_MEASURED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.installationFailureReason

/**
 *  The installation is still in progress.
 *
 *  Value: "IN_PROGRESS"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress;
/**
 *  An unknown condition is preventing the app from being installed. Some
 *  potential reasons are that the device doesn't have enough storage, the
 *  device network connection is unreliable, or the installation is taking
 *  longer than expected. The installation will be retried automatically.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown;
/**
 *  This value is disallowed.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified;
/**
 *  There are no licenses available to assign to the user.
 *
 *  Value: "NO_LICENSES_REMAINING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining;
/**
 *  The app has not been approved by the admin.
 *
 *  Value: "NOT_APPROVED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved;
/**
 *  The app is not available in the user's country.
 *
 *  Value: "NOT_AVAILABLE_IN_COUNTRY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry;
/**
 *  The app is incompatible with the device.
 *
 *  Value: "NOT_COMPATIBLE_WITH_DEVICE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice;
/**
 *  The enterprise is no longer enrolled with managed Play or the admin has not
 *  accepted the latest managed Play terms of service.
 *
 *  Value: "NOT_ENROLLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled;
/**
 *  The app was not found in Play.
 *
 *  Value: "NOT_FOUND"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound;
/**
 *  The app has new permissions that have not been accepted by the admin.
 *
 *  Value: "PERMISSIONS_NOT_ACCEPTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted;
/**
 *  The user is no longer valid. The user may have been deleted or disabled.
 *
 *  Value: "USER_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.nonComplianceReason

/**
 *  The setting is not supported in the API level of the Android version running
 *  on the device.
 *
 *  Value: "API_LEVEL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel;
/**
 *  The setting can't be applied to the app because the app doesn't support it,
 *  for example because its target SDK version is not high enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible;
/**
 *  A blocked app is installed.
 *
 *  Value: "APP_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled;
/**
 *  The app required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled;
/**
 *  The app is installed, but it hasn't been updated to the minimum version code
 *  specified by policy.
 *
 *  Value: "APP_NOT_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) doesn't support the
 *  setting.
 *
 *  Value: "MANAGEMENT_MODE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ManagementMode;
/**
 *  This value is disallowed.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting hasn't been applied at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetailCondition.nonComplianceReason

/**
 *  The setting is not supported in the API level of the Android version running
 *  on the device.
 *
 *  Value: "API_LEVEL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel;
/**
 *  The setting can't be applied to the app because the app doesn't support it,
 *  for example because its target SDK version is not high enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible;
/**
 *  A blocked app is installed.
 *
 *  Value: "APP_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled;
/**
 *  The app required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled;
/**
 *  The app is installed, but it hasn't been updated to the minimum version code
 *  specified by policy.
 *
 *  Value: "APP_NOT_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue;
/**
 *  The management mode (profile owner, device owner, etc.) doesn't support the
 *  setting.
 *
 *  Value: "MANAGEMENT_MODE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ManagementMode;
/**
 *  This value is disallowed.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting hasn't been applied at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordQuality

/**
 *  The password must contain alphabetic (or symbol) characters.
 *
 *  Value: "ALPHABETIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic;
/**
 *  The password must contain both numeric and alphabetic (or symbol)
 *  characters.
 *
 *  Value: "ALPHANUMERIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric;
/**
 *  The device must be secured with a low-security biometric recognition
 *  technology, at minimum. This includes technologies that can recognize the
 *  identity of an individual that are roughly equivalent to a 3-digit PIN
 *  (false detection is less than 1 in 1,000).
 *
 *  Value: "BIOMETRIC_WEAK"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak;
/**
 *  The password must contain at least a letter, a numerical digit and a special
 *  symbol. Other password constraints, for example, password_minimum_letters
 *  are enforced.
 *
 *  Value: "COMPLEX"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex;
/**
 *  The password must contain numeric characters.
 *
 *  Value: "NUMERIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric;
/**
 *  The password must contain numeric characters with no repeating (4444) or
 *  ordered (1234, 4321, 2468) sequences.
 *
 *  Value: "NUMERIC_COMPLEX"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex;
/**
 *  There are no password requirements.
 *
 *  Value: "PASSWORD_QUALITY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified;
/**
 *  A password is required, but there are no restrictions on what the password
 *  must contain.
 *
 *  Value: "SOMETHING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordScope

/**
 *  The password requirements are only applied to the device.
 *
 *  Value: "SCOPE_DEVICE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeDevice;
/**
 *  The password requirements are only applied to the work profile.
 *
 *  Value: "SCOPE_PROFILE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeProfile;
/**
 *  The scope is unspecified. The password requirements are applied to the work
 *  profile for work profile devices and the whole device for fully managed or
 *  dedicated devices.
 *
 *  Value: "SCOPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PermissionGrant.policy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.androidDevicePolicyTracks

/** Value: "APP_TRACK_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_AppTrackUnspecified;
/** Value: "BETA" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_Beta;
/** Value: "PRODUCTION" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AndroidDevicePolicyTracks_Production;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.appAutoUpdatePolicy

/**
 *  Apps are auto-updated at any time. Data charges may apply.
 *
 *  Value: "ALWAYS"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Always;
/**
 *  The auto-update policy is not set. Equivalent to CHOICE_TO_THE_USER.
 *
 *  Value: "APP_AUTO_UPDATE_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_AppAutoUpdatePolicyUnspecified;
/**
 *  The user can control auto-updates.
 *
 *  Value: "CHOICE_TO_THE_USER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_ChoiceToTheUser;
/**
 *  Apps are never auto-updated.
 *
 *  Value: "NEVER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Never;
/**
 *  Apps are auto-updated over Wi-Fi only.
 *
 *  Value: "WIFI_ONLY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_WifiOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.encryptionPolicy

/**
 *  Encryption required but no password required to boot
 *
 *  Value: "ENABLED_WITHOUT_PASSWORD"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithoutPassword;
/**
 *  Encryption required with password required to boot
 *
 *  Value: "ENABLED_WITH_PASSWORD"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithPassword;
/**
 *  This value is ignored, i.e. no encryption required
 *
 *  Value: "ENCRYPTION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_EncryptionPolicy_EncryptionPolicyUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.keyguardDisabledFeatures

/** Value: "ALL_FEATURES" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_AllFeatures;
/** Value: "CAMERA" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Camera;
/** Value: "DISABLE_FINGERPRINT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_DisableFingerprint;
/** Value: "DISABLE_REMOTE_INPUT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_DisableRemoteInput;
/** Value: "KEYGUARD_DISABLED_FEATURE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_KeyguardDisabledFeatureUnspecified;
/** Value: "NOTIFICATIONS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_Notifications;
/** Value: "TRUST_AGENTS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_TrustAgents;
/** Value: "UNREDACTED_NOTIFICATIONS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_KeyguardDisabledFeatures_UnredactedNotifications;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.locationMode

/**
 *  Only the network location provider is enabled.
 *
 *  Value: "BATTERY_SAVING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_BatterySaving;
/**
 *  All location detection methods are enabled, including GPS, networks, and
 *  other sensors.
 *
 *  Value: "HIGH_ACCURACY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_HighAccuracy;
/**
 *  The current device value is not modified.
 *
 *  Value: "LOCATION_MODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_LocationModeUnspecified;
/**
 *  Location detection is disabled.
 *
 *  Value: "OFF"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_Off;
/**
 *  Only GPS and other sensors are enabled.
 *
 *  Value: "SENSORS_ONLY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_LocationMode_SensorsOnly;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.playStoreMode

/**
 *  All apps are available and any app that should not be on the device should
 *  be explicitly markeds as 'BLOCKED' in the applications policy.
 *
 *  Value: "BLACKLIST"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_Blacklist;
/**
 *  Unspecified. Defaults to WHITELIST.
 *
 *  Value: "PLAY_STORE_MODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_PlayStoreModeUnspecified;
/**
 *  Only apps that are in the policy are available and any app not in the policy
 *  will be automatically uninstalled from the device.
 *
 *  Value: "WHITELIST"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_PlayStoreMode_Whitelist;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.stayOnPluggedModes

/** Value: "AC" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Ac;
/** Value: "BATTERY_PLUGGED_MODE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_BatteryPluggedModeUnspecified;
/** Value: "USB" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Usb;
/** Value: "WIRELESS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Wireless;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PowerManagementEvent.eventType

/**
 *  Battery level was measured.
 *
 *  Value: "BATTERY_LEVEL_COLLECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected;
/**
 *  The device entered low-power mode.
 *
 *  Value: "BATTERY_LOW"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow;
/**
 *  The device exited low-power mode.
 *
 *  Value: "BATTERY_OKAY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay;
/**
 *  The device booted.
 *
 *  Value: "BOOT_COMPLETED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted;
/**
 *  The device started charging.
 *
 *  Value: "POWER_CONNECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected;
/**
 *  The device stopped charging.
 *
 *  Value: "POWER_DISCONNECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified;
/**
 *  The device shut down.
 *
 *  Value: "SHUTDOWN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SystemUpdate.type

/**
 *  Install automatically as soon as an update is available.
 *
 *  Value: "AUTOMATIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Automatic;
/**
 *  Postpone automatic install up to a maximum of 30 days.
 *
 *  Value: "POSTPONE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Postpone;
/**
 *  Follow the default update behavior for the device, which typically requires
 *  the user to accept system updates.
 *
 *  Value: "SYSTEM_UPDATE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified;
/**
 *  Install automatically within a daily maintenance window. This also
 *  configures Play apps to be updated within the window. This is strongly
 *  recommended for kiosk devices because this is the only way apps persistently
 *  pinned to the foreground can be updated by Play.
 *
 *  Value: "WINDOWED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Windowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebToken.permissions

/** Value: "APPROVE_APPS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_ApproveApps;
/** Value: "WEB_TOKEN_PERMISSION_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_WebTokenPermissionUnspecified;

/**
 *  Configuration for an always-on VPN connection.
 */
@interface GTLRAndroidManagement_AlwaysOnVpnPackage : GTLRObject

/**
 *  Disallows networking when the VPN is not connected.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockdownEnabled;

/** The package name of the VPN app. */
@property(nonatomic, copy, nullable) NSString *packageName;

@end


/**
 *  A compliance rule condition which is satisfied if the Android Framework API
 *  level on the device doesn't meet a minimum requirement. There can only be
 *  one rule with this type of condition per policy.
 */
@interface GTLRAndroidManagement_ApiLevelCondition : GTLRObject

/**
 *  The minimum desired Android Framework API level. If the device doesn't meet
 *  the minimum requirement, this condition is satisfied. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minApiLevel;

@end


/**
 *  Information about an app.
 */
@interface GTLRAndroidManagement_Application : GTLRObject

/**
 *  The set of managed properties available to be pre-configured for the app.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *managedProperties;

/**
 *  The name of the app in the form
 *  enterprises/{enterpriseId}/applications/{package_name}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The permissions required by the app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPermission *> *permissions;

/** The title of the app. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  An app-related event.
 */
@interface GTLRAndroidManagement_ApplicationEvent : GTLRObject

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  App event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_ApplicationEventTypeUnspecified
 *        This value is disallowed. (Value:
 *        "APPLICATION_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Changed The app
 *        was changed, for example, a component was enabled or disabled. (Value:
 *        "CHANGED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_DataCleared The
 *        app data was cleared. (Value: "DATA_CLEARED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Installed The
 *        app was installed. (Value: "INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Pinned The app
 *        was pinned to the foreground. (Value: "PINNED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Removed The app
 *        was removed. (Value: "REMOVED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Replaced A new
 *        version of the app has been installed, replacing the old version.
 *        (Value: "REPLACED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Restarted The
 *        app was restarted. (Value: "RESTARTED")
 *    @arg @c kGTLRAndroidManagement_ApplicationEvent_EventType_Unpinned The app
 *        was unpinned. (Value: "UNPINNED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  A permission required by the app.
 */
@interface GTLRAndroidManagement_ApplicationPermission : GTLRObject

/**
 *  A longer description of the permission, providing more detail on what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The name of the permission. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/** An opaque string uniquely identifying the permission. Not localized. */
@property(nonatomic, copy, nullable) NSString *permissionId;

@end


/**
 *  Policy for an individual app.
 */
@interface GTLRAndroidManagement_ApplicationPolicy : GTLRObject

/**
 *  The default policy for all permissions requested by the app. If specified,
 *  this overrides the policy-level default_permission_policy which applies to
 *  all apps. It does not override the permission_grants which applies to all
 *  apps.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/** The scopes delegated to the app from Android Device Policy. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *delegatedScopes;

/**
 *  Whether the app is disabled. When disabled, the app data is still preserved.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disabled;

/**
 *  The type of installation to perform.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Available The
 *        app is available to install. (Value: "AVAILABLE")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Blocked The
 *        app is blocked and can't be installed. If the app was installed under
 *        a previous policy, it will be uninstalled. (Value: "BLOCKED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled
 *        The app is automatically installed and can't be removed by the user.
 *        (Value: "FORCE_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified
 *        Unspecified. Defaults to AVAILABLE. (Value:
 *        "INSTALL_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled
 *        The app is automatically installed and can be removed by the user.
 *        (Value: "PREINSTALLED")
 */
@property(nonatomic, copy, nullable) NSString *installType;

/**
 *  Whether the app is allowed to lock itself in full-screen mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockTaskAllowed;

/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: <table> <tr><td><i>type</i></td><td><i>JSON
 *  value</i></td></tr> <tr><td>BOOL</td><td>true or false</td></tr>
 *  <tr><td>STRING</td><td>string</td></tr>
 *  <tr><td>INTEGER</td><td>number</td></tr>
 *  <tr><td>CHOICE</td><td>string</td></tr> <tr><td>MULTISELECT</td><td>array of
 *  strings</td></tr> <tr><td>HIDDEN</td><td>string</td></tr>
 *  <tr><td>BUNDLE_ARRAY</td><td>array of objects</td></tr> </table>
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration *managedConfiguration;

/**
 *  The managed configurations template for the app, saved from the managed
 *  configurations iframe. This field is ignored if managed_configuration is
 *  set.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ManagedConfigurationTemplate *managedConfigurationTemplate;

/**
 *  The minimum version of the app that runs on the device. If set, the device
 *  attempts to update the app to at least this version code. If the app is not
 *  up-to-date, the device will contain a NonComplianceDetail with
 *  non_compliance_reason set to APP_NOT_UPDATED. The app must already be
 *  published to Google Play with a version code greater than or equal to this
 *  value. At most 20 apps may specify a minimum version code per policy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimumVersionCode;

/**
 *  The package name of the app. For example, com.google.android.youtube for the
 *  YouTube app.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  Explicit permission grants or denials for the app. These values override the
 *  default_permission_policy and permission_grants which apply to all apps.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

@end


/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: <table> <tr><td><i>type</i></td><td><i>JSON
 *  value</i></td></tr> <tr><td>BOOL</td><td>true or false</td></tr>
 *  <tr><td>STRING</td><td>string</td></tr>
 *  <tr><td>INTEGER</td><td>number</td></tr>
 *  <tr><td>CHOICE</td><td>string</td></tr> <tr><td>MULTISELECT</td><td>array of
 *  strings</td></tr> <tr><td>HIDDEN</td><td>string</td></tr>
 *  <tr><td>BUNDLE_ARRAY</td><td>array of objects</td></tr> </table>
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration : GTLRObject
@end


/**
 *  Information reported about an installed app.
 */
@interface GTLRAndroidManagement_ApplicationReport : GTLRObject

/**
 *  The source of the package.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_ApplicationSourceUnspecified
 *        The app was sideloaded from an unspecified source. (Value:
 *        "APPLICATION_SOURCE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_InstalledFromPlayStore
 *        The app was installed from the Google Play Store. (Value:
 *        "INSTALLED_FROM_PLAY_STORE")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppFactoryVersion
 *        This is a system app from the device's factory image. (Value:
 *        "SYSTEM_APP_FACTORY_VERSION")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_ApplicationSource_SystemAppUpdatedVersion
 *        This is an updated system app. (Value: "SYSTEM_APP_UPDATED_VERSION")
 */
@property(nonatomic, copy, nullable) NSString *applicationSource;

/** The display name of the app. */
@property(nonatomic, copy, nullable) NSString *displayName;

/** List of app events. The most recent 20 events are stored in the list. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationEvent *> *events;

/** The package name of the app that installed this app. */
@property(nonatomic, copy, nullable) NSString *installerPackageName;

/** Package name of the app. */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The SHA-256 hash of the app's APK file, which can be used to verify the app
 *  hasn't been modified. Each byte of the hash value is represented as a
 *  two-digit hexadecimal number.
 */
@property(nonatomic, copy, nullable) NSString *packageSha256Hash;

/**
 *  The SHA-1 hash of each android.content.pm.Signature
 *  (https://developer.android.com/reference/android/content/pm/Signature.html)
 *  associated with the app package. Each byte of each hash value is represented
 *  as a two-digit hexadecimal number.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *signingKeyCertFingerprints;

/**
 *  Application state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_Installed App is
 *        installed on the device (Value: "INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationReport_State_Removed App was
 *        removed from the device (Value: "REMOVED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The app version code, which can be used to determine whether one version is
 *  more recent than another.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *versionCode;

/** The app version as displayed to the user. */
@property(nonatomic, copy, nullable) NSString *versionName;

@end


/**
 *  A rule for automatically choosing a private key and certificate to
 *  authenticate the device to a server.
 */
@interface GTLRAndroidManagement_ChoosePrivateKeyRule : GTLRObject

/**
 *  The package names for which outgoing requests are subject to this rule. If
 *  no package names are specified, then the rule applies to all packages. For
 *  each package name listed, the rule applies to that package and all other
 *  packages that shared the same Android UID. The SHA256 hash of the signing
 *  key signatures of each package_name will be verified against those provided
 *  by Play
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

/** The alias of the private key to be used. */
@property(nonatomic, copy, nullable) NSString *privateKeyAlias;

/**
 *  The URL pattern to match against the URL of the outgoing request. The
 *  pattern may contain asterisk (*) wildcards. Any URL is matched if
 *  unspecified.
 */
@property(nonatomic, copy, nullable) NSString *urlPattern;

@end


/**
 *  A command.
 */
@interface GTLRAndroidManagement_Command : GTLRObject

/**
 *  The timestamp at which the command was created. The timestamp is
 *  automatically generated by the server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The duration for which the command is valid. The command will expire if not
 *  executed by the device during this time. The default duration if unspecified
 *  is ten minutes. There is no maximum duration.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  If the command failed, an error code explaining the failure. This is not set
 *  when the command is cancelled by the caller.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_ApiLevel The API level of
 *        the device does not support this command. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_CommandErrorCodeUnspecified
 *        There was no error. (Value: "COMMAND_ERROR_CODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_InvalidValue The command
 *        has an invalid parameter value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_ManagementMode The
 *        management mode (profile owner, device owner, etc.) does not support
 *        the command. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_Unknown An unknown error
 *        occurred. (Value: "UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_Command_ErrorCode_Unsupported The device
 *        doesn't support the command. Updating Android Device Policy to the
 *        latest version may resolve the issue. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *errorCode;

/**
 *  For commands of type RESET_PASSWORD, optionally specifies the new password.
 */
@property(nonatomic, copy, nullable) NSString *newPassword NS_RETURNS_NOT_RETAINED;

/** For commands of type RESET_PASSWORD, optionally specifies flags. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resetPasswordFlags;

/**
 *  The type of the command.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified This
 *        value is disallowed. (Value: "COMMAND_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Lock Lock the device, as if
 *        the lock screen timeout had expired. (Value: "LOCK")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Reboot Reboot the device. Only
 *        supported on API level 24+. (Value: "REBOOT")
 *    @arg @c kGTLRAndroidManagement_Command_Type_ResetPassword Reset the user's
 *        password. (Value: "RESET_PASSWORD")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The resource name of the user that owns the device in the form
 *  enterprises/{enterpriseId}/users/{userId}. This is automatically generated
 *  by the server based on the device the command is sent to.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  A rule declaring which mitigating actions to take when a device is not
 *  compliant with its policy. For every rule, there is always an implicit
 *  mitigating action to set policy_compliant to false for the Device resource,
 *  and display a message on the device indicating that the device is not
 *  compliant with its policy. Other mitigating actions may optionally be taken
 *  as well, depending on the field values in the rule.
 */
@interface GTLRAndroidManagement_ComplianceRule : GTLRObject

/**
 *  A condition which is satisfied if the Android Framework API level on the
 *  device doesn't meet a minimum requirement.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApiLevelCondition *apiLevelCondition;

/**
 *  If set to true, the rule includes a mitigating action to disable apps so
 *  that the device is effectively disabled, but app data is preserved. If the
 *  device is running an app in locked task mode, the app will be closed and a
 *  UI showing the reason for non-compliance will be displayed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableApps;

/**
 *  A condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NonComplianceDetailCondition *nonComplianceDetailCondition;

/**
 *  If set, the rule includes a mitigating action to disable apps specified in
 *  the list, but app data is preserved.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNamesToDisable;

@end


/**
 *  A device owned by an enterprise. Unless otherwise noted, all fields are
 *  read-only and can't be modified by enterprises.devices.patch.
 */
@interface GTLRAndroidManagement_Device : GTLRObject

/**
 *  The API level of the Android platform version running on the device.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *apiLevel;

/**
 *  Reports for apps installed on the device. This information is only available
 *  when application_reports_enabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationReport *> *applicationReports;

/** The name of the policy currently applied to the device. */
@property(nonatomic, copy, nullable) NSString *appliedPolicyName;

/**
 *  The version of the policy currently applied to the device.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appliedPolicyVersion;

/**
 *  The state currently applied to the device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Active The device is
 *        active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Deleted The device was
 *        deleted. This state will never be returned by an API call, but is used
 *        in the final status report published to Cloud Pub/Sub when the device
 *        acknowledges the deletion. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified
 *        This value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Provisioning The device
 *        is being provisioned. Newly enrolled devices are in this state until
 *        they have a policy applied. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *appliedState;

/**
 *  Device settings information. This information is only available if
 *  deviceSettingsEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_DeviceSettings *deviceSettings;

/**
 *  If the device state is DISABLED, an optional message that is displayed on
 *  the device indicating the reason the device is disabled. This field can be
 *  modified by a patch request.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *disabledReason;

/**
 *  Detailed information about displays on the device. This information is only
 *  available if displayInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Display *> *displays;

/** The time of device enrollment. */
@property(nonatomic, strong, nullable) GTLRDateTime *enrollmentTime;

/**
 *  If the device was enrolled with an enrollment token with additional data
 *  provided, this field contains that data.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenData;

/**
 *  If the device was enrolled with an enrollment token, this field contains the
 *  name of the token.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenName;

/** Detailed information about the device hardware. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_HardwareInfo *hardwareInfo;

/**
 *  Hardware status samples in chronological order. This information is only
 *  available if hardwareStatusEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_HardwareStatus *> *hardwareStatusSamples;

/** Deprecated. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicyComplianceReportTime;

/** The last time the device fetched its policy. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicySyncTime;

/** The last time the device sent a status report. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastStatusReportTime;

/**
 *  The type of management mode Android Device Policy takes on the device. This
 *  influences which policy settings are supported.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_DeviceOwner Device
 *        owner. Android Device Policy has full control over the device. (Value:
 *        "DEVICE_OWNER")
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_ManagementModeUnspecified
 *        This value is disallowed. (Value: "MANAGEMENT_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_ManagementMode_ProfileOwner Profile
 *        owner. Android Device Policy has control over a managed profile on the
 *        device. (Value: "PROFILE_OWNER")
 */
@property(nonatomic, copy, nullable) NSString *managementMode;

/**
 *  Events related to memory and storage measurements in chronological order.
 *  This information is only available if memoryInfoEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_MemoryEvent *> *memoryEvents;

/**
 *  Memory information. This information is only available if memoryInfoEnabled
 *  is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MemoryInfo *memoryInfo;

/**
 *  The name of the device in the form
 *  enterprises/{enterpriseId}/devices/{deviceId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Device network information. This information is only available if
 *  networkInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NetworkInfo *networkInfo;

/** Details about policy settings that the device is not compliant with. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_NonComplianceDetail *> *nonComplianceDetails;

/**
 *  Whether the device is compliant with its policy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *policyCompliant;

/**
 *  The name of the policy applied to the device, in the form
 *  enterprises/{enterpriseId}/policies/{policyId}. If not specified, the
 *  policy_name for the device's user is applied. This field can be modified by
 *  a patch request. You can specify only the policyId when calling
 *  enterprises.devices.patch, as long as the policyId doesnt contain any
 *  slashes. The rest of the policy name is inferred.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  Power management events on the device in chronological order. This
 *  information is only available if powerManagementEventsEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PowerManagementEvent *> *powerManagementEvents;

/**
 *  If the same physical device has been enrolled multiple times, this field
 *  contains its previous device names. The serial number is used as the unique
 *  identifier to determine if the same physical device has enrolled previously.
 *  The names are in chronological order.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *previousDeviceNames;

/**
 *  Detailed information about the device software. This information is only
 *  available if softwareInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SoftwareInfo *softwareInfo;

/**
 *  The state to be applied to the device. This field can be modified by a patch
 *  request. Note that when calling enterprises.devices.patch, ACTIVE and
 *  DISABLED are the only allowable values. To enter the device into a DELETED
 *  state, call enterprises.devices.delete.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_State_Active The device is active.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_State_Deleted The device was
 *        deleted. This state will never be returned by an API call, but is used
 *        in the final status report published to Cloud Pub/Sub when the device
 *        acknowledges the deletion. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_State_DeviceStateUnspecified This
 *        value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Provisioning The device is
 *        being provisioned. Newly enrolled devices are in this state until they
 *        have a policy applied. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/** The user who owns the device. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_User *user;

/**
 *  The resource name of the user that owns this device in the form
 *  enterprises/{enterpriseId}/users/{userId}.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Information about security related device settings on device.
 */
@interface GTLRAndroidManagement_DeviceSettings : GTLRObject

/**
 *  Whether ADB (https://developer.android.com/studio/command-line/adb.html) is
 *  enabled on the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adbEnabled;

/**
 *  Whether developer mode is enabled on the device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *developmentSettingsEnabled;

/**
 *  Encryption status from DevicePolicyManager.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Activating
 *        Encryption is not currently active, but is currently being activated.
 *        (Value: "ACTIVATING")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Active
 *        Encryption is active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActiveDefaultKey
 *        Encryption is active, but an encryption key is not set by the user.
 *        (Value: "ACTIVE_DEFAULT_KEY")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_ActivePerUser
 *        Encryption is active, and the encryption key is tied to the user
 *        profile. (Value: "ACTIVE_PER_USER")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_EncryptionStatusUnspecified
 *        Unspecified. No device should have this type. (Value:
 *        "ENCRYPTION_STATUS_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Inactive
 *        Encryption is supported by the device, but is not currently active.
 *        (Value: "INACTIVE")
 *    @arg @c kGTLRAndroidManagement_DeviceSettings_EncryptionStatus_Unsupported
 *        Encryption is not supported by the device. (Value: "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionStatus;

/**
 *  Whether the device is secured with PIN/password.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isDeviceSecure;

/**
 *  Whether the storage encryption is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isEncrypted;

/**
 *  Whether installing apps from unknown sources is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unknownSourcesEnabled;

/**
 *  Whether Verify Apps (Google Play Protect
 *  (https://support.google.com/googleplay/answer/2812853)) is enabled on the
 *  device.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *verifyAppsEnabled;

@end


/**
 *  Device display information.
 */
@interface GTLRAndroidManagement_Display : GTLRObject

/**
 *  Display density expressed as dots-per-inch.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *density;

/**
 *  Unique display id.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayId;

/**
 *  Display height in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *height;

/** Name of the display. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Refresh rate of the display in frames per second.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *refreshRate;

/**
 *  State of the display.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Display_State_DisplayStateUnspecified This
 *        value is disallowed. (Value: "DISPLAY_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Display_State_Doze Display is dozing in a
 *        low power state (Value: "DOZE")
 *    @arg @c kGTLRAndroidManagement_Display_State_Off Display is off. (Value:
 *        "OFF")
 *    @arg @c kGTLRAndroidManagement_Display_State_On Display is on. (Value:
 *        "ON")
 *    @arg @c kGTLRAndroidManagement_Display_State_Suspended Display is dozing
 *        in a suspended low power state. (Value: "SUSPENDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Display width in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for Empty is empty JSON object {}.
 */
@interface GTLRAndroidManagement_Empty : GTLRObject
@end


/**
 *  An enrollment token.
 */
@interface GTLRAndroidManagement_EnrollmentToken : GTLRObject

/**
 *  Optional, arbitrary data associated with the enrollment token. This could
 *  contain, for example, the ID of an org unit the device is assigned to after
 *  enrollment. After a device enrolls with the token, this data will be exposed
 *  in the enrollment_token_data field of the Device resource. The data must be
 *  1024 characters or less; otherwise, the creation request will fail.
 */
@property(nonatomic, copy, nullable) NSString *additionalData;

/**
 *  The length of time the enrollment token is valid, ranging from 1 minute to
 *  30 days. If not specified, the default duration is 1 hour.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  The expiration time of the token. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTimestamp;

/**
 *  The name of the enrollment token, which is generated by the server during
 *  creation, in the form
 *  enterprises/{enterpriseId}/enrollmentTokens/{enrollmentTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the enrollment token is for one time use only. If the flag is set to
 *  true, only one device can use it for registration.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *oneTimeOnly;

/**
 *  The name of the policy initially applied to the enrolled device, in the form
 *  enterprises/{enterpriseId}/policies/{policyId}. If not specified, the
 *  policy_name for the devices user is applied. If user_name is also not
 *  specified, enterprises/{enterpriseId}/policies/default is applied by
 *  default. When updating this field, you can specify only the policyId as long
 *  as the policyId doesnt contain any slashes. The rest of the policy name
 *  will be inferred.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/**
 *  The user associated with this enrollment token. If it's specified when the
 *  enrollment token is created and the user does not exist, the user will be
 *  created. This field must not contain personally identifiable information.
 *  Only the account_identifier field needs to be set.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_User *user;

/**
 *  The token value that's passed to the device and authorizes the device to
 *  enroll. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  The configuration applied to an enterprise.
 */
@interface GTLRAndroidManagement_Enterprise : GTLRObject

/**
 *  Deprecated and unused.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appAutoApprovalEnabled;

/** The types of Google Pub/Sub notifications enabled for the enterprise. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledNotificationTypes;

/** The name of the enterprise displayed to users. */
@property(nonatomic, copy, nullable) NSString *enterpriseDisplayName;

/**
 *  An image displayed as a logo during device provisioning. Supported types
 *  are: image/bmp, image/gif, image/x-ico, image/jpeg, image/png, image/webp,
 *  image/vnd.wap.wbmp, image/x-adobe-dng.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ExternalData *logo;

/**
 *  The name of the enterprise which is generated by the server during creation,
 *  in the form enterprises/{enterpriseId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A color in RGB format that indicates the predominant color to display in the
 *  device management app UI. The color components are stored as follows: (red
 *  << 16) | (green << 8) | blue, where the value of each component is between 0
 *  and 255, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *primaryColor;

/**
 *  The topic that Cloud Pub/Sub notifications are published to, in the form
 *  projects/{project}/topics/{topic}. This field is only required if Pub/Sub
 *  notifications are enabled.
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

/**
 *  Sign-in details of the enterprise. Maximum of 1 SigninDetail is supported.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_SigninDetail *> *signinDetails;

/**
 *  Terms and conditions that must be accepted when provisioning a device for
 *  this enterprise. A page of terms is generated for each value in this list.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_TermsAndConditions *> *termsAndConditions;

@end


/**
 *  Data hosted at an external location. The data is to be downloaded by Android
 *  Device Policy and verified against the hash.
 */
@interface GTLRAndroidManagement_ExternalData : GTLRObject

/**
 *  The base-64 encoded SHA-256 hash of the content hosted at url. If the
 *  content doesn't match this hash, Android Device Policy won't use the data.
 */
@property(nonatomic, copy, nullable) NSString *sha256Hash;

/**
 *  The absolute URL to the data, which must use either the http or https
 *  scheme. Android Device Policy doesn't provide any credentials in the GET
 *  request, so the URL must be publicly accessible. Including a long, random
 *  component in the URL may be used to prevent attackers from discovering the
 *  URL.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Information about device hardware. The fields related to temperature
 *  thresholds are only available if hardwareStatusEnabled is true in the
 *  device's policy.
 */
@interface GTLRAndroidManagement_HardwareInfo : GTLRObject

/**
 *  Battery shutdown temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryShutdownTemperatures;

/**
 *  Battery throttling temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryThrottlingTemperatures;

/** Brand of the device. For example, Google. */
@property(nonatomic, copy, nullable) NSString *brand;

/**
 *  CPU shutdown temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuShutdownTemperatures;

/**
 *  CPU throttling temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuThrottlingTemperatures;

/** Baseband version. For example, MDM9625_104662.22.05.34p. */
@property(nonatomic, copy, nullable) NSString *deviceBasebandVersion;

/**
 *  GPU shutdown temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuShutdownTemperatures;

/**
 *  GPU throttling temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuThrottlingTemperatures;

/** Name of the hardware. For example, Angler. */
@property(nonatomic, copy, nullable) NSString *hardware;

/** Manufacturer. For example, Motorola. */
@property(nonatomic, copy, nullable) NSString *manufacturer;

/** The model of the device. For example, Asus Nexus 7. */
@property(nonatomic, copy, nullable) NSString *model;

/** The device serial number. */
@property(nonatomic, copy, nullable) NSString *serialNumber;

/**
 *  Device skin shutdown temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinShutdownTemperatures;

/**
 *  Device skin throttling temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinThrottlingTemperatures;

@end


/**
 *  Hardware status. Temperatures may be compared to the temperature thresholds
 *  available in hardwareInfo to determine hardware health.
 */
@interface GTLRAndroidManagement_HardwareStatus : GTLRObject

/**
 *  Current battery temperatures in Celsius for each battery on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryTemperatures;

/**
 *  Current CPU temperatures in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuTemperatures;

/**
 *  CPU usages in percentage for each core available on the device. Usage is 0
 *  for each unplugged core. Empty array implies that CPU usage is not supported
 *  in the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuUsages;

/** The time the measurements were taken. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Fan speeds in RPM for each fan on the device. Empty array means that there
 *  are no fans or fan speed is not supported on the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *fanSpeeds;

/**
 *  Current GPU temperatures in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuTemperatures;

/**
 *  Current device skin temperatures in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinTemperatures;

@end


/**
 *  Response to a request to list devices for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "devices" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListDevicesResponse : GTLRCollectionObject

/**
 *  The list of devices.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Device *> *devices;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Operation *> *operations;

@end


/**
 *  Response to a request to list policies for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "policies" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListPoliciesResponse : GTLRCollectionObject

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Policy *> *policies;

@end


/**
 *  The managed configurations template for the app, saved from the managed
 *  configurations iframe.
 */
@interface GTLRAndroidManagement_ManagedConfigurationTemplate : GTLRObject

/**
 *  Optional, a map containing <key, value> configuration variables defined for
 *  the configuration.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables *configurationVariables;

/** The ID of the managed configurations template. */
@property(nonatomic, copy, nullable) NSString *templateId;

@end


/**
 *  Optional, a map containing <key, value> configuration variables defined for
 *  the configuration.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_ManagedConfigurationTemplate_ConfigurationVariables : GTLRObject
@end


/**
 *  Managed property.
 */
@interface GTLRAndroidManagement_ManagedProperty : GTLRObject

/**
 *  The default value of the property. BUNDLE_ARRAY properties don't have a
 *  default value.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id defaultValue;

/**
 *  A longer description of the property, providing more detail of what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** For CHOICE or MULTISELECT properties, the list of possible entries. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedPropertyEntry *> *entries;

/**
 *  The unique key that the app uses to identify the property, e.g.
 *  "com.google.android.gm.fieldname".
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  For BUNDLE_ARRAY properties, the list of nested properties. A BUNDLE_ARRAY
 *  property is at most two levels deep.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *nestedProperties;

/** The name of the property. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  The type of the property.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Bool A property of
 *        boolean type. (Value: "BOOL")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_BundleArray An array
 *        of property bundles. (Value: "BUNDLE_ARRAY")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Choice A choice of one
 *        item from a set. (Value: "CHOICE")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Hidden A hidden
 *        restriction of string type (the default value can be used to pass
 *        along information that can't be modified, such as a version code).
 *        (Value: "HIDDEN")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Integer A property of
 *        integer type. (Value: "INTEGER")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified
 *        Not used. (Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Multiselect A choice
 *        of multiple items from a set. (Value: "MULTISELECT")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_String A property of
 *        string type. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  An entry of a managed property.
 */
@interface GTLRAndroidManagement_ManagedPropertyEntry : GTLRObject

/** The human-readable name of the value. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The machine-readable value of the entry, which should be used in the
 *  configuration. Not localized.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  An event related to memory and storage measurements.
 */
@interface GTLRAndroidManagement_MemoryEvent : GTLRObject

/**
 *  The number of free bytes in the medium, or for EXTERNAL_STORAGE_DETECTED,
 *  the total capacity in bytes of the storage medium.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *byteCount;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected
 *        A new external storage medium was detected. The reported byte count is
 *        the total capacity of the storage medium. (Value:
 *        "EXTERNAL_STORAGE_DETECTED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured
 *        Free space in an external storage medium was measured. (Value:
 *        "EXTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved
 *        An external storage medium was removed. The reported byte count is
 *        zero. (Value: "EXTERNAL_STORAGE_REMOVED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured
 *        Free space in internal storage was measured. (Value:
 *        "INTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "MEMORY_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured Free
 *        space in RAM was measured. (Value: "RAM_MEASURED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Information about device memory and storage.
 */
@interface GTLRAndroidManagement_MemoryInfo : GTLRObject

/**
 *  Total internal storage on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalInternalStorage;

/**
 *  Total RAM on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalRam;

@end


/**
 *  Device network info.
 */
@interface GTLRAndroidManagement_NetworkInfo : GTLRObject

/** IMEI number of the GSM device. For example, A1000031212. */
@property(nonatomic, copy, nullable) NSString *imei;

/** MEID number of the CDMA device. For example, A00000292788E1. */
@property(nonatomic, copy, nullable) NSString *meid;

/** Alphabetic name of current registered operator. For example, Vodafone. */
@property(nonatomic, copy, nullable) NSString *networkOperatorName;

/** Wi-Fi MAC address of the device. For example, 7c:11:11:11:11:11. */
@property(nonatomic, copy, nullable) NSString *wifiMacAddress;

@end


/**
 *  Provides detail about non-compliance with a policy setting.
 */
@interface GTLRAndroidManagement_NonComplianceDetail : GTLRObject

/**
 *  If the policy setting could not be applied, the current value of the setting
 *  on the device.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id currentValue;

/**
 *  For settings with nested fields, if a particular nested field is out of
 *  compliance, this specifies the full path to the offending field. The path is
 *  formatted in the same way the policy JSON field would be referenced in
 *  JavaScript, that is: 1) For object-typed fields, the field name is followed
 *  by a dot then by a subfield name. 2) For array-typed fields, the field name
 *  is followed by the array index enclosed in brackets. For example, to
 *  indicate a problem with the url field in the externalData field in the 3rd
 *  application, the path would be applications[2].externalData.url
 */
@property(nonatomic, copy, nullable) NSString *fieldPath;

/**
 *  If package_name is set and the non-compliance reason is APP_NOT_INSTALLED or
 *  APP_NOT_UPDATED, the detailed reason the app can't be installed or updated.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress
 *        The installation is still in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown
 *        An unknown condition is preventing the app from being installed. Some
 *        potential reasons are that the device doesn't have enough storage, the
 *        device network connection is unreliable, or the installation is taking
 *        longer than expected. The installation will be retried automatically.
 *        (Value: "INSTALLATION_FAILURE_REASON_UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified
 *        This value is disallowed. (Value:
 *        "INSTALLATION_FAILURE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining
 *        There are no licenses available to assign to the user. (Value:
 *        "NO_LICENSES_REMAINING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved
 *        The app has not been approved by the admin. (Value: "NOT_APPROVED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry
 *        The app is not available in the user's country. (Value:
 *        "NOT_AVAILABLE_IN_COUNTRY")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice
 *        The app is incompatible with the device. (Value:
 *        "NOT_COMPATIBLE_WITH_DEVICE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled
 *        The enterprise is no longer enrolled with managed Play or the admin
 *        has not accepted the latest managed Play terms of service. (Value:
 *        "NOT_ENROLLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound
 *        The app was not found in Play. (Value: "NOT_FOUND")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted
 *        The app has new permissions that have not been accepted by the admin.
 *        (Value: "PERMISSIONS_NOT_ACCEPTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid
 *        The user is no longer valid. The user may have been deleted or
 *        disabled. (Value: "USER_INVALID")
 */
@property(nonatomic, copy, nullable) NSString *installationFailureReason;

/**
 *  The reason the device is not in compliance with the setting.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of the Android version
 *        running on the device. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible
 *        The setting can't be applied to the app because the app doesn't
 *        support it, for example because its target SDK version is not high
 *        enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled
 *        A blocked app is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled
 *        The app required to implement the policy is not installed. (Value:
 *        "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated
 *        The app is installed, but it hasn't been updated to the minimum
 *        version code specified by policy. (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ManagementMode
 *        The management mode (profile owner, device owner, etc.) doesn't
 *        support the setting. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is disallowed. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending
 *        The setting hasn't been applied at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name indicating which app is out of compliance, if applicable.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

@end


/**
 *  A compliance rule condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device. A NonComplianceDetail matches a
 *  NonComplianceDetailCondition if all the fields which are set within the
 *  NonComplianceDetailCondition match the corresponding NonComplianceDetail
 *  fields.
 */
@interface GTLRAndroidManagement_NonComplianceDetailCondition : GTLRObject

/**
 *  The reason the device is not in compliance with the setting. If not set,
 *  then this condition matches any reason.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of the Android version
 *        running on the device. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible
 *        The setting can't be applied to the app because the app doesn't
 *        support it, for example because its target SDK version is not high
 *        enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled
 *        A blocked app is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled
 *        The app required to implement the policy is not installed. (Value:
 *        "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated
 *        The app is installed, but it hasn't been updated to the minimum
 *        version code specified by policy. (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ManagementMode
 *        The management mode (profile owner, device owner, etc.) doesn't
 *        support the setting. (Value: "MANAGEMENT_MODE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is disallowed. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending
 *        The setting hasn't been applied at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name of the app that's out of compliance. If not set, then this
 *  condition matches any package name.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field. If not set, then this condition matches any setting name.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRAndroidManagement_Operation : GTLRObject

/**
 *  If the value is false, it means the operation is still in progress. If true,
 *  the operation is completed, and either error or response is available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the name should
 *  have the format of operations/some/unique/name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Response : GTLRObject
@end


/**
 *  A list of package names.
 */
@interface GTLRAndroidManagement_PackageNameList : GTLRObject

/** A list of package names. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *packageNames;

@end


/**
 *  Requirements for the password used to unlock a device.
 */
@interface GTLRAndroidManagement_PasswordRequirements : GTLRObject

/**
 *  Number of incorrect device-unlock passwords that can be entered before a
 *  device is wiped. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumFailedPasswordsForWipe;

/** Password expiration timeout. */
@property(nonatomic, strong, nullable) GTLRDuration *passwordExpirationTimeout;

/**
 *  The length of the password history. After setting this field, the user won't
 *  be able to enter a new password that is the same as any password in the
 *  history. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordHistoryLength;

/**
 *  The minimum allowed password length. A value of 0 means there is no
 *  restriction. Only enforced when password_quality is NUMERIC,
 *  NUMERIC_COMPLEX, ALPHABETIC, ALPHANUMERIC, or COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLength;

/**
 *  Minimum number of letters required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLetters;

/**
 *  Minimum number of lower case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLowerCase;

/**
 *  Minimum number of non-letter characters (numerical digits or symbols)
 *  required in the password. Only enforced when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNonLetter;

/**
 *  Minimum number of numerical digits required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNumeric;

/**
 *  Minimum number of symbols required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumSymbols;

/**
 *  Minimum number of upper case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumUpperCase;

/**
 *  The required password quality.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic
 *        The password must contain alphabetic (or symbol) characters. (Value:
 *        "ALPHABETIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric
 *        The password must contain both numeric and alphabetic (or symbol)
 *        characters. (Value: "ALPHANUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak
 *        The device must be secured with a low-security biometric recognition
 *        technology, at minimum. This includes technologies that can recognize
 *        the identity of an individual that are roughly equivalent to a 3-digit
 *        PIN (false detection is less than 1 in 1,000). (Value:
 *        "BIOMETRIC_WEAK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex
 *        The password must contain at least a letter, a numerical digit and a
 *        special symbol. Other password constraints, for example,
 *        password_minimum_letters are enforced. (Value: "COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric
 *        The password must contain numeric characters. (Value: "NUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex
 *        The password must contain numeric characters with no repeating (4444)
 *        or ordered (1234, 4321, 2468) sequences. (Value: "NUMERIC_COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified
 *        There are no password requirements. (Value:
 *        "PASSWORD_QUALITY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something
 *        A password is required, but there are no restrictions on what the
 *        password must contain. (Value: "SOMETHING")
 */
@property(nonatomic, copy, nullable) NSString *passwordQuality;

/**
 *  The scope that the password requirement applies to.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeDevice
 *        The password requirements are only applied to the device. (Value:
 *        "SCOPE_DEVICE")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeProfile
 *        The password requirements are only applied to the work profile.
 *        (Value: "SCOPE_PROFILE")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordScope_ScopeUnspecified
 *        The scope is unspecified. The password requirements are applied to the
 *        work profile for work profile devices and the whole device for fully
 *        managed or dedicated devices. (Value: "SCOPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *passwordScope;

@end


/**
 *  Configuration for an Android permission and its grant state.
 */
@interface GTLRAndroidManagement_PermissionGrant : GTLRObject

/**
 *  The Android permission or group, e.g. android.permission.READ_CALENDAR or
 *  android.permission_group.CALENDAR.
 */
@property(nonatomic, copy, nullable) NSString *permission;

/**
 *  The policy for granting the permission.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Deny Automatically
 *        deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Grant Automatically
 *        grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Prompt Prompt the
 *        user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *policy;

@end


/**
 *  A default activity for handling intents that match a particular intent
 *  filter.
 */
@interface GTLRAndroidManagement_PersistentPreferredActivity : GTLRObject

/**
 *  The intent actions to match in the filter. If any actions are included in
 *  the filter, then an intent's action must be one of those values for it to
 *  match. If no actions are included, the intent action is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *actions;

/**
 *  The intent categories to match in the filter. An intent includes the
 *  categories that it requires, all of which must be included in the filter in
 *  order to match. In other words, adding a category to the filter has no
 *  impact on matching unless that category is specified in the intent.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *categories;

/**
 *  The activity that should be the default intent handler. This should be an
 *  Android component name, e.g. com.android.enterprise.app/.MainActivity.
 *  Alternatively, the value may be the package name of an app, which causes
 *  Android Device Policy to choose an appropriate activity from the app to
 *  handle the intent.
 */
@property(nonatomic, copy, nullable) NSString *receiverActivity;

@end


/**
 *  A policy resources represents a group settings that govern the behavior of a
 *  managed device and the apps installed on it.
 */
@interface GTLRAndroidManagement_Policy : GTLRObject

/** Account types that can't be managed by the user. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *accountTypesWithManagementDisabled;

/**
 *  Whether adding new users and profiles is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *addUserDisabled;

/**
 *  Whether adjusting the master volume is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adjustVolumeDisabled;

/**
 *  Configuration for an always-on VPN connection. Use with vpn_config_disabled
 *  to prevent modification of this setting.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_AlwaysOnVpnPackage *alwaysOnVpnPackage;

/**
 *  The app tracks for Android Device Policy the device can access. The device
 *  receives the latest version among all accessible tracks. If no tracks are
 *  specified, then the device only uses the production track.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *androidDevicePolicyTracks;

/**
 *  The app auto update policy, which controls when automatic app updates can be
 *  applied.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Always Apps are
 *        auto-updated at any time. Data charges may apply. (Value: "ALWAYS")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_AppAutoUpdatePolicyUnspecified
 *        The auto-update policy is not set. Equivalent to CHOICE_TO_THE_USER.
 *        (Value: "APP_AUTO_UPDATE_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_ChoiceToTheUser
 *        The user can control auto-updates. (Value: "CHOICE_TO_THE_USER")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_Never Apps are
 *        never auto-updated. (Value: "NEVER")
 *    @arg @c kGTLRAndroidManagement_Policy_AppAutoUpdatePolicy_WifiOnly Apps
 *        are auto-updated over Wi-Fi only. (Value: "WIFI_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *appAutoUpdatePolicy;

/** Policy applied to apps. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPolicy *> *applications;

/**
 *  Whether auto time is required, which prevents the user from manually setting
 *  the date and time.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoTimeRequired;

/**
 *  Whether applications other than the ones configured in applications are
 *  blocked from being installed. When set, applications that were installed
 *  under a previous policy but no longer appear in the policy are automatically
 *  uninstalled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockApplicationsEnabled;

/**
 *  Whether configuring bluetooth is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothConfigDisabled;

/**
 *  Whether bluetooth contact sharing is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothContactSharingDisabled;

/**
 *  Whether bluetooth is disabled. Prefer this setting over
 *  bluetooth_config_disabled because bluetooth_config_disabled can be bypassed
 *  by the user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bluetoothDisabled;

/**
 *  Whether all cameras on the device are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cameraDisabled;

/**
 *  Whether configuring cell broadcast is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cellBroadcastsConfigDisabled;

/**
 *  Rules for automatically choosing a private key and certificate to
 *  authenticate the device to a server. The rules are ordered by increasing
 *  precedence, so if an outgoing request matches more than one rule, the last
 *  rule defines which private key to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ChoosePrivateKeyRule *> *choosePrivateKeyRules;

/**
 *  Rules declaring which mitigating actions to take when a device is not
 *  compliant with its policy. When the conditions for multiple rules are
 *  satisfied, all of the mitigating actions for the rules are taken. There is a
 *  maximum limit of 100 rules.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ComplianceRule *> *complianceRules;

/**
 *  Whether creating windows besides app windows is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *createWindowsDisabled;

/**
 *  Whether configuring user credentials is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *credentialsConfigDisabled;

/**
 *  Whether roaming data services are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dataRoamingDisabled;

/**
 *  Whether the user is allowed to enable debugging features.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *debuggingFeaturesAllowed;

/**
 *  The default permission policy for runtime permission requests.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/** The device owner information to be shown on the lock screen. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *deviceOwnerLockScreenInfo;

/**
 *  Whether encryption is enabled
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithoutPassword
 *        Encryption required but no password required to boot (Value:
 *        "ENABLED_WITHOUT_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EnabledWithPassword
 *        Encryption required with password required to boot (Value:
 *        "ENABLED_WITH_PASSWORD")
 *    @arg @c kGTLRAndroidManagement_Policy_EncryptionPolicy_EncryptionPolicyUnspecified
 *        This value is ignored, i.e. no encryption required (Value:
 *        "ENCRYPTION_POLICY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *encryptionPolicy;

/**
 *  Whether app verification is force-enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *ensureVerifyAppsEnabled;

/**
 *  Whether factory resetting from settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *factoryResetDisabled;

/**
 *  Email addresses of device administrators for factory reset protection. When
 *  the device is factory reset, it will require one of these admins to log in
 *  with the Google account email and password to unlock the device. If no
 *  admins are specified, the device won't provide factory reset protection.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *frpAdminEmails;

/**
 *  Whether the user is allowed to have fun. Controls whether the Easter egg
 *  game in Settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *funDisabled;

/**
 *  Whether user installation of apps is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installAppsDisabled;

/**
 *  Whether the user is allowed to enable the "Unknown Sources" setting, which
 *  allows installation of apps from unknown sources.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installUnknownSourcesAllowed;

/**
 *  Whether the keyguard is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *keyguardDisabled;

/** Disabled keyguard customizations, such as widgets. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *keyguardDisabledFeatures;

/**
 *  Whether the kiosk custom launcher is enabled. This replaces the home screen
 *  with a launcher that locks down the device to the apps installed via the
 *  applications setting. The apps appear on a single page in alphabetical
 *  order. It is recommended to also use status_bar_disabled to block access to
 *  device settings.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *kioskCustomLauncherEnabled;

/**
 *  The degree of location detection enabled. The user may change the value
 *  unless the user is otherwise blocked from accessing device settings.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_BatterySaving Only the
 *        network location provider is enabled. (Value: "BATTERY_SAVING")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_HighAccuracy All
 *        location detection methods are enabled, including GPS, networks, and
 *        other sensors. (Value: "HIGH_ACCURACY")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_LocationModeUnspecified
 *        The current device value is not modified. (Value:
 *        "LOCATION_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_Off Location detection
 *        is disabled. (Value: "OFF")
 *    @arg @c kGTLRAndroidManagement_Policy_LocationMode_SensorsOnly Only GPS
 *        and other sensors are enabled. (Value: "SENSORS_ONLY")
 */
@property(nonatomic, copy, nullable) NSString *locationMode;

/**
 *  A message displayed to the user in the device administators settings screen.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *longSupportMessage;

/**
 *  Maximum time in milliseconds for user activity until the device locks. A
 *  value of 0 means there is no restriction.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumTimeToLock;

/**
 *  Whether configuring mobile networks is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mobileNetworksConfigDisabled;

/**
 *  Whether adding or removing accounts is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *modifyAccountsDisabled;

/**
 *  Whether the user mounting physical external media is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mountPhysicalMediaDisabled;

/**
 *  The name of the policy in the form
 *  enterprises/{enterpriseId}/policies/{policyId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the network escape hatch is enabled. If a network connection can't
 *  be made at boot time, the escape hatch prompts the user to temporarily
 *  connect to a network in order to refresh the device policy. After applying
 *  policy, the temporary network will be forgotten and the device will continue
 *  booting. This prevents being unable to connect to a network if there is no
 *  suitable network in the last policy and the device boots into an app in lock
 *  task mode, or the user is otherwise unable to reach device settings.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkEscapeHatchEnabled;

/**
 *  Whether resetting network settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkResetDisabled;

/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Policy_OpenNetworkConfiguration *openNetworkConfiguration;

/**
 *  Whether using NFC to beam data from apps is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outgoingBeamDisabled;

/**
 *  Whether outgoing calls are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outgoingCallsDisabled;

/**
 *  Password requirement policies. Different policies can be set for work
 *  profile or fully managed devices by setting the password_scope field in the
 *  policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PasswordRequirements *> *passwordPolicies;

/** Password requirements. DEPRECATED - Use password_policies */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PasswordRequirements *passwordRequirements;

/**
 *  Explicit permission or group grants or denials for all apps. These values
 *  override the default_permission_policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

/**
 *  If present, only the input methods provided by packages in this list are
 *  permitted. If this field is present, but the list is empty, then only system
 *  input methods are permitted.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PackageNameList *permittedInputMethods;

/** Default intent handler activities. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PersistentPreferredActivity *> *persistentPreferredActivities;

/**
 *  This mode controls which apps are available to the user in the Play Store
 *  and the behavior on the device when apps are removed from the policy.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_Blacklist All apps are
 *        available and any app that should not be on the device should be
 *        explicitly markeds as 'BLOCKED' in the applications policy. (Value:
 *        "BLACKLIST")
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_PlayStoreModeUnspecified
 *        Unspecified. Defaults to WHITELIST. (Value:
 *        "PLAY_STORE_MODE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_PlayStoreMode_Whitelist Only apps
 *        that are in the policy are available and any app not in the policy
 *        will be automatically uninstalled from the device. (Value:
 *        "WHITELIST")
 */
@property(nonatomic, copy, nullable) NSString *playStoreMode;

/**
 *  Allows showing UI on a device for a user to choose a private key alias if
 *  there are no matching rules in ChoosePrivateKeyRules. For devices below
 *  Android P, setting this may leave enterprise keys vulnerable.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *privateKeySelectionEnabled;

/**
 *  The network-independent global HTTP proxy. Typically proxies should be
 *  configured per-network in open_network_configuration. However for unusual
 *  configurations like general internal filtering a global HTTP proxy may be
 *  useful. If the proxy is not accessible, network access may break. The global
 *  proxy is only a recommendation and some apps may ignore it.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ProxyInfo *recommendedGlobalProxy;

/**
 *  Whether removing other users is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *removeUserDisabled;

/**
 *  Whether rebooting the device into safe boot is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *safeBootDisabled;

/**
 *  Whether screen capture is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenCaptureDisabled;

/**
 *  Whether changing the user icon is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *setUserIconDisabled;

/**
 *  Whether changing the wallpaper is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *setWallpaperDisabled;

/**
 *  Whether location sharing is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *shareLocationDisabled;

/**
 *  A message displayed to the user in the settings screen wherever
 *  functionality has been disabled by the admin.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *shortSupportMessage;

/**
 *  Flag to skip hints on the first use. Enterprise admin can enable the system
 *  recommendation for apps to skip their user tutorial and other introductory
 *  hints on first start-up.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipFirstUseHintsEnabled;

/**
 *  Whether sending and receiving SMS messages is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *smsDisabled;

/**
 *  Whether the status bar is disabled. This disables notifications, quick
 *  settings, and other screen overlays that allow escape from full-screen mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *statusBarDisabled;

/** Status reporting settings */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StatusReportingSettings *statusReportingSettings;

/**
 *  The battery plugged in modes for which the device stays on. When using this
 *  setting, it is recommended to clear maximum_time_to_lock so that the device
 *  doesn't lock itself while it stays on.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *stayOnPluggedModes;

/**
 *  The system update policy, which controls how OS updates are applied. If the
 *  update type is WINDOWED, the update window will automatically apply to Play
 *  app updates as well.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SystemUpdate *systemUpdate;

/**
 *  Whether configuring tethering and portable hotspots is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *tetheringConfigDisabled;

/**
 *  Whether user uninstallation of applications is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *uninstallAppsDisabled;

/**
 *  Whether the microphone is muted and adjusting microphone volume is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unmuteMicrophoneDisabled;

/**
 *  Whether transferring files over USB is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usbFileTransferDisabled;

/**
 *  Whether USB storage is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *usbMassStorageEnabled;

/**
 *  The version of the policy. This is a read-only field. The version is
 *  incremented each time the policy is updated.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

/**
 *  Whether configuring VPN is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vpnConfigDisabled;

/**
 *  Whether configuring Wi-Fi access points is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigDisabled;

/**
 *  Whether Wi-Fi networks defined in Open Network Configuration are locked so
 *  they can't be edited by the user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigsLockdownEnabled;

@end


/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Policy_OpenNetworkConfiguration : GTLRObject
@end


/**
 *  A power management event.
 */
@interface GTLRAndroidManagement_PowerManagementEvent : GTLRObject

/**
 *  For BATTERY_LEVEL_COLLECTED events, the battery level as a percentage.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batteryLevel;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected
 *        Battery level was measured. (Value: "BATTERY_LEVEL_COLLECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow
 *        The device entered low-power mode. (Value: "BATTERY_LOW")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay
 *        The device exited low-power mode. (Value: "BATTERY_OKAY")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted
 *        The device booted. (Value: "BOOT_COMPLETED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected
 *        The device started charging. (Value: "POWER_CONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected
 *        The device stopped charging. (Value: "POWER_DISCONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown The
 *        device shut down. (Value: "SHUTDOWN")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Configuration info for an HTTP proxy. For a direct proxy, set the host,
 *  port, and excluded_hosts fields. For a PAC script proxy, set the pac_uri
 *  field.
 */
@interface GTLRAndroidManagement_ProxyInfo : GTLRObject

/**
 *  For a direct proxy, the hosts for which the proxy is bypassed. The host
 *  names may contain wildcards such as *.example.com.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *excludedHosts;

/** The host of the direct proxy. */
@property(nonatomic, copy, nullable) NSString *host;

/** The URI of the PAC script used to configure the proxy. */
@property(nonatomic, copy, nullable) NSString *pacUri;

/**
 *  The port of the direct proxy.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *port;

@end


/**
 *  A resource containing sign in details for an enterprise.
 */
@interface GTLRAndroidManagement_SigninDetail : GTLRObject

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/**
 *  An enterprise wide enrollment token used to trigger custom sign-in flow.
 *  This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *signinEnrollmentToken;

/**
 *  Sign-in URL for authentication when device is provisioned with a sign-in
 *  enrollment token. The sign-in endpoint should finish authentication flow
 *  with a URL in the form of
 *  https://enterprise.google.com/android/enroll?et=<token> for a successful
 *  login, or https://enterprise.google.com/android/enroll/invalid for a failed
 *  login.
 */
@property(nonatomic, copy, nullable) NSString *signinUrl;

@end


/**
 *  An enterprise signup URL.
 */
@interface GTLRAndroidManagement_SignupUrl : GTLRObject

/**
 *  The name of the resource. Use this value in the signupUrl field when calling
 *  enterprises.create to complete the enterprise signup flow.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A URL where an enterprise admin can register their enterprise. The page
 *  can't be rendered in an iframe.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Information about device software.
 */
@interface GTLRAndroidManagement_SoftwareInfo : GTLRObject

/**
 *  Android build ID string meant for displaying to the user. For example,
 *  shamu-userdebug 6.0.1 MOB30I 2756745 dev-keys.
 */
@property(nonatomic, copy, nullable) NSString *androidBuildNumber;

/** Build time. */
@property(nonatomic, strong, nullable) GTLRDateTime *androidBuildTime;

/**
 *  The Android Device Policy app version code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *androidDevicePolicyVersionCode;

/** The Android Device Policy app version as displayed to the user. */
@property(nonatomic, copy, nullable) NSString *androidDevicePolicyVersionName;

/** The user-visible Android version string. For example, 6.0.1. */
@property(nonatomic, copy, nullable) NSString *androidVersion;

/** The system bootloader version number, e.g. 0.6.7. */
@property(nonatomic, copy, nullable) NSString *bootloaderVersion;

/**
 *  SHA-256 hash of android.content.pm.Signature
 *  (https://developer.android.com/reference/android/content/pm/Signature.html)
 *  associated with the system package, which can be used to verify that the
 *  system build hasn't been modified.
 */
@property(nonatomic, copy, nullable) NSString *deviceBuildSignature;

/** Kernel version, for example, 2.6.32.9-g103d848. */
@property(nonatomic, copy, nullable) NSString *deviceKernelVersion;

/** An IETF BCP 47 language code for the primary locale on the device. */
@property(nonatomic, copy, nullable) NSString *primaryLanguageCode;

/** Security patch level, e.g. 2016-05-01. */
@property(nonatomic, copy, nullable) NSString *securityPatchLevel;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). The error model is designed to be:
 *  Simple to use and understand for most users
 *  Flexible enough to meet unexpected needsOverviewThe Status message contains
 *  three pieces of data: error code, error message, and error details. The
 *  error code should be an enum value of google.rpc.Code, but it may accept
 *  additional error codes if needed. The error message should be a
 *  developer-facing English message that helps developers understand and
 *  resolve the error. If a localized user-facing error message is needed, put
 *  the localized message in the error details or localize it in the client. The
 *  optional error details may contain arbitrary information about the error.
 *  There is a predefined set of error detail types in the package google.rpc
 *  that can be used for common error conditions.Language mappingThe Status
 *  message is the logical representation of the error model, but it is not
 *  necessarily the actual wire format. When the Status message is exposed in
 *  different client libraries and different wire protocols, it can be mapped
 *  differently. For example, it will likely be mapped to some exceptions in
 *  Java, but more likely mapped to some error codes in C.Other usesThe error
 *  model and the Status message can be used in a variety of environments,
 *  either with or without APIs, to provide a consistent developer experience
 *  across different environments.Example uses of this error model include:
 *  Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the Status in the normal response to indicate the partial
 *  errors.
 *  Workflow errors. A typical workflow has multiple steps. Each step may have a
 *  Status message for error reporting.
 *  Batch operations. If a client uses batch request and batch response, the
 *  Status message should be used directly inside batch response, one for each
 *  error sub-response.
 *  Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the Status message.
 *  Logging. If some API errors are stored in logs, the message Status could be
 *  used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRAndroidManagement_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRAndroidManagement_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Status_Details_Item : GTLRObject
@end


/**
 *  Settings controlling the behavior of status reports.
 */
@interface GTLRAndroidManagement_StatusReportingSettings : GTLRObject

/**
 *  Whether app reports are enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *applicationReportsEnabled;

/**
 *  Whether device settings reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deviceSettingsEnabled;

/**
 *  Whether displays reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayInfoEnabled;

/**
 *  Whether hardware status reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hardwareStatusEnabled;

/**
 *  Whether memory reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryInfoEnabled;

/**
 *  Whether network info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkInfoEnabled;

/**
 *  Whether power management event reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *powerManagementEventsEnabled;

/**
 *  Whether software info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *softwareInfoEnabled;

@end


/**
 *  Configuration for managing system updates
 */
@interface GTLRAndroidManagement_SystemUpdate : GTLRObject

/**
 *  If the type is WINDOWED, the end of the maintenance window, measured as the
 *  number of minutes after midnight in device's local time. This value must be
 *  between 0 and 1439, inclusive. If this value is less than start_minutes,
 *  then the maintenance window spans midnight. If the maintenance window
 *  specified is smaller than 30 minutes, the actual window is extended to 30
 *  minutes beyond the start time.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endMinutes;

/**
 *  If the type is WINDOWED, the start of the maintenance window, measured as
 *  the number of minutes after midnight in the device's local time. This value
 *  must be between 0 and 1439, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startMinutes;

/**
 *  The type of system update to configure.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Automatic Install
 *        automatically as soon as an update is available. (Value: "AUTOMATIC")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Postpone Postpone
 *        automatic install up to a maximum of 30 days. (Value: "POSTPONE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified
 *        Follow the default update behavior for the device, which typically
 *        requires the user to accept system updates. (Value:
 *        "SYSTEM_UPDATE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Windowed Install
 *        automatically within a daily maintenance window. This also configures
 *        Play apps to be updated within the window. This is strongly
 *        recommended for kiosk devices because this is the only way apps
 *        persistently pinned to the foreground can be updated by Play. (Value:
 *        "WINDOWED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A terms and conditions page to be accepted during provisioning.
 */
@interface GTLRAndroidManagement_TermsAndConditions : GTLRObject

/**
 *  A well-formatted HTML string. It will be parsed on the client with
 *  android.text.Html#fromHtml.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *content;

/** A short header which appears above the HTML content. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *header;

@end


/**
 *  A user belonging to an enterprise.
 */
@interface GTLRAndroidManagement_User : GTLRObject

/**
 *  A unique identifier you create for this user, such as user342 or
 *  asset#44418. This field must be set when the user is created and can't be
 *  updated. This field must not contain personally identifiable information
 *  (PII). This identifier must be 1024 characters or less; otherwise, the
 *  update policy request will fail.
 */
@property(nonatomic, copy, nullable) NSString *accountIdentifier;

@end


/**
 *  Provides a user-facing message with locale info. The maximum message length
 *  is 4096 characters.
 */
@interface GTLRAndroidManagement_UserFacingMessage : GTLRObject

/**
 *  The default message displayed if no localized message is specified or the
 *  user's locale doesn't match with any of the localized messages. A default
 *  message must be provided if any localized messages are provided.
 */
@property(nonatomic, copy, nullable) NSString *defaultMessage;

/**
 *  A map containing <locale, message> pairs, where locale is a well-formed BCP
 *  47 language (https://www.w3.org/International/articles/language-tags/) code,
 *  such as en-US, es-ES, or fr.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage_LocalizedMessages *localizedMessages;

@end


/**
 *  A map containing <locale, message> pairs, where locale is a well-formed BCP
 *  47 language (https://www.w3.org/International/articles/language-tags/) code,
 *  such as en-US, es-ES, or fr.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_UserFacingMessage_LocalizedMessages : GTLRObject
@end


/**
 *  A web token used to access the managed Google Play iframe.
 */
@interface GTLRAndroidManagement_WebToken : GTLRObject

/**
 *  The name of the web token, which is generated by the server during creation
 *  in the form enterprises/{enterpriseId}/webTokens/{webTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The URL of the parent frame hosting the iframe with the embedded UI. To
 *  prevent XSS, the iframe may not be hosted at other URLs. The URL must use
 *  the https scheme.
 */
@property(nonatomic, copy, nullable) NSString *parentFrameUrl;

/**
 *  Permissions available to an admin in the embedded UI. An admin must have all
 *  of these permissions in order to view the UI.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

/**
 *  The token value which is used in the hosting page to generate the iframe
 *  with the embedded UI. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
