// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Android Management API (androidmanagement/v1)
// Description:
//   The Android Management API provides remote enterprise management of Android
//   devices and apps.
// Documentation:
//   https://developers.google.com/android/management

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAndroidManagement_ApiLevelCondition;
@class GTLRAndroidManagement_ApplicationPermission;
@class GTLRAndroidManagement_ApplicationPolicy;
@class GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration;
@class GTLRAndroidManagement_ComplianceRule;
@class GTLRAndroidManagement_Device;
@class GTLRAndroidManagement_Display;
@class GTLRAndroidManagement_ExternalData;
@class GTLRAndroidManagement_HardwareInfo;
@class GTLRAndroidManagement_HardwareStatus;
@class GTLRAndroidManagement_ManagedProperty;
@class GTLRAndroidManagement_ManagedPropertyEntry;
@class GTLRAndroidManagement_MemoryEvent;
@class GTLRAndroidManagement_MemoryInfo;
@class GTLRAndroidManagement_NetworkInfo;
@class GTLRAndroidManagement_NonComplianceDetail;
@class GTLRAndroidManagement_NonComplianceDetailCondition;
@class GTLRAndroidManagement_Operation;
@class GTLRAndroidManagement_Operation_Metadata;
@class GTLRAndroidManagement_Operation_Response;
@class GTLRAndroidManagement_PasswordRequirements;
@class GTLRAndroidManagement_PermissionGrant;
@class GTLRAndroidManagement_PersistentPreferredActivity;
@class GTLRAndroidManagement_Policy;
@class GTLRAndroidManagement_Policy_OpenNetworkConfiguration;
@class GTLRAndroidManagement_PowerManagementEvent;
@class GTLRAndroidManagement_SoftwareInfo;
@class GTLRAndroidManagement_Status;
@class GTLRAndroidManagement_Status_Details_Item;
@class GTLRAndroidManagement_StatusReportingSettings;
@class GTLRAndroidManagement_SystemUpdate;
@class GTLRAndroidManagement_UserFacingMessage;
@class GTLRAndroidManagement_UserFacingMessage_LocalizedMessages;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ApplicationPolicy.installType

/**
 *  The application is automatically installed and cannot be removed by the
 *  user.
 *
 *  Value: "FORCE_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled;
/**
 *  No automatic installation is performed. Any other app policies will be
 *  applied if the user installs the app.
 *
 *  Value: "INSTALL_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified;
/**
 *  The application is automatically installed and can be removed by the user.
 *
 *  Value: "PREINSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.resetPasswordFlags

/** Value: "DO_NOT_ASK_CREDENTIALS_ON_BOOT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_DoNotAskCredentialsOnBoot;
/** Value: "LOCK_NOW" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_LockNow;
/** Value: "REQUIRE_ENTRY" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_RequireEntry;
/** Value: "RESET_PASSWORD_FLAG_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_ResetPasswordFlags_ResetPasswordFlagUnspecified;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Command.type

/**
 *  This value is disallowed.
 *
 *  Value: "COMMAND_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified;
/**
 *  Lock the device, as if the lock screen timeout had expired.
 *
 *  Value: "LOCK"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Lock;
/**
 *  Reboot the device. Only supported on API level 24+.
 *
 *  Value: "REBOOT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_Reboot;
/**
 *  Reset the user's password.
 *
 *  Value: "RESET_PASSWORD"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Command_Type_ResetPassword;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.appliedState

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Active;
/**
 *  The device was deleted. This state will never be returned by an API call,
 *  but will be used in the final policy compliance report published to Cloud
 *  Pub/Sub when the device acknowledges the deletion.
 *
 *  Value: "DELETED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Disabled;
/**
 *  The device is being provisioned. Newly enrolled devices will be in this
 *  state until they have applied policy.
 *
 *  Value: "PROVISIONING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_AppliedState_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Device.state

/**
 *  The device is active.
 *
 *  Value: "ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Active;
/**
 *  The device was deleted. This state will never be returned by an API call,
 *  but will be used in the final policy compliance report published to Cloud
 *  Pub/Sub when the device acknowledges the deletion.
 *
 *  Value: "DELETED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Deleted;
/**
 *  This value is disallowed.
 *
 *  Value: "DEVICE_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_DeviceStateUnspecified;
/**
 *  The device is disabled.
 *
 *  Value: "DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Disabled;
/**
 *  The device is being provisioned. Newly enrolled devices will be in this
 *  state until they have applied policy.
 *
 *  Value: "PROVISIONING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Device_State_Provisioning;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Display.state

/**
 *  This value is disallowed.
 *
 *  Value: "DISPLAY_STATE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_DisplayStateUnspecified;
/**
 *  Display is dozing in a low power state
 *
 *  Value: "DOZE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Doze;
/**
 *  Display is off.
 *
 *  Value: "OFF"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Off;
/**
 *  Display is on.
 *
 *  Value: "ON"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_On;
/**
 *  Display is dozing in a suspended low power state.
 *
 *  Value: "SUSPENDED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Display_State_Suspended;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Enterprise.enabledNotificationTypes

/** Value: "COMMAND" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Command;
/** Value: "COMPLIANCE_REPORT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_ComplianceReport;
/** Value: "ENROLLMENT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_Enrollment;
/** Value: "NOTIFICATION_TYPE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_NotificationTypeUnspecified;
/** Value: "STATUS_REPORT" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Enterprise_EnabledNotificationTypes_StatusReport;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_ManagedProperty.type

/**
 *  A property of boolean type.
 *
 *  Value: "BOOL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Bool;
/**
 *  An array of property bundles.
 *
 *  Value: "BUNDLE_ARRAY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_BundleArray;
/**
 *  A choice of one item from a set.
 *
 *  Value: "CHOICE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Choice;
/**
 *  A hidden restriction of string type (the default value can be used to pass
 *  along information that cannot be modified, such as a version code).
 *
 *  Value: "HIDDEN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Hidden;
/**
 *  A property of integer type.
 *
 *  Value: "INTEGER"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Integer;
/**
 *  Not used.
 *
 *  Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified;
/**
 *  A choice of multiple items from a set.
 *
 *  Value: "MULTISELECT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_Multiselect;
/**
 *  A property of string type.
 *
 *  Value: "STRING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_ManagedProperty_Type_String;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_MemoryEvent.eventType

/**
 *  A new external storage medium was detected. The reported byte count is the
 *  total capacity of the storage medium.
 *
 *  Value: "EXTERNAL_STORAGE_DETECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected;
/**
 *  Free space in an external storage medium was measured.
 *
 *  Value: "EXTERNAL_STORAGE_MEASURED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured;
/**
 *  An external storage medium was removed. The reported byte count is zero.
 *
 *  Value: "EXTERNAL_STORAGE_REMOVED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved;
/**
 *  Free space in internal storage was measured.
 *
 *  Value: "INTERNAL_STORAGE_MEASURED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "MEMORY_EVENT_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified;
/**
 *  Free space in RAM was measured.
 *
 *  Value: "RAM_MEASURED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.installationFailureReason

/**
 *  The installation is still in progress.
 *
 *  Value: "IN_PROGRESS"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress;
/**
 *  An unknown condition is preventing the app from being installed. Some
 *  potential reaons are that the device does not have enough storage, the
 *  device network connection is unreliable, or the installation is taking
 *  longer than expected. The installation will be retried automatically.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown;
/**
 *  This value is disallowed.
 *
 *  Value: "INSTALLATION_FAILURE_REASON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified;
/**
 *  There are no more licenses to assign to the user.
 *
 *  Value: "NO_LICENSES_REMAINING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining;
/**
 *  The app has not been approved by the admin.
 *
 *  Value: "NOT_APPROVED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved;
/**
 *  The app is not available in the user's country.
 *
 *  Value: "NOT_AVAILABLE_IN_COUNTRY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry;
/**
 *  The app is incompatible with the device.
 *
 *  Value: "NOT_COMPATIBLE_WITH_DEVICE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice;
/**
 *  The enterprise is no longer enrolled with Play for Work or Android Device
 *  Policy is not enabled for the enterprise.
 *
 *  Value: "NOT_ENROLLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled;
/**
 *  The app was not found in Play.
 *
 *  Value: "NOT_FOUND"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound;
/**
 *  The app has new permissions that have not been accepted by the admin.
 *
 *  Value: "PERMISSIONS_NOT_ACCEPTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted;
/**
 *  The user is no longer valid. The user may have been deleted or disabled.
 *
 *  Value: "USER_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetail.nonComplianceReason

/**
 *  The admin type (profile owner, device owner, etc.) does not support the
 *  setting.
 *
 *  Value: "ADMIN_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AdminType;
/**
 *  The setting is not supported in the API level of Android OS version the
 *  device is running.
 *
 *  Value: "API_LEVEL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel;
/**
 *  The setting cannot be applied to the application because the application
 *  doesn't support it, for example because its target SDK version is not high
 *  enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible;
/**
 *  A blocked application is installed.
 *
 *  Value: "APP_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled;
/**
 *  The application required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled;
/**
 *  The application is installed but not updated to the minimum version code
 *  specified by policy
 *
 *  Value: "APP_NOT_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue;
/**
 *  This value is disallowed.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting was not applied yet at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_NonComplianceDetailCondition.nonComplianceReason

/**
 *  The admin type (profile owner, device owner, etc.) does not support the
 *  setting.
 *
 *  Value: "ADMIN_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AdminType;
/**
 *  The setting is not supported in the API level of Android OS version the
 *  device is running.
 *
 *  Value: "API_LEVEL"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel;
/**
 *  The setting cannot be applied to the application because the application
 *  doesn't support it, for example because its target SDK version is not high
 *  enough.
 *
 *  Value: "APP_INCOMPATIBLE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible;
/**
 *  A blocked application is installed.
 *
 *  Value: "APP_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled;
/**
 *  The application required to implement the policy is not installed.
 *
 *  Value: "APP_NOT_INSTALLED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled;
/**
 *  The application is installed but not updated to the minimum version code
 *  specified by policy
 *
 *  Value: "APP_NOT_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated;
/**
 *  The setting has an invalid value.
 *
 *  Value: "INVALID_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue;
/**
 *  This value is disallowed.
 *
 *  Value: "NON_COMPLIANCE_REASON_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified;
/**
 *  The setting was not applied yet at the time of the report, but is expected
 *  to be applied shortly.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending;
/**
 *  The policy is not supported by the version of Android Device Policy on the
 *  device.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported;
/**
 *  The user has not taken required action to comply with the setting.
 *
 *  Value: "USER_ACTION"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PasswordRequirements.passwordQuality

/**
 *  The password must contain alphabetic (or symbol) characters.
 *
 *  Value: "ALPHABETIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic;
/**
 *  The password must contain at both numeric and alphabetic (or symbol)
 *  characters.
 *
 *  Value: "ALPHANUMERIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric;
/**
 *  There must be at least low-security biometric recognition technology to
 *  secure the device. This includes technologies that can recognize the
 *  identity of an individual to about a 3 digit PIN (false detection is less
 *  than 1 in 1,000).
 *
 *  Value: "BIOMETRIC_WEAK"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak;
/**
 *  The password must contain at least a letter, a numerical digit and a special
 *  symbol. Other password constraints, for example, password_minimum_letters
 *  are enforced.
 *
 *  Value: "COMPLEX"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex;
/**
 *  The password must contain numeric characters.
 *
 *  Value: "NUMERIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric;
/**
 *  The password must contain numeric characters with no repeating (4444) or
 *  ordered (1234, 4321, 2468) sequences.
 *
 *  Value: "NUMERIC_COMPLEX"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex;
/**
 *  There are no requirements for the password.
 *
 *  Value: "PASSWORD_QUALITY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified;
/**
 *  There must be a password, but there are no restrictions on its characters.
 *
 *  Value: "SOMETHING"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PermissionGrant.policy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PermissionGrant_Policy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.defaultPermissionPolicy

/**
 *  Automatically deny a permission.
 *
 *  Value: "DENY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny;
/**
 *  Automatically grant a permission.
 *
 *  Value: "GRANT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant;
/**
 *  Policy not specified. If no policy is specified for a permission at any
 *  level, then the PROMPT behavior is used by default.
 *
 *  Value: "PERMISSION_POLICY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified;
/**
 *  Prompt the user to grant a permission.
 *
 *  Value: "PROMPT"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_Policy.stayOnPluggedModes

/** Value: "AC" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Ac;
/** Value: "BATTERY_PLUGGED_MODE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_BatteryPluggedModeUnspecified;
/** Value: "USB" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Usb;
/** Value: "WIRELESS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_Policy_StayOnPluggedModes_Wireless;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_PowerManagementEvent.eventType

/**
 *  Battery level was measured.
 *
 *  Value: "BATTERY_LEVEL_COLLECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected;
/**
 *  The device entered low-power mode.
 *
 *  Value: "BATTERY_LOW"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow;
/**
 *  The device exited low-power mode.
 *
 *  Value: "BATTERY_OKAY"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay;
/**
 *  The device booted.
 *
 *  Value: "BOOT_COMPLETED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted;
/**
 *  The device started charging.
 *
 *  Value: "POWER_CONNECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected;
/**
 *  The device stopped charging.
 *
 *  Value: "POWER_DISCONNECTED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected;
/**
 *  Unspecified. No events have this type.
 *
 *  Value: "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified;
/**
 *  The device shut down.
 *
 *  Value: "SHUTDOWN"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_SystemUpdate.type

/**
 *  Install automatically as soon as an update is available.
 *
 *  Value: "AUTOMATIC"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Automatic;
/**
 *  Postpone automatic install up to a maximum of 30 days.
 *
 *  Value: "POSTPONE"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Postpone;
/**
 *  Follow the default update behavior for the device, which typically requires
 *  the user to accept system updates.
 *
 *  Value: "SYSTEM_UPDATE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified;
/**
 *  Install automatically within a daily maintenance window. This also
 *  configures Play apps to be updated within the window. This is strongly
 *  recommended for kiosk devices because this is the only way apps persistently
 *  pinned to the foreground can be updated by Play.
 *
 *  Value: "WINDOWED"
 */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_SystemUpdate_Type_Windowed;

// ----------------------------------------------------------------------------
// GTLRAndroidManagement_WebToken.permissions

/** Value: "APPROVE_APPS" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_ApproveApps;
/** Value: "WEB_TOKEN_PERMISSION_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRAndroidManagement_WebToken_Permissions_WebTokenPermissionUnspecified;

/**
 *  A compliance rule condition which is satisfied if the Android Framework API
 *  level on the device does not meet a minimum requirement. There can only be
 *  one rule with this type of condition per policy.
 */
@interface GTLRAndroidManagement_ApiLevelCondition : GTLRObject

/**
 *  The minimum desired Android Framework API level. If the device does not meet
 *  the minimum requirement, this condition is satisfied. Must be greater than
 *  zero.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minApiLevel;

@end


/**
 *  Application information.
 */
@interface GTLRAndroidManagement_Application : GTLRObject

/**
 *  The set of managed properties available to be pre-configured for the
 *  application.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *managedProperties;

/**
 *  The name of the application in the form
 *  enterprises/{enterpriseId}/applications/{package_name}
 */
@property(nonatomic, copy, nullable) NSString *name;

/** The permissions required by the app. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPermission *> *permissions;

/** The title of the application. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Application permission.
 */
@interface GTLRAndroidManagement_ApplicationPermission : GTLRObject

/**
 *  A longer description of the permission, giving more details of what it
 *  affects. Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** The name of the permission. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/** An opaque string uniquely identifying the permission. Not localized. */
@property(nonatomic, copy, nullable) NSString *permissionId;

@end


/**
 *  Policy for an individual app.
 */
@interface GTLRAndroidManagement_ApplicationPolicy : GTLRObject

/**
 *  The default policy for all permissions requested by the app. If specified,
 *  this overrides the policy-level default_permission_policy which applies to
 *  all apps.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/**
 *  The type of installation to perform.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_ForceInstalled
 *        The application is automatically installed and cannot be removed by
 *        the user. (Value: "FORCE_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_InstallTypeUnspecified
 *        No automatic installation is performed. Any other app policies will be
 *        applied if the user installs the app. (Value:
 *        "INSTALL_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ApplicationPolicy_InstallType_Preinstalled
 *        The application is automatically installed and can be removed by the
 *        user. (Value: "PREINSTALLED")
 */
@property(nonatomic, copy, nullable) NSString *installType;

/**
 *  Whether the application is allowed to lock itself in full-screen mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lockTaskAllowed;

/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: <table> <tr><td><i>type</i></td><td><i>JSON
 *  value</i></td></tr> <tr><td>BOOL</td><td>true or false</td></tr>
 *  <tr><td>STRING</td><td>string</td></tr>
 *  <tr><td>INTEGER</td><td>number</td></tr>
 *  <tr><td>CHOICE</td><td>string</td></tr> <tr><td>MULTISELECT</td><td>array of
 *  strings</td></tr> <tr><td>HIDDEN</td><td>string</td></tr>
 *  <tr><td>BUNDLE_ARRAY</td><td>array of objects</td></tr> </table>
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration *managedConfiguration;

/**
 *  The package name of the app, e.g. com.google.android.youtube for the YouTube
 *  app.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  Explicit permission grants or denials for the app. These values override the
 *  default_permission_policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PermissionGrant *> *permissionGrants;

@end


/**
 *  Managed configuration applied to the app. The format for the configuration
 *  is dictated by the ManagedProperty values supported by the app. Each field
 *  name in the managed configuration must match the key field of the
 *  ManagedProperty. The field value must be compatible with the type of the
 *  ManagedProperty: <table> <tr><td><i>type</i></td><td><i>JSON
 *  value</i></td></tr> <tr><td>BOOL</td><td>true or false</td></tr>
 *  <tr><td>STRING</td><td>string</td></tr>
 *  <tr><td>INTEGER</td><td>number</td></tr>
 *  <tr><td>CHOICE</td><td>string</td></tr> <tr><td>MULTISELECT</td><td>array of
 *  strings</td></tr> <tr><td>HIDDEN</td><td>string</td></tr>
 *  <tr><td>BUNDLE_ARRAY</td><td>array of objects</td></tr> </table>
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_ApplicationPolicy_ManagedConfiguration : GTLRObject
@end


/**
 *  A command.
 */
@interface GTLRAndroidManagement_Command : GTLRObject

/**
 *  The timestamp at which the command was created. The timestamp is
 *  automatically generated by the server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The duration for which the command is valid. The command will expire if not
 *  executed by the device during this time. The default duration if unspecified
 *  is ten minutes. There is no maximum duration.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  For commands of type RESET_PASSWORD, optionally specifies the new password.
 */
@property(nonatomic, copy, nullable) NSString *newPassword NS_RETURNS_NOT_RETAINED;

/** For commands of type RESET_PASSWORD, optionally specifies flags. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *resetPasswordFlags;

/**
 *  The type of the command.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Command_Type_CommandTypeUnspecified This
 *        value is disallowed. (Value: "COMMAND_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Lock Lock the device, as if
 *        the lock screen timeout had expired. (Value: "LOCK")
 *    @arg @c kGTLRAndroidManagement_Command_Type_Reboot Reboot the device. Only
 *        supported on API level 24+. (Value: "REBOOT")
 *    @arg @c kGTLRAndroidManagement_Command_Type_ResetPassword Reset the user's
 *        password. (Value: "RESET_PASSWORD")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  A rule declaring which mitigating actions to take when a device is not
 *  compliant with its policy. For every rule, there is always an implicit
 *  mitigating action to set policy_compliant to false for the Device resource,
 *  and display a message on the device indicating that the device is not
 *  compliant with its policy. Other mitigating actions may optionally be taken
 *  as well, depending on the field values in the rule.
 */
@interface GTLRAndroidManagement_ComplianceRule : GTLRObject

/**
 *  A condition which is satisfied if the Android Framework API level on the
 *  device does not meet a minimum requirement.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ApiLevelCondition *apiLevelCondition;

/**
 *  If set to true, the rule includes a mitigating action to disable
 *  applications so that the device is effectively disabled, but application
 *  data is preserved. If the device is running an app in locked task mode, the
 *  app will be closed and a UI showing the reason for non-compliance will be
 *  displayed.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *disableApps;

/**
 *  A condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NonComplianceDetailCondition *nonComplianceDetailCondition;

@end


/**
 *  A device owned by an enterprise. Unless otherwise noted, all fields are
 *  read-only and cannot be modified by an update device request.
 */
@interface GTLRAndroidManagement_Device : GTLRObject

/**
 *  The API level of the Android platform version running on the device.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *apiLevel;

/** The name of the policy that is currently applied by the device. */
@property(nonatomic, copy, nullable) NSString *appliedPolicyName;

/**
 *  The version of the policy that is currently applied by the device.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appliedPolicyVersion;

/**
 *  The state that is currently applied by the device.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Active The device is
 *        active. (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Deleted The device was
 *        deleted. This state will never be returned by an API call, but will be
 *        used in the final policy compliance report published to Cloud Pub/Sub
 *        when the device acknowledges the deletion. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_DeviceStateUnspecified
 *        This value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_AppliedState_Provisioning The device
 *        is being provisioned. Newly enrolled devices will be in this state
 *        until they have applied policy. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *appliedState;

/**
 *  If the device state is DISABLED, an optional message that is displayed on
 *  the device indicating the reason the device is disabled. This field may be
 *  modified by an update request.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage *disabledReason;

/**
 *  Displays on the device. This information is only available when
 *  displayInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Display *> *displays;

/** The time of device enrollment. */
@property(nonatomic, strong, nullable) GTLRDateTime *enrollmentTime;

/**
 *  If this device was enrolled with an enrollment token with additional data
 *  provided, this field contains that data.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenData;

/**
 *  If this device was enrolled with an enrollment token, this field contains
 *  the name of the token.
 */
@property(nonatomic, copy, nullable) NSString *enrollmentTokenName;

/** Detailed information about the device hardware. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_HardwareInfo *hardwareInfo;

/**
 *  Hardware status samples in chronological order. This information is only
 *  available when hardwareStatusEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_HardwareStatus *> *hardwareStatusSamples;

/** The last time the device sent a policy compliance report. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicyComplianceReportTime;

/** The last time the device fetched its policy. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastPolicySyncTime;

/** The last time the device sent a status report. */
@property(nonatomic, strong, nullable) GTLRDateTime *lastStatusReportTime;

/**
 *  Events related to memory and storage measurements in chronological order.
 *  This information is only available when memoryInfoEnabled is true in the
 *  device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_MemoryEvent *> *memoryEvents;

/**
 *  Memory information. This information is only available when
 *  memoryInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_MemoryInfo *memoryInfo;

/**
 *  The name of the device in the form
 *  enterprises/{enterpriseId}/devices/{deviceId}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Device network information. This information is only available when
 *  networkInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_NetworkInfo *networkInfo;

/**
 *  Details about policy settings for which the device is not in compliance.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_NonComplianceDetail *> *nonComplianceDetails;

/**
 *  Whether the device is compliant with its policy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *policyCompliant;

/**
 *  The name of the policy that is intended to be applied to the device. If
 *  empty, the policy_name for the user that owns this device is applied. This
 *  field may be modified by an update request. The name of the policy is in the
 *  form enterprises/{enterpriseId}/policies/{policyId}. It is also permissible
 *  to only specify the policyId when updating this field as long as the
 *  policyId contains no slashes since the rest of the policy name can be
 *  inferred from context.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  Power management events on the device in chronological order. This
 *  information is only available when powerManagementEventsEnabled is true in
 *  the device's policy.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PowerManagementEvent *> *powerManagementEvents;

/**
 *  The previous device names used for the same physical device when it has been
 *  enrolled multiple times. The serial number is used as the unique identifier
 *  to determine if the same physical device has enrolled previously. The names
 *  are in chronological order.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *previousDeviceNames;

/**
 *  Detailed information about the device software. This information is only
 *  available when softwareInfoEnabled is true in the device's policy.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SoftwareInfo *softwareInfo;

/**
 *  The state that is intended to be applied to the device. This field may be
 *  modified by an update request. Note that UpdateDevice only handles toggling
 *  between ACTIVE and DISABLED states. Use the delete device method to cause
 *  the device to enter the DELETED state.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Device_State_Active The device is active.
 *        (Value: "ACTIVE")
 *    @arg @c kGTLRAndroidManagement_Device_State_Deleted The device was
 *        deleted. This state will never be returned by an API call, but will be
 *        used in the final policy compliance report published to Cloud Pub/Sub
 *        when the device acknowledges the deletion. (Value: "DELETED")
 *    @arg @c kGTLRAndroidManagement_Device_State_DeviceStateUnspecified This
 *        value is disallowed. (Value: "DEVICE_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Disabled The device is
 *        disabled. (Value: "DISABLED")
 *    @arg @c kGTLRAndroidManagement_Device_State_Provisioning The device is
 *        being provisioned. Newly enrolled devices will be in this state until
 *        they have applied policy. (Value: "PROVISIONING")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The resource name of the user that owns this device in the form
 *  enterprises/{enterpriseId}/users/{userId}.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Device display information.
 */
@interface GTLRAndroidManagement_Display : GTLRObject

/**
 *  Display density expressed as dots-per-inch.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *density;

/**
 *  Unique display id.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayId;

/**
 *  Display height in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *height;

/** Name of the display. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Refresh rate of the display in frames per second.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *refreshRate;

/**
 *  State of the display.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Display_State_DisplayStateUnspecified This
 *        value is disallowed. (Value: "DISPLAY_STATE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Display_State_Doze Display is dozing in a
 *        low power state (Value: "DOZE")
 *    @arg @c kGTLRAndroidManagement_Display_State_Off Display is off. (Value:
 *        "OFF")
 *    @arg @c kGTLRAndroidManagement_Display_State_On Display is on. (Value:
 *        "ON")
 *    @arg @c kGTLRAndroidManagement_Display_State_Suspended Display is dozing
 *        in a suspended low power state. (Value: "SUSPENDED")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  Display width in pixels.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for Empty is empty JSON object {}.
 */
@interface GTLRAndroidManagement_Empty : GTLRObject
@end


/**
 *  An enrollment token.
 */
@interface GTLRAndroidManagement_EnrollmentToken : GTLRObject

/**
 *  Optional, arbitrary data associated with the enrollment token. This could
 *  contain, for example, the id of an org unit to which the device is assigned
 *  after enrollment. After a device enrolls with the token, this data will be
 *  exposed in the enrollment_token_data field of the Device resource. The data
 *  must be 1024 characters or less; otherwise, the creation request will fail.
 */
@property(nonatomic, copy, nullable) NSString *additionalData;

/**
 *  The duration of the token. If not specified, the duration will be 1 hour.
 *  The allowed range is 1 minute to 30 days.
 */
@property(nonatomic, strong, nullable) GTLRDuration *duration;

/**
 *  The expiration time of the token. This is a read-only field generated by the
 *  server.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *expirationTimestamp;

/**
 *  The name of the enrollment token, which is generated by the server during
 *  creation, in the form
 *  enterprises/{enterpriseId}/enrollmentTokens/{enrollmentTokenId}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The name of the policy that will be initially applied to the enrolled device
 *  in the form enterprises/{enterpriseId}/policies/{policyId}. If not
 *  specified, the policy_name for the user that owns the device is applied. If
 *  user_name also isn't specified, the policy defaults to
 *  enterprises/{enterpriseId}/policies/default. It is permissible to only
 *  specify the policyId when updating this field as long as the policyId
 *  contains no slashes since the rest of the policy name can be inferred from
 *  context.
 */
@property(nonatomic, copy, nullable) NSString *policyName;

/**
 *  A JSON string whose UTF-8 representation can be used to generate a QR code
 *  to enroll a device with this enrollment token. To enroll a device using NFC,
 *  the NFC record must contain a serialized java.util.Properties representation
 *  of the properties in the JSON.
 */
@property(nonatomic, copy, nullable) NSString *qrCode;

/**
 *  The token value which is passed to the device and authorizes the device to
 *  enroll. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  The configuration applied to an enterprise.
 */
@interface GTLRAndroidManagement_Enterprise : GTLRObject

/**
 *  Whether app auto-approval is enabled. When enabled, apps installed via
 *  policy for this enterprise have all permissions automatically approved. When
 *  enabled, it is the caller's responsibility to display the permissions
 *  required by an app to the enterprise admin before setting the app to be
 *  installed in a policy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *appAutoApprovalEnabled;

/** The notification types to enable via Google Cloud Pub/Sub. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *enabledNotificationTypes;

/** The name of the enterprise as it will appear to users. */
@property(nonatomic, copy, nullable) NSString *enterpriseDisplayName;

/**
 *  An image displayed as a logo during device provisioning. Supported types
 *  are: image/bmp, image/gif, image/x-ico, image/jpeg, image/png, image/webp,
 *  image/vnd.wap.wbmp, image/x-adobe-dng.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_ExternalData *logo;

/**
 *  The name of the enterprise which is generated by the server during creation,
 *  in the form enterprises/{enterpriseId}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A color in RGB format indicating the predominant color to display in the
 *  device management app UI. The color components are stored as follows: (red
 *  << 16) | (green << 8) | blue, where each component may take a value between
 *  0 and 255 inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *primaryColor;

/**
 *  When Cloud Pub/Sub notifications are enabled, this field is required to
 *  indicate the topic to which the notifications will be published. The format
 *  of this field is projects/{project}/topics/{topic}. You must have granted
 *  the publish permission on this topic to
 *  android-cloud-policy\@system.gserviceaccount.com
 */
@property(nonatomic, copy, nullable) NSString *pubsubTopic;

@end


/**
 *  Data hosted at an external location. The data is to be downloaded by Android
 *  Device Policy and verified against the hash.
 */
@interface GTLRAndroidManagement_ExternalData : GTLRObject

/**
 *  The base-64 encoded SHA-256 hash of the content hosted at url. If the
 *  content does not match this hash, Android Device Policy will not use the
 *  data.
 */
@property(nonatomic, copy, nullable) NSString *sha256Hash;

/**
 *  The absolute URL to the data, which must use either the http or https
 *  scheme. Android Device Policy does not provide any credentials in the GET
 *  request, so the URL must be publicly accessible. Including a long, random
 *  component in the URL may be used to prevent attackers from discovering the
 *  URL.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Information about device hardware. The fields related to temperature
 *  thresholds are only available when hardwareStatusEnabled is true in the
 *  device's policy.
 */
@interface GTLRAndroidManagement_HardwareInfo : GTLRObject

/**
 *  Battery shutdown temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryShutdownTemperatures;

/**
 *  Battery throttling temperature thresholds in Celsius for each battery on the
 *  device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryThrottlingTemperatures;

/** Brand of the device, e.g. Google. */
@property(nonatomic, copy, nullable) NSString *brand;

/**
 *  CPU shutdown temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuShutdownTemperatures;

/**
 *  CPU throttling temperature thresholds in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuThrottlingTemperatures;

/** Baseband version, e.g. MDM9625_104662.22.05.34p. */
@property(nonatomic, copy, nullable) NSString *deviceBasebandVersion;

/**
 *  GPU shutdown temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuShutdownTemperatures;

/**
 *  GPU throttling temperature thresholds in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuThrottlingTemperatures;

/** Name of the hardware, e.g. Angler. */
@property(nonatomic, copy, nullable) NSString *hardware;

/** Manufacturer, e.g. Motorola. */
@property(nonatomic, copy, nullable) NSString *manufacturer;

/** The model of the device, e.g. Asus Nexus 7. */
@property(nonatomic, copy, nullable) NSString *model;

/** The device serial number. */
@property(nonatomic, copy, nullable) NSString *serialNumber;

/**
 *  Device skin shutdown temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinShutdownTemperatures;

/**
 *  Device skin throttling temperature thresholds in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinThrottlingTemperatures;

@end


/**
 *  Hardware status. Temperatures may be compared to the temperature thresholds
 *  available in hardwareInfo to determine hardware health.
 */
@interface GTLRAndroidManagement_HardwareStatus : GTLRObject

/**
 *  Current battery temperatures in Celsius for each battery on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *batteryTemperatures;

/**
 *  Current CPU temperatures in Celsius for each CPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuTemperatures;

/**
 *  CPU usages in percentage for each core available on the device. Usage is 0
 *  for each unplugged core. Empty array implies that CPU usage is not supported
 *  in the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *cpuUsages;

/** The time the measurements were taken. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Fan speeds in RPM for each fan on the device. Empty array means that there
 *  are no fans or fan speed is not supported on the system.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *fanSpeeds;

/**
 *  Current GPU temperatures in Celsius for each GPU on the device.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *gpuTemperatures;

/**
 *  Current device skin temperatures in Celsius.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *skinTemperatures;

@end


/**
 *  Response to a request to list devices for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "devices" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListDevicesResponse : GTLRCollectionObject

/**
 *  The list of devices.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Device *> *devices;

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Operation *> *operations;

@end


/**
 *  Response to a request to list policies for a given enterprise.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "policies" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAndroidManagement_ListPoliciesResponse : GTLRCollectionObject

/** If there are more results, a token to retrieve next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The list of policies.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Policy *> *policies;

@end


/**
 *  Managed property.
 */
@interface GTLRAndroidManagement_ManagedProperty : GTLRObject

/**
 *  The default value of the properties. BUNDLE_ARRAY properties never have a
 *  default value.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id defaultValue;

/**
 *  A longer description of the property, giving more detail of what it affects.
 *  Localized.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** For CHOICE or MULTISELECT properties, the list of possible entries. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedPropertyEntry *> *entries;

/**
 *  The unique key that the application uses to identify the property, e.g.
 *  "com.google.android.gm.fieldname".
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  For BUNDLE_ARRAY properties, the list of nested properties. A BUNDLE_ARRAY
 *  property is at most two levels deep.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ManagedProperty *> *nestedProperties;

/** The name of the property. Localized. */
@property(nonatomic, copy, nullable) NSString *title;

/**
 *  The type of the property.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Bool A property of
 *        boolean type. (Value: "BOOL")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_BundleArray An array
 *        of property bundles. (Value: "BUNDLE_ARRAY")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Choice A choice of one
 *        item from a set. (Value: "CHOICE")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Hidden A hidden
 *        restriction of string type (the default value can be used to pass
 *        along information that cannot be modified, such as a version code).
 *        (Value: "HIDDEN")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Integer A property of
 *        integer type. (Value: "INTEGER")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_ManagedPropertyTypeUnspecified
 *        Not used. (Value: "MANAGED_PROPERTY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_Multiselect A choice
 *        of multiple items from a set. (Value: "MULTISELECT")
 *    @arg @c kGTLRAndroidManagement_ManagedProperty_Type_String A property of
 *        string type. (Value: "STRING")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  An entry of a managed property.
 */
@interface GTLRAndroidManagement_ManagedPropertyEntry : GTLRObject

/** The human-readable name of the value. Localized. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The machine-readable value of the entry, which should be used in the
 *  configuration. Not localized.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  An event related to memory and storage measurements.
 */
@interface GTLRAndroidManagement_MemoryEvent : GTLRObject

/**
 *  The number of free bytes in the medium, or for EXTERNAL_STORAGE_DETECTED,
 *  the total capacity in bytes of the storage medium.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *byteCount;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageDetected
 *        A new external storage medium was detected. The reported byte count is
 *        the total capacity of the storage medium. (Value:
 *        "EXTERNAL_STORAGE_DETECTED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageMeasured
 *        Free space in an external storage medium was measured. (Value:
 *        "EXTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_ExternalStorageRemoved
 *        An external storage medium was removed. The reported byte count is
 *        zero. (Value: "EXTERNAL_STORAGE_REMOVED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_InternalStorageMeasured
 *        Free space in internal storage was measured. (Value:
 *        "INTERNAL_STORAGE_MEASURED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_MemoryEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "MEMORY_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_MemoryEvent_EventType_RamMeasured Free
 *        space in RAM was measured. (Value: "RAM_MEASURED")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  Information about device memory and storage.
 */
@interface GTLRAndroidManagement_MemoryInfo : GTLRObject

/**
 *  Total internal storage on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalInternalStorage;

/**
 *  Total RAM on device in bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalRam;

@end


/**
 *  Device network info.
 */
@interface GTLRAndroidManagement_NetworkInfo : GTLRObject

/** IMEI number of the GSM device, e.g. A1000031212. */
@property(nonatomic, copy, nullable) NSString *imei;

/** MEID number of the CDMA device, e.g. A00000292788E1. */
@property(nonatomic, copy, nullable) NSString *meid;

/** WiFi MAC address of the device, e.g. 7c:11:11:11:11:11. */
@property(nonatomic, copy, nullable) NSString *wifiMacAddress;

@end


/**
 *  Provides detail about non-compliance with a policy setting.
 */
@interface GTLRAndroidManagement_NonComplianceDetail : GTLRObject

/**
 *  If the policy setting could not be applied, the current value of the setting
 *  on the device.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id currentValue;

/**
 *  For settings with nested fields, if a particular nested field is out of
 *  compliance, this specifies the full path to the offending field. The path is
 *  formatted in the same way the policy JSON field would be referenced in
 *  JavaScript, that is: 1) For object-typed fields, the field name is followed
 *  by a dot then by a subfield name. 2) For array-typed fields, the field name
 *  is followed by the array index enclosed in brackets. For example, to
 *  indicate a problem with the url field in the externalData field in the 3rd
 *  application, the path would be applications[2].externalData.url
 */
@property(nonatomic, copy, nullable) NSString *fieldPath;

/**
 *  If package_name is set and the non-compliance reason is APP_NOT_INSTALLED or
 *  APP_NOT_UPDATED, the detailed reason the app cannot be installed or updated.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InProgress
 *        The installation is still in progress. (Value: "IN_PROGRESS")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnknown
 *        An unknown condition is preventing the app from being installed. Some
 *        potential reaons are that the device does not have enough storage, the
 *        device network connection is unreliable, or the installation is taking
 *        longer than expected. The installation will be retried automatically.
 *        (Value: "INSTALLATION_FAILURE_REASON_UNKNOWN")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_InstallationFailureReasonUnspecified
 *        This value is disallowed. (Value:
 *        "INSTALLATION_FAILURE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NoLicensesRemaining
 *        There are no more licenses to assign to the user. (Value:
 *        "NO_LICENSES_REMAINING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotApproved
 *        The app has not been approved by the admin. (Value: "NOT_APPROVED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotAvailableInCountry
 *        The app is not available in the user's country. (Value:
 *        "NOT_AVAILABLE_IN_COUNTRY")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotCompatibleWithDevice
 *        The app is incompatible with the device. (Value:
 *        "NOT_COMPATIBLE_WITH_DEVICE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotEnrolled
 *        The enterprise is no longer enrolled with Play for Work or Android
 *        Device Policy is not enabled for the enterprise. (Value:
 *        "NOT_ENROLLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_NotFound
 *        The app was not found in Play. (Value: "NOT_FOUND")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_PermissionsNotAccepted
 *        The app has new permissions that have not been accepted by the admin.
 *        (Value: "PERMISSIONS_NOT_ACCEPTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_InstallationFailureReason_UserInvalid
 *        The user is no longer valid. The user may have been deleted or
 *        disabled. (Value: "USER_INVALID")
 */
@property(nonatomic, copy, nullable) NSString *installationFailureReason;

/**
 *  The reason the device is not in compliance with the setting.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AdminType
 *        The admin type (profile owner, device owner, etc.) does not support
 *        the setting. (Value: "ADMIN_TYPE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of Android OS version
 *        the device is running. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppIncompatible
 *        The setting cannot be applied to the application because the
 *        application doesn't support it, for example because its target SDK
 *        version is not high enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppInstalled
 *        A blocked application is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotInstalled
 *        The application required to implement the policy is not installed.
 *        (Value: "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_AppNotUpdated
 *        The application is installed but not updated to the minimum version
 *        code specified by policy (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is disallowed. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Pending
 *        The setting was not applied yet at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetail_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name indicating which application is out of compliance, if
 *  applicable.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

@end


/**
 *  A compliance rule condition which is satisfied if there exists any matching
 *  NonComplianceDetail for the device. A NonComplianceDetail matches a
 *  NonComplianceDetailCondition if all the fields which are set within the
 *  NonComplianceDetailCondition match the corresponding NonComplianceDetail
 *  fields.
 */
@interface GTLRAndroidManagement_NonComplianceDetailCondition : GTLRObject

/**
 *  The reason the device is not in compliance with the setting. If not set,
 *  then this condition matches any reason.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AdminType
 *        The admin type (profile owner, device owner, etc.) does not support
 *        the setting. (Value: "ADMIN_TYPE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_ApiLevel
 *        The setting is not supported in the API level of Android OS version
 *        the device is running. (Value: "API_LEVEL")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppIncompatible
 *        The setting cannot be applied to the application because the
 *        application doesn't support it, for example because its target SDK
 *        version is not high enough. (Value: "APP_INCOMPATIBLE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppInstalled
 *        A blocked application is installed. (Value: "APP_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotInstalled
 *        The application required to implement the policy is not installed.
 *        (Value: "APP_NOT_INSTALLED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_AppNotUpdated
 *        The application is installed but not updated to the minimum version
 *        code specified by policy (Value: "APP_NOT_UPDATED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_InvalidValue
 *        The setting has an invalid value. (Value: "INVALID_VALUE")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_NonComplianceReasonUnspecified
 *        This value is disallowed. (Value: "NON_COMPLIANCE_REASON_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Pending
 *        The setting was not applied yet at the time of the report, but is
 *        expected to be applied shortly. (Value: "PENDING")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_Unsupported
 *        The policy is not supported by the version of Android Device Policy on
 *        the device. (Value: "UNSUPPORTED")
 *    @arg @c kGTLRAndroidManagement_NonComplianceDetailCondition_NonComplianceReason_UserAction
 *        The user has not taken required action to comply with the setting.
 *        (Value: "USER_ACTION")
 */
@property(nonatomic, copy, nullable) NSString *nonComplianceReason;

/**
 *  The package name indicating which application is out of compliance. If not
 *  set, then this condition matches any package name.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  The name of the policy setting. This is the JSON field name of a top-level
 *  Policy field. If not set, then this condition matches any setting name.
 */
@property(nonatomic, copy, nullable) NSString *settingName;

@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRAndroidManagement_Operation : GTLRObject

/**
 *  If the value is false, it means the operation is still in progress. If true,
 *  the operation is completed, and either error or response is available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the name should
 *  have the format of operations/some/unique/name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time. Some
 *  services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as Delete, the response is
 *  google.protobuf.Empty. If the original method is standard Get/Create/Update,
 *  the response should be the resource. For other methods, the response should
 *  have the type XxxResponse, where Xxx is the original method name. For
 *  example, if the original method name is TakeSnapshot(), the inferred
 *  response type is TakeSnapshotResponse.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Operation_Response : GTLRObject
@end


/**
 *  Requirements for the password used to unlock a device.
 */
@interface GTLRAndroidManagement_PasswordRequirements : GTLRObject

/**
 *  A device will be wiped after too many incorrect device-unlock passwords have
 *  been entered. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumFailedPasswordsForWipe;

/** Password expiration timeout. */
@property(nonatomic, strong, nullable) GTLRDuration *passwordExpirationTimeout;

/**
 *  The length of the password history. After setting this, the user will not be
 *  able to enter a new password that is the same as any password in the
 *  history. A value of 0 means there is no restriction.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordHistoryLength;

/**
 *  The minimum allowed password length. A value of 0 means there is no
 *  restriction. Only enforced when password_quality is NUMERIC,
 *  NUMERIC_COMPLEX, ALPHABETIC, ALPHANUMERIC, or COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLength;

/**
 *  Minimum number of letters required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLetters;

/**
 *  Minimum number of lower case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumLowerCase;

/**
 *  Minimum number of non-letter characters (numerical digits or symbols)
 *  required in the password. Only enforced when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNonLetter;

/**
 *  Minimum number of numerical digits required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumNumeric;

/**
 *  Minimum number of symbols required in the password. Only enforced when
 *  password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumSymbols;

/**
 *  Minimum number of upper case letters required in the password. Only enforced
 *  when password_quality is COMPLEX.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *passwordMinimumUpperCase;

/**
 *  The required password quality.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphabetic
 *        The password must contain alphabetic (or symbol) characters. (Value:
 *        "ALPHABETIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Alphanumeric
 *        The password must contain at both numeric and alphabetic (or symbol)
 *        characters. (Value: "ALPHANUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_BiometricWeak
 *        There must be at least low-security biometric recognition technology
 *        to secure the device. This includes technologies that can recognize
 *        the identity of an individual to about a 3 digit PIN (false detection
 *        is less than 1 in 1,000). (Value: "BIOMETRIC_WEAK")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Complex
 *        The password must contain at least a letter, a numerical digit and a
 *        special symbol. Other password constraints, for example,
 *        password_minimum_letters are enforced. (Value: "COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Numeric
 *        The password must contain numeric characters. (Value: "NUMERIC")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_NumericComplex
 *        The password must contain numeric characters with no repeating (4444)
 *        or ordered (1234, 4321, 2468) sequences. (Value: "NUMERIC_COMPLEX")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_PasswordQualityUnspecified
 *        There are no requirements for the password. (Value:
 *        "PASSWORD_QUALITY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PasswordRequirements_PasswordQuality_Something
 *        There must be a password, but there are no restrictions on its
 *        characters. (Value: "SOMETHING")
 */
@property(nonatomic, copy, nullable) NSString *passwordQuality;

@end


/**
 *  Configuration for an Android permission and its grant state.
 */
@interface GTLRAndroidManagement_PermissionGrant : GTLRObject

/** The android permission, e.g. android.permission.READ_CALENDAR. */
@property(nonatomic, copy, nullable) NSString *permission;

/**
 *  The policy for granting the permission.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Deny Automatically
 *        deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Grant Automatically
 *        grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PermissionGrant_Policy_Prompt Prompt the
 *        user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *policy;

@end


/**
 *  A default activity for handling intents that match a particular intent
 *  filter.
 */
@interface GTLRAndroidManagement_PersistentPreferredActivity : GTLRObject

/**
 *  The intent actions to match in the filter. If any actions are included in
 *  the filter, then an intent's action must be one of those values for it to
 *  match. If no actions are included, the intent action is ignored.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *actions;

/**
 *  The intent categories to match in the filter. An intent includes the
 *  categories that it requires, all of which must be included in the filter in
 *  order to match. In other words, adding a category to the filter has no
 *  impact on matching unless that category is specified in the intent.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *categories;

/**
 *  The activity that should be the default intent handler. This should be an
 *  Android component name, e.g. com.android.enterprise.app/.MainActivity.
 *  Alternatively, the value may be the package name of an app, which causes
 *  Android Device Policy to choose an appropriate activity from the app to
 *  handle the intent.
 */
@property(nonatomic, copy, nullable) NSString *receiverActivity;

@end


/**
 *  A policy, which governs behavior for a device.
 */
@interface GTLRAndroidManagement_Policy : GTLRObject

/**
 *  Whether adding new users and profiles is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *addUserDisabled;

/**
 *  Whether adjusting the master volume is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *adjustVolumeDisabled;

/** Policy applied to apps. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ApplicationPolicy *> *applications;

/**
 *  Whether auto time is required, which prevents the user from manually setting
 *  the date and time.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *autoTimeRequired;

/**
 *  Whether applications other than the ones configured in applications are
 *  blocked from being installed. When set, applications that were installed
 *  under a previous policy but no longer appear in the policy are automatically
 *  uninstalled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockApplicationsEnabled;

/**
 *  Whether all cameras on the device are disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cameraDisabled;

/**
 *  Rules declaring which mitigating actions to take when a device is not
 *  compliant with its policy. When the conditions for multiple rules are
 *  satisfied, all of the mitigating actions for the rules are taken. There is a
 *  maximum limit of 100 rules.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_ComplianceRule *> *complianceRules;

/**
 *  Whether the user is allowed to enable debugging features.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *debuggingFeaturesAllowed;

/**
 *  The default permission policy for requests for runtime permissions.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Deny
 *        Automatically deny a permission. (Value: "DENY")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Grant
 *        Automatically grant a permission. (Value: "GRANT")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_PermissionPolicyUnspecified
 *        Policy not specified. If no policy is specified for a permission at
 *        any level, then the PROMPT behavior is used by default. (Value:
 *        "PERMISSION_POLICY_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_Policy_DefaultPermissionPolicy_Prompt
 *        Prompt the user to grant a permission. (Value: "PROMPT")
 */
@property(nonatomic, copy, nullable) NSString *defaultPermissionPolicy;

/**
 *  Whether factory resetting from settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *factoryResetDisabled;

/**
 *  Email addresses of device administrators for factory reset protection. When
 *  the device is factory reset, it will require one of these admins to log in
 *  with the Google account email and password to unlock the device. If no
 *  admins are specified, the device will not provide factory reset protection.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *frpAdminEmails;

/**
 *  Whether the user is allowed to have fun. Controls whether the Easter egg
 *  game in Settings is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *funDisabled;

/**
 *  Whether the user is allowed to enable the "Unknown Sources" setting, which
 *  allows installation of apps from unknown sources.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *installUnknownSourcesAllowed;

/**
 *  Whether the keyguard is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *keyguardDisabled;

/**
 *  Maximum time in milliseconds for user activity until the device will lock. A
 *  value of 0 means there is no restriction.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximumTimeToLock;

/**
 *  Whether adding or removing accounts is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *modifyAccountsDisabled;

/**
 *  The name of the policy in the form
 *  enterprises/{enterpriseId}/policies/{policyId}
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Whether the network escape hatch is enabled. If a network connection can't
 *  be made at boot time, the escape hatch prompts the user to temporarily
 *  connect to a network in order to refresh the device policy. After applying
 *  policy, the temporary network will be forgotten and the device will continue
 *  booting. This prevents being unable to connect to a network if there is no
 *  suitable network in the last policy and the device boots into an app in lock
 *  task mode, or the user is otherwise unable to reach device settings.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkEscapeHatchEnabled;

/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_Policy_OpenNetworkConfiguration *openNetworkConfiguration;

/** Password requirements. */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_PasswordRequirements *passwordRequirements;

/** Default intent handler activities. */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_PersistentPreferredActivity *> *persistentPreferredActivities;

/**
 *  Whether removing other users is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *removeUserDisabled;

/**
 *  Whether rebooting the device into safe boot is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *safeBootDisabled;

/**
 *  Whether screen capture is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *screenCaptureDisabled;

/**
 *  Whether the status bar is disabled. This disables notifications, quick
 *  settings and other screen overlays that allow escape from full-screen mode.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *statusBarDisabled;

/** Status reporting settings */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_StatusReportingSettings *statusReportingSettings;

/**
 *  The battery plugged in modes for which the device stays on. When using this
 *  setting, it is recommended to clear maximum_time_to_lock so that the device
 *  doesn't lock itself while it stays on.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *stayOnPluggedModes;

/**
 *  The system update policy, which controls how OS updates are applied. If the
 *  update type is WINDOWED, the update window will automatically apply to Play
 *  app updates as well.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_SystemUpdate *systemUpdate;

/**
 *  Whether the microphone is muted and adjusting microphone volume is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *unmuteMicrophoneDisabled;

/**
 *  The version of the policy. This is a read-only field. The version is
 *  incremented each time the policy is updated.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

/**
 *  Whether configuring WiFi access points is disabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigDisabled;

/**
 *  Whether WiFi networks defined in Open Network Configuration are locked so
 *  they cannot be edited by the user.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *wifiConfigsLockdownEnabled;

@end


/**
 *  Network configuration for the device. See configure networks for more
 *  information.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Policy_OpenNetworkConfiguration : GTLRObject
@end


/**
 *  A power management event.
 */
@interface GTLRAndroidManagement_PowerManagementEvent : GTLRObject

/**
 *  For BATTERY_LEVEL_COLLECTED events, the battery level as a percentage.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *batteryLevel;

/** The creation time of the event. */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  Event type.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLevelCollected
 *        Battery level was measured. (Value: "BATTERY_LEVEL_COLLECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryLow
 *        The device entered low-power mode. (Value: "BATTERY_LOW")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BatteryOkay
 *        The device exited low-power mode. (Value: "BATTERY_OKAY")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_BootCompleted
 *        The device booted. (Value: "BOOT_COMPLETED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerConnected
 *        The device started charging. (Value: "POWER_CONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerDisconnected
 *        The device stopped charging. (Value: "POWER_DISCONNECTED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_PowerManagementEventTypeUnspecified
 *        Unspecified. No events have this type. (Value:
 *        "POWER_MANAGEMENT_EVENT_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_PowerManagementEvent_EventType_Shutdown The
 *        device shut down. (Value: "SHUTDOWN")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

@end


/**
 *  An enterprise signup URL.
 */
@interface GTLRAndroidManagement_SignupUrl : GTLRObject

/**
 *  The name of the resource. This must be included in the create enterprise
 *  request at the end of the signup flow.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A URL under which the Admin can sign up for an enterprise. The page pointed
 *  to cannot be rendered in an iframe.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Information about device software.
 */
@interface GTLRAndroidManagement_SoftwareInfo : GTLRObject

/**
 *  Android build Id string meant for displaying to the user, e.g.
 *  shamu-userdebug 6.0.1 MOB30I 2756745 dev-keys.
 */
@property(nonatomic, copy, nullable) NSString *androidBuildNumber;

/** Build time. */
@property(nonatomic, strong, nullable) GTLRDateTime *androidBuildTime;

/** The user visible Android version string, e.g. 6.0.1. */
@property(nonatomic, copy, nullable) NSString *androidVersion;

/** The system bootloader version number, e.g. 0.6.7. */
@property(nonatomic, copy, nullable) NSString *bootloaderVersion;

/** Kernel version, e.g. 2.6.32.9-g103d848. */
@property(nonatomic, copy, nullable) NSString *deviceKernelVersion;

/** Security patch level, e.g. 2016-05-01. */
@property(nonatomic, copy, nullable) NSString *securityPatchLevel;

@end


/**
 *  The Status type defines a logical error model that is suitable for different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  gRPC (https://github.com/grpc). The error model is designed to be:
 *  Simple to use and understand for most users
 *  Flexible enough to meet unexpected needsOverviewThe Status message contains
 *  three pieces of data: error code, error message, and error details. The
 *  error code should be an enum value of google.rpc.Code, but it may accept
 *  additional error codes if needed. The error message should be a
 *  developer-facing English message that helps developers understand and
 *  resolve the error. If a localized user-facing error message is needed, put
 *  the localized message in the error details or localize it in the client. The
 *  optional error details may contain arbitrary information about the error.
 *  There is a predefined set of error detail types in the package google.rpc
 *  that can be used for common error conditions.Language mappingThe Status
 *  message is the logical representation of the error model, but it is not
 *  necessarily the actual wire format. When the Status message is exposed in
 *  different client libraries and different wire protocols, it can be mapped
 *  differently. For example, it will likely be mapped to some exceptions in
 *  Java, but more likely mapped to some error codes in C.Other usesThe error
 *  model and the Status message can be used in a variety of environments,
 *  either with or without APIs, to provide a consistent developer experience
 *  across different environments.Example uses of this error model include:
 *  Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the Status in the normal response to indicate the partial
 *  errors.
 *  Workflow errors. A typical workflow has multiple steps. Each step may have a
 *  Status message for error reporting.
 *  Batch operations. If a client uses batch request and batch response, the
 *  Status message should be used directly inside batch response, one for each
 *  error sub-response.
 *  Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the Status message.
 *  Logging. If some API errors are stored in logs, the message Status could be
 *  used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRAndroidManagement_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAndroidManagement_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRAndroidManagement_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRAndroidManagement_Status_Details_Item : GTLRObject
@end


/**
 *  Settings controlling the behavior of status reports.
 */
@interface GTLRAndroidManagement_StatusReportingSettings : GTLRObject

/**
 *  Whether displays reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *displayInfoEnabled;

/**
 *  Whether hardware status reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hardwareStatusEnabled;

/**
 *  Whether memory info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *memoryInfoEnabled;

/**
 *  Whether network info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *networkInfoEnabled;

/**
 *  Whether power management event reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *powerManagementEventsEnabled;

/**
 *  Whether software info reporting is enabled.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *softwareInfoEnabled;

@end


/**
 *  Configuration for managing system updates
 */
@interface GTLRAndroidManagement_SystemUpdate : GTLRObject

/**
 *  If the type is WINDOWED, the end of the maintenance window, measured as the
 *  number of minutes after midnight in device local time. This value must be
 *  between 0 and 1439, inclusive. If this value is less than start_minutes,
 *  then the maintenance window spans midnight. If the maintenance window
 *  specified is smaller than 30 minutes, the actual window is extended to 30
 *  minutes beyond the start time.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endMinutes;

/**
 *  If the type is WINDOWED, the start of the maintenance window, measured as
 *  the number of minutes after midnight in device local time. This value must
 *  be between 0 and 1439, inclusive.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startMinutes;

/**
 *  The type of system update to configure.
 *
 *  Likely values:
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Automatic Install
 *        automatically as soon as an update is available. (Value: "AUTOMATIC")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Postpone Postpone
 *        automatic install up to a maximum of 30 days. (Value: "POSTPONE")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_SystemUpdateTypeUnspecified
 *        Follow the default update behavior for the device, which typically
 *        requires the user to accept system updates. (Value:
 *        "SYSTEM_UPDATE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAndroidManagement_SystemUpdate_Type_Windowed Install
 *        automatically within a daily maintenance window. This also configures
 *        Play apps to be updated within the window. This is strongly
 *        recommended for kiosk devices because this is the only way apps
 *        persistently pinned to the foreground can be updated by Play. (Value:
 *        "WINDOWED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Provides user facing message with locale info. The maximum message length is
 *  4096 characters.
 */
@interface GTLRAndroidManagement_UserFacingMessage : GTLRObject

/**
 *  The default message that gets displayed if no localized message is
 *  specified, or the user's locale does not match with any of the localized
 *  messages. A default message must be provided if any localized messages are
 *  provided.
 */
@property(nonatomic, copy, nullable) NSString *defaultMessage;

/**
 *  A map which contains <locale, message> pairs. The locale is a BCP 47
 *  language code, e.g. en-US, es-ES, fr.
 */
@property(nonatomic, strong, nullable) GTLRAndroidManagement_UserFacingMessage_LocalizedMessages *localizedMessages;

@end


/**
 *  A map which contains <locale, message> pairs. The locale is a BCP 47
 *  language code, e.g. en-US, es-ES, fr.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRAndroidManagement_UserFacingMessage_LocalizedMessages : GTLRObject
@end


/**
 *  A web token used to access an embeddable managed Google Play web UI.
 */
@interface GTLRAndroidManagement_WebToken : GTLRObject

/**
 *  The name of the web token, which is generated by the server during creation,
 *  in the form enterprises/{enterpriseId}/webTokens/{webTokenId}.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The URL of the parent frame hosting the iframe with the embedded UI. To
 *  prevent XSS, the iframe may not be hosted at other URLs. The URL must use
 *  the https scheme.
 */
@property(nonatomic, copy, nullable) NSString *parentFrameUrl;

/**
 *  Permissions the admin may exercise in the embedded UI. The admin must have
 *  all of these permissions in order to view the UI.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

/**
 *  The token value which is used in the hosting page to generate the iframe
 *  with the embedded UI. This is a read-only field generated by the server.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
