// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Bigtable Admin API (bigtableadmin/v2)
// Documentation:
//   https://cloud.google.com/bigtable/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRBigtableAdmin_AppProfile;
@class GTLRBigtableAdmin_AuditConfig;
@class GTLRBigtableAdmin_AuditLogConfig;
@class GTLRBigtableAdmin_Binding;
@class GTLRBigtableAdmin_Cluster;
@class GTLRBigtableAdmin_ClusterState;
@class GTLRBigtableAdmin_ColumnFamily;
@class GTLRBigtableAdmin_CreateClusterMetadata_Tables;
@class GTLRBigtableAdmin_CreateClusterRequest;
@class GTLRBigtableAdmin_CreateInstanceRequest;
@class GTLRBigtableAdmin_CreateInstanceRequest_Clusters;
@class GTLRBigtableAdmin_Expr;
@class GTLRBigtableAdmin_GcRule;
@class GTLRBigtableAdmin_Instance;
@class GTLRBigtableAdmin_Instance_Labels;
@class GTLRBigtableAdmin_Intersection;
@class GTLRBigtableAdmin_Modification;
@class GTLRBigtableAdmin_MultiClusterRoutingUseAny;
@class GTLRBigtableAdmin_Operation;
@class GTLRBigtableAdmin_Operation_Metadata;
@class GTLRBigtableAdmin_Operation_Response;
@class GTLRBigtableAdmin_PartialUpdateInstanceRequest;
@class GTLRBigtableAdmin_Policy;
@class GTLRBigtableAdmin_SingleClusterRouting;
@class GTLRBigtableAdmin_Split;
@class GTLRBigtableAdmin_Status;
@class GTLRBigtableAdmin_Status_Details_Item;
@class GTLRBigtableAdmin_Table;
@class GTLRBigtableAdmin_Table_ClusterStates;
@class GTLRBigtableAdmin_Table_ColumnFamilies;
@class GTLRBigtableAdmin_TableProgress;
@class GTLRBigtableAdmin_Union;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Cluster.defaultStorageType

/**
 *  Magnetic drive (HDD) storage should be used.
 *
 *  Value: "HDD"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_DefaultStorageType_Hdd;
/**
 *  Flash (SSD) storage should be used.
 *
 *  Value: "SSD"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_DefaultStorageType_Ssd;
/**
 *  The user did not specify a storage type.
 *
 *  Value: "STORAGE_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_DefaultStorageType_StorageTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Cluster.state

/**
 *  The cluster is currently being created, and may be destroyed
 *  if the creation process encounters an error.
 *  A cluster may not be able to serve requests while being created.
 *
 *  Value: "CREATING"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Creating;
/**
 *  The cluster has no backing nodes. The data (tables) still
 *  exist, but no operations can be performed on the cluster.
 *
 *  Value: "DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Disabled;
/**
 *  The cluster has been successfully created and is ready to serve requests.
 *
 *  Value: "READY"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Ready;
/**
 *  The cluster is currently being resized, and may revert to its previous
 *  node count if the process encounters an error.
 *  A cluster is still capable of serving requests while being resized,
 *  but may exhibit performance as if its number of allocated nodes is
 *  between the starting and requested states.
 *
 *  Value: "RESIZING"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_Resizing;
/**
 *  The state of the cluster could not be determined.
 *
 *  Value: "STATE_NOT_KNOWN"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Cluster_State_StateNotKnown;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_ClusterState.replicationState

/**
 *  The cluster was recently created, and the table must finish copying
 *  over pre-existing data from other clusters before it can begin
 *  receiving live replication updates and serving Data API requests.
 *
 *  Value: "INITIALIZING"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_Initializing;
/**
 *  The table is temporarily unable to serve Data API requests from this
 *  cluster due to planned internal maintenance.
 *
 *  Value: "PLANNED_MAINTENANCE"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_PlannedMaintenance;
/**
 *  The table can serve Data API requests from this cluster. Depending on
 *  replication delay, reads may not immediately reflect the state of the
 *  table in other clusters.
 *
 *  Value: "READY"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_Ready;
/**
 *  The replication state of the table is unknown in this cluster.
 *
 *  Value: "STATE_NOT_KNOWN"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_StateNotKnown;
/**
 *  The table is temporarily unable to serve Data API requests from this
 *  cluster due to unplanned or emergency maintenance.
 *
 *  Value: "UNPLANNED_MAINTENANCE"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_ClusterState_ReplicationState_UnplannedMaintenance;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Instance.state

/**
 *  The instance is currently being created, and may be destroyed
 *  if the creation process encounters an error.
 *
 *  Value: "CREATING"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Instance_State_Creating;
/**
 *  The instance has been successfully created and can serve requests
 *  to its tables.
 *
 *  Value: "READY"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Instance_State_Ready;
/**
 *  The state of the instance could not be determined.
 *
 *  Value: "STATE_NOT_KNOWN"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Instance_State_StateNotKnown;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Instance.type

/**
 *  The instance is meant for development and testing purposes only; it has
 *  no performance or uptime guarantees and is not covered by SLA.
 *  After a development instance is created, it can be upgraded by
 *  updating the instance to type `PRODUCTION`. An instance created
 *  as a production instance cannot be changed to a development instance.
 *  When creating a development instance, `serve_nodes` on the cluster must
 *  not be set.
 *
 *  Value: "DEVELOPMENT"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Instance_Type_Development;
/**
 *  An instance meant for production use. `serve_nodes` must be set
 *  on the cluster.
 *
 *  Value: "PRODUCTION"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Instance_Type_Production;
/**
 *  The type of the instance is unspecified. If set when creating an
 *  instance, a `PRODUCTION` instance will be created. If set when updating
 *  an instance, the type will be left unchanged.
 *
 *  Value: "TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Instance_Type_TypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_Table.granularity

/**
 *  The table keeps data versioned at a granularity of 1ms.
 *
 *  Value: "MILLIS"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Table_Granularity_Millis;
/**
 *  The user did not specify a granularity. Should not be returned.
 *  When specified during table creation, MILLIS will be used.
 *
 *  Value: "TIMESTAMP_GRANULARITY_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_Table_Granularity_TimestampGranularityUnspecified;

// ----------------------------------------------------------------------------
// GTLRBigtableAdmin_TableProgress.state

/**
 *  The table was deleted before it finished copying to the new cluster.
 *  Note that tables deleted after completion will stay marked as
 *  COMPLETED, not CANCELLED.
 *
 *  Value: "CANCELLED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Cancelled;
/**
 *  The table has been fully copied to the new cluster.
 *
 *  Value: "COMPLETED"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Completed;
/**
 *  The table is actively being copied to the new cluster.
 *
 *  Value: "COPYING"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Copying;
/**
 *  The table has not yet begun copying to the new cluster.
 *
 *  Value: "PENDING"
 */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_Pending;
/** Value: "STATE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRBigtableAdmin_TableProgress_State_StateUnspecified;

/**
 *  A configuration object describing how Cloud Bigtable should treat traffic
 *  from a particular end user application.
 */
@interface GTLRBigtableAdmin_AppProfile : GTLRObject

/**
 *  Optional long form description of the use case for this AppProfile.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Strongly validated etag for optimistic concurrency control. Preserve the
 *  value returned from `GetAppProfile` when calling `UpdateAppProfile` to
 *  fail the request if there has been a modification in the mean time. The
 *  `update_mask` of the request need not include `etag` for this protection
 *  to apply.
 *  See [Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag) and
 *  [RFC 7232](https://tools.ietf.org/html/rfc7232#section-2.3) for more
 *  details.
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/** Use a multi-cluster routing policy that may pick any cluster. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_MultiClusterRoutingUseAny *multiClusterRoutingUseAny;

/**
 *  (`OutputOnly`)
 *  The unique name of the app profile. Values are of the form
 *  `projects/<project>/instances/<instance>/appProfiles/_a-zA-Z0-9*`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/** Use a single-cluster routing policy. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_SingleClusterRouting *singleClusterRouting;

@end


/**
 *  Specifies the audit configuration for a service.
 *  The configuration determines which permission types are logged, and what
 *  identities, if any, are exempted from logging.
 *  An AuditConfig must have one or more AuditLogConfigs.
 *  If there are AuditConfigs for both `allServices` and a specific service,
 *  the union of the two AuditConfigs is used for that service: the log_types
 *  specified in each AuditConfig are enabled, and the exempted_members in each
 *  AuditLogConfig are exempted.
 *  Example Policy with multiple AuditConfigs:
 *  {
 *  "audit_configs": [
 *  {
 *  "service": "allServices"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:foo\@gmail.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  },
 *  {
 *  "log_type": "ADMIN_READ",
 *  }
 *  ]
 *  },
 *  {
 *  "service": "fooservice.googleapis.com"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  "exempted_members": [
 *  "user:bar\@gmail.com"
 *  ]
 *  }
 *  ]
 *  }
 *  ]
 *  }
 *  For fooservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts foo\@gmail.com from DATA_READ logging, and
 *  bar\@gmail.com from DATA_WRITE logging.
 */
@interface GTLRBigtableAdmin_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging.
 *  For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
 *  `allServices` is a special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions.
 *  Example:
 *  {
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:foo\@gmail.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  }
 *  ]
 *  }
 *  This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
 *  foo\@gmail.com from DATA_READ logging.
 */
@interface GTLRBigtableAdmin_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission.
 *  Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_DataRead Data reads.
 *        Example: CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRBigtableAdmin_AuditLogConfig_LogType_LogTypeUnspecified
 *        Default case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRBigtableAdmin_Binding : GTLRObject

/**
 *  Unimplemented. The condition that is associated with this binding.
 *  NOTE: an unsatisfied condition will not allow user access via current
 *  binding. Different bindings, including their conditions, are examined
 *  independently.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values:
 *  * `allUsers`: A special identifier that represents anyone who is
 *  on the internet; with or without a Google account.
 *  * `allAuthenticatedUsers`: A special identifier that represents anyone
 *  who is authenticated with a Google account or a service account.
 *  * `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@gmail.com` .
 *  * `serviceAccount:{emailid}`: An email address that represents a service
 *  account. For example, `my-other-app\@appspot.gserviceaccount.com`.
 *  * `group:{emailid}`: An email address that represents a Google group.
 *  For example, `admins\@example.com`.
 *  * `domain:{domain}`: A Google Apps domain name that represents all the
 *  users of that domain. For example, `google.com` or `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`.
 *  For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency
 */
@interface GTLRBigtableAdmin_CheckConsistencyRequest : GTLRObject

/** The token created using GenerateConsistencyToken for the Table. */
@property(nonatomic, copy, nullable) NSString *consistencyToken;

@end


/**
 *  Response message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency
 */
@interface GTLRBigtableAdmin_CheckConsistencyResponse : GTLRObject

/**
 *  True only if the token is consistent. A token is consistent if replication
 *  has caught up with the restrictions specified in the request.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *consistent;

@end


/**
 *  A resizable group of nodes in a particular cloud location, capable
 *  of serving all Tables in the parent
 *  Instance.
 */
@interface GTLRBigtableAdmin_Cluster : GTLRObject

/**
 *  (`CreationOnly`)
 *  The type of storage used by this cluster to serve its
 *  parent instance's tables, unless explicitly overridden.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Cluster_DefaultStorageType_Hdd Magnetic drive
 *        (HDD) storage should be used. (Value: "HDD")
 *    @arg @c kGTLRBigtableAdmin_Cluster_DefaultStorageType_Ssd Flash (SSD)
 *        storage should be used. (Value: "SSD")
 *    @arg @c kGTLRBigtableAdmin_Cluster_DefaultStorageType_StorageTypeUnspecified
 *        The user did not specify a storage type. (Value:
 *        "STORAGE_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *defaultStorageType;

/**
 *  (`CreationOnly`)
 *  The location where this cluster's nodes and storage reside. For best
 *  performance, clients should be located as close as possible to this
 *  cluster. Currently only zones are supported, so values should be of the
 *  form `projects/<project>/locations/<zone>`.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  (`OutputOnly`)
 *  The unique name of the cluster. Values are of the form
 *  `projects/<project>/instances/<instance>/clusters/a-z*`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The number of nodes allocated to this cluster. More nodes enable higher
 *  throughput and more consistent performance.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *serveNodes;

/**
 *  (`OutputOnly`)
 *  The current state of the cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Creating The cluster is currently
 *        being created, and may be destroyed
 *        if the creation process encounters an error.
 *        A cluster may not be able to serve requests while being created.
 *        (Value: "CREATING")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Disabled The cluster has no
 *        backing nodes. The data (tables) still
 *        exist, but no operations can be performed on the cluster. (Value:
 *        "DISABLED")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Ready The cluster has been
 *        successfully created and is ready to serve requests. (Value: "READY")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_Resizing The cluster is currently
 *        being resized, and may revert to its previous
 *        node count if the process encounters an error.
 *        A cluster is still capable of serving requests while being resized,
 *        but may exhibit performance as if its number of allocated nodes is
 *        between the starting and requested states. (Value: "RESIZING")
 *    @arg @c kGTLRBigtableAdmin_Cluster_State_StateNotKnown The state of the
 *        cluster could not be determined. (Value: "STATE_NOT_KNOWN")
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  The state of a table's data in a particular cluster.
 */
@interface GTLRBigtableAdmin_ClusterState : GTLRObject

/**
 *  (`OutputOnly`)
 *  The state of replication for the table in this cluster.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_Initializing The
 *        cluster was recently created, and the table must finish copying
 *        over pre-existing data from other clusters before it can begin
 *        receiving live replication updates and serving Data API requests.
 *        (Value: "INITIALIZING")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_PlannedMaintenance
 *        The table is temporarily unable to serve Data API requests from this
 *        cluster due to planned internal maintenance. (Value:
 *        "PLANNED_MAINTENANCE")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_Ready The table
 *        can serve Data API requests from this cluster. Depending on
 *        replication delay, reads may not immediately reflect the state of the
 *        table in other clusters. (Value: "READY")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_StateNotKnown The
 *        replication state of the table is unknown in this cluster. (Value:
 *        "STATE_NOT_KNOWN")
 *    @arg @c kGTLRBigtableAdmin_ClusterState_ReplicationState_UnplannedMaintenance
 *        The table is temporarily unable to serve Data API requests from this
 *        cluster due to unplanned or emergency maintenance. (Value:
 *        "UNPLANNED_MAINTENANCE")
 */
@property(nonatomic, copy, nullable) NSString *replicationState;

@end


/**
 *  A set of columns within a table which share a common configuration.
 */
@interface GTLRBigtableAdmin_ColumnFamily : GTLRObject

/**
 *  Garbage collection rule specified as a protobuf.
 *  Must serialize to at most 500 bytes.
 *  NOTE: Garbage collection executes opportunistically in the background, and
 *  so it's possible for reads to return a cell even if it matches the active
 *  GC expression for its family.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_GcRule *gcRule;

@end


/**
 *  The metadata for the Operation returned by CreateCluster.
 */
@interface GTLRBigtableAdmin_CreateClusterMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this CreateCluster operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateClusterRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

/**
 *  Keys: the full `name` of each table that existed in the instance when
 *  CreateCluster was first called, i.e.
 *  `projects/<project>/instances/<instance>/tables/<table>`. Any table added
 *  to the instance by a later API call will be created in the new cluster by
 *  that API call, not this one.
 *  Values: information on how much of a table's data has been copied to the
 *  newly-created cluster so far.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateClusterMetadata_Tables *tables;

@end


/**
 *  Keys: the full `name` of each table that existed in the instance when
 *  CreateCluster was first called, i.e.
 *  `projects/<project>/instances/<instance>/tables/<table>`. Any table added
 *  to the instance by a later API call will be created in the new cluster by
 *  that API call, not this one.
 *  Values: information on how much of a table's data has been copied to the
 *  newly-created cluster so far.
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_TableProgress. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_CreateClusterMetadata_Tables : GTLRObject
@end


/**
 *  Request message for BigtableInstanceAdmin.CreateCluster.
 */
@interface GTLRBigtableAdmin_CreateClusterRequest : GTLRObject

/**
 *  The cluster to be created.
 *  Fields marked `OutputOnly` must be left blank.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Cluster *cluster;

/**
 *  The ID to be used when referring to the new cluster within its instance,
 *  e.g., just `mycluster` rather than
 *  `projects/myproject/instances/myinstance/clusters/mycluster`.
 */
@property(nonatomic, copy, nullable) NSString *clusterId;

/**
 *  The unique name of the instance in which to create the new cluster.
 *  Values are of the form
 *  `projects/<project>/instances/<instance>`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

@end


/**
 *  The metadata for the Operation returned by CreateInstance.
 */
@interface GTLRBigtableAdmin_CreateInstanceMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this CreateInstance operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateInstanceRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end


/**
 *  Request message for BigtableInstanceAdmin.CreateInstance.
 */
@interface GTLRBigtableAdmin_CreateInstanceRequest : GTLRObject

/**
 *  The clusters to be created within the instance, mapped by desired
 *  cluster ID, e.g., just `mycluster` rather than
 *  `projects/myproject/instances/myinstance/clusters/mycluster`.
 *  Fields marked `OutputOnly` must be left blank.
 *  Currently, at most two clusters can be specified.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_CreateInstanceRequest_Clusters *clusters;

/**
 *  The instance to create.
 *  Fields marked `OutputOnly` must be left blank.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Instance *instance;

/**
 *  The ID to be used when referring to the new instance within its project,
 *  e.g., just `myinstance` rather than
 *  `projects/myproject/instances/myinstance`.
 */
@property(nonatomic, copy, nullable) NSString *instanceId;

/**
 *  The unique name of the project in which to create the new instance.
 *  Values are of the form `projects/<project>`.
 */
@property(nonatomic, copy, nullable) NSString *parent;

@end


/**
 *  The clusters to be created within the instance, mapped by desired
 *  cluster ID, e.g., just `mycluster` rather than
 *  `projects/myproject/instances/myinstance/clusters/mycluster`.
 *  Fields marked `OutputOnly` must be left blank.
 *  Currently, at most two clusters can be specified.
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_Cluster. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_CreateInstanceRequest_Clusters : GTLRObject
@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.CreateTable
 */
@interface GTLRBigtableAdmin_CreateTableRequest : GTLRObject

/**
 *  The optional list of row keys that will be used to initially split the
 *  table into several tablets (tablets are similar to HBase regions).
 *  Given two split keys, `s1` and `s2`, three tablets will be created,
 *  spanning the key ranges: `[, s1), [s1, s2), [s2, )`.
 *  Example:
 *  * Row keys := `["a", "apple", "custom", "customer_1", "customer_2",`
 *  `"other", "zz"]`
 *  * initial_split_keys := `["apple", "customer_1", "customer_2", "other"]`
 *  * Key assignment:
 *  - Tablet 1 `[, apple) => {"a"}.`
 *  - Tablet 2 `[apple, customer_1) => {"apple", "custom"}.`
 *  - Tablet 3 `[customer_1, customer_2) => {"customer_1"}.`
 *  - Tablet 4 `[customer_2, other) => {"customer_2"}.`
 *  - Tablet 5 `[other, ) => {"other", "zz"}.`
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Split *> *initialSplits;

/** The Table to create. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Table *table;

/**
 *  The name by which the new table should be referred to within the parent
 *  instance, e.g., `foobar` rather than `<parent>/tables/foobar`.
 */
@property(nonatomic, copy, nullable) NSString *tableId;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange
 */
@interface GTLRBigtableAdmin_DropRowRangeRequest : GTLRObject

/**
 *  Delete all rows in the table. Setting this to false is a no-op.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deleteAllDataFromTable;

/**
 *  Delete all rows that start with this row key prefix. Prefix cannot be
 *  zero length.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *rowKeyPrefix;

@end


/**
 *  A generic empty message that you can re-use to avoid defining duplicated
 *  empty messages in your APIs. A typical example is to use it as the request
 *  or the response type of an API method. For instance:
 *  service Foo {
 *  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *  }
 *  The JSON representation for `Empty` is empty JSON object `{}`.
 */
@interface GTLRBigtableAdmin_Empty : GTLRObject
@end


/**
 *  Represents an expression text. Example:
 *  title: "User account presence"
 *  description: "Determines whether the request has a user account"
 *  expression: "size(request.user) > 0"
 */
@interface GTLRBigtableAdmin_Expr : GTLRObject

/**
 *  An optional description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in
 *  Common Expression Language syntax.
 *  The application context of the containing message determines which
 *  well-known feature set of CEL is supported.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  An optional string indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  An optional title for the expression, i.e. a short string describing
 *  its purpose. This can be used e.g. in UIs which allow to enter the
 *  expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Rule for determining which cells to delete during garbage collection.
 */
@interface GTLRBigtableAdmin_GcRule : GTLRObject

/** Delete cells that would be deleted by every nested rule. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Intersection *intersection;

/**
 *  Delete cells in a column older than the given age.
 *  Values must be at least one millisecond, and will be truncated to
 *  microsecond granularity.
 */
@property(nonatomic, strong, nullable) GTLRDuration *maxAge;

/**
 *  Delete all cells in a column except the most recent N.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxNumVersions;

/**
 *  Delete cells that would be deleted by any nested rule.
 *
 *  Remapped to 'unionProperty' to avoid language reserved word 'union'.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Union *unionProperty;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken
 */
@interface GTLRBigtableAdmin_GenerateConsistencyTokenRequest : GTLRObject
@end


/**
 *  Response message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken
 */
@interface GTLRBigtableAdmin_GenerateConsistencyTokenResponse : GTLRObject

/** The generated consistency token. */
@property(nonatomic, copy, nullable) NSString *consistencyToken;

@end


/**
 *  Request message for `GetIamPolicy` method.
 */
@interface GTLRBigtableAdmin_GetIamPolicyRequest : GTLRObject
@end


/**
 *  A collection of Bigtable Tables and
 *  the resources that serve them.
 *  All tables in an instance are served from all
 *  Clusters in the instance.
 */
@interface GTLRBigtableAdmin_Instance : GTLRObject

/**
 *  The descriptive name for this instance as it appears in UIs.
 *  Can be changed at any time, but should be kept globally unique
 *  to avoid confusion.
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. They can be used to filter resources and aggregate
 *  metrics.
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the regular expression: `\\p{Ll}\\p{Lo}{0,62}`.
 *  * Label values must be between 0 and 63 characters long and must conform to
 *  the regular expression: `[\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}`.
 *  * No more than 64 labels can be associated with a given resource.
 *  * Keys and values must both be under 128 bytes.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Instance_Labels *labels;

/**
 *  (`OutputOnly`)
 *  The unique name of the instance. Values are of the form
 *  `projects/<project>/instances/a-z+[a-z0-9]`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (`OutputOnly`)
 *  The current state of the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Instance_State_Creating The instance is
 *        currently being created, and may be destroyed
 *        if the creation process encounters an error. (Value: "CREATING")
 *    @arg @c kGTLRBigtableAdmin_Instance_State_Ready The instance has been
 *        successfully created and can serve requests
 *        to its tables. (Value: "READY")
 *    @arg @c kGTLRBigtableAdmin_Instance_State_StateNotKnown The state of the
 *        instance could not be determined. (Value: "STATE_NOT_KNOWN")
 */
@property(nonatomic, copy, nullable) NSString *state;

/**
 *  The type of the instance. Defaults to `PRODUCTION`.
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Instance_Type_Development The instance is meant
 *        for development and testing purposes only; it has
 *        no performance or uptime guarantees and is not covered by SLA.
 *        After a development instance is created, it can be upgraded by
 *        updating the instance to type `PRODUCTION`. An instance created
 *        as a production instance cannot be changed to a development instance.
 *        When creating a development instance, `serve_nodes` on the cluster
 *        must
 *        not be set. (Value: "DEVELOPMENT")
 *    @arg @c kGTLRBigtableAdmin_Instance_Type_Production An instance meant for
 *        production use. `serve_nodes` must be set
 *        on the cluster. (Value: "PRODUCTION")
 *    @arg @c kGTLRBigtableAdmin_Instance_Type_TypeUnspecified The type of the
 *        instance is unspecified. If set when creating an
 *        instance, a `PRODUCTION` instance will be created. If set when
 *        updating
 *        an instance, the type will be left unchanged. (Value:
 *        "TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Labels are a flexible and lightweight mechanism for organizing cloud
 *  resources into groups that reflect a customer's organizational needs and
 *  deployment strategies. They can be used to filter resources and aggregate
 *  metrics.
 *  * Label keys must be between 1 and 63 characters long and must conform to
 *  the regular expression: `\\p{Ll}\\p{Lo}{0,62}`.
 *  * Label values must be between 0 and 63 characters long and must conform to
 *  the regular expression: `[\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}`.
 *  * No more than 64 labels can be associated with a given resource.
 *  * Keys and values must both be under 128 bytes.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRBigtableAdmin_Instance_Labels : GTLRObject
@end


/**
 *  A GcRule which deletes cells matching all of the given rules.
 */
@interface GTLRBigtableAdmin_Intersection : GTLRObject

/** Only delete cells which would be deleted by every element of `rules`. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_GcRule *> *rules;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListAppProfiles.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "appProfiles" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListAppProfilesResponse : GTLRCollectionObject

/**
 *  The list of requested app profiles.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_AppProfile *> *appProfiles;

/**
 *  Locations from which AppProfile information could not be retrieved,
 *  due to an outage or some other transient condition.
 *  AppProfiles from these locations may be missing from `app_profiles`.
 *  Values are of the form `projects/<project>/locations/<zone_id>`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *failedLocations;

/**
 *  Set if not all app profiles could be returned in a single response.
 *  Pass this value to `page_token` in another request to get the next
 *  page of results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListClusters.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "clusters" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListClustersResponse : GTLRCollectionObject

/**
 *  The list of requested clusters.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Cluster *> *clusters;

/**
 *  Locations from which Cluster information could not be retrieved,
 *  due to an outage or some other transient condition.
 *  Clusters from these locations may be missing from `clusters`,
 *  or may only have partial information returned.
 *  Values are of the form `projects/<project>/locations/<zone_id>`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *failedLocations;

/** DEPRECATED: This field is unused and ignored. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response message for BigtableInstanceAdmin.ListInstances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "instances" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListInstancesResponse : GTLRCollectionObject

/**
 *  Locations from which Instance information could not be retrieved,
 *  due to an outage or some other transient condition.
 *  Instances whose Clusters are all in one of the failed locations
 *  may be missing from `instances`, and Instances with at least one
 *  Cluster in a failed location may only have partial information returned.
 *  Values are of the form `projects/<project>/locations/<zone_id>`
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *failedLocations;

/**
 *  The list of requested instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Instance *> *instances;

/** DEPRECATED: This field is unused and ignored. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The response message for Operations.ListOperations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "operations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListOperationsResponse : GTLRCollectionObject

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A list of operations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Operation *> *operations;

@end


/**
 *  Response message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.ListTables
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "tables" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRBigtableAdmin_ListTablesResponse : GTLRCollectionObject

/**
 *  Set if not all tables could be returned in a single response.
 *  Pass this value to `page_token` in another request to get the next
 *  page of results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  The tables present in the requested instance.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Table *> *tables;

@end


/**
 *  A create, update, or delete of a particular column family.
 */
@interface GTLRBigtableAdmin_Modification : GTLRObject

/**
 *  Create a new column family with the specified schema, or fail if
 *  one already exists with the given ID.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ColumnFamily *create;

/**
 *  Drop (delete) the column family with the given ID, or fail if no such
 *  family exists.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *drop;

/**
 *  The ID of the column family to be modified.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Update an existing column family to the specified schema, or fail
 *  if no column family exists with the given ID.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_ColumnFamily *update;

@end


/**
 *  Request message for
 *  google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies
 */
@interface GTLRBigtableAdmin_ModifyColumnFamiliesRequest : GTLRObject

/**
 *  Modifications to be atomically applied to the specified table's families.
 *  Entries are applied in order, meaning that earlier modifications can be
 *  masked by later ones (in the case of repeated updates to the same family,
 *  for example).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Modification *> *modifications;

@end


/**
 *  Read/write requests may be routed to any cluster in the instance, and will
 *  fail over to another cluster in the event of transient errors or delays.
 *  Choosing this option sacrifices read-your-writes consistency to improve
 *  availability.
 */
@interface GTLRBigtableAdmin_MultiClusterRoutingUseAny : GTLRObject
@end


/**
 *  This resource represents a long-running operation that is the result of a
 *  network API call.
 */
@interface GTLRBigtableAdmin_Operation : GTLRObject

/**
 *  If the value is `false`, it means the operation is still in progress.
 *  If `true`, the operation is completed, and either `error` or `response` is
 *  available.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *done;

/** The error result of the operation in case of failure or cancellation. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Status *error;

/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Operation_Metadata *metadata;

/**
 *  The server-assigned name, which is only unique within the same service that
 *  originally returns it. If you use the default HTTP mapping, the
 *  `name` should have the format of `operations/some/unique/name`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Operation_Response *response;

@end


/**
 *  Service-specific metadata associated with the operation. It typically
 *  contains progress information and common metadata such as create time.
 *  Some services might not provide such metadata. Any method that returns a
 *  long-running operation should document the metadata type, if any.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Operation_Metadata : GTLRObject
@end


/**
 *  The normal response of the operation in case of success. If the original
 *  method returns no data on success, such as `Delete`, the response is
 *  `google.protobuf.Empty`. If the original method is standard
 *  `Get`/`Create`/`Update`, the response should be the resource. For other
 *  methods, the response should have the type `XxxResponse`, where `Xxx`
 *  is the original method name. For example, if the original method name
 *  is `TakeSnapshot()`, the inferred response type is
 *  `TakeSnapshotResponse`.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Operation_Response : GTLRObject
@end


/**
 *  Request message for BigtableInstanceAdmin.PartialUpdateInstance.
 */
@interface GTLRBigtableAdmin_PartialUpdateInstanceRequest : GTLRObject

/** The Instance which will (partially) replace the current value. */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Instance *instance;

/**
 *  The subset of Instance fields which should be replaced.
 *  Must be explicitly set.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Defines an Identity and Access Management (IAM) policy. It is used to
 *  specify access control policies for Cloud Platform resources.
 *  A `Policy` consists of a list of `bindings`. A `binding` binds a list of
 *  `members` to a `role`, where the members can be user accounts, Google
 *  groups,
 *  Google domains, and service accounts. A `role` is a named list of
 *  permissions
 *  defined by IAM.
 *  **JSON Example**
 *  {
 *  "bindings": [
 *  {
 *  "role": "roles/owner",
 *  "members": [
 *  "user:mike\@example.com",
 *  "group:admins\@example.com",
 *  "domain:google.com",
 *  "serviceAccount:my-other-app\@appspot.gserviceaccount.com"
 *  ]
 *  },
 *  {
 *  "role": "roles/viewer",
 *  "members": ["user:sean\@example.com"]
 *  }
 *  ]
 *  }
 *  **YAML Example**
 *  bindings:
 *  - members:
 *  - user:mike\@example.com
 *  - group:admins\@example.com
 *  - domain:google.com
 *  - serviceAccount:my-other-app\@appspot.gserviceaccount.com
 *  role: roles/owner
 *  - members:
 *  - user:sean\@example.com
 *  role: roles/viewer
 *  For a description of IAM and its features, see the
 *  [IAM developer's guide](https://cloud.google.com/iam/docs).
 */
@interface GTLRBigtableAdmin_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members` to a `role`.
 *  `bindings` with no members will result in an error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help
 *  prevent simultaneous updates of a policy from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform policy updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `getIamPolicy`, and
 *  systems are expected to put that etag in the request to `setIamPolicy` to
 *  ensure that their change will be applied to the same version of the policy.
 *  If no `etag` is provided in the call to `setIamPolicy`, then the existing
 *  policy is overwritten blindly.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Deprecated.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRBigtableAdmin_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a
 *  valid policy but certain Cloud Platform services (such as Projects)
 *  might reject them.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used:
 *  paths: "bindings, etag"
 *  This field is only used by Cloud IAM.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Unconditionally routes all read/write requests to a specific cluster.
 *  This option preserves read-your-writes consistency, but does not improve
 *  availability.
 */
@interface GTLRBigtableAdmin_SingleClusterRouting : GTLRObject

/**
 *  Whether or not `CheckAndMutateRow` and `ReadModifyWriteRow` requests are
 *  allowed by this app profile. It is unsafe to send these requests to
 *  the same table/row/column in multiple clusters.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *allowTransactionalWrites;

/** The cluster to which read/write requests should be routed. */
@property(nonatomic, copy, nullable) NSString *clusterId;

@end


/**
 *  An initial split point for a newly created table.
 */
@interface GTLRBigtableAdmin_Split : GTLRObject

/**
 *  Row key to use as an initial tablet boundary.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *key;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` that can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRBigtableAdmin_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRBigtableAdmin_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Status_Details_Item : GTLRObject
@end


/**
 *  A collection of user data indexed by row, column, and timestamp.
 *  Each table is served using the resources of its parent cluster.
 */
@interface GTLRBigtableAdmin_Table : GTLRObject

/**
 *  (`OutputOnly`)
 *  Map from cluster ID to per-cluster table state.
 *  If it could not be determined whether or not the table has data in a
 *  particular cluster (for example, if its zone is unavailable), then
 *  there will be an entry for the cluster with UNKNOWN `replication_status`.
 *  Views: `REPLICATION_VIEW`, `FULL`
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Table_ClusterStates *clusterStates;

/**
 *  (`CreationOnly`)
 *  The column families configured for this table, mapped by column family ID.
 *  Views: `SCHEMA_VIEW`, `FULL`
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Table_ColumnFamilies *columnFamilies;

/**
 *  (`CreationOnly`)
 *  The granularity (i.e. `MILLIS`) at which timestamps are stored in
 *  this table. Timestamps not matching the granularity will be rejected.
 *  If unspecified at creation time, the value will be set to `MILLIS`.
 *  Views: `SCHEMA_VIEW`, `FULL`
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_Table_Granularity_Millis The table keeps data
 *        versioned at a granularity of 1ms. (Value: "MILLIS")
 *    @arg @c kGTLRBigtableAdmin_Table_Granularity_TimestampGranularityUnspecified
 *        The user did not specify a granularity. Should not be returned.
 *        When specified during table creation, MILLIS will be used. (Value:
 *        "TIMESTAMP_GRANULARITY_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *granularity;

/**
 *  (`OutputOnly`)
 *  The unique name of the table. Values are of the form
 *  `projects/<project>/instances/<instance>/tables/_a-zA-Z0-9*`.
 *  Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  (`OutputOnly`)
 *  Map from cluster ID to per-cluster table state.
 *  If it could not be determined whether or not the table has data in a
 *  particular cluster (for example, if its zone is unavailable), then
 *  there will be an entry for the cluster with UNKNOWN `replication_status`.
 *  Views: `REPLICATION_VIEW`, `FULL`
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_ClusterState. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Table_ClusterStates : GTLRObject
@end


/**
 *  (`CreationOnly`)
 *  The column families configured for this table, mapped by column family ID.
 *  Views: `SCHEMA_VIEW`, `FULL`
 *
 *  @note This class is documented as having more properties of
 *        GTLRBigtableAdmin_ColumnFamily. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRBigtableAdmin_Table_ColumnFamilies : GTLRObject
@end


/**
 *  Progress info for copying a table's data to the new cluster.
 */
@interface GTLRBigtableAdmin_TableProgress : GTLRObject

/**
 *  Estimate of the number of bytes copied so far for this table.
 *  This will eventually reach 'estimated_size_bytes' unless the table copy
 *  is CANCELLED.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *estimatedCopiedBytes;

/**
 *  Estimate of the size of the table to be copied.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *estimatedSizeBytes;

/**
 *  state
 *
 *  Likely values:
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Cancelled The table was
 *        deleted before it finished copying to the new cluster.
 *        Note that tables deleted after completion will stay marked as
 *        COMPLETED, not CANCELLED. (Value: "CANCELLED")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Completed The table has
 *        been fully copied to the new cluster. (Value: "COMPLETED")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Copying The table is
 *        actively being copied to the new cluster. (Value: "COPYING")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_Pending The table has not
 *        yet begun copying to the new cluster. (Value: "PENDING")
 *    @arg @c kGTLRBigtableAdmin_TableProgress_State_StateUnspecified Value
 *        "STATE_UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *state;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRBigtableAdmin_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as '*' or 'storage.*') are not allowed. For more
 *  information see
 *  [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRBigtableAdmin_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is
 *  allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  A GcRule which deletes cells matching any of the given rules.
 */
@interface GTLRBigtableAdmin_Union : GTLRObject

/** Delete cells which would be deleted by any element of `rules`. */
@property(nonatomic, strong, nullable) NSArray<GTLRBigtableAdmin_GcRule *> *rules;

@end


/**
 *  The metadata for the Operation returned by UpdateAppProfile.
 */
@interface GTLRBigtableAdmin_UpdateAppProfileMetadata : GTLRObject
@end


/**
 *  The metadata for the Operation returned by UpdateCluster.
 */
@interface GTLRBigtableAdmin_UpdateClusterMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this UpdateCluster operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_Cluster *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end


/**
 *  The metadata for the Operation returned by UpdateInstance.
 */
@interface GTLRBigtableAdmin_UpdateInstanceMetadata : GTLRObject

/** The time at which the operation failed or was completed successfully. */
@property(nonatomic, strong, nullable) GTLRDateTime *finishTime;

/**
 *  The request that prompted the initiation of this UpdateInstance operation.
 */
@property(nonatomic, strong, nullable) GTLRBigtableAdmin_PartialUpdateInstanceRequest *originalRequest;

/** The time at which the original request was received. */
@property(nonatomic, strong, nullable) GTLRDateTime *requestTime;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
