// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Analytics Reporting API (analyticsreporting/v4)
// Description:
//   Accesses Analytics report data.
// Documentation:
//   https://developers.google.com/analytics/devguides/reporting/core/v4/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAnalyticsReporting_Activity;
@class GTLRAnalyticsReporting_Cohort;
@class GTLRAnalyticsReporting_CohortGroup;
@class GTLRAnalyticsReporting_ColumnHeader;
@class GTLRAnalyticsReporting_CustomDimension;
@class GTLRAnalyticsReporting_DateRange;
@class GTLRAnalyticsReporting_DateRangeValues;
@class GTLRAnalyticsReporting_Dimension;
@class GTLRAnalyticsReporting_DimensionFilter;
@class GTLRAnalyticsReporting_DimensionFilterClause;
@class GTLRAnalyticsReporting_DynamicSegment;
@class GTLRAnalyticsReporting_EcommerceData;
@class GTLRAnalyticsReporting_EventData;
@class GTLRAnalyticsReporting_GoalData;
@class GTLRAnalyticsReporting_GoalSetData;
@class GTLRAnalyticsReporting_Metric;
@class GTLRAnalyticsReporting_MetricFilter;
@class GTLRAnalyticsReporting_MetricFilterClause;
@class GTLRAnalyticsReporting_MetricHeader;
@class GTLRAnalyticsReporting_MetricHeaderEntry;
@class GTLRAnalyticsReporting_OrderBy;
@class GTLRAnalyticsReporting_OrFiltersForSegment;
@class GTLRAnalyticsReporting_PageviewData;
@class GTLRAnalyticsReporting_Pivot;
@class GTLRAnalyticsReporting_PivotHeader;
@class GTLRAnalyticsReporting_PivotHeaderEntry;
@class GTLRAnalyticsReporting_PivotValueRegion;
@class GTLRAnalyticsReporting_ProductData;
@class GTLRAnalyticsReporting_Report;
@class GTLRAnalyticsReporting_ReportData;
@class GTLRAnalyticsReporting_ReportRequest;
@class GTLRAnalyticsReporting_ReportRow;
@class GTLRAnalyticsReporting_ResourceQuotasRemaining;
@class GTLRAnalyticsReporting_ScreenviewData;
@class GTLRAnalyticsReporting_Segment;
@class GTLRAnalyticsReporting_SegmentDefinition;
@class GTLRAnalyticsReporting_SegmentDimensionFilter;
@class GTLRAnalyticsReporting_SegmentFilter;
@class GTLRAnalyticsReporting_SegmentFilterClause;
@class GTLRAnalyticsReporting_SegmentMetricFilter;
@class GTLRAnalyticsReporting_SegmentSequenceStep;
@class GTLRAnalyticsReporting_SequenceSegment;
@class GTLRAnalyticsReporting_SimpleSegment;
@class GTLRAnalyticsReporting_TransactionData;
@class GTLRAnalyticsReporting_User;
@class GTLRAnalyticsReporting_UserActivitySession;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_Activity.activityType

/**
 *  ActivityType will never have this value in the response. Using this type in
 *  the request will result in an error.
 *
 *  Value: "ACTIVITY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Activity_ActivityType_ActivityTypeUnspecified;
/**
 *  An e-commerce transaction was performed by the visitor on the page.
 *
 *  Value: "ECOMMERCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Activity_ActivityType_Ecommerce;
/**
 *  Used when the activity is an event.
 *
 *  Value: "EVENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Activity_ActivityType_Event;
/**
 *  Used to denote that a goal type activity.
 *
 *  Value: "GOAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Activity_ActivityType_Goal;
/**
 *  Used when the activity resulted out of a visitor viewing a page.
 *
 *  Value: "PAGEVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Activity_ActivityType_Pageview;
/**
 *  Used when the activity resulted out of a visitor using an application on a
 *  mobile device.
 *
 *  Value: "SCREENVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Activity_ActivityType_Screenview;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_Cohort.type

/**
 *  Cohorts that are selected based on first visit date.
 *
 *  Value: "FIRST_VISIT_DATE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Cohort_Type_FirstVisitDate;
/**
 *  If unspecified it's treated as `FIRST_VISIT_DATE`.
 *
 *  Value: "UNSPECIFIED_COHORT_TYPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Cohort_Type_UnspecifiedCohortType;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_DimensionFilter.operatorProperty

/**
 *  Matches the value which begin with the match expression provided.
 *
 *  Value: "BEGINS_WITH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_BeginsWith;
/**
 *  Matches the values which end with the match expression provided.
 *
 *  Value: "ENDS_WITH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_EndsWith;
/**
 *  The value should match the match expression entirely.
 *
 *  Value: "EXACT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Exact;
/**
 *  This option is used to specify a dimension filter whose expression can take
 *  any value from a selected list of values. This helps avoiding evaluating
 *  multiple exact match dimension filters which are OR'ed for every single
 *  response row. For example: expressions: ["A", "B", "C"] Any response row
 *  whose dimension has it is value as A, B or C, matches this DimensionFilter.
 *
 *  Value: "IN_LIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_InList;
/**
 *  Integer comparison filters. case sensitivity is ignored for these and the
 *  expression is assumed to be a string representing an integer. Failure
 *  conditions: - If expression is not a valid int64, the client should expect
 *  an error. - Input dimensions that are not valid int64 values will never
 *  match the filter.
 *
 *  Value: "NUMERIC_EQUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericEqual;
/**
 *  Checks if the dimension is numerically greater than the match expression.
 *  Read the description for `NUMERIC_EQUALS` for restrictions.
 *
 *  Value: "NUMERIC_GREATER_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericGreaterThan;
/**
 *  Checks if the dimension is numerically less than the match expression. Read
 *  the description for `NUMERIC_EQUALS` for restrictions.
 *
 *  Value: "NUMERIC_LESS_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericLessThan;
/**
 *  If the match type is unspecified, it is treated as a `REGEXP`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_OperatorUnspecified;
/**
 *  Substring match.
 *
 *  Value: "PARTIAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Partial;
/**
 *  The match expression is treated as a regular expression. All match types are
 *  not treated as regular expressions.
 *
 *  Value: "REGEXP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Regexp;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_DimensionFilterClause.operatorProperty

/**
 *  The logical `AND` operator.
 *
 *  Value: "AND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_And;
/**
 *  Unspecified operator. It is treated as an `OR`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_OperatorUnspecified;
/**
 *  The logical `OR` operator.
 *
 *  Value: "OR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_Or;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_EcommerceData.actionType

/**
 *  Add product(s) to cart.
 *
 *  Value: "ADD_TO_CART"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_AddToCart;
/**
 *  Check out.
 *
 *  Value: "CHECKOUT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_Checkout;
/**
 *  Checkout options.
 *
 *  Value: "CHECKOUT_OPTION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_CheckoutOption;
/**
 *  Click through of product lists.
 *
 *  Value: "CLICK"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_Click;
/**
 *  Product detail views.
 *
 *  Value: "DETAILS_VIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_DetailsView;
/**
 *  Completed purchase.
 *
 *  Value: "PAYMENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_Payment;
/**
 *  Refund of purchase.
 *
 *  Value: "REFUND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_Refund;
/**
 *  Remove product(s) from cart.
 *
 *  Value: "REMOVE_FROM_CART"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_RemoveFromCart;
/**
 *  Action type is not known.
 *
 *  Value: "UNKNOWN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_ActionType_Unknown;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_EcommerceData.ecommerceType

/**
 *  Used when activity has classic (non-enhanced) e-commerce information.
 *
 *  Value: "CLASSIC"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_EcommerceType_Classic;
/**
 *  Used when the e-commerce activity type is unspecified.
 *
 *  Value: "ECOMMERCE_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_EcommerceType_EcommerceTypeUnspecified;
/**
 *  Used when activity has enhanced e-commerce information.
 *
 *  Value: "ENHANCED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_EcommerceData_EcommerceType_Enhanced;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_Metric.formattingType

/**
 *  Currency metric.
 *
 *  Value: "CURRENCY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Currency;
/**
 *  Float metric.
 *
 *  Value: "FLOAT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Float;
/**
 *  Integer metric.
 *
 *  Value: "INTEGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Integer;
/**
 *  Metric type is unspecified.
 *
 *  Value: "METRIC_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_MetricTypeUnspecified;
/**
 *  Percentage metric.
 *
 *  Value: "PERCENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Percent;
/**
 *  Time metric in `HH:MM:SS` format.
 *
 *  Value: "TIME"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Time;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_MetricFilter.operatorProperty

/**
 *  Should the value of the metric be exactly equal to the comparison value.
 *
 *  Value: "EQUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_Equal;
/**
 *  Should the value of the metric be greater than to the comparison value.
 *
 *  Value: "GREATER_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_GreaterThan;
/**
 *  Validates if the metric is missing. Doesn't take comparisonValue into
 *  account.
 *
 *  Value: "IS_MISSING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_IsMissing;
/**
 *  Should the value of the metric be less than to the comparison value.
 *
 *  Value: "LESS_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_LessThan;
/**
 *  If the operator is not specified, it is treated as `EQUAL`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_OperatorUnspecified;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_MetricFilterClause.operatorProperty

/**
 *  The logical `AND` operator.
 *
 *  Value: "AND"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_And;
/**
 *  Unspecified operator. It is treated as an `OR`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_OperatorUnspecified;
/**
 *  The logical `OR` operator.
 *
 *  Value: "OR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_Or;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_MetricHeaderEntry.type

/**
 *  Currency metric.
 *
 *  Value: "CURRENCY"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Currency;
/**
 *  Float metric.
 *
 *  Value: "FLOAT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Float;
/**
 *  Integer metric.
 *
 *  Value: "INTEGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Integer;
/**
 *  Metric type is unspecified.
 *
 *  Value: "METRIC_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_MetricTypeUnspecified;
/**
 *  Percentage metric.
 *
 *  Value: "PERCENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Percent;
/**
 *  Time metric in `HH:MM:SS` format.
 *
 *  Value: "TIME"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Time;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_OrderBy.orderType

/**
 *  The sort order is based on the difference of the values of the chosen column
 *  between the first two date ranges. Usable only if there are exactly two date
 *  ranges.
 *
 *  Value: "DELTA"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_Delta;
/**
 *  If the dimensions are fixed length numbers, ordinary sort would just work
 *  fine. `DIMENSION_AS_INTEGER` can be used if the dimensions are variable
 *  length numbers.
 *
 *  Value: "DIMENSION_AS_INTEGER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_DimensionAsInteger;
/**
 *  Histogram order type is applicable only to dimension columns with non-empty
 *  histogram-buckets.
 *
 *  Value: "HISTOGRAM_BUCKET"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_HistogramBucket;
/**
 *  Unspecified order type will be treated as sort based on value.
 *
 *  Value: "ORDER_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_OrderTypeUnspecified;
/**
 *  The sort order is based on weighted value of the chosen column. If column
 *  has n/d format, then weighted value of this ratio will be `(n + totals.n)/(d
 *  + totals.d)` Usable only for metrics that represent ratios.
 *
 *  Value: "SMART"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_Smart;
/**
 *  The sort order is based on the value of the chosen column; looks only at the
 *  first date range.
 *
 *  Value: "VALUE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_Value;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_OrderBy.sortOrder

/**
 *  Ascending sort. The field will be sorted in an ascending manner.
 *
 *  Value: "ASCENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_SortOrder_Ascending;
/**
 *  Descending sort. The field will be sorted in a descending manner.
 *
 *  Value: "DESCENDING"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_SortOrder_Descending;
/**
 *  If the sort order is unspecified, the default is ascending.
 *
 *  Value: "SORT_ORDER_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_SortOrder_SortOrderUnspecified;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_ReportRequest.samplingLevel

/**
 *  Returns response with a sample size that balances speed and accuracy.
 *
 *  Value: "DEFAULT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Default;
/**
 *  Returns a more accurate response using a large sampling size. But this may
 *  result in response being slower.
 *
 *  Value: "LARGE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Large;
/**
 *  If the `samplingLevel` field is unspecified the `DEFAULT` sampling level is
 *  used.
 *
 *  Value: "SAMPLING_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_SamplingUnspecified;
/**
 *  It returns a fast response with a smaller sampling size.
 *
 *  Value: "SMALL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Small;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SearchUserActivityRequest.activityTypes

/**
 *  ActivityType will never have this value in the response. Using this type in
 *  the request will result in an error.
 *
 *  Value: "ACTIVITY_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SearchUserActivityRequest_ActivityTypes_ActivityTypeUnspecified;
/**
 *  An e-commerce transaction was performed by the visitor on the page.
 *
 *  Value: "ECOMMERCE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SearchUserActivityRequest_ActivityTypes_Ecommerce;
/**
 *  Used when the activity is an event.
 *
 *  Value: "EVENT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SearchUserActivityRequest_ActivityTypes_Event;
/**
 *  Used to denote that a goal type activity.
 *
 *  Value: "GOAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SearchUserActivityRequest_ActivityTypes_Goal;
/**
 *  Used when the activity resulted out of a visitor viewing a page.
 *
 *  Value: "PAGEVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SearchUserActivityRequest_ActivityTypes_Pageview;
/**
 *  Used when the activity resulted out of a visitor using an application on a
 *  mobile device.
 *
 *  Value: "SCREENVIEW"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SearchUserActivityRequest_ActivityTypes_Screenview;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentDimensionFilter.operatorProperty

/**
 *  Matches the values which begin with the match expression provided.
 *
 *  Value: "BEGINS_WITH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_BeginsWith;
/**
 *  Matches the values which end with the match expression provided.
 *
 *  Value: "ENDS_WITH"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_EndsWith;
/**
 *  The value should match the match expression entirely.
 *
 *  Value: "EXACT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Exact;
/**
 *  This option is used to specify a dimension filter whose expression can take
 *  any value from a selected list of values. This helps avoiding evaluating
 *  multiple exact match dimension filters which are OR'ed for every single
 *  response row. For example: expressions: ["A", "B", "C"] Any response row
 *  whose dimension has it is value as A, B or C, matches this DimensionFilter.
 *
 *  Value: "IN_LIST"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_InList;
/**
 *  Checks if the dimension is numerically between the minimum and maximum of
 *  the match expression, boundaries excluded.
 *
 *  Value: "NUMERIC_BETWEEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericBetween;
/**
 *  Checks if the dimension is numerically greater than the match expression.
 *
 *  Value: "NUMERIC_GREATER_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericGreaterThan;
/**
 *  Integer comparison filters. case sensitivity is ignored for these and the
 *  expression is assumed to be a string representing an integer. Failure
 *  conditions: - if expression is not a valid int64, the client should expect
 *  an error. - input dimensions that are not valid int64 values will never
 *  match the filter. Checks if the dimension is numerically less than the match
 *  expression.
 *
 *  Value: "NUMERIC_LESS_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericLessThan;
/**
 *  If the match type is unspecified, it is treated as a REGEXP.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_OperatorUnspecified;
/**
 *  Substring match.
 *
 *  Value: "PARTIAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Partial;
/**
 *  The match expression is treated as a regular expression. All other match
 *  types are not treated as regular expressions.
 *
 *  Value: "REGEXP"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Regexp;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentMetricFilter.operatorProperty

/**
 *  For between operator, both the minimum and maximum are exclusive. We will
 *  use `LT` and `GT` for comparison.
 *
 *  Value: "BETWEEN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Between;
/**
 *  Equals operator.
 *
 *  Value: "EQUAL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Equal;
/**
 *  Checks if the metric value is greater than comparison value.
 *
 *  Value: "GREATER_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_GreaterThan;
/**
 *  Checks if the metric value is less than comparison value.
 *
 *  Value: "LESS_THAN"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_LessThan;
/**
 *  Unspecified operator is treated as `LESS_THAN` operator.
 *
 *  Value: "UNSPECIFIED_OPERATOR"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_UnspecifiedOperator;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentMetricFilter.scope

/**
 *  Hit scope.
 *
 *  Value: "HIT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Hit;
/**
 *  Product scope.
 *
 *  Value: "PRODUCT"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Product;
/**
 *  Session scope.
 *
 *  Value: "SESSION"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Session;
/**
 *  If the scope is unspecified, it defaults to the condition scope, `USER` or
 *  `SESSION` depending on if the segment is trying to choose users or sessions.
 *
 *  Value: "UNSPECIFIED_SCOPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_UnspecifiedScope;
/**
 *  User scope.
 *
 *  Value: "USER"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_User;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentSequenceStep.matchType

/**
 *  Operator indicates that the previous step immediately precedes the next
 *  step.
 *
 *  Value: "IMMEDIATELY_PRECEDES"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_ImmediatelyPrecedes;
/**
 *  Operator indicates that the previous step precedes the next step.
 *
 *  Value: "PRECEDES"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_Precedes;
/**
 *  Unspecified match type is treated as precedes.
 *
 *  Value: "UNSPECIFIED_MATCH_TYPE"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_UnspecifiedMatchType;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_User.type

/**
 *  Analytics assigned client_id.
 *
 *  Value: "CLIENT_ID"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_User_Type_ClientId;
/**
 *  A single user, like a signed-in user account, that may interact with content
 *  across one or more devices and / or browser instances.
 *
 *  Value: "USER_ID"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_User_Type_UserId;
/**
 *  When the User Id Type is not specified, the default type used will be
 *  CLIENT_ID.
 *
 *  Value: "USER_ID_TYPE_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAnalyticsReporting_User_Type_UserIdTypeUnspecified;

/**
 *  An Activity represents data for an activity of a user. Note that an Activity
 *  is different from a hit. A hit might result in multiple Activity's. For
 *  example, if a hit includes a transaction and a goal completion, there will
 *  be two Activity protos for this hit, one for ECOMMERCE and one for GOAL.
 *  Conversely, multiple hits can also construct one Activity. In classic
 *  e-commerce, data for one transaction might be sent through multiple hits.
 *  These hits will be merged into one ECOMMERCE Activity.
 */
@interface GTLRAnalyticsReporting_Activity : GTLRObject

/**
 *  Timestamp of the activity. If activities for a visit cross midnight and
 *  occur in two separate dates, then two sessions (one per date) share the
 *  session identifier. For example, say session ID 113472 has activity within
 *  2019-08-20, and session ID 243742 has activity within 2019-08-25 and
 *  2019-08-26. Session ID 113472 is one session, and session ID 243742 is two
 *  sessions.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *activityTime;

/**
 *  Type of this activity.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_Activity_ActivityType_ActivityTypeUnspecified
 *        ActivityType will never have this value in the response. Using this
 *        type in the request will result in an error. (Value:
 *        "ACTIVITY_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_Activity_ActivityType_Ecommerce An
 *        e-commerce transaction was performed by the visitor on the page.
 *        (Value: "ECOMMERCE")
 *    @arg @c kGTLRAnalyticsReporting_Activity_ActivityType_Event Used when the
 *        activity is an event. (Value: "EVENT")
 *    @arg @c kGTLRAnalyticsReporting_Activity_ActivityType_Goal Used to denote
 *        that a goal type activity. (Value: "GOAL")
 *    @arg @c kGTLRAnalyticsReporting_Activity_ActivityType_Pageview Used when
 *        the activity resulted out of a visitor viewing a page. (Value:
 *        "PAGEVIEW")
 *    @arg @c kGTLRAnalyticsReporting_Activity_ActivityType_Screenview Used when
 *        the activity resulted out of a visitor using an application on a
 *        mobile device. (Value: "SCREENVIEW")
 */
@property(nonatomic, copy, nullable) NSString *activityType;

/** This will be set if `activity_type` equals `SCREEN_VIEW`. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_ScreenviewData *appview;

/**
 *  For manual campaign tracking, it is the value of the utm_campaign campaign
 *  tracking parameter. For AdWords autotagging, it is the name(s) of the online
 *  ad campaign(s) you use for the property. If you use neither, its value is
 *  (not set).
 */
@property(nonatomic, copy, nullable) NSString *campaign;

/**
 *  The Channel Group associated with an end user's session for this View
 *  (defined by the View's Channel Groupings).
 */
@property(nonatomic, copy, nullable) NSString *channelGrouping;

/** A list of all custom dimensions associated with this activity. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_CustomDimension *> *customDimension;

/** This will be set if `activity_type` equals `ECOMMERCE`. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_EcommerceData *ecommerce;

/**
 *  This field contains all the details pertaining to an event and will be set
 *  if `activity_type` equals `EVENT`.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_EventData *event;

/**
 *  This field contains a list of all the goals that were reached in this
 *  activity when `activity_type` equals `GOAL`.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_GoalSetData *goals;

/** The hostname from which the tracking request was made. */
@property(nonatomic, copy, nullable) NSString *hostname;

/**
 *  For manual campaign tracking, it is the value of the utm_term campaign
 *  tracking parameter. For AdWords traffic, it contains the best matching
 *  targeting criteria. For the display network, where multiple targeting
 *  criteria could have caused the ad to show up, it returns the best matching
 *  targeting criteria as selected by Ads. This could be display_keyword, site
 *  placement, boomuserlist, user_interest, age, or gender. Otherwise its value
 *  is (not set).
 */
@property(nonatomic, copy, nullable) NSString *keyword;

/** The first page in users' sessions, or the landing page. */
@property(nonatomic, copy, nullable) NSString *landingPagePath;

/**
 *  The type of referrals. For manual campaign tracking, it is the value of the
 *  utm_medium campaign tracking parameter. For AdWords autotagging, it is cpc.
 *  If users came from a search engine detected by Google Analytics, it is
 *  organic. If the referrer is not a search engine, it is referral. If users
 *  came directly to the property and document.referrer is empty, its value is
 *  (none).
 */
@property(nonatomic, copy, nullable) NSString *medium;

/**
 *  This will be set if `activity_type` equals `PAGEVIEW`. This field contains
 *  all the details about the visitor and the page that was visited.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_PageviewData *pageview;

/**
 *  The source of referrals. For manual campaign tracking, it is the value of
 *  the utm_source campaign tracking parameter. For AdWords autotagging, it is
 *  google. If you use neither, it is the domain of the source (e.g.,
 *  document.referrer) referring the users. It may also contain a port address.
 *  If users arrived without a referrer, its value is (direct).
 */
@property(nonatomic, copy, nullable) NSString *source;

@end


/**
 *  Defines a cohort. A cohort is a group of users who share a common
 *  characteristic. For example, all users with the same acquisition date belong
 *  to the same cohort.
 */
@interface GTLRAnalyticsReporting_Cohort : GTLRObject

/**
 *  This is used for `FIRST_VISIT_DATE` cohort, the cohort selects users whose
 *  first visit date is between start date and end date defined in the
 *  DateRange. The date ranges should be aligned for cohort requests. If the
 *  request contains `ga:cohortNthDay` it should be exactly one day long, if
 *  `ga:cohortNthWeek` it should be aligned to the week boundary (starting at
 *  Sunday and ending Saturday), and for `ga:cohortNthMonth` the date range
 *  should be aligned to the month (starting at the first and ending on the last
 *  day of the month). For LTV requests there are no such restrictions. You do
 *  not need to supply a date range for the `reportsRequest.dateRanges` field.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_DateRange *dateRange;

/**
 *  A unique name for the cohort. If not defined name will be auto-generated
 *  with values cohort_[1234...].
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Type of the cohort. The only supported type as of now is `FIRST_VISIT_DATE`.
 *  If this field is unspecified the cohort is treated as `FIRST_VISIT_DATE`
 *  type cohort.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_Cohort_Type_FirstVisitDate Cohorts that
 *        are selected based on first visit date. (Value: "FIRST_VISIT_DATE")
 *    @arg @c kGTLRAnalyticsReporting_Cohort_Type_UnspecifiedCohortType If
 *        unspecified it's treated as `FIRST_VISIT_DATE`. (Value:
 *        "UNSPECIFIED_COHORT_TYPE")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Defines a cohort group. For example: "cohortGroup": { "cohorts": [{ "name":
 *  "cohort 1", "type": "FIRST_VISIT_DATE", "dateRange": { "startDate":
 *  "2015-08-01", "endDate": "2015-08-01" } },{ "name": "cohort 2" "type":
 *  "FIRST_VISIT_DATE" "dateRange": { "startDate": "2015-07-01", "endDate":
 *  "2015-07-01" } }] }
 */
@interface GTLRAnalyticsReporting_CohortGroup : GTLRObject

/** The definition for the cohort. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Cohort *> *cohorts;

/**
 *  Enable Life Time Value (LTV). LTV measures lifetime value for users acquired
 *  through different channels. Please see: [Cohort
 *  Analysis](https://support.google.com/analytics/answer/6074676) and [Lifetime
 *  Value](https://support.google.com/analytics/answer/6182550) If the value of
 *  lifetimeValue is false: - The metric values are similar to the values in the
 *  web interface cohort report. - The cohort definition date ranges must be
 *  aligned to the calendar week and month. i.e. while requesting
 *  `ga:cohortNthWeek` the `startDate` in the cohort definition should be a
 *  Sunday and the `endDate` should be the following Saturday, and for
 *  `ga:cohortNthMonth`, the `startDate` should be the 1st of the month and
 *  `endDate` should be the last day of the month. When the lifetimeValue is
 *  true: - The metric values will correspond to the values in the web interface
 *  LifeTime value report. - The Lifetime Value report shows you how user value
 *  (Revenue) and engagement (Appviews, Goal Completions, Sessions, and Session
 *  Duration) grow during the 90 days after a user is acquired. - The metrics
 *  are calculated as a cumulative average per user per the time increment. -
 *  The cohort definition date ranges need not be aligned to the calendar week
 *  and month boundaries. - The `viewId` must be an [app view
 *  ID](https://support.google.com/analytics/answer/2649553#WebVersusAppViews)
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lifetimeValue;

@end


/**
 *  Column headers.
 */
@interface GTLRAnalyticsReporting_ColumnHeader : GTLRObject

/** The dimension names in the response. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dimensions;

/** Metric headers for the metrics in the response. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_MetricHeader *metricHeader;

@end


/**
 *  Custom dimension.
 */
@interface GTLRAnalyticsReporting_CustomDimension : GTLRObject

/**
 *  Slot number of custom dimension.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/**
 *  Value of the custom dimension. Default value (i.e. empty string) indicates
 *  clearing sesion/visitor scope custom dimension value.
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  A contiguous set of days: startDate, startDate + 1 day, ..., endDate. The
 *  start and end dates are specified in
 *  [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date format `YYYY-MM-DD`.
 */
@interface GTLRAnalyticsReporting_DateRange : GTLRObject

/** The end date for the query in the format `YYYY-MM-DD`. */
@property(nonatomic, copy, nullable) NSString *endDate;

/** The start date for the query in the format `YYYY-MM-DD`. */
@property(nonatomic, copy, nullable) NSString *startDate;

@end


/**
 *  Used to return a list of metrics for a single DateRange / dimension
 *  combination
 */
@interface GTLRAnalyticsReporting_DateRangeValues : GTLRObject

/** The values of each pivot region. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_PivotValueRegion *> *pivotValueRegions;

/** Each value corresponds to each Metric in the request. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  [Dimensions](https://support.google.com/analytics/answer/1033861) are
 *  attributes of your data. For example, the dimension `ga:city` indicates the
 *  city, for example, "Paris" or "New York", from which a session originates.
 */
@interface GTLRAnalyticsReporting_Dimension : GTLRObject

/**
 *  If non-empty, we place dimension values into buckets after string to int64.
 *  Dimension values that are not the string representation of an integral value
 *  will be converted to zero. The bucket values have to be in increasing order.
 *  Each bucket is closed on the lower end, and open on the upper end. The
 *  "first" bucket includes all values less than the first boundary, the "last"
 *  bucket includes all values up to infinity. Dimension values that fall in a
 *  bucket get transformed to a new dimension value. For example, if one gives a
 *  list of "0, 1, 3, 4, 7", then we return the following buckets: - bucket #1:
 *  values < 0, dimension value "<0" - bucket #2: values in [0,1), dimension
 *  value "0" - bucket #3: values in [1,3), dimension value "1-2" - bucket #4:
 *  values in [3,4), dimension value "3" - bucket #5: values in [4,7), dimension
 *  value "4-6" - bucket #6: values >= 7, dimension value "7+" NOTE: If you are
 *  applying histogram mutation on any dimension, and using that dimension in
 *  sort, you will want to use the sort type `HISTOGRAM_BUCKET` for that
 *  purpose. Without that the dimension values will be sorted according to
 *  dictionary (lexicographic) order. For example the ascending dictionary order
 *  is: "<50", "1001+", "121-1000", "50-120" And the ascending
 *  `HISTOGRAM_BUCKET` order is: "<50", "50-120", "121-1000", "1001+" The client
 *  has to explicitly request `"orderType": "HISTOGRAM_BUCKET"` for a
 *  histogram-mutated dimension.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *histogramBuckets;

/** Name of the dimension to fetch, for example `ga:browser`. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Dimension filter specifies the filtering options on a dimension.
 */
@interface GTLRAnalyticsReporting_DimensionFilter : GTLRObject

/**
 *  Should the match be case sensitive? Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *caseSensitive;

/** The dimension to filter on. A DimensionFilter must contain a dimension. */
@property(nonatomic, copy, nullable) NSString *dimensionName;

/**
 *  Strings or regular expression to match against. Only the first value of the
 *  list is used for comparison unless the operator is `IN_LIST`. If `IN_LIST`
 *  operator, then the entire list is used to filter the dimensions as explained
 *  in the description of the `IN_LIST` operator.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *expressions;

/**
 *  Logical `NOT` operator. If this boolean is set to true, then the matching
 *  dimension values will be excluded in the report. The default is false.
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *notProperty;

/**
 *  How to match the dimension to the expression. The default is REGEXP.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_BeginsWith
 *        Matches the value which begin with the match expression provided.
 *        (Value: "BEGINS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_EndsWith
 *        Matches the values which end with the match expression provided.
 *        (Value: "ENDS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Exact The
 *        value should match the match expression entirely. (Value: "EXACT")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_InList
 *        This option is used to specify a dimension filter whose expression can
 *        take any value from a selected list of values. This helps avoiding
 *        evaluating multiple exact match dimension filters which are OR'ed for
 *        every single response row. For example: expressions: ["A", "B", "C"]
 *        Any response row whose dimension has it is value as A, B or C, matches
 *        this DimensionFilter. (Value: "IN_LIST")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericEqual
 *        Integer comparison filters. case sensitivity is ignored for these and
 *        the expression is assumed to be a string representing an integer.
 *        Failure conditions: - If expression is not a valid int64, the client
 *        should expect an error. - Input dimensions that are not valid int64
 *        values will never match the filter. (Value: "NUMERIC_EQUAL")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericGreaterThan
 *        Checks if the dimension is numerically greater than the match
 *        expression. Read the description for `NUMERIC_EQUALS` for
 *        restrictions. (Value: "NUMERIC_GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericLessThan
 *        Checks if the dimension is numerically less than the match expression.
 *        Read the description for `NUMERIC_EQUALS` for restrictions. (Value:
 *        "NUMERIC_LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_OperatorUnspecified
 *        If the match type is unspecified, it is treated as a `REGEXP`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Partial
 *        Substring match. (Value: "PARTIAL")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Regexp
 *        The match expression is treated as a regular expression. All match
 *        types are not treated as regular expressions. (Value: "REGEXP")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

@end


/**
 *  A group of dimension filters. Set the operator value to specify how the
 *  filters are logically combined.
 */
@interface GTLRAnalyticsReporting_DimensionFilterClause : GTLRObject

/**
 *  The repeated set of filters. They are logically combined based on the
 *  operator specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DimensionFilter *> *filters;

/**
 *  The operator for combining multiple dimension filters. If unspecified, it is
 *  treated as an `OR`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_And
 *        The logical `AND` operator. (Value: "AND")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_OperatorUnspecified
 *        Unspecified operator. It is treated as an `OR`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_Or
 *        The logical `OR` operator. (Value: "OR")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

@end


/**
 *  Dynamic segment definition for defining the segment within the request. A
 *  segment can select users, sessions or both.
 */
@interface GTLRAnalyticsReporting_DynamicSegment : GTLRObject

/** The name of the dynamic segment. */
@property(nonatomic, copy, nullable) NSString *name;

/** Session Segment to select sessions to include in the segment. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_SegmentDefinition *sessionSegment;

/** User Segment to select users to include in the segment. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_SegmentDefinition *userSegment;

@end


/**
 *  E-commerce details associated with the user activity.
 */
@interface GTLRAnalyticsReporting_EcommerceData : GTLRObject

/**
 *  Action associated with this e-commerce action.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_AddToCart Add
 *        product(s) to cart. (Value: "ADD_TO_CART")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_Checkout Check
 *        out. (Value: "CHECKOUT")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_CheckoutOption
 *        Checkout options. (Value: "CHECKOUT_OPTION")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_Click Click
 *        through of product lists. (Value: "CLICK")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_DetailsView
 *        Product detail views. (Value: "DETAILS_VIEW")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_Payment Completed
 *        purchase. (Value: "PAYMENT")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_Refund Refund of
 *        purchase. (Value: "REFUND")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_RemoveFromCart
 *        Remove product(s) from cart. (Value: "REMOVE_FROM_CART")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_ActionType_Unknown Action
 *        type is not known. (Value: "UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *actionType;

/**
 *  The type of this e-commerce activity.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_EcommerceType_Classic Used
 *        when activity has classic (non-enhanced) e-commerce information.
 *        (Value: "CLASSIC")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_EcommerceType_EcommerceTypeUnspecified
 *        Used when the e-commerce activity type is unspecified. (Value:
 *        "ECOMMERCE_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_EcommerceData_EcommerceType_Enhanced Used
 *        when activity has enhanced e-commerce information. (Value: "ENHANCED")
 */
@property(nonatomic, copy, nullable) NSString *ecommerceType;

/** Details of the products in this transaction. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_ProductData *> *products;

/** Transaction details of this e-commerce action. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_TransactionData *transaction;

@end


/**
 *  Represents all the details pertaining to an event.
 */
@interface GTLRAnalyticsReporting_EventData : GTLRObject

/** Type of interaction with the object. Eg: 'play'. */
@property(nonatomic, copy, nullable) NSString *eventAction;

/** The object on the page that was interacted with. Eg: 'Video'. */
@property(nonatomic, copy, nullable) NSString *eventCategory;

/**
 *  Number of such events in this activity.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *eventCount;

/** Label attached with the event. */
@property(nonatomic, copy, nullable) NSString *eventLabel;

/**
 *  Numeric value associated with the event.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *eventValue;

@end


/**
 *  The batch request containing multiple report request.
 */
@interface GTLRAnalyticsReporting_GetReportsRequest : GTLRObject

/**
 *  Requests, each request will have a separate response. There can be a maximum
 *  of 5 requests. All requests should have the same `dateRanges`, `viewId`,
 *  `segments`, `samplingLevel`, and `cohortGroup`.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_ReportRequest *> *reportRequests;

/**
 *  Enables [resource based
 *  quotas](/analytics/devguides/reporting/core/v4/limits-quotas#analytics_reporting_api_v4),
 *  (defaults to `False`). If this field is set to `True` the per view (profile)
 *  quotas are governed by the computational cost of the request. Note that
 *  using cost based quotas will higher enable sampling rates. (10 Million for
 *  `SMALL`, 100M for `LARGE`. See the [limits and quotas
 *  documentation](/analytics/devguides/reporting/core/v4/limits-quotas#analytics_reporting_api_v4)
 *  for details.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *useResourceQuotas;

@end


/**
 *  The main response class which holds the reports from the Reporting API
 *  `batchGet` call.
 */
@interface GTLRAnalyticsReporting_GetReportsResponse : GTLRObject

/**
 *  The amount of resource quota tokens deducted to execute the query. Includes
 *  all responses.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *queryCost;

/** Responses corresponding to each of the request. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Report *> *reports;

/** The amount of resource quota remaining for the property. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_ResourceQuotasRemaining *resourceQuotasRemaining;

@end


/**
 *  Represents all the details pertaining to a goal.
 */
@interface GTLRAnalyticsReporting_GoalData : GTLRObject

/** URL of the page where this goal was completed. */
@property(nonatomic, copy, nullable) NSString *goalCompletionLocation;

/**
 *  Total number of goal completions in this activity.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *goalCompletions;

/**
 *  This identifies the goal as configured for the profile.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *goalIndex;

/** Name of the goal. */
@property(nonatomic, copy, nullable) NSString *goalName;

/** URL of the page one step prior to the goal completion. */
@property(nonatomic, copy, nullable) NSString *goalPreviousStep1;

/** URL of the page two steps prior to the goal completion. */
@property(nonatomic, copy, nullable) NSString *goalPreviousStep2;

/** URL of the page three steps prior to the goal completion. */
@property(nonatomic, copy, nullable) NSString *goalPreviousStep3;

/**
 *  Value in this goal.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *goalValue;

@end


/**
 *  Represents a set of goals that were reached in an activity.
 */
@interface GTLRAnalyticsReporting_GoalSetData : GTLRObject

/** All the goals that were reached in the current activity. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_GoalData *> *goals;

@end


/**
 *  [Metrics](https://support.google.com/analytics/answer/1033861) are the
 *  quantitative measurements. For example, the metric `ga:users` indicates the
 *  total number of users for the requested time period.
 */
@interface GTLRAnalyticsReporting_Metric : GTLRObject

/**
 *  An alias for the metric expression is an alternate name for the expression.
 *  The alias can be used for filtering and sorting. This field is optional and
 *  is useful if the expression is not a single metric but a complex expression
 *  which cannot be used in filtering and sorting. The alias is also used in the
 *  response column header.
 */
@property(nonatomic, copy, nullable) NSString *alias;

/**
 *  A metric expression in the request. An expression is constructed from one or
 *  more metrics and numbers. Accepted operators include: Plus (+), Minus (-),
 *  Negation (Unary -), Divided by (/), Multiplied by (*), Parenthesis, Positive
 *  cardinal numbers (0-9), can include decimals and is limited to 1024
 *  characters. Example `ga:totalRefunds/ga:users`, in most cases the metric
 *  expression is just a single metric name like `ga:users`. Adding mixed
 *  `MetricType` (E.g., `CURRENCY` + `PERCENTAGE`) metrics will result in
 *  unexpected results.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  Specifies how the metric expression should be formatted, for example
 *  `INTEGER`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Currency Currency
 *        metric. (Value: "CURRENCY")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Float Float metric.
 *        (Value: "FLOAT")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Integer Integer
 *        metric. (Value: "INTEGER")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_MetricTypeUnspecified
 *        Metric type is unspecified. (Value: "METRIC_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Percent Percentage
 *        metric. (Value: "PERCENT")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Time Time metric in
 *        `HH:MM:SS` format. (Value: "TIME")
 */
@property(nonatomic, copy, nullable) NSString *formattingType;

@end


/**
 *  MetricFilter specifies the filter on a metric.
 */
@interface GTLRAnalyticsReporting_MetricFilter : GTLRObject

/** The value to compare against. */
@property(nonatomic, copy, nullable) NSString *comparisonValue;

/**
 *  The metric that will be filtered on. A metricFilter must contain a metric
 *  name. A metric name can be an alias earlier defined as a metric or it can
 *  also be a metric expression.
 */
@property(nonatomic, copy, nullable) NSString *metricName;

/**
 *  Logical `NOT` operator. If this boolean is set to true, then the matching
 *  metric values will be excluded in the report. The default is false.
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *notProperty;

/**
 *  Is the metric `EQUAL`, `LESS_THAN` or `GREATER_THAN` the comparisonValue,
 *  the default is `EQUAL`. If the operator is `IS_MISSING`, checks if the
 *  metric is missing and would ignore the comparisonValue.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_Equal Should
 *        the value of the metric be exactly equal to the comparison value.
 *        (Value: "EQUAL")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_GreaterThan
 *        Should the value of the metric be greater than to the comparison
 *        value. (Value: "GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_IsMissing
 *        Validates if the metric is missing. Doesn't take comparisonValue into
 *        account. (Value: "IS_MISSING")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_LessThan
 *        Should the value of the metric be less than to the comparison value.
 *        (Value: "LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_OperatorUnspecified
 *        If the operator is not specified, it is treated as `EQUAL`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

@end


/**
 *  Represents a group of metric filters. Set the operator value to specify how
 *  the filters are logically combined.
 */
@interface GTLRAnalyticsReporting_MetricFilterClause : GTLRObject

/**
 *  The repeated set of filters. They are logically combined based on the
 *  operator specified.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_MetricFilter *> *filters;

/**
 *  The operator for combining multiple metric filters. If unspecified, it is
 *  treated as an `OR`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_And
 *        The logical `AND` operator. (Value: "AND")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_OperatorUnspecified
 *        Unspecified operator. It is treated as an `OR`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_Or The
 *        logical `OR` operator. (Value: "OR")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

@end


/**
 *  The headers for the metrics.
 */
@interface GTLRAnalyticsReporting_MetricHeader : GTLRObject

/** Headers for the metrics in the response. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_MetricHeaderEntry *> *metricHeaderEntries;

/** Headers for the pivots in the response. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_PivotHeader *> *pivotHeaders;

@end


/**
 *  Header for the metrics.
 */
@interface GTLRAnalyticsReporting_MetricHeaderEntry : GTLRObject

/** The name of the header. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The type of the metric, for example `INTEGER`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Currency Currency
 *        metric. (Value: "CURRENCY")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Float Float metric.
 *        (Value: "FLOAT")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Integer Integer
 *        metric. (Value: "INTEGER")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_MetricTypeUnspecified
 *        Metric type is unspecified. (Value: "METRIC_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Percent Percentage
 *        metric. (Value: "PERCENT")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Time Time metric in
 *        `HH:MM:SS` format. (Value: "TIME")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Specifies the sorting options.
 */
@interface GTLRAnalyticsReporting_OrderBy : GTLRObject

/**
 *  The field which to sort by. The default sort order is ascending. Example:
 *  `ga:browser`. Note, that you can only specify one field for sort here. For
 *  example, `ga:browser, ga:city` is not valid.
 */
@property(nonatomic, copy, nullable) NSString *fieldName;

/**
 *  The order type. The default orderType is `VALUE`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_Delta The sort order is
 *        based on the difference of the values of the chosen column between the
 *        first two date ranges. Usable only if there are exactly two date
 *        ranges. (Value: "DELTA")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_DimensionAsInteger If
 *        the dimensions are fixed length numbers, ordinary sort would just work
 *        fine. `DIMENSION_AS_INTEGER` can be used if the dimensions are
 *        variable length numbers. (Value: "DIMENSION_AS_INTEGER")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_HistogramBucket
 *        Histogram order type is applicable only to dimension columns with
 *        non-empty histogram-buckets. (Value: "HISTOGRAM_BUCKET")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_OrderTypeUnspecified
 *        Unspecified order type will be treated as sort based on value. (Value:
 *        "ORDER_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_Smart The sort order is
 *        based on weighted value of the chosen column. If column has n/d
 *        format, then weighted value of this ratio will be `(n + totals.n)/(d +
 *        totals.d)` Usable only for metrics that represent ratios. (Value:
 *        "SMART")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_Value The sort order is
 *        based on the value of the chosen column; looks only at the first date
 *        range. (Value: "VALUE")
 */
@property(nonatomic, copy, nullable) NSString *orderType;

/**
 *  The sorting order for the field.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_SortOrder_Ascending Ascending
 *        sort. The field will be sorted in an ascending manner. (Value:
 *        "ASCENDING")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_SortOrder_Descending Descending
 *        sort. The field will be sorted in a descending manner. (Value:
 *        "DESCENDING")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_SortOrder_SortOrderUnspecified If
 *        the sort order is unspecified, the default is ascending. (Value:
 *        "SORT_ORDER_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *sortOrder;

@end


/**
 *  A list of segment filters in the `OR` group are combined with the logical OR
 *  operator.
 */
@interface GTLRAnalyticsReporting_OrFiltersForSegment : GTLRObject

/** List of segment filters to be combined with a `OR` operator. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_SegmentFilterClause *> *segmentFilterClauses;

@end


/**
 *  Represents details collected when the visitor views a page.
 */
@interface GTLRAnalyticsReporting_PageviewData : GTLRObject

/** The URL of the page that the visitor viewed. */
@property(nonatomic, copy, nullable) NSString *pagePath;

/** The title of the page that the visitor viewed. */
@property(nonatomic, copy, nullable) NSString *pageTitle;

@end


/**
 *  The Pivot describes the pivot section in the request. The Pivot helps
 *  rearrange the information in the table for certain reports by pivoting your
 *  data on a second dimension.
 */
@interface GTLRAnalyticsReporting_Pivot : GTLRObject

/**
 *  DimensionFilterClauses are logically combined with an `AND` operator: only
 *  data that is included by all these DimensionFilterClauses contributes to the
 *  values in this pivot region. Dimension filters can be used to restrict the
 *  columns shown in the pivot region. For example if you have `ga:browser` as
 *  the requested dimension in the pivot region, and you specify key filters to
 *  restrict `ga:browser` to only "IE" or "Firefox", then only those two
 *  browsers would show up as columns.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DimensionFilterClause *> *dimensionFilterClauses;

/**
 *  A list of dimensions to show as pivot columns. A Pivot can have a maximum of
 *  4 dimensions. Pivot dimensions are part of the restriction on the total
 *  number of dimensions allowed in the request.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Dimension *> *dimensions;

/**
 *  Specifies the maximum number of groups to return. The default value is 10,
 *  also the maximum value is 1,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxGroupCount;

/**
 *  The pivot metrics. Pivot metrics are part of the restriction on total number
 *  of metrics allowed in the request.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Metric *> *metrics;

/**
 *  If k metrics were requested, then the response will contain some
 *  data-dependent multiple of k columns in the report. E.g., if you pivoted on
 *  the dimension `ga:browser` then you'd get k columns for "Firefox", k columns
 *  for "IE", k columns for "Chrome", etc. The ordering of the groups of columns
 *  is determined by descending order of "total" for the first of the k values.
 *  Ties are broken by lexicographic ordering of the first pivot dimension, then
 *  lexicographic ordering of the second pivot dimension, and so on. E.g., if
 *  the totals for the first value for Firefox, IE, and Chrome were 8, 2, 8,
 *  respectively, the order of columns would be Chrome, Firefox, IE. The
 *  following let you choose which of the groups of k columns are included in
 *  the response.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startGroup;

@end


/**
 *  The headers for each of the pivot sections defined in the request.
 */
@interface GTLRAnalyticsReporting_PivotHeader : GTLRObject

/** A single pivot section header. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_PivotHeaderEntry *> *pivotHeaderEntries;

/**
 *  The total number of groups for this pivot.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalPivotGroupsCount;

@end


/**
 *  The headers for the each of the metric column corresponding to the metrics
 *  requested in the pivots section of the response.
 */
@interface GTLRAnalyticsReporting_PivotHeaderEntry : GTLRObject

/** The name of the dimensions in the pivot response. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dimensionNames;

/** The values for the dimensions in the pivot. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dimensionValues;

/** The metric header for the metric in the pivot. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_MetricHeaderEntry *metric;

@end


/**
 *  The metric values in the pivot region.
 */
@interface GTLRAnalyticsReporting_PivotValueRegion : GTLRObject

/** The values of the metrics in each of the pivot regions. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  Details of the products in an e-commerce transaction.
 */
@interface GTLRAnalyticsReporting_ProductData : GTLRObject

/**
 *  The total revenue from purchased product items.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *itemRevenue;

/**
 *  The product name, supplied by the e-commerce tracking application, for the
 *  purchased items.
 */
@property(nonatomic, copy, nullable) NSString *productName;

/**
 *  Total number of this product units in the transaction.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *productQuantity;

/** Unique code that represents the product. */
@property(nonatomic, copy, nullable) NSString *productSku;

@end


/**
 *  The data response corresponding to the request.
 */
@interface GTLRAnalyticsReporting_Report : GTLRObject

/** The column headers. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_ColumnHeader *columnHeader;

/** Response data. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_ReportData *data;

/** Page token to retrieve the next page of results in the list. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  The data part of the report.
 */
@interface GTLRAnalyticsReporting_ReportData : GTLRObject

/**
 *  The last time the data in the report was refreshed. All the hits received
 *  before this timestamp are included in the calculation of the report.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *dataLastRefreshed;

/** If empty reason is specified, the report is empty for this reason. */
@property(nonatomic, copy, nullable) NSString *emptyReason;

/**
 *  Indicates if response to this request is golden or not. Data is golden when
 *  the exact same request will not produce any new results if asked at a later
 *  point in time.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isDataGolden;

/**
 *  Minimum and maximum values seen over all matching rows. These are both empty
 *  when `hideValueRanges` in the request is false, or when rowCount is zero.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *maximums;

/**
 *  Minimum and maximum values seen over all matching rows. These are both empty
 *  when `hideValueRanges` in the request is false, or when rowCount is zero.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *minimums;

/**
 *  Total number of matching rows for this query.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rowCount;

/** There's one ReportRow for every unique combination of dimensions. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_ReportRow *> *rows;

/**
 *  If the results are
 *  [sampled](https://support.google.com/analytics/answer/2637192), this returns
 *  the total number of samples read, one entry per date range. If the results
 *  are not sampled this field will not be defined. See [developer
 *  guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *samplesReadCounts;

/**
 *  If the results are
 *  [sampled](https://support.google.com/analytics/answer/2637192), this returns
 *  the total number of samples present, one entry per date range. If the
 *  results are not sampled this field will not be defined. See [developer
 *  guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *samplingSpaceSizes;

/**
 *  For each requested date range, for the set of all rows that match the query,
 *  every requested value format gets a total. The total for a value format is
 *  computed by first totaling the metrics mentioned in the value format and
 *  then evaluating the value format as a scalar expression. E.g., The "totals"
 *  for `3 / (ga:sessions + 2)` we compute `3 / ((sum of all relevant
 *  ga:sessions) + 2)`. Totals are computed before pagination.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *totals;

@end


/**
 *  The main request class which specifies the Reporting API request.
 */
@interface GTLRAnalyticsReporting_ReportRequest : GTLRObject

/**
 *  Cohort group associated with this request. If there is a cohort group in the
 *  request the `ga:cohort` dimension must be present. Every
 *  [ReportRequest](#ReportRequest) within a `batchGet` method must contain the
 *  same `cohortGroup` definition.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_CohortGroup *cohortGroup;

/**
 *  Date ranges in the request. The request can have a maximum of 2 date ranges.
 *  The response will contain a set of metric values for each combination of the
 *  dimensions for each date range in the request. So, if there are two date
 *  ranges, there will be two set of metric values, one for the original date
 *  range and one for the second date range. The `reportRequest.dateRanges`
 *  field should not be specified for cohorts or Lifetime value requests. If a
 *  date range is not provided, the default date range is (startDate: current
 *  date - 7 days, endDate: current date - 1 day). Every
 *  [ReportRequest](#ReportRequest) within a `batchGet` method must contain the
 *  same `dateRanges` definition.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DateRange *> *dateRanges;

/**
 *  The dimension filter clauses for filtering Dimension Values. They are
 *  logically combined with the `AND` operator. Note that filtering occurs
 *  before any dimensions are aggregated, so that the returned metrics represent
 *  the total for only the relevant dimensions.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DimensionFilterClause *> *dimensionFilterClauses;

/** The dimensions requested. Requests can have a total of 9 dimensions. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Dimension *> *dimensions;

/**
 *  Dimension or metric filters that restrict the data returned for your
 *  request. To use the `filtersExpression`, supply a dimension or metric on
 *  which to filter, followed by the filter expression. For example, the
 *  following expression selects `ga:browser` dimension which starts with
 *  Firefox; `ga:browser=~^Firefox`. For more information on dimensions and
 *  metric filters, see [Filters
 *  reference](https://developers.google.com/analytics/devguides/reporting/core/v3/reference#filters).
 */
@property(nonatomic, copy, nullable) NSString *filtersExpression;

/**
 *  If set to true, hides the total of all metrics for all the matching rows,
 *  for every date range. The default false and will return the totals.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hideTotals;

/**
 *  If set to true, hides the minimum and maximum across all matching rows. The
 *  default is false and the value ranges are returned.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hideValueRanges;

/**
 *  If set to false, the response does not include rows if all the retrieved
 *  metrics are equal to zero. The default is false which will exclude these
 *  rows.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *includeEmptyRows;

/**
 *  The metric filter clauses. They are logically combined with the `AND`
 *  operator. Metric filters look at only the first date range and not the
 *  comparing date range. Note that filtering on metrics occurs after the
 *  metrics are aggregated.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_MetricFilterClause *> *metricFilterClauses;

/**
 *  The metrics requested. Requests must specify at least one metric. Requests
 *  can have a total of 10 metrics.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Metric *> *metrics;

/**
 *  Sort order on output rows. To compare two rows, the elements of the
 *  following are applied in order until a difference is found. All date ranges
 *  in the output get the same row order.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_OrderBy *> *orderBys;

/**
 *  Page size is for paging and specifies the maximum number of returned rows.
 *  Page size should be >= 0. A query returns the default of 1,000 rows. The
 *  Analytics Core Reporting API returns a maximum of 100,000 rows per request,
 *  no matter how many you ask for. It can also return fewer rows than
 *  requested, if there aren't as many dimension segments as you expect. For
 *  instance, there are fewer than 300 possible values for `ga:country`, so when
 *  segmenting only by country, you can't get more than 300 rows, even if you
 *  set `pageSize` to a higher value.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pageSize;

/**
 *  A continuation token to get the next page of the results. Adding this to the
 *  request will return the rows after the pageToken. The pageToken should be
 *  the value returned in the nextPageToken parameter in the response to the
 *  GetReports request.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** The pivot definitions. Requests can have a maximum of 2 pivots. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Pivot *> *pivots;

/**
 *  The desired report
 *  [sample](https://support.google.com/analytics/answer/2637192) size. If the
 *  the `samplingLevel` field is unspecified the `DEFAULT` sampling level is
 *  used. Every [ReportRequest](#ReportRequest) within a `batchGet` method must
 *  contain the same `samplingLevel` definition. See [developer
 *  guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Default
 *        Returns response with a sample size that balances speed and accuracy.
 *        (Value: "DEFAULT")
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Large Returns
 *        a more accurate response using a large sampling size. But this may
 *        result in response being slower. (Value: "LARGE")
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_SamplingUnspecified
 *        If the `samplingLevel` field is unspecified the `DEFAULT` sampling
 *        level is used. (Value: "SAMPLING_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Small It
 *        returns a fast response with a smaller sampling size. (Value: "SMALL")
 */
@property(nonatomic, copy, nullable) NSString *samplingLevel;

/**
 *  Segment the data returned for the request. A segment definition helps look
 *  at a subset of the segment request. A request can contain up to four
 *  segments. Every [ReportRequest](#ReportRequest) within a `batchGet` method
 *  must contain the same `segments` definition. Requests with segments must
 *  have the `ga:segment` dimension.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Segment *> *segments;

/**
 *  The Analytics [view ID](https://support.google.com/analytics/answer/1009618)
 *  from which to retrieve data. Every [ReportRequest](#ReportRequest) within a
 *  `batchGet` method must contain the same `viewId`.
 */
@property(nonatomic, copy, nullable) NSString *viewId;

@end


/**
 *  A row in the report.
 */
@interface GTLRAnalyticsReporting_ReportRow : GTLRObject

/** List of requested dimensions. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dimensions;

/** List of metrics for each requested DateRange. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *metrics;

@end


/**
 *  The resource quota tokens remaining for the property after the request is
 *  completed.
 */
@interface GTLRAnalyticsReporting_ResourceQuotasRemaining : GTLRObject

/**
 *  Daily resource quota remaining remaining.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dailyQuotaTokensRemaining;

/**
 *  Hourly resource quota tokens remaining.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hourlyQuotaTokensRemaining;

@end


/**
 *  GTLRAnalyticsReporting_ScreenviewData
 */
@interface GTLRAnalyticsReporting_ScreenviewData : GTLRObject

/** The application name. */
@property(nonatomic, copy, nullable) NSString *appName;

/** Mobile manufacturer or branded name. Eg: "Google", "Apple" etc. */
@property(nonatomic, copy, nullable) NSString *mobileDeviceBranding;

/** Mobile device model. Eg: "Pixel", "iPhone" etc. */
@property(nonatomic, copy, nullable) NSString *mobileDeviceModel;

/** The name of the screen. */
@property(nonatomic, copy, nullable) NSString *screenName;

@end


/**
 *  The request to fetch User Report from Reporting API `userActivity:get` call.
 */
@interface GTLRAnalyticsReporting_SearchUserActivityRequest : GTLRObject

/**
 *  Set of all activity types being requested. Only acvities matching these
 *  types will be returned in the response. If empty, all activies will be
 *  returned.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *activityTypes;

/**
 *  Date range for which to retrieve the user activity. If a date range is not
 *  provided, the default date range is (startDate: current date - 7 days,
 *  endDate: current date - 1 day).
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_DateRange *dateRange;

/**
 *  Page size is for paging and specifies the maximum number of returned rows.
 *  Page size should be > 0. If the value is 0 or if the field isn't specified,
 *  the request returns the default of 1000 rows per page.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *pageSize;

/**
 *  A continuation token to get the next page of the results. Adding this to the
 *  request will return the rows after the pageToken. The pageToken should be
 *  the value returned in the nextPageToken parameter in the response to the
 *  [SearchUserActivityRequest](#SearchUserActivityRequest) request.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Unique user Id to query for. Every
 *  [SearchUserActivityRequest](#SearchUserActivityRequest) must contain this
 *  field.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_User *user;

/**
 *  Required. The Analytics [view
 *  ID](https://support.google.com/analytics/answer/1009618) from which to
 *  retrieve data. Every [SearchUserActivityRequest](#SearchUserActivityRequest)
 *  must contain the `viewId`.
 */
@property(nonatomic, copy, nullable) NSString *viewId;

@end


/**
 *  The response from `userActivity:get` call.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "sessions" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRAnalyticsReporting_SearchUserActivityResponse : GTLRCollectionObject

/**
 *  This token should be passed to
 *  [SearchUserActivityRequest](#SearchUserActivityRequest) to retrieve the next
 *  page.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  This field represents the [sampling
 *  rate](https://support.google.com/analytics/answer/2637192) for the given
 *  request and is a number between 0.0 to 1.0. See [developer
 *  guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sampleRate;

/**
 *  Each record represents a session (device details, duration, etc).
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_UserActivitySession *> *sessions;

/**
 *  Total rows returned by this query (across different pages).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalRows;

@end


/**
 *  The segment definition, if the report needs to be segmented. A Segment is a
 *  subset of the Analytics data. For example, of the entire set of users, one
 *  Segment might be users from a particular country or city.
 */
@interface GTLRAnalyticsReporting_Segment : GTLRObject

/** A dynamic segment definition in the request. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_DynamicSegment *dynamicSegment;

/** The segment ID of a built-in or custom segment, for example `gaid::-3`. */
@property(nonatomic, copy, nullable) NSString *segmentId;

@end


/**
 *  SegmentDefinition defines the segment to be a set of SegmentFilters which
 *  are combined together with a logical `AND` operation.
 */
@interface GTLRAnalyticsReporting_SegmentDefinition : GTLRObject

/**
 *  A segment is defined by a set of segment filters which are combined together
 *  with a logical `AND` operation.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_SegmentFilter *> *segmentFilters;

@end


/**
 *  Dimension filter specifies the filtering options on a dimension.
 */
@interface GTLRAnalyticsReporting_SegmentDimensionFilter : GTLRObject

/**
 *  Should the match be case sensitive, ignored for `IN_LIST` operator.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *caseSensitive;

/** Name of the dimension for which the filter is being applied. */
@property(nonatomic, copy, nullable) NSString *dimensionName;

/**
 *  The list of expressions, only the first element is used for all operators
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *expressions;

/** Maximum comparison values for `BETWEEN` match type. */
@property(nonatomic, copy, nullable) NSString *maxComparisonValue;

/** Minimum comparison values for `BETWEEN` match type. */
@property(nonatomic, copy, nullable) NSString *minComparisonValue;

/**
 *  The operator to use to match the dimension with the expressions.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_BeginsWith
 *        Matches the values which begin with the match expression provided.
 *        (Value: "BEGINS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_EndsWith
 *        Matches the values which end with the match expression provided.
 *        (Value: "ENDS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Exact
 *        The value should match the match expression entirely. (Value: "EXACT")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_InList
 *        This option is used to specify a dimension filter whose expression can
 *        take any value from a selected list of values. This helps avoiding
 *        evaluating multiple exact match dimension filters which are OR'ed for
 *        every single response row. For example: expressions: ["A", "B", "C"]
 *        Any response row whose dimension has it is value as A, B or C, matches
 *        this DimensionFilter. (Value: "IN_LIST")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericBetween
 *        Checks if the dimension is numerically between the minimum and maximum
 *        of the match expression, boundaries excluded. (Value:
 *        "NUMERIC_BETWEEN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericGreaterThan
 *        Checks if the dimension is numerically greater than the match
 *        expression. (Value: "NUMERIC_GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericLessThan
 *        Integer comparison filters. case sensitivity is ignored for these and
 *        the expression is assumed to be a string representing an integer.
 *        Failure conditions: - if expression is not a valid int64, the client
 *        should expect an error. - input dimensions that are not valid int64
 *        values will never match the filter. Checks if the dimension is
 *        numerically less than the match expression. (Value:
 *        "NUMERIC_LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_OperatorUnspecified
 *        If the match type is unspecified, it is treated as a REGEXP. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Partial
 *        Substring match. (Value: "PARTIAL")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Regexp
 *        The match expression is treated as a regular expression. All other
 *        match types are not treated as regular expressions. (Value: "REGEXP")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

@end


/**
 *  SegmentFilter defines the segment to be either a simple or a sequence
 *  segment. A simple segment condition contains dimension and metric conditions
 *  to select the sessions or users. A sequence segment condition can be used to
 *  select users or sessions based on sequential conditions.
 */
@interface GTLRAnalyticsReporting_SegmentFilter : GTLRObject

/**
 *  If true, match the complement of simple or sequence segment. For example, to
 *  match all visits not from "New York", we can define the segment as follows:
 *  "sessionSegment": { "segmentFilters": [{ "simpleSegment" :{
 *  "orFiltersForSegment": [{ "segmentFilterClauses":[{ "dimensionFilter": {
 *  "dimensionName": "ga:city", "expressions": ["New York"] } }] }] }, "not":
 *  "True" }] },
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *notProperty;

/**
 *  Sequence conditions consist of one or more steps, where each step is defined
 *  by one or more dimension/metric conditions. Multiple steps can be combined
 *  with special sequence operators.
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_SequenceSegment *sequenceSegment;

/**
 *  A Simple segment conditions consist of one or more dimension/metric
 *  conditions that can be combined
 */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_SimpleSegment *simpleSegment;

@end


/**
 *  Filter Clause to be used in a segment definition, can be wither a metric or
 *  a dimension filter.
 */
@interface GTLRAnalyticsReporting_SegmentFilterClause : GTLRObject

/** Dimension Filter for the segment definition. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_SegmentDimensionFilter *dimensionFilter;

/** Metric Filter for the segment definition. */
@property(nonatomic, strong, nullable) GTLRAnalyticsReporting_SegmentMetricFilter *metricFilter;

/**
 *  Matches the complement (`!`) of the filter.
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *notProperty;

@end


/**
 *  Metric filter to be used in a segment filter clause.
 */
@interface GTLRAnalyticsReporting_SegmentMetricFilter : GTLRObject

/**
 *  The value to compare against. If the operator is `BETWEEN`, this value is
 *  treated as minimum comparison value.
 */
@property(nonatomic, copy, nullable) NSString *comparisonValue;

/** Max comparison value is only used for `BETWEEN` operator. */
@property(nonatomic, copy, nullable) NSString *maxComparisonValue;

/**
 *  The metric that will be filtered on. A `metricFilter` must contain a metric
 *  name.
 */
@property(nonatomic, copy, nullable) NSString *metricName;

/**
 *  Specifies is the operation to perform to compare the metric. The default is
 *  `EQUAL`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Between
 *        For between operator, both the minimum and maximum are exclusive. We
 *        will use `LT` and `GT` for comparison. (Value: "BETWEEN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Equal
 *        Equals operator. (Value: "EQUAL")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_GreaterThan
 *        Checks if the metric value is greater than comparison value. (Value:
 *        "GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_LessThan
 *        Checks if the metric value is less than comparison value. (Value:
 *        "LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_UnspecifiedOperator
 *        Unspecified operator is treated as `LESS_THAN` operator. (Value:
 *        "UNSPECIFIED_OPERATOR")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(nonatomic, copy, nullable) NSString *operatorProperty;

/**
 *  Scope for a metric defines the level at which that metric is defined. The
 *  specified metric scope must be equal to or greater than its primary scope as
 *  defined in the data model. The primary scope is defined by if the segment is
 *  selecting users or sessions.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Hit Hit scope.
 *        (Value: "HIT")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Product Product
 *        scope. (Value: "PRODUCT")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Session Session
 *        scope. (Value: "SESSION")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_UnspecifiedScope
 *        If the scope is unspecified, it defaults to the condition scope,
 *        `USER` or `SESSION` depending on if the segment is trying to choose
 *        users or sessions. (Value: "UNSPECIFIED_SCOPE")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_User User scope.
 *        (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *scope;

@end


/**
 *  A segment sequence definition.
 */
@interface GTLRAnalyticsReporting_SegmentSequenceStep : GTLRObject

/**
 *  Specifies if the step immediately precedes or can be any time before the
 *  next step.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_ImmediatelyPrecedes
 *        Operator indicates that the previous step immediately precedes the
 *        next step. (Value: "IMMEDIATELY_PRECEDES")
 *    @arg @c kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_Precedes
 *        Operator indicates that the previous step precedes the next step.
 *        (Value: "PRECEDES")
 *    @arg @c kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_UnspecifiedMatchType
 *        Unspecified match type is treated as precedes. (Value:
 *        "UNSPECIFIED_MATCH_TYPE")
 */
@property(nonatomic, copy, nullable) NSString *matchType;

/**
 *  A sequence is specified with a list of Or grouped filters which are combined
 *  with `AND` operator.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_OrFiltersForSegment *> *orFiltersForSegment;

@end


/**
 *  Sequence conditions consist of one or more steps, where each step is defined
 *  by one or more dimension/metric conditions. Multiple steps can be combined
 *  with special sequence operators.
 */
@interface GTLRAnalyticsReporting_SequenceSegment : GTLRObject

/**
 *  If set, first step condition must match the first hit of the visitor (in the
 *  date range).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *firstStepShouldMatchFirstHit;

/** The list of steps in the sequence. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_SegmentSequenceStep *> *segmentSequenceSteps;

@end


/**
 *  A Simple segment conditions consist of one or more dimension/metric
 *  conditions that can be combined.
 */
@interface GTLRAnalyticsReporting_SimpleSegment : GTLRObject

/**
 *  A list of segment filters groups which are combined with logical `AND`
 *  operator.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_OrFiltersForSegment *> *orFiltersForSegment;

@end


/**
 *  Represents details collected when the visitor performs a transaction on the
 *  page.
 */
@interface GTLRAnalyticsReporting_TransactionData : GTLRObject

/**
 *  The transaction ID, supplied by the e-commerce tracking method, for the
 *  purchase in the shopping cart.
 */
@property(nonatomic, copy, nullable) NSString *transactionId;

/**
 *  The total sale revenue (excluding shipping and tax) of the transaction.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *transactionRevenue;

/**
 *  Total cost of shipping.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *transactionShipping;

/**
 *  Total tax for the transaction.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *transactionTax;

@end


/**
 *  Contains information to identify a particular user uniquely.
 */
@interface GTLRAnalyticsReporting_User : GTLRObject

/**
 *  Type of the user in the request. The field `userId` is associated with this
 *  type.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_User_Type_ClientId Analytics assigned
 *        client_id. (Value: "CLIENT_ID")
 *    @arg @c kGTLRAnalyticsReporting_User_Type_UserId A single user, like a
 *        signed-in user account, that may interact with content across one or
 *        more devices and / or browser instances. (Value: "USER_ID")
 *    @arg @c kGTLRAnalyticsReporting_User_Type_UserIdTypeUnspecified When the
 *        User Id Type is not specified, the default type used will be
 *        CLIENT_ID. (Value: "USER_ID_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

/** Unique Id of the user for which the data is being requested. */
@property(nonatomic, copy, nullable) NSString *userId;

@end


/**
 *  This represents a user session performed on a specific device at a certain
 *  time over a period of time.
 */
@interface GTLRAnalyticsReporting_UserActivitySession : GTLRObject

/** Represents a detailed view into each of the activity in this session. */
@property(nonatomic, strong, nullable) NSArray<GTLRAnalyticsReporting_Activity *> *activities;

/**
 *  The data source of a hit. By default, hits sent from analytics.js are
 *  reported as "web" and hits sent from the mobile SDKs are reported as "app".
 *  These values can be overridden in the Measurement Protocol.
 */
@property(nonatomic, copy, nullable) NSString *dataSource;

/** The type of device used: "mobile", "tablet" etc. */
@property(nonatomic, copy, nullable) NSString *deviceCategory;

/** Platform on which the activity happened: "android", "ios" etc. */
@property(nonatomic, copy, nullable) NSString *platform;

/** Date of this session in ISO-8601 format. */
@property(nonatomic, copy, nullable) NSString *sessionDate;

/** Unique ID of the session. */
@property(nonatomic, copy, nullable) NSString *sessionId;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
