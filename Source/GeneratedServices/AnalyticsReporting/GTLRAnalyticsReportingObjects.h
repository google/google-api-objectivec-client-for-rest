// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Analytics Reporting API (analyticsreporting/v4)
// Description:
//   Accesses Analytics report data.
// Documentation:
//   https://developers.google.com/analytics/devguides/reporting/core/v4/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAnalyticsReporting_Cohort;
@class GTLRAnalyticsReporting_CohortGroup;
@class GTLRAnalyticsReporting_ColumnHeader;
@class GTLRAnalyticsReporting_DateRange;
@class GTLRAnalyticsReporting_DateRangeValues;
@class GTLRAnalyticsReporting_Dimension;
@class GTLRAnalyticsReporting_DimensionFilter;
@class GTLRAnalyticsReporting_DimensionFilterClause;
@class GTLRAnalyticsReporting_DynamicSegment;
@class GTLRAnalyticsReporting_Metric;
@class GTLRAnalyticsReporting_MetricFilter;
@class GTLRAnalyticsReporting_MetricFilterClause;
@class GTLRAnalyticsReporting_MetricHeader;
@class GTLRAnalyticsReporting_MetricHeaderEntry;
@class GTLRAnalyticsReporting_OrderBy;
@class GTLRAnalyticsReporting_OrFiltersForSegment;
@class GTLRAnalyticsReporting_Pivot;
@class GTLRAnalyticsReporting_PivotHeader;
@class GTLRAnalyticsReporting_PivotHeaderEntry;
@class GTLRAnalyticsReporting_PivotValueRegion;
@class GTLRAnalyticsReporting_Report;
@class GTLRAnalyticsReporting_ReportData;
@class GTLRAnalyticsReporting_ReportRequest;
@class GTLRAnalyticsReporting_ReportRow;
@class GTLRAnalyticsReporting_Segment;
@class GTLRAnalyticsReporting_SegmentDefinition;
@class GTLRAnalyticsReporting_SegmentDimensionFilter;
@class GTLRAnalyticsReporting_SegmentFilter;
@class GTLRAnalyticsReporting_SegmentFilterClause;
@class GTLRAnalyticsReporting_SegmentMetricFilter;
@class GTLRAnalyticsReporting_SegmentSequenceStep;
@class GTLRAnalyticsReporting_SequenceSegment;
@class GTLRAnalyticsReporting_SimpleSegment;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_Cohort.type

/**
 *  Cohorts that are selected based on first visit date.
 *
 *  Value: "FIRST_VISIT_DATE"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Cohort_Type_FirstVisitDate;
/**
 *  If unspecified it's treated as `FIRST_VISIT_DATE`.
 *
 *  Value: "UNSPECIFIED_COHORT_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Cohort_Type_UnspecifiedCohortType;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_DimensionFilter.operatorProperty

/**
 *  Matches the value which begin with the match expression provided.
 *
 *  Value: "BEGINS_WITH"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_BeginsWith;
/**
 *  Matches the values which end with the match expression provided.
 *
 *  Value: "ENDS_WITH"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_EndsWith;
/**
 *  The value should match the match expression entirely.
 *
 *  Value: "EXACT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Exact;
/**
 *  This option is used to specify a dimension filter whose expression can
 *  take any value from a selected list of values. This helps avoiding
 *  evaluating multiple exact match dimension filters which are OR'ed for
 *  every single response row. For example:
 *  expressions: ["A", "B", "C"]
 *  Any response row whose dimension has it is value as A, B or C, matches
 *  this DimensionFilter.
 *
 *  Value: "IN_LIST"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_InList;
/**
 *  Integer comparison filters.
 *  case sensitivity is ignored for these and the expression
 *  is assumed to be a string representing an integer.
 *  Failure conditions:
 *  - If expression is not a valid int64, the client should expect
 *  an error.
 *  - Input dimensions that are not valid int64 values will never match the
 *  filter.
 *
 *  Value: "NUMERIC_EQUAL"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericEqual;
/**
 *  Checks if the dimension is numerically greater than the match
 *  expression. Read the description for `NUMERIC_EQUALS` for restrictions.
 *
 *  Value: "NUMERIC_GREATER_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericGreaterThan;
/**
 *  Checks if the dimension is numerically less than the match expression.
 *  Read the description for `NUMERIC_EQUALS` for restrictions.
 *
 *  Value: "NUMERIC_LESS_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericLessThan;
/**
 *  If the match type is unspecified, it is treated as a `REGEXP`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_OperatorUnspecified;
/**
 *  Substring match.
 *
 *  Value: "PARTIAL"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Partial;
/**
 *  The match expression is treated as a regular expression. All match types
 *  are not treated as regular expressions.
 *
 *  Value: "REGEXP"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Regexp;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_DimensionFilterClause.operatorProperty

/**
 *  The logical `AND` operator.
 *
 *  Value: "AND"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_And;
/**
 *  Unspecified operator. It is treated as an `OR`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_OperatorUnspecified;
/**
 *  The logical `OR` operator.
 *
 *  Value: "OR"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_Or;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_Metric.formattingType

/**
 *  Currency metric.
 *
 *  Value: "CURRENCY"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Currency;
/**
 *  Float metric.
 *
 *  Value: "FLOAT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Float;
/**
 *  Integer metric.
 *
 *  Value: "INTEGER"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Integer;
/**
 *  Metric type is unspecified.
 *
 *  Value: "METRIC_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_MetricTypeUnspecified;
/**
 *  Percentage metric.
 *
 *  Value: "PERCENT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Percent;
/**
 *  Time metric in `HH:MM:SS` format.
 *
 *  Value: "TIME"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_Metric_FormattingType_Time;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_MetricFilter.operatorProperty

/**
 *  Should the value of the metric be exactly equal to the comparison value.
 *
 *  Value: "EQUAL"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_Equal;
/**
 *  Should the value of the metric be greater than to the comparison value.
 *
 *  Value: "GREATER_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_GreaterThan;
/**
 *  Validates if the metric is missing.
 *  Doesn't take comparisonValue into account.
 *
 *  Value: "IS_MISSING"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_IsMissing;
/**
 *  Should the value of the metric be less than to the comparison value.
 *
 *  Value: "LESS_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_LessThan;
/**
 *  If the operator is not specified, it is treated as `EQUAL`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_OperatorUnspecified;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_MetricFilterClause.operatorProperty

/**
 *  The logical `AND` operator.
 *
 *  Value: "AND"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_And;
/**
 *  Unspecified operator. It is treated as an `OR`.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_OperatorUnspecified;
/**
 *  The logical `OR` operator.
 *
 *  Value: "OR"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_Or;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_MetricHeaderEntry.type

/**
 *  Currency metric.
 *
 *  Value: "CURRENCY"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Currency;
/**
 *  Float metric.
 *
 *  Value: "FLOAT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Float;
/**
 *  Integer metric.
 *
 *  Value: "INTEGER"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Integer;
/**
 *  Metric type is unspecified.
 *
 *  Value: "METRIC_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_MetricTypeUnspecified;
/**
 *  Percentage metric.
 *
 *  Value: "PERCENT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Percent;
/**
 *  Time metric in `HH:MM:SS` format.
 *
 *  Value: "TIME"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Time;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_OrderBy.orderType

/**
 *  The sort order is based on the difference of the values of the chosen
 *  column between the first two date ranges. Usable only if there are
 *  exactly two date ranges.
 *
 *  Value: "DELTA"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_Delta;
/**
 *  If the dimensions are fixed length numbers, ordinary sort would just
 *  work fine. `DIMENSION_AS_INTEGER` can be used if the dimensions are
 *  variable length numbers.
 *
 *  Value: "DIMENSION_AS_INTEGER"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_DimensionAsInteger;
/**
 *  Histogram order type is applicable only to dimension columns with
 *  non-empty histogram-buckets.
 *
 *  Value: "HISTOGRAM_BUCKET"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_HistogramBucket;
/**
 *  Unspecified order type will be treated as sort based on value.
 *
 *  Value: "ORDER_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_OrderTypeUnspecified;
/**
 *  The sort order is based on weighted value of the chosen column. If
 *  column has n/d format, then weighted value of this ratio will
 *  be `(n + totals.n)/(d + totals.d)` Usable only for metrics that
 *  represent ratios.
 *
 *  Value: "SMART"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_Smart;
/**
 *  The sort order is based on the value of the chosen column; looks only at
 *  the first date range
 *
 *  Value: "VALUE"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_OrderType_Value;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_OrderBy.sortOrder

/**
 *  Ascending sort. The field will be sorted in an ascending manner.
 *
 *  Value: "ASCENDING"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_SortOrder_Ascending;
/**
 *  Descending sort. The field will be sorted in a descending manner.
 *
 *  Value: "DESCENDING"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_SortOrder_Descending;
/**
 *  If the sort order is unspecified, the default is ascending.
 *
 *  Value: "SORT_ORDER_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_OrderBy_SortOrder_SortOrderUnspecified;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_ReportRequest.samplingLevel

/**
 *  Returns response with a sample size that balances speed and
 *  accuracy.
 *
 *  Value: "DEFAULT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Default;
/**
 *  Returns a more accurate response using a large sampling size. But this
 *  may result in response being slower.
 *
 *  Value: "LARGE"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Large;
/**
 *  If sampling level is unspecified the default sampling level is used.
 *
 *  Value: "SAMPLING_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_SamplingUnspecified;
/**
 *  It returns a fast response with a smaller sampling size.
 *
 *  Value: "SMALL"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Small;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentDimensionFilter.operatorProperty

/**
 *  Matches the values which begin with the match expression provided.
 *
 *  Value: "BEGINS_WITH"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_BeginsWith;
/**
 *  Matches the values which end with the match expression provided.
 *
 *  Value: "ENDS_WITH"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_EndsWith;
/**
 *  The value should match the match expression entirely.
 *
 *  Value: "EXACT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Exact;
/**
 *  This option is used to specify a dimension filter whose expression can
 *  take any value from a selected list of values. This helps avoiding
 *  evaluating multiple exact match dimension filters which are OR'ed for
 *  every single response row. For example:
 *  expressions: ["A", "B", "C"]
 *  Any response row whose dimension has it is value as A, B or C, matches
 *  this DimensionFilter.
 *
 *  Value: "IN_LIST"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_InList;
/**
 *  Checks if the dimension is numerically between the minimum and maximum
 *  of the match expression, boundaries excluded.
 *
 *  Value: "NUMERIC_BETWEEN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericBetween;
/**
 *  Checks if the dimension is numerically greater than the match
 *  expression.
 *
 *  Value: "NUMERIC_GREATER_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericGreaterThan;
/**
 *  Integer comparison filters.
 *  case sensitivity is ignored for these and the expression
 *  is assumed to be a string representing an integer.
 *  Failure conditions:
 *  - if expression is not a valid int64, the client should expect
 *  an error.
 *  - input dimensions that are not valid int64 values will never match the
 *  filter.
 *  Checks if the dimension is numerically less than the match expression.
 *
 *  Value: "NUMERIC_LESS_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericLessThan;
/**
 *  If the match type is unspecified, it is treated as a REGEXP.
 *
 *  Value: "OPERATOR_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_OperatorUnspecified;
/**
 *  Substring match.
 *
 *  Value: "PARTIAL"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Partial;
/**
 *  The match expression is treated as a regular expression. All other match
 *  types are not treated as regular expressions.
 *
 *  Value: "REGEXP"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Regexp;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentMetricFilter.operatorProperty

/**
 *  For between operator, both the minimum and maximum are exclusive.
 *  We will use `LT` and `GT` for comparison.
 *
 *  Value: "BETWEEN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Between;
/**
 *  Equals operator.
 *
 *  Value: "EQUAL"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Equal;
/**
 *  Checks if the metric value is greater than comparison value.
 *
 *  Value: "GREATER_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_GreaterThan;
/**
 *  Checks if the metric value is less than comparison value.
 *
 *  Value: "LESS_THAN"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_LessThan;
/**
 *  Unspecified operator is treated as `LESS_THAN` operator.
 *
 *  Value: "UNSPECIFIED_OPERATOR"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_UnspecifiedOperator;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentMetricFilter.scope

/**
 *  Hit scope.
 *
 *  Value: "HIT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Hit;
/**
 *  Product scope.
 *
 *  Value: "PRODUCT"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Product;
/**
 *  Session scope.
 *
 *  Value: "SESSION"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Session;
/**
 *  If the scope is unspecified, it defaults to the condition scope,
 *  `USER` or `SESSION` depending on if the segment is trying to choose
 *  users or sessions.
 *
 *  Value: "UNSPECIFIED_SCOPE"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_UnspecifiedScope;
/**
 *  User scope.
 *
 *  Value: "USER"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_User;

// ----------------------------------------------------------------------------
// GTLRAnalyticsReporting_SegmentSequenceStep.matchType

/**
 *  Operator indicates that the previous step immediately precedes the next
 *  step.
 *
 *  Value: "IMMEDIATELY_PRECEDES"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_ImmediatelyPrecedes;
/**
 *  Operator indicates that the previous step precedes the next step.
 *
 *  Value: "PRECEDES"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_Precedes;
/**
 *  Unspecified match type is treated as precedes.
 *
 *  Value: "UNSPECIFIED_MATCH_TYPE"
 */
GTLR_EXTERN NSString * const kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_UnspecifiedMatchType;

/**
 *  Defines a cohort. A cohort is a group of users who share a common
 *  characteristic. For example, all users with the same acquisition date
 *  belong to the same cohort.
 */
@interface GTLRAnalyticsReporting_Cohort : GTLRObject

/**
 *  This is used for `FIRST_VISIT_DATE` cohort, the cohort selects users
 *  whose first visit date is between start date and end date defined in the
 *  DateRange. The date ranges should be aligned for cohort requests. If the
 *  request contains cohort_nth_day it should be exactly one day long,
 *  if `ga:cohortNthWeek` it should be aligned to the week boundary (starting
 *  at Sunday and ending Saturday), and for cohort_nth_month the date range
 *  should be aligned to the month (starting at the first and ending on the
 *  last day of the month).
 *  For LTV requests there are no such restrictions.
 *  You do not need to supply a date range for the reportsRequest object.
 */
@property(strong, nullable) GTLRAnalyticsReporting_DateRange *dateRange;

/**
 *  A unique name for the cohort. If not defined name will be auto-generated
 *  with values cohort_[1234...].
 */
@property(copy, nullable) NSString *name;

/**
 *  Type of the cohort. The only supported type as of now is
 *  `FIRST_VISIT_DATE`. If this field is unspecified the cohort is treated
 *  as `FIRST_VISIT_DATE` type cohort.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_Cohort_Type_FirstVisitDate Cohorts that
 *        are selected based on first visit date. (Value: "FIRST_VISIT_DATE")
 *    @arg @c kGTLRAnalyticsReporting_Cohort_Type_UnspecifiedCohortType If
 *        unspecified it's treated as `FIRST_VISIT_DATE`. (Value:
 *        "UNSPECIFIED_COHORT_TYPE")
 */
@property(copy, nullable) NSString *type;

@end


/**
 *  Defines a cohort group.
 *  For example:
 *  "cohortGroup": {
 *  "cohorts": [{
 *  "name": "cohort 1",
 *  "type": "FIRST_VISIT_DATE",
 *  "dateRange": { "startDate": "2015-08-01", "endDate": "2015-08-01" }
 *  },{
 *  "name": "cohort 2"
 *  "type": "FIRST_VISIT_DATE"
 *  "dateRange": { "startDate": "2015-07-01", "endDate": "2015-07-01" }
 *  }]
 *  }
 */
@interface GTLRAnalyticsReporting_CohortGroup : GTLRObject

/** The definition for the cohort. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Cohort *> *cohorts;

/**
 *  Enable Life Time Value (LTV). LTV measures lifetime value for users
 *  acquired through different channels.
 *  Please see:
 *  [Cohort Analysis](https://support.google.com/analytics/answer/6074676) and
 *  [Lifetime Value](https://support.google.com/analytics/answer/6182550)
 *  If the value of lifetimeValue is false:
 *  - The metric values are similar to the values in the web interface cohort
 *  report.
 *  - The cohort definition date ranges must be aligned to the calendar week
 *  and month. i.e. while requesting `ga:cohortNthWeek` the `startDate` in
 *  the cohort definition should be a Sunday and the `endDate` should be the
 *  following Saturday, and for `ga:cohortNthMonth`, the `startDate`
 *  should be the 1st of the month and `endDate` should be the last day
 *  of the month.
 *  When the lifetimeValue is true:
 *  - The metric values will correspond to the values in the web interface
 *  LifeTime value report.
 *  - The Lifetime Value report shows you how user value (Revenue) and
 *  engagement (Appviews, Goal Completions, Sessions, and Session Duration)
 *  grow during the 90 days after a user is acquired.
 *  - The metrics are calculated as a cumulative average per user per the time
 *  increment.
 *  - The cohort definition date ranges need not be aligned to the calendar
 *  week and month boundaries.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *lifetimeValue;

@end


/**
 *  Column headers.
 */
@interface GTLRAnalyticsReporting_ColumnHeader : GTLRObject

/** The dimension names in the response. */
@property(strong, nullable) NSArray<NSString *> *dimensions;

/** Metric headers for the metrics in the response. */
@property(strong, nullable) GTLRAnalyticsReporting_MetricHeader *metricHeader;

@end


/**
 *  A contiguous set of days: startDate, startDate + 1 day, ..., endDate.
 *  The start and end dates are specified in
 *  [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date format `YYYY-MM-DD`.
 */
@interface GTLRAnalyticsReporting_DateRange : GTLRObject

/** The end date for the query in the format `YYYY-MM-DD`. */
@property(copy, nullable) NSString *endDate;

/** The start date for the query in the format `YYYY-MM-DD`. */
@property(copy, nullable) NSString *startDate;

@end


/**
 *  Used to return a list of metrics for a single DateRange / dimension
 *  combination
 */
@interface GTLRAnalyticsReporting_DateRangeValues : GTLRObject

/** The values of each pivot region. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_PivotValueRegion *> *pivotValueRegions;

/** Each value corresponds to each Metric in the request. */
@property(strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  A dimension in the request.
 */
@interface GTLRAnalyticsReporting_Dimension : GTLRObject

/**
 *  If non-empty, we place dimension values into buckets after string to
 *  int64. Dimension values that are not the string representation of an
 *  integral value will be converted to zero. The bucket values have to be in
 *  increasing order. Each bucket is closed on the lower end, and open on the
 *  upper end. The "first" bucket includes all values less than the first
 *  boundary, the "last" bucket includes all values up to infinity. Dimension
 *  values that fall in a bucket get transformed to a new dimension value. For
 *  example, if one gives a list of "0, 1, 3, 4, 7", then we return the
 *  following buckets:
 *  - bucket #1: values < 0, dimension value "<0"
 *  - bucket #2: values in [0,1), dimension value "0"
 *  - bucket #3: values in [1,3), dimension value "1-2"
 *  - bucket #4: values in [3,4), dimension value "3"
 *  - bucket #5: values in [4,7), dimension value "4-6"
 *  - bucket #6: values >= 7, dimension value "7+"
 *  NOTE: If you are applying histogram mutation on any dimension, and using
 *  that dimension in sort, you will want to use the sort type
 *  `HISTOGRAM_BUCKET` for that purpose. Without that the dimension values
 *  will be sorted according to dictionary
 *  (lexicographic) order. For example the ascending dictionary order is:
 *  "<50", "1001+", "121-1000", "50-120"
 *  And the ascending `HISTOGRAM_BUCKET` order is:
 *  "<50", "50-120", "121-1000", "1001+"
 *  The client has to explicitly request `"orderType": "HISTOGRAM_BUCKET"`
 *  for a histogram-mutated dimension.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSArray<NSNumber *> *histogramBuckets;

/** Name of the dimension to fetch, for example `ga:browser`. */
@property(copy, nullable) NSString *name;

@end


/**
 *  Dimension filter specifies the filtering options on a dimension.
 */
@interface GTLRAnalyticsReporting_DimensionFilter : GTLRObject

/**
 *  Should the match be case sensitive? Default is false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *caseSensitive;

/** The dimension to filter on. A DimensionFilter must contain a dimension. */
@property(copy, nullable) NSString *dimensionName;

/**
 *  Strings or regular expression to match against. Only the first value of
 *  the list is used for comparison unless the operator is `IN_LIST`.
 *  If `IN_LIST` operator, then the entire list is used to filter the
 *  dimensions as explained in the description of the `IN_LIST` operator.
 */
@property(strong, nullable) NSArray<NSString *> *expressions;

/**
 *  Logical `NOT` operator. If this boolean is set to true, then the matching
 *  dimension values will be excluded in the report. The default is false.
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *notProperty;

/**
 *  How to match the dimension to the expression. The default is REGEXP.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_BeginsWith
 *        Matches the value which begin with the match expression provided.
 *        (Value: "BEGINS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_EndsWith
 *        Matches the values which end with the match expression provided.
 *        (Value: "ENDS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Exact The
 *        value should match the match expression entirely. (Value: "EXACT")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_InList
 *        This option is used to specify a dimension filter whose expression can
 *        take any value from a selected list of values. This helps avoiding
 *        evaluating multiple exact match dimension filters which are OR'ed for
 *        every single response row. For example:
 *        expressions: ["A", "B", "C"]
 *        Any response row whose dimension has it is value as A, B or C, matches
 *        this DimensionFilter. (Value: "IN_LIST")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericEqual
 *        Integer comparison filters.
 *        case sensitivity is ignored for these and the expression
 *        is assumed to be a string representing an integer.
 *        Failure conditions:
 *        - If expression is not a valid int64, the client should expect
 *        an error.
 *        - Input dimensions that are not valid int64 values will never match
 *        the
 *        filter. (Value: "NUMERIC_EQUAL")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericGreaterThan
 *        Checks if the dimension is numerically greater than the match
 *        expression. Read the description for `NUMERIC_EQUALS` for
 *        restrictions. (Value: "NUMERIC_GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_NumericLessThan
 *        Checks if the dimension is numerically less than the match expression.
 *        Read the description for `NUMERIC_EQUALS` for restrictions. (Value:
 *        "NUMERIC_LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_OperatorUnspecified
 *        If the match type is unspecified, it is treated as a `REGEXP`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Partial
 *        Substring match. (Value: "PARTIAL")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilter_OperatorProperty_Regexp
 *        The match expression is treated as a regular expression. All match
 *        types
 *        are not treated as regular expressions. (Value: "REGEXP")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(copy, nullable) NSString *operatorProperty;

@end


/**
 *  A group of dimension filters. Set the operator value to specify how
 *  the filters are logically combined.
 */
@interface GTLRAnalyticsReporting_DimensionFilterClause : GTLRObject

/**
 *  The repeated set of filters. They are logically combined based on the
 *  operator specified.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DimensionFilter *> *filters;

/**
 *  The operator for combining multiple dimension filters. If unspecified, it
 *  is treated as an `OR`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_And
 *        The logical `AND` operator. (Value: "AND")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_OperatorUnspecified
 *        Unspecified operator. It is treated as an `OR`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_DimensionFilterClause_OperatorProperty_Or
 *        The logical `OR` operator. (Value: "OR")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(copy, nullable) NSString *operatorProperty;

@end


/**
 *  Dynamic segment definition for defining the segment within the request.
 *  A segment can select users, sessions or both.
 */
@interface GTLRAnalyticsReporting_DynamicSegment : GTLRObject

/** The name of the dynamic segment. */
@property(copy, nullable) NSString *name;

/** Session Segment to select sessions to include in the segment. */
@property(strong, nullable) GTLRAnalyticsReporting_SegmentDefinition *sessionSegment;

/** User Segment to select users to include in the segment. */
@property(strong, nullable) GTLRAnalyticsReporting_SegmentDefinition *userSegment;

@end


/**
 *  The batch request containing multiple report request.
 */
@interface GTLRAnalyticsReporting_GetReportsRequest : GTLRObject

/** Requests, each request will have a separate response. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_ReportRequest *> *reportRequests;

@end


/**
 *  The main response class which holds the reports from the Reporting API
 *  batchRequest call.
 */
@interface GTLRAnalyticsReporting_GetReportsResponse : GTLRObject

/** Responses corresponding to each of the request. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Report *> *reports;

@end


/**
 *  A metric in the request.
 */
@interface GTLRAnalyticsReporting_Metric : GTLRObject

/**
 *  An alias for the metric expression is an alternate name for the
 *  expression. The alias can be used for filtering and sorting. This field
 *  is optional and is useful if the expression is not a single metric but
 *  a complex expression which cannot be used in filtering and sorting.
 *  The alias is also used in the response column header.
 */
@property(copy, nullable) NSString *alias;

/**
 *  A metric expression in the request. An expression is constructed from one
 *  or more metrics and numbers. Accepted operators include: Plus (+), Minus
 *  (-), Negation (Unary -), Divided by (/), Multiplied by (*), Parenthesis,
 *  Positive cardinal numbers (0-9), can include decimals and is limited to
 *  1024 characters. Example `ga:totalRefunds/ga:users`, in most cases the
 *  metric expression is just a single metric name like `ga:users`.
 */
@property(copy, nullable) NSString *expression;

/**
 *  Specifies how the metric expression should be formatted, for example
 *  `INTEGER`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Currency Currency
 *        metric. (Value: "CURRENCY")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Float Float metric.
 *        (Value: "FLOAT")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Integer Integer
 *        metric. (Value: "INTEGER")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_MetricTypeUnspecified
 *        Metric type is unspecified. (Value: "METRIC_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Percent Percentage
 *        metric. (Value: "PERCENT")
 *    @arg @c kGTLRAnalyticsReporting_Metric_FormattingType_Time Time metric in
 *        `HH:MM:SS` format. (Value: "TIME")
 */
@property(copy, nullable) NSString *formattingType;

@end


/**
 *  MetricFilter specifies the filter on a metric.
 */
@interface GTLRAnalyticsReporting_MetricFilter : GTLRObject

/** The value to compare against. */
@property(copy, nullable) NSString *comparisonValue;

/**
 *  The metric that will be filtered on. A metricFilter must contain a metric
 *  name. A metric name can be an alias earlier defined as a metric or it can
 *  also be a metric expression.
 */
@property(copy, nullable) NSString *metricName;

/**
 *  Logical `NOT` operator. If this boolean is set to true, then the matching
 *  metric values will be excluded in the report. The default is false.
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *notProperty;

/**
 *  Is the metric `EQUAL`, `LESS_THAN` or `GREATER_THAN` the
 *  comparisonValue, the default is `EQUAL`. If the operator is
 *  `IS_MISSING`, checks if the metric is missing and would ignore the
 *  comparisonValue.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_Equal Should
 *        the value of the metric be exactly equal to the comparison value.
 *        (Value: "EQUAL")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_GreaterThan
 *        Should the value of the metric be greater than to the comparison
 *        value. (Value: "GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_IsMissing
 *        Validates if the metric is missing.
 *        Doesn't take comparisonValue into account. (Value: "IS_MISSING")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_LessThan
 *        Should the value of the metric be less than to the comparison value.
 *        (Value: "LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilter_OperatorProperty_OperatorUnspecified
 *        If the operator is not specified, it is treated as `EQUAL`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(copy, nullable) NSString *operatorProperty;

@end


/**
 *  Represents a group of metric filters.
 *  Set the operator value to specify how the filters are logically combined.
 */
@interface GTLRAnalyticsReporting_MetricFilterClause : GTLRObject

/**
 *  The repeated set of filters. They are logically combined based on the
 *  operator specified.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_MetricFilter *> *filters;

/**
 *  The operator for combining multiple metric filters. If unspecified, it is
 *  treated as an `OR`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_And
 *        The logical `AND` operator. (Value: "AND")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_OperatorUnspecified
 *        Unspecified operator. It is treated as an `OR`. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_MetricFilterClause_OperatorProperty_Or The
 *        logical `OR` operator. (Value: "OR")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(copy, nullable) NSString *operatorProperty;

@end


/**
 *  The headers for the metrics.
 */
@interface GTLRAnalyticsReporting_MetricHeader : GTLRObject

/** Headers for the metrics in the response. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_MetricHeaderEntry *> *metricHeaderEntries;

/** Headers for the pivots in the response. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_PivotHeader *> *pivotHeaders;

@end


/**
 *  Header for the metrics.
 */
@interface GTLRAnalyticsReporting_MetricHeaderEntry : GTLRObject

/** The name of the header. */
@property(copy, nullable) NSString *name;

/**
 *  The type of the metric, for example `INTEGER`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Currency Currency
 *        metric. (Value: "CURRENCY")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Float Float metric.
 *        (Value: "FLOAT")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Integer Integer
 *        metric. (Value: "INTEGER")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_MetricTypeUnspecified
 *        Metric type is unspecified. (Value: "METRIC_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Percent Percentage
 *        metric. (Value: "PERCENT")
 *    @arg @c kGTLRAnalyticsReporting_MetricHeaderEntry_Type_Time Time metric in
 *        `HH:MM:SS` format. (Value: "TIME")
 */
@property(copy, nullable) NSString *type;

@end


/**
 *  Specifies the sorting options.
 */
@interface GTLRAnalyticsReporting_OrderBy : GTLRObject

/**
 *  The field which to sort by. The default sort order is ascending. Example:
 *  `ga:browser`.
 *  Note, that you can only specify one field for sort here. For example,
 *  `ga:browser, ga:city` is not valid.
 */
@property(copy, nullable) NSString *fieldName;

/**
 *  The order type. The default orderType is `VALUE`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_Delta The sort order is
 *        based on the difference of the values of the chosen
 *        column between the first two date ranges. Usable only if there are
 *        exactly two date ranges. (Value: "DELTA")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_DimensionAsInteger If
 *        the dimensions are fixed length numbers, ordinary sort would just
 *        work fine. `DIMENSION_AS_INTEGER` can be used if the dimensions are
 *        variable length numbers. (Value: "DIMENSION_AS_INTEGER")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_HistogramBucket
 *        Histogram order type is applicable only to dimension columns with
 *        non-empty histogram-buckets. (Value: "HISTOGRAM_BUCKET")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_OrderTypeUnspecified
 *        Unspecified order type will be treated as sort based on value. (Value:
 *        "ORDER_TYPE_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_Smart The sort order is
 *        based on weighted value of the chosen column. If
 *        column has n/d format, then weighted value of this ratio will
 *        be `(n + totals.n)/(d + totals.d)` Usable only for metrics that
 *        represent ratios. (Value: "SMART")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_OrderType_Value The sort order is
 *        based on the value of the chosen column; looks only at
 *        the first date range (Value: "VALUE")
 */
@property(copy, nullable) NSString *orderType;

/**
 *  The sorting order for the field.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_SortOrder_Ascending Ascending
 *        sort. The field will be sorted in an ascending manner. (Value:
 *        "ASCENDING")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_SortOrder_Descending Descending
 *        sort. The field will be sorted in a descending manner. (Value:
 *        "DESCENDING")
 *    @arg @c kGTLRAnalyticsReporting_OrderBy_SortOrder_SortOrderUnspecified If
 *        the sort order is unspecified, the default is ascending. (Value:
 *        "SORT_ORDER_UNSPECIFIED")
 */
@property(copy, nullable) NSString *sortOrder;

@end


/**
 *  A list of segment filters in the `OR` group are combined with the logical OR
 *  operator.
 */
@interface GTLRAnalyticsReporting_OrFiltersForSegment : GTLRObject

/** List of segment filters to be combined with a `OR` operator. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_SegmentFilterClause *> *segmentFilterClauses;

@end


/**
 *  The Pivot describes the pivot section in the request.
 *  The Pivot helps rearrange the information in the table for certain reports
 *  by pivoting your data on a second dimension.
 */
@interface GTLRAnalyticsReporting_Pivot : GTLRObject

/**
 *  DimensionFilterClauses are logically combined with an `AND` operator: only
 *  data that is included by all these DimensionFilterClauses contributes to
 *  the values in this pivot region. Dimension filters can be used to restrict
 *  the columns shown in the pivot region. For example if you have
 *  `ga:browser` as the requested dimension in the pivot region, and you
 *  specify key filters to restrict `ga:browser` to only "IE" or "Firefox",
 *  then only those two browsers would show up as columns.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DimensionFilterClause *> *dimensionFilterClauses;

/** A list of dimensions to show as pivot columns. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Dimension *> *dimensions;

/**
 *  Specifies the maximum number of groups to return.
 *  If set to -1, returns all groups. The default value is 5.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *maxGroupCount;

/** Metrics to aggregate and return. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Metric *> *metrics;

/**
 *  If k metrics were requested, then the response will contain some
 *  data-dependent multiple of k columns in the report. E.g., if you pivoted
 *  on the dimension `ga:browser` then you'd get k columns for "Firefox", k
 *  columns for "IE", k columns for "Chrome", etc. The ordering of the groups
 *  of columns is determined by descending order of "total" for the first of
 *  the k values. Ties are broken by lexicographic ordering of the first
 *  pivot dimension, then lexicographic ordering of the second pivot
 *  dimension, and so on. E.g., if the totals for the first value for
 *  Firefox, IE, and Chrome were 8, 2, 8, respectively, the order of columns
 *  would be Chrome, Firefox, IE.
 *  The following let you choose which of the groups of k columns are
 *  included in the response.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *startGroup;

@end


/**
 *  The headers for each of the pivot sections defined in the request.
 */
@interface GTLRAnalyticsReporting_PivotHeader : GTLRObject

/** A single pivot section header. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_PivotHeaderEntry *> *pivotHeaderEntries;

/**
 *  The total number of groups for this pivot.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *totalPivotGroupsCount;

@end


/**
 *  The headers for the each of the metric column corresponding to the metrics
 *  requested in the pivots section of the response.
 */
@interface GTLRAnalyticsReporting_PivotHeaderEntry : GTLRObject

/**
 *  The name of the dimensions in the pivotDimensionValues field in the
 *  response.
 */
@property(strong, nullable) NSArray<NSString *> *dimensionNames;

/** The values for the dimensions in the pivot. */
@property(strong, nullable) NSArray<NSString *> *dimensionValues;

/** The metric header for the metric in the pivot. */
@property(strong, nullable) GTLRAnalyticsReporting_MetricHeaderEntry *metric;

@end


/**
 *  The metric values in the pivot region.
 */
@interface GTLRAnalyticsReporting_PivotValueRegion : GTLRObject

/** The values of the metrics in each of the pivot regions. */
@property(strong, nullable) NSArray<NSString *> *values;

@end


/**
 *  The data response corresponding to the request.
 */
@interface GTLRAnalyticsReporting_Report : GTLRObject

/** The column headers. */
@property(strong, nullable) GTLRAnalyticsReporting_ColumnHeader *columnHeader;

/** Response data. */
@property(strong, nullable) GTLRAnalyticsReporting_ReportData *data;

/** Page token to retrieve the next page of results in the list. */
@property(copy, nullable) NSString *nextPageToken;

@end


/**
 *  The data part of the report.
 */
@interface GTLRAnalyticsReporting_ReportData : GTLRObject

/**
 *  Indicates if response to this request is golden or not. Data is
 *  golden when the exact same request will not produce any new results if
 *  asked at a later point in time.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *isDataGolden;

/**
 *  Minimum and maximum values seen over all matching rows. These are both
 *  empty when `hideValueRanges` in the request is false, or when
 *  rowCount is zero.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *maximums;

/**
 *  Minimum and maximum values seen over all matching rows. These are both
 *  empty when `hideValueRanges` in the request is false, or when
 *  rowCount is zero.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *minimums;

/**
 *  Total number of matching rows for this query.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *rowCount;

/** There's one ReportRow for every unique combination of dimensions. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_ReportRow *> *rows;

/**
 *  If sampling was enabled, this returns the total number of samples
 *  read, one entry per date range
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSArray<NSNumber *> *samplesReadCounts;

/**
 *  If sampling was enabled, this returns the total number of samples
 *  present, one entry per date range.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSArray<NSNumber *> *samplingSpaceSizes;

/**
 *  For each requested date range, for the set of all rows that match
 *  the query, every requested value format gets a total. The total
 *  for a value format is computed by first totaling the metrics
 *  mentioned in the value format and then evaluating the value
 *  format as a scalar expression. E.g., The "totals" for
 *  `3 / (ga:sessions + 2)` we compute
 *  `3 / ((sum of all relevant ga:sessions) + 2)`.
 *  Totals are computed before pagination.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *totals;

@end


/**
 *  The main request class which specifies the Reporting API request.
 */
@interface GTLRAnalyticsReporting_ReportRequest : GTLRObject

/**
 *  Cohort group associated with this request. If there is a cohort group
 *  in the request the `ga:cohort` dimension must be present.
 */
@property(strong, nullable) GTLRAnalyticsReporting_CohortGroup *cohortGroup;

/**
 *  Date ranges in the request. The request can have a maximum of 2 date
 *  ranges. The response will contain a set of metric values for each
 *  combination of the dimensions for each date range in the request. So, if
 *  there are two date ranges, there will be two set of metric values, one for
 *  the original date range and one for the second date range.
 *  Date ranges should not be specified for cohorts or Lifetime value
 *  requests.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DateRange *> *dateRanges;

/**
 *  The dimension filter clauses for filtering Dimension Values. They are
 *  logically combined with the `AND` operator. Note that filtering occurs
 *  before any dimensions are aggregated, so that the returned metrics
 *  represent the total for only the relevant dimensions.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DimensionFilterClause *> *dimensionFilterClauses;

/** Dimensions requested in the request. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Dimension *> *dimensions;

/**
 *  Dimension or metric filters that restrict the data returned for your
 *  request. To use the filtersExpression, supply a dimension or metric on
 *  which to filter, followed by the filter expression. For example, the
 *  following expression selects `ga:browser` dimension which starts with
 *  Firefox; `ga:browser=~^Firefox`. For more information on dimensions
 *  and metric filters, see
 *  [Filters
 *  reference](https://developers.google.com/analytics/devguides/reporting/core/v3/reference#filters).
 */
@property(copy, nullable) NSString *filtersExpression;

/**
 *  If set to true, hides the total of all metrics for all the matching rows,
 *  for every date range. The default false and will return the totals.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *hideTotals;

/**
 *  If set to true, hides the minimum and maximum across all matching rows.
 *  The default is false and the value ranges are returned.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *hideValueRanges;

/**
 *  If set to false, the response does not include rows if all the retrieved
 *  metrics are equal to zero. The default is false which will exclude these
 *  rows.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *includeEmptyRows;

/**
 *  The metric filter clauses. They are logically combined with the `AND`
 *  operator. Metric filters look at only the first date range and not the
 *  comparing date range. Note that filtering on metrics occurs after the
 *  metrics are aggregated.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_MetricFilterClause *> *metricFilterClauses;

/** Metrics (numbers) requested in the request. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Metric *> *metrics;

/**
 *  Sort order on output rows. To compare two rows, the elements of the
 *  following are applied in order until a difference is found. All date
 *  ranges in the output get the same row order. The `order_by` field gets
 *  applied first followed by the sorts in the `additional_ordering` fields.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_OrderBy *> *orderBys;

/**
 *  Page size is for paging and specifies the maximum number of returned rows.
 *  Page size should be >= 0. A query returns the default of 1000 rows.
 *  The Analytics Core Reporting API returns a maximum of 10,000 rows per
 *  request, no matter how many you ask for. It can also return fewer rows
 *  than requested, if there aren't as many dimension segments as you expect.
 *  For instance, there are fewer than 300 possible values for `ga:country`,
 *  so when segmenting only by country, you can't get more than 300 rows,
 *  even if you set `pageSize` to a higher value.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *pageSize;

/**
 *  A continuation token to get the next page of the results. Adding this to
 *  the request will return the rows after the pageToken. The pageToken should
 *  be the value returned in the nextPageToken parameter in the response to
 *  the GetReports request.
 */
@property(copy, nullable) NSString *pageToken;

/** The pivot definitions. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Pivot *> *pivots;

/**
 *  The desired sampling level. If the sampling level is not specified the
 *  DEFAULT sampling level will be used.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Default
 *        Returns response with a sample size that balances speed and
 *        accuracy. (Value: "DEFAULT")
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Large Returns
 *        a more accurate response using a large sampling size. But this
 *        may result in response being slower. (Value: "LARGE")
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_SamplingUnspecified
 *        If sampling level is unspecified the default sampling level is used.
 *        (Value: "SAMPLING_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_ReportRequest_SamplingLevel_Small It
 *        returns a fast response with a smaller sampling size. (Value: "SMALL")
 */
@property(copy, nullable) NSString *samplingLevel;

/**
 *  Segment the data returned for the request. A segment definition helps look
 *  at a subset of the segment request. A request can contain up to four
 *  segments.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_Segment *> *segments;

/** Unique View Id for retrieving Analytics data. */
@property(copy, nullable) NSString *viewId;

@end


/**
 *  A row in the report.
 */
@interface GTLRAnalyticsReporting_ReportRow : GTLRObject

/** List of requested dimensions. */
@property(strong, nullable) NSArray<NSString *> *dimensions;

/** List of metrics for each requested DateRange */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_DateRangeValues *> *metrics;

@end


/**
 *  The segment definition, if the report needs to be segmented.
 *  A Segment is a subset of the Analytics data. For example, of the entire
 *  set of users, one Segment might be users from a particular country or city.
 */
@interface GTLRAnalyticsReporting_Segment : GTLRObject

/** A dynamic segment definition in the request. */
@property(strong, nullable) GTLRAnalyticsReporting_DynamicSegment *dynamicSegment;

/** The segment ID of a built-in or custom segment, for example 'gaid::-3'. */
@property(copy, nullable) NSString *segmentId;

@end


/**
 *  SegmentDefinition defines the segment to be a set of SegmentFilters which
 *  are combined together with a logical `AND` operation.
 */
@interface GTLRAnalyticsReporting_SegmentDefinition : GTLRObject

/**
 *  A segment is defined by a set of segment filters which are combined
 *  together with a logical `AND` operation.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_SegmentFilter *> *segmentFilters;

@end


/**
 *  Dimension filter specifies the filtering options on a dimension.
 */
@interface GTLRAnalyticsReporting_SegmentDimensionFilter : GTLRObject

/**
 *  Should the match be case sensitive, ignored for IN_LIST operator.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *caseSensitive;

/** Name of the dimension for which the filter is being applied. */
@property(copy, nullable) NSString *dimensionName;

/**
 *  The list of expressions, only the first element is used for all operators
 */
@property(strong, nullable) NSArray<NSString *> *expressions;

/** Maximum comparison values for BETWEEN match type. */
@property(copy, nullable) NSString *maxComparisonValue;

/** Minimum comparison values for BETWEEN match type. */
@property(copy, nullable) NSString *minComparisonValue;

/**
 *  The operator to use to match the dimension with the expressions.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_BeginsWith
 *        Matches the values which begin with the match expression provided.
 *        (Value: "BEGINS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_EndsWith
 *        Matches the values which end with the match expression provided.
 *        (Value: "ENDS_WITH")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Exact
 *        The value should match the match expression entirely. (Value: "EXACT")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_InList
 *        This option is used to specify a dimension filter whose expression can
 *        take any value from a selected list of values. This helps avoiding
 *        evaluating multiple exact match dimension filters which are OR'ed for
 *        every single response row. For example:
 *        expressions: ["A", "B", "C"]
 *        Any response row whose dimension has it is value as A, B or C, matches
 *        this DimensionFilter. (Value: "IN_LIST")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericBetween
 *        Checks if the dimension is numerically between the minimum and maximum
 *        of the match expression, boundaries excluded. (Value:
 *        "NUMERIC_BETWEEN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericGreaterThan
 *        Checks if the dimension is numerically greater than the match
 *        expression. (Value: "NUMERIC_GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_NumericLessThan
 *        Integer comparison filters.
 *        case sensitivity is ignored for these and the expression
 *        is assumed to be a string representing an integer.
 *        Failure conditions:
 *        - if expression is not a valid int64, the client should expect
 *        an error.
 *        - input dimensions that are not valid int64 values will never match
 *        the
 *        filter.
 *        Checks if the dimension is numerically less than the match expression.
 *        (Value: "NUMERIC_LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_OperatorUnspecified
 *        If the match type is unspecified, it is treated as a REGEXP. (Value:
 *        "OPERATOR_UNSPECIFIED")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Partial
 *        Substring match. (Value: "PARTIAL")
 *    @arg @c kGTLRAnalyticsReporting_SegmentDimensionFilter_OperatorProperty_Regexp
 *        The match expression is treated as a regular expression. All other
 *        match
 *        types are not treated as regular expressions. (Value: "REGEXP")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(copy, nullable) NSString *operatorProperty;

@end


/**
 *  SegmentFilter defines the segment to be either a simple or a sequence
 *  segment. A simple segment condition contains dimension and metric conditions
 *  to select the sessions or users. A sequence segment condition can be used to
 *  select users or sessions based on sequential conditions.
 */
@interface GTLRAnalyticsReporting_SegmentFilter : GTLRObject

/**
 *  If true, match the complement of simple or sequence segment.
 *  For example, to match all visits not from "New York", we can define the
 *  segment as follows:
 *  "sessionSegment": {
 *  "segmentFilters": [{
 *  "simpleSegment" :{
 *  "orFiltersForSegment": [{
 *  "segmentFilterClauses":[{
 *  "dimensionFilter": {
 *  "dimensionName": "ga:city",
 *  "expressions": ["New York"]
 *  }
 *  }]
 *  }]
 *  },
 *  "not": "True"
 *  }]
 *  },
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *notProperty;

/**
 *  Sequence conditions consist of one or more steps, where each step is
 *  defined by one or more dimension/metric conditions. Multiple steps can
 *  be combined with special sequence operators.
 */
@property(strong, nullable) GTLRAnalyticsReporting_SequenceSegment *sequenceSegment;

/**
 *  A Simple segment conditions consist of one or more dimension/metric
 *  conditions that can be combined
 */
@property(strong, nullable) GTLRAnalyticsReporting_SimpleSegment *simpleSegment;

@end


/**
 *  Filter Clause to be used in a segment definition, can be wither a metric or
 *  a dimension filter.
 */
@interface GTLRAnalyticsReporting_SegmentFilterClause : GTLRObject

/** Dimension Filter for the segment definition. */
@property(strong, nullable) GTLRAnalyticsReporting_SegmentDimensionFilter *dimensionFilter;

/** Metric Filter for the segment definition. */
@property(strong, nullable) GTLRAnalyticsReporting_SegmentMetricFilter *metricFilter;

/**
 *  Matches the complement (`!`) of the filter.
 *
 *  Remapped to 'notProperty' to avoid language reserved word 'not'.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *notProperty;

@end


/**
 *  Metric filter to be used in a segment filter clause.
 */
@interface GTLRAnalyticsReporting_SegmentMetricFilter : GTLRObject

/**
 *  The value to compare against. If the operator is `BETWEEN`, this value is
 *  treated as minimum comparison value.
 */
@property(copy, nullable) NSString *comparisonValue;

/** Max comparison value is only used for BETWEEN operator. */
@property(copy, nullable) NSString *maxComparisonValue;

/**
 *  The metric that will be filtered on. A `metricFilter` must contain a
 *  metric name.
 */
@property(copy, nullable) NSString *metricName;

/**
 *  Specifies is the operation to perform to compare the metric. The default
 *  is `EQUAL`.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Between
 *        For between operator, both the minimum and maximum are exclusive.
 *        We will use `LT` and `GT` for comparison. (Value: "BETWEEN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_Equal
 *        Equals operator. (Value: "EQUAL")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_GreaterThan
 *        Checks if the metric value is greater than comparison value. (Value:
 *        "GREATER_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_LessThan
 *        Checks if the metric value is less than comparison value. (Value:
 *        "LESS_THAN")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_OperatorProperty_UnspecifiedOperator
 *        Unspecified operator is treated as `LESS_THAN` operator. (Value:
 *        "UNSPECIFIED_OPERATOR")
 *
 *  Remapped to 'operatorProperty' to avoid language reserved word 'operator'.
 */
@property(copy, nullable) NSString *operatorProperty;

/**
 *  Scope for a metric defines the level at which that metric is defined. The
 *  specified metric scope must be equal to or greater than its primary scope
 *  as defined in the data model. The primary scope is defined by if the
 *  segment is selecting users or sessions.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Hit Hit scope.
 *        (Value: "HIT")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Product Product
 *        scope. (Value: "PRODUCT")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_Session Session
 *        scope. (Value: "SESSION")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_UnspecifiedScope
 *        If the scope is unspecified, it defaults to the condition scope,
 *        `USER` or `SESSION` depending on if the segment is trying to choose
 *        users or sessions. (Value: "UNSPECIFIED_SCOPE")
 *    @arg @c kGTLRAnalyticsReporting_SegmentMetricFilter_Scope_User User scope.
 *        (Value: "USER")
 */
@property(copy, nullable) NSString *scope;

@end


/**
 *  A segment sequence definition.
 */
@interface GTLRAnalyticsReporting_SegmentSequenceStep : GTLRObject

/**
 *  Specifies if the step immediately precedes or can be any time before the
 *  next step.
 *
 *  Likely values:
 *    @arg @c kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_ImmediatelyPrecedes
 *        Operator indicates that the previous step immediately precedes the
 *        next
 *        step. (Value: "IMMEDIATELY_PRECEDES")
 *    @arg @c kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_Precedes
 *        Operator indicates that the previous step precedes the next step.
 *        (Value: "PRECEDES")
 *    @arg @c kGTLRAnalyticsReporting_SegmentSequenceStep_MatchType_UnspecifiedMatchType
 *        Unspecified match type is treated as precedes. (Value:
 *        "UNSPECIFIED_MATCH_TYPE")
 */
@property(copy, nullable) NSString *matchType;

/**
 *  A sequence is specified with a list of Or grouped filters which are
 *  combined with `AND` operator.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_OrFiltersForSegment *> *orFiltersForSegment;

@end


/**
 *  Sequence conditions consist of one or more steps, where each step is defined
 *  by one or more dimension/metric conditions. Multiple steps can be combined
 *  with special sequence operators.
 */
@interface GTLRAnalyticsReporting_SequenceSegment : GTLRObject

/**
 *  If set, first step condition must match the first hit of the visitor (in
 *  the date range).
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *firstStepShouldMatchFirstHit;

/** The list of steps in the sequence. */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_SegmentSequenceStep *> *segmentSequenceSteps;

@end


/**
 *  A Simple segment conditions consist of one or more dimension/metric
 *  conditions that can be combined.
 */
@interface GTLRAnalyticsReporting_SimpleSegment : GTLRObject

/**
 *  A list of segment filters groups which are combined with logical `AND`
 *  operator.
 */
@property(strong, nullable) NSArray<GTLRAnalyticsReporting_OrFiltersForSegment *> *orFiltersForSegment;

@end

NS_ASSUME_NONNULL_END
