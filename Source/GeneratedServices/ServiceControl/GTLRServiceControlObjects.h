// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Service Control API (servicecontrol/v1)
// Description:
//   Google Service Control provides control plane functionality to managed
//   services, such as logging, monitoring, and status checks.
// Documentation:
//   https://cloud.google.com/service-control/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRServiceControl_AuditLog_Request;
@class GTLRServiceControl_AuditLog_Response;
@class GTLRServiceControl_AuditLog_ServiceData;
@class GTLRServiceControl_AuthenticationInfo;
@class GTLRServiceControl_AuthorizationInfo;
@class GTLRServiceControl_CheckError;
@class GTLRServiceControl_CheckInfo;
@class GTLRServiceControl_ConsumerInfo;
@class GTLRServiceControl_Distribution;
@class GTLRServiceControl_ExplicitBuckets;
@class GTLRServiceControl_ExponentialBuckets;
@class GTLRServiceControl_LinearBuckets;
@class GTLRServiceControl_LogEntry;
@class GTLRServiceControl_LogEntry_Labels;
@class GTLRServiceControl_LogEntry_ProtoPayload;
@class GTLRServiceControl_LogEntry_StructPayload;
@class GTLRServiceControl_MetricValue;
@class GTLRServiceControl_MetricValue_Labels;
@class GTLRServiceControl_MetricValueSet;
@class GTLRServiceControl_Money;
@class GTLRServiceControl_Operation;
@class GTLRServiceControl_Operation_Labels;
@class GTLRServiceControl_Operation_UserLabels;
@class GTLRServiceControl_QuotaError;
@class GTLRServiceControl_QuotaInfo;
@class GTLRServiceControl_QuotaInfo_QuotaConsumed;
@class GTLRServiceControl_QuotaOperation;
@class GTLRServiceControl_QuotaOperation_Labels;
@class GTLRServiceControl_QuotaProperties;
@class GTLRServiceControl_QuotaProperties_LimitByIds;
@class GTLRServiceControl_ReportError;
@class GTLRServiceControl_ReportInfo;
@class GTLRServiceControl_RequestMetadata;
@class GTLRServiceControl_Status;
@class GTLRServiceControl_Status_Details_Item;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRServiceControl_AllocateQuotaRequest.allocationMode

/**
 *  Allocates quota for the amount specified in the service configuration or
 *  specified using the quota_metrics. If the amount is higher than the
 *  available quota, request does not fail but all available quota will be
 *  allocated.
 *
 *  Value: "BEST_EFFORT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_BestEffort;
/**
 *  Only checks if there is enough quota available and does not change the
 *  available quota. No lock is placed on the available quota either.
 *
 *  Value: "CHECK_ONLY"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_CheckOnly;
/**
 *  Allocates quota for the amount specified in the service configuration or
 *  specified using the quota_metrics. If the amount is higher than the
 *  available quota, allocation error will be returned and no quota will be
 *  allocated.
 *
 *  Value: "NORMAL"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_Normal;
/** Value: "UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_Unspecified;

// ----------------------------------------------------------------------------
// GTLRServiceControl_CheckError.code

/**
 *  The consumer has been flagged as an abuser.
 *
 *  Value: "ABUSER_DETECTED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_AbuserDetected;
/**
 *  The consumer's API Key has expired.
 *
 *  Value: "API_KEY_EXPIRED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiKeyExpired;
/**
 *  The consumer's API key is invalid.
 *
 *  Value: "API_KEY_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiKeyInvalid;
/**
 *  The consumer's API Key was not found in config record.
 *
 *  Value: "API_KEY_NOT_FOUND"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiKeyNotFound;
/**
 *  The API targeted by this request is invalid for the specified consumer
 *  project.
 *
 *  Value: "API_TARGET_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiTargetBlocked;
/**
 *  The consumer cannot access the service because billing is disabled.
 *
 *  Value: "BILLING_DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_BillingDisabled;
/**
 *  The backend server for checking billing status is unavailable.
 *
 *  Value: "BILLING_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_BillingStatusUnavailable;
/**
 *  Budget check failed.
 *
 *  Value: "BUDGET_EXCEEDED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_BudgetExceeded;
/**
 *  The client application of the consumer request is invalid for the
 *  specific consumer project.
 *
 *  Value: "CLIENT_APP_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ClientAppBlocked;
/**
 *  Cloud Resource Manager backend server is unavailable.
 *
 *  Value: "CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_CloudResourceManagerBackendUnavailable;
/**
 *  The consumer's request has been flagged as a DoS attack.
 *
 *  Value: "DENIAL_OF_SERVICE_DETECTED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_DenialOfServiceDetected;
/**
 *  This is never used in `CheckResponse`.
 *
 *  Value: "ERROR_CODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ErrorCodeUnspecified;
/**
 *  The IP address of the consumer is invalid for the specific consumer
 *  project.
 *
 *  Value: "IP_ADDRESS_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_IpAddressBlocked;
/**
 *  The consumer's request should be rejected in order to protect the service
 *  from being overloaded.
 *
 *  Value: "LOAD_SHEDDING"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_LoadShedding;
/**
 *  The consumer's LOAS project is not `ACTIVE` in LoquatV2.
 *
 *  Value: "LOAS_PROJECT_DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_LoasProjectDisabled;
/**
 *  The Spanner for looking up LOAS project is unavailable.
 *
 *  Value: "LOAS_PROJECT_LOOKUP_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_LoasProjectLookupUnavailable;
/**
 *  The consumer's LOAS role is invalid.
 *
 *  Value: "LOAS_ROLE_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_LoasRoleInvalid;
/**
 *  The backend server for looking up project id/number is unavailable.
 *
 *  Value: "NAMESPACE_LOOKUP_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_NamespaceLookupUnavailable;
/**
 *  The consumer's LOAS role has no associated project.
 *
 *  Value: "NO_LOAS_PROJECT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_NoLoasProject;
/**
 *  The consumer's project id was not found.
 *  Same as google.rpc.Code.NOT_FOUND.
 *
 *  Value: "NOT_FOUND"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_NotFound;
/**
 *  The consumer doesn't have access to the specified resource.
 *  Same as google.rpc.Code.PERMISSION_DENIED.
 *
 *  Value: "PERMISSION_DENIED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_PermissionDenied;
/**
 *  The consumer's project has been marked as deleted (soft deletion).
 *
 *  Value: "PROJECT_DELETED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ProjectDeleted;
/**
 *  The consumer's project number or id does not represent a valid project.
 *
 *  Value: "PROJECT_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ProjectInvalid;
/**
 *  The backend server for checking quota limits is unavailable.
 *
 *  Value: "QUOTA_CHECK_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_QuotaCheckUnavailable;
/**
 *  The referer address of the consumer request is invalid for the specific
 *  consumer project.
 *
 *  Value: "REFERER_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_RefererBlocked;
/**
 *  Quota check failed. Same as google.rpc.Code.RESOURCE_EXHAUSTED.
 *
 *  Value: "RESOURCE_EXHAUSTED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ResourceExhausted;
/**
 *  Backend server for evaluating security policy is unavailable.
 *
 *  Value: "SECURITY_POLICY_BACKEND_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_SecurityPolicyBackendUnavailable;
/**
 *  Request is not allowed as per security policies defined in Org Policy.
 *
 *  Value: "SECURITY_POLICY_VIOLATED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_SecurityPolicyViolated;
/**
 *  The consumer hasn't activated the service.
 *
 *  Value: "SERVICE_NOT_ACTIVATED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ServiceNotActivated;
/**
 *  The backend server for checking service status is unavailable.
 *
 *  Value: "SERVICE_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ServiceStatusUnavailable;
/**
 *  The consumer's spatula header is invalid.
 *
 *  Value: "SPATULA_HEADER_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_SpatulaHeaderInvalid;
/**
 *  The consumer cannot access the service due to visibility configuration.
 *
 *  Value: "VISIBILITY_DENIED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_VisibilityDenied;

// ----------------------------------------------------------------------------
// GTLRServiceControl_LogEntry.severity

/**
 *  (700) A person must take an action immediately.
 *
 *  Value: "ALERT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Alert;
/**
 *  (600) Critical events cause more severe problems or outages.
 *
 *  Value: "CRITICAL"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Critical;
/**
 *  (100) Debug or trace information.
 *
 *  Value: "DEBUG"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Debug;
/**
 *  (0) The log entry has no assigned severity level.
 *
 *  Value: "DEFAULT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Default;
/**
 *  (800) One or more systems are unusable.
 *
 *  Value: "EMERGENCY"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Emergency;
/**
 *  (500) Error events are likely to cause problems.
 *
 *  Value: "ERROR"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Error;
/**
 *  (200) Routine information, such as ongoing status or performance.
 *
 *  Value: "INFO"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Info;
/**
 *  (300) Normal but significant events, such as start up, shut down, or
 *  a configuration change.
 *
 *  Value: "NOTICE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Notice;
/**
 *  (400) Warning events might cause problems.
 *
 *  Value: "WARNING"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRServiceControl_Operation.importance

/**
 *  In addition to the behavior described in HIGH, DEBUG enables
 *  additional validation logic that is only useful during the onboarding
 *  process. This is only available to Google internal services and
 *  the service must be whitelisted by chemist-dev\@google.com in order
 *  to use this level.
 *
 *  Value: "DEBUG"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_Operation_Importance_Debug;
/**
 *  The API implementation doesn't cache and aggregate the data.
 *  If the method returns successfully, it's guaranteed that the data has
 *  been persisted in durable storage.
 *
 *  Value: "HIGH"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_Operation_Importance_High;
/**
 *  The API implementation may cache and aggregate the data.
 *  The data may be lost when rare and unexpected system failures occur.
 *
 *  Value: "LOW"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_Operation_Importance_Low;

// ----------------------------------------------------------------------------
// GTLRServiceControl_QuotaError.code

/**
 *  Specified API Key has expired.
 *
 *  Value: "API_KEY_EXPIRED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_ApiKeyExpired;
/**
 *  Specified API key is invalid.
 *
 *  Value: "API_KEY_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_ApiKeyInvalid;
/**
 *  Consumer cannot access the service because the service requires active
 *  billing.
 *
 *  Value: "BILLING_NOT_ACTIVE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_BillingNotActive;
/**
 *  The backend server for checking billing status is unavailable.
 *
 *  Value: "BILLING_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_BillingStatusUnavailable;
/**
 *  The consumer's LOAS role is invalid.
 *
 *  Value: "LOAS_ROLE_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_LoasRoleInvalid;
/**
 *  The consumer's LOAS role has no associated project.
 *
 *  Value: "NO_LOAS_PROJECT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_NoLoasProject;
/**
 *  Quota release failed. This error is ONLY returned on a NORMAL release.
 *  More formally: if a user requests a release of 10 tokens, but only
 *  5 tokens were previously allocated, in a BEST_EFFORT release, this will
 *  be considered a success, 5 tokens will be released, and the result will
 *  be "Ok". If this is done in NORMAL mode, no tokens will be released,
 *  and an OUT_OF_RANGE error will be returned.
 *  Same as google.rpc.Code.OUT_OF_RANGE.
 *
 *  Value: "OUT_OF_RANGE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_OutOfRange;
/**
 *  Consumer's project has been marked as deleted (soft deletion).
 *
 *  Value: "PROJECT_DELETED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_ProjectDeleted;
/**
 *  The backend server for looking up project id/number is unavailable.
 *
 *  Value: "PROJECT_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_ProjectStatusUnavailable;
/**
 *  The backend server for checking quota limits is unavailable.
 *
 *  Value: "QUOTA_SYSTEM_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_QuotaSystemUnavailable;
/**
 *  Quota allocation failed.
 *  Same as google.rpc.Code.RESOURCE_EXHAUSTED.
 *
 *  Value: "RESOURCE_EXHAUSTED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_ResourceExhausted;
/**
 *  The backend server for checking service status is unavailable.
 *
 *  Value: "SERVICE_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_ServiceStatusUnavailable;
/**
 *  Consumer's spatula header is invalid.
 *
 *  Value: "SPATULA_HEADER_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_SpatulaHeaderInvalid;
/**
 *  This is never used.
 *
 *  Value: "UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaError_Code_Unspecified;

// ----------------------------------------------------------------------------
// GTLRServiceControl_QuotaOperation.quotaMode

/**
 *  For AllocateQuota request, this mode is supported only for imprecise
 *  quota limits. In this case, the operation allocates quota for the amount
 *  specified in the service configuration or specified using the quota
 *  metrics. If the amount is higher than the available quota, request does
 *  not fail but all available quota will be allocated.
 *  For ReleaseQuota request, this mode is supported for both precise quota
 *  limits and imprecise quota limits. In this case, this operation releases
 *  quota for the amount specified in the service configuration or specified
 *  using the quota metrics. If the release can make used quota
 *  negative, request does not fail but only the used quota will be
 *  released. After the ReleaseQuota request completes, the used quota
 *  will be 0, and never goes to negative.
 *
 *  Value: "BEST_EFFORT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaOperation_QuotaMode_BestEffort;
/**
 *  For AllocateQuota request, only checks if there is enough quota
 *  available and does not change the available quota. No lock is placed on
 *  the available quota either. Not supported for ReleaseQuota request.
 *
 *  Value: "CHECK_ONLY"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaOperation_QuotaMode_CheckOnly;
/**
 *  For AllocateQuota request, allocates quota for the amount specified in
 *  the service configuration or specified using the quota metrics. If the
 *  amount is higher than the available quota, allocation error will be
 *  returned and no quota will be allocated.
 *  For ReleaseQuota request, this mode is supported only for precise quota
 *  limits. In this case, this operation releases quota for the amount
 *  specified in the service configuration or specified using the quota
 *  metrics. If the release can make used quota negative, release error
 *  will be returned and no quota will be released.
 *
 *  Value: "NORMAL"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaOperation_QuotaMode_Normal;
/** Value: "UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaOperation_QuotaMode_Unspecified;

// ----------------------------------------------------------------------------
// GTLRServiceControl_QuotaProperties.quotaMode

/**
 *  Decreases available quota by the cost specified for the operation.
 *  If cost is higher than available quota, operation fails and returns
 *  error.
 *
 *  Value: "ACQUIRE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaProperties_QuotaMode_Acquire;
/**
 *  Decreases available quota by the cost specified for the operation.
 *  If cost is higher than available quota, operation does not fail and
 *  available quota goes down to zero but it returns error.
 *
 *  Value: "ACQUIRE_BEST_EFFORT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaProperties_QuotaMode_AcquireBestEffort;
/**
 *  Does not change any available quota. Only checks if there is enough
 *  quota.
 *  No lock is placed on the checked tokens neither.
 *
 *  Value: "CHECK"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaProperties_QuotaMode_Check;
/**
 *  Increases available quota by the operation cost specified for the
 *  operation.
 *
 *  Value: "RELEASE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_QuotaProperties_QuotaMode_Release;

/**
 *  Request message for the AllocateQuota method.
 */
@interface GTLRServiceControl_AllocateQuotaRequest : GTLRObject

/** Operation that describes the quota allocation. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaOperation *allocateOperation;

/**
 *  Allocation mode for this operation.
 *  Deprecated: use QuotaMode inside the QuotaOperation.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_BestEffort
 *        Allocates quota for the amount specified in the service configuration
 *        or
 *        specified using the quota_metrics. If the amount is higher than the
 *        available quota, request does not fail but all available quota will be
 *        allocated. (Value: "BEST_EFFORT")
 *    @arg @c kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_CheckOnly
 *        Only checks if there is enough quota available and does not change the
 *        available quota. No lock is placed on the available quota either.
 *        (Value: "CHECK_ONLY")
 *    @arg @c kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_Normal
 *        Allocates quota for the amount specified in the service configuration
 *        or
 *        specified using the quota_metrics. If the amount is higher than the
 *        available quota, allocation error will be returned and no quota will
 *        be
 *        allocated. (Value: "NORMAL")
 *    @arg @c kGTLRServiceControl_AllocateQuotaRequest_AllocationMode_Unspecified
 *        Value "UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *allocationMode;

/**
 *  Specifies which version of service configuration should be used to process
 *  the request. If unspecified or no matching version can be found, the latest
 *  one will be used.
 */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Response message for the AllocateQuota method.
 */
@interface GTLRServiceControl_AllocateQuotaResponse : GTLRObject

/** Indicates the decision of the allocate. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_QuotaError *> *allocateErrors;

/**
 *  The same operation_id value used in the AllocateQuotaRequest. Used for
 *  logging and diagnostics purposes.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/**
 *  Quota metrics to indicate the result of allocation. Depending on the
 *  request, one or more of the following metrics will be included:
 *  1. For rate quota, per quota group or per quota metric incremental usage
 *  will be specified using the following delta metric:
 *  "serviceruntime.googleapis.com/api/consumer/quota_used_count"
 *  2. For allocation quota, per quota metric total usage will be specified
 *  using the following gauge metric:
 *  "serviceruntime.googleapis.com/allocation/consumer/quota_used_count"
 *  3. For both rate quota and allocation quota, the quota limit reached
 *  condition will be specified using the following boolean metric:
 *  "serviceruntime.googleapis.com/quota/exceeded"
 *  4. For allocation quota, value for each quota limit associated with
 *  the metrics will be specified using the following gauge metric:
 *  "serviceruntime.googleapis.com/quota/limit"
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *quotaMetrics;

/** ID of the actual config used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Common audit log format for Google Cloud Platform API operations.
 */
@interface GTLRServiceControl_AuditLog : GTLRObject

/** Authentication information. */
@property(nonatomic, strong, nullable) GTLRServiceControl_AuthenticationInfo *authenticationInfo;

/**
 *  Authorization information. If there are multiple
 *  resources or permissions involved, then there is
 *  one AuthorizationInfo element for each {resource, permission} tuple.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_AuthorizationInfo *> *authorizationInfo;

/**
 *  The name of the service method or operation.
 *  For API calls, this should be the name of the API method.
 *  For example,
 *  "google.datastore.v1.Datastore.RunQuery"
 *  "google.logging.v1.LoggingService.DeleteLog"
 */
@property(nonatomic, copy, nullable) NSString *methodName;

/**
 *  The number of items returned from a List or Query API method,
 *  if applicable.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numResponseItems;

/**
 *  The operation request. This may not include all request parameters,
 *  such as those that are too large, privacy-sensitive, or duplicated
 *  elsewhere in the log record.
 *  It should never include user-generated data, such as file contents.
 *  When the JSON object represented here has a proto equivalent, the proto
 *  name will be indicated in the `\@type` property.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_AuditLog_Request *request;

/** Metadata about the operation. */
@property(nonatomic, strong, nullable) GTLRServiceControl_RequestMetadata *requestMetadata;

/**
 *  The resource or collection that is the target of the operation.
 *  The name is a scheme-less URI, not including the API service name.
 *  For example:
 *  "shelves/SHELF_ID/books"
 *  "shelves/SHELF_ID/books/BOOK_ID"
 */
@property(nonatomic, copy, nullable) NSString *resourceName;

/**
 *  The operation response. This may not include all response elements,
 *  such as those that are too large, privacy-sensitive, or duplicated
 *  elsewhere in the log record.
 *  It should never include user-generated data, such as file contents.
 *  When the JSON object represented here has a proto equivalent, the proto
 *  name will be indicated in the `\@type` property.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_AuditLog_Response *response;

/**
 *  Other service-specific data about the request, response, and other
 *  activities.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_AuditLog_ServiceData *serviceData;

/**
 *  The name of the API service performing the operation. For example,
 *  `"datastore.googleapis.com"`.
 */
@property(nonatomic, copy, nullable) NSString *serviceName;

/** The status of the overall operation. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Status *status;

@end


/**
 *  The operation request. This may not include all request parameters,
 *  such as those that are too large, privacy-sensitive, or duplicated
 *  elsewhere in the log record.
 *  It should never include user-generated data, such as file contents.
 *  When the JSON object represented here has a proto equivalent, the proto
 *  name will be indicated in the `\@type` property.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_AuditLog_Request : GTLRObject
@end


/**
 *  The operation response. This may not include all response elements,
 *  such as those that are too large, privacy-sensitive, or duplicated
 *  elsewhere in the log record.
 *  It should never include user-generated data, such as file contents.
 *  When the JSON object represented here has a proto equivalent, the proto
 *  name will be indicated in the `\@type` property.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_AuditLog_Response : GTLRObject
@end


/**
 *  Other service-specific data about the request, response, and other
 *  activities.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_AuditLog_ServiceData : GTLRObject
@end


/**
 *  Authentication information for the operation.
 */
@interface GTLRServiceControl_AuthenticationInfo : GTLRObject

/**
 *  The authority selector specified by the requestor, if any.
 *  It is not guaranteed that the principal was allowed to use this authority.
 */
@property(nonatomic, copy, nullable) NSString *authoritySelector;

/** The email address of the authenticated user making the request. */
@property(nonatomic, copy, nullable) NSString *principalEmail;

@end


/**
 *  Authorization information for the operation.
 */
@interface GTLRServiceControl_AuthorizationInfo : GTLRObject

/**
 *  Whether or not authorization for `resource` and `permission`
 *  was granted.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *granted;

/** The required IAM permission. */
@property(nonatomic, copy, nullable) NSString *permission;

/**
 *  The resource being accessed, as a REST-style string. For example:
 *  bigquery.googleapis.com/projects/PROJECTID/datasets/DATASETID
 */
@property(nonatomic, copy, nullable) NSString *resource;

@end


/**
 *  Defines the errors to be returned in
 *  google.api.servicecontrol.v1.CheckResponse.check_errors.
 */
@interface GTLRServiceControl_CheckError : GTLRObject

/**
 *  The error code.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_CheckError_Code_AbuserDetected The consumer
 *        has been flagged as an abuser. (Value: "ABUSER_DETECTED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiKeyExpired The consumer's
 *        API Key has expired. (Value: "API_KEY_EXPIRED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiKeyInvalid The consumer's
 *        API key is invalid. (Value: "API_KEY_INVALID")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiKeyNotFound The consumer's
 *        API Key was not found in config record. (Value: "API_KEY_NOT_FOUND")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiTargetBlocked The API
 *        targeted by this request is invalid for the specified consumer
 *        project. (Value: "API_TARGET_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_BillingDisabled The consumer
 *        cannot access the service because billing is disabled. (Value:
 *        "BILLING_DISABLED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_BillingStatusUnavailable The
 *        backend server for checking billing status is unavailable. (Value:
 *        "BILLING_STATUS_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_BudgetExceeded Budget check
 *        failed. (Value: "BUDGET_EXCEEDED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ClientAppBlocked The client
 *        application of the consumer request is invalid for the
 *        specific consumer project. (Value: "CLIENT_APP_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_CloudResourceManagerBackendUnavailable
 *        Cloud Resource Manager backend server is unavailable. (Value:
 *        "CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_DenialOfServiceDetected The
 *        consumer's request has been flagged as a DoS attack. (Value:
 *        "DENIAL_OF_SERVICE_DETECTED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ErrorCodeUnspecified This is
 *        never used in `CheckResponse`. (Value: "ERROR_CODE_UNSPECIFIED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_IpAddressBlocked The IP
 *        address of the consumer is invalid for the specific consumer
 *        project. (Value: "IP_ADDRESS_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_LoadShedding The consumer's
 *        request should be rejected in order to protect the service
 *        from being overloaded. (Value: "LOAD_SHEDDING")
 *    @arg @c kGTLRServiceControl_CheckError_Code_LoasProjectDisabled The
 *        consumer's LOAS project is not `ACTIVE` in LoquatV2. (Value:
 *        "LOAS_PROJECT_DISABLED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_LoasProjectLookupUnavailable
 *        The Spanner for looking up LOAS project is unavailable. (Value:
 *        "LOAS_PROJECT_LOOKUP_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_LoasRoleInvalid The consumer's
 *        LOAS role is invalid. (Value: "LOAS_ROLE_INVALID")
 *    @arg @c kGTLRServiceControl_CheckError_Code_NamespaceLookupUnavailable The
 *        backend server for looking up project id/number is unavailable.
 *        (Value: "NAMESPACE_LOOKUP_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_NoLoasProject The consumer's
 *        LOAS role has no associated project. (Value: "NO_LOAS_PROJECT")
 *    @arg @c kGTLRServiceControl_CheckError_Code_NotFound The consumer's
 *        project id was not found.
 *        Same as google.rpc.Code.NOT_FOUND. (Value: "NOT_FOUND")
 *    @arg @c kGTLRServiceControl_CheckError_Code_PermissionDenied The consumer
 *        doesn't have access to the specified resource.
 *        Same as google.rpc.Code.PERMISSION_DENIED. (Value:
 *        "PERMISSION_DENIED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ProjectDeleted The consumer's
 *        project has been marked as deleted (soft deletion). (Value:
 *        "PROJECT_DELETED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ProjectInvalid The consumer's
 *        project number or id does not represent a valid project. (Value:
 *        "PROJECT_INVALID")
 *    @arg @c kGTLRServiceControl_CheckError_Code_QuotaCheckUnavailable The
 *        backend server for checking quota limits is unavailable. (Value:
 *        "QUOTA_CHECK_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_RefererBlocked The referer
 *        address of the consumer request is invalid for the specific
 *        consumer project. (Value: "REFERER_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ResourceExhausted Quota check
 *        failed. Same as google.rpc.Code.RESOURCE_EXHAUSTED. (Value:
 *        "RESOURCE_EXHAUSTED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_SecurityPolicyBackendUnavailable
 *        Backend server for evaluating security policy is unavailable. (Value:
 *        "SECURITY_POLICY_BACKEND_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_SecurityPolicyViolated Request
 *        is not allowed as per security policies defined in Org Policy. (Value:
 *        "SECURITY_POLICY_VIOLATED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ServiceNotActivated The
 *        consumer hasn't activated the service. (Value:
 *        "SERVICE_NOT_ACTIVATED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ServiceStatusUnavailable The
 *        backend server for checking service status is unavailable. (Value:
 *        "SERVICE_STATUS_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_SpatulaHeaderInvalid The
 *        consumer's spatula header is invalid. (Value:
 *        "SPATULA_HEADER_INVALID")
 *    @arg @c kGTLRServiceControl_CheckError_Code_VisibilityDenied The consumer
 *        cannot access the service due to visibility configuration. (Value:
 *        "VISIBILITY_DENIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** Free-form text providing details on the error cause of the error. */
@property(nonatomic, copy, nullable) NSString *detail;

@end


/**
 *  GTLRServiceControl_CheckInfo
 */
@interface GTLRServiceControl_CheckInfo : GTLRObject

/** Consumer info of this check. */
@property(nonatomic, strong, nullable) GTLRServiceControl_ConsumerInfo *consumerInfo;

/**
 *  A list of fields and label keys that are ignored by the server.
 *  The client doesn't need to send them for following requests to improve
 *  performance and allow better aggregation.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unusedArguments;

@end


/**
 *  Request message for the Check method.
 */
@interface GTLRServiceControl_CheckRequest : GTLRObject

/** The operation to be checked. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Operation *operation;

/**
 *  Requests the project settings to be returned as part of the check response.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *requestProjectSettings;

/**
 *  Specifies which version of service configuration should be used to process
 *  the request.
 *  If unspecified or no matching version can be found, the
 *  latest one will be used.
 */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

/**
 *  Indicates if service activation check should be skipped for this request.
 *  Default behavior is to perform the check and apply relevant quota.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *skipActivationCheck;

@end


/**
 *  Response message for the Check method.
 */
@interface GTLRServiceControl_CheckResponse : GTLRObject

/**
 *  Indicate the decision of the check.
 *  If no check errors are present, the service should process the operation.
 *  Otherwise the service should use the list of errors to determine the
 *  appropriate action.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_CheckError *> *checkErrors;

/**
 *  Feedback data returned from the server during processing a Check request.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_CheckInfo *checkInfo;

/**
 *  The same operation_id value used in the CheckRequest.
 *  Used for logging and diagnostics purposes.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Quota information for the check request associated with this response. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaInfo *quotaInfo;

/** The actual config id used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  `ConsumerInfo` provides information about the consumer project.
 */
@interface GTLRServiceControl_ConsumerInfo : GTLRObject

/**
 *  The Google cloud project number, e.g. 1234567890. A value of 0 indicates
 *  no project number is found.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *projectNumber;

@end


/**
 *  Distribution represents a frequency distribution of double-valued sample
 *  points. It contains the size of the population of sample points plus
 *  additional optional information:
 *  - the arithmetic mean of the samples
 *  - the minimum and maximum of the samples
 *  - the sum-squared-deviation of the samples, used to compute variance
 *  - a histogram of the values of the sample points
 */
@interface GTLRServiceControl_Distribution : GTLRObject

/**
 *  The number of samples in each histogram bucket. `bucket_counts` are
 *  optional. If present, they must sum to the `count` value.
 *  The buckets are defined below in `bucket_option`. There are N buckets.
 *  `bucket_counts[0]` is the number of samples in the underflow bucket.
 *  `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
 *  in each of the finite buckets. And `bucket_counts[N] is the number
 *  of samples in the overflow bucket. See the comments of `bucket_option`
 *  below for more details.
 *  Any suffix of trailing zeros may be omitted.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  The total number of samples in the distribution. Must be >= 0.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/** Buckets with arbitrary user-provided width. */
@property(nonatomic, strong, nullable) GTLRServiceControl_ExplicitBuckets *explicitBuckets;

/** Buckets with exponentially growing width. */
@property(nonatomic, strong, nullable) GTLRServiceControl_ExponentialBuckets *exponentialBuckets;

/** Buckets with constant width. */
@property(nonatomic, strong, nullable) GTLRServiceControl_LinearBuckets *linearBuckets;

/**
 *  The maximum of the population of values. Ignored if `count` is zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximum;

/**
 *  The arithmetic mean of the samples in the distribution. If `count` is
 *  zero then this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  The minimum of the population of values. Ignored if `count` is zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimum;

/**
 *  The sum of squared deviations from the mean:
 *  Sum[i=1..count]((x_i - mean)^2)
 *  where each x_i is a sample values. If `count` is zero then this field
 *  must be zero, otherwise validation of the request fails.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  GTLRServiceControl_EndReconciliationRequest
 */
@interface GTLRServiceControl_EndReconciliationRequest : GTLRObject

/** Operation that describes the quota reconciliation. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaOperation *reconciliationOperation;

/**
 *  Specifies which version of service configuration should be used to process
 *  the request. If unspecified or no matching version can be found, the latest
 *  one will be used.
 */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  GTLRServiceControl_EndReconciliationResponse
 */
@interface GTLRServiceControl_EndReconciliationResponse : GTLRObject

/**
 *  The same operation_id value used in the EndReconciliationRequest. Used for
 *  logging and diagnostics purposes.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/**
 *  Metric values as tracked by One Platform before the adjustment was made.
 *  The following metrics will be included:
 *  1. Per quota metric total usage will be specified using the following gauge
 *  metric:
 *  "serviceruntime.googleapis.com/allocation/consumer/quota_used_count"
 *  2. Value for each quota limit associated with the metrics will be specified
 *  using the following gauge metric:
 *  "serviceruntime.googleapis.com/quota/limit"
 *  3. Delta value of the usage after the reconciliation for limits associated
 *  with the metrics will be specified using the following metric:
 *  "serviceruntime.googleapis.com/allocation/reconciliation_delta"
 *  The delta value is defined as:
 *  new_usage_from_client - existing_value_in_spanner.
 *  This metric is not defined in serviceruntime.yaml or in Cloud Monarch.
 *  This metric is meant for callers' use only. Since this metric is not
 *  defined in the monitoring backend, reporting on this metric will result in
 *  an error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *quotaMetrics;

/** Indicates the decision of the reconciliation end. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_QuotaError *> *reconciliationErrors;

/** ID of the actual config used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Describing buckets with arbitrary user-provided width.
 */
@interface GTLRServiceControl_ExplicitBuckets : GTLRObject

/**
 *  'bound' is a list of strictly increasing boundaries between
 *  buckets. Note that a list of length N-1 defines N buckets because
 *  of fenceposting. See comments on `bucket_options` for details.
 *  The i'th finite bucket covers the interval
 *  [bound[i-1], bound[i])
 *  where i ranges from 1 to bound_size() - 1. Note that there are no
 *  finite buckets at all if 'bound' only contains a single element; in
 *  that special case the single bound defines the boundary between the
 *  underflow and overflow buckets.
 *  bucket number lower bound upper bound
 *  i == 0 (underflow) -inf bound[i]
 *  0 < i < bound_size() bound[i-1] bound[i]
 *  i == bound_size() (overflow) bound[i-1] +inf
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Describing buckets with exponentially growing width.
 */
@interface GTLRServiceControl_ExponentialBuckets : GTLRObject

/**
 *  The i'th exponential bucket covers the interval
 *  [scale * growth_factor^(i-1), scale * growth_factor^i)
 *  where i ranges from 1 to num_finite_buckets inclusive.
 *  Must be larger than 1.0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  The number of finite buckets. With the underflow and overflow buckets,
 *  the total number of buckets is `num_finite_buckets` + 2.
 *  See comments on `bucket_options` for details.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  The i'th exponential bucket covers the interval
 *  [scale * growth_factor^(i-1), scale * growth_factor^i)
 *  where i ranges from 1 to num_finite_buckets inclusive.
 *  Must be > 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  Describing buckets with constant width.
 */
@interface GTLRServiceControl_LinearBuckets : GTLRObject

/**
 *  The number of finite buckets. With the underflow and overflow buckets,
 *  the total number of buckets is `num_finite_buckets` + 2.
 *  See comments on `bucket_options` for details.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  The i'th linear bucket covers the interval
 *  [offset + (i-1) * width, offset + i * width)
 *  where i ranges from 1 to num_finite_buckets, inclusive.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  The i'th linear bucket covers the interval
 *  [offset + (i-1) * width, offset + i * width)
 *  where i ranges from 1 to num_finite_buckets, inclusive.
 *  Must be strictly positive.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  An individual log entry.
 */
@interface GTLRServiceControl_LogEntry : GTLRObject

/**
 *  A unique ID for the log entry used for deduplication. If omitted,
 *  the implementation will generate one based on operation_id.
 */
@property(nonatomic, copy, nullable) NSString *insertId;

/**
 *  A set of user-defined (key, value) data that provides additional
 *  information about the log entry.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_LogEntry_Labels *labels;

/**
 *  Required. The log to which this log entry belongs. Examples: `"syslog"`,
 *  `"book_log"`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The log entry payload, represented as a protocol buffer that is
 *  expressed as a JSON object. You can only pass `protoPayload`
 *  values that belong to a set of approved types.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_LogEntry_ProtoPayload *protoPayload;

/**
 *  The severity of the log entry. The default value is
 *  `LogSeverity.DEFAULT`.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Alert (700) A person must
 *        take an action immediately. (Value: "ALERT")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Critical (600) Critical
 *        events cause more severe problems or outages. (Value: "CRITICAL")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Debug (100) Debug or trace
 *        information. (Value: "DEBUG")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Default (0) The log entry
 *        has no assigned severity level. (Value: "DEFAULT")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Emergency (800) One or more
 *        systems are unusable. (Value: "EMERGENCY")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Error (500) Error events are
 *        likely to cause problems. (Value: "ERROR")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Info (200) Routine
 *        information, such as ongoing status or performance. (Value: "INFO")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Notice (300) Normal but
 *        significant events, such as start up, shut down, or
 *        a configuration change. (Value: "NOTICE")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Warning (400) Warning events
 *        might cause problems. (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/**
 *  The log entry payload, represented as a structure that
 *  is expressed as a JSON object.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_LogEntry_StructPayload *structPayload;

/** The log entry payload, represented as a Unicode string (UTF-8). */
@property(nonatomic, copy, nullable) NSString *textPayload;

/**
 *  The time the event described by the log entry occurred. If
 *  omitted, defaults to operation start time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

@end


/**
 *  A set of user-defined (key, value) data that provides additional
 *  information about the log entry.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_LogEntry_Labels : GTLRObject
@end


/**
 *  The log entry payload, represented as a protocol buffer that is
 *  expressed as a JSON object. You can only pass `protoPayload`
 *  values that belong to a set of approved types.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_LogEntry_ProtoPayload : GTLRObject
@end


/**
 *  The log entry payload, represented as a structure that
 *  is expressed as a JSON object.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_LogEntry_StructPayload : GTLRObject
@end


/**
 *  Represents a single metric value.
 */
@interface GTLRServiceControl_MetricValue : GTLRObject

/**
 *  A boolean value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Distribution *distributionValue;

/**
 *  A double precision floating point value.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  The end of the time period over which this metric value's measurement
 *  applies.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  A signed 64-bit integer value.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/**
 *  The labels describing the metric value.
 *  See comments on google.api.servicecontrol.v1.Operation.labels for
 *  the overriding relationship.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_MetricValue_Labels *labels;

/** A money value. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Money *moneyValue;

/**
 *  The start of the time period over which this metric value's measurement
 *  applies. The time period has different semantics for different metric
 *  types (cumulative, delta, and gauge). See the metric definition
 *  documentation in the service configuration for details.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** A text string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  The labels describing the metric value.
 *  See comments on google.api.servicecontrol.v1.Operation.labels for
 *  the overriding relationship.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_MetricValue_Labels : GTLRObject
@end


/**
 *  Represents a set of metric values in the same metric.
 *  Each metric value in the set should have a unique combination of start time,
 *  end time, and label values.
 */
@interface GTLRServiceControl_MetricValueSet : GTLRObject

/** The metric name defined in the service configuration. */
@property(nonatomic, copy, nullable) NSString *metricName;

/** The values in this metric. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValue *> *metricValues;

@end


/**
 *  Represents an amount of money with its currency type.
 */
@interface GTLRServiceControl_Money : GTLRObject

/** The 3-letter currency code defined in ISO 4217. */
@property(nonatomic, copy, nullable) NSString *currencyCode;

/**
 *  Number of nano (10^-9) units of the amount.
 *  The value must be between -999,999,999 and +999,999,999 inclusive.
 *  If `units` is positive, `nanos` must be positive or zero.
 *  If `units` is zero, `nanos` can be positive, zero, or negative.
 *  If `units` is negative, `nanos` must be negative or zero.
 *  For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nanos;

/**
 *  The whole units of the amount.
 *  For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *units;

@end


/**
 *  Represents information regarding an operation.
 */
@interface GTLRServiceControl_Operation : GTLRObject

/**
 *  Identity of the consumer who is using the service.
 *  This field should be filled in for the operations initiated by a
 *  consumer, but not for service-initiated operations that are
 *  not related to a specific consumer.
 *  This can be in one of the following formats:
 *  project:<project_id>,
 *  project_number:<project_number>,
 *  api_key:<api_key>.
 */
@property(nonatomic, copy, nullable) NSString *consumerId;

/**
 *  End time of the operation.
 *  Required when the operation is used in ServiceController.Report,
 *  but optional when the operation is used in ServiceController.Check.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  DO NOT USE. This is an experimental field.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_Operation_Importance_Debug In addition to the
 *        behavior described in HIGH, DEBUG enables
 *        additional validation logic that is only useful during the onboarding
 *        process. This is only available to Google internal services and
 *        the service must be whitelisted by chemist-dev\@google.com in order
 *        to use this level. (Value: "DEBUG")
 *    @arg @c kGTLRServiceControl_Operation_Importance_High The API
 *        implementation doesn't cache and aggregate the data.
 *        If the method returns successfully, it's guaranteed that the data has
 *        been persisted in durable storage. (Value: "HIGH")
 *    @arg @c kGTLRServiceControl_Operation_Importance_Low The API
 *        implementation may cache and aggregate the data.
 *        The data may be lost when rare and unexpected system failures occur.
 *        (Value: "LOW")
 */
@property(nonatomic, copy, nullable) NSString *importance;

/**
 *  Labels describing the operation. Only the following labels are allowed:
 *  - Labels describing monitored resources as defined in
 *  the service configuration.
 *  - Default labels of metric values. When specified, labels defined in the
 *  metric value override these default.
 *  - The following labels defined by Google Cloud Platform:
 *  - `cloud.googleapis.com/location` describing the location where the
 *  operation happened,
 *  - `servicecontrol.googleapis.com/user_agent` describing the user agent
 *  of the API request,
 *  - `servicecontrol.googleapis.com/service_agent` describing the service
 *  used to handle the API request (e.g. ESP),
 *  - `servicecontrol.googleapis.com/platform` describing the platform
 *  where the API is served (e.g. GAE, GCE, GKE).
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_Operation_Labels *labels;

/** Represents information to be logged. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_LogEntry *> *logEntries;

/**
 *  Represents information about this operation. Each MetricValueSet
 *  corresponds to a metric defined in the service configuration.
 *  The data type used in the MetricValueSet must agree with
 *  the data type specified in the metric definition.
 *  Within a single operation, it is not allowed to have more than one
 *  MetricValue instances that have the same metric names and identical
 *  label value combinations. If a request has such duplicated MetricValue
 *  instances, the entire request is rejected with
 *  an invalid argument error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *metricValueSets;

/**
 *  Identity of the operation. This must be unique within the scope of the
 *  service that generated the operation. If the service calls
 *  Check() and Report() on the same operation, the two calls should carry
 *  the same id.
 *  UUID version 4 is recommended, though not required.
 *  In scenarios where an operation is computed from existing information
 *  and an idempotent id is desirable for deduplication purpose, UUID version 5
 *  is recommended. See RFC 4122 for details.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Fully qualified name of the operation. Reserved for future use. */
@property(nonatomic, copy, nullable) NSString *operationName;

/**
 *  Represents the properties needed for quota check. Applicable only if this
 *  operation is for a quota check request.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaProperties *quotaProperties;

/**
 *  The resource name of the parent of a resource in the resource hierarchy.
 *  This can be in one of the following formats:
 *  - projects/<project-id or project-number>
 *  - folders/<folder-id>
 *  - organizations/<organization-id>
 */
@property(nonatomic, copy, nullable) NSString *resourceContainer;

/** Required. Start time of the operation. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  User defined labels for the resource that this operation is associated
 *  with.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_Operation_UserLabels *userLabels;

@end


/**
 *  Labels describing the operation. Only the following labels are allowed:
 *  - Labels describing monitored resources as defined in
 *  the service configuration.
 *  - Default labels of metric values. When specified, labels defined in the
 *  metric value override these default.
 *  - The following labels defined by Google Cloud Platform:
 *  - `cloud.googleapis.com/location` describing the location where the
 *  operation happened,
 *  - `servicecontrol.googleapis.com/user_agent` describing the user agent
 *  of the API request,
 *  - `servicecontrol.googleapis.com/service_agent` describing the service
 *  used to handle the API request (e.g. ESP),
 *  - `servicecontrol.googleapis.com/platform` describing the platform
 *  where the API is served (e.g. GAE, GCE, GKE).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_Operation_Labels : GTLRObject
@end


/**
 *  User defined labels for the resource that this operation is associated
 *  with.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_Operation_UserLabels : GTLRObject
@end


/**
 *  GTLRServiceControl_QuotaError
 */
@interface GTLRServiceControl_QuotaError : GTLRObject

/**
 *  Error code.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_QuotaError_Code_ApiKeyExpired Specified API
 *        Key has expired. (Value: "API_KEY_EXPIRED")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_ApiKeyInvalid Specified API
 *        key is invalid. (Value: "API_KEY_INVALID")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_BillingNotActive Consumer
 *        cannot access the service because the service requires active
 *        billing. (Value: "BILLING_NOT_ACTIVE")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_BillingStatusUnavailable The
 *        backend server for checking billing status is unavailable. (Value:
 *        "BILLING_STATUS_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_LoasRoleInvalid The consumer's
 *        LOAS role is invalid. (Value: "LOAS_ROLE_INVALID")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_NoLoasProject The consumer's
 *        LOAS role has no associated project. (Value: "NO_LOAS_PROJECT")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_OutOfRange Quota release
 *        failed. This error is ONLY returned on a NORMAL release.
 *        More formally: if a user requests a release of 10 tokens, but only
 *        5 tokens were previously allocated, in a BEST_EFFORT release, this
 *        will
 *        be considered a success, 5 tokens will be released, and the result
 *        will
 *        be "Ok". If this is done in NORMAL mode, no tokens will be released,
 *        and an OUT_OF_RANGE error will be returned.
 *        Same as google.rpc.Code.OUT_OF_RANGE. (Value: "OUT_OF_RANGE")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_ProjectDeleted Consumer's
 *        project has been marked as deleted (soft deletion). (Value:
 *        "PROJECT_DELETED")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_ProjectStatusUnavailable The
 *        backend server for looking up project id/number is unavailable.
 *        (Value: "PROJECT_STATUS_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_QuotaSystemUnavailable The
 *        backend server for checking quota limits is unavailable. (Value:
 *        "QUOTA_SYSTEM_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_ResourceExhausted Quota
 *        allocation failed.
 *        Same as google.rpc.Code.RESOURCE_EXHAUSTED. (Value:
 *        "RESOURCE_EXHAUSTED")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_ServiceStatusUnavailable The
 *        backend server for checking service status is unavailable. (Value:
 *        "SERVICE_STATUS_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_SpatulaHeaderInvalid
 *        Consumer's spatula header is invalid. (Value:
 *        "SPATULA_HEADER_INVALID")
 *    @arg @c kGTLRServiceControl_QuotaError_Code_Unspecified This is never
 *        used. (Value: "UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Free-form text that provides details on the cause of the error.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Subject to whom this error applies. See the specific enum for more details
 *  on this field. For example, "clientip:<ip address of client>" or
 *  "project:<Google developer project id>".
 */
@property(nonatomic, copy, nullable) NSString *subject;

@end


/**
 *  Contains the quota information for a quota check response.
 */
@interface GTLRServiceControl_QuotaInfo : GTLRObject

/**
 *  Quota Metrics that have exceeded quota limits.
 *  For QuotaGroup-based quota, this is QuotaGroup.name
 *  For QuotaLimit-based quota, this is QuotaLimit.name
 *  See: google.api.Quota
 *  Deprecated: Use quota_metrics to get per quota group limit exceeded status.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *limitExceeded;

/**
 *  Map of quota group name to the actual number of tokens consumed. If the
 *  quota check was not successful, then this will not be populated due to no
 *  quota consumption.
 *  Deprecated: Use quota_metrics to get per quota group usage.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaInfo_QuotaConsumed *quotaConsumed;

/**
 *  Quota metrics to indicate the usage. Depending on the check request, one or
 *  more of the following metrics will be included:
 *  1. For rate quota, per quota group or per quota metric incremental usage
 *  will be specified using the following delta metric:
 *  "serviceruntime.googleapis.com/api/consumer/quota_used_count"
 *  2. For allocation quota, per quota metric total usage will be specified
 *  using the following gauge metric:
 *  "serviceruntime.googleapis.com/allocation/consumer/quota_used_count"
 *  3. For both rate quota and allocation quota, the quota limit reached
 *  condition will be specified using the following boolean metric:
 *  "serviceruntime.googleapis.com/quota/exceeded"
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *quotaMetrics;

@end


/**
 *  Map of quota group name to the actual number of tokens consumed. If the
 *  quota check was not successful, then this will not be populated due to no
 *  quota consumption.
 *  Deprecated: Use quota_metrics to get per quota group usage.
 *
 *  @note This class is documented as having more properties of NSNumber (Uses
 *        NSNumber of intValue.). Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_QuotaInfo_QuotaConsumed : GTLRObject
@end


/**
 *  Represents information regarding a quota operation.
 */
@interface GTLRServiceControl_QuotaOperation : GTLRObject

/**
 *  Identity of the consumer for whom this quota operation is being performed.
 *  This can be in one of the following formats:
 *  project:<project_id>,
 *  project_number:<project_number>,
 *  api_key:<api_key>.
 */
@property(nonatomic, copy, nullable) NSString *consumerId;

/** Labels describing the operation. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaOperation_Labels *labels;

/**
 *  Fully qualified name of the API method for which this quota operation is
 *  requested. This name is used for matching quota rules or metric rules and
 *  billing status rules defined in service configuration. This field is not
 *  required if the quota operation is performed on non-API resources.
 *  Example of an RPC method name:
 *  google.example.library.v1.LibraryService.CreateShelf
 */
@property(nonatomic, copy, nullable) NSString *methodName;

/**
 *  Identity of the operation. This is expected to be unique within the scope
 *  of the service that generated the operation, and guarantees idempotency in
 *  case of retries.
 *  UUID version 4 is recommended, though not required. In scenarios where an
 *  operation is computed from existing information and an idempotent id is
 *  desirable for deduplication purpose, UUID version 5 is recommended. See
 *  RFC 4122 for details.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/**
 *  Represents information about this operation. Each MetricValueSet
 *  corresponds to a metric defined in the service configuration.
 *  The data type used in the MetricValueSet must agree with
 *  the data type specified in the metric definition.
 *  Within a single operation, it is not allowed to have more than one
 *  MetricValue instances that have the same metric names and identical
 *  label value combinations. If a request has such duplicated MetricValue
 *  instances, the entire request is rejected with
 *  an invalid argument error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *quotaMetrics;

/**
 *  Quota mode for this operation.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_QuotaOperation_QuotaMode_BestEffort For
 *        AllocateQuota request, this mode is supported only for imprecise
 *        quota limits. In this case, the operation allocates quota for the
 *        amount
 *        specified in the service configuration or specified using the quota
 *        metrics. If the amount is higher than the available quota, request
 *        does
 *        not fail but all available quota will be allocated.
 *        For ReleaseQuota request, this mode is supported for both precise
 *        quota
 *        limits and imprecise quota limits. In this case, this operation
 *        releases
 *        quota for the amount specified in the service configuration or
 *        specified
 *        using the quota metrics. If the release can make used quota
 *        negative, request does not fail but only the used quota will be
 *        released. After the ReleaseQuota request completes, the used quota
 *        will be 0, and never goes to negative. (Value: "BEST_EFFORT")
 *    @arg @c kGTLRServiceControl_QuotaOperation_QuotaMode_CheckOnly For
 *        AllocateQuota request, only checks if there is enough quota
 *        available and does not change the available quota. No lock is placed
 *        on
 *        the available quota either. Not supported for ReleaseQuota request.
 *        (Value: "CHECK_ONLY")
 *    @arg @c kGTLRServiceControl_QuotaOperation_QuotaMode_Normal For
 *        AllocateQuota request, allocates quota for the amount specified in
 *        the service configuration or specified using the quota metrics. If the
 *        amount is higher than the available quota, allocation error will be
 *        returned and no quota will be allocated.
 *        For ReleaseQuota request, this mode is supported only for precise
 *        quota
 *        limits. In this case, this operation releases quota for the amount
 *        specified in the service configuration or specified using the quota
 *        metrics. If the release can make used quota negative, release error
 *        will be returned and no quota will be released. (Value: "NORMAL")
 *    @arg @c kGTLRServiceControl_QuotaOperation_QuotaMode_Unspecified Value
 *        "UNSPECIFIED"
 */
@property(nonatomic, copy, nullable) NSString *quotaMode;

@end


/**
 *  Labels describing the operation.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_QuotaOperation_Labels : GTLRObject
@end


/**
 *  Represents the properties needed for quota operations.
 */
@interface GTLRServiceControl_QuotaProperties : GTLRObject

/**
 *  LimitType IDs that should be used for checking quota. Key in this map
 *  should be a valid LimitType string, and the value is the ID to be used. For
 *  example, an entry <USER, 123> will cause all user quota limits to use 123
 *  as the user ID. See google/api/quota.proto for the definition of LimitType.
 *  CLIENT_PROJECT: Not supported.
 *  USER: Value of this entry will be used for enforcing user-level quota
 *  limits. If none specified, caller IP passed in the
 *  servicecontrol.googleapis.com/caller_ip label will be used instead.
 *  If the server cannot resolve a value for this LimitType, an error
 *  will be thrown. No validation will be performed on this ID.
 *  Deprecated: use servicecontrol.googleapis.com/user label to send user ID.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaProperties_LimitByIds *limitByIds;

/**
 *  Quota mode for this operation.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_QuotaProperties_QuotaMode_Acquire Decreases
 *        available quota by the cost specified for the operation.
 *        If cost is higher than available quota, operation fails and returns
 *        error. (Value: "ACQUIRE")
 *    @arg @c kGTLRServiceControl_QuotaProperties_QuotaMode_AcquireBestEffort
 *        Decreases available quota by the cost specified for the operation.
 *        If cost is higher than available quota, operation does not fail and
 *        available quota goes down to zero but it returns error. (Value:
 *        "ACQUIRE_BEST_EFFORT")
 *    @arg @c kGTLRServiceControl_QuotaProperties_QuotaMode_Check Does not
 *        change any available quota. Only checks if there is enough
 *        quota.
 *        No lock is placed on the checked tokens neither. (Value: "CHECK")
 *    @arg @c kGTLRServiceControl_QuotaProperties_QuotaMode_Release Increases
 *        available quota by the operation cost specified for the
 *        operation. (Value: "RELEASE")
 */
@property(nonatomic, copy, nullable) NSString *quotaMode;

@end


/**
 *  LimitType IDs that should be used for checking quota. Key in this map
 *  should be a valid LimitType string, and the value is the ID to be used. For
 *  example, an entry <USER, 123> will cause all user quota limits to use 123
 *  as the user ID. See google/api/quota.proto for the definition of LimitType.
 *  CLIENT_PROJECT: Not supported.
 *  USER: Value of this entry will be used for enforcing user-level quota
 *  limits. If none specified, caller IP passed in the
 *  servicecontrol.googleapis.com/caller_ip label will be used instead.
 *  If the server cannot resolve a value for this LimitType, an error
 *  will be thrown. No validation will be performed on this ID.
 *  Deprecated: use servicecontrol.googleapis.com/user label to send user ID.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_QuotaProperties_LimitByIds : GTLRObject
@end


/**
 *  Request message for the ReleaseQuota method.
 */
@interface GTLRServiceControl_ReleaseQuotaRequest : GTLRObject

/** Operation that describes the quota release. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaOperation *releaseOperation;

/**
 *  Specifies which version of service configuration should be used to process
 *  the request. If unspecified or no matching version can be found, the latest
 *  one will be used.
 */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Response message for the ReleaseQuota method.
 */
@interface GTLRServiceControl_ReleaseQuotaResponse : GTLRObject

/**
 *  The same operation_id value used in the ReleaseQuotaRequest. Used for
 *  logging and diagnostics purposes.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/**
 *  Quota metrics to indicate the result of release. Depending on the
 *  request, one or more of the following metrics will be included:
 *  1. For rate quota, per quota group or per quota metric released amount
 *  will be specified using the following delta metric:
 *  "serviceruntime.googleapis.com/api/consumer/quota_refund_count"
 *  2. For allocation quota, per quota metric total usage will be specified
 *  using the following gauge metric:
 *  "serviceruntime.googleapis.com/allocation/consumer/quota_used_count"
 *  3. For allocation quota, value for each quota limit associated with
 *  the metrics will be specified using the following gauge metric:
 *  "serviceruntime.googleapis.com/quota/limit"
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *quotaMetrics;

/** Indicates the decision of the release. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_QuotaError *> *releaseErrors;

/** ID of the actual config used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Represents the processing error of one `Operation` in the request.
 */
@interface GTLRServiceControl_ReportError : GTLRObject

/** The Operation.operation_id value from the request. */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Details of the error when processing the `Operation`. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Status *status;

@end


/**
 *  GTLRServiceControl_ReportInfo
 */
@interface GTLRServiceControl_ReportInfo : GTLRObject

/** The Operation.operation_id value from the request. */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Quota usage info when processing the `Operation`. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaInfo *quotaInfo;

@end


/**
 *  Request message for the Report method.
 */
@interface GTLRServiceControl_ReportRequest : GTLRObject

/**
 *  Operations to be reported.
 *  Typically the service should report one operation per request.
 *  Putting multiple operations into a single request is allowed, but should
 *  be used only when multiple operations are natually available at the time
 *  of the report.
 *  If multiple operations are in a single request, the total request size
 *  should be no larger than 1MB. See ReportResponse.report_errors for
 *  partial failure behavior.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_Operation *> *operations;

/**
 *  Specifies which version of service config should be used to process the
 *  request.
 *  If unspecified or no matching version can be found, the
 *  latest one will be used.
 */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Response message for the Report method.
 */
@interface GTLRServiceControl_ReportResponse : GTLRObject

/**
 *  Partial failures, one for each `Operation` in the request that failed
 *  processing. There are three possible combinations of the RPC status:
 *  1. The combination of a successful RPC status and an empty `report_errors`
 *  list indicates a complete success where all `Operations` in the
 *  request are processed successfully.
 *  2. The combination of a successful RPC status and a non-empty
 *  `report_errors` list indicates a partial success where some
 *  `Operations` in the request succeeded. Each
 *  `Operation` that failed processing has a corresponding item
 *  in this list.
 *  3. A failed RPC status indicates a general non-deterministic failure.
 *  When this happens, it's impossible to know which of the
 *  'Operations' in the request succeeded or failed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_ReportError *> *reportErrors;

/**
 *  Quota usage for each quota release `Operation` request.
 *  Fully or partially failed quota release request may or may not be present
 *  in `report_quota_info`. For example, a failed quota release request will
 *  have the current quota usage info when precise quota library returns the
 *  info. A deadline exceeded quota request will not have quota usage info.
 *  If there is no quota release request, report_quota_info will be empty.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_ReportInfo *> *reportInfos;

/** The actual config id used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Metadata about the request.
 */
@interface GTLRServiceControl_RequestMetadata : GTLRObject

/**
 *  The IP address of the caller.
 *  For caller from internet, this will be public IPv4 or IPv6 address.
 *  For caller from GCE VM with external IP address, this will be the VM's
 *  external IP address. For caller from GCE VM without external IP address, if
 *  the VM is in the same GCP organization (or project) as the accessed
 *  resource, `caller_ip` will be the GCE VM's internal IPv4 address, otherwise
 *  it will be redacted to "gce-internal-ip".
 *  See https://cloud.google.com/compute/docs/vpc/ for more information.
 */
@property(nonatomic, copy, nullable) NSString *callerIp;

/**
 *  The user agent of the caller.
 *  This information is not authenticated and should be treated accordingly.
 *  For example:
 *  + `google-api-python-client/1.4.0`:
 *  The request was made by the Google API client for Python.
 *  + `Cloud SDK Command Line Tool apitools-client/1.0 gcloud/0.9.62`:
 *  The request was made by the Google Cloud SDK CLI (gcloud).
 *  + `AppEngine-Google; (+http://code.google.com/appengine; appid:
 *  s~my-project`:
 *  The request was made from the `my-project` App Engine app.
 *  NOLINT
 */
@property(nonatomic, copy, nullable) NSString *callerSuppliedUserAgent;

@end


/**
 *  GTLRServiceControl_StartReconciliationRequest
 */
@interface GTLRServiceControl_StartReconciliationRequest : GTLRObject

/** Operation that describes the quota reconciliation. */
@property(nonatomic, strong, nullable) GTLRServiceControl_QuotaOperation *reconciliationOperation;

/**
 *  Specifies which version of service configuration should be used to process
 *  the request. If unspecified or no matching version can be found, the latest
 *  one will be used.
 */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  GTLRServiceControl_StartReconciliationResponse
 */
@interface GTLRServiceControl_StartReconciliationResponse : GTLRObject

/**
 *  The same operation_id value used in the StartReconciliationRequest. Used
 *  for logging and diagnostics purposes.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/**
 *  Metric values as tracked by One Platform before the start of
 *  reconciliation. The following metrics will be included:
 *  1. Per quota metric total usage will be specified using the following gauge
 *  metric:
 *  "serviceruntime.googleapis.com/allocation/consumer/quota_used_count"
 *  2. Value for each quota limit associated with the metrics will be specified
 *  using the following gauge metric:
 *  "serviceruntime.googleapis.com/quota/limit"
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *quotaMetrics;

/** Indicates the decision of the reconciliation start. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_QuotaError *> *reconciliationErrors;

/** ID of the actual config used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` that can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRServiceControl_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRServiceControl_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_Status_Details_Item : GTLRObject
@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
