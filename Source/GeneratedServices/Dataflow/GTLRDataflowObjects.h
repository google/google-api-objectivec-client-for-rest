// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Dataflow API (dataflow/v1b3)
// Description:
//   Manages Google Cloud Dataflow projects on Google Cloud Platform.
// Documentation:
//   https://cloud.google.com/dataflow

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRDataflow_ApproximateProgress;
@class GTLRDataflow_ApproximateReportedProgress;
@class GTLRDataflow_ApproximateSplitRequest;
@class GTLRDataflow_AutoscalingEvent;
@class GTLRDataflow_AutoscalingSettings;
@class GTLRDataflow_BigQueryIODetails;
@class GTLRDataflow_BigTableIODetails;
@class GTLRDataflow_ComponentSource;
@class GTLRDataflow_ComponentTransform;
@class GTLRDataflow_ComputationTopology;
@class GTLRDataflow_ConcatPosition;
@class GTLRDataflow_CounterMetadata;
@class GTLRDataflow_CounterStructuredName;
@class GTLRDataflow_CounterStructuredNameAndMetadata;
@class GTLRDataflow_CounterUpdate;
@class GTLRDataflow_CPUTime;
@class GTLRDataflow_CreateJobFromTemplateRequest_Parameters;
@class GTLRDataflow_CustomSourceLocation;
@class GTLRDataflow_DataDiskAssignment;
@class GTLRDataflow_DatastoreIODetails;
@class GTLRDataflow_DerivedSource;
@class GTLRDataflow_Disk;
@class GTLRDataflow_DisplayData;
@class GTLRDataflow_DistributionUpdate;
@class GTLRDataflow_DynamicSourceSplit;
@class GTLRDataflow_Environment;
@class GTLRDataflow_Environment_InternalExperiments;
@class GTLRDataflow_Environment_SdkPipelineOptions;
@class GTLRDataflow_Environment_UserAgent;
@class GTLRDataflow_Environment_Version;
@class GTLRDataflow_ExecutionStageState;
@class GTLRDataflow_ExecutionStageSummary;
@class GTLRDataflow_FailedLocation;
@class GTLRDataflow_FileIODetails;
@class GTLRDataflow_FlattenInstruction;
@class GTLRDataflow_FloatingPointList;
@class GTLRDataflow_FloatingPointMean;
@class GTLRDataflow_Histogram;
@class GTLRDataflow_InstructionInput;
@class GTLRDataflow_InstructionOutput;
@class GTLRDataflow_InstructionOutput_Codec;
@class GTLRDataflow_IntegerGauge;
@class GTLRDataflow_IntegerList;
@class GTLRDataflow_IntegerMean;
@class GTLRDataflow_Job;
@class GTLRDataflow_Job_Labels;
@class GTLRDataflow_Job_TransformNameMapping;
@class GTLRDataflow_JobExecutionInfo;
@class GTLRDataflow_JobExecutionInfo_Stages;
@class GTLRDataflow_JobExecutionStageInfo;
@class GTLRDataflow_JobMessage;
@class GTLRDataflow_JobMetadata;
@class GTLRDataflow_KeyRangeDataDiskAssignment;
@class GTLRDataflow_KeyRangeLocation;
@class GTLRDataflow_LaunchTemplateParameters_Parameters;
@class GTLRDataflow_MapTask;
@class GTLRDataflow_MetricShortId;
@class GTLRDataflow_MetricStructuredName;
@class GTLRDataflow_MetricStructuredName_Context;
@class GTLRDataflow_MetricUpdate;
@class GTLRDataflow_MountedDataDisk;
@class GTLRDataflow_MultiOutputInfo;
@class GTLRDataflow_NameAndKind;
@class GTLRDataflow_Package;
@class GTLRDataflow_ParallelInstruction;
@class GTLRDataflow_Parameter;
@class GTLRDataflow_ParameterMetadata;
@class GTLRDataflow_ParDoInstruction;
@class GTLRDataflow_ParDoInstruction_UserFn;
@class GTLRDataflow_PartialGroupByKeyInstruction;
@class GTLRDataflow_PartialGroupByKeyInstruction_InputElementCodec;
@class GTLRDataflow_PartialGroupByKeyInstruction_ValueCombiningFn;
@class GTLRDataflow_PipelineDescription;
@class GTLRDataflow_Position;
@class GTLRDataflow_PubSubIODetails;
@class GTLRDataflow_PubsubLocation;
@class GTLRDataflow_ReadInstruction;
@class GTLRDataflow_ReportedParallelism;
@class GTLRDataflow_ResourceUtilizationReport;
@class GTLRDataflow_ResourceUtilizationReportResponse;
@class GTLRDataflow_RuntimeEnvironment;
@class GTLRDataflow_RuntimeEnvironment_AdditionalUserLabels;
@class GTLRDataflow_SdkVersion;
@class GTLRDataflow_SeqMapTask;
@class GTLRDataflow_SeqMapTask_UserFn;
@class GTLRDataflow_SeqMapTaskOutputInfo;
@class GTLRDataflow_ShellTask;
@class GTLRDataflow_SideInputInfo;
@class GTLRDataflow_SideInputInfo_Kind;
@class GTLRDataflow_Sink;
@class GTLRDataflow_Sink_Codec;
@class GTLRDataflow_Sink_Spec;
@class GTLRDataflow_Source;
@class GTLRDataflow_Source_BaseSpecs_Item;
@class GTLRDataflow_Source_Codec;
@class GTLRDataflow_Source_Spec;
@class GTLRDataflow_SourceFork;
@class GTLRDataflow_SourceGetMetadataRequest;
@class GTLRDataflow_SourceGetMetadataResponse;
@class GTLRDataflow_SourceMetadata;
@class GTLRDataflow_SourceOperationRequest;
@class GTLRDataflow_SourceOperationResponse;
@class GTLRDataflow_SourceSplitOptions;
@class GTLRDataflow_SourceSplitRequest;
@class GTLRDataflow_SourceSplitResponse;
@class GTLRDataflow_SourceSplitShard;
@class GTLRDataflow_SpannerIODetails;
@class GTLRDataflow_SplitInt64;
@class GTLRDataflow_StageSource;
@class GTLRDataflow_StateFamilyConfig;
@class GTLRDataflow_Status;
@class GTLRDataflow_Status_Details_Item;
@class GTLRDataflow_Step;
@class GTLRDataflow_Step_Properties;
@class GTLRDataflow_StreamingApplianceSnapshotConfig;
@class GTLRDataflow_StreamingComputationConfig;
@class GTLRDataflow_StreamingComputationRanges;
@class GTLRDataflow_StreamingComputationTask;
@class GTLRDataflow_StreamingConfigTask;
@class GTLRDataflow_StreamingConfigTask_UserStepToStateFamilyNameMap;
@class GTLRDataflow_StreamingSetupTask;
@class GTLRDataflow_StreamingSideInputLocation;
@class GTLRDataflow_StreamingStageLocation;
@class GTLRDataflow_StreamLocation;
@class GTLRDataflow_StringList;
@class GTLRDataflow_StructuredMessage;
@class GTLRDataflow_TaskRunnerSettings;
@class GTLRDataflow_TemplateMetadata;
@class GTLRDataflow_TopologyConfig;
@class GTLRDataflow_TopologyConfig_UserStageToComputationNameMap;
@class GTLRDataflow_TransformSummary;
@class GTLRDataflow_WorkerHealthReport;
@class GTLRDataflow_WorkerHealthReport_Pods_Item;
@class GTLRDataflow_WorkerHealthReportResponse;
@class GTLRDataflow_WorkerLifecycleEvent;
@class GTLRDataflow_WorkerLifecycleEvent_Metadata;
@class GTLRDataflow_WorkerMessage;
@class GTLRDataflow_WorkerMessage_Labels;
@class GTLRDataflow_WorkerMessageCode;
@class GTLRDataflow_WorkerMessageCode_Parameters;
@class GTLRDataflow_WorkerMessageResponse;
@class GTLRDataflow_WorkerPool;
@class GTLRDataflow_WorkerPool_Metadata;
@class GTLRDataflow_WorkerPool_PoolArgs;
@class GTLRDataflow_WorkerSettings;
@class GTLRDataflow_WorkerShutdownNotice;
@class GTLRDataflow_WorkerShutdownNoticeResponse;
@class GTLRDataflow_WorkItem;
@class GTLRDataflow_WorkItemServiceState;
@class GTLRDataflow_WorkItemServiceState_HarnessData;
@class GTLRDataflow_WorkItemStatus;
@class GTLRDataflow_WriteInstruction;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRDataflow_AutoscalingEvent.eventType

/**
 *  The ACTUATION_FAILURE type should be used when we want to report
 *  an error to the user indicating why the current number of workers
 *  in the pool could not be changed.
 *  Displayed in the current status and history widgets.
 *
 *  Value: "ACTUATION_FAILURE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingEvent_EventType_ActuationFailure;
/**
 *  The CURRENT_NUM_WORKERS_CHANGED type should be used when actual worker
 *  pool size has been changed, but the target_num_workers has not changed.
 *
 *  Value: "CURRENT_NUM_WORKERS_CHANGED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingEvent_EventType_CurrentNumWorkersChanged;
/**
 *  Used when we want to report to the user a reason why we are
 *  not currently adjusting the number of workers.
 *  Should specify both target_num_workers, current_num_workers and a
 *  decision_message.
 *
 *  Value: "NO_CHANGE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingEvent_EventType_NoChange;
/**
 *  The TARGET_NUM_WORKERS_CHANGED type should be used when the target
 *  worker pool size has changed at the start of an actuation. An event
 *  should always be specified as TARGET_NUM_WORKERS_CHANGED if it reflects
 *  a change in the target_num_workers.
 *
 *  Value: "TARGET_NUM_WORKERS_CHANGED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingEvent_EventType_TargetNumWorkersChanged;
/**
 *  Default type for the enum. Value should never be returned.
 *
 *  Value: "TYPE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingEvent_EventType_TypeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_AutoscalingSettings.algorithm

/**
 *  Increase worker count over time to reduce job execution time.
 *
 *  Value: "AUTOSCALING_ALGORITHM_BASIC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmBasic;
/**
 *  Disable autoscaling.
 *
 *  Value: "AUTOSCALING_ALGORITHM_NONE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmNone;
/**
 *  The algorithm is unknown, or unspecified.
 *
 *  Value: "AUTOSCALING_ALGORITHM_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterMetadata.kind

/**
 *  Aggregated value represents the logical 'and' of all contributed values.
 *
 *  Value: "AND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_And;
/**
 *  Aggregated value captures statistics about a distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Distribution;
/**
 *  Counter aggregation kind was not set.
 *
 *  Value: "INVALID"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Invalid;
/**
 *  Aggregated value tracks the latest value of a variable.
 *
 *  Value: "LATEST_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_LatestValue;
/**
 *  Aggregated value is the max of all contributed values.
 *
 *  Value: "MAX"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Max;
/**
 *  Aggregated value is the mean of all contributed values.
 *
 *  Value: "MEAN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Mean;
/**
 *  Aggregated value is the min of all contributed values.
 *
 *  Value: "MIN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Min;
/**
 *  Aggregated value represents the logical 'or' of all contributed values.
 *
 *  Value: "OR"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Or;
/**
 *  Aggregated value is a set of unique contributed values.
 *
 *  Value: "SET"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Set;
/**
 *  Aggregated value is the sum of all contributed values.
 *
 *  Value: "SUM"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Sum;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterMetadata.standardUnits

/**
 *  Counter returns a value in bytes.
 *
 *  Value: "BYTES"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Bytes;
/**
 *  Counter returns a value in bytes per second.
 *
 *  Value: "BYTES_PER_SEC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_BytesPerSec;
/**
 *  Counter returns a value in microseconds.
 *
 *  Value: "MICROSECONDS"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Microseconds;
/**
 *  Counter returns a value in milliseconds.
 *
 *  Value: "MILLISECONDS"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Milliseconds;
/**
 *  Counter returns a value in nanoseconds.
 *
 *  Value: "NANOSECONDS"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Nanoseconds;
/**
 *  Counter returns a timestamp in milliseconds.
 *
 *  Value: "TIMESTAMP_MSEC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_TimestampMsec;
/**
 *  Counter returns a timestamp in nanoseconds.
 *
 *  Value: "TIMESTAMP_NSEC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_TimestampNsec;
/**
 *  Counter returns a timestamp in microseconds.
 *
 *  Value: "TIMESTAMP_USEC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_TimestampUsec;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterStructuredName.origin

/**
 *  Counter was created by the Dataflow system.
 *
 *  Value: "SYSTEM"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Origin_System;
/**
 *  Counter was created by the user.
 *
 *  Value: "USER"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Origin_User;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterStructuredName.portion

/**
 *  Counter portion has not been set.
 *
 *  Value: "ALL"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Portion_All;
/**
 *  Counter reports a key.
 *
 *  Value: "KEY"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Portion_Key;
/**
 *  Counter reports a value.
 *
 *  Value: "VALUE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Portion_Value;

// ----------------------------------------------------------------------------
// GTLRDataflow_DerivedSource.derivationMode

/**
 *  Produce a Source based on the Source being split.
 *
 *  Value: "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeChildOfCurrent;
/**
 *  Produce a completely independent Source with no base.
 *
 *  Value: "SOURCE_DERIVATION_MODE_INDEPENDENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeIndependent;
/**
 *  Produce a Source based on the base of the Source being split.
 *
 *  Value: "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeSiblingOfCurrent;
/**
 *  The source derivation is unknown, or unspecified.
 *
 *  Value: "SOURCE_DERIVATION_MODE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_ExecutionStageState.executionStageState

/**
 *  `JOB_STATE_CANCELLED` indicates that the job has been explicitly
 *  cancelled. This is a terminal job state. This state may only be
 *  set via a Cloud Dataflow `UpdateJob` call, and only if the job has not
 *  yet reached another terminal state.
 *
 *  Value: "JOB_STATE_CANCELLED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateCancelled;
/**
 *  `JOB_STATE_CANCELLING` indicates that the job has been explicitly cancelled
 *  and is in the process of stopping. Jobs that are cancelling may only
 *  transition to `JOB_STATE_CANCELLED` or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_CANCELLING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateCancelling;
/**
 *  `JOB_STATE_DONE` indicates that the job has successfully completed.
 *  This is a terminal job state. This state may be set by the Cloud Dataflow
 *  service, as a transition from `JOB_STATE_RUNNING`. It may also be set via a
 *  Cloud Dataflow `UpdateJob` call, if the job has not yet reached a terminal
 *  state.
 *
 *  Value: "JOB_STATE_DONE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateDone;
/**
 *  `JOB_STATE_DRAINED` indicates that the job has been drained.
 *  A drained job terminated by stopping pulling from its input sources and
 *  processing any data that remained in-flight when draining was requested.
 *  This state is a terminal state, may only be set by the Cloud Dataflow
 *  service, and only as a transition from `JOB_STATE_DRAINING`.
 *
 *  Value: "JOB_STATE_DRAINED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateDrained;
/**
 *  `JOB_STATE_DRAINING` indicates that the job is in the process of draining.
 *  A draining job has stopped pulling from its input sources and is processing
 *  any data that remains in-flight. This state may be set via a Cloud Dataflow
 *  `UpdateJob` call, but only as a transition from `JOB_STATE_RUNNING`. Jobs
 *  that are draining may only transition to `JOB_STATE_DRAINED`,
 *  `JOB_STATE_CANCELLED`, or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_DRAINING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateDraining;
/**
 *  `JOB_STATE_FAILED` indicates that the job has failed. This is a
 *  terminal job state. This state may only be set by the Cloud Dataflow
 *  service, and only as a transition from `JOB_STATE_RUNNING`.
 *
 *  Value: "JOB_STATE_FAILED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateFailed;
/**
 *  `JOB_STATE_PENDING` indicates that the job has been created but is not yet
 *  running. Jobs that are pending may only transition to `JOB_STATE_RUNNING`,
 *  or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_PENDING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStatePending;
/**
 *  `JOB_STATE_QUEUED` indicates that the job has been created but is being
 *  delayed until launch. Jobs that are queued may only transition to
 *  `JOB_STATE_PENDING` or `JOB_STATE_CANCELLED`.
 *
 *  Value: "JOB_STATE_QUEUED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateQueued;
/**
 *  `JOB_STATE_RUNNING` indicates that the job is currently running.
 *
 *  Value: "JOB_STATE_RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateRunning;
/**
 *  `JOB_STATE_STOPPED` indicates that the job has not
 *  yet started to run.
 *
 *  Value: "JOB_STATE_STOPPED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateStopped;
/**
 *  The job's run state isn't specified.
 *
 *  Value: "JOB_STATE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateUnknown;
/**
 *  `JOB_STATE_UPDATED` indicates that the job was successfully updated,
 *  meaning that this job was stopped and another job was started, inheriting
 *  state from this one. This is a terminal job state. This state may only be
 *  set by the Cloud Dataflow service, and only as a transition from
 *  `JOB_STATE_RUNNING`.
 *
 *  Value: "JOB_STATE_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateUpdated;

// ----------------------------------------------------------------------------
// GTLRDataflow_ExecutionStageSummary.kind

/**
 *  Constructs from a constant value, such as with Create.of.
 *
 *  Value: "CONSTANT_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_ConstantKind;
/**
 *  Flatten transform.
 *
 *  Value: "FLATTEN_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_FlattenKind;
/**
 *  Group By Key transform.
 *
 *  Value: "GROUP_BY_KEY_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_GroupByKeyKind;
/**
 *  ParDo transform.
 *
 *  Value: "PAR_DO_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_ParDoKind;
/**
 *  Read transform.
 *
 *  Value: "READ_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_ReadKind;
/**
 *  Opening or closing a shuffle session, often as part of a GroupByKey.
 *
 *  Value: "SHUFFLE_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_ShuffleKind;
/**
 *  Creates a Singleton view of a collection.
 *
 *  Value: "SINGLETON_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_SingletonKind;
/**
 *  Unrecognized transform type.
 *
 *  Value: "UNKNOWN_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_UnknownKind;
/**
 *  Write transform.
 *
 *  Value: "WRITE_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_ExecutionStageSummary_Kind_WriteKind;

// ----------------------------------------------------------------------------
// GTLRDataflow_Job.currentState

/**
 *  `JOB_STATE_CANCELLED` indicates that the job has been explicitly
 *  cancelled. This is a terminal job state. This state may only be
 *  set via a Cloud Dataflow `UpdateJob` call, and only if the job has not
 *  yet reached another terminal state.
 *
 *  Value: "JOB_STATE_CANCELLED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateCancelled;
/**
 *  `JOB_STATE_CANCELLING` indicates that the job has been explicitly cancelled
 *  and is in the process of stopping. Jobs that are cancelling may only
 *  transition to `JOB_STATE_CANCELLED` or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_CANCELLING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateCancelling;
/**
 *  `JOB_STATE_DONE` indicates that the job has successfully completed.
 *  This is a terminal job state. This state may be set by the Cloud Dataflow
 *  service, as a transition from `JOB_STATE_RUNNING`. It may also be set via a
 *  Cloud Dataflow `UpdateJob` call, if the job has not yet reached a terminal
 *  state.
 *
 *  Value: "JOB_STATE_DONE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateDone;
/**
 *  `JOB_STATE_DRAINED` indicates that the job has been drained.
 *  A drained job terminated by stopping pulling from its input sources and
 *  processing any data that remained in-flight when draining was requested.
 *  This state is a terminal state, may only be set by the Cloud Dataflow
 *  service, and only as a transition from `JOB_STATE_DRAINING`.
 *
 *  Value: "JOB_STATE_DRAINED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateDrained;
/**
 *  `JOB_STATE_DRAINING` indicates that the job is in the process of draining.
 *  A draining job has stopped pulling from its input sources and is processing
 *  any data that remains in-flight. This state may be set via a Cloud Dataflow
 *  `UpdateJob` call, but only as a transition from `JOB_STATE_RUNNING`. Jobs
 *  that are draining may only transition to `JOB_STATE_DRAINED`,
 *  `JOB_STATE_CANCELLED`, or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_DRAINING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateDraining;
/**
 *  `JOB_STATE_FAILED` indicates that the job has failed. This is a
 *  terminal job state. This state may only be set by the Cloud Dataflow
 *  service, and only as a transition from `JOB_STATE_RUNNING`.
 *
 *  Value: "JOB_STATE_FAILED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateFailed;
/**
 *  `JOB_STATE_PENDING` indicates that the job has been created but is not yet
 *  running. Jobs that are pending may only transition to `JOB_STATE_RUNNING`,
 *  or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_PENDING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStatePending;
/**
 *  `JOB_STATE_QUEUED` indicates that the job has been created but is being
 *  delayed until launch. Jobs that are queued may only transition to
 *  `JOB_STATE_PENDING` or `JOB_STATE_CANCELLED`.
 *
 *  Value: "JOB_STATE_QUEUED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateQueued;
/**
 *  `JOB_STATE_RUNNING` indicates that the job is currently running.
 *
 *  Value: "JOB_STATE_RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateRunning;
/**
 *  `JOB_STATE_STOPPED` indicates that the job has not
 *  yet started to run.
 *
 *  Value: "JOB_STATE_STOPPED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateStopped;
/**
 *  The job's run state isn't specified.
 *
 *  Value: "JOB_STATE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateUnknown;
/**
 *  `JOB_STATE_UPDATED` indicates that the job was successfully updated,
 *  meaning that this job was stopped and another job was started, inheriting
 *  state from this one. This is a terminal job state. This state may only be
 *  set by the Cloud Dataflow service, and only as a transition from
 *  `JOB_STATE_RUNNING`.
 *
 *  Value: "JOB_STATE_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateUpdated;

// ----------------------------------------------------------------------------
// GTLRDataflow_Job.requestedState

/**
 *  `JOB_STATE_CANCELLED` indicates that the job has been explicitly
 *  cancelled. This is a terminal job state. This state may only be
 *  set via a Cloud Dataflow `UpdateJob` call, and only if the job has not
 *  yet reached another terminal state.
 *
 *  Value: "JOB_STATE_CANCELLED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateCancelled;
/**
 *  `JOB_STATE_CANCELLING` indicates that the job has been explicitly cancelled
 *  and is in the process of stopping. Jobs that are cancelling may only
 *  transition to `JOB_STATE_CANCELLED` or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_CANCELLING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateCancelling;
/**
 *  `JOB_STATE_DONE` indicates that the job has successfully completed.
 *  This is a terminal job state. This state may be set by the Cloud Dataflow
 *  service, as a transition from `JOB_STATE_RUNNING`. It may also be set via a
 *  Cloud Dataflow `UpdateJob` call, if the job has not yet reached a terminal
 *  state.
 *
 *  Value: "JOB_STATE_DONE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateDone;
/**
 *  `JOB_STATE_DRAINED` indicates that the job has been drained.
 *  A drained job terminated by stopping pulling from its input sources and
 *  processing any data that remained in-flight when draining was requested.
 *  This state is a terminal state, may only be set by the Cloud Dataflow
 *  service, and only as a transition from `JOB_STATE_DRAINING`.
 *
 *  Value: "JOB_STATE_DRAINED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateDrained;
/**
 *  `JOB_STATE_DRAINING` indicates that the job is in the process of draining.
 *  A draining job has stopped pulling from its input sources and is processing
 *  any data that remains in-flight. This state may be set via a Cloud Dataflow
 *  `UpdateJob` call, but only as a transition from `JOB_STATE_RUNNING`. Jobs
 *  that are draining may only transition to `JOB_STATE_DRAINED`,
 *  `JOB_STATE_CANCELLED`, or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_DRAINING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateDraining;
/**
 *  `JOB_STATE_FAILED` indicates that the job has failed. This is a
 *  terminal job state. This state may only be set by the Cloud Dataflow
 *  service, and only as a transition from `JOB_STATE_RUNNING`.
 *
 *  Value: "JOB_STATE_FAILED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateFailed;
/**
 *  `JOB_STATE_PENDING` indicates that the job has been created but is not yet
 *  running. Jobs that are pending may only transition to `JOB_STATE_RUNNING`,
 *  or `JOB_STATE_FAILED`.
 *
 *  Value: "JOB_STATE_PENDING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStatePending;
/**
 *  `JOB_STATE_QUEUED` indicates that the job has been created but is being
 *  delayed until launch. Jobs that are queued may only transition to
 *  `JOB_STATE_PENDING` or `JOB_STATE_CANCELLED`.
 *
 *  Value: "JOB_STATE_QUEUED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateQueued;
/**
 *  `JOB_STATE_RUNNING` indicates that the job is currently running.
 *
 *  Value: "JOB_STATE_RUNNING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateRunning;
/**
 *  `JOB_STATE_STOPPED` indicates that the job has not
 *  yet started to run.
 *
 *  Value: "JOB_STATE_STOPPED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateStopped;
/**
 *  The job's run state isn't specified.
 *
 *  Value: "JOB_STATE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateUnknown;
/**
 *  `JOB_STATE_UPDATED` indicates that the job was successfully updated,
 *  meaning that this job was stopped and another job was started, inheriting
 *  state from this one. This is a terminal job state. This state may only be
 *  set by the Cloud Dataflow service, and only as a transition from
 *  `JOB_STATE_RUNNING`.
 *
 *  Value: "JOB_STATE_UPDATED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateUpdated;

// ----------------------------------------------------------------------------
// GTLRDataflow_Job.type

/**
 *  A batch job with a well-defined end point: data is read, data is
 *  processed, data is written, and the job is done.
 *
 *  Value: "JOB_TYPE_BATCH"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_Type_JobTypeBatch;
/**
 *  A continuously streaming job with no end: data is read,
 *  processed, and written continuously.
 *
 *  Value: "JOB_TYPE_STREAMING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_Type_JobTypeStreaming;
/**
 *  The type of the job is unspecified, or unknown.
 *
 *  Value: "JOB_TYPE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_Type_JobTypeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_JobMessage.messageImportance

/**
 *  The message is at the 'basic' level: useful for keeping
 *  track of the execution of a Dataflow pipeline. Typically,
 *  Dataflow pipeline runners display log messages at this level by
 *  default, and these messages are displayed by default in the
 *  Dataflow monitoring UI.
 *
 *  Value: "JOB_MESSAGE_BASIC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageBasic;
/**
 *  The message is at the 'debug' level: typically only useful for
 *  software engineers working on the code the job is running.
 *  Typically, Dataflow pipeline runners do not display log messages
 *  at this level by default.
 *
 *  Value: "JOB_MESSAGE_DEBUG"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageDebug;
/**
 *  The message is at the 'detailed' level: somewhat verbose, but
 *  potentially useful to users. Typically, Dataflow pipeline
 *  runners do not display log messages at this level by default.
 *  These messages are displayed by default in the Dataflow
 *  monitoring UI.
 *
 *  Value: "JOB_MESSAGE_DETAILED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageDetailed;
/**
 *  The message is at the 'error' level: indicating a condition
 *  preventing a job from succeeding. Typically, Dataflow pipeline
 *  runners display log messages at this level by default, and these
 *  messages are displayed by default in the Dataflow monitoring UI.
 *
 *  Value: "JOB_MESSAGE_ERROR"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageError;
/**
 *  The message importance isn't specified, or is unknown.
 *
 *  Value: "JOB_MESSAGE_IMPORTANCE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageImportanceUnknown;
/**
 *  The message is at the 'warning' level: indicating a condition
 *  pertaining to a job which may require human intervention.
 *  Typically, Dataflow pipeline runners display log messages at this
 *  level by default, and these messages are displayed by default in
 *  the Dataflow monitoring UI.
 *
 *  Value: "JOB_MESSAGE_WARNING"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageWarning;

// ----------------------------------------------------------------------------
// GTLRDataflow_NameAndKind.kind

/**
 *  Aggregated value represents the logical 'and' of all contributed values.
 *
 *  Value: "AND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_And;
/**
 *  Aggregated value captures statistics about a distribution.
 *
 *  Value: "DISTRIBUTION"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Distribution;
/**
 *  Counter aggregation kind was not set.
 *
 *  Value: "INVALID"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Invalid;
/**
 *  Aggregated value tracks the latest value of a variable.
 *
 *  Value: "LATEST_VALUE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_LatestValue;
/**
 *  Aggregated value is the max of all contributed values.
 *
 *  Value: "MAX"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Max;
/**
 *  Aggregated value is the mean of all contributed values.
 *
 *  Value: "MEAN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Mean;
/**
 *  Aggregated value is the min of all contributed values.
 *
 *  Value: "MIN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Min;
/**
 *  Aggregated value represents the logical 'or' of all contributed values.
 *
 *  Value: "OR"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Or;
/**
 *  Aggregated value is a set of unique contributed values.
 *
 *  Value: "SET"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Set;
/**
 *  Aggregated value is the sum of all contributed values.
 *
 *  Value: "SUM"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Sum;

// ----------------------------------------------------------------------------
// GTLRDataflow_SdkVersion.sdkSupportStatus

/**
 *  This version of the SDK is deprecated and will eventually be no
 *  longer supported.
 *
 *  Value: "DEPRECATED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SdkVersion_SdkSupportStatus_Deprecated;
/**
 *  A newer version of the SDK family exists, and an update is recommended.
 *
 *  Value: "STALE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SdkVersion_SdkSupportStatus_Stale;
/**
 *  This is a known version of an SDK, and is supported.
 *
 *  Value: "SUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SdkVersion_SdkSupportStatus_Supported;
/**
 *  Cloud Dataflow is unaware of this version.
 *
 *  Value: "UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SdkVersion_SdkSupportStatus_Unknown;
/**
 *  Support for this SDK version has ended and it should no longer be used.
 *
 *  Value: "UNSUPPORTED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SdkVersion_SdkSupportStatus_Unsupported;

// ----------------------------------------------------------------------------
// GTLRDataflow_SourceSplitResponse.outcome

/**
 *  Splitting produced a list of bundles.
 *
 *  Value: "SOURCE_SPLIT_OUTCOME_SPLITTING_HAPPENED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeSplittingHappened;
/**
 *  The source split outcome is unknown, or unspecified.
 *
 *  Value: "SOURCE_SPLIT_OUTCOME_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUnknown;
/**
 *  The current source should be processed "as is" without splitting.
 *
 *  Value: "SOURCE_SPLIT_OUTCOME_USE_CURRENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUseCurrent;

// ----------------------------------------------------------------------------
// GTLRDataflow_SourceSplitShard.derivationMode

/**
 *  Produce a Source based on the Source being split.
 *
 *  Value: "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeChildOfCurrent;
/**
 *  Produce a completely independent Source with no base.
 *
 *  Value: "SOURCE_DERIVATION_MODE_INDEPENDENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeIndependent;
/**
 *  Produce a Source based on the base of the Source being split.
 *
 *  Value: "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeSiblingOfCurrent;
/**
 *  The source derivation is unknown, or unspecified.
 *
 *  Value: "SOURCE_DERIVATION_MODE_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_StreamingComputationTask.taskType

/**
 *  Start processing specified streaming computation range(s).
 *
 *  Value: "STREAMING_COMPUTATION_TASK_START"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStart;
/**
 *  Stop processing specified streaming computation range(s).
 *
 *  Value: "STREAMING_COMPUTATION_TASK_STOP"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStop;
/**
 *  The streaming computation task is unknown, or unspecified.
 *
 *  Value: "STREAMING_COMPUTATION_TASK_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_TransformSummary.kind

/**
 *  Constructs from a constant value, such as with Create.of.
 *
 *  Value: "CONSTANT_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_ConstantKind;
/**
 *  Flatten transform.
 *
 *  Value: "FLATTEN_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_FlattenKind;
/**
 *  Group By Key transform.
 *
 *  Value: "GROUP_BY_KEY_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_GroupByKeyKind;
/**
 *  ParDo transform.
 *
 *  Value: "PAR_DO_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_ParDoKind;
/**
 *  Read transform.
 *
 *  Value: "READ_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_ReadKind;
/**
 *  Opening or closing a shuffle session, often as part of a GroupByKey.
 *
 *  Value: "SHUFFLE_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_ShuffleKind;
/**
 *  Creates a Singleton view of a collection.
 *
 *  Value: "SINGLETON_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_SingletonKind;
/**
 *  Unrecognized transform type.
 *
 *  Value: "UNKNOWN_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_UnknownKind;
/**
 *  Write transform.
 *
 *  Value: "WRITE_KIND"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_TransformSummary_Kind_WriteKind;

// ----------------------------------------------------------------------------
// GTLRDataflow_WorkerLifecycleEvent.event

/**
 *  Our container code starts running. Multiple containers could be
 *  distinguished with WorkerMessage.labels if desired.
 *
 *  Value: "CONTAINER_START"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_ContainerStart;
/**
 *  The worker has a functional external network connection.
 *
 *  Value: "NETWORK_UP"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_NetworkUp;
/**
 *  The time the VM started.
 *
 *  Value: "OS_START"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_OsStart;
/**
 *  Finished installing SDK.
 *
 *  Value: "SDK_INSTALL_FINISH"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_SdkInstallFinish;
/**
 *  For applicable SDKs, started installation of SDK and worker packages.
 *
 *  Value: "SDK_INSTALL_START"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_SdkInstallStart;
/**
 *  Finished downloading all staging files.
 *
 *  Value: "STAGING_FILES_DOWNLOAD_FINISH"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_StagingFilesDownloadFinish;
/**
 *  Started downloading staging files.
 *
 *  Value: "STAGING_FILES_DOWNLOAD_START"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_StagingFilesDownloadStart;
/**
 *  Invalid event.
 *
 *  Value: "UNKNOWN_EVENT"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerLifecycleEvent_Event_UnknownEvent;

// ----------------------------------------------------------------------------
// GTLRDataflow_WorkerPool.defaultPackageSet

/**
 *  Stage packages typically useful to workers written in Java.
 *
 *  Value: "DEFAULT_PACKAGE_SET_JAVA"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetJava;
/**
 *  Indicates that no packages should be staged at the worker unless
 *  explicitly specified by the job.
 *
 *  Value: "DEFAULT_PACKAGE_SET_NONE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetNone;
/**
 *  Stage pacakges typically useful to workers written in Python.
 *
 *  Value: "DEFAULT_PACKAGE_SET_PYTHON"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetPython;
/**
 *  The default set of packages to stage is unknown, or unspecified.
 *
 *  Value: "DEFAULT_PACKAGE_SET_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_WorkerPool.ipConfiguration

/**
 *  Workers should have private IP addresses.
 *
 *  Value: "WORKER_IP_PRIVATE"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_IpConfiguration_WorkerIpPrivate;
/**
 *  Workers should have public IP addresses.
 *
 *  Value: "WORKER_IP_PUBLIC"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_IpConfiguration_WorkerIpPublic;
/**
 *  The configuration is unknown, or unspecified.
 *
 *  Value: "WORKER_IP_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_IpConfiguration_WorkerIpUnspecified;

// ----------------------------------------------------------------------------
// GTLRDataflow_WorkerPool.teardownPolicy

/**
 *  Always teardown the resource.
 *
 *  Value: "TEARDOWN_ALWAYS"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownAlways;
/**
 *  Never teardown the resource. This is useful for debugging and
 *  development.
 *
 *  Value: "TEARDOWN_NEVER"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownNever;
/**
 *  Teardown the resource on success. This is useful for debugging
 *  failures.
 *
 *  Value: "TEARDOWN_ON_SUCCESS"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownOnSuccess;
/**
 *  The teardown policy isn't specified, or is unknown.
 *
 *  Value: "TEARDOWN_POLICY_UNKNOWN"
 */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownPolicyUnknown;

/**
 *  Obsolete in favor of ApproximateReportedProgress and
 *  ApproximateSplitRequest.
 */
@interface GTLRDataflow_ApproximateProgress : GTLRObject

/**
 *  Obsolete.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percentComplete;

/** Obsolete. */
@property(nonatomic, strong, nullable) GTLRDataflow_Position *position;

/** Obsolete. */
@property(nonatomic, strong, nullable) GTLRDuration *remainingTime;

@end


/**
 *  A progress measurement of a WorkItem by a worker.
 */
@interface GTLRDataflow_ApproximateReportedProgress : GTLRObject

/**
 *  Total amount of parallelism in the portion of input of this task that has
 *  already been consumed and is no longer active. In the first two examples
 *  above (see remaining_parallelism), the value should be 29 or 2
 *  respectively. The sum of remaining_parallelism and consumed_parallelism
 *  should equal the total amount of parallelism in this work item. If
 *  specified, must be finite.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_ReportedParallelism *consumedParallelism;

/**
 *  Completion as fraction of the input consumed, from 0.0 (beginning, nothing
 *  consumed), to 1.0 (end of the input, entire input consumed).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fractionConsumed;

/** A Position within the work to represent a progress. */
@property(nonatomic, strong, nullable) GTLRDataflow_Position *position;

/**
 *  Total amount of parallelism in the input of this task that remains,
 *  (i.e. can be delegated to this task and any new tasks via dynamic
 *  splitting). Always at least 1 for non-finished work items and 0 for
 *  finished.
 *  "Amount of parallelism" refers to how many non-empty parts of the input
 *  can be read in parallel. This does not necessarily equal number
 *  of records. An input that can be read in parallel down to the
 *  individual records is called "perfectly splittable".
 *  An example of non-perfectly parallelizable input is a block-compressed
 *  file format where a block of records has to be read as a whole,
 *  but different blocks can be read in parallel.
 *  Examples:
 *  * If we are processing record #30 (starting at 1) out of 50 in a perfectly
 *  splittable 50-record input, this value should be 21 (20 remaining + 1
 *  current).
 *  * If we are reading through block 3 in a block-compressed file consisting
 *  of 5 blocks, this value should be 3 (since blocks 4 and 5 can be
 *  processed in parallel by new tasks via dynamic splitting and the current
 *  task remains processing block 3).
 *  * If we are reading through the last block in a block-compressed file,
 *  or reading or processing the last record in a perfectly splittable
 *  input, this value should be 1, because apart from the current task, no
 *  additional remainder can be split off.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_ReportedParallelism *remainingParallelism;

@end


/**
 *  A suggestion by the service to the worker to dynamically split the WorkItem.
 */
@interface GTLRDataflow_ApproximateSplitRequest : GTLRObject

/**
 *  A fraction at which to split the work item, from 0.0 (beginning of the
 *  input) to 1.0 (end of the input).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fractionConsumed;

/**
 *  The fraction of the remainder of work to split the work item at, from 0.0
 *  (split at the current position) to 1.0 (end of the input).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fractionOfRemainder;

/** A Position at which to split the work item. */
@property(nonatomic, strong, nullable) GTLRDataflow_Position *position;

@end


/**
 *  A structured message reporting an autoscaling decision made by the Dataflow
 *  service.
 */
@interface GTLRDataflow_AutoscalingEvent : GTLRObject

/**
 *  The current number of workers the job has.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *currentNumWorkers;

/**
 *  A message describing why the system decided to adjust the current
 *  number of workers, why it failed, or why the system decided to
 *  not make any changes to the number of workers.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_StructuredMessage *descriptionProperty;

/**
 *  The type of autoscaling event to report.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_AutoscalingEvent_EventType_ActuationFailure The
 *        ACTUATION_FAILURE type should be used when we want to report
 *        an error to the user indicating why the current number of workers
 *        in the pool could not be changed.
 *        Displayed in the current status and history widgets. (Value:
 *        "ACTUATION_FAILURE")
 *    @arg @c kGTLRDataflow_AutoscalingEvent_EventType_CurrentNumWorkersChanged
 *        The CURRENT_NUM_WORKERS_CHANGED type should be used when actual worker
 *        pool size has been changed, but the target_num_workers has not
 *        changed. (Value: "CURRENT_NUM_WORKERS_CHANGED")
 *    @arg @c kGTLRDataflow_AutoscalingEvent_EventType_NoChange Used when we
 *        want to report to the user a reason why we are
 *        not currently adjusting the number of workers.
 *        Should specify both target_num_workers, current_num_workers and a
 *        decision_message. (Value: "NO_CHANGE")
 *    @arg @c kGTLRDataflow_AutoscalingEvent_EventType_TargetNumWorkersChanged
 *        The TARGET_NUM_WORKERS_CHANGED type should be used when the target
 *        worker pool size has changed at the start of an actuation. An event
 *        should always be specified as TARGET_NUM_WORKERS_CHANGED if it
 *        reflects
 *        a change in the target_num_workers. (Value:
 *        "TARGET_NUM_WORKERS_CHANGED")
 *    @arg @c kGTLRDataflow_AutoscalingEvent_EventType_TypeUnknown Default type
 *        for the enum. Value should never be returned. (Value: "TYPE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *eventType;

/**
 *  The target number of workers the worker pool wants to resize to use.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *targetNumWorkers;

/**
 *  The time this event was emitted to indicate a new target or current
 *  num_workers value.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *time;

/**
 *  A short and friendly name for the worker pool this event refers to,
 *  populated from the value of PoolStageRelation::user_pool_name.
 */
@property(nonatomic, copy, nullable) NSString *workerPool;

@end


/**
 *  Settings for WorkerPool autoscaling.
 */
@interface GTLRDataflow_AutoscalingSettings : GTLRObject

/**
 *  The algorithm to use for autoscaling.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmBasic
 *        Increase worker count over time to reduce job execution time. (Value:
 *        "AUTOSCALING_ALGORITHM_BASIC")
 *    @arg @c kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmNone
 *        Disable autoscaling. (Value: "AUTOSCALING_ALGORITHM_NONE")
 *    @arg @c kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmUnknown
 *        The algorithm is unknown, or unspecified. (Value:
 *        "AUTOSCALING_ALGORITHM_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *algorithm;

/**
 *  The maximum number of workers to cap scaling at.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxNumWorkers;

@end


/**
 *  Metadata for a BigQuery connector used by the job.
 */
@interface GTLRDataflow_BigQueryIODetails : GTLRObject

/** Dataset accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *dataset;

/** Project accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Query used to access data in the connection. */
@property(nonatomic, copy, nullable) NSString *query;

/** Table accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *table;

@end


/**
 *  Metadata for a BigTable connector used by the job.
 */
@interface GTLRDataflow_BigTableIODetails : GTLRObject

/** InstanceId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *instanceId;

/** ProjectId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** TableId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *tableId;

@end


/**
 *  Description of an interstitial value between transforms in an execution
 *  stage.
 */
@interface GTLRDataflow_ComponentSource : GTLRObject

/** Dataflow service generated name for this source. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  User name for the original user transform or collection with which this
 *  source is most closely associated.
 */
@property(nonatomic, copy, nullable) NSString *originalTransformOrCollection;

/**
 *  Human-readable name for this transform; may be user or system generated.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  Description of a transform executed as part of an execution stage.
 */
@interface GTLRDataflow_ComponentTransform : GTLRObject

/** Dataflow service generated name for this source. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  User name for the original user transform with which this transform is
 *  most closely associated.
 */
@property(nonatomic, copy, nullable) NSString *originalTransform;

/**
 *  Human-readable name for this transform; may be user or system generated.
 */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  All configuration data for a particular Computation.
 */
@interface GTLRDataflow_ComputationTopology : GTLRObject

/** The ID of the computation. */
@property(nonatomic, copy, nullable) NSString *computationId;

/** The inputs to the computation. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StreamLocation *> *inputs;

/** The key ranges processed by the computation. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_KeyRangeLocation *> *keyRanges;

/** The outputs from the computation. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StreamLocation *> *outputs;

/** The state family values. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StateFamilyConfig *> *stateFamilies;

/** The system stage name. */
@property(nonatomic, copy, nullable) NSString *systemStageName;

@end


/**
 *  A position that encapsulates an inner position and an index for the inner
 *  position. A ConcatPosition can be used by a reader of a source that
 *  encapsulates a set of other sources.
 */
@interface GTLRDataflow_ConcatPosition : GTLRObject

/**
 *  Index of the inner source.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *index;

/** Position within the inner source. */
@property(nonatomic, strong, nullable) GTLRDataflow_Position *position;

@end


/**
 *  CounterMetadata includes all static non-name non-value counter attributes.
 */
@interface GTLRDataflow_CounterMetadata : GTLRObject

/**
 *  Human-readable description of the counter semantics.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Counter aggregation kind.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_And Aggregated value represents
 *        the logical 'and' of all contributed values. (Value: "AND")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Distribution Aggregated value
 *        captures statistics about a distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Invalid Counter aggregation
 *        kind was not set. (Value: "INVALID")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_LatestValue Aggregated value
 *        tracks the latest value of a variable. (Value: "LATEST_VALUE")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Max Aggregated value is the max
 *        of all contributed values. (Value: "MAX")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Mean Aggregated value is the
 *        mean of all contributed values. (Value: "MEAN")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Min Aggregated value is the min
 *        of all contributed values. (Value: "MIN")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Or Aggregated value represents
 *        the logical 'or' of all contributed values. (Value: "OR")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Set Aggregated value is a set
 *        of unique contributed values. (Value: "SET")
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Sum Aggregated value is the sum
 *        of all contributed values. (Value: "SUM")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** A string referring to the unit type. */
@property(nonatomic, copy, nullable) NSString *otherUnits;

/**
 *  System defined Units, see above enum.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Bytes Counter returns
 *        a value in bytes. (Value: "BYTES")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_BytesPerSec Counter
 *        returns a value in bytes per second. (Value: "BYTES_PER_SEC")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Microseconds Counter
 *        returns a value in microseconds. (Value: "MICROSECONDS")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Milliseconds Counter
 *        returns a value in milliseconds. (Value: "MILLISECONDS")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Nanoseconds Counter
 *        returns a value in nanoseconds. (Value: "NANOSECONDS")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_TimestampMsec Counter
 *        returns a timestamp in milliseconds. (Value: "TIMESTAMP_MSEC")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_TimestampNsec Counter
 *        returns a timestamp in nanoseconds. (Value: "TIMESTAMP_NSEC")
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_TimestampUsec Counter
 *        returns a timestamp in microseconds. (Value: "TIMESTAMP_USEC")
 */
@property(nonatomic, copy, nullable) NSString *standardUnits;

@end


/**
 *  Identifies a counter within a per-job namespace. Counters whose structured
 *  names are the same get merged into a single value for the job.
 */
@interface GTLRDataflow_CounterStructuredName : GTLRObject

/** Name of the optimized step being executed by the workers. */
@property(nonatomic, copy, nullable) NSString *componentStepName;

/** Name of the stage. An execution step contains multiple component steps. */
@property(nonatomic, copy, nullable) NSString *executionStepName;

/**
 *  Index of an input collection that's being read from/written to as a side
 *  input.
 *  The index identifies a step's side inputs starting by 1 (e.g. the first
 *  side input has input_index 1, the third has input_index 3).
 *  Side inputs are identified by a pair of (original_step_name, input_index).
 *  This field helps uniquely identify them.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *inputIndex;

/**
 *  Counter name. Not necessarily globally-unique, but unique within the
 *  context of the other fields.
 *  Required.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  One of the standard Origins defined above.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterStructuredName_Origin_System Counter was
 *        created by the Dataflow system. (Value: "SYSTEM")
 *    @arg @c kGTLRDataflow_CounterStructuredName_Origin_User Counter was
 *        created by the user. (Value: "USER")
 */
@property(nonatomic, copy, nullable) NSString *origin;

/**
 *  The step name requesting an operation, such as GBK.
 *  I.e. the ParDo causing a read/write from shuffle to occur, or a
 *  read from side inputs.
 */
@property(nonatomic, copy, nullable) NSString *originalRequestingStepName;

/**
 *  System generated name of the original step in the user's graph, before
 *  optimization.
 */
@property(nonatomic, copy, nullable) NSString *originalStepName;

/** A string containing a more specific namespace of the counter's origin. */
@property(nonatomic, copy, nullable) NSString *originNamespace;

/**
 *  Portion of this counter, either key or value.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterStructuredName_Portion_All Counter portion
 *        has not been set. (Value: "ALL")
 *    @arg @c kGTLRDataflow_CounterStructuredName_Portion_Key Counter reports a
 *        key. (Value: "KEY")
 *    @arg @c kGTLRDataflow_CounterStructuredName_Portion_Value Counter reports
 *        a value. (Value: "VALUE")
 */
@property(nonatomic, copy, nullable) NSString *portion;

/** ID of a particular worker. */
@property(nonatomic, copy, nullable) NSString *workerId;

@end


/**
 *  A single message which encapsulates structured name and metadata for a given
 *  counter.
 */
@interface GTLRDataflow_CounterStructuredNameAndMetadata : GTLRObject

/** Metadata associated with a counter */
@property(nonatomic, strong, nullable) GTLRDataflow_CounterMetadata *metadata;

/** Structured name of the counter. */
@property(nonatomic, strong, nullable) GTLRDataflow_CounterStructuredName *name;

@end


/**
 *  An update to a Counter sent from a worker.
 */
@interface GTLRDataflow_CounterUpdate : GTLRObject

/**
 *  Boolean value for And, Or.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolean;

/**
 *  True if this counter is reported as the total cumulative aggregate
 *  value accumulated since the worker started working on this WorkItem.
 *  By default this is false, indicating that this counter is reported
 *  as a delta.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cumulative;

/** Distribution data */
@property(nonatomic, strong, nullable) GTLRDataflow_DistributionUpdate *distribution;

/**
 *  Floating point value for Sum, Max, Min.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *floatingPoint;

/** List of floating point numbers, for Set. */
@property(nonatomic, strong, nullable) GTLRDataflow_FloatingPointList *floatingPointList;

/** Floating point mean aggregation value for Mean. */
@property(nonatomic, strong, nullable) GTLRDataflow_FloatingPointMean *floatingPointMean;

/** Integer value for Sum, Max, Min. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *integer;

/** Gauge data */
@property(nonatomic, strong, nullable) GTLRDataflow_IntegerGauge *integerGauge;

/** List of integers, for Set. */
@property(nonatomic, strong, nullable) GTLRDataflow_IntegerList *integerList;

/** Integer mean aggregation value for Mean. */
@property(nonatomic, strong, nullable) GTLRDataflow_IntegerMean *integerMean;

/**
 *  Value for internally-defined counters used by the Dataflow service.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id internal;

/** Counter name and aggregation type. */
@property(nonatomic, strong, nullable) GTLRDataflow_NameAndKind *nameAndKind;

/**
 *  The service-generated short identifier for this counter.
 *  The short_id -> (name, metadata) mapping is constant for the lifetime of
 *  a job.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *shortId;

/** List of strings, for Set. */
@property(nonatomic, strong, nullable) GTLRDataflow_StringList *stringList;

/** Counter structured name and metadata. */
@property(nonatomic, strong, nullable) GTLRDataflow_CounterStructuredNameAndMetadata *structuredNameAndMetadata;

@end


/**
 *  Modeled after information exposed by /proc/stat.
 */
@interface GTLRDataflow_CPUTime : GTLRObject

/**
 *  Average CPU utilization rate (% non-idle cpu / second) since previous
 *  sample.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rate;

/** Timestamp of the measurement. */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

/**
 *  Total active CPU time across all cores (ie., non-idle) in milliseconds
 *  since start-up.
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalMs;

@end


/**
 *  A request to create a Cloud Dataflow job from a template.
 */
@interface GTLRDataflow_CreateJobFromTemplateRequest : GTLRObject

/** The runtime environment for the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_RuntimeEnvironment *environment;

/**
 *  Required. A Cloud Storage path to the template from which to
 *  create the job.
 *  Must be a valid Cloud Storage URL, beginning with `gs://`.
 */
@property(nonatomic, copy, nullable) NSString *gcsPath;

/** Required. The job name to use for the created job. */
@property(nonatomic, copy, nullable) NSString *jobName;

/** The location to which to direct the request. */
@property(nonatomic, copy, nullable) NSString *location;

/** The runtime parameters to pass to the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_CreateJobFromTemplateRequest_Parameters *parameters;

@end


/**
 *  The runtime parameters to pass to the job.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_CreateJobFromTemplateRequest_Parameters : GTLRObject
@end


/**
 *  Identifies the location of a custom souce.
 */
@interface GTLRDataflow_CustomSourceLocation : GTLRObject

/**
 *  Whether this source is stateful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *stateful;

@end


/**
 *  Data disk assignment for a given VM instance.
 */
@interface GTLRDataflow_DataDiskAssignment : GTLRObject

/**
 *  Mounted data disks. The order is important a data disk's 0-based index in
 *  this list defines which persistent directory the disk is mounted to, for
 *  example the list of { "myproject-1014-104817-4c2-harness-0-disk-0" },
 *  { "myproject-1014-104817-4c2-harness-0-disk-1" }.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dataDisks;

/**
 *  VM instance name the data disks mounted to, for example
 *  "myproject-1014-104817-4c2-harness-0".
 */
@property(nonatomic, copy, nullable) NSString *vmInstance;

@end


/**
 *  Metadata for a Datastore connector used by the job.
 */
@interface GTLRDataflow_DatastoreIODetails : GTLRObject

/**
 *  Namespace used in the connection.
 *
 *  Remapped to 'namespaceProperty' to avoid language reserved word 'namespace'.
 */
@property(nonatomic, copy, nullable) NSString *namespaceProperty;

/** ProjectId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *projectId;

@end


/**
 *  Specification of one of the bundles produced as a result of splitting
 *  a Source (e.g. when executing a SourceSplitRequest, or when
 *  splitting an active task using WorkItemStatus.dynamic_source_split),
 *  relative to the source being split.
 */
@interface GTLRDataflow_DerivedSource : GTLRObject

/**
 *  What source to base the produced source on (if any).
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeChildOfCurrent
 *        Produce a Source based on the Source being split. (Value:
 *        "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT")
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeIndependent
 *        Produce a completely independent Source with no base. (Value:
 *        "SOURCE_DERIVATION_MODE_INDEPENDENT")
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeSiblingOfCurrent
 *        Produce a Source based on the base of the Source being split. (Value:
 *        "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT")
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeUnknown
 *        The source derivation is unknown, or unspecified. (Value:
 *        "SOURCE_DERIVATION_MODE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *derivationMode;

/** Specification of the source. */
@property(nonatomic, strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  Describes the data disk used by a workflow job.
 */
@interface GTLRDataflow_Disk : GTLRObject

/**
 *  Disk storage type, as defined by Google Compute Engine. This
 *  must be a disk type appropriate to the project and zone in which
 *  the workers will run. If unknown or unspecified, the service
 *  will attempt to choose a reasonable default.
 *  For example, the standard persistent disk type is a resource name
 *  typically ending in "pd-standard". If SSD persistent disks are
 *  available, the resource name typically ends with "pd-ssd". The
 *  actual valid values are defined the Google Compute Engine API,
 *  not by the Cloud Dataflow API; consult the Google Compute Engine
 *  documentation for more information about determining the set of
 *  available disk types for a particular project and zone.
 *  Google Compute Engine Disk types are local to a particular
 *  project in a particular zone, and so the resource name will
 *  typically look something like this:
 *  compute.googleapis.com/projects/project-id/zones/zone/diskTypes/pd-standard
 */
@property(nonatomic, copy, nullable) NSString *diskType;

/** Directory in a VM where disk is mounted. */
@property(nonatomic, copy, nullable) NSString *mountPoint;

/**
 *  Size of disk in GB. If zero or unspecified, the service will
 *  attempt to choose a reasonable default.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeGb;

@end


/**
 *  Data provided with a pipeline or transform to provide descriptive info.
 */
@interface GTLRDataflow_DisplayData : GTLRObject

/**
 *  Contains value if the data is of a boolean type.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** Contains value if the data is of duration type. */
@property(nonatomic, strong, nullable) GTLRDuration *durationValue;

/**
 *  Contains value if the data is of float type.
 *
 *  Uses NSNumber of floatValue.
 */
@property(nonatomic, strong, nullable) NSNumber *floatValue;

/**
 *  Contains value if the data is of int64 type.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/** Contains value if the data is of java class type. */
@property(nonatomic, copy, nullable) NSString *javaClassValue;

/**
 *  The key identifying the display data.
 *  This is intended to be used as a label for the display data
 *  when viewed in a dax monitoring system.
 */
@property(nonatomic, copy, nullable) NSString *key;

/** An optional label to display in a dax UI for the element. */
@property(nonatomic, copy, nullable) NSString *label;

/**
 *  The namespace for the key. This is usually a class name or programming
 *  language namespace (i.e. python module) which defines the display data.
 *  This allows a dax monitoring system to specially handle the data
 *  and perform custom rendering.
 *
 *  Remapped to 'namespaceProperty' to avoid language reserved word 'namespace'.
 */
@property(nonatomic, copy, nullable) NSString *namespaceProperty;

/**
 *  A possible additional shorter value to display.
 *  For example a java_class_name_value of com.mypackage.MyDoFn
 *  will be stored with MyDoFn as the short_str_value and
 *  com.mypackage.MyDoFn as the java_class_name value.
 *  short_str_value can be displayed and java_class_name_value
 *  will be displayed as a tooltip.
 */
@property(nonatomic, copy, nullable) NSString *shortStrValue;

/** Contains value if the data is of string type. */
@property(nonatomic, copy, nullable) NSString *strValue;

/** Contains value if the data is of timestamp type. */
@property(nonatomic, strong, nullable) GTLRDateTime *timestampValue;

/** An optional full URL. */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  A metric value representing a distribution.
 */
@interface GTLRDataflow_DistributionUpdate : GTLRObject

/** The count of the number of elements present in the distribution. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *count;

/** (Optional) Histogram of value counts for the distribution. */
@property(nonatomic, strong, nullable) GTLRDataflow_Histogram *histogram;

/** The maximum value present in the distribution. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *max;

/** The minimum value present in the distribution. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *min;

/**
 *  Use an int64 since we'd prefer the added precision. If overflow is a common
 *  problem we can detect it and use an additional int64 or a double.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *sum;

/**
 *  Use a double since the sum of squares is likely to overflow int64.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquares;

@end


/**
 *  When a task splits using WorkItemStatus.dynamic_source_split, this
 *  message describes the two parts of the split relative to the
 *  description of the current task's input.
 */
@interface GTLRDataflow_DynamicSourceSplit : GTLRObject

/**
 *  Primary part (continued to be processed by worker).
 *  Specified relative to the previously-current source.
 *  Becomes current.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_DerivedSource *primary;

/**
 *  Residual part (returned to the pool of work).
 *  Specified relative to the previously-current source.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_DerivedSource *residual;

@end


/**
 *  Describes the environment in which a Dataflow Job runs.
 */
@interface GTLRDataflow_Environment : GTLRObject

/**
 *  The type of cluster manager API to use. If unknown or
 *  unspecified, the service will attempt to choose a reasonable
 *  default. This should be in the form of the API service name,
 *  e.g. "compute.googleapis.com".
 */
@property(nonatomic, copy, nullable) NSString *clusterManagerApiService;

/**
 *  The dataset for the current project where various workflow
 *  related tables are stored.
 *  The supported resource type is:
 *  Google BigQuery:
 *  bigquery.googleapis.com/{dataset}
 */
@property(nonatomic, copy, nullable) NSString *dataset;

/** The list of experiments to enable. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *experiments;

/** Experimental settings. */
@property(nonatomic, strong, nullable) GTLRDataflow_Environment_InternalExperiments *internalExperiments;

/**
 *  The Cloud Dataflow SDK pipeline options specified by the user. These
 *  options are passed through the service and are used to recreate the
 *  SDK pipeline options on the worker in a language agnostic and platform
 *  independent way.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Environment_SdkPipelineOptions *sdkPipelineOptions;

/** Identity to run virtual machines as. Defaults to the default account. */
@property(nonatomic, copy, nullable) NSString *serviceAccountEmail;

/**
 *  The prefix of the resources the system should use for temporary
 *  storage. The system will append the suffix "/temp-{JOBNAME} to
 *  this resource prefix, where {JOBNAME} is the value of the
 *  job_name field. The resulting bucket and object prefix is used
 *  as the prefix of the resources used to store temporary data
 *  needed during the job execution. NOTE: This will override the
 *  value in taskrunner_settings.
 *  The supported resource type is:
 *  Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(nonatomic, copy, nullable) NSString *tempStoragePrefix;

/** A description of the process that generated the request. */
@property(nonatomic, strong, nullable) GTLRDataflow_Environment_UserAgent *userAgent;

/**
 *  A structure describing which components and their versions of the service
 *  are required in order to run the job.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Environment_Version *version;

/**
 *  The worker pools. At least one "harness" worker pool must be
 *  specified in order for the job to have workers.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkerPool *> *workerPools;

@end


/**
 *  Experimental settings.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Environment_InternalExperiments : GTLRObject
@end


/**
 *  The Cloud Dataflow SDK pipeline options specified by the user. These
 *  options are passed through the service and are used to recreate the
 *  SDK pipeline options on the worker in a language agnostic and platform
 *  independent way.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Environment_SdkPipelineOptions : GTLRObject
@end


/**
 *  A description of the process that generated the request.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Environment_UserAgent : GTLRObject
@end


/**
 *  A structure describing which components and their versions of the service
 *  are required in order to run the job.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Environment_Version : GTLRObject
@end


/**
 *  A message describing the state of a particular execution stage.
 */
@interface GTLRDataflow_ExecutionStageState : GTLRObject

/** The time at which the stage transitioned to this state. */
@property(nonatomic, strong, nullable) GTLRDateTime *currentStateTime;

/** The name of the execution stage. */
@property(nonatomic, copy, nullable) NSString *executionStageName;

/**
 *  Executions stage states allow the same set of values as JobState.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateCancelled
 *        `JOB_STATE_CANCELLED` indicates that the job has been explicitly
 *        cancelled. This is a terminal job state. This state may only be
 *        set via a Cloud Dataflow `UpdateJob` call, and only if the job has not
 *        yet reached another terminal state. (Value: "JOB_STATE_CANCELLED")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateCancelling
 *        `JOB_STATE_CANCELLING` indicates that the job has been explicitly
 *        cancelled
 *        and is in the process of stopping. Jobs that are cancelling may only
 *        transition to `JOB_STATE_CANCELLED` or `JOB_STATE_FAILED`. (Value:
 *        "JOB_STATE_CANCELLING")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateDone
 *        `JOB_STATE_DONE` indicates that the job has successfully completed.
 *        This is a terminal job state. This state may be set by the Cloud
 *        Dataflow
 *        service, as a transition from `JOB_STATE_RUNNING`. It may also be set
 *        via a
 *        Cloud Dataflow `UpdateJob` call, if the job has not yet reached a
 *        terminal
 *        state. (Value: "JOB_STATE_DONE")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateDrained
 *        `JOB_STATE_DRAINED` indicates that the job has been drained.
 *        A drained job terminated by stopping pulling from its input sources
 *        and
 *        processing any data that remained in-flight when draining was
 *        requested.
 *        This state is a terminal state, may only be set by the Cloud Dataflow
 *        service, and only as a transition from `JOB_STATE_DRAINING`. (Value:
 *        "JOB_STATE_DRAINED")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateDraining
 *        `JOB_STATE_DRAINING` indicates that the job is in the process of
 *        draining.
 *        A draining job has stopped pulling from its input sources and is
 *        processing
 *        any data that remains in-flight. This state may be set via a Cloud
 *        Dataflow
 *        `UpdateJob` call, but only as a transition from `JOB_STATE_RUNNING`.
 *        Jobs
 *        that are draining may only transition to `JOB_STATE_DRAINED`,
 *        `JOB_STATE_CANCELLED`, or `JOB_STATE_FAILED`. (Value:
 *        "JOB_STATE_DRAINING")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateFailed
 *        `JOB_STATE_FAILED` indicates that the job has failed. This is a
 *        terminal job state. This state may only be set by the Cloud Dataflow
 *        service, and only as a transition from `JOB_STATE_RUNNING`. (Value:
 *        "JOB_STATE_FAILED")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStatePending
 *        `JOB_STATE_PENDING` indicates that the job has been created but is not
 *        yet
 *        running. Jobs that are pending may only transition to
 *        `JOB_STATE_RUNNING`,
 *        or `JOB_STATE_FAILED`. (Value: "JOB_STATE_PENDING")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateQueued
 *        `JOB_STATE_QUEUED` indicates that the job has been created but is
 *        being
 *        delayed until launch. Jobs that are queued may only transition to
 *        `JOB_STATE_PENDING` or `JOB_STATE_CANCELLED`. (Value:
 *        "JOB_STATE_QUEUED")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateRunning
 *        `JOB_STATE_RUNNING` indicates that the job is currently running.
 *        (Value: "JOB_STATE_RUNNING")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateStopped
 *        `JOB_STATE_STOPPED` indicates that the job has not
 *        yet started to run. (Value: "JOB_STATE_STOPPED")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateUnknown
 *        The job's run state isn't specified. (Value: "JOB_STATE_UNKNOWN")
 *    @arg @c kGTLRDataflow_ExecutionStageState_ExecutionStageState_JobStateUpdated
 *        `JOB_STATE_UPDATED` indicates that the job was successfully updated,
 *        meaning that this job was stopped and another job was started,
 *        inheriting
 *        state from this one. This is a terminal job state. This state may only
 *        be
 *        set by the Cloud Dataflow service, and only as a transition from
 *        `JOB_STATE_RUNNING`. (Value: "JOB_STATE_UPDATED")
 */
@property(nonatomic, copy, nullable) NSString *executionStageState;

@end


/**
 *  Description of the composing transforms, names/ids, and input/outputs of a
 *  stage of execution. Some composing transforms and sources may have been
 *  generated by the Dataflow service during execution planning.
 */
@interface GTLRDataflow_ExecutionStageSummary : GTLRObject

/**
 *  Collections produced and consumed by component transforms of this stage.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ComponentSource *> *componentSource;

/** Transforms that comprise this execution stage. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ComponentTransform *> *componentTransform;

/**
 *  Dataflow service generated id for this stage.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** Input sources for this stage. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StageSource *> *inputSource;

/**
 *  Type of tranform this stage is executing.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_ConstantKind Constructs
 *        from a constant value, such as with Create.of. (Value:
 *        "CONSTANT_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_FlattenKind Flatten
 *        transform. (Value: "FLATTEN_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_GroupByKeyKind Group By
 *        Key transform. (Value: "GROUP_BY_KEY_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_ParDoKind ParDo
 *        transform. (Value: "PAR_DO_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_ReadKind Read transform.
 *        (Value: "READ_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_ShuffleKind Opening or
 *        closing a shuffle session, often as part of a GroupByKey. (Value:
 *        "SHUFFLE_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_SingletonKind Creates a
 *        Singleton view of a collection. (Value: "SINGLETON_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_UnknownKind Unrecognized
 *        transform type. (Value: "UNKNOWN_KIND")
 *    @arg @c kGTLRDataflow_ExecutionStageSummary_Kind_WriteKind Write
 *        transform. (Value: "WRITE_KIND")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** Dataflow service generated name for this stage. */
@property(nonatomic, copy, nullable) NSString *name;

/** Output sources for this stage. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StageSource *> *outputSource;

@end


/**
 *  Indicates which location failed to respond to a request for data.
 */
@interface GTLRDataflow_FailedLocation : GTLRObject

/** The name of the failed location. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Metadata for a File connector used by the job.
 */
@interface GTLRDataflow_FileIODetails : GTLRObject

/** File Pattern used to access files by the connector. */
@property(nonatomic, copy, nullable) NSString *filePattern;

@end


/**
 *  An instruction that copies its inputs (zero or more) to its (single) output.
 */
@interface GTLRDataflow_FlattenInstruction : GTLRObject

/** Describes the inputs to the flatten instruction. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_InstructionInput *> *inputs;

@end


/**
 *  A metric value representing a list of floating point numbers.
 */
@interface GTLRDataflow_FloatingPointList : GTLRObject

/**
 *  Elements of the list.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *elements;

@end


/**
 *  A representation of a floating point mean metric contribution.
 */
@interface GTLRDataflow_FloatingPointMean : GTLRObject

/** The number of values being aggregated. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *count;

/**
 *  The sum of all values being aggregated.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sum;

@end


/**
 *  Request to get updated debug configuration for component.
 */
@interface GTLRDataflow_GetDebugConfigRequest : GTLRObject

/**
 *  The internal component id for which debug configuration is
 *  requested.
 */
@property(nonatomic, copy, nullable) NSString *componentId;

/** The location which contains the job specified by job_id. */
@property(nonatomic, copy, nullable) NSString *location;

/** The worker id, i.e., VM hostname. */
@property(nonatomic, copy, nullable) NSString *workerId;

@end


/**
 *  Response to a get debug configuration request.
 */
@interface GTLRDataflow_GetDebugConfigResponse : GTLRObject

/** The encoded debug configuration for the requested component. */
@property(nonatomic, copy, nullable) NSString *config;

@end


/**
 *  The response to a GetTemplate request.
 */
@interface GTLRDataflow_GetTemplateResponse : GTLRObject

/**
 *  The template metadata describing the template name, available
 *  parameters, etc.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_TemplateMetadata *metadata;

/**
 *  The status of the get template request. Any problems with the
 *  request will be indicated in the error_details.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Status *status;

@end


/**
 *  Histogram of value counts for a distribution.
 *  Buckets have an inclusive lower bound and exclusive upper bound and use
 *  "1,2,5 bucketing": The first bucket range is from [0,1) and all subsequent
 *  bucket boundaries are powers of ten multiplied by 1, 2, or 5. Thus, bucket
 *  boundaries are 0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, ...
 *  Negative values are not supported.
 */
@interface GTLRDataflow_Histogram : GTLRObject

/**
 *  Counts of values in each bucket. For efficiency, prefix and trailing
 *  buckets with count = 0 are elided. Buckets can store the full range of
 *  values of an unsigned long, with ULLONG_MAX falling into the 59th bucket
 *  with range [1e19, 2e19).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  Starting index of first stored bucket. The non-inclusive upper-bound of
 *  the ith bucket is given by:
 *  pow(10,(i-first_bucket_offset)/3) * (1,2,5)[(i-first_bucket_offset)%3]
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *firstBucketOffset;

@end


/**
 *  An input of an instruction, as a reference to an output of a
 *  producer instruction.
 */
@interface GTLRDataflow_InstructionInput : GTLRObject

/**
 *  The output index (origin zero) within the producer.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *outputNum;

/**
 *  The index (origin zero) of the parallel instruction that produces
 *  the output to be consumed by this input. This index is relative
 *  to the list of instructions in this input's instruction's
 *  containing MapTask.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *producerInstructionIndex;

@end


/**
 *  An output of an instruction.
 */
@interface GTLRDataflow_InstructionOutput : GTLRObject

/** The codec to use to encode data being written via this output. */
@property(nonatomic, strong, nullable) GTLRDataflow_InstructionOutput_Codec *codec;

/** The user-provided name of this output. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  For system-generated byte and mean byte metrics, certain instructions
 *  should only report the key size.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *onlyCountKeyBytes;

/**
 *  For system-generated byte and mean byte metrics, certain instructions
 *  should only report the value size.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *onlyCountValueBytes;

/**
 *  System-defined name for this output in the original workflow graph.
 *  Outputs that do not contribute to an original instruction do not set this.
 */
@property(nonatomic, copy, nullable) NSString *originalName;

/**
 *  System-defined name of this output.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *systemName;

@end


/**
 *  The codec to use to encode data being written via this output.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_InstructionOutput_Codec : GTLRObject
@end


/**
 *  A metric value representing temporal values of a variable.
 */
@interface GTLRDataflow_IntegerGauge : GTLRObject

/**
 *  The time at which this value was measured. Measured as msecs from epoch.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

/** The value of the variable represented by this gauge. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *value;

@end


/**
 *  A metric value representing a list of integers.
 */
@interface GTLRDataflow_IntegerList : GTLRObject

/** Elements of the list. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SplitInt64 *> *elements;

@end


/**
 *  A representation of an integer mean metric contribution.
 */
@interface GTLRDataflow_IntegerMean : GTLRObject

/** The number of values being aggregated. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *count;

/** The sum of all values being aggregated. */
@property(nonatomic, strong, nullable) GTLRDataflow_SplitInt64 *sum;

@end


/**
 *  Defines a job to be run by the Cloud Dataflow service.
 */
@interface GTLRDataflow_Job : GTLRObject

/**
 *  The client's unique identifier of the job, re-used across retried attempts.
 *  If this field is set, the service will ensure its uniqueness.
 *  The request to create a job will fail if the service has knowledge of a
 *  previously submitted job with the same client's ID and job name.
 *  The caller may use this field to ensure idempotence of job
 *  creation across retried attempts to create a job.
 *  By default, the field is empty and, in that case, the service ignores it.
 */
@property(nonatomic, copy, nullable) NSString *clientRequestId;

/**
 *  If this is specified, the job's initial state is populated from the given
 *  snapshot.
 */
@property(nonatomic, copy, nullable) NSString *createdFromSnapshotId;

/**
 *  The timestamp when the job was initially created. Immutable and set by the
 *  Cloud Dataflow service.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *createTime;

/**
 *  The current state of the job.
 *  Jobs are created in the `JOB_STATE_STOPPED` state unless otherwise
 *  specified.
 *  A job in the `JOB_STATE_RUNNING` state may asynchronously enter a
 *  terminal state. After a job has reached a terminal state, no
 *  further state updates may be made.
 *  This field may be mutated by the Cloud Dataflow service;
 *  callers cannot mutate it.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateCancelled
 *        `JOB_STATE_CANCELLED` indicates that the job has been explicitly
 *        cancelled. This is a terminal job state. This state may only be
 *        set via a Cloud Dataflow `UpdateJob` call, and only if the job has not
 *        yet reached another terminal state. (Value: "JOB_STATE_CANCELLED")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateCancelling
 *        `JOB_STATE_CANCELLING` indicates that the job has been explicitly
 *        cancelled
 *        and is in the process of stopping. Jobs that are cancelling may only
 *        transition to `JOB_STATE_CANCELLED` or `JOB_STATE_FAILED`. (Value:
 *        "JOB_STATE_CANCELLING")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateDone `JOB_STATE_DONE`
 *        indicates that the job has successfully completed.
 *        This is a terminal job state. This state may be set by the Cloud
 *        Dataflow
 *        service, as a transition from `JOB_STATE_RUNNING`. It may also be set
 *        via a
 *        Cloud Dataflow `UpdateJob` call, if the job has not yet reached a
 *        terminal
 *        state. (Value: "JOB_STATE_DONE")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateDrained `JOB_STATE_DRAINED`
 *        indicates that the job has been drained.
 *        A drained job terminated by stopping pulling from its input sources
 *        and
 *        processing any data that remained in-flight when draining was
 *        requested.
 *        This state is a terminal state, may only be set by the Cloud Dataflow
 *        service, and only as a transition from `JOB_STATE_DRAINING`. (Value:
 *        "JOB_STATE_DRAINED")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateDraining
 *        `JOB_STATE_DRAINING` indicates that the job is in the process of
 *        draining.
 *        A draining job has stopped pulling from its input sources and is
 *        processing
 *        any data that remains in-flight. This state may be set via a Cloud
 *        Dataflow
 *        `UpdateJob` call, but only as a transition from `JOB_STATE_RUNNING`.
 *        Jobs
 *        that are draining may only transition to `JOB_STATE_DRAINED`,
 *        `JOB_STATE_CANCELLED`, or `JOB_STATE_FAILED`. (Value:
 *        "JOB_STATE_DRAINING")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateFailed `JOB_STATE_FAILED`
 *        indicates that the job has failed. This is a
 *        terminal job state. This state may only be set by the Cloud Dataflow
 *        service, and only as a transition from `JOB_STATE_RUNNING`. (Value:
 *        "JOB_STATE_FAILED")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStatePending `JOB_STATE_PENDING`
 *        indicates that the job has been created but is not yet
 *        running. Jobs that are pending may only transition to
 *        `JOB_STATE_RUNNING`,
 *        or `JOB_STATE_FAILED`. (Value: "JOB_STATE_PENDING")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateQueued `JOB_STATE_QUEUED`
 *        indicates that the job has been created but is being
 *        delayed until launch. Jobs that are queued may only transition to
 *        `JOB_STATE_PENDING` or `JOB_STATE_CANCELLED`. (Value:
 *        "JOB_STATE_QUEUED")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateRunning `JOB_STATE_RUNNING`
 *        indicates that the job is currently running. (Value:
 *        "JOB_STATE_RUNNING")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateStopped `JOB_STATE_STOPPED`
 *        indicates that the job has not
 *        yet started to run. (Value: "JOB_STATE_STOPPED")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateUnknown The job's run state
 *        isn't specified. (Value: "JOB_STATE_UNKNOWN")
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateUpdated `JOB_STATE_UPDATED`
 *        indicates that the job was successfully updated,
 *        meaning that this job was stopped and another job was started,
 *        inheriting
 *        state from this one. This is a terminal job state. This state may only
 *        be
 *        set by the Cloud Dataflow service, and only as a transition from
 *        `JOB_STATE_RUNNING`. (Value: "JOB_STATE_UPDATED")
 */
@property(nonatomic, copy, nullable) NSString *currentState;

/** The timestamp associated with the current state. */
@property(nonatomic, strong, nullable) GTLRDateTime *currentStateTime;

/** The environment for the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_Environment *environment;

/** Deprecated. */
@property(nonatomic, strong, nullable) GTLRDataflow_JobExecutionInfo *executionInfo;

/**
 *  The unique ID of this job.
 *  This field is set by the Cloud Dataflow service when the Job is
 *  created, and is immutable for the life of the job.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  This field is populated by the Dataflow service to support filtering jobs
 *  by the metadata values provided here. Populated for ListJobs and all GetJob
 *  views SUMMARY and higher.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_JobMetadata *jobMetadata;

/**
 *  User-defined labels for this job.
 *  The labels map can contain no more than 64 entries. Entries of the labels
 *  map are UTF8 strings that comply with the following restrictions:
 *  * Keys must conform to regexp: \\p{Ll}\\p{Lo}{0,62}
 *  * Values must conform to regexp: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  * Both keys and values are additionally constrained to be <= 128 bytes in
 *  size.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Job_Labels *labels;

/** The location that contains this job. */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The user-specified Cloud Dataflow job name.
 *  Only one Job with a given name may exist in a project at any
 *  given time. If a caller attempts to create a Job with the same
 *  name as an already-existing Job, the attempt returns the
 *  existing Job.
 *  The name must match the regular expression
 *  `[a-z]([-a-z0-9]{0,38}[a-z0-9])?`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Preliminary field: The format of this data may change at any time.
 *  A description of the user pipeline and stages through which it is executed.
 *  Created by Cloud Dataflow service. Only retrieved with
 *  JOB_VIEW_DESCRIPTION or JOB_VIEW_ALL.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_PipelineDescription *pipelineDescription;

/** The ID of the Cloud Platform project that the job belongs to. */
@property(nonatomic, copy, nullable) NSString *projectId;

/**
 *  If another job is an update of this job (and thus, this job is in
 *  `JOB_STATE_UPDATED`), this field contains the ID of that job.
 */
@property(nonatomic, copy, nullable) NSString *replacedByJobId;

/**
 *  If this job is an update of an existing job, this field is the job ID
 *  of the job it replaced.
 *  When sending a `CreateJobRequest`, you can update a job by specifying it
 *  here. The job named here is stopped, and its intermediate state is
 *  transferred to this job.
 */
@property(nonatomic, copy, nullable) NSString *replaceJobId;

/**
 *  The job's requested state.
 *  `UpdateJob` may be used to switch between the `JOB_STATE_STOPPED` and
 *  `JOB_STATE_RUNNING` states, by setting requested_state. `UpdateJob` may
 *  also be used to directly set a job's requested state to
 *  `JOB_STATE_CANCELLED` or `JOB_STATE_DONE`, irrevocably terminating the
 *  job if it has not already reached a terminal state.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateCancelled
 *        `JOB_STATE_CANCELLED` indicates that the job has been explicitly
 *        cancelled. This is a terminal job state. This state may only be
 *        set via a Cloud Dataflow `UpdateJob` call, and only if the job has not
 *        yet reached another terminal state. (Value: "JOB_STATE_CANCELLED")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateCancelling
 *        `JOB_STATE_CANCELLING` indicates that the job has been explicitly
 *        cancelled
 *        and is in the process of stopping. Jobs that are cancelling may only
 *        transition to `JOB_STATE_CANCELLED` or `JOB_STATE_FAILED`. (Value:
 *        "JOB_STATE_CANCELLING")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateDone `JOB_STATE_DONE`
 *        indicates that the job has successfully completed.
 *        This is a terminal job state. This state may be set by the Cloud
 *        Dataflow
 *        service, as a transition from `JOB_STATE_RUNNING`. It may also be set
 *        via a
 *        Cloud Dataflow `UpdateJob` call, if the job has not yet reached a
 *        terminal
 *        state. (Value: "JOB_STATE_DONE")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateDrained
 *        `JOB_STATE_DRAINED` indicates that the job has been drained.
 *        A drained job terminated by stopping pulling from its input sources
 *        and
 *        processing any data that remained in-flight when draining was
 *        requested.
 *        This state is a terminal state, may only be set by the Cloud Dataflow
 *        service, and only as a transition from `JOB_STATE_DRAINING`. (Value:
 *        "JOB_STATE_DRAINED")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateDraining
 *        `JOB_STATE_DRAINING` indicates that the job is in the process of
 *        draining.
 *        A draining job has stopped pulling from its input sources and is
 *        processing
 *        any data that remains in-flight. This state may be set via a Cloud
 *        Dataflow
 *        `UpdateJob` call, but only as a transition from `JOB_STATE_RUNNING`.
 *        Jobs
 *        that are draining may only transition to `JOB_STATE_DRAINED`,
 *        `JOB_STATE_CANCELLED`, or `JOB_STATE_FAILED`. (Value:
 *        "JOB_STATE_DRAINING")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateFailed `JOB_STATE_FAILED`
 *        indicates that the job has failed. This is a
 *        terminal job state. This state may only be set by the Cloud Dataflow
 *        service, and only as a transition from `JOB_STATE_RUNNING`. (Value:
 *        "JOB_STATE_FAILED")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStatePending
 *        `JOB_STATE_PENDING` indicates that the job has been created but is not
 *        yet
 *        running. Jobs that are pending may only transition to
 *        `JOB_STATE_RUNNING`,
 *        or `JOB_STATE_FAILED`. (Value: "JOB_STATE_PENDING")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateQueued `JOB_STATE_QUEUED`
 *        indicates that the job has been created but is being
 *        delayed until launch. Jobs that are queued may only transition to
 *        `JOB_STATE_PENDING` or `JOB_STATE_CANCELLED`. (Value:
 *        "JOB_STATE_QUEUED")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateRunning
 *        `JOB_STATE_RUNNING` indicates that the job is currently running.
 *        (Value: "JOB_STATE_RUNNING")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateStopped
 *        `JOB_STATE_STOPPED` indicates that the job has not
 *        yet started to run. (Value: "JOB_STATE_STOPPED")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateUnknown The job's run
 *        state isn't specified. (Value: "JOB_STATE_UNKNOWN")
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateUpdated
 *        `JOB_STATE_UPDATED` indicates that the job was successfully updated,
 *        meaning that this job was stopped and another job was started,
 *        inheriting
 *        state from this one. This is a terminal job state. This state may only
 *        be
 *        set by the Cloud Dataflow service, and only as a transition from
 *        `JOB_STATE_RUNNING`. (Value: "JOB_STATE_UPDATED")
 */
@property(nonatomic, copy, nullable) NSString *requestedState;

/**
 *  This field may be mutated by the Cloud Dataflow service;
 *  callers cannot mutate it.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ExecutionStageState *> *stageStates;

/**
 *  The timestamp when the job was started (transitioned to JOB_STATE_PENDING).
 *  Flexible resource scheduling jobs are started with some delay after job
 *  creation, so start_time is unset before start and is updated when the
 *  job is started by the Cloud Dataflow service. For other jobs, start_time
 *  always equals to create_time and is immutable and set by the Cloud Dataflow
 *  service.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/**
 *  Exactly one of step or steps_location should be specified.
 *  The top-level steps that constitute the entire job.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Step *> *steps;

/** The GCS location where the steps are stored. */
@property(nonatomic, copy, nullable) NSString *stepsLocation;

/**
 *  A set of files the system should be aware of that are used
 *  for temporary storage. These temporary files will be
 *  removed on job completion.
 *  No duplicates are allowed.
 *  No file patterns are supported.
 *  The supported files are:
 *  Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *tempFiles;

/**
 *  The map of transform name prefixes of the job to be replaced to the
 *  corresponding name prefixes of the new job.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Job_TransformNameMapping *transformNameMapping;

/**
 *  The type of Cloud Dataflow job.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_Job_Type_JobTypeBatch A batch job with a
 *        well-defined end point: data is read, data is
 *        processed, data is written, and the job is done. (Value:
 *        "JOB_TYPE_BATCH")
 *    @arg @c kGTLRDataflow_Job_Type_JobTypeStreaming A continuously streaming
 *        job with no end: data is read,
 *        processed, and written continuously. (Value: "JOB_TYPE_STREAMING")
 *    @arg @c kGTLRDataflow_Job_Type_JobTypeUnknown The type of the job is
 *        unspecified, or unknown. (Value: "JOB_TYPE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  User-defined labels for this job.
 *  The labels map can contain no more than 64 entries. Entries of the labels
 *  map are UTF8 strings that comply with the following restrictions:
 *  * Keys must conform to regexp: \\p{Ll}\\p{Lo}{0,62}
 *  * Values must conform to regexp: [\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}
 *  * Both keys and values are additionally constrained to be <= 128 bytes in
 *  size.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_Job_Labels : GTLRObject
@end


/**
 *  The map of transform name prefixes of the job to be replaced to the
 *  corresponding name prefixes of the new job.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_Job_TransformNameMapping : GTLRObject
@end


/**
 *  Additional information about how a Cloud Dataflow job will be executed that
 *  isn't contained in the submitted job.
 */
@interface GTLRDataflow_JobExecutionInfo : GTLRObject

/** A mapping from each stage to the information about that stage. */
@property(nonatomic, strong, nullable) GTLRDataflow_JobExecutionInfo_Stages *stages;

@end


/**
 *  A mapping from each stage to the information about that stage.
 *
 *  @note This class is documented as having more properties of
 *        GTLRDataflow_JobExecutionStageInfo. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_JobExecutionInfo_Stages : GTLRObject
@end


/**
 *  Contains information about how a particular
 *  google.dataflow.v1beta3.Step will be executed.
 */
@interface GTLRDataflow_JobExecutionStageInfo : GTLRObject

/**
 *  The steps associated with the execution stage.
 *  Note that stages may have several steps, and that a given step
 *  might be run by more than one stage.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *stepName;

@end


/**
 *  A particular message pertaining to a Dataflow job.
 */
@interface GTLRDataflow_JobMessage : GTLRObject

/**
 *  Deprecated.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Importance level of the message.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageBasic The
 *        message is at the 'basic' level: useful for keeping
 *        track of the execution of a Dataflow pipeline. Typically,
 *        Dataflow pipeline runners display log messages at this level by
 *        default, and these messages are displayed by default in the
 *        Dataflow monitoring UI. (Value: "JOB_MESSAGE_BASIC")
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageDebug The
 *        message is at the 'debug' level: typically only useful for
 *        software engineers working on the code the job is running.
 *        Typically, Dataflow pipeline runners do not display log messages
 *        at this level by default. (Value: "JOB_MESSAGE_DEBUG")
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageDetailed The
 *        message is at the 'detailed' level: somewhat verbose, but
 *        potentially useful to users. Typically, Dataflow pipeline
 *        runners do not display log messages at this level by default.
 *        These messages are displayed by default in the Dataflow
 *        monitoring UI. (Value: "JOB_MESSAGE_DETAILED")
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageError The
 *        message is at the 'error' level: indicating a condition
 *        preventing a job from succeeding. Typically, Dataflow pipeline
 *        runners display log messages at this level by default, and these
 *        messages are displayed by default in the Dataflow monitoring UI.
 *        (Value: "JOB_MESSAGE_ERROR")
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageImportanceUnknown
 *        The message importance isn't specified, or is unknown. (Value:
 *        "JOB_MESSAGE_IMPORTANCE_UNKNOWN")
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageWarning The
 *        message is at the 'warning' level: indicating a condition
 *        pertaining to a job which may require human intervention.
 *        Typically, Dataflow pipeline runners display log messages at this
 *        level by default, and these messages are displayed by default in
 *        the Dataflow monitoring UI. (Value: "JOB_MESSAGE_WARNING")
 */
@property(nonatomic, copy, nullable) NSString *messageImportance;

/** The text of the message. */
@property(nonatomic, copy, nullable) NSString *messageText;

/** The timestamp of the message. */
@property(nonatomic, strong, nullable) GTLRDateTime *time;

@end


/**
 *  Metadata available primarily for filtering jobs. Will be included in the
 *  ListJob response and Job SUMMARY view+.
 */
@interface GTLRDataflow_JobMetadata : GTLRObject

/** Identification of a BigQuery source used in the Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_BigQueryIODetails *> *bigqueryDetails;

/** Identification of a BigTable source used in the Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_BigTableIODetails *> *bigTableDetails;

/** Identification of a Datastore source used in the Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_DatastoreIODetails *> *datastoreDetails;

/** Identification of a File source used in the Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_FileIODetails *> *fileDetails;

/** Identification of a PubSub source used in the Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_PubSubIODetails *> *pubsubDetails;

/** The SDK version used to run the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_SdkVersion *sdkVersion;

/** Identification of a Spanner source used in the Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SpannerIODetails *> *spannerDetails;

@end


/**
 *  JobMetrics contains a collection of metrics descibing the detailed progress
 *  of a Dataflow job. Metrics correspond to user-defined and system-defined
 *  metrics in the job.
 *  This resource captures only the most recent values of each metric;
 *  time-series data can be queried for them (under the same metric names)
 *  from Cloud Monitoring.
 */
@interface GTLRDataflow_JobMetrics : GTLRObject

/** All metrics for this job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_MetricUpdate *> *metrics;

/** Timestamp as of which metric values are current. */
@property(nonatomic, strong, nullable) GTLRDateTime *metricTime;

@end


/**
 *  Data disk assignment information for a specific key-range of a sharded
 *  computation.
 *  Currently we only support UTF-8 character splits to simplify encoding into
 *  JSON.
 */
@interface GTLRDataflow_KeyRangeDataDiskAssignment : GTLRObject

/**
 *  The name of the data disk where data for this range is stored.
 *  This name is local to the Google Cloud Platform project and uniquely
 *  identifies the disk within that project, for example
 *  "myproject-1014-104817-4c2-harness-0-disk-1".
 */
@property(nonatomic, copy, nullable) NSString *dataDisk;

/** The end (exclusive) of the key range. */
@property(nonatomic, copy, nullable) NSString *end;

/** The start (inclusive) of the key range. */
@property(nonatomic, copy, nullable) NSString *start;

@end


/**
 *  Location information for a specific key-range of a sharded computation.
 *  Currently we only support UTF-8 character splits to simplify encoding into
 *  JSON.
 */
@interface GTLRDataflow_KeyRangeLocation : GTLRObject

/**
 *  The name of the data disk where data for this range is stored.
 *  This name is local to the Google Cloud Platform project and uniquely
 *  identifies the disk within that project, for example
 *  "myproject-1014-104817-4c2-harness-0-disk-1".
 */
@property(nonatomic, copy, nullable) NSString *dataDisk;

/**
 *  The physical location of this range assignment to be used for
 *  streaming computation cross-worker message delivery.
 */
@property(nonatomic, copy, nullable) NSString *deliveryEndpoint;

/**
 *  DEPRECATED. The location of the persistent state for this range, as a
 *  persistent directory in the worker local filesystem.
 */
@property(nonatomic, copy, nullable) NSString *deprecatedPersistentDirectory;

/** The end (exclusive) of the key range. */
@property(nonatomic, copy, nullable) NSString *end;

/** The start (inclusive) of the key range. */
@property(nonatomic, copy, nullable) NSString *start;

@end


/**
 *  Parameters to provide to the template being launched.
 */
@interface GTLRDataflow_LaunchTemplateParameters : GTLRObject

/** The runtime environment for the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_RuntimeEnvironment *environment;

/** Required. The job name to use for the created job. */
@property(nonatomic, copy, nullable) NSString *jobName;

/** The runtime parameters to pass to the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_LaunchTemplateParameters_Parameters *parameters;

@end


/**
 *  The runtime parameters to pass to the job.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_LaunchTemplateParameters_Parameters : GTLRObject
@end


/**
 *  Response to the request to launch a template.
 */
@interface GTLRDataflow_LaunchTemplateResponse : GTLRObject

/**
 *  The job that was launched, if the request was not a dry run and
 *  the job was successfully launched.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Job *job;

@end


/**
 *  Request to lease WorkItems.
 */
@interface GTLRDataflow_LeaseWorkItemRequest : GTLRObject

/** The current timestamp at the worker. */
@property(nonatomic, strong, nullable) GTLRDateTime *currentWorkerTime;

/** The location which contains the WorkItem's job. */
@property(nonatomic, copy, nullable) NSString *location;

/** The initial lease period. */
@property(nonatomic, strong, nullable) GTLRDuration *requestedLeaseDuration;

/**
 *  Worker capabilities. WorkItems might be limited to workers with specific
 *  capabilities.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *workerCapabilities;

/**
 *  Identifies the worker leasing work -- typically the ID of the
 *  virtual machine running the worker.
 */
@property(nonatomic, copy, nullable) NSString *workerId;

/** Filter for WorkItem type. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *workItemTypes;

@end


/**
 *  Response to a request to lease WorkItems.
 */
@interface GTLRDataflow_LeaseWorkItemResponse : GTLRObject

/** A list of the leased WorkItems. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkItem *> *workItems;

@end


/**
 *  Response to a request to list job messages.
 */
@interface GTLRDataflow_ListJobMessagesResponse : GTLRObject

/** Autoscaling events in ascending timestamp order. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_AutoscalingEvent *> *autoscalingEvents;

/** Messages in ascending timestamp order. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_JobMessage *> *jobMessages;

/** The token to obtain the next page of results if there are more. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list Cloud Dataflow jobs. This may be a partial
 *  response, depending on the page size in the ListJobsRequest.
 */
@interface GTLRDataflow_ListJobsResponse : GTLRObject

/** Zero or more messages describing locations that failed to respond. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_FailedLocation *> *failedLocation;

/** A subset of the requested job information. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Job *> *jobs;

/** Set if there may be more results than fit in this response. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  MapTask consists of an ordered set of instructions, each of which
 *  describes one particular low-level operation for the worker to
 *  perform in order to accomplish the MapTask's WorkItem.
 *  Each instruction must appear in the list before any instructions which
 *  depends on its output.
 */
@interface GTLRDataflow_MapTask : GTLRObject

/**
 *  Counter prefix that can be used to prefix counters. Not currently used in
 *  Dataflow.
 */
@property(nonatomic, copy, nullable) NSString *counterPrefix;

/** The instructions in the MapTask. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ParallelInstruction *> *instructions;

/**
 *  System-defined name of the stage containing this MapTask.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *stageName;

/**
 *  System-defined name of this MapTask.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *systemName;

@end


/**
 *  The metric short id is returned to the user alongside an offset into
 *  ReportWorkItemStatusRequest
 */
@interface GTLRDataflow_MetricShortId : GTLRObject

/**
 *  The index of the corresponding metric in
 *  the ReportWorkItemStatusRequest. Required.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *metricIndex;

/**
 *  The service-generated short identifier for the metric.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *shortId;

@end


/**
 *  Identifies a metric, by describing the source which generated the
 *  metric.
 */
@interface GTLRDataflow_MetricStructuredName : GTLRObject

/**
 *  Zero or more labeled fields which identify the part of the job this
 *  metric is associated with, such as the name of a step or collection.
 *  For example, built-in counters associated with steps will have
 *  context['step'] = <step-name>. Counters associated with PCollections
 *  in the SDK will have context['pcollection'] = <pcollection-name>.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_MetricStructuredName_Context *context;

/** Worker-defined metric name. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Origin (namespace) of metric name. May be blank for user-define metrics;
 *  will be "dataflow" for metrics defined by the Dataflow service or SDK.
 */
@property(nonatomic, copy, nullable) NSString *origin;

@end


/**
 *  Zero or more labeled fields which identify the part of the job this
 *  metric is associated with, such as the name of a step or collection.
 *  For example, built-in counters associated with steps will have
 *  context['step'] = <step-name>. Counters associated with PCollections
 *  in the SDK will have context['pcollection'] = <pcollection-name>.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_MetricStructuredName_Context : GTLRObject
@end


/**
 *  Describes the state of a metric.
 */
@interface GTLRDataflow_MetricUpdate : GTLRObject

/**
 *  True if this metric is reported as the total cumulative aggregate
 *  value accumulated since the worker started working on this WorkItem.
 *  By default this is false, indicating that this metric is reported
 *  as a delta that is not associated with any WorkItem.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *cumulative;

/**
 *  A struct value describing properties of a distribution of numeric values.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id distribution;

/**
 *  A struct value describing properties of a Gauge.
 *  Metrics of gauge type show the value of a metric across time, and is
 *  aggregated based on the newest value.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id gauge;

/**
 *  Worker-computed aggregate value for internal use by the Dataflow
 *  service.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id internal;

/**
 *  Metric aggregation kind. The possible metric aggregation kinds are
 *  "Sum", "Max", "Min", "Mean", "Set", "And", "Or", and "Distribution".
 *  The specified aggregation kind is case-insensitive.
 *  If omitted, this is not an aggregated value but instead
 *  a single metric sample value.
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Worker-computed aggregate value for the "Mean" aggregation kind.
 *  This holds the count of the aggregated values and is used in combination
 *  with mean_sum above to obtain the actual mean aggregate value.
 *  The only possible value type is Long.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id meanCount;

/**
 *  Worker-computed aggregate value for the "Mean" aggregation kind.
 *  This holds the sum of the aggregated values and is used in combination
 *  with mean_count below to obtain the actual mean aggregate value.
 *  The only possible value types are Long and Double.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id meanSum;

/** Name of the metric. */
@property(nonatomic, strong, nullable) GTLRDataflow_MetricStructuredName *name;

/**
 *  Worker-computed aggregate value for aggregation kinds "Sum", "Max", "Min",
 *  "And", and "Or". The possible value types are Long, Double, and Boolean.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id scalar;

/**
 *  Worker-computed aggregate value for the "Set" aggregation kind. The only
 *  possible value type is a list of Values whose type can be Long, Double,
 *  or String, according to the metric's type. All Values in the list must
 *  be of the same type.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id set;

/**
 *  Timestamp associated with the metric value. Optional when workers are
 *  reporting work progress; it will be filled in responses from the
 *  metrics API.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *updateTime;

@end


/**
 *  Describes mounted data disk.
 */
@interface GTLRDataflow_MountedDataDisk : GTLRObject

/**
 *  The name of the data disk.
 *  This name is local to the Google Cloud Platform project and uniquely
 *  identifies the disk within that project, for example
 *  "myproject-1014-104817-4c2-harness-0-disk-1".
 */
@property(nonatomic, copy, nullable) NSString *dataDisk;

@end


/**
 *  Information about an output of a multi-output DoFn.
 */
@interface GTLRDataflow_MultiOutputInfo : GTLRObject

/**
 *  The id of the tag the user code will emit to this output by; this
 *  should correspond to the tag of some SideInputInfo.
 */
@property(nonatomic, copy, nullable) NSString *tag;

@end


/**
 *  Basic metadata about a counter.
 */
@interface GTLRDataflow_NameAndKind : GTLRObject

/**
 *  Counter aggregation kind.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_And Aggregated value represents the
 *        logical 'and' of all contributed values. (Value: "AND")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Distribution Aggregated value
 *        captures statistics about a distribution. (Value: "DISTRIBUTION")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Invalid Counter aggregation kind
 *        was not set. (Value: "INVALID")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_LatestValue Aggregated value tracks
 *        the latest value of a variable. (Value: "LATEST_VALUE")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Max Aggregated value is the max of
 *        all contributed values. (Value: "MAX")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Mean Aggregated value is the mean
 *        of all contributed values. (Value: "MEAN")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Min Aggregated value is the min of
 *        all contributed values. (Value: "MIN")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Or Aggregated value represents the
 *        logical 'or' of all contributed values. (Value: "OR")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Set Aggregated value is a set of
 *        unique contributed values. (Value: "SET")
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Sum Aggregated value is the sum of
 *        all contributed values. (Value: "SUM")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** Name of the counter. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  The packages that must be installed in order for a worker to run the
 *  steps of the Cloud Dataflow job that will be assigned to its worker
 *  pool.
 *  This is the mechanism by which the Cloud Dataflow SDK causes code to
 *  be loaded onto the workers. For example, the Cloud Dataflow Java SDK
 *  might use this to install jars containing the user's code and all of the
 *  various dependencies (libraries, data files, etc.) required in order
 *  for that code to run.
 */
@interface GTLRDataflow_Package : GTLRObject

/**
 *  The resource to read the package from. The supported resource type is:
 *  Google Cloud Storage:
 *  storage.googleapis.com/{bucket}
 *  bucket.storage.googleapis.com/
 */
@property(nonatomic, copy, nullable) NSString *location;

/** The name of the package. */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Describes a particular operation comprising a MapTask.
 */
@interface GTLRDataflow_ParallelInstruction : GTLRObject

/** Additional information for Flatten instructions. */
@property(nonatomic, strong, nullable) GTLRDataflow_FlattenInstruction *flatten;

/** User-provided name of this operation. */
@property(nonatomic, copy, nullable) NSString *name;

/** System-defined name for the operation in the original workflow graph. */
@property(nonatomic, copy, nullable) NSString *originalName;

/** Describes the outputs of the instruction. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_InstructionOutput *> *outputs;

/** Additional information for ParDo instructions. */
@property(nonatomic, strong, nullable) GTLRDataflow_ParDoInstruction *parDo;

/** Additional information for PartialGroupByKey instructions. */
@property(nonatomic, strong, nullable) GTLRDataflow_PartialGroupByKeyInstruction *partialGroupByKey;

/** Additional information for Read instructions. */
@property(nonatomic, strong, nullable) GTLRDataflow_ReadInstruction *read;

/**
 *  System-defined name of this operation.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *systemName;

/** Additional information for Write instructions. */
@property(nonatomic, strong, nullable) GTLRDataflow_WriteInstruction *write;

@end


/**
 *  Structured data associated with this message.
 */
@interface GTLRDataflow_Parameter : GTLRObject

/** Key or name for this parameter. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Value for this parameter.
 *
 *  Can be any valid JSON type.
 */
@property(nonatomic, strong, nullable) id value;

@end


/**
 *  Metadata for a specific parameter.
 */
@interface GTLRDataflow_ParameterMetadata : GTLRObject

/** Required. The help text to display for the parameter. */
@property(nonatomic, copy, nullable) NSString *helpText;

/**
 *  Optional. Whether the parameter is optional. Defaults to false.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isOptional;

/** Required. The label to display for the parameter. */
@property(nonatomic, copy, nullable) NSString *label;

/** Required. The name of the parameter. */
@property(nonatomic, copy, nullable) NSString *name;

/** Optional. Regexes that the parameter must match. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *regexes;

@end


/**
 *  An instruction that does a ParDo operation.
 *  Takes one main input and zero or more side inputs, and produces
 *  zero or more outputs.
 *  Runs user code.
 */
@interface GTLRDataflow_ParDoInstruction : GTLRObject

/** The input. */
@property(nonatomic, strong, nullable) GTLRDataflow_InstructionInput *input;

/** Information about each of the outputs, if user_fn is a MultiDoFn. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_MultiOutputInfo *> *multiOutputInfos;

/**
 *  The number of outputs.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numOutputs;

/** Zero or more side inputs. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SideInputInfo *> *sideInputs;

/** The user function to invoke. */
@property(nonatomic, strong, nullable) GTLRDataflow_ParDoInstruction_UserFn *userFn;

@end


/**
 *  The user function to invoke.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_ParDoInstruction_UserFn : GTLRObject
@end


/**
 *  An instruction that does a partial group-by-key.
 *  One input and one output.
 */
@interface GTLRDataflow_PartialGroupByKeyInstruction : GTLRObject

/** Describes the input to the partial group-by-key instruction. */
@property(nonatomic, strong, nullable) GTLRDataflow_InstructionInput *input;

/** The codec to use for interpreting an element in the input PTable. */
@property(nonatomic, strong, nullable) GTLRDataflow_PartialGroupByKeyInstruction_InputElementCodec *inputElementCodec;

/**
 *  If this instruction includes a combining function this is the name of the
 *  intermediate store between the GBK and the CombineValues.
 */
@property(nonatomic, copy, nullable) NSString *originalCombineValuesInputStoreName;

/**
 *  If this instruction includes a combining function, this is the name of the
 *  CombineValues instruction lifted into this instruction.
 */
@property(nonatomic, copy, nullable) NSString *originalCombineValuesStepName;

/** Zero or more side inputs. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SideInputInfo *> *sideInputs;

/** The value combining function to invoke. */
@property(nonatomic, strong, nullable) GTLRDataflow_PartialGroupByKeyInstruction_ValueCombiningFn *valueCombiningFn;

@end


/**
 *  The codec to use for interpreting an element in the input PTable.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_PartialGroupByKeyInstruction_InputElementCodec : GTLRObject
@end


/**
 *  The value combining function to invoke.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_PartialGroupByKeyInstruction_ValueCombiningFn : GTLRObject
@end


/**
 *  A descriptive representation of submitted pipeline as well as the executed
 *  form. This data is provided by the Dataflow service for ease of visualizing
 *  the pipeline and interpretting Dataflow provided metrics.
 */
@interface GTLRDataflow_PipelineDescription : GTLRObject

/** Pipeline level display data. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_DisplayData *> *displayData;

/** Description of each stage of execution of the pipeline. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ExecutionStageSummary *> *executionPipelineStage;

/**
 *  Description of each transform in the pipeline and collections between them.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_TransformSummary *> *originalPipelineTransform;

@end


/**
 *  Position defines a position within a collection of data. The value
 *  can be either the end position, a key (used with ordered
 *  collections), a byte offset, or a record index.
 */
@interface GTLRDataflow_Position : GTLRObject

/**
 *  Position is a byte offset.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *byteOffset;

/** CloudPosition is a concat position. */
@property(nonatomic, strong, nullable) GTLRDataflow_ConcatPosition *concatPosition;

/**
 *  Position is past all other positions. Also useful for the end
 *  position of an unbounded range.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *end;

/** Position is a string key, ordered lexicographically. */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  Position is a record index.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *recordIndex;

/**
 *  CloudPosition is a base64 encoded BatchShufflePosition (with FIXED
 *  sharding).
 */
@property(nonatomic, copy, nullable) NSString *shufflePosition;

@end


/**
 *  Metadata for a PubSub connector used by the job.
 */
@interface GTLRDataflow_PubSubIODetails : GTLRObject

/** Subscription used in the connection. */
@property(nonatomic, copy, nullable) NSString *subscription;

/** Topic accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *topic;

@end


/**
 *  Identifies a pubsub location to use for transferring data into or
 *  out of a streaming Dataflow job.
 */
@interface GTLRDataflow_PubsubLocation : GTLRObject

/**
 *  Indicates whether the pipeline allows late-arriving data.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *dropLateData;

/**
 *  If set, contains a pubsub label from which to extract record ids.
 *  If left empty, record deduplication will be strictly best effort.
 */
@property(nonatomic, copy, nullable) NSString *idLabel;

/**
 *  A pubsub subscription, in the form of
 *  "pubsub.googleapis.com/subscriptions/<project-id>/<subscription-name>"
 */
@property(nonatomic, copy, nullable) NSString *subscription;

/**
 *  If set, contains a pubsub label from which to extract record timestamps.
 *  If left empty, record timestamps will be generated upon arrival.
 */
@property(nonatomic, copy, nullable) NSString *timestampLabel;

/**
 *  A pubsub topic, in the form of
 *  "pubsub.googleapis.com/topics/<project-id>/<topic-name>"
 */
@property(nonatomic, copy, nullable) NSString *topic;

/**
 *  If set, specifies the pubsub subscription that will be used for tracking
 *  custom time timestamps for watermark estimation.
 */
@property(nonatomic, copy, nullable) NSString *trackingSubscription;

/**
 *  If true, then the client has requested to get pubsub attributes.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *withAttributes;

@end


/**
 *  An instruction that reads records.
 *  Takes no inputs, produces one output.
 */
@interface GTLRDataflow_ReadInstruction : GTLRObject

/** The source to read from. */
@property(nonatomic, strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  Represents the level of parallelism in a WorkItem's input,
 *  reported by the worker.
 */
@interface GTLRDataflow_ReportedParallelism : GTLRObject

/**
 *  Specifies whether the parallelism is infinite. If true, "value" is
 *  ignored.
 *  Infinite parallelism means the service will assume that the work item
 *  can always be split into more non-empty work items by dynamic splitting.
 *  This is a work-around for lack of support for infinity by the current
 *  JSON-based Java RPC stack.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isInfinite;

/**
 *  Specifies the level of parallelism in case it is finite.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  Request to report the status of WorkItems.
 */
@interface GTLRDataflow_ReportWorkItemStatusRequest : GTLRObject

/** The current timestamp at the worker. */
@property(nonatomic, strong, nullable) GTLRDateTime *currentWorkerTime;

/** The location which contains the WorkItem's job. */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  The ID of the worker reporting the WorkItem status. If this
 *  does not match the ID of the worker which the Dataflow service
 *  believes currently has the lease on the WorkItem, the report
 *  will be dropped (with an error response).
 */
@property(nonatomic, copy, nullable) NSString *workerId;

/**
 *  The order is unimportant, except that the order of the
 *  WorkItemServiceState messages in the ReportWorkItemStatusResponse
 *  corresponds to the order of WorkItemStatus messages here.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkItemStatus *> *workItemStatuses;

@end


/**
 *  Response from a request to report the status of WorkItems.
 */
@interface GTLRDataflow_ReportWorkItemStatusResponse : GTLRObject

/**
 *  A set of messages indicating the service-side state for each
 *  WorkItem whose status was reported, in the same order as the
 *  WorkItemStatus messages in the ReportWorkItemStatusRequest which
 *  resulting in this response.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkItemServiceState *> *workItemServiceStates;

@end


/**
 *  Worker metrics exported from workers. This contains resource utilization
 *  metrics accumulated from a variety of sources. For more information, see
 *  go/df-resource-signals.
 */
@interface GTLRDataflow_ResourceUtilizationReport : GTLRObject

/** CPU utilization samples. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_CPUTime *> *cpuTime;

@end


/**
 *  Service-side response to WorkerMessage reporting resource utilization.
 */
@interface GTLRDataflow_ResourceUtilizationReportResponse : GTLRObject
@end


/**
 *  The environment values to set at runtime.
 */
@interface GTLRDataflow_RuntimeEnvironment : GTLRObject

/** Additional experiment flags for the job. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *additionalExperiments;

/** Additional user labels attached to the job. */
@property(nonatomic, strong, nullable) GTLRDataflow_RuntimeEnvironment_AdditionalUserLabels *additionalUserLabels;

/**
 *  Whether to bypass the safety checks for the job's temporary directory.
 *  Use with caution.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *bypassTempDirValidation;

/**
 *  The machine type to use for the job. Defaults to the value from the
 *  template if not specified.
 */
@property(nonatomic, copy, nullable) NSString *machineType;

/**
 *  The maximum number of Google Compute Engine instances to be made
 *  available to your pipeline during execution, from 1 to 1000.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxWorkers;

/**
 *  Network to which VMs will be assigned. If empty or unspecified,
 *  the service will use the network "default".
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  The initial number of Google Compute Engine instnaces for the job.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numWorkers;

/** The email address of the service account to run the job as. */
@property(nonatomic, copy, nullable) NSString *serviceAccountEmail;

/**
 *  Subnetwork to which VMs will be assigned, if desired. Expected to be of
 *  the form "regions/REGION/subnetworks/SUBNETWORK".
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  The Cloud Storage path to use for temporary files.
 *  Must be a valid Cloud Storage URL, beginning with `gs://`.
 */
@property(nonatomic, copy, nullable) NSString *tempLocation;

/**
 *  The Compute Engine [availability
 *  zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones)
 *  for launching worker instances to run your pipeline.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  Additional user labels attached to the job.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_RuntimeEnvironment_AdditionalUserLabels : GTLRObject
@end


/**
 *  The version of the SDK used to run the jobl
 */
@interface GTLRDataflow_SdkVersion : GTLRObject

/**
 *  The support status for this SDK version.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_SdkVersion_SdkSupportStatus_Deprecated This version
 *        of the SDK is deprecated and will eventually be no
 *        longer supported. (Value: "DEPRECATED")
 *    @arg @c kGTLRDataflow_SdkVersion_SdkSupportStatus_Stale A newer version of
 *        the SDK family exists, and an update is recommended. (Value: "STALE")
 *    @arg @c kGTLRDataflow_SdkVersion_SdkSupportStatus_Supported This is a
 *        known version of an SDK, and is supported. (Value: "SUPPORTED")
 *    @arg @c kGTLRDataflow_SdkVersion_SdkSupportStatus_Unknown Cloud Dataflow
 *        is unaware of this version. (Value: "UNKNOWN")
 *    @arg @c kGTLRDataflow_SdkVersion_SdkSupportStatus_Unsupported Support for
 *        this SDK version has ended and it should no longer be used. (Value:
 *        "UNSUPPORTED")
 */
@property(nonatomic, copy, nullable) NSString *sdkSupportStatus;

/** The version of the SDK used to run the job. */
@property(nonatomic, copy, nullable) NSString *version;

/** A readable string describing the version of the sdk. */
@property(nonatomic, copy, nullable) NSString *versionDisplayName;

@end


/**
 *  Request to send encoded debug information.
 */
@interface GTLRDataflow_SendDebugCaptureRequest : GTLRObject

/** The internal component id for which debug information is sent. */
@property(nonatomic, copy, nullable) NSString *componentId;

/** The encoded debug information. */
@property(nonatomic, copy, nullable) NSString *data;

/** The location which contains the job specified by job_id. */
@property(nonatomic, copy, nullable) NSString *location;

/** The worker id, i.e., VM hostname. */
@property(nonatomic, copy, nullable) NSString *workerId;

@end


/**
 *  Response to a send capture request.
 *  nothing
 */
@interface GTLRDataflow_SendDebugCaptureResponse : GTLRObject
@end


/**
 *  A request for sending worker messages to the service.
 */
@interface GTLRDataflow_SendWorkerMessagesRequest : GTLRObject

/** The location which contains the job */
@property(nonatomic, copy, nullable) NSString *location;

/** The WorkerMessages to send. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkerMessage *> *workerMessages;

@end


/**
 *  The response to the worker messages.
 */
@interface GTLRDataflow_SendWorkerMessagesResponse : GTLRObject

/** The servers response to the worker messages. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkerMessageResponse *> *workerMessageResponses;

@end


/**
 *  Describes a particular function to invoke.
 */
@interface GTLRDataflow_SeqMapTask : GTLRObject

/** Information about each of the inputs. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SideInputInfo *> *inputs;

/** The user-provided name of the SeqDo operation. */
@property(nonatomic, copy, nullable) NSString *name;

/** Information about each of the outputs. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SeqMapTaskOutputInfo *> *outputInfos;

/**
 *  System-defined name of the stage containing the SeqDo operation.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *stageName;

/**
 *  System-defined name of the SeqDo operation.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *systemName;

/** The user function to invoke. */
@property(nonatomic, strong, nullable) GTLRDataflow_SeqMapTask_UserFn *userFn;

@end


/**
 *  The user function to invoke.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SeqMapTask_UserFn : GTLRObject
@end


/**
 *  Information about an output of a SeqMapTask.
 */
@interface GTLRDataflow_SeqMapTaskOutputInfo : GTLRObject

/** The sink to write the output value to. */
@property(nonatomic, strong, nullable) GTLRDataflow_Sink *sink;

/** The id of the TupleTag the user code will tag the output value by. */
@property(nonatomic, copy, nullable) NSString *tag;

@end


/**
 *  A task which consists of a shell command for the worker to execute.
 */
@interface GTLRDataflow_ShellTask : GTLRObject

/** The shell command to run. */
@property(nonatomic, copy, nullable) NSString *command;

/**
 *  Exit code for the task.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *exitCode;

@end


/**
 *  Information about a side input of a DoFn or an input of a SeqDoFn.
 */
@interface GTLRDataflow_SideInputInfo : GTLRObject

/** How to interpret the source element(s) as a side input value. */
@property(nonatomic, strong, nullable) GTLRDataflow_SideInputInfo_Kind *kind;

/**
 *  The source(s) to read element(s) from to get the value of this side input.
 *  If more than one source, then the elements are taken from the
 *  sources, in the specified order if order matters.
 *  At least one source is required.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Source *> *sources;

/**
 *  The id of the tag the user code will access this side input by;
 *  this should correspond to the tag of some MultiOutputInfo.
 */
@property(nonatomic, copy, nullable) NSString *tag;

@end


/**
 *  How to interpret the source element(s) as a side input value.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SideInputInfo_Kind : GTLRObject
@end


/**
 *  A sink that records can be encoded and written to.
 */
@interface GTLRDataflow_Sink : GTLRObject

/** The codec to use to encode data written to the sink. */
@property(nonatomic, strong, nullable) GTLRDataflow_Sink_Codec *codec;

/** The sink to write to, plus its parameters. */
@property(nonatomic, strong, nullable) GTLRDataflow_Sink_Spec *spec;

@end


/**
 *  The codec to use to encode data written to the sink.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Sink_Codec : GTLRObject
@end


/**
 *  The sink to write to, plus its parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Sink_Spec : GTLRObject
@end


/**
 *  Represents a snapshot of a job.
 */
@interface GTLRDataflow_Snapshot : GTLRObject

/** The time this snapshot was created. */
@property(nonatomic, strong, nullable) GTLRDateTime *creationTime;

/**
 *  The unique ID of this snapshot.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** The project this snapshot belongs to. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** The job this snapshot was created from. */
@property(nonatomic, copy, nullable) NSString *sourceJobId;

/** The time after which this snapshot will be automatically deleted. */
@property(nonatomic, strong, nullable) GTLRDuration *ttl;

@end


/**
 *  Request to create a snapshot of a job.
 */
@interface GTLRDataflow_SnapshotJobRequest : GTLRObject

/** The location that contains this job. */
@property(nonatomic, copy, nullable) NSString *location;

/** TTL for the snapshot. */
@property(nonatomic, strong, nullable) GTLRDuration *ttl;

@end


/**
 *  A source that records can be read and decoded from.
 */
@interface GTLRDataflow_Source : GTLRObject

/**
 *  While splitting, sources may specify the produced bundles
 *  as differences against another source, in order to save backend-side
 *  memory and allow bigger jobs. For details, see SourceSplitRequest.
 *  To support this use case, the full set of parameters of the source
 *  is logically obtained by taking the latest explicitly specified value
 *  of each parameter in the order:
 *  base_specs (later items win), spec (overrides anything in base_specs).
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Source_BaseSpecs_Item *> *baseSpecs;

/** The codec to use to decode data read from the source. */
@property(nonatomic, strong, nullable) GTLRDataflow_Source_Codec *codec;

/**
 *  Setting this value to true hints to the framework that the source
 *  doesn't need splitting, and using SourceSplitRequest on it would
 *  yield SOURCE_SPLIT_OUTCOME_USE_CURRENT.
 *  E.g. a file splitter may set this to true when splitting a single file
 *  into a set of byte ranges of appropriate size, and set this
 *  to false when splitting a filepattern into individual files.
 *  However, for efficiency, a file splitter may decide to produce
 *  file subranges directly from the filepattern to avoid a splitting
 *  round-trip.
 *  See SourceSplitRequest for an overview of the splitting process.
 *  This field is meaningful only in the Source objects populated
 *  by the user (e.g. when filling in a DerivedSource).
 *  Source objects supplied by the framework to the user don't have
 *  this field populated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doesNotNeedSplitting;

/**
 *  Optionally, metadata for this source can be supplied right away,
 *  avoiding a SourceGetMetadataOperation roundtrip
 *  (see SourceOperationRequest).
 *  This field is meaningful only in the Source objects populated
 *  by the user (e.g. when filling in a DerivedSource).
 *  Source objects supplied by the framework to the user don't have
 *  this field populated.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceMetadata *metadata;

/** The source to read from, plus its parameters. */
@property(nonatomic, strong, nullable) GTLRDataflow_Source_Spec *spec;

@end


/**
 *  GTLRDataflow_Source_BaseSpecs_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Source_BaseSpecs_Item : GTLRObject
@end


/**
 *  The codec to use to decode data read from the source.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Source_Codec : GTLRObject
@end


/**
 *  The source to read from, plus its parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Source_Spec : GTLRObject
@end


/**
 *  DEPRECATED in favor of DynamicSourceSplit.
 */
@interface GTLRDataflow_SourceFork : GTLRObject

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceSplitShard *primary;

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLRDataflow_DerivedSource *primarySource;

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceSplitShard *residual;

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLRDataflow_DerivedSource *residualSource;

@end


/**
 *  A request to compute the SourceMetadata of a Source.
 */
@interface GTLRDataflow_SourceGetMetadataRequest : GTLRObject

/** Specification of the source whose metadata should be computed. */
@property(nonatomic, strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  The result of a SourceGetMetadataOperation.
 */
@interface GTLRDataflow_SourceGetMetadataResponse : GTLRObject

/** The computed metadata. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceMetadata *metadata;

@end


/**
 *  Metadata about a Source useful for automatically optimizing
 *  and tuning the pipeline, etc.
 */
@interface GTLRDataflow_SourceMetadata : GTLRObject

/**
 *  An estimate of the total size (in bytes) of the data that would be
 *  read from this source. This estimate is in terms of external storage
 *  size, before any decompression or other processing done by the reader.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *estimatedSizeBytes;

/**
 *  Specifies that the size of this source is known to be infinite
 *  (this is a streaming source).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *infinite;

/**
 *  Whether this source is known to produce key/value pairs with
 *  the (encoded) keys in lexicographically sorted order.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *producesSortedKeys;

@end


/**
 *  A work item that represents the different operations that can be
 *  performed on a user-defined Source specification.
 */
@interface GTLRDataflow_SourceOperationRequest : GTLRObject

/** Information about a request to get metadata about a source. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceGetMetadataRequest *getMetadata;

/** User-provided name of the Read instruction for this source. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  System-defined name for the Read instruction for this source
 *  in the original workflow graph.
 */
@property(nonatomic, copy, nullable) NSString *originalName;

/** Information about a request to split a source. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceSplitRequest *split;

/**
 *  System-defined name of the stage containing the source operation.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *stageName;

/**
 *  System-defined name of the Read instruction for this source.
 *  Unique across the workflow.
 */
@property(nonatomic, copy, nullable) NSString *systemName;

@end


/**
 *  The result of a SourceOperationRequest, specified in
 *  ReportWorkItemStatusRequest.source_operation when the work item
 *  is completed.
 */
@interface GTLRDataflow_SourceOperationResponse : GTLRObject

/** A response to a request to get metadata about a source. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceGetMetadataResponse *getMetadata;

/** A response to a request to split a source. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceSplitResponse *split;

@end


/**
 *  Hints for splitting a Source into bundles (parts for parallel
 *  processing) using SourceSplitRequest.
 */
@interface GTLRDataflow_SourceSplitOptions : GTLRObject

/**
 *  The source should be split into a set of bundles where the estimated size
 *  of each is approximately this many bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *desiredBundleSizeBytes;

/**
 *  DEPRECATED in favor of desired_bundle_size_bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *desiredShardSizeBytes;

@end


/**
 *  Represents the operation to split a high-level Source specification
 *  into bundles (parts for parallel processing).
 *  At a high level, splitting of a source into bundles happens as follows:
 *  SourceSplitRequest is applied to the source. If it returns
 *  SOURCE_SPLIT_OUTCOME_USE_CURRENT, no further splitting happens and the
 *  source
 *  is used "as is". Otherwise, splitting is applied recursively to each
 *  produced DerivedSource.
 *  As an optimization, for any Source, if its does_not_need_splitting is
 *  true, the framework assumes that splitting this source would return
 *  SOURCE_SPLIT_OUTCOME_USE_CURRENT, and doesn't initiate a SourceSplitRequest.
 *  This applies both to the initial source being split and to bundles
 *  produced from it.
 */
@interface GTLRDataflow_SourceSplitRequest : GTLRObject

/** Hints for tuning the splitting process. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceSplitOptions *options;

/** Specification of the source to be split. */
@property(nonatomic, strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  The response to a SourceSplitRequest.
 */
@interface GTLRDataflow_SourceSplitResponse : GTLRObject

/**
 *  If outcome is SPLITTING_HAPPENED, then this is a list of bundles
 *  into which the source was split. Otherwise this field is ignored.
 *  This list can be empty, which means the source represents an empty input.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_DerivedSource *> *bundles;

/**
 *  Indicates whether splitting happened and produced a list of bundles.
 *  If this is USE_CURRENT_SOURCE_AS_IS, the current source should
 *  be processed "as is" without splitting. "bundles" is ignored in this case.
 *  If this is SPLITTING_HAPPENED, then "bundles" contains a list of
 *  bundles into which the source was split.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeSplittingHappened
 *        Splitting produced a list of bundles. (Value:
 *        "SOURCE_SPLIT_OUTCOME_SPLITTING_HAPPENED")
 *    @arg @c kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUnknown
 *        The source split outcome is unknown, or unspecified. (Value:
 *        "SOURCE_SPLIT_OUTCOME_UNKNOWN")
 *    @arg @c kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUseCurrent
 *        The current source should be processed "as is" without splitting.
 *        (Value: "SOURCE_SPLIT_OUTCOME_USE_CURRENT")
 */
@property(nonatomic, copy, nullable) NSString *outcome;

/** DEPRECATED in favor of bundles. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_SourceSplitShard *> *shards;

@end


/**
 *  DEPRECATED in favor of DerivedSource.
 */
@interface GTLRDataflow_SourceSplitShard : GTLRObject

/**
 *  DEPRECATED
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeChildOfCurrent
 *        Produce a Source based on the Source being split. (Value:
 *        "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT")
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeIndependent
 *        Produce a completely independent Source with no base. (Value:
 *        "SOURCE_DERIVATION_MODE_INDEPENDENT")
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeSiblingOfCurrent
 *        Produce a Source based on the base of the Source being split. (Value:
 *        "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT")
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeUnknown
 *        The source derivation is unknown, or unspecified. (Value:
 *        "SOURCE_DERIVATION_MODE_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *derivationMode;

/** DEPRECATED */
@property(nonatomic, strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  Metadata for a Spanner connector used by the job.
 */
@interface GTLRDataflow_SpannerIODetails : GTLRObject

/** DatabaseId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *databaseId;

/** InstanceId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *instanceId;

/** ProjectId accessed in the connection. */
@property(nonatomic, copy, nullable) NSString *projectId;

@end


/**
 *  A representation of an int64, n, that is immune to precision loss when
 *  encoded in JSON.
 */
@interface GTLRDataflow_SplitInt64 : GTLRObject

/**
 *  The high order bits, including the sign: n >> 32.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *highBits;

/**
 *  The low order bits: n & 0xffffffff.
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(nonatomic, strong, nullable) NSNumber *lowBits;

@end


/**
 *  Description of an input or output of an execution stage.
 */
@interface GTLRDataflow_StageSource : GTLRObject

/** Dataflow service generated name for this source. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  User name for the original user transform or collection with which this
 *  source is most closely associated.
 */
@property(nonatomic, copy, nullable) NSString *originalTransformOrCollection;

/**
 *  Size of the source, if measurable.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sizeBytes;

/** Human-readable name for this source; may be user or system generated. */
@property(nonatomic, copy, nullable) NSString *userName;

@end


/**
 *  State family configuration.
 */
@interface GTLRDataflow_StateFamilyConfig : GTLRObject

/**
 *  If true, this family corresponds to a read operation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *isRead;

/** The state family value. */
@property(nonatomic, copy, nullable) NSString *stateFamily;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` that can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRDataflow_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There is a common set of
 *  message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Status_Details_Item *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRDataflow_Status_Details_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Status_Details_Item : GTLRObject
@end


/**
 *  Defines a particular step within a Cloud Dataflow job.
 *  A job consists of multiple steps, each of which performs some
 *  specific operation as part of the overall job. Data is typically
 *  passed from one step to another as part of the job.
 *  Here's an example of a sequence of steps which together implement a
 *  Map-Reduce job:
 *  * Read a collection of data from some source, parsing the
 *  collection's elements.
 *  * Validate the elements.
 *  * Apply a user-defined function to map each element to some value
 *  and extract an element-specific key value.
 *  * Group elements with the same key into a single element with
 *  that key, transforming a multiply-keyed collection into a
 *  uniquely-keyed collection.
 *  * Write the elements out to some data sink.
 *  Note that the Cloud Dataflow service may be used to run many different
 *  types of jobs, not just Map-Reduce.
 */
@interface GTLRDataflow_Step : GTLRObject

/** The kind of step in the Cloud Dataflow job. */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  The name that identifies the step. This must be unique for each
 *  step with respect to all other steps in the Cloud Dataflow job.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Named properties associated with the step. Each kind of
 *  predefined step has its own required set of properties.
 *  Must be provided on Create. Only retrieved with JOB_VIEW_ALL.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Step_Properties *properties;

@end


/**
 *  Named properties associated with the step. Each kind of
 *  predefined step has its own required set of properties.
 *  Must be provided on Create. Only retrieved with JOB_VIEW_ALL.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_Step_Properties : GTLRObject
@end


/**
 *  Streaming appliance snapshot configuration.
 */
@interface GTLRDataflow_StreamingApplianceSnapshotConfig : GTLRObject

/** Indicates which endpoint is used to import appliance state. */
@property(nonatomic, copy, nullable) NSString *importStateEndpoint;

/** If set, indicates the snapshot id for the snapshot being performed. */
@property(nonatomic, copy, nullable) NSString *snapshotId;

@end


/**
 *  Configuration information for a single streaming computation.
 */
@interface GTLRDataflow_StreamingComputationConfig : GTLRObject

/** Unique identifier for this computation. */
@property(nonatomic, copy, nullable) NSString *computationId;

/** Instructions that comprise the computation. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ParallelInstruction *> *instructions;

/** Stage name of this computation. */
@property(nonatomic, copy, nullable) NSString *stageName;

/** System defined name for this computation. */
@property(nonatomic, copy, nullable) NSString *systemName;

@end


/**
 *  Describes full or partial data disk assignment information of the
 *  computation
 *  ranges.
 */
@interface GTLRDataflow_StreamingComputationRanges : GTLRObject

/** The ID of the computation. */
@property(nonatomic, copy, nullable) NSString *computationId;

/** Data disk assignments for ranges from this computation. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_KeyRangeDataDiskAssignment *> *rangeAssignments;

@end


/**
 *  A task which describes what action should be performed for the specified
 *  streaming computation ranges.
 */
@interface GTLRDataflow_StreamingComputationTask : GTLRObject

/** Contains ranges of a streaming computation this task should apply to. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StreamingComputationRanges *> *computationRanges;

/** Describes the set of data disks this task should apply to. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_MountedDataDisk *> *dataDisks;

/**
 *  A type of streaming computation task.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStart
 *        Start processing specified streaming computation range(s). (Value:
 *        "STREAMING_COMPUTATION_TASK_START")
 *    @arg @c kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStop
 *        Stop processing specified streaming computation range(s). (Value:
 *        "STREAMING_COMPUTATION_TASK_STOP")
 *    @arg @c kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskUnknown
 *        The streaming computation task is unknown, or unspecified. (Value:
 *        "STREAMING_COMPUTATION_TASK_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *taskType;

@end


/**
 *  A task that carries configuration information for streaming computations.
 */
@interface GTLRDataflow_StreamingConfigTask : GTLRObject

/** Set of computation configuration information. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_StreamingComputationConfig *> *streamingComputationConfigs;

/** Map from user step names to state families. */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingConfigTask_UserStepToStateFamilyNameMap *userStepToStateFamilyNameMap;

/**
 *  If present, the worker must use this endpoint to communicate with Windmill
 *  Service dispatchers, otherwise the worker must continue to use whatever
 *  endpoint it had been using.
 */
@property(nonatomic, copy, nullable) NSString *windmillServiceEndpoint;

/**
 *  If present, the worker must use this port to communicate with Windmill
 *  Service dispatchers. Only applicable when windmill_service_endpoint is
 *  specified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *windmillServicePort;

@end


/**
 *  Map from user step names to state families.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_StreamingConfigTask_UserStepToStateFamilyNameMap : GTLRObject
@end


/**
 *  A task which initializes part of a streaming Dataflow job.
 */
@interface GTLRDataflow_StreamingSetupTask : GTLRObject

/**
 *  The user has requested drain.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *drain;

/**
 *  The TCP port on which the worker should listen for messages from
 *  other streaming computation workers.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *receiveWorkPort;

/** Configures streaming appliance snapshot. */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingApplianceSnapshotConfig *snapshotConfig;

/** The global topology of the streaming Dataflow job. */
@property(nonatomic, strong, nullable) GTLRDataflow_TopologyConfig *streamingComputationTopology;

/**
 *  The TCP port used by the worker to communicate with the Dataflow
 *  worker harness.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *workerHarnessPort;

@end


/**
 *  Identifies the location of a streaming side input.
 */
@interface GTLRDataflow_StreamingSideInputLocation : GTLRObject

/** Identifies the state family where this side input is stored. */
@property(nonatomic, copy, nullable) NSString *stateFamily;

/** Identifies the particular side input within the streaming Dataflow job. */
@property(nonatomic, copy, nullable) NSString *tag;

@end


/**
 *  Identifies the location of a streaming computation stage, for
 *  stage-to-stage communication.
 */
@interface GTLRDataflow_StreamingStageLocation : GTLRObject

/**
 *  Identifies the particular stream within the streaming Dataflow
 *  job.
 */
@property(nonatomic, copy, nullable) NSString *streamId;

@end


/**
 *  Describes a stream of data, either as input to be processed or as
 *  output of a streaming Dataflow job.
 */
@interface GTLRDataflow_StreamLocation : GTLRObject

/** The stream is a custom source. */
@property(nonatomic, strong, nullable) GTLRDataflow_CustomSourceLocation *customSourceLocation;

/** The stream is a pubsub stream. */
@property(nonatomic, strong, nullable) GTLRDataflow_PubsubLocation *pubsubLocation;

/** The stream is a streaming side input. */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingSideInputLocation *sideInputLocation;

/**
 *  The stream is part of another computation within the current
 *  streaming Dataflow job.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingStageLocation *streamingStageLocation;

@end


/**
 *  A metric value representing a list of strings.
 */
@interface GTLRDataflow_StringList : GTLRObject

/** Elements of the list. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *elements;

@end


/**
 *  A rich message format, including a human readable string, a key for
 *  identifying the message, and structured data associated with the message for
 *  programmatic consumption.
 */
@interface GTLRDataflow_StructuredMessage : GTLRObject

/**
 *  Idenfier for this message type. Used by external systems to
 *  internationalize or personalize message.
 */
@property(nonatomic, copy, nullable) NSString *messageKey;

/** Human-readable version of message. */
@property(nonatomic, copy, nullable) NSString *messageText;

/** The structured data associated with this message. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Parameter *> *parameters;

@end


/**
 *  Taskrunner configuration settings.
 */
@interface GTLRDataflow_TaskRunnerSettings : GTLRObject

/**
 *  Whether to also send taskrunner log info to stderr.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *alsologtostderr;

/** The location on the worker for task-specific subdirectories. */
@property(nonatomic, copy, nullable) NSString *baseTaskDir;

/**
 *  The base URL for the taskrunner to use when accessing Google Cloud APIs.
 *  When workers access Google Cloud APIs, they logically do so via
 *  relative URLs. If this field is specified, it supplies the base
 *  URL to use for resolving these relative URLs. The normative
 *  algorithm used is defined by RFC 1808, "Relative Uniform Resource
 *  Locators".
 *  If not specified, the default value is "http://www.googleapis.com/"
 */
@property(nonatomic, copy, nullable) NSString *baseUrl;

/** The file to store preprocessing commands in. */
@property(nonatomic, copy, nullable) NSString *commandlinesFileName;

/**
 *  Whether to continue taskrunner if an exception is hit.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *continueOnException;

/** The API version of endpoint, e.g. "v1b3" */
@property(nonatomic, copy, nullable) NSString *dataflowApiVersion;

/** The command to launch the worker harness. */
@property(nonatomic, copy, nullable) NSString *harnessCommand;

/** The suggested backend language. */
@property(nonatomic, copy, nullable) NSString *languageHint;

/** The directory on the VM to store logs. */
@property(nonatomic, copy, nullable) NSString *logDir;

/**
 *  Whether to send taskrunner log info to Google Compute Engine VM serial
 *  console.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *logToSerialconsole;

/**
 *  Indicates where to put logs. If this is not specified, the logs
 *  will not be uploaded.
 *  The supported resource type is:
 *  Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(nonatomic, copy, nullable) NSString *logUploadLocation;

/**
 *  The OAuth2 scopes to be requested by the taskrunner in order to
 *  access the Cloud Dataflow API.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *oauthScopes;

/** The settings to pass to the parallel worker harness. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerSettings *parallelWorkerSettings;

/** The streaming worker main class name. */
@property(nonatomic, copy, nullable) NSString *streamingWorkerMainClass;

/**
 *  The UNIX group ID on the worker VM to use for tasks launched by
 *  taskrunner; e.g. "wheel".
 */
@property(nonatomic, copy, nullable) NSString *taskGroup;

/**
 *  The UNIX user ID on the worker VM to use for tasks launched by
 *  taskrunner; e.g. "root".
 */
@property(nonatomic, copy, nullable) NSString *taskUser;

/**
 *  The prefix of the resources the taskrunner should use for
 *  temporary storage.
 *  The supported resource type is:
 *  Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(nonatomic, copy, nullable) NSString *tempStoragePrefix;

/** The ID string of the VM. */
@property(nonatomic, copy, nullable) NSString *vmId;

/** The file to store the workflow in. */
@property(nonatomic, copy, nullable) NSString *workflowFileName;

@end


/**
 *  Metadata describing a template.
 */
@interface GTLRDataflow_TemplateMetadata : GTLRObject

/**
 *  Optional. A description of the template.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/** Required. The name of the template. */
@property(nonatomic, copy, nullable) NSString *name;

/** The parameters for the template. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ParameterMetadata *> *parameters;

@end


/**
 *  Global topology of the streaming Dataflow job, including all
 *  computations and their sharded locations.
 */
@interface GTLRDataflow_TopologyConfig : GTLRObject

/** The computations associated with a streaming Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_ComputationTopology *> *computations;

/** The disks assigned to a streaming Dataflow job. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_DataDiskAssignment *> *dataDiskAssignments;

/**
 *  The size (in bits) of keys that will be assigned to source messages.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *forwardingKeyBits;

/**
 *  Version number for persistent state.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *persistentStateVersion;

/** Maps user stage names to stable computation names. */
@property(nonatomic, strong, nullable) GTLRDataflow_TopologyConfig_UserStageToComputationNameMap *userStageToComputationNameMap;

@end


/**
 *  Maps user stage names to stable computation names.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_TopologyConfig_UserStageToComputationNameMap : GTLRObject
@end


/**
 *  Description of the type, names/ids, and input/outputs for a transform.
 */
@interface GTLRDataflow_TransformSummary : GTLRObject

/** Transform-specific display data. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_DisplayData *> *displayData;

/**
 *  SDK generated id of this transform instance.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/** User names for all collection inputs to this transform. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *inputCollectionName;

/**
 *  Type of transform.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_ConstantKind Constructs from a
 *        constant value, such as with Create.of. (Value: "CONSTANT_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_FlattenKind Flatten transform.
 *        (Value: "FLATTEN_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_GroupByKeyKind Group By Key
 *        transform. (Value: "GROUP_BY_KEY_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_ParDoKind ParDo transform.
 *        (Value: "PAR_DO_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_ReadKind Read transform.
 *        (Value: "READ_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_ShuffleKind Opening or closing
 *        a shuffle session, often as part of a GroupByKey. (Value:
 *        "SHUFFLE_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_SingletonKind Creates a
 *        Singleton view of a collection. (Value: "SINGLETON_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_UnknownKind Unrecognized
 *        transform type. (Value: "UNKNOWN_KIND")
 *    @arg @c kGTLRDataflow_TransformSummary_Kind_WriteKind Write transform.
 *        (Value: "WRITE_KIND")
 */
@property(nonatomic, copy, nullable) NSString *kind;

/** User provided name for this transform instance. */
@property(nonatomic, copy, nullable) NSString *name;

/** User names for all collection outputs to this transform. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *outputCollectionName;

@end


/**
 *  WorkerHealthReport contains information about the health of a worker.
 *  The VM should be identified by the labels attached to the WorkerMessage that
 *  this health ping belongs to.
 */
@interface GTLRDataflow_WorkerHealthReport : GTLRObject

/**
 *  The pods running on the worker. See:
 *  http://kubernetes.io/v1.1/docs/api-reference/v1/definitions.html#_v1_pod
 *  This field is used by the worker to send the status of the indvidual
 *  containers running on each worker.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_WorkerHealthReport_Pods_Item *> *pods;

/**
 *  The interval at which the worker is sending health reports.
 *  The default value of 0 should be interpreted as the field is not being
 *  explicitly set by the worker.
 */
@property(nonatomic, strong, nullable) GTLRDuration *reportInterval;

/**
 *  Whether the VM is healthy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *vmIsHealthy;

/** The time the VM was booted. */
@property(nonatomic, strong, nullable) GTLRDateTime *vmStartupTime;

@end


/**
 *  GTLRDataflow_WorkerHealthReport_Pods_Item
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkerHealthReport_Pods_Item : GTLRObject
@end


/**
 *  WorkerHealthReportResponse contains information returned to the worker
 *  in response to a health ping.
 */
@interface GTLRDataflow_WorkerHealthReportResponse : GTLRObject

/**
 *  A positive value indicates the worker should change its reporting interval
 *  to the specified value.
 *  The default value of zero means no change in report rate is requested by
 *  the server.
 */
@property(nonatomic, strong, nullable) GTLRDuration *reportInterval;

@end


/**
 *  A report of an event in a worker's lifecycle.
 *  The proto contains one event, because the worker is expected to
 *  asynchronously send each message immediately after the event.
 *  Due to this asynchrony, messages may arrive out of order (or missing), and
 *  it
 *  is up to the consumer to interpret.
 *  The timestamp of the event is in the enclosing WorkerMessage proto.
 */
@interface GTLRDataflow_WorkerLifecycleEvent : GTLRObject

/**
 *  The start time of this container. All events will report this so that
 *  events can be grouped together across container/VM restarts.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *containerStartTime;

/**
 *  The event being reported.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_ContainerStart Our
 *        container code starts running. Multiple containers could be
 *        distinguished with WorkerMessage.labels if desired. (Value:
 *        "CONTAINER_START")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_NetworkUp The worker has
 *        a functional external network connection. (Value: "NETWORK_UP")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_OsStart The time the VM
 *        started. (Value: "OS_START")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_SdkInstallFinish Finished
 *        installing SDK. (Value: "SDK_INSTALL_FINISH")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_SdkInstallStart For
 *        applicable SDKs, started installation of SDK and worker packages.
 *        (Value: "SDK_INSTALL_START")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_StagingFilesDownloadFinish
 *        Finished downloading all staging files. (Value:
 *        "STAGING_FILES_DOWNLOAD_FINISH")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_StagingFilesDownloadStart
 *        Started downloading staging files. (Value:
 *        "STAGING_FILES_DOWNLOAD_START")
 *    @arg @c kGTLRDataflow_WorkerLifecycleEvent_Event_UnknownEvent Invalid
 *        event. (Value: "UNKNOWN_EVENT")
 */
@property(nonatomic, copy, nullable) NSString *event;

/**
 *  Other stats that can accompany an event. E.g.
 *  { "downloaded_bytes" : "123456" }
 */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerLifecycleEvent_Metadata *metadata;

@end


/**
 *  Other stats that can accompany an event. E.g.
 *  { "downloaded_bytes" : "123456" }
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_WorkerLifecycleEvent_Metadata : GTLRObject
@end


/**
 *  WorkerMessage provides information to the backend about a worker.
 */
@interface GTLRDataflow_WorkerMessage : GTLRObject

/**
 *  Labels are used to group WorkerMessages.
 *  For example, a worker_message about a particular container
 *  might have the labels:
 *  { "JOB_ID": "2015-04-22",
 *  "WORKER_ID": "wordcount-vm-2015…"
 *  "CONTAINER_TYPE": "worker",
 *  "CONTAINER_ID": "ac1234def"}
 *  Label tags typically correspond to Label enum values. However, for ease
 *  of development other strings can be used as tags. LABEL_UNSPECIFIED should
 *  not be used here.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerMessage_Labels *labels;

/** The timestamp of the worker_message. */
@property(nonatomic, strong, nullable) GTLRDateTime *time;

/** The health of a worker. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerHealthReport *workerHealthReport;

/** Record of worker lifecycle events. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerLifecycleEvent *workerLifecycleEvent;

/** A worker message code. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerMessageCode *workerMessageCode;

/** Resource metrics reported by workers. */
@property(nonatomic, strong, nullable) GTLRDataflow_ResourceUtilizationReport *workerMetrics;

/** Shutdown notice by workers. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerShutdownNotice *workerShutdownNotice;

@end


/**
 *  Labels are used to group WorkerMessages.
 *  For example, a worker_message about a particular container
 *  might have the labels:
 *  { "JOB_ID": "2015-04-22",
 *  "WORKER_ID": "wordcount-vm-2015…"
 *  "CONTAINER_TYPE": "worker",
 *  "CONTAINER_ID": "ac1234def"}
 *  Label tags typically correspond to Label enum values. However, for ease
 *  of development other strings can be used as tags. LABEL_UNSPECIFIED should
 *  not be used here.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_WorkerMessage_Labels : GTLRObject
@end


/**
 *  A message code is used to report status and error messages to the service.
 *  The message codes are intended to be machine readable. The service will
 *  take care of translating these into user understandable messages if
 *  necessary.
 *  Example use cases:
 *  1. Worker processes reporting successful startup.
 *  2. Worker processes reporting specific errors (e.g. package staging
 *  failure).
 */
@interface GTLRDataflow_WorkerMessageCode : GTLRObject

/**
 *  The code is a string intended for consumption by a machine that identifies
 *  the type of message being sent.
 *  Examples:
 *  1. "HARNESS_STARTED" might be used to indicate the worker harness has
 *  started.
 *  2. "GCS_DOWNLOAD_ERROR" might be used to indicate an error downloading
 *  a GCS file as part of the boot process of one of the worker containers.
 *  This is a string and not an enum to make it easy to add new codes without
 *  waiting for an API change.
 */
@property(nonatomic, copy, nullable) NSString *code;

/**
 *  Parameters contains specific information about the code.
 *  This is a struct to allow parameters of different types.
 *  Examples:
 *  1. For a "HARNESS_STARTED" message parameters might provide the name
 *  of the worker and additional data like timing information.
 *  2. For a "GCS_DOWNLOAD_ERROR" parameters might contain fields listing
 *  the GCS objects being downloaded and fields containing errors.
 *  In general complex data structures should be avoided. If a worker
 *  needs to send a specific and complicated data structure then please
 *  consider defining a new proto and adding it to the data oneof in
 *  WorkerMessageResponse.
 *  Conventions:
 *  Parameters should only be used for information that isn't typically passed
 *  as a label.
 *  hostname and other worker identifiers should almost always be passed
 *  as labels since they will be included on most messages.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerMessageCode_Parameters *parameters;

@end


/**
 *  Parameters contains specific information about the code.
 *  This is a struct to allow parameters of different types.
 *  Examples:
 *  1. For a "HARNESS_STARTED" message parameters might provide the name
 *  of the worker and additional data like timing information.
 *  2. For a "GCS_DOWNLOAD_ERROR" parameters might contain fields listing
 *  the GCS objects being downloaded and fields containing errors.
 *  In general complex data structures should be avoided. If a worker
 *  needs to send a specific and complicated data structure then please
 *  consider defining a new proto and adding it to the data oneof in
 *  WorkerMessageResponse.
 *  Conventions:
 *  Parameters should only be used for information that isn't typically passed
 *  as a label.
 *  hostname and other worker identifiers should almost always be passed
 *  as labels since they will be included on most messages.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkerMessageCode_Parameters : GTLRObject
@end


/**
 *  A worker_message response allows the server to pass information to the
 *  sender.
 */
@interface GTLRDataflow_WorkerMessageResponse : GTLRObject

/** The service's response to a worker's health report. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerHealthReportResponse *workerHealthReportResponse;

/** Service's response to reporting worker metrics (currently empty). */
@property(nonatomic, strong, nullable) GTLRDataflow_ResourceUtilizationReportResponse *workerMetricsResponse;

/** Service's response to shutdown notice (currently empty). */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerShutdownNoticeResponse *workerShutdownNoticeResponse;

@end


/**
 *  Describes one particular pool of Cloud Dataflow workers to be
 *  instantiated by the Cloud Dataflow service in order to perform the
 *  computations required by a job. Note that a workflow job may use
 *  multiple pools, in order to match the various computational
 *  requirements of the various stages of the job.
 */
@interface GTLRDataflow_WorkerPool : GTLRObject

/** Settings for autoscaling of this WorkerPool. */
@property(nonatomic, strong, nullable) GTLRDataflow_AutoscalingSettings *autoscalingSettings;

/** Data disks that are used by a VM in this workflow. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Disk *> *dataDisks;

/**
 *  The default package set to install. This allows the service to
 *  select a default set of packages which are useful to worker
 *  harnesses written in a particular language.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetJava
 *        Stage packages typically useful to workers written in Java. (Value:
 *        "DEFAULT_PACKAGE_SET_JAVA")
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetNone
 *        Indicates that no packages should be staged at the worker unless
 *        explicitly specified by the job. (Value: "DEFAULT_PACKAGE_SET_NONE")
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetPython
 *        Stage pacakges typically useful to workers written in Python. (Value:
 *        "DEFAULT_PACKAGE_SET_PYTHON")
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetUnknown
 *        The default set of packages to stage is unknown, or unspecified.
 *        (Value: "DEFAULT_PACKAGE_SET_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *defaultPackageSet;

/**
 *  Size of root disk for VMs, in GB. If zero or unspecified, the service will
 *  attempt to choose a reasonable default.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *diskSizeGb;

/** Fully qualified source image for disks. */
@property(nonatomic, copy, nullable) NSString *diskSourceImage;

/**
 *  Type of root disk for VMs. If empty or unspecified, the service will
 *  attempt to choose a reasonable default.
 */
@property(nonatomic, copy, nullable) NSString *diskType;

/**
 *  Configuration for VM IPs.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_WorkerPool_IpConfiguration_WorkerIpPrivate Workers
 *        should have private IP addresses. (Value: "WORKER_IP_PRIVATE")
 *    @arg @c kGTLRDataflow_WorkerPool_IpConfiguration_WorkerIpPublic Workers
 *        should have public IP addresses. (Value: "WORKER_IP_PUBLIC")
 *    @arg @c kGTLRDataflow_WorkerPool_IpConfiguration_WorkerIpUnspecified The
 *        configuration is unknown, or unspecified. (Value:
 *        "WORKER_IP_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *ipConfiguration;

/**
 *  The kind of the worker pool; currently only `harness` and `shuffle`
 *  are supported.
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Machine type (e.g. "n1-standard-1"). If empty or unspecified, the
 *  service will attempt to choose a reasonable default.
 */
@property(nonatomic, copy, nullable) NSString *machineType;

/** Metadata to set on the Google Compute Engine VMs. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerPool_Metadata *metadata;

/**
 *  Network to which VMs will be assigned. If empty or unspecified,
 *  the service will use the network "default".
 */
@property(nonatomic, copy, nullable) NSString *network;

/**
 *  The number of threads per worker harness. If empty or unspecified, the
 *  service will choose a number of threads (according to the number of cores
 *  on the selected machine type for batch, or 1 by convention for streaming).
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numThreadsPerWorker;

/**
 *  Number of Google Compute Engine workers in this pool needed to
 *  execute the job. If zero or unspecified, the service will
 *  attempt to choose a reasonable default.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numWorkers;

/**
 *  The action to take on host maintenance, as defined by the Google
 *  Compute Engine API.
 */
@property(nonatomic, copy, nullable) NSString *onHostMaintenance;

/** Packages to be installed on workers. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Package *> *packages;

/** Extra arguments for this worker pool. */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkerPool_PoolArgs *poolArgs;

/**
 *  Subnetwork to which VMs will be assigned, if desired. Expected to be of
 *  the form "regions/REGION/subnetworks/SUBNETWORK".
 */
@property(nonatomic, copy, nullable) NSString *subnetwork;

/**
 *  Settings passed through to Google Compute Engine workers when
 *  using the standard Dataflow task runner. Users should ignore
 *  this field.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_TaskRunnerSettings *taskrunnerSettings;

/**
 *  Sets the policy for determining when to turndown worker pool.
 *  Allowed values are: `TEARDOWN_ALWAYS`, `TEARDOWN_ON_SUCCESS`, and
 *  `TEARDOWN_NEVER`.
 *  `TEARDOWN_ALWAYS` means workers are always torn down regardless of whether
 *  the job succeeds. `TEARDOWN_ON_SUCCESS` means workers are torn down
 *  if the job succeeds. `TEARDOWN_NEVER` means the workers are never torn
 *  down.
 *  If the workers are not torn down by the service, they will
 *  continue to run and use Google Compute Engine VM resources in the
 *  user's project until they are explicitly terminated by the user.
 *  Because of this, Google recommends using the `TEARDOWN_ALWAYS`
 *  policy except for small, manually supervised test jobs.
 *  If unknown or unspecified, the service will attempt to choose a reasonable
 *  default.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownAlways Always
 *        teardown the resource. (Value: "TEARDOWN_ALWAYS")
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownNever Never
 *        teardown the resource. This is useful for debugging and
 *        development. (Value: "TEARDOWN_NEVER")
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownOnSuccess Teardown
 *        the resource on success. This is useful for debugging
 *        failures. (Value: "TEARDOWN_ON_SUCCESS")
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownPolicyUnknown The
 *        teardown policy isn't specified, or is unknown. (Value:
 *        "TEARDOWN_POLICY_UNKNOWN")
 */
@property(nonatomic, copy, nullable) NSString *teardownPolicy;

/**
 *  Required. Docker container image that executes the Cloud Dataflow worker
 *  harness, residing in Google Container Registry.
 */
@property(nonatomic, copy, nullable) NSString *workerHarnessContainerImage;

/**
 *  Zone to run the worker pools in. If empty or unspecified, the service
 *  will attempt to choose a reasonable default.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(nonatomic, copy, nullable) NSString *zoneProperty;

@end


/**
 *  Metadata to set on the Google Compute Engine VMs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_WorkerPool_Metadata : GTLRObject
@end


/**
 *  Extra arguments for this worker pool.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkerPool_PoolArgs : GTLRObject
@end


/**
 *  Provides data to pass through to the worker harness.
 */
@interface GTLRDataflow_WorkerSettings : GTLRObject

/**
 *  The base URL for accessing Google Cloud APIs.
 *  When workers access Google Cloud APIs, they logically do so via
 *  relative URLs. If this field is specified, it supplies the base
 *  URL to use for resolving these relative URLs. The normative
 *  algorithm used is defined by RFC 1808, "Relative Uniform Resource
 *  Locators".
 *  If not specified, the default value is "http://www.googleapis.com/"
 */
@property(nonatomic, copy, nullable) NSString *baseUrl;

/**
 *  Whether to send work progress updates to the service.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reportingEnabled;

/**
 *  The Cloud Dataflow service path relative to the root URL, for example,
 *  "dataflow/v1b3/projects".
 */
@property(nonatomic, copy, nullable) NSString *servicePath;

/**
 *  The Shuffle service path relative to the root URL, for example,
 *  "shuffle/v1beta1".
 */
@property(nonatomic, copy, nullable) NSString *shuffleServicePath;

/**
 *  The prefix of the resources the system should use for temporary
 *  storage.
 *  The supported resource type is:
 *  Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(nonatomic, copy, nullable) NSString *tempStoragePrefix;

/** The ID of the worker running this pipeline. */
@property(nonatomic, copy, nullable) NSString *workerId;

@end


/**
 *  Shutdown notification from workers. This is to be sent by the shutdown
 *  script of the worker VM so that the backend knows that the VM is being
 *  shut down.
 */
@interface GTLRDataflow_WorkerShutdownNotice : GTLRObject

/**
 *  The reason for the worker shutdown.
 *  Current possible values are:
 *  "UNKNOWN": shutdown reason is unknown.
 *  "PREEMPTION": shutdown reason is preemption.
 *  Other possible reasons may be added in the future.
 */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  Service-side response to WorkerMessage issuing shutdown notice.
 */
@interface GTLRDataflow_WorkerShutdownNoticeResponse : GTLRObject
@end


/**
 *  WorkItem represents basic information about a WorkItem to be executed
 *  in the cloud.
 */
@interface GTLRDataflow_WorkItem : GTLRObject

/** Work item-specific configuration as an opaque blob. */
@property(nonatomic, copy, nullable) NSString *configuration;

/**
 *  Identifies this WorkItem.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *identifier;

/**
 *  The initial index to use when reporting the status of the WorkItem.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialReportIndex;

/** Identifies the workflow job this WorkItem belongs to. */
@property(nonatomic, copy, nullable) NSString *jobId;

/** Time when the lease on this Work will expire. */
@property(nonatomic, strong, nullable) GTLRDateTime *leaseExpireTime;

/** Additional information for MapTask WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_MapTask *mapTask;

/**
 *  Any required packages that need to be fetched in order to execute
 *  this WorkItem.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Package *> *packages;

/** Identifies the cloud project this WorkItem belongs to. */
@property(nonatomic, copy, nullable) NSString *projectId;

/** Recommended reporting interval. */
@property(nonatomic, strong, nullable) GTLRDuration *reportStatusInterval;

/** Additional information for SeqMapTask WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_SeqMapTask *seqMapTask;

/** Additional information for ShellTask WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_ShellTask *shellTask;

/** Additional information for source operation WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceOperationRequest *sourceOperationTask;

/** Additional information for StreamingComputationTask WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingComputationTask *streamingComputationTask;

/** Additional information for StreamingConfigTask WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingConfigTask *streamingConfigTask;

/** Additional information for StreamingSetupTask WorkItems. */
@property(nonatomic, strong, nullable) GTLRDataflow_StreamingSetupTask *streamingSetupTask;

@end


/**
 *  The Dataflow service's idea of the current state of a WorkItem
 *  being processed by a worker.
 */
@interface GTLRDataflow_WorkItemServiceState : GTLRObject

/**
 *  Other data returned by the service, specific to the particular
 *  worker harness.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_WorkItemServiceState_HarnessData *harnessData;

/** Time at which the current lease will expire. */
@property(nonatomic, strong, nullable) GTLRDateTime *leaseExpireTime;

/**
 *  The short ids that workers should use in subsequent metric updates.
 *  Workers should strive to use short ids whenever possible, but it is ok
 *  to request the short_id again if a worker lost track of it
 *  (e.g. if the worker is recovering from a crash).
 *  NOTE: it is possible that the response may have short ids for a subset
 *  of the metrics.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_MetricShortId *> *metricShortId;

/**
 *  The index value to use for the next report sent by the worker.
 *  Note: If the report call fails for whatever reason, the worker should
 *  reuse this index for subsequent report attempts.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *nextReportIndex;

/** New recommended reporting interval. */
@property(nonatomic, strong, nullable) GTLRDuration *reportStatusInterval;

/**
 *  The progress point in the WorkItem where the Dataflow service
 *  suggests that the worker truncate the task.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_ApproximateSplitRequest *splitRequest;

/** DEPRECATED in favor of split_request. */
@property(nonatomic, strong, nullable) GTLRDataflow_ApproximateProgress *suggestedStopPoint;

/** Obsolete, always empty. */
@property(nonatomic, strong, nullable) GTLRDataflow_Position *suggestedStopPosition;

@end


/**
 *  Other data returned by the service, specific to the particular
 *  worker harness.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkItemServiceState_HarnessData : GTLRObject
@end


/**
 *  Conveys a worker's progress through the work described by a WorkItem.
 */
@interface GTLRDataflow_WorkItemStatus : GTLRObject

/**
 *  True if the WorkItem was completed (successfully or unsuccessfully).
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *completed;

/** Worker output counters for this WorkItem. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_CounterUpdate *> *counterUpdates;

/** See documentation of stop_position. */
@property(nonatomic, strong, nullable) GTLRDataflow_DynamicSourceSplit *dynamicSourceSplit;

/**
 *  Specifies errors which occurred during processing. If errors are
 *  provided, and completed = true, then the WorkItem is considered
 *  to have failed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_Status *> *errors;

/** DEPRECATED in favor of counter_updates. */
@property(nonatomic, strong, nullable) NSArray<GTLRDataflow_MetricUpdate *> *metricUpdates;

/** DEPRECATED in favor of reported_progress. */
@property(nonatomic, strong, nullable) GTLRDataflow_ApproximateProgress *progress;

/** The worker's progress through this WorkItem. */
@property(nonatomic, strong, nullable) GTLRDataflow_ApproximateReportedProgress *reportedProgress;

/**
 *  The report index. When a WorkItem is leased, the lease will
 *  contain an initial report index. When a WorkItem's status is
 *  reported to the system, the report should be sent with
 *  that report index, and the response will contain the index the
 *  worker should use for the next report. Reports received with
 *  unexpected index values will be rejected by the service.
 *  In order to preserve idempotency, the worker should not alter the
 *  contents of a report, even if the worker must submit the same
 *  report multiple times before getting back a response. The worker
 *  should not submit a subsequent report until the response for the
 *  previous report had been received from the service.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *reportIndex;

/** Amount of time the worker requests for its lease. */
@property(nonatomic, strong, nullable) GTLRDuration *requestedLeaseDuration;

/** DEPRECATED in favor of dynamic_source_split. */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceFork *sourceFork;

/**
 *  If the work item represented a SourceOperationRequest, and the work
 *  is completed, contains the result of the operation.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_SourceOperationResponse *sourceOperationResponse;

/**
 *  A worker may split an active map task in two parts, "primary" and
 *  "residual", continuing to process the primary part and returning the
 *  residual part into the pool of available work.
 *  This event is called a "dynamic split" and is critical to the dynamic
 *  work rebalancing feature. The two obtained sub-tasks are called
 *  "parts" of the split.
 *  The parts, if concatenated, must represent the same input as would
 *  be read by the current task if the split did not happen.
 *  The exact way in which the original task is decomposed into the two
 *  parts is specified either as a position demarcating them
 *  (stop_position), or explicitly as two DerivedSources, if this
 *  task consumes a user-defined source type (dynamic_source_split).
 *  The "current" task is adjusted as a result of the split: after a task
 *  with range [A, B) sends a stop_position update at C, its range is
 *  considered to be [A, C), e.g.:
 *  * Progress should be interpreted relative to the new range, e.g.
 *  "75% completed" means "75% of [A, C) completed"
 *  * The worker should interpret proposed_stop_position relative to the
 *  new range, e.g. "split at 68%" should be interpreted as
 *  "split at 68% of [A, C)".
 *  * If the worker chooses to split again using stop_position, only
 *  stop_positions in [A, C) will be accepted.
 *  * Etc.
 *  dynamic_source_split has similar semantics: e.g., if a task with
 *  source S splits using dynamic_source_split into {P, R}
 *  (where P and R must be together equivalent to S), then subsequent
 *  progress and proposed_stop_position should be interpreted relative
 *  to P, and in a potential subsequent dynamic_source_split into {P', R'},
 *  P' and R' must be together equivalent to P, etc.
 */
@property(nonatomic, strong, nullable) GTLRDataflow_Position *stopPosition;

/**
 *  Total time the worker spent being throttled by external systems.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *totalThrottlerWaitTimeSeconds;

/** Identifies the WorkItem. */
@property(nonatomic, copy, nullable) NSString *workItemId;

@end


/**
 *  An instruction that writes records.
 *  Takes one input, produces no outputs.
 */
@interface GTLRDataflow_WriteInstruction : GTLRObject

/** The input. */
@property(nonatomic, strong, nullable) GTLRDataflow_InstructionInput *input;

/** The sink to write to. */
@property(nonatomic, strong, nullable) GTLRDataflow_Sink *sink;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
