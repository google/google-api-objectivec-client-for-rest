// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Dataflow API (dataflow/v1b3)
// Description:
//   Develops and executes data processing patterns like ETL, batch computation,
//   and continuous computation.
// Documentation:
//   https://cloud.google.com/dataflow

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRDataflow_ApproximateProgress;
@class GTLRDataflow_ApproximateReportedProgress;
@class GTLRDataflow_ApproximateSplitRequest;
@class GTLRDataflow_AutoscalingSettings;
@class GTLRDataflow_ComputationTopology;
@class GTLRDataflow_ConcatPosition;
@class GTLRDataflow_CounterMetadata;
@class GTLRDataflow_CounterStructuredName;
@class GTLRDataflow_CounterStructuredNameAndMetadata;
@class GTLRDataflow_CounterUpdate;
@class GTLRDataflow_CustomSourceLocation;
@class GTLRDataflow_DataDiskAssignment;
@class GTLRDataflow_DerivedSource;
@class GTLRDataflow_Disk;
@class GTLRDataflow_DynamicSourceSplit;
@class GTLRDataflow_Environment;
@class GTLRDataflow_EnvironmentInternalExperiments;
@class GTLRDataflow_EnvironmentSdkPipelineOptions;
@class GTLRDataflow_EnvironmentUserAgent;
@class GTLRDataflow_EnvironmentVersion;
@class GTLRDataflow_FlattenInstruction;
@class GTLRDataflow_FloatingPointList;
@class GTLRDataflow_FloatingPointMean;
@class GTLRDataflow_InstructionInput;
@class GTLRDataflow_InstructionOutput;
@class GTLRDataflow_InstructionOutputCodec;
@class GTLRDataflow_IntegerList;
@class GTLRDataflow_IntegerMean;
@class GTLRDataflow_Job;
@class GTLRDataflow_JobExecutionInfo;
@class GTLRDataflow_JobExecutionInfoStages;
@class GTLRDataflow_JobExecutionStageInfo;
@class GTLRDataflow_JobMessage;
@class GTLRDataflow_JobTransformNameMapping;
@class GTLRDataflow_KeyRangeDataDiskAssignment;
@class GTLRDataflow_KeyRangeLocation;
@class GTLRDataflow_MapTask;
@class GTLRDataflow_MetricShortId;
@class GTLRDataflow_MetricStructuredName;
@class GTLRDataflow_MetricStructuredNameContext;
@class GTLRDataflow_MetricUpdate;
@class GTLRDataflow_MountedDataDisk;
@class GTLRDataflow_MultiOutputInfo;
@class GTLRDataflow_NameAndKind;
@class GTLRDataflow_Package;
@class GTLRDataflow_ParallelInstruction;
@class GTLRDataflow_ParDoInstruction;
@class GTLRDataflow_ParDoInstructionUserFn;
@class GTLRDataflow_PartialGroupByKeyInstruction;
@class GTLRDataflow_PartialGroupByKeyInstructionInputElementCodec;
@class GTLRDataflow_PartialGroupByKeyInstructionValueCombiningFn;
@class GTLRDataflow_Position;
@class GTLRDataflow_PubsubLocation;
@class GTLRDataflow_ReadInstruction;
@class GTLRDataflow_ReportedParallelism;
@class GTLRDataflow_SeqMapTask;
@class GTLRDataflow_SeqMapTaskOutputInfo;
@class GTLRDataflow_SeqMapTaskUserFn;
@class GTLRDataflow_ShellTask;
@class GTLRDataflow_SideInputInfo;
@class GTLRDataflow_SideInputInfoKind;
@class GTLRDataflow_Sink;
@class GTLRDataflow_SinkCodec;
@class GTLRDataflow_SinkSpec;
@class GTLRDataflow_Source;
@class GTLRDataflow_SourceBaseSpecsItem;
@class GTLRDataflow_SourceCodec;
@class GTLRDataflow_SourceFork;
@class GTLRDataflow_SourceGetMetadataRequest;
@class GTLRDataflow_SourceGetMetadataResponse;
@class GTLRDataflow_SourceMetadata;
@class GTLRDataflow_SourceOperationRequest;
@class GTLRDataflow_SourceOperationResponse;
@class GTLRDataflow_SourceSpec;
@class GTLRDataflow_SourceSplitOptions;
@class GTLRDataflow_SourceSplitRequest;
@class GTLRDataflow_SourceSplitResponse;
@class GTLRDataflow_SourceSplitShard;
@class GTLRDataflow_SplitInt64;
@class GTLRDataflow_StateFamilyConfig;
@class GTLRDataflow_Status;
@class GTLRDataflow_StatusDetailsItem;
@class GTLRDataflow_Step;
@class GTLRDataflow_StepProperties;
@class GTLRDataflow_StreamingComputationConfig;
@class GTLRDataflow_StreamingComputationRanges;
@class GTLRDataflow_StreamingComputationTask;
@class GTLRDataflow_StreamingConfigTask;
@class GTLRDataflow_StreamingConfigTaskUserStepToStateFamilyNameMap;
@class GTLRDataflow_StreamingSetupTask;
@class GTLRDataflow_StreamingSideInputLocation;
@class GTLRDataflow_StreamingStageLocation;
@class GTLRDataflow_StreamLocation;
@class GTLRDataflow_StringList;
@class GTLRDataflow_TaskRunnerSettings;
@class GTLRDataflow_TopologyConfig;
@class GTLRDataflow_TopologyConfigUserStageToComputationNameMap;
@class GTLRDataflow_WorkerHealthReport;
@class GTLRDataflow_WorkerHealthReportPodsItem;
@class GTLRDataflow_WorkerHealthReportResponse;
@class GTLRDataflow_WorkerMessage;
@class GTLRDataflow_WorkerMessageCode;
@class GTLRDataflow_WorkerMessageCodeParameters;
@class GTLRDataflow_WorkerMessageLabels;
@class GTLRDataflow_WorkerMessageResponse;
@class GTLRDataflow_WorkerPool;
@class GTLRDataflow_WorkerPoolMetadata;
@class GTLRDataflow_WorkerPoolPoolArgs;
@class GTLRDataflow_WorkerSettings;
@class GTLRDataflow_WorkItem;
@class GTLRDataflow_WorkItemServiceState;
@class GTLRDataflow_WorkItemServiceStateHarnessData;
@class GTLRDataflow_WorkItemStatus;
@class GTLRDataflow_WriteInstruction;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRDataflow_AutoscalingSettings.algorithm

/** Value: "AUTOSCALING_ALGORITHM_BASIC" */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmBasic;
/** Value: "AUTOSCALING_ALGORITHM_NONE" */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmNone;
/** Value: "AUTOSCALING_ALGORITHM_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterMetadata.kind

/** Value: "AND" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_And;
/** Value: "INVALID" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Invalid;
/** Value: "MAX" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Max;
/** Value: "MEAN" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Mean;
/** Value: "MIN" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Min;
/** Value: "OR" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Or;
/** Value: "SET" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Set;
/** Value: "SUM" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_Kind_Sum;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterMetadata.standardUnits

/** Value: "BYTES" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Bytes;
/** Value: "BYTES_PER_SEC" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_BytesPerSec;
/** Value: "MICROSECONDS" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Microseconds;
/** Value: "MILLISECONDS" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Milliseconds;
/** Value: "NANOSECONDS" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_Nanoseconds;
/** Value: "TIMESTAMP_MSEC" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_TimestampMsec;
/** Value: "TIMESTAMP_NSEC" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_TimestampNsec;
/** Value: "TIMESTAMP_USEC" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterMetadata_StandardUnits_TimestampUsec;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterStructuredName.portion

/** Value: "ALL" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Portion_All;
/** Value: "KEY" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Portion_Key;
/** Value: "VALUE" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_Portion_Value;

// ----------------------------------------------------------------------------
// GTLRDataflow_CounterStructuredName.standardOrigin

/** Value: "DATAFLOW" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_StandardOrigin_Dataflow;
/** Value: "USER" */
GTLR_EXTERN NSString * const kGTLRDataflow_CounterStructuredName_StandardOrigin_User;

// ----------------------------------------------------------------------------
// GTLRDataflow_DerivedSource.derivationMode

/** Value: "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeChildOfCurrent;
/** Value: "SOURCE_DERIVATION_MODE_INDEPENDENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeIndependent;
/** Value: "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeSiblingOfCurrent;
/** Value: "SOURCE_DERIVATION_MODE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_Job.currentState

/** Value: "JOB_STATE_CANCELLED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateCancelled;
/** Value: "JOB_STATE_DONE" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateDone;
/** Value: "JOB_STATE_DRAINED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateDrained;
/** Value: "JOB_STATE_DRAINING" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateDraining;
/** Value: "JOB_STATE_FAILED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateFailed;
/** Value: "JOB_STATE_RUNNING" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateRunning;
/** Value: "JOB_STATE_STOPPED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateStopped;
/** Value: "JOB_STATE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateUnknown;
/** Value: "JOB_STATE_UPDATED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_CurrentState_JobStateUpdated;

// ----------------------------------------------------------------------------
// GTLRDataflow_Job.requestedState

/** Value: "JOB_STATE_CANCELLED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateCancelled;
/** Value: "JOB_STATE_DONE" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateDone;
/** Value: "JOB_STATE_DRAINED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateDrained;
/** Value: "JOB_STATE_DRAINING" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateDraining;
/** Value: "JOB_STATE_FAILED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateFailed;
/** Value: "JOB_STATE_RUNNING" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateRunning;
/** Value: "JOB_STATE_STOPPED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateStopped;
/** Value: "JOB_STATE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateUnknown;
/** Value: "JOB_STATE_UPDATED" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_RequestedState_JobStateUpdated;

// ----------------------------------------------------------------------------
// GTLRDataflow_Job.type

/** Value: "JOB_TYPE_BATCH" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_Type_JobTypeBatch;
/** Value: "JOB_TYPE_STREAMING" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_Type_JobTypeStreaming;
/** Value: "JOB_TYPE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_Job_Type_JobTypeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_JobMessage.messageImportance

/** Value: "JOB_MESSAGE_BASIC" */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageBasic;
/** Value: "JOB_MESSAGE_DEBUG" */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageDebug;
/** Value: "JOB_MESSAGE_DETAILED" */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageDetailed;
/** Value: "JOB_MESSAGE_ERROR" */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageError;
/** Value: "JOB_MESSAGE_IMPORTANCE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageImportanceUnknown;
/** Value: "JOB_MESSAGE_WARNING" */
GTLR_EXTERN NSString * const kGTLRDataflow_JobMessage_MessageImportance_JobMessageWarning;

// ----------------------------------------------------------------------------
// GTLRDataflow_NameAndKind.kind

/** Value: "AND" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_And;
/** Value: "INVALID" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Invalid;
/** Value: "MAX" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Max;
/** Value: "MEAN" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Mean;
/** Value: "MIN" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Min;
/** Value: "OR" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Or;
/** Value: "SET" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Set;
/** Value: "SUM" */
GTLR_EXTERN NSString * const kGTLRDataflow_NameAndKind_Kind_Sum;

// ----------------------------------------------------------------------------
// GTLRDataflow_SourceSplitResponse.outcome

/** Value: "SOURCE_SPLIT_OUTCOME_SPLITTING_HAPPENED" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeSplittingHappened;
/** Value: "SOURCE_SPLIT_OUTCOME_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUnknown;
/** Value: "SOURCE_SPLIT_OUTCOME_USE_CURRENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUseCurrent;

// ----------------------------------------------------------------------------
// GTLRDataflow_SourceSplitShard.derivationMode

/** Value: "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeChildOfCurrent;
/** Value: "SOURCE_DERIVATION_MODE_INDEPENDENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeIndependent;
/** Value: "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeSiblingOfCurrent;
/** Value: "SOURCE_DERIVATION_MODE_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_StreamingComputationTask.taskType

/** Value: "STREAMING_COMPUTATION_TASK_START" */
GTLR_EXTERN NSString * const kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStart;
/** Value: "STREAMING_COMPUTATION_TASK_STOP" */
GTLR_EXTERN NSString * const kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStop;
/** Value: "STREAMING_COMPUTATION_TASK_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_WorkerPool.defaultPackageSet

/** Value: "DEFAULT_PACKAGE_SET_JAVA" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetJava;
/** Value: "DEFAULT_PACKAGE_SET_NONE" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetNone;
/** Value: "DEFAULT_PACKAGE_SET_PYTHON" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetPython;
/** Value: "DEFAULT_PACKAGE_SET_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetUnknown;

// ----------------------------------------------------------------------------
// GTLRDataflow_WorkerPool.teardownPolicy

/** Value: "TEARDOWN_ALWAYS" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownAlways;
/** Value: "TEARDOWN_NEVER" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownNever;
/** Value: "TEARDOWN_ON_SUCCESS" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownOnSuccess;
/** Value: "TEARDOWN_POLICY_UNKNOWN" */
GTLR_EXTERN NSString * const kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownPolicyUnknown;

/**
 *  Obsolete in favor of ApproximateReportedProgress and
 *  ApproximateSplitRequest.
 */
@interface GTLRDataflow_ApproximateProgress : GTLRObject

/**
 *  Obsolete.
 *
 *  Uses NSNumber of floatValue.
 */
@property(strong, nullable) NSNumber *percentComplete;

/** Obsolete. */
@property(strong, nullable) GTLRDataflow_Position *position;

/** Obsolete. */
@property(copy, nullable) NSString *remainingTime;

@end


/**
 *  A progress measurement of a WorkItem by a worker.
 */
@interface GTLRDataflow_ApproximateReportedProgress : GTLRObject

/**
 *  Total amount of parallelism in the portion of input of this task that has
 *  already been consumed and is no longer active. In the first two examples
 *  above (see remaining_parallelism), the value should be 29 or 2 respectively.
 *  The sum of remaining_parallelism and consumed_parallelism should equal the
 *  total amount of parallelism in this work item. If specified, must be finite.
 */
@property(strong, nullable) GTLRDataflow_ReportedParallelism *consumedParallelism;

/**
 *  Completion as fraction of the input consumed, from 0.0 (beginning, nothing
 *  consumed), to 1.0 (end of the input, entire input consumed).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *fractionConsumed;

/** A Position within the work to represent a progress. */
@property(strong, nullable) GTLRDataflow_Position *position;

/**
 *  Total amount of parallelism in the input of this task that remains, (i.e.
 *  can be delegated to this task and any new tasks via dynamic splitting).
 *  Always at least 1 for non-finished work items and 0 for finished. "Amount of
 *  parallelism" refers to how many non-empty parts of the input can be read in
 *  parallel. This does not necessarily equal number of records. An input that
 *  can be read in parallel down to the individual records is called "perfectly
 *  splittable". An example of non-perfectly parallelizable input is a
 *  block-compressed file format where a block of records has to be read as a
 *  whole, but different blocks can be read in parallel. Examples: * If we are
 *  processing record #30 (starting at 1) out of 50 in a perfectly splittable
 *  50-record input, this value should be 21 (20 remaining + 1 current). * If we
 *  are reading through block 3 in a block-compressed file consisting of 5
 *  blocks, this value should be 3 (since blocks 4 and 5 can be processed in
 *  parallel by new tasks via dynamic splitting and the current task remains
 *  processing block 3). * If we are reading through the last block in a
 *  block-compressed file, or reading or processing the last record in a
 *  perfectly splittable input, this value should be 1, because apart from the
 *  current task, no additional remainder can be split off.
 */
@property(strong, nullable) GTLRDataflow_ReportedParallelism *remainingParallelism;

@end


/**
 *  A suggestion by the service to the worker to dynamically split the WorkItem.
 */
@interface GTLRDataflow_ApproximateSplitRequest : GTLRObject

/**
 *  A fraction at which to split the work item, from 0.0 (beginning of the
 *  input) to 1.0 (end of the input).
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *fractionConsumed;

/** A Position at which to split the work item. */
@property(strong, nullable) GTLRDataflow_Position *position;

@end


/**
 *  Settings for WorkerPool autoscaling.
 */
@interface GTLRDataflow_AutoscalingSettings : GTLRObject

/**
 *  The algorithm to use for autoscaling.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmBasic
 *        Value "AUTOSCALING_ALGORITHM_BASIC"
 *    @arg @c kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmNone
 *        Value "AUTOSCALING_ALGORITHM_NONE"
 *    @arg @c kGTLRDataflow_AutoscalingSettings_Algorithm_AutoscalingAlgorithmUnknown
 *        Value "AUTOSCALING_ALGORITHM_UNKNOWN"
 */
@property(copy, nullable) NSString *algorithm;

/**
 *  The maximum number of workers to cap scaling at.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *maxNumWorkers;

@end


/**
 *  All configuration data for a particular Computation.
 */
@interface GTLRDataflow_ComputationTopology : GTLRObject

/** The ID of the computation. */
@property(copy, nullable) NSString *computationId;

/** The inputs to the computation. */
@property(strong, nullable) NSArray<GTLRDataflow_StreamLocation *> *inputs;

/** The key ranges processed by the computation. */
@property(strong, nullable) NSArray<GTLRDataflow_KeyRangeLocation *> *keyRanges;

/** The outputs from the computation. */
@property(strong, nullable) NSArray<GTLRDataflow_StreamLocation *> *outputs;

/** The state family values. */
@property(strong, nullable) NSArray<GTLRDataflow_StateFamilyConfig *> *stateFamilies;

/** The system stage name. */
@property(copy, nullable) NSString *systemStageName;

/** The user stage name. */
@property(copy, nullable) NSString *userStageName;

@end


/**
 *  A position that encapsulates an inner position and an index for the inner
 *  position. A ConcatPosition can be used by a reader of a source that
 *  encapsulates a set of other sources.
 */
@interface GTLRDataflow_ConcatPosition : GTLRObject

/**
 *  Index of the inner source.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *index;

/** Position within the inner source. */
@property(strong, nullable) GTLRDataflow_Position *position;

@end


/**
 *  CounterMetadata includes all static non-name non-value counter attributes.
 */
@interface GTLRDataflow_CounterMetadata : GTLRObject

/**
 *  Human-readable description of the counter semantics.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  Counter aggregation kind.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_And Value "AND"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Invalid Value "INVALID"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Max Value "MAX"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Mean Value "MEAN"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Min Value "MIN"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Or Value "OR"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Set Value "SET"
 *    @arg @c kGTLRDataflow_CounterMetadata_Kind_Sum Value "SUM"
 */
@property(copy, nullable) NSString *kind;

/** A string referring to the unit type. */
@property(copy, nullable) NSString *otherUnits;

/**
 *  System defined Units, see above enum.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Bytes Value "BYTES"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_BytesPerSec Value
 *        "BYTES_PER_SEC"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Microseconds Value
 *        "MICROSECONDS"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Milliseconds Value
 *        "MILLISECONDS"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_Nanoseconds Value
 *        "NANOSECONDS"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_TimestampMsec Value
 *        "TIMESTAMP_MSEC"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_TimestampNsec Value
 *        "TIMESTAMP_NSEC"
 *    @arg @c kGTLRDataflow_CounterMetadata_StandardUnits_TimestampUsec Value
 *        "TIMESTAMP_USEC"
 */
@property(copy, nullable) NSString *standardUnits;

@end


/**
 *  Identifies a counter within a per-job namespace. Counters whose structured
 *  names are the same get merged into a single value for the job.
 */
@interface GTLRDataflow_CounterStructuredName : GTLRObject

/** Name of the optimized step being executed by the workers. */
@property(copy, nullable) NSString *componentStepName;

/** Name of the stage. An execution step contains multiple component steps. */
@property(copy, nullable) NSString *executionStepName;

/**
 *  Counter name. Not necessarily globally-unique, but unique within the context
 *  of the other fields. Required.
 */
@property(copy, nullable) NSString *name;

/**
 *  System generated name of the original step in the user's graph, before
 *  optimization.
 */
@property(copy, nullable) NSString *originalStepName;

/** A string containing the origin of the counter. */
@property(copy, nullable) NSString *otherOrigin;

/**
 *  Portion of this counter, either key or value.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterStructuredName_Portion_All Value "ALL"
 *    @arg @c kGTLRDataflow_CounterStructuredName_Portion_Key Value "KEY"
 *    @arg @c kGTLRDataflow_CounterStructuredName_Portion_Value Value "VALUE"
 */
@property(copy, nullable) NSString *portion;

/**
 *  One of the standard Origins defined above.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_CounterStructuredName_StandardOrigin_Dataflow Value
 *        "DATAFLOW"
 *    @arg @c kGTLRDataflow_CounterStructuredName_StandardOrigin_User Value
 *        "USER"
 */
@property(copy, nullable) NSString *standardOrigin;

/** ID of a particular worker. */
@property(copy, nullable) NSString *workerId;

@end


/**
 *  A single message which encapsulates structured name and metadata for a given
 *  counter.
 */
@interface GTLRDataflow_CounterStructuredNameAndMetadata : GTLRObject

/** Metadata associated with a counter */
@property(strong, nullable) GTLRDataflow_CounterMetadata *metadata;

/** Structured name of the counter. */
@property(strong, nullable) GTLRDataflow_CounterStructuredName *name;

@end


/**
 *  An update to a Counter sent from a worker.
 */
@interface GTLRDataflow_CounterUpdate : GTLRObject

/**
 *  Boolean value for And, Or.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *boolean;

/**
 *  True if this counter is reported as the total cumulative aggregate value
 *  accumulated since the worker started working on this WorkItem. By default
 *  this is false, indicating that this counter is reported as a delta.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *cumulative;

/**
 *  Floating point value for Sum, Max, Min.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *floatingPoint;

/** List of floating point numbers, for Set. */
@property(strong, nullable) GTLRDataflow_FloatingPointList *floatingPointList;

/** Floating point mean aggregation value for Mean. */
@property(strong, nullable) GTLRDataflow_FloatingPointMean *floatingPointMean;

/** Integer value for Sum, Max, Min. */
@property(strong, nullable) GTLRDataflow_SplitInt64 *integer;

/** List of integers, for Set. */
@property(strong, nullable) GTLRDataflow_IntegerList *integerList;

/** Integer mean aggregation value for Mean. */
@property(strong, nullable) GTLRDataflow_IntegerMean *integerMean;

/**
 *  Value for internally-defined counters used by the Dataflow service.
 *
 *  Can be any valid JSON type.
 */
@property(strong, nullable) id internal;

/** Counter name and aggregation type. */
@property(strong, nullable) GTLRDataflow_NameAndKind *nameAndKind;

/**
 *  The service-generated short identifier for this counter. The short_id ->
 *  (name, metadata) mapping is constant for the lifetime of a job.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *shortId;

/** List of strings, for Set. */
@property(strong, nullable) GTLRDataflow_StringList *stringList;

/** Counter structured name and metadata. */
@property(strong, nullable) GTLRDataflow_CounterStructuredNameAndMetadata *structuredNameAndMetadata;

@end


/**
 *  Identifies the location of a custom souce.
 */
@interface GTLRDataflow_CustomSourceLocation : GTLRObject

/**
 *  Whether this source is stateful.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *stateful;

@end


/**
 *  Data disk assignment for a given VM instance.
 */
@interface GTLRDataflow_DataDiskAssignment : GTLRObject

/**
 *  Mounted data disks. The order is important a data disk's 0-based index in
 *  this list defines which persistent directory the disk is mounted to, for
 *  example the list of { "myproject-1014-104817-4c2-harness-0-disk-0" }, {
 *  "myproject-1014-104817-4c2-harness-0-disk-1" }.
 */
@property(strong, nullable) NSArray<NSString *> *dataDisks;

/**
 *  VM instance name the data disks mounted to, for example
 *  "myproject-1014-104817-4c2-harness-0".
 */
@property(copy, nullable) NSString *vmInstance;

@end


/**
 *  Specification of one of the bundles produced as a result of splitting a
 *  Source (e.g. when executing a SourceSplitRequest, or when splitting an
 *  active task using WorkItemStatus.dynamic_source_split), relative to the
 *  source being split.
 */
@interface GTLRDataflow_DerivedSource : GTLRObject

/**
 *  What source to base the produced source on (if any).
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeChildOfCurrent
 *        Value "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT"
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeIndependent
 *        Value "SOURCE_DERIVATION_MODE_INDEPENDENT"
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeSiblingOfCurrent
 *        Value "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT"
 *    @arg @c kGTLRDataflow_DerivedSource_DerivationMode_SourceDerivationModeUnknown
 *        Value "SOURCE_DERIVATION_MODE_UNKNOWN"
 */
@property(copy, nullable) NSString *derivationMode;

/** Specification of the source. */
@property(strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  Describes the data disk used by a workflow job.
 */
@interface GTLRDataflow_Disk : GTLRObject

/**
 *  Disk storage type, as defined by Google Compute Engine. This must be a disk
 *  type appropriate to the project and zone in which the workers will run. If
 *  unknown or unspecified, the service will attempt to choose a reasonable
 *  default. For example, the standard persistent disk type is a resource name
 *  typically ending in "pd-standard". If SSD persistent disks are available,
 *  the resource name typically ends with "pd-ssd". The actual valid values are
 *  defined the Google Compute Engine API, not by the Dataflow API; consult the
 *  Google Compute Engine documentation for more information about determining
 *  the set of available disk types for a particular project and zone. Google
 *  Compute Engine Disk types are local to a particular project in a particular
 *  zone, and so the resource name will typically look something like this:
 *  compute.googleapis.com/projects/
 *  /zones//diskTypes/pd-standard
 */
@property(copy, nullable) NSString *diskType;

/** Directory in a VM where disk is mounted. */
@property(copy, nullable) NSString *mountPoint;

/**
 *  Size of disk in GB. If zero or unspecified, the service will attempt to
 *  choose a reasonable default.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *sizeGb;

@end


/**
 *  When a task splits using WorkItemStatus.dynamic_source_split, this message
 *  describes the two parts of the split relative to the description of the
 *  current task's input.
 */
@interface GTLRDataflow_DynamicSourceSplit : GTLRObject

/**
 *  Primary part (continued to be processed by worker). Specified relative to
 *  the previously-current source. Becomes current.
 */
@property(strong, nullable) GTLRDataflow_DerivedSource *primary;

/**
 *  Residual part (returned to the pool of work). Specified relative to the
 *  previously-current source.
 */
@property(strong, nullable) GTLRDataflow_DerivedSource *residual;

@end


/**
 *  Describes the environment in which a Dataflow Job runs.
 */
@interface GTLRDataflow_Environment : GTLRObject

/**
 *  The type of cluster manager API to use. If unknown or unspecified, the
 *  service will attempt to choose a reasonable default. This should be in the
 *  form of the API service name, e.g. "compute.googleapis.com".
 */
@property(copy, nullable) NSString *clusterManagerApiService;

/**
 *  The dataset for the current project where various workflow related tables
 *  are stored. The supported resource type is: Google BigQuery:
 *  bigquery.googleapis.com/{dataset}
 */
@property(copy, nullable) NSString *dataset;

/** The list of experiments to enable. */
@property(strong, nullable) NSArray<NSString *> *experiments;

/** Experimental settings. */
@property(strong, nullable) GTLRDataflow_EnvironmentInternalExperiments *internalExperiments;

/**
 *  The Dataflow SDK pipeline options specified by the user. These options are
 *  passed through the service and are used to recreate the SDK pipeline options
 *  on the worker in a language agnostic and platform independent way.
 */
@property(strong, nullable) GTLRDataflow_EnvironmentSdkPipelineOptions *sdkPipelineOptions;

/**
 *  The prefix of the resources the system should use for temporary storage. The
 *  system will append the suffix "/temp-{JOBNAME} to this resource prefix,
 *  where {JOBNAME} is the value of the job_name field. The resulting bucket and
 *  object prefix is used as the prefix of the resources used to store temporary
 *  data needed during the job execution. NOTE: This will override the value in
 *  taskrunner_settings. The supported resource type is: Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(copy, nullable) NSString *tempStoragePrefix;

/** A description of the process that generated the request. */
@property(strong, nullable) GTLRDataflow_EnvironmentUserAgent *userAgent;

/**
 *  A structure describing which components and their versions of the service
 *  are required in order to run the job.
 */
@property(strong, nullable) GTLRDataflow_EnvironmentVersion *version;

/**
 *  Worker pools. At least one "harness" worker pool must be specified in order
 *  for the job to have workers.
 */
@property(strong, nullable) NSArray<GTLRDataflow_WorkerPool *> *workerPools;

@end


/**
 *  Experimental settings.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_EnvironmentInternalExperiments : GTLRObject
@end


/**
 *  The Dataflow SDK pipeline options specified by the user. These options are
 *  passed through the service and are used to recreate the SDK pipeline options
 *  on the worker in a language agnostic and platform independent way.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_EnvironmentSdkPipelineOptions : GTLRObject
@end


/**
 *  A description of the process that generated the request.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_EnvironmentUserAgent : GTLRObject
@end


/**
 *  A structure describing which components and their versions of the service
 *  are required in order to run the job.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_EnvironmentVersion : GTLRObject
@end


/**
 *  An instruction that copies its inputs (zero or more) to its (single) output.
 */
@interface GTLRDataflow_FlattenInstruction : GTLRObject

/** Describes the inputs to the flatten instruction. */
@property(strong, nullable) NSArray<GTLRDataflow_InstructionInput *> *inputs;

@end


/**
 *  A metric value representing a list of floating point numbers.
 */
@interface GTLRDataflow_FloatingPointList : GTLRObject

/**
 *  Elements of the list.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSArray<NSNumber *> *elements;

@end


/**
 *  A representation of a floating point mean metric contribution.
 */
@interface GTLRDataflow_FloatingPointMean : GTLRObject

/** The number of values being aggregated. */
@property(strong, nullable) GTLRDataflow_SplitInt64 *count;

/**
 *  The sum of all values being aggregated.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *sum;

@end


/**
 *  An input of an instruction, as a reference to an output of a producer
 *  instruction.
 */
@interface GTLRDataflow_InstructionInput : GTLRObject

/**
 *  The output index (origin zero) within the producer.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *outputNum;

/**
 *  The index (origin zero) of the parallel instruction that produces the output
 *  to be consumed by this input. This index is relative to the list of
 *  instructions in this input's instruction's containing MapTask.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *producerInstructionIndex;

@end


/**
 *  An output of an instruction.
 */
@interface GTLRDataflow_InstructionOutput : GTLRObject

/** The codec to use to encode data being written via this output. */
@property(strong, nullable) GTLRDataflow_InstructionOutputCodec *codec;

/** The user-provided name of this output. */
@property(copy, nullable) NSString *name;

/** System-defined name of this output. Unique across the workflow. */
@property(copy, nullable) NSString *systemName;

@end


/**
 *  The codec to use to encode data being written via this output.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_InstructionOutputCodec : GTLRObject
@end


/**
 *  A metric value representing a list of integers.
 */
@interface GTLRDataflow_IntegerList : GTLRObject

/** Elements of the list. */
@property(strong, nullable) NSArray<GTLRDataflow_SplitInt64 *> *elements;

@end


/**
 *  A representation of an integer mean metric contribution.
 */
@interface GTLRDataflow_IntegerMean : GTLRObject

/** The number of values being aggregated. */
@property(strong, nullable) GTLRDataflow_SplitInt64 *count;

/** The sum of all values being aggregated. */
@property(strong, nullable) GTLRDataflow_SplitInt64 *sum;

@end


/**
 *  Defines a job to be run by the Dataflow service.
 */
@interface GTLRDataflow_Job : GTLRObject

/**
 *  Client's unique identifier of the job, re-used by SDK across retried
 *  attempts. If this field is set, the service will ensure its uniqueness. That
 *  is, the request to create a job will fail if the service has knowledge of a
 *  previously submitted job with the same client's id and job name. The caller
 *  may, for example, use this field to ensure idempotence of job creation
 *  across retried attempts to create a job. By default, the field is empty and,
 *  in that case, the service ignores it.
 */
@property(copy, nullable) NSString *clientRequestId;

/**
 *  Timestamp when job was initially created. Immutable, set by the Dataflow
 *  service.
 */
@property(copy, nullable) NSString *createTime;

/**
 *  The current state of the job. Jobs are created in the JOB_STATE_STOPPED
 *  state unless otherwise specified. A job in the JOB_STATE_RUNNING state may
 *  asynchronously enter a terminal state. Once a job has reached a terminal
 *  state, no further state updates may be made. This field may be mutated by
 *  the Dataflow service; callers cannot mutate it.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateCancelled Value
 *        "JOB_STATE_CANCELLED"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateDone Value "JOB_STATE_DONE"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateDrained Value
 *        "JOB_STATE_DRAINED"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateDraining Value
 *        "JOB_STATE_DRAINING"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateFailed Value
 *        "JOB_STATE_FAILED"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateRunning Value
 *        "JOB_STATE_RUNNING"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateStopped Value
 *        "JOB_STATE_STOPPED"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateUnknown Value
 *        "JOB_STATE_UNKNOWN"
 *    @arg @c kGTLRDataflow_Job_CurrentState_JobStateUpdated Value
 *        "JOB_STATE_UPDATED"
 */
@property(copy, nullable) NSString *currentState;

/** The timestamp associated with the current state. */
@property(copy, nullable) NSString *currentStateTime;

/** Environment for the job. */
@property(strong, nullable) GTLRDataflow_Environment *environment;

/** Information about how the Dataflow service will actually run the job. */
@property(strong, nullable) GTLRDataflow_JobExecutionInfo *executionInfo;

/**
 *  The unique ID of this job. This field is set by the Dataflow service when
 *  the Job is created, and is immutable for the life of the Job.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  The user-specified Dataflow job name. Only one Job with a given name may
 *  exist in a project at any given time. If a caller attempts to create a Job
 *  with the same name as an already-existing Job, the attempt will return the
 *  existing Job. The name must match the regular expression
 *  [a-z]([-a-z0-9]{0,38}[a-z0-9])?
 */
@property(copy, nullable) NSString *name;

/** The project which owns the job. */
@property(copy, nullable) NSString *projectId;

/**
 *  If another job is an update of this job (and thus, this job is in
 *  JOB_STATE_UPDATED), this field will contain the ID of that job.
 */
@property(copy, nullable) NSString *replacedByJobId;

/**
 *  If this job is an update of an existing job, this field will be the ID of
 *  the job it replaced. When sending a CreateJobRequest, you can update a job
 *  by specifying it here. The job named here will be stopped, and its
 *  intermediate state transferred to this job.
 */
@property(copy, nullable) NSString *replaceJobId;

/**
 *  The job's requested state. UpdateJob may be used to switch between the
 *  JOB_STATE_STOPPED and JOB_STATE_RUNNING states, by setting requested_state.
 *  UpdateJob may also be used to directly set a job's requested state to
 *  JOB_STATE_CANCELLED or JOB_STATE_DONE, irrevocably terminating the job if it
 *  has not already reached a terminal state.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateCancelled Value
 *        "JOB_STATE_CANCELLED"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateDone Value
 *        "JOB_STATE_DONE"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateDrained Value
 *        "JOB_STATE_DRAINED"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateDraining Value
 *        "JOB_STATE_DRAINING"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateFailed Value
 *        "JOB_STATE_FAILED"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateRunning Value
 *        "JOB_STATE_RUNNING"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateStopped Value
 *        "JOB_STATE_STOPPED"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateUnknown Value
 *        "JOB_STATE_UNKNOWN"
 *    @arg @c kGTLRDataflow_Job_RequestedState_JobStateUpdated Value
 *        "JOB_STATE_UPDATED"
 */
@property(copy, nullable) NSString *requestedState;

/** The top-level steps that constitute the entire job. */
@property(strong, nullable) NSArray<GTLRDataflow_Step *> *steps;

/**
 *  A set of files the system should be aware of that are used for temporary
 *  storage. These temporary files will be removed on job completion. No
 *  duplicates are allowed. No file patterns are supported. The supported files
 *  are: Google Cloud Storage: storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(strong, nullable) NSArray<NSString *> *tempFiles;

/**
 *  Map of transform name prefixes of the job to be replaced to the
 *  corresponding name prefixes of the new job.
 */
@property(strong, nullable) GTLRDataflow_JobTransformNameMapping *transformNameMapping;

/**
 *  The type of dataflow job.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_Job_Type_JobTypeBatch Value "JOB_TYPE_BATCH"
 *    @arg @c kGTLRDataflow_Job_Type_JobTypeStreaming Value "JOB_TYPE_STREAMING"
 *    @arg @c kGTLRDataflow_Job_Type_JobTypeUnknown Value "JOB_TYPE_UNKNOWN"
 */
@property(copy, nullable) NSString *type;

@end


/**
 *  Map of transform name prefixes of the job to be replaced to the
 *  corresponding name prefixes of the new job.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_JobTransformNameMapping : GTLRObject
@end


/**
 *  Additional information about how a Dataflow job will be executed which isnâ€™t
 *  contained in the submitted job.
 */
@interface GTLRDataflow_JobExecutionInfo : GTLRObject

/** A mapping from each stage to the information about that stage. */
@property(strong, nullable) GTLRDataflow_JobExecutionInfoStages *stages;

@end


/**
 *  A mapping from each stage to the information about that stage.
 *
 *  @note This class is documented as having more properties of
 *        GTLRDataflow_JobExecutionStageInfo. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_JobExecutionInfoStages : GTLRObject
@end


/**
 *  Contains information about how a particular google.dataflow.v1beta3.Step
 *  will be executed.
 */
@interface GTLRDataflow_JobExecutionStageInfo : GTLRObject

/**
 *  The steps associated with the execution stage. Note that stages may have
 *  several steps, and that a given step might be run by more than one stage.
 */
@property(strong, nullable) NSArray<NSString *> *stepName;

@end


/**
 *  A particular message pertaining to a Dataflow job.
 */
@interface GTLRDataflow_JobMessage : GTLRObject

/**
 *  Identifies the message. This is automatically generated by the service; the
 *  caller should treat it as an opaque string.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  Importance level of the message.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageBasic Value
 *        "JOB_MESSAGE_BASIC"
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageDebug Value
 *        "JOB_MESSAGE_DEBUG"
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageDetailed
 *        Value "JOB_MESSAGE_DETAILED"
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageError Value
 *        "JOB_MESSAGE_ERROR"
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageImportanceUnknown
 *        Value "JOB_MESSAGE_IMPORTANCE_UNKNOWN"
 *    @arg @c kGTLRDataflow_JobMessage_MessageImportance_JobMessageWarning Value
 *        "JOB_MESSAGE_WARNING"
 */
@property(copy, nullable) NSString *messageImportance;

/** The text of the message. */
@property(copy, nullable) NSString *messageText;

/** The timestamp of the message. */
@property(copy, nullable) NSString *time;

@end


/**
 *  JobMetrics contains a collection of metrics descibing the detailed progress
 *  of a Dataflow job. Metrics correspond to user-defined and system-defined
 *  metrics in the job. This resource captures only the most recent values of
 *  each metric; time-series data can be queried for them (under the same metric
 *  names) from Cloud Monitoring.
 */
@interface GTLRDataflow_JobMetrics : GTLRObject

/** All metrics for this job. */
@property(strong, nullable) NSArray<GTLRDataflow_MetricUpdate *> *metrics;

/** Timestamp as of which metric values are current. */
@property(copy, nullable) NSString *metricTime;

@end


/**
 *  Data disk assignment information for a specific key-range of a sharded
 *  computation. Currently we only support UTF-8 character splits to simplify
 *  encoding into JSON.
 */
@interface GTLRDataflow_KeyRangeDataDiskAssignment : GTLRObject

/**
 *  The name of the data disk where data for this range is stored. This name is
 *  local to the Google Cloud Platform project and uniquely identifies the disk
 *  within that project, for example
 *  "myproject-1014-104817-4c2-harness-0-disk-1".
 */
@property(copy, nullable) NSString *dataDisk;

/** The end (exclusive) of the key range. */
@property(copy, nullable) NSString *end;

/** The start (inclusive) of the key range. */
@property(copy, nullable) NSString *start;

@end


/**
 *  Location information for a specific key-range of a sharded computation.
 *  Currently we only support UTF-8 character splits to simplify encoding into
 *  JSON.
 */
@interface GTLRDataflow_KeyRangeLocation : GTLRObject

/**
 *  The name of the data disk where data for this range is stored. This name is
 *  local to the Google Cloud Platform project and uniquely identifies the disk
 *  within that project, for example
 *  "myproject-1014-104817-4c2-harness-0-disk-1".
 */
@property(copy, nullable) NSString *dataDisk;

/**
 *  The physical location of this range assignment to be used for streaming
 *  computation cross-worker message delivery.
 */
@property(copy, nullable) NSString *deliveryEndpoint;

/** The end (exclusive) of the key range. */
@property(copy, nullable) NSString *end;

/**
 *  The location of the persistent state for this range, as a persistent
 *  directory in the worker local filesystem.
 */
@property(copy, nullable) NSString *persistentDirectory;

/** The start (inclusive) of the key range. */
@property(copy, nullable) NSString *start;

@end


/**
 *  Request to lease WorkItems.
 */
@interface GTLRDataflow_LeaseWorkItemRequest : GTLRObject

/** The current timestamp at the worker. */
@property(copy, nullable) NSString *currentWorkerTime;

/** The initial lease period. */
@property(copy, nullable) NSString *requestedLeaseDuration;

/**
 *  Worker capabilities. WorkItems might be limited to workers with specific
 *  capabilities.
 */
@property(strong, nullable) NSArray<NSString *> *workerCapabilities;

/**
 *  Identifies the worker leasing work -- typically the ID of the virtual
 *  machine running the worker.
 */
@property(copy, nullable) NSString *workerId;

/** Filter for WorkItem type. */
@property(strong, nullable) NSArray<NSString *> *workItemTypes;

@end


/**
 *  Response to a request to lease WorkItems.
 */
@interface GTLRDataflow_LeaseWorkItemResponse : GTLRObject

/** A list of the leased WorkItems. */
@property(strong, nullable) NSArray<GTLRDataflow_WorkItem *> *workItems;

@end


/**
 *  Response to a request to list job messages.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobMessages" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRDataflow_ListJobMessagesResponse : GTLRCollectionObject

/**
 *  Messages in ascending timestamp order.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRDataflow_JobMessage *> *jobMessages;

/** The token to obtain the next page of results if there are more. */
@property(copy, nullable) NSString *nextPageToken;

@end


/**
 *  Response to a request to list Dataflow jobs. This may be a partial response,
 *  depending on the page size in the ListJobsRequest.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "jobs" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRDataflow_ListJobsResponse : GTLRCollectionObject

/**
 *  A subset of the requested job information.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRDataflow_Job *> *jobs;

/** Set if there may be more results than fit in this response. */
@property(copy, nullable) NSString *nextPageToken;

@end


/**
 *  MapTask consists of an ordered set of instructions, each of which describes
 *  one particular low-level operation for the worker to perform in order to
 *  accomplish the MapTask's WorkItem. Each instruction must appear in the list
 *  before any instructions which depends on its output.
 */
@interface GTLRDataflow_MapTask : GTLRObject

/** The instructions in the MapTask. */
@property(strong, nullable) NSArray<GTLRDataflow_ParallelInstruction *> *instructions;

/**
 *  System-defined name of the stage containing this MapTask. Unique across the
 *  workflow.
 */
@property(copy, nullable) NSString *stageName;

/** System-defined name of this MapTask. Unique across the workflow. */
@property(copy, nullable) NSString *systemName;

@end


/**
 *  The metric short id is returned to the user alongside an offset into
 *  ReportWorkItemStatusRequest
 */
@interface GTLRDataflow_MetricShortId : GTLRObject

/**
 *  The index of the corresponding metric in the ReportWorkItemStatusRequest.
 *  Required.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *metricIndex;

/**
 *  The service-generated short identifier for the metric.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *shortId;

@end


/**
 *  Identifies a metric, by describing the source which generated the metric.
 */
@interface GTLRDataflow_MetricStructuredName : GTLRObject

/**
 *  Zero or more labeled fields which identify the part of the job this metric
 *  is associated with, such as the name of a step or collection. For example,
 *  built-in counters associated with steps will have context['step'] = .
 *  Counters associated with PCollections in the SDK will have
 *  context['pcollection'] =
 *  .
 */
@property(strong, nullable) GTLRDataflow_MetricStructuredNameContext *context;

/** Worker-defined metric name. */
@property(copy, nullable) NSString *name;

/**
 *  Origin (namespace) of metric name. May be blank for user-define metrics;
 *  will be "dataflow" for metrics defined by the Dataflow service or SDK.
 */
@property(copy, nullable) NSString *origin;

@end


/**
 *  Zero or more labeled fields which identify the part of the job this metric
 *  is associated with, such as the name of a step or collection. For example,
 *  built-in counters associated with steps will have context['step'] = .
 *  Counters associated with PCollections in the SDK will have
 *  context['pcollection'] =
 *  .
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_MetricStructuredNameContext : GTLRObject
@end


/**
 *  Describes the state of a metric.
 */
@interface GTLRDataflow_MetricUpdate : GTLRObject

/**
 *  True if this metric is reported as the total cumulative aggregate value
 *  accumulated since the worker started working on this WorkItem. By default
 *  this is false, indicating that this metric is reported as a delta that is
 *  not associated with any WorkItem.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *cumulative;

/**
 *  Worker-computed aggregate value for internal use by the Dataflow service.
 *
 *  Can be any valid JSON type.
 */
@property(strong, nullable) id internal;

/**
 *  Metric aggregation kind. The possible metric aggregation kinds are "Sum",
 *  "Max", "Min", "Mean", "Set", "And", and "Or". The specified aggregation kind
 *  is case-insensitive. If omitted, this is not an aggregated value but instead
 *  a single metric sample value.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Worker-computed aggregate value for the "Mean" aggregation kind. This holds
 *  the count of the aggregated values and is used in combination with mean_sum
 *  above to obtain the actual mean aggregate value. The only possible value
 *  type is Long.
 *
 *  Can be any valid JSON type.
 */
@property(strong, nullable) id meanCount;

/**
 *  Worker-computed aggregate value for the "Mean" aggregation kind. This holds
 *  the sum of the aggregated values and is used in combination with mean_count
 *  below to obtain the actual mean aggregate value. The only possible value
 *  types are Long and Double.
 *
 *  Can be any valid JSON type.
 */
@property(strong, nullable) id meanSum;

/** Name of the metric. */
@property(strong, nullable) GTLRDataflow_MetricStructuredName *name;

/**
 *  Worker-computed aggregate value for aggregation kinds "Sum", "Max", "Min",
 *  "And", and "Or". The possible value types are Long, Double, and Boolean.
 *
 *  Can be any valid JSON type.
 */
@property(strong, nullable) id scalar;

/**
 *  Worker-computed aggregate value for the "Set" aggregation kind. The only
 *  possible value type is a list of Values whose type can be Long, Double, or
 *  String, according to the metric's type. All Values in the list must be of
 *  the same type.
 *
 *  Can be any valid JSON type.
 */
@property(strong, nullable) id set;

/**
 *  Timestamp associated with the metric value. Optional when workers are
 *  reporting work progress; it will be filled in responses from the metrics
 *  API.
 */
@property(copy, nullable) NSString *updateTime;

@end


/**
 *  Describes mounted data disk.
 */
@interface GTLRDataflow_MountedDataDisk : GTLRObject

/**
 *  The name of the data disk. This name is local to the Google Cloud Platform
 *  project and uniquely identifies the disk within that project, for example
 *  "myproject-1014-104817-4c2-harness-0-disk-1".
 */
@property(copy, nullable) NSString *dataDisk;

@end


/**
 *  Information about an output of a multi-output DoFn.
 */
@interface GTLRDataflow_MultiOutputInfo : GTLRObject

/**
 *  The id of the tag the user code will emit to this output by; this should
 *  correspond to the tag of some SideInputInfo.
 */
@property(copy, nullable) NSString *tag;

@end


/**
 *  Basic metadata about a counter.
 */
@interface GTLRDataflow_NameAndKind : GTLRObject

/**
 *  Counter aggregation kind.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_And Value "AND"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Invalid Value "INVALID"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Max Value "MAX"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Mean Value "MEAN"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Min Value "MIN"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Or Value "OR"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Set Value "SET"
 *    @arg @c kGTLRDataflow_NameAndKind_Kind_Sum Value "SUM"
 */
@property(copy, nullable) NSString *kind;

/** Name of the counter. */
@property(copy, nullable) NSString *name;

@end


/**
 *  Packages that need to be installed in order for a worker to run the steps of
 *  the Dataflow job which will be assigned to its worker pool. This is the
 *  mechanism by which the SDK causes code to be loaded onto the workers. For
 *  example, the Dataflow Java SDK might use this to install jars containing the
 *  user's code and all of the various dependencies (libraries, data files, etc)
 *  required in order for that code to run.
 */
@interface GTLRDataflow_Package : GTLRObject

/**
 *  The resource to read the package from. The supported resource type is:
 *  Google Cloud Storage: storage.googleapis.com/{bucket}
 *  bucket.storage.googleapis.com/
 */
@property(copy, nullable) NSString *location;

/** The name of the package. */
@property(copy, nullable) NSString *name;

@end


/**
 *  Describes a particular operation comprising a MapTask.
 */
@interface GTLRDataflow_ParallelInstruction : GTLRObject

/** Additional information for Flatten instructions. */
@property(strong, nullable) GTLRDataflow_FlattenInstruction *flatten;

/** User-provided name of this operation. */
@property(copy, nullable) NSString *name;

/** Describes the outputs of the instruction. */
@property(strong, nullable) NSArray<GTLRDataflow_InstructionOutput *> *outputs;

/** Additional information for ParDo instructions. */
@property(strong, nullable) GTLRDataflow_ParDoInstruction *parDo;

/** Additional information for PartialGroupByKey instructions. */
@property(strong, nullable) GTLRDataflow_PartialGroupByKeyInstruction *partialGroupByKey;

/** Additional information for Read instructions. */
@property(strong, nullable) GTLRDataflow_ReadInstruction *read;

/** System-defined name of this operation. Unique across the workflow. */
@property(copy, nullable) NSString *systemName;

/** Additional information for Write instructions. */
@property(strong, nullable) GTLRDataflow_WriteInstruction *write;

@end


/**
 *  An instruction that does a ParDo operation. Takes one main input and zero or
 *  more side inputs, and produces zero or more outputs. Runs user code.
 */
@interface GTLRDataflow_ParDoInstruction : GTLRObject

/** The input. */
@property(strong, nullable) GTLRDataflow_InstructionInput *input;

/** Information about each of the outputs, if user_fn is a MultiDoFn. */
@property(strong, nullable) NSArray<GTLRDataflow_MultiOutputInfo *> *multiOutputInfos;

/**
 *  The number of outputs.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *numOutputs;

/** Zero or more side inputs. */
@property(strong, nullable) NSArray<GTLRDataflow_SideInputInfo *> *sideInputs;

/** The user function to invoke. */
@property(strong, nullable) GTLRDataflow_ParDoInstructionUserFn *userFn;

@end


/**
 *  The user function to invoke.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_ParDoInstructionUserFn : GTLRObject
@end


/**
 *  An instruction that does a partial group-by-key. One input and one output.
 */
@interface GTLRDataflow_PartialGroupByKeyInstruction : GTLRObject

/** Describes the input to the partial group-by-key instruction. */
@property(strong, nullable) GTLRDataflow_InstructionInput *input;

/** The codec to use for interpreting an element in the input PTable. */
@property(strong, nullable) GTLRDataflow_PartialGroupByKeyInstructionInputElementCodec *inputElementCodec;

/** Zero or more side inputs. */
@property(strong, nullable) NSArray<GTLRDataflow_SideInputInfo *> *sideInputs;

/** The value combining function to invoke. */
@property(strong, nullable) GTLRDataflow_PartialGroupByKeyInstructionValueCombiningFn *valueCombiningFn;

@end


/**
 *  The codec to use for interpreting an element in the input PTable.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_PartialGroupByKeyInstructionInputElementCodec : GTLRObject
@end


/**
 *  The value combining function to invoke.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_PartialGroupByKeyInstructionValueCombiningFn : GTLRObject
@end


/**
 *  Position defines a position within a collection of data. The value can be
 *  either the end position, a key (used with ordered collections), a byte
 *  offset, or a record index.
 */
@interface GTLRDataflow_Position : GTLRObject

/**
 *  Position is a byte offset.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *byteOffset;

/** CloudPosition is a concat position. */
@property(strong, nullable) GTLRDataflow_ConcatPosition *concatPosition;

/**
 *  Position is past all other positions. Also useful for the end position of an
 *  unbounded range.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *end;

/** Position is a string key, ordered lexicographically. */
@property(copy, nullable) NSString *key;

/**
 *  Position is a record index.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *recordIndex;

/**
 *  CloudPosition is a base64 encoded BatchShufflePosition (with FIXED
 *  sharding).
 */
@property(copy, nullable) NSString *shufflePosition;

@end


/**
 *  Identifies a pubsub location to use for transferring data into or out of a
 *  streaming Dataflow job.
 */
@interface GTLRDataflow_PubsubLocation : GTLRObject

/**
 *  Indicates whether the pipeline allows late-arriving data.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *dropLateData;

/**
 *  If set, contains a pubsub label from which to extract record ids. If left
 *  empty, record deduplication will be strictly best effort.
 */
@property(copy, nullable) NSString *idLabel;

/**
 *  A pubsub subscription, in the form of "pubsub.googleapis.com/subscriptions/
 *  /"
 */
@property(copy, nullable) NSString *subscription;

/**
 *  If set, contains a pubsub label from which to extract record timestamps. If
 *  left empty, record timestamps will be generated upon arrival.
 */
@property(copy, nullable) NSString *timestampLabel;

/**
 *  A pubsub topic, in the form of "pubsub.googleapis.com/topics/
 *  /"
 */
@property(copy, nullable) NSString *topic;

/**
 *  If set, specifies the pubsub subscription that will be used for tracking
 *  custom time timestamps for watermark estimation.
 */
@property(copy, nullable) NSString *trackingSubscription;

@end


/**
 *  An instruction that reads records. Takes no inputs, produces one output.
 */
@interface GTLRDataflow_ReadInstruction : GTLRObject

/** The source to read from. */
@property(strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  Represents the level of parallelism in a WorkItem's input, reported by the
 *  worker.
 */
@interface GTLRDataflow_ReportedParallelism : GTLRObject

/**
 *  Specifies whether the parallelism is infinite. If true, "value" is ignored.
 *  Infinite parallelism means the service will assume that the work item can
 *  always be split into more non-empty work items by dynamic splitting. This is
 *  a work-around for lack of support for infinity by the current JSON-based
 *  Java RPC stack.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *isInfinite;

/**
 *  Specifies the level of parallelism in case it is finite.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *value;

@end


/**
 *  Request to report the status of WorkItems.
 */
@interface GTLRDataflow_ReportWorkItemStatusRequest : GTLRObject

/** The current timestamp at the worker. */
@property(copy, nullable) NSString *currentWorkerTime;

/**
 *  The ID of the worker reporting the WorkItem status. If this does not match
 *  the ID of the worker which the Dataflow service believes currently has the
 *  lease on the WorkItem, the report will be dropped (with an error response).
 */
@property(copy, nullable) NSString *workerId;

/**
 *  The order is unimportant, except that the order of the WorkItemServiceState
 *  messages in the ReportWorkItemStatusResponse corresponds to the order of
 *  WorkItemStatus messages here.
 */
@property(strong, nullable) NSArray<GTLRDataflow_WorkItemStatus *> *workItemStatuses;

@end


/**
 *  Response from a request to report the status of WorkItems.
 */
@interface GTLRDataflow_ReportWorkItemStatusResponse : GTLRObject

/**
 *  A set of messages indicating the service-side state for each WorkItem whose
 *  status was reported, in the same order as the WorkItemStatus messages in the
 *  ReportWorkItemStatusRequest which resulting in this response.
 */
@property(strong, nullable) NSArray<GTLRDataflow_WorkItemServiceState *> *workItemServiceStates;

@end


/**
 *  A request for sending worker messages to the service.
 */
@interface GTLRDataflow_SendWorkerMessagesRequest : GTLRObject

/** The WorkerMessages to send. */
@property(strong, nullable) NSArray<GTLRDataflow_WorkerMessage *> *workerMessages;

@end


/**
 *  The response to the worker messages.
 */
@interface GTLRDataflow_SendWorkerMessagesResponse : GTLRObject

/** The servers response to the worker messages. */
@property(strong, nullable) NSArray<GTLRDataflow_WorkerMessageResponse *> *workerMessageResponses;

@end


/**
 *  Describes a particular function to invoke.
 */
@interface GTLRDataflow_SeqMapTask : GTLRObject

/** Information about each of the inputs. */
@property(strong, nullable) NSArray<GTLRDataflow_SideInputInfo *> *inputs;

/** The user-provided name of the SeqDo operation. */
@property(copy, nullable) NSString *name;

/** Information about each of the outputs. */
@property(strong, nullable) NSArray<GTLRDataflow_SeqMapTaskOutputInfo *> *outputInfos;

/**
 *  System-defined name of the stage containing the SeqDo operation. Unique
 *  across the workflow.
 */
@property(copy, nullable) NSString *stageName;

/** System-defined name of the SeqDo operation. Unique across the workflow. */
@property(copy, nullable) NSString *systemName;

/** The user function to invoke. */
@property(strong, nullable) GTLRDataflow_SeqMapTaskUserFn *userFn;

@end


/**
 *  The user function to invoke.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SeqMapTaskUserFn : GTLRObject
@end


/**
 *  Information about an output of a SeqMapTask.
 */
@interface GTLRDataflow_SeqMapTaskOutputInfo : GTLRObject

/** The sink to write the output value to. */
@property(strong, nullable) GTLRDataflow_Sink *sink;

/** The id of the TupleTag the user code will tag the output value by. */
@property(copy, nullable) NSString *tag;

@end


/**
 *  A task which consists of a shell command for the worker to execute.
 */
@interface GTLRDataflow_ShellTask : GTLRObject

/** The shell command to run. */
@property(copy, nullable) NSString *command;

/**
 *  Exit code for the task.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *exitCode;

@end


/**
 *  Information about a side input of a DoFn or an input of a SeqDoFn.
 */
@interface GTLRDataflow_SideInputInfo : GTLRObject

/** How to interpret the source element(s) as a side input value. */
@property(strong, nullable) GTLRDataflow_SideInputInfoKind *kind;

/**
 *  The source(s) to read element(s) from to get the value of this side input.
 *  If more than one source, then the elements are taken from the sources, in
 *  the specified order if order matters. At least one source is required.
 */
@property(strong, nullable) NSArray<GTLRDataflow_Source *> *sources;

/**
 *  The id of the tag the user code will access this side input by; this should
 *  correspond to the tag of some MultiOutputInfo.
 */
@property(copy, nullable) NSString *tag;

@end


/**
 *  How to interpret the source element(s) as a side input value.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SideInputInfoKind : GTLRObject
@end


/**
 *  A sink that records can be encoded and written to.
 */
@interface GTLRDataflow_Sink : GTLRObject

/** The codec to use to encode data written to the sink. */
@property(strong, nullable) GTLRDataflow_SinkCodec *codec;

/** The sink to write to, plus its parameters. */
@property(strong, nullable) GTLRDataflow_SinkSpec *spec;

@end


/**
 *  The codec to use to encode data written to the sink.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SinkCodec : GTLRObject
@end


/**
 *  The sink to write to, plus its parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SinkSpec : GTLRObject
@end


/**
 *  A source that records can be read and decoded from.
 */
@interface GTLRDataflow_Source : GTLRObject

/**
 *  While splitting, sources may specify the produced bundles as differences
 *  against another source, in order to save backend-side memory and allow
 *  bigger jobs. For details, see SourceSplitRequest. To support this use case,
 *  the full set of parameters of the source is logically obtained by taking the
 *  latest explicitly specified value of each parameter in the order: base_specs
 *  (later items win), spec (overrides anything in base_specs).
 */
@property(strong, nullable) NSArray<GTLRDataflow_SourceBaseSpecsItem *> *baseSpecs;

/** The codec to use to decode data read from the source. */
@property(strong, nullable) GTLRDataflow_SourceCodec *codec;

/**
 *  Setting this value to true hints to the framework that the source doesn't
 *  need splitting, and using SourceSplitRequest on it would yield
 *  SOURCE_SPLIT_OUTCOME_USE_CURRENT. E.g. a file splitter may set this to true
 *  when splitting a single file into a set of byte ranges of appropriate size,
 *  and set this to false when splitting a filepattern into individual files.
 *  However, for efficiency, a file splitter may decide to produce file
 *  subranges directly from the filepattern to avoid a splitting round-trip. See
 *  SourceSplitRequest for an overview of the splitting process. This field is
 *  meaningful only in the Source objects populated by the user (e.g. when
 *  filling in a DerivedSource). Source objects supplied by the framework to the
 *  user don't have this field populated.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *doesNotNeedSplitting;

/**
 *  Optionally, metadata for this source can be supplied right away, avoiding a
 *  SourceGetMetadataOperation roundtrip (see SourceOperationRequest). This
 *  field is meaningful only in the Source objects populated by the user (e.g.
 *  when filling in a DerivedSource). Source objects supplied by the framework
 *  to the user don't have this field populated.
 */
@property(strong, nullable) GTLRDataflow_SourceMetadata *metadata;

/** The source to read from, plus its parameters. */
@property(strong, nullable) GTLRDataflow_SourceSpec *spec;

@end


/**
 *  GTLRDataflow_SourceBaseSpecsItem
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SourceBaseSpecsItem : GTLRObject
@end


/**
 *  The codec to use to decode data read from the source.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SourceCodec : GTLRObject
@end


/**
 *  The source to read from, plus its parameters.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_SourceSpec : GTLRObject
@end


/**
 *  DEPRECATED in favor of DynamicSourceSplit.
 */
@interface GTLRDataflow_SourceFork : GTLRObject

/** DEPRECATED */
@property(strong, nullable) GTLRDataflow_SourceSplitShard *primary;

/** DEPRECATED */
@property(strong, nullable) GTLRDataflow_DerivedSource *primarySource;

/** DEPRECATED */
@property(strong, nullable) GTLRDataflow_SourceSplitShard *residual;

/** DEPRECATED */
@property(strong, nullable) GTLRDataflow_DerivedSource *residualSource;

@end


/**
 *  A request to compute the SourceMetadata of a Source.
 */
@interface GTLRDataflow_SourceGetMetadataRequest : GTLRObject

/** Specification of the source whose metadata should be computed. */
@property(strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  The result of a SourceGetMetadataOperation.
 */
@interface GTLRDataflow_SourceGetMetadataResponse : GTLRObject

/** The computed metadata. */
@property(strong, nullable) GTLRDataflow_SourceMetadata *metadata;

@end


/**
 *  Metadata about a Source useful for automatically optimizing and tuning the
 *  pipeline, etc.
 */
@interface GTLRDataflow_SourceMetadata : GTLRObject

/**
 *  An estimate of the total size (in bytes) of the data that would be read from
 *  this source. This estimate is in terms of external storage size, before any
 *  decompression or other processing done by the reader.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *estimatedSizeBytes;

/**
 *  Specifies that the size of this source is known to be infinite (this is a
 *  streaming source).
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *infinite;

/**
 *  Whether this source is known to produce key/value pairs with the (encoded)
 *  keys in lexicographically sorted order.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *producesSortedKeys;

@end


/**
 *  A work item that represents the different operations that can be performed
 *  on a user-defined Source specification.
 */
@interface GTLRDataflow_SourceOperationRequest : GTLRObject

/** Information about a request to get metadata about a source. */
@property(strong, nullable) GTLRDataflow_SourceGetMetadataRequest *getMetadata;

/** Information about a request to split a source. */
@property(strong, nullable) GTLRDataflow_SourceSplitRequest *split;

@end


/**
 *  The result of a SourceOperationRequest, specified in
 *  ReportWorkItemStatusRequest.source_operation when the work item is
 *  completed.
 */
@interface GTLRDataflow_SourceOperationResponse : GTLRObject

/** A response to a request to get metadata about a source. */
@property(strong, nullable) GTLRDataflow_SourceGetMetadataResponse *getMetadata;

/** A response to a request to split a source. */
@property(strong, nullable) GTLRDataflow_SourceSplitResponse *split;

@end


/**
 *  Hints for splitting a Source into bundles (parts for parallel processing)
 *  using SourceSplitRequest.
 */
@interface GTLRDataflow_SourceSplitOptions : GTLRObject

/**
 *  The source should be split into a set of bundles where the estimated size of
 *  each is approximately this many bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *desiredBundleSizeBytes;

/**
 *  DEPRECATED in favor of desired_bundle_size_bytes.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *desiredShardSizeBytes;

@end


/**
 *  Represents the operation to split a high-level Source specification into
 *  bundles (parts for parallel processing). At a high level, splitting of a
 *  source into bundles happens as follows: SourceSplitRequest is applied to the
 *  source. If it returns SOURCE_SPLIT_OUTCOME_USE_CURRENT, no further splitting
 *  happens and the source is used "as is". Otherwise, splitting is applied
 *  recursively to each produced DerivedSource. As an optimization, for any
 *  Source, if its does_not_need_splitting is true, the framework assumes that
 *  splitting this source would return SOURCE_SPLIT_OUTCOME_USE_CURRENT, and
 *  doesn't initiate a SourceSplitRequest. This applies both to the initial
 *  source being split and to bundles produced from it.
 */
@interface GTLRDataflow_SourceSplitRequest : GTLRObject

/** Hints for tuning the splitting process. */
@property(strong, nullable) GTLRDataflow_SourceSplitOptions *options;

/** Specification of the source to be split. */
@property(strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  The response to a SourceSplitRequest.
 */
@interface GTLRDataflow_SourceSplitResponse : GTLRObject

/**
 *  If outcome is SPLITTING_HAPPENED, then this is a list of bundles into which
 *  the source was split. Otherwise this field is ignored. This list can be
 *  empty, which means the source represents an empty input.
 */
@property(strong, nullable) NSArray<GTLRDataflow_DerivedSource *> *bundles;

/**
 *  Indicates whether splitting happened and produced a list of bundles. If this
 *  is USE_CURRENT_SOURCE_AS_IS, the current source should be processed "as is"
 *  without splitting. "bundles" is ignored in this case. If this is
 *  SPLITTING_HAPPENED, then "bundles" contains a list of bundles into which the
 *  source was split.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeSplittingHappened
 *        Value "SOURCE_SPLIT_OUTCOME_SPLITTING_HAPPENED"
 *    @arg @c kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUnknown
 *        Value "SOURCE_SPLIT_OUTCOME_UNKNOWN"
 *    @arg @c kGTLRDataflow_SourceSplitResponse_Outcome_SourceSplitOutcomeUseCurrent
 *        Value "SOURCE_SPLIT_OUTCOME_USE_CURRENT"
 */
@property(copy, nullable) NSString *outcome;

/** DEPRECATED in favor of bundles. */
@property(strong, nullable) NSArray<GTLRDataflow_SourceSplitShard *> *shards;

@end


/**
 *  DEPRECATED in favor of DerivedSource.
 */
@interface GTLRDataflow_SourceSplitShard : GTLRObject

/**
 *  DEPRECATED
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeChildOfCurrent
 *        Value "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT"
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeIndependent
 *        Value "SOURCE_DERIVATION_MODE_INDEPENDENT"
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeSiblingOfCurrent
 *        Value "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT"
 *    @arg @c kGTLRDataflow_SourceSplitShard_DerivationMode_SourceDerivationModeUnknown
 *        Value "SOURCE_DERIVATION_MODE_UNKNOWN"
 */
@property(copy, nullable) NSString *derivationMode;

/** DEPRECATED */
@property(strong, nullable) GTLRDataflow_Source *source;

@end


/**
 *  A representation of an int64, n, that is immune to precision loss when
 *  encoded in JSON.
 */
@interface GTLRDataflow_SplitInt64 : GTLRObject

/**
 *  The high order bits, including the sign: n >> 32.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *highBits;

/**
 *  The low order bits: n & 0xffffffff.
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(strong, nullable) NSNumber *lowBits;

@end


/**
 *  State family configuration.
 */
@interface GTLRDataflow_StateFamilyConfig : GTLRObject

/**
 *  If true, this family corresponds to a read operation.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *isRead;

/** The state family value. */
@property(copy, nullable) NSString *stateFamily;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different programming environments, including REST APIs and RPC APIs. It is
 *  used by [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users - Flexible enough to meet
 *  unexpected needs # Overview The `Status` message contains three pieces of
 *  data: error code, error message, and error details. The error code should be
 *  an enum value of google.rpc.Code, but it may accept additional error codes
 *  if needed. The error message should be a developer-facing English message
 *  that helps developers *understand* and *resolve* the error. If a localized
 *  user-facing error message is needed, put the localized message in the error
 *  details or localize it in the client. The optional error details may contain
 *  arbitrary information about the error. There is a predefined set of error
 *  detail types in the package `google.rpc` which can be used for common error
 *  conditions. # Language mapping The `Status` message is the logical
 *  representation of the error model, but it is not necessarily the actual wire
 *  format. When the `Status` message is exposed in different client libraries
 *  and different wire protocols, it can be mapped differently. For example, it
 *  will likely be mapped to some exceptions in Java, but more likely mapped to
 *  some error codes in C. # Other uses The error model and the `Status` message
 *  can be used in a variety of environments, either with or without APIs, to
 *  provide a consistent developer experience across different environments.
 *  Example uses of this error model include: - Partial errors. If a service
 *  needs to return partial errors to the client, it may embed the `Status` in
 *  the normal response to indicate the partial errors. - Workflow errors. A
 *  typical workflow has multiple steps. Each step may have a `Status` message
 *  for error reporting purpose. - Batch operations. If a client uses batch
 *  request and batch response, the `Status` message should be used directly
 *  inside batch response, one for each error sub-response. - Asynchronous
 *  operations. If an API call embeds asynchronous operation results in its
 *  response, the status of those operations should be represented directly
 *  using the `Status` message. - Logging. If some API errors are stored in
 *  logs, the message `Status` could be used directly after any stripping needed
 *  for security/privacy reasons.
 */
@interface GTLRDataflow_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There will be a common set
 *  of message types for APIs to use.
 */
@property(strong, nullable) NSArray<GTLRDataflow_StatusDetailsItem *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRDataflow_StatusDetailsItem
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_StatusDetailsItem : GTLRObject
@end


/**
 *  Defines a particular step within a Dataflow job. A job consists of multiple
 *  steps, each of which performs some specific operation as part of the overall
 *  job. Data is typically passed from one step to another as part of the job.
 *  Here's an example of a sequence of steps which together implement a
 *  Map-Reduce job: * Read a collection of data from some source, parsing the
 *  collection's elements. * Validate the elements. * Apply a user-defined
 *  function to map each element to some value and extract an element-specific
 *  key value. * Group elements with the same key into a single element with
 *  that key, transforming a multiply-keyed collection into a uniquely-keyed
 *  collection. * Write the elements out to some data sink. (Note that the
 *  Dataflow service may be used to run many different types of jobs, not just
 *  Map-Reduce).
 */
@interface GTLRDataflow_Step : GTLRObject

/** The kind of step in the dataflow Job. */
@property(copy, nullable) NSString *kind;

/**
 *  Name identifying the step. This must be unique for each step with respect to
 *  all other steps in the dataflow Job.
 */
@property(copy, nullable) NSString *name;

/**
 *  Named properties associated with the step. Each kind of predefined step has
 *  its own required set of properties.
 */
@property(strong, nullable) GTLRDataflow_StepProperties *properties;

@end


/**
 *  Named properties associated with the step. Each kind of predefined step has
 *  its own required set of properties.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_StepProperties : GTLRObject
@end


/**
 *  Configuration information for a single streaming computation.
 */
@interface GTLRDataflow_StreamingComputationConfig : GTLRObject

/** Unique identifier for this computation. */
@property(copy, nullable) NSString *computationId;

/** Instructions that comprise the computation. */
@property(strong, nullable) NSArray<GTLRDataflow_ParallelInstruction *> *instructions;

/** Stage name of this computation. */
@property(copy, nullable) NSString *stageName;

/** System defined name for this computation. */
@property(copy, nullable) NSString *systemName;

@end


/**
 *  Describes full or partial data disk assignment information of the
 *  computation ranges.
 */
@interface GTLRDataflow_StreamingComputationRanges : GTLRObject

/** The ID of the computation. */
@property(copy, nullable) NSString *computationId;

/** Data disk assignments for ranges from this computation. */
@property(strong, nullable) NSArray<GTLRDataflow_KeyRangeDataDiskAssignment *> *rangeAssignments;

@end


/**
 *  A task which describes what action should be performed for the specified
 *  streaming computation ranges.
 */
@interface GTLRDataflow_StreamingComputationTask : GTLRObject

/** Contains ranges of a streaming computation this task should apply to. */
@property(strong, nullable) NSArray<GTLRDataflow_StreamingComputationRanges *> *computationRanges;

/** Describes the set of data disks this task should apply to. */
@property(strong, nullable) NSArray<GTLRDataflow_MountedDataDisk *> *dataDisks;

/**
 *  A type of streaming computation task.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStart
 *        Value "STREAMING_COMPUTATION_TASK_START"
 *    @arg @c kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskStop
 *        Value "STREAMING_COMPUTATION_TASK_STOP"
 *    @arg @c kGTLRDataflow_StreamingComputationTask_TaskType_StreamingComputationTaskUnknown
 *        Value "STREAMING_COMPUTATION_TASK_UNKNOWN"
 */
@property(copy, nullable) NSString *taskType;

@end


/**
 *  A task that carries configuration information for streaming computations.
 */
@interface GTLRDataflow_StreamingConfigTask : GTLRObject

/** Set of computation configuration information. */
@property(strong, nullable) NSArray<GTLRDataflow_StreamingComputationConfig *> *streamingComputationConfigs;

/** Map from user step names to state families. */
@property(strong, nullable) GTLRDataflow_StreamingConfigTaskUserStepToStateFamilyNameMap *userStepToStateFamilyNameMap;

@end


/**
 *  Map from user step names to state families.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_StreamingConfigTaskUserStepToStateFamilyNameMap : GTLRObject
@end


/**
 *  A task which initializes part of a streaming Dataflow job.
 */
@interface GTLRDataflow_StreamingSetupTask : GTLRObject

/**
 *  The user has requested drain.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *drain;

/**
 *  The TCP port on which the worker should listen for messages from other
 *  streaming computation workers.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *receiveWorkPort;

/** The global topology of the streaming Dataflow job. */
@property(strong, nullable) GTLRDataflow_TopologyConfig *streamingComputationTopology;

/**
 *  The TCP port used by the worker to communicate with the Dataflow worker
 *  harness.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *workerHarnessPort;

@end


/**
 *  Identifies the location of a streaming side input.
 */
@interface GTLRDataflow_StreamingSideInputLocation : GTLRObject

/** Identifies the state family where this side input is stored. */
@property(copy, nullable) NSString *stateFamily;

/** Identifies the particular side input within the streaming Dataflow job. */
@property(copy, nullable) NSString *tag;

@end


/**
 *  Identifies the location of a streaming computation stage, for stage-to-stage
 *  communication.
 */
@interface GTLRDataflow_StreamingStageLocation : GTLRObject

/** Identifies the particular stream within the streaming Dataflow job. */
@property(copy, nullable) NSString *streamId;

@end


/**
 *  Describes a stream of data, either as input to be processed or as output of
 *  a streaming Dataflow job.
 */
@interface GTLRDataflow_StreamLocation : GTLRObject

/** The stream is a custom source. */
@property(strong, nullable) GTLRDataflow_CustomSourceLocation *customSourceLocation;

/** The stream is a pubsub stream. */
@property(strong, nullable) GTLRDataflow_PubsubLocation *pubsubLocation;

/** The stream is a streaming side input. */
@property(strong, nullable) GTLRDataflow_StreamingSideInputLocation *sideInputLocation;

/**
 *  The stream is part of another computation within the current streaming
 *  Dataflow job.
 */
@property(strong, nullable) GTLRDataflow_StreamingStageLocation *streamingStageLocation;

@end


/**
 *  A metric value representing a list of strings.
 */
@interface GTLRDataflow_StringList : GTLRObject

/** Elements of the list. */
@property(strong, nullable) NSArray<NSString *> *elements;

@end


/**
 *  Taskrunner configuration settings.
 */
@interface GTLRDataflow_TaskRunnerSettings : GTLRObject

/**
 *  Also send taskrunner log info to stderr?
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *alsologtostderr;

/** Location on the worker for task-specific subdirectories. */
@property(copy, nullable) NSString *baseTaskDir;

/**
 *  The base URL for the taskrunner to use when accessing Google Cloud APIs.
 *  When workers access Google Cloud APIs, they logically do so via relative
 *  URLs. If this field is specified, it supplies the base URL to use for
 *  resolving these relative URLs. The normative algorithm used is defined by
 *  RFC 1808, "Relative Uniform Resource Locators". If not specified, the
 *  default value is "http://www.googleapis.com/"
 */
@property(copy, nullable) NSString *baseUrl;

/** Store preprocessing commands in this file. */
@property(copy, nullable) NSString *commandlinesFileName;

/**
 *  Do we continue taskrunner if an exception is hit?
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *continueOnException;

/** API version of endpoint, e.g. "v1b3" */
@property(copy, nullable) NSString *dataflowApiVersion;

/** Command to launch the worker harness. */
@property(copy, nullable) NSString *harnessCommand;

/** Suggested backend language. */
@property(copy, nullable) NSString *languageHint;

/** Directory on the VM to store logs. */
@property(copy, nullable) NSString *logDir;

/**
 *  Send taskrunner log into to Google Compute Engine VM serial console?
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *logToSerialconsole;

/**
 *  Indicates where to put logs. If this is not specified, the logs will not be
 *  uploaded. The supported resource type is: Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(copy, nullable) NSString *logUploadLocation;

/**
 *  OAuth2 scopes to be requested by the taskrunner in order to access the
 *  dataflow API.
 */
@property(strong, nullable) NSArray<NSString *> *oauthScopes;

/** Settings to pass to the parallel worker harness. */
@property(strong, nullable) GTLRDataflow_WorkerSettings *parallelWorkerSettings;

/** Streaming worker main class name. */
@property(copy, nullable) NSString *streamingWorkerMainClass;

/**
 *  The UNIX group ID on the worker VM to use for tasks launched by taskrunner;
 *  e.g. "wheel".
 */
@property(copy, nullable) NSString *taskGroup;

/**
 *  The UNIX user ID on the worker VM to use for tasks launched by taskrunner;
 *  e.g. "root".
 */
@property(copy, nullable) NSString *taskUser;

/**
 *  The prefix of the resources the taskrunner should use for temporary storage.
 *  The supported resource type is: Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(copy, nullable) NSString *tempStoragePrefix;

/** ID string of VM. */
@property(copy, nullable) NSString *vmId;

/** Store the workflow in this file. */
@property(copy, nullable) NSString *workflowFileName;

@end


/**
 *  Global topology of the streaming Dataflow job, including all computations
 *  and their sharded locations.
 */
@interface GTLRDataflow_TopologyConfig : GTLRObject

/** The computations associated with a streaming Dataflow job. */
@property(strong, nullable) NSArray<GTLRDataflow_ComputationTopology *> *computations;

/** The disks assigned to a streaming Dataflow job. */
@property(strong, nullable) NSArray<GTLRDataflow_DataDiskAssignment *> *dataDiskAssignments;

/**
 *  The size (in bits) of keys that will be assigned to source messages.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *forwardingKeyBits;

/**
 *  Version number for persistent state.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *persistentStateVersion;

/** Maps user stage names to stable computation names. */
@property(strong, nullable) GTLRDataflow_TopologyConfigUserStageToComputationNameMap *userStageToComputationNameMap;

@end


/**
 *  Maps user stage names to stable computation names.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_TopologyConfigUserStageToComputationNameMap : GTLRObject
@end


/**
 *  WorkerHealthReport contains information about the health of a worker. The VM
 *  should be identified by the labels attached to the WorkerMessage that this
 *  health ping belongs to.
 */
@interface GTLRDataflow_WorkerHealthReport : GTLRObject

/**
 *  The pods running on the worker. See:
 *  http://kubernetes.io/v1.1/docs/api-reference/v1/definitions.html#_v1_pod
 *  This field is used by the worker to send the status of the indvidual
 *  containers running on each worker.
 */
@property(strong, nullable) NSArray<GTLRDataflow_WorkerHealthReportPodsItem *> *pods;

/**
 *  The interval at which the worker is sending health reports. The default
 *  value of 0 should be interpreted as the field is not being explicitly set by
 *  the worker.
 */
@property(copy, nullable) NSString *reportInterval;

/**
 *  Whether the VM is healthy.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *vmIsHealthy;

/** The time the VM was booted. */
@property(copy, nullable) NSString *vmStartupTime;

@end


/**
 *  GTLRDataflow_WorkerHealthReportPodsItem
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkerHealthReportPodsItem : GTLRObject
@end


/**
 *  WorkerHealthReportResponse contains information returned to the worker in
 *  response to a health ping.
 */
@interface GTLRDataflow_WorkerHealthReportResponse : GTLRObject

/**
 *  A positive value indicates the worker should change its reporting interval
 *  to the specified value. The default value of zero means no change in report
 *  rate is requested by the server.
 */
@property(copy, nullable) NSString *reportInterval;

@end


/**
 *  WorkerMessage provides information to the backend about a worker.
 */
@interface GTLRDataflow_WorkerMessage : GTLRObject

/**
 *  Labels are used to group WorkerMessages. For example, a worker_message about
 *  a particular container might have the labels: { "JOB_ID": "2015-04-22",
 *  "WORKER_ID": "wordcount-vm-2015â€¦" "CONTAINER_TYPE": "worker",
 *  "CONTAINER_ID": "ac1234def"} Label tags typically correspond to Label enum
 *  values. However, for ease of development other strings can be used as tags.
 *  LABEL_UNSPECIFIED should not be used here.
 */
@property(strong, nullable) GTLRDataflow_WorkerMessageLabels *labels;

/** The timestamp of the worker_message. */
@property(copy, nullable) NSString *time;

/** The health of a worker. */
@property(strong, nullable) GTLRDataflow_WorkerHealthReport *workerHealthReport;

/** A worker message code. */
@property(strong, nullable) GTLRDataflow_WorkerMessageCode *workerMessageCode;

@end


/**
 *  Labels are used to group WorkerMessages. For example, a worker_message about
 *  a particular container might have the labels: { "JOB_ID": "2015-04-22",
 *  "WORKER_ID": "wordcount-vm-2015â€¦" "CONTAINER_TYPE": "worker",
 *  "CONTAINER_ID": "ac1234def"} Label tags typically correspond to Label enum
 *  values. However, for ease of development other strings can be used as tags.
 *  LABEL_UNSPECIFIED should not be used here.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_WorkerMessageLabels : GTLRObject
@end


/**
 *  A message code is used to report status and error messages to the service.
 *  The message codes are intended to be machine readable. The service will take
 *  care of translating these into user understandable messages if necessary.
 *  Example use cases: 1. Worker processes reporting successful startup. 2.
 *  Worker processes reporting specific errors (e.g. package staging failure).
 */
@interface GTLRDataflow_WorkerMessageCode : GTLRObject

/**
 *  The code is a string intended for consumption by a machine that identifies
 *  the type of message being sent. Examples: 1. "HARNESS_STARTED" might be used
 *  to indicate the worker harness has started. 2. "GCS_DOWNLOAD_ERROR" might be
 *  used to indicate an error downloading a GCS file as part of the boot process
 *  of one of the worker containers. This is a string and not an enum to make it
 *  easy to add new codes without waiting for an API change.
 */
@property(copy, nullable) NSString *code;

/**
 *  Parameters contains specific information about the code. This is a struct to
 *  allow parameters of different types. Examples: 1. For a "HARNESS_STARTED"
 *  message parameters might provide the name of the worker and additional data
 *  like timing information. 2. For a "GCS_DOWNLOAD_ERROR" parameters might
 *  contain fields listing the GCS objects being downloaded and fields
 *  containing errors. In general complex data structures should be avoided. If
 *  a worker needs to send a specific and complicated data structure then please
 *  consider defining a new proto and adding it to the data oneof in
 *  WorkerMessageResponse. Conventions: Parameters should only be used for
 *  information that isn't typically passed as a label. hostname and other
 *  worker identifiers should almost always be passed as labels since they will
 *  be included on most messages.
 */
@property(strong, nullable) GTLRDataflow_WorkerMessageCodeParameters *parameters;

@end


/**
 *  Parameters contains specific information about the code. This is a struct to
 *  allow parameters of different types. Examples: 1. For a "HARNESS_STARTED"
 *  message parameters might provide the name of the worker and additional data
 *  like timing information. 2. For a "GCS_DOWNLOAD_ERROR" parameters might
 *  contain fields listing the GCS objects being downloaded and fields
 *  containing errors. In general complex data structures should be avoided. If
 *  a worker needs to send a specific and complicated data structure then please
 *  consider defining a new proto and adding it to the data oneof in
 *  WorkerMessageResponse. Conventions: Parameters should only be used for
 *  information that isn't typically passed as a label. hostname and other
 *  worker identifiers should almost always be passed as labels since they will
 *  be included on most messages.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkerMessageCodeParameters : GTLRObject
@end


/**
 *  A worker_message response allows the server to pass information to the
 *  sender.
 */
@interface GTLRDataflow_WorkerMessageResponse : GTLRObject

/** The service's response to a worker's health report. */
@property(strong, nullable) GTLRDataflow_WorkerHealthReportResponse *workerHealthReportResponse;

@end


/**
 *  Describes one particular pool of Dataflow workers to be instantiated by the
 *  Dataflow service in order to perform the computations required by a job.
 *  Note that a workflow job may use multiple pools, in order to match the
 *  various computational requirements of the various stages of the job.
 */
@interface GTLRDataflow_WorkerPool : GTLRObject

/** Settings for autoscaling of this WorkerPool. */
@property(strong, nullable) GTLRDataflow_AutoscalingSettings *autoscalingSettings;

/** Data disks that are used by a VM in this workflow. */
@property(strong, nullable) NSArray<GTLRDataflow_Disk *> *dataDisks;

/**
 *  The default package set to install. This allows the service to select a
 *  default set of packages which are useful to worker harnesses written in a
 *  particular language.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetJava
 *        Value "DEFAULT_PACKAGE_SET_JAVA"
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetNone
 *        Value "DEFAULT_PACKAGE_SET_NONE"
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetPython
 *        Value "DEFAULT_PACKAGE_SET_PYTHON"
 *    @arg @c kGTLRDataflow_WorkerPool_DefaultPackageSet_DefaultPackageSetUnknown
 *        Value "DEFAULT_PACKAGE_SET_UNKNOWN"
 */
@property(copy, nullable) NSString *defaultPackageSet;

/**
 *  Size of root disk for VMs, in GB. If zero or unspecified, the service will
 *  attempt to choose a reasonable default.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *diskSizeGb;

/** Fully qualified source image for disks. */
@property(copy, nullable) NSString *diskSourceImage;

/**
 *  Type of root disk for VMs. If empty or unspecified, the service will attempt
 *  to choose a reasonable default.
 */
@property(copy, nullable) NSString *diskType;

/**
 *  The kind of the worker pool; currently only 'harness' and 'shuffle' are
 *  supported.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Machine type (e.g. "n1-standard-1"). If empty or unspecified, the service
 *  will attempt to choose a reasonable default.
 */
@property(copy, nullable) NSString *machineType;

/** Metadata to set on the Google Compute Engine VMs. */
@property(strong, nullable) GTLRDataflow_WorkerPoolMetadata *metadata;

/**
 *  Network to which VMs will be assigned. If empty or unspecified, the service
 *  will use the network "default".
 */
@property(copy, nullable) NSString *network;

/**
 *  The number of threads per worker harness. If empty or unspecified, the
 *  service will choose a number of threads (according to the number of cores on
 *  the selected machine type for batch, or 1 by convention for streaming).
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *numThreadsPerWorker;

/**
 *  Number of Google Compute Engine workers in this pool needed to execute the
 *  job. If zero or unspecified, the service will attempt to choose a reasonable
 *  default.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *numWorkers;

/**
 *  The action to take on host maintenance, as defined by the Google Compute
 *  Engine API.
 */
@property(copy, nullable) NSString *onHostMaintenance;

/** Packages to be installed on workers. */
@property(strong, nullable) NSArray<GTLRDataflow_Package *> *packages;

/** Extra arguments for this worker pool. */
@property(strong, nullable) GTLRDataflow_WorkerPoolPoolArgs *poolArgs;

/**
 *  Subnetwork to which VMs will be assigned, if desired. Expected to be of the
 *  form "regions/REGION/subnetworks/SUBNETWORK".
 */
@property(copy, nullable) NSString *subnetwork;

/**
 *  Settings passed through to Google Compute Engine workers when using the
 *  standard Dataflow task runner. Users should ignore this field.
 */
@property(strong, nullable) GTLRDataflow_TaskRunnerSettings *taskrunnerSettings;

/**
 *  Sets the policy for determining when to turndown worker pool. Allowed values
 *  are: TEARDOWN_ALWAYS, TEARDOWN_ON_SUCCESS, and TEARDOWN_NEVER.
 *  TEARDOWN_ALWAYS means workers are always torn down regardless of whether the
 *  job succeeds. TEARDOWN_ON_SUCCESS means workers are torn down if the job
 *  succeeds. TEARDOWN_NEVER means the workers are never torn down. If the
 *  workers are not torn down by the service, they will continue to run and use
 *  Google Compute Engine VM resources in the user's project until they are
 *  explicitly terminated by the user. Because of this, Google recommends using
 *  the TEARDOWN_ALWAYS policy except for small, manually supervised test jobs.
 *  If unknown or unspecified, the service will attempt to choose a reasonable
 *  default.
 *
 *  Likely values:
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownAlways Value
 *        "TEARDOWN_ALWAYS"
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownNever Value
 *        "TEARDOWN_NEVER"
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownOnSuccess Value
 *        "TEARDOWN_ON_SUCCESS"
 *    @arg @c kGTLRDataflow_WorkerPool_TeardownPolicy_TeardownPolicyUnknown
 *        Value "TEARDOWN_POLICY_UNKNOWN"
 */
@property(copy, nullable) NSString *teardownPolicy;

/**
 *  Docker container image that executes Dataflow worker harness, residing in
 *  Google Container Registry. Required.
 */
@property(copy, nullable) NSString *workerHarnessContainerImage;

/**
 *  Zone to run the worker pools in. If empty or unspecified, the service will
 *  attempt to choose a reasonable default.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  Metadata to set on the Google Compute Engine VMs.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRDataflow_WorkerPoolMetadata : GTLRObject
@end


/**
 *  Extra arguments for this worker pool.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkerPoolPoolArgs : GTLRObject
@end


/**
 *  Provides data to pass through to the worker harness.
 */
@interface GTLRDataflow_WorkerSettings : GTLRObject

/**
 *  The base URL for accessing Google Cloud APIs. When workers access Google
 *  Cloud APIs, they logically do so via relative URLs. If this field is
 *  specified, it supplies the base URL to use for resolving these relative
 *  URLs. The normative algorithm used is defined by RFC 1808, "Relative Uniform
 *  Resource Locators". If not specified, the default value is
 *  "http://www.googleapis.com/"
 */
@property(copy, nullable) NSString *baseUrl;

/**
 *  Send work progress updates to service.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *reportingEnabled;

/**
 *  The Dataflow service path relative to the root URL, for example,
 *  "dataflow/v1b3/projects".
 */
@property(copy, nullable) NSString *servicePath;

/**
 *  The Shuffle service path relative to the root URL, for example,
 *  "shuffle/v1beta1".
 */
@property(copy, nullable) NSString *shuffleServicePath;

/**
 *  The prefix of the resources the system should use for temporary storage. The
 *  supported resource type is: Google Cloud Storage:
 *  storage.googleapis.com/{bucket}/{object}
 *  bucket.storage.googleapis.com/{object}
 */
@property(copy, nullable) NSString *tempStoragePrefix;

/** ID of the worker running this pipeline. */
@property(copy, nullable) NSString *workerId;

@end


/**
 *  WorkItem represents basic information about a WorkItem to be executed in the
 *  cloud.
 */
@interface GTLRDataflow_WorkItem : GTLRObject

/** Work item-specific configuration as an opaque blob. */
@property(copy, nullable) NSString *configuration;

/**
 *  Identifies this WorkItem.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  The initial index to use when reporting the status of the WorkItem.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *initialReportIndex;

/** Identifies the workflow job this WorkItem belongs to. */
@property(copy, nullable) NSString *jobId;

/** Time when the lease on this Work will expire. */
@property(copy, nullable) NSString *leaseExpireTime;

/** Additional information for MapTask WorkItems. */
@property(strong, nullable) GTLRDataflow_MapTask *mapTask;

/**
 *  Any required packages that need to be fetched in order to execute this
 *  WorkItem.
 */
@property(strong, nullable) NSArray<GTLRDataflow_Package *> *packages;

/** Identifies the cloud project this WorkItem belongs to. */
@property(copy, nullable) NSString *projectId;

/** Recommended reporting interval. */
@property(copy, nullable) NSString *reportStatusInterval;

/** Additional information for SeqMapTask WorkItems. */
@property(strong, nullable) GTLRDataflow_SeqMapTask *seqMapTask;

/** Additional information for ShellTask WorkItems. */
@property(strong, nullable) GTLRDataflow_ShellTask *shellTask;

/** Additional information for source operation WorkItems. */
@property(strong, nullable) GTLRDataflow_SourceOperationRequest *sourceOperationTask;

/** Additional information for StreamingComputationTask WorkItems. */
@property(strong, nullable) GTLRDataflow_StreamingComputationTask *streamingComputationTask;

/** Additional information for StreamingConfigTask WorkItems. */
@property(strong, nullable) GTLRDataflow_StreamingConfigTask *streamingConfigTask;

/** Additional information for StreamingSetupTask WorkItems. */
@property(strong, nullable) GTLRDataflow_StreamingSetupTask *streamingSetupTask;

@end


/**
 *  The Dataflow service's idea of the current state of a WorkItem being
 *  processed by a worker.
 */
@interface GTLRDataflow_WorkItemServiceState : GTLRObject

/**
 *  Other data returned by the service, specific to the particular worker
 *  harness.
 */
@property(strong, nullable) GTLRDataflow_WorkItemServiceStateHarnessData *harnessData;

/** Time at which the current lease will expire. */
@property(copy, nullable) NSString *leaseExpireTime;

/**
 *  The short ids that workers should use in subsequent metric updates. Workers
 *  should strive to use short ids whenever possible, but it is ok to request
 *  the short_id again if a worker lost track of it (e.g. if the worker is
 *  recovering from a crash). NOTE: it is possible that the response may have
 *  short ids for a subset of the metrics.
 */
@property(strong, nullable) NSArray<GTLRDataflow_MetricShortId *> *metricShortId;

/**
 *  The index value to use for the next report sent by the worker. Note: If the
 *  report call fails for whatever reason, the worker should reuse this index
 *  for subsequent report attempts.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *nextReportIndex;

/** New recommended reporting interval. */
@property(copy, nullable) NSString *reportStatusInterval;

/**
 *  The progress point in the WorkItem where the Dataflow service suggests that
 *  the worker truncate the task.
 */
@property(strong, nullable) GTLRDataflow_ApproximateSplitRequest *splitRequest;

/** DEPRECATED in favor of split_request. */
@property(strong, nullable) GTLRDataflow_ApproximateProgress *suggestedStopPoint;

/** Obsolete, always empty. */
@property(strong, nullable) GTLRDataflow_Position *suggestedStopPosition;

@end


/**
 *  Other data returned by the service, specific to the particular worker
 *  harness.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRDataflow_WorkItemServiceStateHarnessData : GTLRObject
@end


/**
 *  Conveys a worker's progress through the work described by a WorkItem.
 */
@interface GTLRDataflow_WorkItemStatus : GTLRObject

/**
 *  True if the WorkItem was completed (successfully or unsuccessfully).
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *completed;

/** Worker output counters for this WorkItem. */
@property(strong, nullable) NSArray<GTLRDataflow_CounterUpdate *> *counterUpdates;

/** See documentation of stop_position. */
@property(strong, nullable) GTLRDataflow_DynamicSourceSplit *dynamicSourceSplit;

/**
 *  Specifies errors which occurred during processing. If errors are provided,
 *  and completed = true, then the WorkItem is considered to have failed.
 */
@property(strong, nullable) NSArray<GTLRDataflow_Status *> *errors;

/** DEPRECATED in favor of counter_updates. */
@property(strong, nullable) NSArray<GTLRDataflow_MetricUpdate *> *metricUpdates;

/** DEPRECATED in favor of reported_progress. */
@property(strong, nullable) GTLRDataflow_ApproximateProgress *progress;

/** The worker's progress through this WorkItem. */
@property(strong, nullable) GTLRDataflow_ApproximateReportedProgress *reportedProgress;

/**
 *  The report index. When a WorkItem is leased, the lease will contain an
 *  initial report index. When a WorkItem's status is reported to the system,
 *  the report should be sent with that report index, and the response will
 *  contain the index the worker should use for the next report. Reports
 *  received with unexpected index values will be rejected by the service. In
 *  order to preserve idempotency, the worker should not alter the contents of a
 *  report, even if the worker must submit the same report multiple times before
 *  getting back a response. The worker should not submit a subsequent report
 *  until the response for the previous report had been received from the
 *  service.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *reportIndex;

/** Amount of time the worker requests for its lease. */
@property(copy, nullable) NSString *requestedLeaseDuration;

/** DEPRECATED in favor of dynamic_source_split. */
@property(strong, nullable) GTLRDataflow_SourceFork *sourceFork;

/**
 *  If the work item represented a SourceOperationRequest, and the work is
 *  completed, contains the result of the operation.
 */
@property(strong, nullable) GTLRDataflow_SourceOperationResponse *sourceOperationResponse;

/**
 *  A worker may split an active map task in two parts, "primary" and
 *  "residual", continuing to process the primary part and returning the
 *  residual part into the pool of available work. This event is called a
 *  "dynamic split" and is critical to the dynamic work rebalancing feature. The
 *  two obtained sub-tasks are called "parts" of the split. The parts, if
 *  concatenated, must represent the same input as would be read by the current
 *  task if the split did not happen. The exact way in which the original task
 *  is decomposed into the two parts is specified either as a position
 *  demarcating them (stop_position), or explicitly as two DerivedSources, if
 *  this task consumes a user-defined source type (dynamic_source_split). The
 *  "current" task is adjusted as a result of the split: after a task with range
 *  [A, B) sends a stop_position update at C, its range is considered to be [A,
 *  C), e.g.: * Progress should be interpreted relative to the new range, e.g.
 *  "75% completed" means "75% of [A, C) completed" * The worker should
 *  interpret proposed_stop_position relative to the new range, e.g. "split at
 *  68%" should be interpreted as "split at 68% of [A, C)". * If the worker
 *  chooses to split again using stop_position, only stop_positions in [A, C)
 *  will be accepted. * Etc. dynamic_source_split has similar semantics: e.g.,
 *  if a task with source S splits using dynamic_source_split into {P, R} (where
 *  P and R must be together equivalent to S), then subsequent progress and
 *  proposed_stop_position should be interpreted relative to P, and in a
 *  potential subsequent dynamic_source_split into {P', R'}, P' and R' must be
 *  together equivalent to P, etc.
 */
@property(strong, nullable) GTLRDataflow_Position *stopPosition;

/** Identifies the WorkItem. */
@property(copy, nullable) NSString *workItemId;

@end


/**
 *  An instruction that writes records. Takes one input, produces no outputs.
 */
@interface GTLRDataflow_WriteInstruction : GTLRObject

/** The input. */
@property(strong, nullable) GTLRDataflow_InstructionInput *input;

/** The sink to write to. */
@property(strong, nullable) GTLRDataflow_Sink *sink;

@end

NS_ASSUME_NONNULL_END
