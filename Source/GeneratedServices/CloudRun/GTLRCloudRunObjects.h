// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Cloud Run API (run/v1)
// Description:
//   Deploy and manage user provided container images that scale automatically
//   based on HTTP traffic.
// Documentation:
//   https://cloud.google.com/run/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCloudRun_Addressable;
@class GTLRCloudRun_AuditConfig;
@class GTLRCloudRun_AuditLogConfig;
@class GTLRCloudRun_AuthorizedDomain;
@class GTLRCloudRun_AutoDomainMapping;
@class GTLRCloudRun_AutoDomainMappingSpec;
@class GTLRCloudRun_AutoDomainMappingStatus;
@class GTLRCloudRun_Binding;
@class GTLRCloudRun_ConfigMapEnvSource;
@class GTLRCloudRun_ConfigMapKeySelector;
@class GTLRCloudRun_ConfigMapVolumeSource;
@class GTLRCloudRun_Configuration;
@class GTLRCloudRun_ConfigurationSpec;
@class GTLRCloudRun_ConfigurationStatus;
@class GTLRCloudRun_Container;
@class GTLRCloudRun_ContainerPort;
@class GTLRCloudRun_DomainMapping;
@class GTLRCloudRun_DomainMappingSpec;
@class GTLRCloudRun_DomainMappingStatus;
@class GTLRCloudRun_EnvFromSource;
@class GTLRCloudRun_EnvVar;
@class GTLRCloudRun_EnvVarSource;
@class GTLRCloudRun_ExecAction;
@class GTLRCloudRun_Expr;
@class GTLRCloudRun_GoogleCloudRunV1Condition;
@class GTLRCloudRun_Handler;
@class GTLRCloudRun_HTTPGetAction;
@class GTLRCloudRun_HTTPHeader;
@class GTLRCloudRun_IntOrString;
@class GTLRCloudRun_KeyToPath;
@class GTLRCloudRun_ListMeta;
@class GTLRCloudRun_LocalObjectReference;
@class GTLRCloudRun_Location;
@class GTLRCloudRun_Location_Labels;
@class GTLRCloudRun_Location_Metadata;
@class GTLRCloudRun_ObjectMeta;
@class GTLRCloudRun_ObjectMeta_Annotations;
@class GTLRCloudRun_ObjectMeta_Labels;
@class GTLRCloudRun_OwnerReference;
@class GTLRCloudRun_Policy;
@class GTLRCloudRun_Probe;
@class GTLRCloudRun_ResourceRecord;
@class GTLRCloudRun_ResourceRequirements;
@class GTLRCloudRun_ResourceRequirements_Limits;
@class GTLRCloudRun_ResourceRequirements_Requests;
@class GTLRCloudRun_Revision;
@class GTLRCloudRun_RevisionSpec;
@class GTLRCloudRun_RevisionStatus;
@class GTLRCloudRun_RevisionTemplate;
@class GTLRCloudRun_Route;
@class GTLRCloudRun_RouteSpec;
@class GTLRCloudRun_RouteStatus;
@class GTLRCloudRun_SecretEnvSource;
@class GTLRCloudRun_SecretKeySelector;
@class GTLRCloudRun_SecretVolumeSource;
@class GTLRCloudRun_SecurityContext;
@class GTLRCloudRun_Service;
@class GTLRCloudRun_ServiceSpec;
@class GTLRCloudRun_ServiceStatus;
@class GTLRCloudRun_StatusCause;
@class GTLRCloudRun_StatusDetails;
@class GTLRCloudRun_TCPSocketAction;
@class GTLRCloudRun_TrafficTarget;
@class GTLRCloudRun_Volume;
@class GTLRCloudRun_VolumeMount;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCloudRun_AuditLogConfig.logType

/**
 *  Admin reads. Example: CloudIAM getIamPolicy
 *
 *  Value: "ADMIN_READ"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_AuditLogConfig_LogType_AdminRead;
/**
 *  Data reads. Example: CloudSQL Users list
 *
 *  Value: "DATA_READ"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_AuditLogConfig_LogType_DataRead;
/**
 *  Data writes. Example: CloudSQL Users create
 *
 *  Value: "DATA_WRITE"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_AuditLogConfig_LogType_DataWrite;
/**
 *  Default case. Should never be this.
 *
 *  Value: "LOG_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_AuditLogConfig_LogType_LogTypeUnspecified;

// ----------------------------------------------------------------------------
// GTLRCloudRun_AutoDomainMappingSpec.certificateMode

/**
 *  Automatically provisions an HTTPS certificate via LetsEncrypt.
 *
 *  Value: "AUTOMATIC"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_AutoDomainMappingSpec_CertificateMode_Automatic;
/** Value: "CERTIFICATE_MODE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRCloudRun_AutoDomainMappingSpec_CertificateMode_CertificateModeUnspecified;
/**
 *  Do not provision an HTTPS certificate.
 *
 *  Value: "NONE"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_AutoDomainMappingSpec_CertificateMode_None;

// ----------------------------------------------------------------------------
// GTLRCloudRun_AutoDomainMappingSpec.expansionType

/** Value: "EXPANSION_TYPE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRCloudRun_AutoDomainMappingSpec_ExpansionType_ExpansionTypeUnspecified;
/** Value: "PREFIX" */
GTLR_EXTERN NSString * const kGTLRCloudRun_AutoDomainMappingSpec_ExpansionType_Prefix;

// ----------------------------------------------------------------------------
// GTLRCloudRun_DomainMappingSpec.certificateMode

/**
 *  Automatically provisions an HTTPS certificate via LetsEncrypt.
 *
 *  Value: "AUTOMATIC"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_DomainMappingSpec_CertificateMode_Automatic;
/** Value: "CERTIFICATE_MODE_UNSPECIFIED" */
GTLR_EXTERN NSString * const kGTLRCloudRun_DomainMappingSpec_CertificateMode_CertificateModeUnspecified;
/**
 *  Do not provision an HTTPS certificate.
 *
 *  Value: "NONE"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_DomainMappingSpec_CertificateMode_None;

// ----------------------------------------------------------------------------
// GTLRCloudRun_ResourceRecord.type

/**
 *  An A resource record. Data is an IPv4 address.
 *
 *  Value: "A"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_ResourceRecord_Type_A;
/**
 *  An AAAA resource record. Data is an IPv6 address.
 *
 *  Value: "AAAA"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_ResourceRecord_Type_Aaaa;
/**
 *  A CNAME resource record. Data is a domain name to be aliased.
 *
 *  Value: "CNAME"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_ResourceRecord_Type_Cname;
/**
 *  An unknown resource record.
 *
 *  Value: "RECORD_TYPE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRCloudRun_ResourceRecord_Type_RecordTypeUnspecified;

/**
 *  Information for connecting over HTTP(s).
 */
@interface GTLRCloudRun_Addressable : GTLRObject

@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Specifies the audit configuration for a service.
 *  The configuration determines which permission types are logged, and what
 *  identities, if any, are exempted from logging.
 *  An AuditConfig must have one or more AuditLogConfigs.
 *  If there are AuditConfigs for both `allServices` and a specific service,
 *  the union of the two AuditConfigs is used for that service: the log_types
 *  specified in each AuditConfig are enabled, and the exempted_members in each
 *  AuditLogConfig are exempted.
 *  Example Policy with multiple AuditConfigs:
 *  {
 *  "audit_configs": [
 *  {
 *  "service": "allServices"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:jose\@example.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  },
 *  {
 *  "log_type": "ADMIN_READ",
 *  }
 *  ]
 *  },
 *  {
 *  "service": "sampleservice.googleapis.com"
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  "exempted_members": [
 *  "user:aliya\@example.com"
 *  ]
 *  }
 *  ]
 *  }
 *  ]
 *  }
 *  For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
 *  logging. It also exempts jose\@example.com from DATA_READ logging, and
 *  aliya\@example.com from DATA_WRITE logging.
 */
@interface GTLRCloudRun_AuditConfig : GTLRObject

/** The configuration for logging of each type of permission. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_AuditLogConfig *> *auditLogConfigs;

/**
 *  Specifies a service that will be enabled for audit logging.
 *  For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
 *  `allServices` is a special value that covers all services.
 */
@property(nonatomic, copy, nullable) NSString *service;

@end


/**
 *  Provides the configuration for logging a type of permissions.
 *  Example:
 *  {
 *  "audit_log_configs": [
 *  {
 *  "log_type": "DATA_READ",
 *  "exempted_members": [
 *  "user:jose\@example.com"
 *  ]
 *  },
 *  {
 *  "log_type": "DATA_WRITE",
 *  }
 *  ]
 *  }
 *  This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
 *  jose\@example.com from DATA_READ logging.
 */
@interface GTLRCloudRun_AuditLogConfig : GTLRObject

/**
 *  Specifies the identities that do not cause logging for this type of
 *  permission.
 *  Follows the same format of Binding.members.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *exemptedMembers;

/**
 *  The log type that this config enables.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudRun_AuditLogConfig_LogType_AdminRead Admin reads.
 *        Example: CloudIAM getIamPolicy (Value: "ADMIN_READ")
 *    @arg @c kGTLRCloudRun_AuditLogConfig_LogType_DataRead Data reads. Example:
 *        CloudSQL Users list (Value: "DATA_READ")
 *    @arg @c kGTLRCloudRun_AuditLogConfig_LogType_DataWrite Data writes.
 *        Example: CloudSQL Users create (Value: "DATA_WRITE")
 *    @arg @c kGTLRCloudRun_AuditLogConfig_LogType_LogTypeUnspecified Default
 *        case. Should never be this. (Value: "LOG_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *logType;

@end


/**
 *  A domain that a user has been authorized to administer. To authorize use
 *  of a domain, verify ownership via
 *  [Webmaster Central](https://www.google.com/webmasters/verification/home).
 */
@interface GTLRCloudRun_AuthorizedDomain : GTLRObject

/**
 *  Relative name of the domain authorized for use. Example: `example.com`.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  Read only. Full path to the `AuthorizedDomain` resource in the API.
 *  Example: `apps/myapp/authorizedDomains/example.com`.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Resource to hold the state and status of a user's auto domain mapping.
 */
@interface GTLRCloudRun_AutoDomainMapping : GTLRObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** The kind of resource, in this case "AutoDomainMapping". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this BuildTemplate. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** The spec for this AutoDomainMapping. */
@property(nonatomic, strong, nullable) GTLRCloudRun_AutoDomainMappingSpec *spec;

/** The current status of the AutoDomainMapping. */
@property(nonatomic, strong, nullable) GTLRCloudRun_AutoDomainMappingStatus *status;

@end


/**
 *  The desired state of the Auto Domain Mapping.
 */
@interface GTLRCloudRun_AutoDomainMappingSpec : GTLRObject

/**
 *  The mode of the certificate.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudRun_AutoDomainMappingSpec_CertificateMode_Automatic
 *        Automatically provisions an HTTPS certificate via LetsEncrypt. (Value:
 *        "AUTOMATIC")
 *    @arg @c kGTLRCloudRun_AutoDomainMappingSpec_CertificateMode_CertificateModeUnspecified
 *        Value "CERTIFICATE_MODE_UNSPECIFIED"
 *    @arg @c kGTLRCloudRun_AutoDomainMappingSpec_CertificateMode_None Do not
 *        provision an HTTPS certificate. (Value: "NONE")
 */
@property(nonatomic, copy, nullable) NSString *certificateMode;

/**
 *  The type of expansion for the auto auto domain mapping.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudRun_AutoDomainMappingSpec_ExpansionType_ExpansionTypeUnspecified
 *        Value "EXPANSION_TYPE_UNSPECIFIED"
 *    @arg @c kGTLRCloudRun_AutoDomainMappingSpec_ExpansionType_Prefix Value
 *        "PREFIX"
 */
@property(nonatomic, copy, nullable) NSString *expansionType;

/**
 *  If set, the mapping will override any mapping set before this spec was set.
 *  It is recommended that the user leaves this empty to receive an error
 *  warning about a potential conflict and only set it once the respective UI
 *  has given such a warning.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *forceOverride;

@end


/**
 *  The current state of the Domain Mapping.
 */
@interface GTLRCloudRun_AutoDomainMappingStatus : GTLRObject

/**
 *  Array of observed AutoDomainMappingConditions, indicating the current state
 *  of the AutoDomainMapping.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_GoogleCloudRunV1Condition *> *conditions;

/**
 *  ObservedGeneration is the 'Generation' of the AutoDomainMapping that
 *  was last processed by the controller.
 *  Clients polling for completed reconciliation should poll until
 *  observedGeneration = metadata.generation and the Ready condition's status
 *  is True or False.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *observedGeneration;

/**
 *  The resource records required to configure this domain mapping. These
 *  records must be added to the domain's DNS configuration in order to
 *  serve the application via this domain mapping.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_ResourceRecord *> *resourceRecords;

@end


/**
 *  Associates `members` with a `role`.
 */
@interface GTLRCloudRun_Binding : GTLRObject

/**
 *  The condition that is associated with this binding.
 *  NOTE: An unsatisfied condition will not allow user access via current
 *  binding. Different bindings, including their conditions, are examined
 *  independently.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Expr *condition;

/**
 *  Specifies the identities requesting access for a Cloud Platform resource.
 *  `members` can have the following values:
 *  * `allUsers`: A special identifier that represents anyone who is
 *  on the internet; with or without a Google account.
 *  * `allAuthenticatedUsers`: A special identifier that represents anyone
 *  who is authenticated with a Google account or a service account.
 *  * `user:{emailid}`: An email address that represents a specific Google
 *  account. For example, `alice\@example.com` .
 *  * `serviceAccount:{emailid}`: An email address that represents a service
 *  account. For example, `my-other-app\@appspot.gserviceaccount.com`.
 *  * `group:{emailid}`: An email address that represents a Google group.
 *  For example, `admins\@example.com`.
 *  * `domain:{domain}`: The G Suite domain (primary) that represents all the
 *  users of that domain. For example, `google.com` or `example.com`.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *members;

/**
 *  Role that is assigned to `members`.
 *  For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
 */
@property(nonatomic, copy, nullable) NSString *role;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  ConfigMapEnvSource selects a ConfigMap to populate the environment
 *  variables with.
 *  The contents of the target ConfigMap's Data field will represent the
 *  key-value pairs as environment variables.
 */
@interface GTLRCloudRun_ConfigMapEnvSource : GTLRObject

/**
 *  This field should not be used directly as it is meant to be inlined
 *  directly into the message. Use the "name" field instead.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_LocalObjectReference *localObjectReference;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The ConfigMap to select from.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Specify whether the ConfigMap must be defined
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Selects a key from a ConfigMap.
 */
@interface GTLRCloudRun_ConfigMapKeySelector : GTLRObject

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The key to select.
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  This field should not be used directly as it is meant to be inlined
 *  directly into the message. Use the "name" field instead.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_LocalObjectReference *localObjectReference;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The ConfigMap to select from.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Specify whether the ConfigMap or its key must be defined
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Adapts a ConfigMap into a volume.
 *  The contents of the target ConfigMap's Data field will be presented in a
 *  volume as files using the keys in the Data field as the file names, unless
 *  the items element is populated with specific mappings of keys to paths.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ConfigMapVolumeSource : GTLRCollectionObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Mode bits to use on created files by default. Must be a value between 0 and
 *  0777. Defaults to 0644. Directories within the path are not affected by
 *  this setting. This might be in conflict with other options that affect the
 *  file mode, like fsGroup, and the result can be other mode bits set.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultMode;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  If unspecified, each key-value pair in the Data field of the referenced
 *  Secret will be projected into the volume as a file whose name is the
 *  key and content is the value. If specified, the listed keys will be
 *  projected into the specified paths, and unlisted keys will not be
 *  present. If a key is specified which is not present in the Secret,
 *  the volume setup will error unless it is marked optional.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_KeyToPath *> *items;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Name of the config.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Specify whether the Secret or its keys must be defined.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

@end


/**
 *  Configuration represents the "floating HEAD" of a linear history of
 *  Revisions, and optionally how the containers those revisions reference are
 *  built. Users create new Revisions by updating the Configuration's spec. The
 *  "latest created" revision's name is available under status, as is the
 *  "latest
 *  ready" revision's name. See also:
 *  https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration
 */
@interface GTLRCloudRun_Configuration : GTLRObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** The kind of resource, in this case always "Configuration". */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Metadata associated with this Configuration, including name, namespace,
 *  labels, and annotations.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** Spec holds the desired state of the Configuration (from the client). */
@property(nonatomic, strong, nullable) GTLRCloudRun_ConfigurationSpec *spec;

/**
 *  Status communicates the observed state of the Configuration (from the
 *  controller).
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ConfigurationStatus *status;

@end


/**
 *  ConfigurationSpec holds the desired state of the Configuration (from the
 *  client).
 */
@interface GTLRCloudRun_ConfigurationSpec : GTLRObject

/**
 *  Optional metadata for this Revision, including labels and annotations. Name
 *  will be generated by the Configuration.
 *  To set minimum instances for this revision, use the
 *  "autoscaling.knative.dev/minScale" annotation key. (Cloud Run for Anthos
 *  only). To set maximum instances for this revision, use the
 *  "autoscaling.knative.dev/maxScale" annotation key.
 *  To set Cloud SQL connections for the revision, use the
 *  "run.googleapis.com/cloudsql-instances" annotation key. Values should be
 *  comma separated.
 *
 *  Remapped to 'templateProperty' to avoid language reserved word 'template'.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_RevisionTemplate *templateProperty;

@end


/**
 *  ConfigurationStatus communicates the observed state of the Configuration
 *  (from the controller).
 */
@interface GTLRCloudRun_ConfigurationStatus : GTLRObject

/**
 *  Conditions communicates information about ongoing/complete
 *  reconciliation processes that bring the "spec" inline with the observed
 *  state of the world.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_GoogleCloudRunV1Condition *> *conditions;

/**
 *  LatestCreatedRevisionName is the last revision that was created from this
 *  Configuration. It might not be ready yet, for that use
 *  LatestReadyRevisionName.
 */
@property(nonatomic, copy, nullable) NSString *latestCreatedRevisionName;

/**
 *  LatestReadyRevisionName holds the name of the latest Revision stamped out
 *  from this Configuration that has had its "Ready" condition become "True".
 */
@property(nonatomic, copy, nullable) NSString *latestReadyRevisionName;

/**
 *  ObservedGeneration is the 'Generation' of the Configuration that
 *  was last processed by the controller. The observed generation is updated
 *  even if the controller failed to process the spec and create the Revision.
 *  Clients polling for completed reconciliation should poll until
 *  observedGeneration = metadata.generation, and the Ready condition's status
 *  is True or False.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *observedGeneration;

@end


/**
 *  A single application container.
 *  This specifies both the container to run, the command to run in the
 *  container
 *  and the arguments to supply to it.
 *  Note that additional arguments may be supplied by the system to the
 *  container
 *  at runtime.
 */
@interface GTLRCloudRun_Container : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: supported
 *  Cloud Run for Anthos: supported
 *  Arguments to the entrypoint.
 *  The docker image's CMD is used if this is not provided.
 *  Variable references $(VAR_NAME) are expanded using the container's
 *  environment. If a variable cannot be resolved, the reference in the input
 *  string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
 *  double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
 *  regardless of whether the variable exists or not.
 *  More info:
 *  https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *args;

@property(nonatomic, strong, nullable) NSArray<NSString *> *command;

/**
 *  (Optional)
 *  Cloud Run fully managed: supported
 *  Cloud Run for Anthos: supported
 *  List of environment variables to set in the container.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_EnvVar *> *env;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  List of sources to populate environment variables in the container.
 *  The keys defined within a source must be a C_IDENTIFIER. All invalid keys
 *  will be reported as an event when the container is starting. When a key
 *  exists in multiple sources, the value associated with the last source will
 *  take precedence. Values defined by an Env with a duplicate key will take
 *  precedence. Cannot be updated.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_EnvFromSource *> *envFrom;

/**
 *  Cloud Run fully managed: only supports containers from Google Container
 *  Registry
 *  Cloud Run for Anthos: supported
 *  URL of the Container image.
 *  More info: https://kubernetes.io/docs/concepts/containers/images
 */
@property(nonatomic, copy, nullable) NSString *image;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Image pull policy.
 *  One of Always, Never, IfNotPresent.
 *  Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
 *  More info:
 *  https://kubernetes.io/docs/concepts/containers/images#updating-images
 */
@property(nonatomic, copy, nullable) NSString *imagePullPolicy;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Periodic probe of container liveness.
 *  Container will be restarted if the probe fails.
 *  More info:
 *  https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Probe *livenessProbe;

/**
 *  (Optional)
 *  Name of the container specified as a DNS_LABEL.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  List of ports to expose from the container. Exposing a port here gives
 *  the system additional information about the network connections a
 *  container uses, but is primarily informational. Not specifying a port here
 *  DOES NOT prevent that port from being exposed. Any port which is
 *  listening on the default "0.0.0.0" address inside a container will be
 *  accessible from the network.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_ContainerPort *> *ports;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Periodic probe of container service readiness.
 *  Container will be removed from service endpoints if the probe fails.
 *  More info:
 *  https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Probe *readinessProbe;

/**
 *  (Optional)
 *  Cloud Run fully managed: supported
 *  Cloud Run for Anthos: supported
 *  Compute Resources required by this container.
 *  More info:
 *  https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ResourceRequirements *resources;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Security options the pod should run with.
 *  More info: https://kubernetes.io/docs/concepts/policy/security-context/
 *  More info:
 *  https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_SecurityContext *securityContext;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Path at which the file to which the container's termination
 *  message will be written is mounted into the container's filesystem. Message
 *  written is intended to be brief final status, such as an assertion failure
 *  message. Will be truncated by the node if greater than 4096 bytes. The
 *  total message length across all containers will be limited to 12kb.
 *  Defaults to /dev/termination-log.
 */
@property(nonatomic, copy, nullable) NSString *terminationMessagePath;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Indicate how the termination message should be populated. File will use the
 *  contents of terminationMessagePath to populate the container status message
 *  on both success and failure. FallbackToLogsOnError will use the last chunk
 *  of container log output if the termination message file is empty and the
 *  container exited with an error. The log output is limited to 2048 bytes or
 *  80 lines, whichever is smaller. Defaults to File. Cannot be updated.
 */
@property(nonatomic, copy, nullable) NSString *terminationMessagePolicy;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Pod volumes to mount into the container's filesystem.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_VolumeMount *> *volumeMounts;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Container's working directory.
 *  If not specified, the container runtime's default will be used, which
 *  might be configured in the container image.
 */
@property(nonatomic, copy, nullable) NSString *workingDir;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  ContainerPort represents a network port in a single container.
 */
@interface GTLRCloudRun_ContainerPort : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Number of port to expose on the pod's IP address.
 *  This must be a valid port number, 0 < x < 65536.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *containerPort;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  If specified, used to specify which protocol to use.
 *  Allowed values are "http1" and "h2c".
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Protocol for port. Must be TCP.
 *  Defaults to "TCP".
 */
@property(nonatomic, copy, nullable) NSString *protocol;

@end


/**
 *  Resource to hold the state and status of a user's domain mapping.
 */
@interface GTLRCloudRun_DomainMapping : GTLRObject

/** The API version for this call such as "domains.cloudrun.com/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** The kind of resource, in this case "DomainMapping". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this BuildTemplate. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** The spec for this DomainMapping. */
@property(nonatomic, strong, nullable) GTLRCloudRun_DomainMappingSpec *spec;

/** The current status of the DomainMapping. */
@property(nonatomic, strong, nullable) GTLRCloudRun_DomainMappingStatus *status;

@end


/**
 *  The desired state of the Domain Mapping.
 */
@interface GTLRCloudRun_DomainMappingSpec : GTLRObject

/**
 *  The mode of the certificate.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudRun_DomainMappingSpec_CertificateMode_Automatic
 *        Automatically provisions an HTTPS certificate via LetsEncrypt. (Value:
 *        "AUTOMATIC")
 *    @arg @c kGTLRCloudRun_DomainMappingSpec_CertificateMode_CertificateModeUnspecified
 *        Value "CERTIFICATE_MODE_UNSPECIFIED"
 *    @arg @c kGTLRCloudRun_DomainMappingSpec_CertificateMode_None Do not
 *        provision an HTTPS certificate. (Value: "NONE")
 */
@property(nonatomic, copy, nullable) NSString *certificateMode;

/**
 *  If set, the mapping will override any mapping set before this spec was set.
 *  It is recommended that the user leaves this empty to receive an error
 *  warning about a potential conflict and only set it once the respective UI
 *  has given such a warning.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *forceOverride;

/**
 *  The name of the Knative Route that this DomainMapping applies to.
 *  The route must exist.
 */
@property(nonatomic, copy, nullable) NSString *routeName;

@end


/**
 *  The current state of the Domain Mapping.
 */
@interface GTLRCloudRun_DomainMappingStatus : GTLRObject

/**
 *  Array of observed DomainMappingConditions, indicating the current state
 *  of the DomainMapping.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_GoogleCloudRunV1Condition *> *conditions;

/** The name of the route that the mapping currently points to. */
@property(nonatomic, copy, nullable) NSString *mappedRouteName;

/**
 *  ObservedGeneration is the 'Generation' of the DomainMapping that
 *  was last processed by the controller.
 *  Clients polling for completed reconciliation should poll until
 *  observedGeneration = metadata.generation and the Ready condition's status
 *  is True or False.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *observedGeneration;

/**
 *  The resource records required to configure this domain mapping. These
 *  records must be added to the domain's DNS configuration in order to
 *  serve the application via this domain mapping.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_ResourceRecord *> *resourceRecords;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  EnvFromSource represents the source of a set of ConfigMaps
 */
@interface GTLRCloudRun_EnvFromSource : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The ConfigMap to select from
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ConfigMapEnvSource *configMapRef;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  An optional identifier to prepend to each key in the ConfigMap. Must be a
 *  C_IDENTIFIER.
 */
@property(nonatomic, copy, nullable) NSString *prefix;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The Secret to select from
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_SecretEnvSource *secretRef;

@end


/**
 *  EnvVar represents an environment variable present in a Container.
 */
@interface GTLRCloudRun_EnvVar : GTLRObject

/** Name of the environment variable. Must be a C_IDENTIFIER. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Variable references $(VAR_NAME) are expanded
 *  using the previous defined environment variables in the container and
 *  any route environment variables. If a variable cannot be resolved,
 *  the reference in the input string will be unchanged. The $(VAR_NAME)
 *  syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
 *  references will never be expanded, regardless of whether the variable
 *  exists or not.
 *  Defaults to "".
 */
@property(nonatomic, copy, nullable) NSString *value;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Source for the environment variable's value. Cannot be used if value is not
 *  empty.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_EnvVarSource *valueFrom;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  EnvVarSource represents a source for the value of an EnvVar.
 */
@interface GTLRCloudRun_EnvVarSource : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Selects a key of a ConfigMap.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ConfigMapKeySelector *configMapKeyRef;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Selects a key of a secret in the pod's namespace
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_SecretKeySelector *secretKeyRef;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  ExecAction describes a "run in container" action.
 */
@interface GTLRCloudRun_ExecAction : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Command is the command line to execute inside the container, the working
 *  directory for the command is root ('/') in the container's filesystem. The
 *  command is simply exec'd, it is not run inside a shell, so traditional
 *  shell instructions ('|', etc) won't work. To use a shell, you need to
 *  explicitly call out to that shell. Exit status of 0 is treated as
 *  live/healthy and non-zero is unhealthy.
 */
@property(nonatomic, copy, nullable) NSString *command;

@end


/**
 *  Represents an expression text. Example:
 *  title: "User account presence"
 *  description: "Determines whether the request has a user account"
 *  expression: "size(request.user) > 0"
 */
@interface GTLRCloudRun_Expr : GTLRObject

/**
 *  An optional description of the expression. This is a longer text which
 *  describes the expression, e.g. when hovered over it in a UI.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  Textual representation of an expression in
 *  Common Expression Language syntax.
 *  The application context of the containing message determines which
 *  well-known feature set of CEL is supported.
 */
@property(nonatomic, copy, nullable) NSString *expression;

/**
 *  An optional string indicating the location of the expression for error
 *  reporting, e.g. a file name and a position in the file.
 */
@property(nonatomic, copy, nullable) NSString *location;

/**
 *  An optional title for the expression, i.e. a short string describing
 *  its purpose. This can be used e.g. in UIs which allow to enter the
 *  expression.
 */
@property(nonatomic, copy, nullable) NSString *title;

@end


/**
 *  Condition defines a generic condition for a Resource
 */
@interface GTLRCloudRun_GoogleCloudRunV1Condition : GTLRObject

/**
 *  Optional. Last time the condition transitioned from one status to another.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *lastTransitionTime;

/**
 *  Optional. Human readable message indicating details about the current
 *  status.
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  Optional. One-word CamelCase reason for the condition's last transition.
 */
@property(nonatomic, copy, nullable) NSString *reason;

/**
 *  Optional. How to interpret failures of this condition, one of Error,
 *  Warning, Info
 */
@property(nonatomic, copy, nullable) NSString *severity;

/** Status of the condition, one of True, False, Unknown. */
@property(nonatomic, copy, nullable) NSString *status;

/**
 *  type is used to communicate the status of the reconciliation process.
 *  See also:
 *  https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting
 *  Types common to all resources include:
 *  * "Ready": True when the Resource is ready.
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Handler defines a specific action that should be taken
 */
@interface GTLRCloudRun_Handler : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  One and only one of the following should be specified.
 *  Exec specifies the action to take.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ExecAction *exec;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  HTTPGet specifies the http request to perform.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_HTTPGetAction *httpGet;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  TCPSocket specifies an action involving a TCP port.
 *  TCP hooks not yet supported
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_TCPSocketAction *tcpSocket;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  HTTPGetAction describes an action based on HTTP Get requests.
 */
@interface GTLRCloudRun_HTTPGetAction : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Host name to connect to, defaults to the pod IP. You probably want to set
 *  "Host" in httpHeaders instead.
 */
@property(nonatomic, copy, nullable) NSString *host;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Custom headers to set in the request. HTTP allows repeated headers.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_HTTPHeader *> *httpHeaders;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Path to access on the HTTP server.
 */
@property(nonatomic, copy, nullable) NSString *path;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Scheme to use for connecting to the host.
 *  Defaults to HTTP.
 */
@property(nonatomic, copy, nullable) NSString *scheme;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  HTTPHeader describes a custom header to be used in HTTP probes
 */
@interface GTLRCloudRun_HTTPHeader : GTLRObject

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The header field name
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The header field value
 */
@property(nonatomic, copy, nullable) NSString *value;

@end


/**
 *  IntOrString is a type that can hold an int32 or a string. When used in
 *  JSON or YAML marshalling and unmarshalling, it produces or consumes the
 *  inner type. This allows you to have, for example, a JSON field that can
 *  accept a name or number.
 */
@interface GTLRCloudRun_IntOrString : GTLRObject

/**
 *  The int value.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *intVal;

/** The string value. */
@property(nonatomic, copy, nullable) NSString *strVal;

/**
 *  The type of the value.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *type;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Maps a string key to a path within a volume.
 */
@interface GTLRCloudRun_KeyToPath : GTLRObject

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The key to project.
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Mode bits to use on this file, must be a value between 0 and 0777. If not
 *  specified, the volume defaultMode will be used. This might be in conflict
 *  with other options that affect the file mode, like fsGroup, and the result
 *  can be other mode bits set.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mode;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The relative path of the file to map the key to.
 *  May not be an absolute path.
 *  May not contain the path element '..'.
 *  May not start with the string '..'.
 */
@property(nonatomic, copy, nullable) NSString *path;

@end


/**
 *  A list of Authorized Domains.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "domains" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudRun_ListAuthorizedDomainsResponse : GTLRCollectionObject

/**
 *  The authorized domains belonging to the user.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_AuthorizedDomain *> *domains;

/** Continuation token for fetching the next page of results. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  ListAutoDomainMappingsResponse is a list of AutoDomainMapping resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ListAutoDomainMappingsResponse : GTLRCollectionObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  List of AutoDomainMappings.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_AutoDomainMapping *> *items;

/** The kind of this resource, in this case "AutoDomainMappingList". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this AutoDomainMapping list. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListConfigurationsResponse is a list of Configuration resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ListConfigurationsResponse : GTLRCollectionObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  List of Configurations.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Configuration *> *items;

/** The kind of this resource, in this case "ConfigurationList". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this Configuration list. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListDomainMappingsResponse is a list of DomainMapping resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ListDomainMappingsResponse : GTLRCollectionObject

/** The API version for this call such as "domains.cloudrun.com/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  List of DomainMappings.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_DomainMapping *> *items;

/** The kind of this resource, in this case "DomainMappingList". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this DomainMapping list. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  The response message for Locations.ListLocations.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "locations" property. If returned as the result of a query, it
 *        should support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCloudRun_ListLocationsResponse : GTLRCollectionObject

/**
 *  A list of locations that matches the specified filter in the request.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Location *> *locations;

/** The standard List next-page token. */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  ListMeta describes metadata that synthetic resources must have, including
 *  lists and various status objects. A resource may have only one of
 *  {ObjectMeta, ListMeta}.
 */
@interface GTLRCloudRun_ListMeta : GTLRObject

/**
 *  continue may be set if the user set a limit on the number of items
 *  returned, and indicates that the server has more data available. The value
 *  is opaque and may be used to issue another request to the endpoint that
 *  served this list to retrieve the next set of available objects. Continuing
 *  a list may not be possible if the server configuration has changed or more
 *  than a few minutes have passed. The resourceVersion field returned when
 *  using this continue value will be identical to the value in the first
 *  response.
 *
 *  Remapped to 'continueProperty' to avoid language reserved word 'continue'.
 */
@property(nonatomic, copy, nullable) NSString *continueProperty;

/**
 *  String that identifies the server's internal version of this object that
 *  can be used by clients to determine when objects have changed. Value must
 *  be treated as opaque by clients and passed unmodified back to the server.
 *  Populated by the system.
 *  Read-only.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *resourceVersion;

/**
 *  SelfLink is a URL representing this object.
 *  Populated by the system.
 *  Read-only.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *selfLink;

@end


/**
 *  ListRevisionsResponse is a list of Revision resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ListRevisionsResponse : GTLRCollectionObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  List of Revisions.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Revision *> *items;

/** The kind of this resource, in this case "RevisionList". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this revision list. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  ListRoutesResponse is a list of Route resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ListRoutesResponse : GTLRCollectionObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  List of Routes.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Route *> *items;

/** The kind of this resource, in this case always "RouteList". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this Route list. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  A list of Service resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_ListServicesResponse : GTLRCollectionObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  List of Services.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Service *> *items;

/** The kind of this resource, in this case "ServiceList". */
@property(nonatomic, copy, nullable) NSString *kind;

/** Metadata associated with this Service list. */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/** Locations that could not be reached. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *unreachable;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  LocalObjectReference contains enough information to let you locate the
 *  referenced object inside the same namespace.
 */
@interface GTLRCloudRun_LocalObjectReference : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Name of the referent.
 *  More info:
 *  https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  A resource that represents Google Cloud Platform location.
 */
@interface GTLRCloudRun_Location : GTLRObject

/**
 *  The friendly name for this location, typically a nearby city name.
 *  For example, "Tokyo".
 */
@property(nonatomic, copy, nullable) NSString *displayName;

/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Location_Labels *labels;

/** The canonical id for this location. For example: `"us-east1"`. */
@property(nonatomic, copy, nullable) NSString *locationId;

/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Location_Metadata *metadata;

/**
 *  Resource name for the location, which may vary between implementations.
 *  For example: `"projects/example-project/locations/us-east1"`
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  Cross-service attributes for the location. For example
 *  {"cloud.googleapis.com/region": "us-east1"}
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudRun_Location_Labels : GTLRObject
@end


/**
 *  Service-specific metadata. For example the available capacity at the given
 *  location.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRCloudRun_Location_Metadata : GTLRObject
@end


/**
 *  k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta is metadata that all
 *  persisted resources must have, which includes all objects users must create.
 */
@interface GTLRCloudRun_ObjectMeta : GTLRObject

/**
 *  (Optional)
 *  Annotations is an unstructured key value map stored with a resource that
 *  may be set by external tools to store and retrieve arbitrary metadata. They
 *  are not queryable and should be preserved when modifying objects. More
 *  info: http://kubernetes.io/docs/user-guide/annotations
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta_Annotations *annotations;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The name of the cluster which the object belongs to.
 *  This is used to distinguish resources with same name and namespace in
 *  different clusters. This field is not set anywhere right now and apiserver
 *  is going to ignore it if set in create or update request.
 */
@property(nonatomic, copy, nullable) NSString *clusterName;

/**
 *  (Optional)
 *  CreationTimestamp is a timestamp representing the server time when this
 *  object was created. It is not guaranteed to be set in happens-before order
 *  across separate operations. Clients may not set this value. It is
 *  represented in RFC3339 form and is in UTC.
 *  Populated by the system.
 *  Read-only.
 *  Null for lists.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
 */
@property(nonatomic, strong, nullable) GTLRDateTime *creationTimestamp;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Number of seconds allowed for this object to gracefully terminate before
 *  it will be removed from the system. Only set when deletionTimestamp is also
 *  set. May only be shortened. Read-only.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *deletionGracePeriodSeconds;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  DeletionTimestamp is RFC 3339 date and time at which this resource will be
 *  deleted. This field is set by the server when a graceful deletion is
 *  requested by the user, and is not directly settable by a client. The
 *  resource is expected to be deleted (no longer visible from resource lists,
 *  and not reachable by name) after the time in this field, once the
 *  finalizers list is empty. As long as the finalizers list contains items,
 *  deletion is blocked. Once the deletionTimestamp is set, this value may not
 *  be unset or be set further into the future, although it may be shortened or
 *  the resource may be deleted prior to this time. For example, a user may
 *  request that a pod is deleted in 30 seconds. The Kubelet will react by
 *  sending a graceful termination signal to the containers in the pod. After
 *  that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL)
 *  to the container and after cleanup, remove the pod from the API. In the
 *  presence of network partitions, this object may still exist after this
 *  timestamp, until an administrator or automated process can determine the
 *  resource is fully terminated.
 *  If not set, graceful deletion of the object has not been requested.
 *  Populated by the system when a graceful deletion is requested.
 *  Read-only.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
 */
@property(nonatomic, strong, nullable) GTLRDateTime *deletionTimestamp;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Must be empty before the object is deleted from the registry. Each entry
 *  is an identifier for the responsible component that will remove the entry
 *  from the list. If the deletionTimestamp of the object is non-nil, entries
 *  in this list can only be removed.
 *  +patchStrategy=merge
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *finalizers;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  GenerateName is an optional prefix, used by the server, to generate a
 *  unique name ONLY IF the Name field has not been provided. If this field is
 *  used, the name returned to the client will be different than the name
 *  passed. This value will also be combined with a unique suffix. The provided
 *  value has the same validation rules as the Name field, and may be truncated
 *  by the length of the suffix required to make the value unique on the
 *  server.
 *  If this field is specified and the generated name exists, the server will
 *  NOT return a 409 - instead, it will either return 201 Created or 500 with
 *  Reason ServerTimeout indicating a unique name could not be found in the
 *  time allotted, and the client should retry (optionally after the time
 *  indicated in the Retry-After header).
 *  Applied only if Name is not specified.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency
 *  string generateName = 2;
 */
@property(nonatomic, copy, nullable) NSString *generateName;

/**
 *  (Optional)
 *  A sequence number representing a specific generation of the desired state.
 *  Populated by the system. Read-only.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *generation;

/**
 *  (Optional)
 *  Map of string keys and values that can be used to organize and categorize
 *  (scope and select) objects. May match selectors of replication controllers
 *  and routes.
 *  More info: http://kubernetes.io/docs/user-guide/labels
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta_Labels *labels;

/**
 *  Name must be unique within a namespace, within a Cloud Run region.
 *  Is required when creating
 *  resources, although some resources may allow a client to request the
 *  generation of an appropriate name automatically. Name is primarily intended
 *  for creation idempotence and configuration definition. Cannot be updated.
 *  More info: http://kubernetes.io/docs/user-guide/identifiers#names
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Namespace defines the space within each name must be unique, within a
 *  Cloud Run region. In Cloud Run the namespace must be equal to either the
 *  project ID or project number.
 *
 *  Remapped to 'namespaceProperty' to avoid language reserved word 'namespace'.
 */
@property(nonatomic, copy, nullable) NSString *namespaceProperty;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  List of objects that own this object. If ALL objects in the list have
 *  been deleted, this object will be garbage collected.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_OwnerReference *> *ownerReferences;

/**
 *  (Optional)
 *  An opaque value that represents the internal version of this object that
 *  can be used by clients to determine when objects have changed. May be used
 *  for optimistic concurrency, change detection, and the watch operation on a
 *  resource or set of resources. Clients must treat these values as opaque and
 *  passed unmodified back to the server. They may only be valid for a
 *  particular resource or set of resources.
 *  Populated by the system.
 *  Read-only.
 *  Value must be treated as opaque by clients and .
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
 */
@property(nonatomic, copy, nullable) NSString *resourceVersion;

/**
 *  (Optional)
 *  SelfLink is a URL representing this object.
 *  Populated by the system.
 *  Read-only.
 *  string selfLink = 4;
 */
@property(nonatomic, copy, nullable) NSString *selfLink;

/**
 *  (Optional)
 *  UID is the unique in time and space value for this object. It is typically
 *  generated by the server on successful creation of a resource and is not
 *  allowed to change on PUT operations.
 *  Populated by the system.
 *  Read-only.
 *  More info: http://kubernetes.io/docs/user-guide/identifiers#uids
 */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  (Optional)
 *  Annotations is an unstructured key value map stored with a resource that
 *  may be set by external tools to store and retrieve arbitrary metadata. They
 *  are not queryable and should be preserved when modifying objects. More
 *  info: http://kubernetes.io/docs/user-guide/annotations
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudRun_ObjectMeta_Annotations : GTLRObject
@end


/**
 *  (Optional)
 *  Map of string keys and values that can be used to organize and categorize
 *  (scope and select) objects. May match selectors of replication controllers
 *  and routes.
 *  More info: http://kubernetes.io/docs/user-guide/labels
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudRun_ObjectMeta_Labels : GTLRObject
@end


/**
 *  OwnerReference contains enough information to let you identify an owning
 *  object. Currently, an owning object must be in the same namespace, so there
 *  is no namespace field.
 */
@interface GTLRCloudRun_OwnerReference : GTLRObject

/** API version of the referent. */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/**
 *  If true, AND if the owner has the "foregroundDeletion" finalizer, then
 *  the owner cannot be deleted from the key-value store until this
 *  reference is removed.
 *  Defaults to false.
 *  To set this field, a user needs "delete" permission of the owner,
 *  otherwise 422 (Unprocessable Entity) will be returned.
 *  +optional
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *blockOwnerDeletion;

/**
 *  If true, this reference points to the managing controller.
 *  +optional
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *controller;

/**
 *  Kind of the referent.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Name of the referent.
 *  More info: http://kubernetes.io/docs/user-guide/identifiers#names
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  UID of the referent.
 *  More info: http://kubernetes.io/docs/user-guide/identifiers#uids
 */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  Defines an Identity and Access Management (IAM) policy. It is used to
 *  specify access control policies for Cloud Platform resources.
 *  A `Policy` is a collection of `bindings`. A `binding` binds one or more
 *  `members` to a single `role`. Members can be user accounts, service
 *  accounts,
 *  Google groups, and domains (such as G Suite). A `role` is a named list of
 *  permissions (defined by IAM or configured by users). A `binding` can
 *  optionally specify a `condition`, which is a logic expression that further
 *  constrains the role binding based on attributes about the request and/or
 *  target resource.
 *  **JSON Example**
 *  {
 *  "bindings": [
 *  {
 *  "role": "roles/resourcemanager.organizationAdmin",
 *  "members": [
 *  "user:mike\@example.com",
 *  "group:admins\@example.com",
 *  "domain:google.com",
 *  "serviceAccount:my-project-id\@appspot.gserviceaccount.com"
 *  ]
 *  },
 *  {
 *  "role": "roles/resourcemanager.organizationViewer",
 *  "members": ["user:eve\@example.com"],
 *  "condition": {
 *  "title": "expirable access",
 *  "description": "Does not grant access after Sep 2020",
 *  "expression": "request.time <
 *  timestamp('2020-10-01T00:00:00.000Z')",
 *  }
 *  }
 *  ]
 *  }
 *  **YAML Example**
 *  bindings:
 *  - members:
 *  - user:mike\@example.com
 *  - group:admins\@example.com
 *  - domain:google.com
 *  - serviceAccount:my-project-id\@appspot.gserviceaccount.com
 *  role: roles/resourcemanager.organizationAdmin
 *  - members:
 *  - user:eve\@example.com
 *  role: roles/resourcemanager.organizationViewer
 *  condition:
 *  title: expirable access
 *  description: Does not grant access after Sep 2020
 *  expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
 *  For a description of IAM and its features, see the
 *  [IAM developer's guide](https://cloud.google.com/iam/docs).
 */
@interface GTLRCloudRun_Policy : GTLRObject

/** Specifies cloud audit logging configuration for this policy. */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_AuditConfig *> *auditConfigs;

/**
 *  Associates a list of `members` to a `role`. Optionally may specify a
 *  `condition` that determines when binding is in effect.
 *  `bindings` with no members will result in an error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Binding *> *bindings;

/**
 *  `etag` is used for optimistic concurrency control as a way to help
 *  prevent simultaneous updates of a policy from overwriting each other.
 *  It is strongly suggested that systems make use of the `etag` in the
 *  read-modify-write cycle to perform policy updates in order to avoid race
 *  conditions: An `etag` is returned in the response to `getIamPolicy`, and
 *  systems are expected to put that etag in the request to `setIamPolicy` to
 *  ensure that their change will be applied to the same version of the policy.
 *  If no `etag` is provided in the call to `setIamPolicy`, then the existing
 *  policy is overwritten. Due to blind-set semantics of an etag-less policy,
 *  'setIamPolicy' will not fail even if either of incoming or stored policy
 *  does not meet the version requirements.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(nonatomic, copy, nullable) NSString *ETag;

/**
 *  Specifies the format of the policy.
 *  Valid values are 0, 1, and 3. Requests specifying an invalid value will be
 *  rejected.
 *  Operations affecting conditional bindings must specify version 3. This can
 *  be either setting a conditional policy, modifying a conditional binding,
 *  or removing a conditional binding from the stored conditional policy.
 *  Operations on non-conditional policies may specify any valid value or
 *  leave the field unset.
 *  If no etag is provided in the call to `setIamPolicy`, any version
 *  compliance checks on the incoming and/or stored policy is skipped.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *version;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Probe describes a health check to be performed against a container to
 *  determine whether it is alive or ready to receive traffic.
 */
@interface GTLRCloudRun_Probe : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Minimum consecutive failures for the probe to be considered failed after
 *  having succeeded. Defaults to 3. Minimum value is 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *failureThreshold;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The action taken to determine the health of a container
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Handler *handler;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Number of seconds after the container has started before liveness probes
 *  are initiated. More info:
 *  https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *initialDelaySeconds;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  How often (in seconds) to perform the probe.
 *  Default to 10 seconds. Minimum value is 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *periodSeconds;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Minimum consecutive successes for the probe to be considered successful
 *  after having failed. Defaults to 1. Must be 1 for liveness. Minimum value
 *  is 1.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *successThreshold;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Number of seconds after which the probe times out.
 *  Defaults to 1 second. Minimum value is 1.
 *  More info:
 *  https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *timeoutSeconds;

@end


/**
 *  A DNS resource record.
 */
@interface GTLRCloudRun_ResourceRecord : GTLRObject

/**
 *  Relative name of the object affected by this record. Only applicable for
 *  `CNAME` records. Example: 'www'.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Data for this record. Values vary by record type, as defined in RFC 1035
 *  (section 5) and RFC 1034 (section 3.6.1).
 */
@property(nonatomic, copy, nullable) NSString *rrdata;

/**
 *  Resource record type. Example: `AAAA`.
 *
 *  Likely values:
 *    @arg @c kGTLRCloudRun_ResourceRecord_Type_A An A resource record. Data is
 *        an IPv4 address. (Value: "A")
 *    @arg @c kGTLRCloudRun_ResourceRecord_Type_Aaaa An AAAA resource record.
 *        Data is an IPv6 address. (Value: "AAAA")
 *    @arg @c kGTLRCloudRun_ResourceRecord_Type_Cname A CNAME resource record.
 *        Data is a domain name to be aliased. (Value: "CNAME")
 *    @arg @c kGTLRCloudRun_ResourceRecord_Type_RecordTypeUnspecified An unknown
 *        resource record. (Value: "RECORD_TYPE_UNSPECIFIED")
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  ResourceRequirements describes the compute resource requirements.
 */
@interface GTLRCloudRun_ResourceRequirements : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: Only memory and CPU are supported. Note: The only
 *  supported value for CPU is '1'.
 *  Cloud Run for Anthos: supported
 *  Limits describes the maximum amount of compute resources allowed.
 *  The values of the map is string form of the 'quantity' k8s type:
 *  https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ResourceRequirements_Limits *limits;

/**
 *  (Optional)
 *  Cloud Run fully managed: Only memory and CPU are supported. Note: The only
 *  supported value for CPU is '1'.
 *  Cloud Run for Anthos: supported
 *  Requests describes the minimum amount of compute resources required.
 *  If Requests is omitted for a container, it defaults to Limits if that is
 *  explicitly specified, otherwise to an implementation-defined value.
 *  The values of the map is string form of the 'quantity' k8s type:
 *  https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ResourceRequirements_Requests *requests;

@end


/**
 *  (Optional)
 *  Cloud Run fully managed: Only memory and CPU are supported. Note: The only
 *  supported value for CPU is '1'.
 *  Cloud Run for Anthos: supported
 *  Limits describes the maximum amount of compute resources allowed.
 *  The values of the map is string form of the 'quantity' k8s type:
 *  https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudRun_ResourceRequirements_Limits : GTLRObject
@end


/**
 *  (Optional)
 *  Cloud Run fully managed: Only memory and CPU are supported. Note: The only
 *  supported value for CPU is '1'.
 *  Cloud Run for Anthos: supported
 *  Requests describes the minimum amount of compute resources required.
 *  If Requests is omitted for a container, it defaults to Limits if that is
 *  explicitly specified, otherwise to an implementation-defined value.
 *  The values of the map is string form of the 'quantity' k8s type:
 *  https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCloudRun_ResourceRequirements_Requests : GTLRObject
@end


/**
 *  Revision is an immutable snapshot of code and configuration. A revision
 *  references a container image. Revisions are created by updates to a
 *  Configuration.
 *  See also:
 *  https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision
 */
@interface GTLRCloudRun_Revision : GTLRObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** The kind of this resource, in this case "Revision". */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Metadata associated with this Revision, including name, namespace, labels,
 *  and annotations.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** Spec holds the desired state of the Revision (from the client). */
@property(nonatomic, strong, nullable) GTLRCloudRun_RevisionSpec *spec;

/**
 *  Status communicates the observed state of the Revision (from the
 *  controller).
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_RevisionStatus *status;

@end


/**
 *  RevisionSpec holds the desired state of the Revision (from the client).
 */
@interface GTLRCloudRun_RevisionSpec : GTLRObject

/**
 *  (Optional)
 *  ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
 *  requests per container instance of the Revision.
 *  Cloud Run fully managed: supported, defaults to 80
 *  Cloud Run for Anthos: supported, defaults to 0, which means concurrency
 *  to the application is not limited, and the system decides the
 *  target concurrency for the autoscaler.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *containerConcurrency;

/**
 *  Containers holds the single container that defines the unit of execution
 *  for this Revision. In the context of a Revision, we disallow a number of
 *  fields on this Container, including: name and lifecycle.
 *  In Cloud Run, only a single container may be provided.
 *  The runtime contract is documented here:
 *  https://github.com/knative/serving/blob/master/docs/runtime-contract.md
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Container *> *containers;

/**
 *  Email address of the IAM service account associated with the revision
 *  of the service. The service account represents the identity of the
 *  running revision, and determines what permissions the revision has. If
 *  not provided, the revision will use the project's default service account.
 */
@property(nonatomic, copy, nullable) NSString *serviceAccountName;

/**
 *  TimeoutSeconds holds the max duration the instance is allowed for
 *  responding to a request.
 *  Not currently used by Cloud Run.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *timeoutSeconds;

@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_Volume *> *volumes;

@end


/**
 *  RevisionStatus communicates the observed state of the Revision (from the
 *  controller).
 */
@interface GTLRCloudRun_RevisionStatus : GTLRObject

/**
 *  Conditions communicates information about ongoing/complete
 *  reconciliation processes that bring the "spec" inline with the observed
 *  state of the world.
 *  As a Revision is being prepared, it will incrementally
 *  update conditions. Revision-specific conditions include:
 *  * "ResourcesAvailable": True when underlying resources have been
 *  provisioned.
 *  * "ContainerHealthy": True when the Revision readiness check completes.
 *  * "Active": True when the Revision may receive traffic.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_GoogleCloudRunV1Condition *> *conditions;

/**
 *  ImageDigest holds the resolved digest for the image specified
 *  within .Spec.Container.Image. The digest is resolved during the creation
 *  of Revision. This field holds the digest value regardless of whether
 *  a tag or digest was originally specified in the Container object.
 */
@property(nonatomic, copy, nullable) NSString *imageDigest;

/**
 *  Specifies the generated logging url for this particular revision
 *  based on the revision url template specified in the controller's config.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *logUrl;

/**
 *  ObservedGeneration is the 'Generation' of the Revision that
 *  was last processed by the controller.
 *  Clients polling for completed reconciliation should poll until
 *  observedGeneration = metadata.generation, and the Ready condition's status
 *  is True or False.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *observedGeneration;

/** Not currently used by Cloud Run. */
@property(nonatomic, copy, nullable) NSString *serviceName;

@end


/**
 *  RevisionTemplateSpec describes the data a revision should have when created
 *  from a template. Based on:
 *  https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190
 */
@interface GTLRCloudRun_RevisionTemplate : GTLRObject

/**
 *  Optional metadata for this Revision, including labels and annotations. Name
 *  will be generated by the Configuration.
 *  To set minimum instances for this revision, use the
 *  "autoscaling.knative.dev/minScale" annotation key.
 *  To set maximum instances for this revision, use the
 *  "autoscaling.knative.dev/maxScale" annotation key.
 *  To set Cloud SQL connections for the revision, use the
 *  "run.googleapis.com/cloudsql-instances" annotation key.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** RevisionSpec holds the desired state of the Revision (from the client). */
@property(nonatomic, strong, nullable) GTLRCloudRun_RevisionSpec *spec;

@end


/**
 *  Route is responsible for configuring ingress over a collection of Revisions.
 *  Some of the Revisions a Route distributes traffic over may be specified by
 *  referencing the Configuration responsible for creating them; in these cases
 *  the Route is additionally responsible for monitoring the Configuration for
 *  "latest ready" revision changes, and smoothly rolling out latest revisions.
 *  See also:
 *  https://github.com/knative/serving/blob/master/docs/spec/overview.md#route
 *  Cloud Run currently supports referencing a single Configuration to
 *  automatically deploy the "latest ready" Revision from that Configuration.
 */
@interface GTLRCloudRun_Route : GTLRObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** The kind of this resource, in this case always "Route". */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Metadata associated with this Route, including name, namespace, labels,
 *  and annotations.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** Spec holds the desired state of the Route (from the client). */
@property(nonatomic, strong, nullable) GTLRCloudRun_RouteSpec *spec;

/**
 *  Status communicates the observed state of the Route (from the controller).
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_RouteStatus *status;

@end


/**
 *  RouteSpec holds the desired state of the Route (from the client).
 */
@interface GTLRCloudRun_RouteSpec : GTLRObject

/**
 *  Traffic specifies how to distribute traffic over a collection of Knative
 *  Revisions and Configurations.
 *  Cloud Run currently supports a single configurationName.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_TrafficTarget *> *traffic;

@end


/**
 *  RouteStatus communicates the observed state of the Route (from the
 *  controller).
 */
@interface GTLRCloudRun_RouteStatus : GTLRObject

/** Similar to url, information on where the service is available on HTTP. */
@property(nonatomic, strong, nullable) GTLRCloudRun_Addressable *address;

/**
 *  Conditions communicates information about ongoing/complete
 *  reconciliation processes that bring the "spec" inline with the observed
 *  state of the world.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_GoogleCloudRunV1Condition *> *conditions;

/**
 *  ObservedGeneration is the 'Generation' of the Route that
 *  was last processed by the controller.
 *  Clients polling for completed reconciliation should poll until
 *  observedGeneration = metadata.generation and the Ready condition's status
 *  is True or False.
 *  Note that providing a trafficTarget that only has a configurationName will
 *  result in a Route that does not increment either its metadata.generation or
 *  its observedGeneration, as new "latest ready" revisions from the
 *  Configuration are processed without an update to the Route's spec.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *observedGeneration;

/**
 *  Traffic holds the configured traffic distribution.
 *  These entries will always contain RevisionName references.
 *  When ConfigurationName appears in the spec, this will hold the
 *  LatestReadyRevisionName that we last observed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_TrafficTarget *> *traffic;

/**
 *  URL holds the url that will distribute traffic over the provided traffic
 *  targets. It generally has the form:
 *  https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  SecretEnvSource selects a Secret to populate the environment
 *  variables with.
 *  The contents of the target Secret's Data field will represent the
 *  key-value pairs as environment variables.
 */
@interface GTLRCloudRun_SecretEnvSource : GTLRObject

/**
 *  This field should not be used directly as it is meant to be inlined
 *  directly into the message. Use the "name" field instead.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_LocalObjectReference *localObjectReference;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The Secret to select from.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Specify whether the Secret must be defined
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  SecretKeySelector selects a key of a Secret.
 */
@interface GTLRCloudRun_SecretKeySelector : GTLRObject

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The key of the secret to select from. Must be a valid secret key.
 */
@property(nonatomic, copy, nullable) NSString *key;

/**
 *  This field should not be used directly as it is meant to be inlined
 *  directly into the message. Use the "name" field instead.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_LocalObjectReference *localObjectReference;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The name of the secret in the pod's namespace to select from.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Specify whether the Secret or its key must be defined
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The contents of the target Secret's Data field will be presented in a volume
 *  as files using the keys in the Data field as the file names.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCloudRun_SecretVolumeSource : GTLRCollectionObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Mode bits to use on created files by default. Must be a value between 0 and
 *  0777. Defaults to 0644. Directories within the path are not affected by
 *  this setting. This might be in conflict with other options that affect the
 *  file mode, like fsGroup, and the result can be other mode bits set.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *defaultMode;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  If unspecified, each key-value pair in the Data field of the referenced
 *  Secret will be projected into the volume as a file whose name is the
 *  key and content is the value. If specified, the listed keys will be
 *  projected into the specified paths, and unlisted keys will not be
 *  present. If a key is specified which is not present in the Secret,
 *  the volume setup will error unless it is marked optional.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_KeyToPath *> *items;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Specify whether the Secret or its keys must be defined.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Name of the secret in the container's namespace to use.
 */
@property(nonatomic, copy, nullable) NSString *secretName;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  SecurityContext holds security configuration that will be applied to a
 *  container. Some fields are present in both SecurityContext and
 *  PodSecurityContext. When both are set, the values in SecurityContext take
 *  precedence.
 */
@interface GTLRCloudRun_SecurityContext : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  The UID to run the entrypoint of the container process.
 *  Defaults to user specified in image metadata if unspecified.
 *  May also be set in PodSecurityContext. If set in both SecurityContext and
 *  PodSecurityContext, the value specified in SecurityContext takes
 *  precedence.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *runAsUser;

@end


/**
 *  Service acts as a top-level container that manages a set of Routes and
 *  Configurations which implement a network service. Service exists to provide
 *  a
 *  singular abstraction which can be access controlled, reasoned about, and
 *  which encapsulates software lifecycle decisions such as rollout policy and
 *  team resource ownership. Service acts only as an orchestrator of the
 *  underlying Routes and Configurations (much as a kubernetes Deployment
 *  orchestrates ReplicaSets).
 *  The Service's controller will track the statuses of its owned Configuration
 *  and Route, reflecting their statuses and conditions as its own.
 *  See also:
 *  https://github.com/knative/serving/blob/master/docs/spec/overview.md#service
 */
@interface GTLRCloudRun_Service : GTLRObject

/** The API version for this call such as "serving.knative.dev/v1". */
@property(nonatomic, copy, nullable) NSString *apiVersion;

/** The kind of resource, in this case "Service". */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  Metadata associated with this Service, including name, namespace, labels,
 *  and annotations.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ObjectMeta *metadata;

/** Spec holds the desired state of the Service (from the client). */
@property(nonatomic, strong, nullable) GTLRCloudRun_ServiceSpec *spec;

/**
 *  Status communicates the observed state of the Service (from the
 *  controller).
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ServiceStatus *status;

@end


/**
 *  ServiceSpec holds the desired state of the Route (from the client), which
 *  is used to manipulate the underlying Route and Configuration(s).
 */
@interface GTLRCloudRun_ServiceSpec : GTLRObject

/**
 *  Template holds the latest specification for the Revision to
 *  be stamped out.
 *
 *  Remapped to 'templateProperty' to avoid language reserved word 'template'.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_RevisionTemplate *templateProperty;

/**
 *  Traffic specifies how to distribute traffic over a collection of Knative
 *  Revisions and Configurations.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_TrafficTarget *> *traffic;

@end


/**
 *  The current state of the Service. Output only.
 */
@interface GTLRCloudRun_ServiceStatus : GTLRObject

/**
 *  From RouteStatus.
 *  Similar to url, information on where the service is available on HTTP.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Addressable *address;

/**
 *  Conditions communicates information about ongoing/complete
 *  reconciliation processes that bring the "spec" inline with the observed
 *  state of the world.
 *  Service-specific conditions include:
 *  * "ConfigurationsReady": true when the underlying Configuration is ready.
 *  * "RoutesReady": true when the underlying Route is ready.
 *  * "Ready": true when both the underlying Route and Configuration are
 *  ready.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_GoogleCloudRunV1Condition *> *conditions;

/**
 *  From ConfigurationStatus.
 *  LatestCreatedRevisionName is the last revision that was created from this
 *  Service's Configuration. It might not be ready yet, for that use
 *  LatestReadyRevisionName.
 */
@property(nonatomic, copy, nullable) NSString *latestCreatedRevisionName;

/**
 *  From ConfigurationStatus.
 *  LatestReadyRevisionName holds the name of the latest Revision stamped out
 *  from this Service's Configuration that has had its "Ready" condition become
 *  "True".
 */
@property(nonatomic, copy, nullable) NSString *latestReadyRevisionName;

/**
 *  ObservedGeneration is the 'Generation' of the Route that
 *  was last processed by the controller.
 *  Clients polling for completed reconciliation should poll until
 *  observedGeneration = metadata.generation and the Ready condition's status
 *  is True or False.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *observedGeneration;

/**
 *  From RouteStatus.
 *  Traffic holds the configured traffic distribution.
 *  These entries will always contain RevisionName references.
 *  When ConfigurationName appears in the spec, this will hold the
 *  LatestReadyRevisionName that we last observed.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_TrafficTarget *> *traffic;

/**
 *  From RouteStatus.
 *  URL holds the url that will distribute traffic over the provided traffic
 *  targets. It generally has the form
 *  https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Request message for `SetIamPolicy` method.
 */
@interface GTLRCloudRun_SetIamPolicyRequest : GTLRObject

/**
 *  REQUIRED: The complete policy to be applied to the `resource`. The size of
 *  the policy is limited to a few 10s of KB. An empty policy is a
 *  valid policy but certain Cloud Platform services (such as Projects)
 *  might reject them.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_Policy *policy;

/**
 *  OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
 *  the fields in the mask will be modified. If no mask is provided, the
 *  following default mask is used:
 *  paths: "bindings, etag"
 *  This field is only used by Cloud IAM.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

@end


/**
 *  Status is a return value for calls that don't return other objects
 */
@interface GTLRCloudRun_Status : GTLRObject

/**
 *  Suggested HTTP return code for this status, 0 if not set.
 *  +optional
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  Extended data associated with the reason. Each reason may define its
 *  own extended details. This field is optional and the data returned
 *  is not guaranteed to conform to any schema except that defined by
 *  the reason type.
 *  +optional
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_StatusDetails *details;

/**
 *  A human-readable description of the status of this operation.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  Standard list metadata.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
 *  +optional
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ListMeta *metadata;

/**
 *  A machine-readable description of why this operation is in the
 *  "Failure" status. If this value is empty there
 *  is no information available. A Reason clarifies an HTTP status
 *  code but does not override it.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *reason;

/**
 *  Status of the operation.
 *  One of: "Success" or "Failure".
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *status;

@end


/**
 *  StatusCause provides more information about an api.Status failure, including
 *  cases when multiple errors are encountered.
 */
@interface GTLRCloudRun_StatusCause : GTLRObject

/**
 *  The field of the resource that has caused this error, as named by its JSON
 *  serialization. May include dot and postfix notation for nested attributes.
 *  Arrays are zero-indexed. Fields may appear more than once in an array of
 *  causes due to fields having multiple errors.
 *  Optional.
 *  Examples:
 *  "name" - the field "name" on the current resource
 *  "items[0].name" - the field "name" on the first array entry in "items"
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *field;

/**
 *  A human-readable description of the cause of the error. This field may be
 *  presented as-is to a reader.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *message;

/**
 *  A machine-readable description of the cause of the error. If this value is
 *  empty there is no information available.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *reason;

@end


/**
 *  StatusDetails is a set of additional properties that MAY be set by the
 *  server to provide additional information about a response. The Reason
 *  field of a Status object defines what attributes will be set. Clients
 *  must ignore fields that do not match the defined type of each attribute,
 *  and should assume that any attribute may be empty, invalid, or under
 *  defined.
 */
@interface GTLRCloudRun_StatusDetails : GTLRObject

/**
 *  The Causes array includes more details associated with the StatusReason
 *  failure. Not all StatusReasons may provide detailed causes.
 *  +optional
 */
@property(nonatomic, strong, nullable) NSArray<GTLRCloudRun_StatusCause *> *causes;

/**
 *  The group attribute of the resource associated with the status
 *  StatusReason. +optional
 */
@property(nonatomic, copy, nullable) NSString *group;

/**
 *  The kind attribute of the resource associated with the status StatusReason.
 *  On some operations may differ from the requested resource Kind.
 *  More info:
 *  https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *kind;

/**
 *  The name attribute of the resource associated with the status StatusReason
 *  (when there is a single name which can be described).
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  If specified, the time in seconds before the operation should be retried.
 *  Some errors may indicate the client must take an alternate action - for
 *  those errors this field may indicate how long to wait before taking the
 *  alternate action. +optional
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *retryAfterSeconds;

/**
 *  UID of the resource.
 *  (when there is a single resource which can be described).
 *  More info: http://kubernetes.io/docs/user-guide/identifiers#uids
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *uid;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  TCPSocketAction describes an action based on opening a socket
 */
@interface GTLRCloudRun_TCPSocketAction : GTLRObject

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Optional: Host name to connect to, defaults to the pod IP.
 */
@property(nonatomic, copy, nullable) NSString *host;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Number or name of the port to access on the container.
 *  Number must be in the range 1 to 65535.
 *  Name must be an IANA_SVC_NAME.
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_IntOrString *port;

@end


/**
 *  Request message for `TestIamPermissions` method.
 */
@interface GTLRCloudRun_TestIamPermissionsRequest : GTLRObject

/**
 *  The set of permissions to check for the `resource`. Permissions with
 *  wildcards (such as '*' or 'storage.*') are not allowed. For more
 *  information see
 *  [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  Response message for `TestIamPermissions` method.
 */
@interface GTLRCloudRun_TestIamPermissionsResponse : GTLRObject

/**
 *  A subset of `TestPermissionsRequest.permissions` that the caller is
 *  allowed.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *permissions;

@end


/**
 *  TrafficTarget holds a single entry of the routing table for a Route.
 */
@interface GTLRCloudRun_TrafficTarget : GTLRObject

/**
 *  ConfigurationName of a configuration to whose latest revision we will
 *  send this portion of traffic. When the "status.latestReadyRevisionName"
 *  of the referenced configuration changes, we will automatically migrate
 *  traffic from the prior "latest ready" revision to the new one. This field
 *  is never set in Route's status, only its spec. This is mutually exclusive
 *  with RevisionName.
 *  Cloud Run currently supports a single ConfigurationName.
 */
@property(nonatomic, copy, nullable) NSString *configurationName;

/**
 *  LatestRevision may be optionally provided to indicate that the latest
 *  ready Revision of the Configuration should be used for this traffic
 *  target. When provided LatestRevision must be true if RevisionName is
 *  empty; it must be false when RevisionName is non-empty.
 *  +optional
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *latestRevision;

/**
 *  Percent specifies percent of the traffic to this Revision or Configuration.
 *  This defaults to zero if unspecified.
 *  Cloud Run currently requires 100 percent for a single ConfigurationName
 *  TrafficTarget entry.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *percent;

/**
 *  RevisionName of a specific revision to which to send this portion of
 *  traffic. This is mutually exclusive with ConfigurationName.
 *  Providing RevisionName in spec is not currently supported by Cloud Run.
 */
@property(nonatomic, copy, nullable) NSString *revisionName;

/**
 *  Tag is optionally used to expose a dedicated url for referencing
 *  this target exclusively.
 *  Not currently supported in Cloud Run.
 *  +optional
 */
@property(nonatomic, copy, nullable) NSString *tag;

/**
 *  Output only. URL displays the URL for accessing tagged traffic targets. URL
 *  is displayed in status, and is disallowed on spec. URL must contain a
 *  scheme (e.g. http://) and a hostname, but may not contain anything else
 *  (e.g. basic auth, url path, etc.
 *  Not currently supported in Cloud Run.
 */
@property(nonatomic, copy, nullable) NSString *url;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Volume represents a named volume in a container.
 */
@interface GTLRCloudRun_Volume : GTLRObject

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_ConfigMapVolumeSource *configMap;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Volume's name.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 */
@property(nonatomic, strong, nullable) GTLRCloudRun_SecretVolumeSource *secret;

@end


/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  VolumeMount describes a mounting of a Volume within a container.
 */
@interface GTLRCloudRun_VolumeMount : GTLRObject

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Path within the container at which the volume should be mounted. Must
 *  not contain ':'.
 */
@property(nonatomic, copy, nullable) NSString *mountPath;

/**
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  This must match the Name of a Volume.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Only true is accepted.
 *  Defaults to true.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *readOnly;

/**
 *  (Optional)
 *  Cloud Run fully managed: not supported
 *  Cloud Run for Anthos: supported
 *  Path within the volume from which the container's volume should be mounted.
 *  Defaults to "" (volume's root).
 */
@property(nonatomic, copy, nullable) NSString *subPath;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
