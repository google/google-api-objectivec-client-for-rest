// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Fitness API (fitness/v1)
// Description:
//   The Fitness API for managing users' fitness tracking data.
// Documentation:
//   https://developers.google.com/fit/rest/v1/get-started

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRFitness_AggregateBucket;
@class GTLRFitness_AggregateBy;
@class GTLRFitness_Application;
@class GTLRFitness_BucketByActivity;
@class GTLRFitness_BucketBySession;
@class GTLRFitness_BucketByTime;
@class GTLRFitness_BucketByTimePeriod;
@class GTLRFitness_DataPoint;
@class GTLRFitness_Dataset;
@class GTLRFitness_DataSource;
@class GTLRFitness_DataType;
@class GTLRFitness_DataTypeField;
@class GTLRFitness_Device;
@class GTLRFitness_MapValue;
@class GTLRFitness_Session;
@class GTLRFitness_Value;
@class GTLRFitness_ValueMapValEntry;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRFitness_AggregateBucket.type

/**
 *  Denotes that bucketing by individual activity segment is requested. This
 *  will aggregate data by the time boundaries specified by each activity
 *  segment occurring within the dataset time frame of interest.
 *
 *  Value: "activitySegment"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateBucket_Type_ActivitySegment;
/**
 *  Denotes that bucketing by activity type is requested. When this is
 *  specified, there will be one bucket for each unique activity type that
 *  a user participated in, during the dataset time frame of interest.
 *
 *  Value: "activityType"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateBucket_Type_ActivityType;
/**
 *  Denotes that bucketing by session is requested. When this is specified,
 *  only data that occurs within sessions that begin and end within the
 *  dataset time frame, is included in the results.
 *
 *  Value: "session"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateBucket_Type_Session;
/**
 *  Denotes that bucketing by time is requested. When this is specified, the
 *  timeBucketDurationMillis field is used to determine how many buckets will
 *  be returned.
 *
 *  Value: "time"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateBucket_Type_Time;
/** Value: "unknown" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateBucket_Type_Unknown;

// ----------------------------------------------------------------------------
// GTLRFitness_AggregateRequest.filteredDataQualityStandard

/** Value: "dataQualityBloodGlucoseIso151972003" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodGlucoseIso151972003;
/** Value: "dataQualityBloodGlucoseIso151972013" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodGlucoseIso151972013;
/** Value: "dataQualityBloodPressureAami" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureAami;
/** Value: "dataQualityBloodPressureBhsAA" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureBhsAA;
/** Value: "dataQualityBloodPressureBhsAB" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureBhsAB;
/** Value: "dataQualityBloodPressureBhsBA" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureBhsBA;
/** Value: "dataQualityBloodPressureBhsBB" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureBhsBB;
/** Value: "dataQualityBloodPressureEsh2002" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureEsh2002;
/** Value: "dataQualityBloodPressureEsh2010" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityBloodPressureEsh2010;
/** Value: "dataQualityUnknown" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_AggregateRequest_FilteredDataQualityStandard_DataQualityUnknown;

// ----------------------------------------------------------------------------
// GTLRFitness_BucketByTimePeriod.type

/** Value: "day" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_BucketByTimePeriod_Type_Day;
/** Value: "month" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_BucketByTimePeriod_Type_Month;
/** Value: "week" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_BucketByTimePeriod_Type_Week;

// ----------------------------------------------------------------------------
// GTLRFitness_DataSource.dataQualityStandard

/** Value: "dataQualityBloodGlucoseIso151972003" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodGlucoseIso151972003;
/** Value: "dataQualityBloodGlucoseIso151972013" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodGlucoseIso151972013;
/** Value: "dataQualityBloodPressureAami" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureAami;
/** Value: "dataQualityBloodPressureBhsAA" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureBhsAA;
/** Value: "dataQualityBloodPressureBhsAB" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureBhsAB;
/** Value: "dataQualityBloodPressureBhsBA" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureBhsBA;
/** Value: "dataQualityBloodPressureBhsBB" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureBhsBB;
/** Value: "dataQualityBloodPressureEsh2002" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureEsh2002;
/** Value: "dataQualityBloodPressureEsh2010" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityBloodPressureEsh2010;
/** Value: "dataQualityUnknown" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_DataQualityStandard_DataQualityUnknown;

// ----------------------------------------------------------------------------
// GTLRFitness_DataSource.type

/** Value: "derived" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_Type_Derived;
/** Value: "raw" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataSource_Type_Raw;

// ----------------------------------------------------------------------------
// GTLRFitness_DataTypeField.format

/** Value: "blob" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_Blob;
/** Value: "floatList" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_FloatList;
/** Value: "floatPoint" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_FloatPoint;
/** Value: "integer" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_Integer;
/** Value: "integerList" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_IntegerList;
/** Value: "map" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_Map;
/** Value: "string" */
FOUNDATION_EXTERN NSString * const kGTLRFitness_DataTypeField_Format_String;

// ----------------------------------------------------------------------------
// GTLRFitness_Device.type

/**
 *  A chest strap.
 *
 *  Value: "chestStrap"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_ChestStrap;
/**
 *  Glass or other head-mounted device.
 *
 *  Value: "headMounted"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_HeadMounted;
/**
 *  An Android phone.
 *
 *  Value: "phone"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_Phone;
/**
 *  A scale.
 *
 *  Value: "scale"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_Scale;
/**
 *  An Android tablet.
 *
 *  Value: "tablet"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_Tablet;
/**
 *  Device type is not known.
 *
 *  Value: "unknown"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_Unknown;
/**
 *  A watch or other wrist-mounted band.
 *
 *  Value: "watch"
 */
FOUNDATION_EXTERN NSString * const kGTLRFitness_Device_Type_Watch;

/**
 *  GTLRFitness_AggregateBucket
 */
@interface GTLRFitness_AggregateBucket : GTLRObject

/**
 *  Available for Bucket.Type.ACTIVITY_TYPE, Bucket.Type.ACTIVITY_SEGMENT
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *activity;

/** There will be one dataset per AggregateBy in the request. */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_Dataset *> *dataset;

/**
 *  The end time for the aggregated data, in milliseconds since epoch,
 *  inclusive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endTimeMillis;

/** Available for Bucket.Type.SESSION */
@property(nonatomic, strong, nullable) GTLRFitness_Session *session;

/**
 *  The start time for the aggregated data, in milliseconds since epoch,
 *  inclusive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startTimeMillis;

/**
 *  The type of a bucket signifies how the data aggregation is performed in the
 *  bucket.
 *
 *  Likely values:
 *    @arg @c kGTLRFitness_AggregateBucket_Type_ActivitySegment Denotes that
 *        bucketing by individual activity segment is requested. This
 *        will aggregate data by the time boundaries specified by each activity
 *        segment occurring within the dataset time frame of interest. (Value:
 *        "activitySegment")
 *    @arg @c kGTLRFitness_AggregateBucket_Type_ActivityType Denotes that
 *        bucketing by activity type is requested. When this is
 *        specified, there will be one bucket for each unique activity type that
 *        a user participated in, during the dataset time frame of interest.
 *        (Value: "activityType")
 *    @arg @c kGTLRFitness_AggregateBucket_Type_Session Denotes that bucketing
 *        by session is requested. When this is specified,
 *        only data that occurs within sessions that begin and end within the
 *        dataset time frame, is included in the results. (Value: "session")
 *    @arg @c kGTLRFitness_AggregateBucket_Type_Time Denotes that bucketing by
 *        time is requested. When this is specified, the
 *        timeBucketDurationMillis field is used to determine how many buckets
 *        will
 *        be returned. (Value: "time")
 *    @arg @c kGTLRFitness_AggregateBucket_Type_Unknown Value "unknown"
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  The specification of which data to aggregate.
 */
@interface GTLRFitness_AggregateBy : GTLRObject

/**
 *  A data source ID to aggregate. Only data from the specified data source ID
 *  will be included in the aggregation. If specified, this data source must
 *  exist; the OAuth scopes in the supplied credentials must grant read access
 *  to this data type. The dataset in the response will have the same data
 *  source ID. Note: Data can be aggregated by either the dataTypeName or the
 *  dataSourceId, not both.
 */
@property(nonatomic, copy, nullable) NSString *dataSourceId;

/**
 *  The data type to aggregate. All data sources providing this data type will
 *  contribute data to the aggregation. The response will contain a single
 *  dataset for this data type name. The dataset will have a data source ID of
 *  derived:<output data type name>:com.google.android.gms:aggregated.
 *  If the user has no data for this data type, an empty data set will be
 *  returned. Note: Data can be aggregated by either the dataTypeName or the
 *  dataSourceId, not both.
 */
@property(nonatomic, copy, nullable) NSString *dataTypeName;

@end


/**
 *  Next id: 10
 */
@interface GTLRFitness_AggregateRequest : GTLRObject

/**
 *  The specification of data to be aggregated. At least one aggregateBy spec
 *  must be provided. All data that is specified will be aggregated using the
 *  same bucketing criteria. There will be one dataset in the response for
 *  every aggregateBy spec.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_AggregateBy *> *aggregateBy;

/**
 *  Specifies that data be aggregated each activity segment recored for a user.
 *  Similar to bucketByActivitySegment, but bucketing is done for each activity
 *  segment rather than all segments of the same type. Mutually exclusive of
 *  other bucketing specifications.
 */
@property(nonatomic, strong, nullable) GTLRFitness_BucketByActivity *bucketByActivitySegment;

/**
 *  Specifies that data be aggregated by the type of activity being performed
 *  when the data was recorded. All data that was recorded during a certain
 *  activity type (for the given time range) will be aggregated into the same
 *  bucket. Data that was recorded while the user was not active will not be
 *  included in the response. Mutually exclusive of other bucketing
 *  specifications.
 */
@property(nonatomic, strong, nullable) GTLRFitness_BucketByActivity *bucketByActivityType;

/**
 *  Specifies that data be aggregated by user sessions. Data that does not fall
 *  within the time range of a session will not be included in the response.
 *  Mutually exclusive of other bucketing specifications.
 */
@property(nonatomic, strong, nullable) GTLRFitness_BucketBySession *bucketBySession;

/**
 *  Specifies that data be aggregated by a single time interval. Mutually
 *  exclusive of other bucketing specifications.
 */
@property(nonatomic, strong, nullable) GTLRFitness_BucketByTime *bucketByTime;

/**
 *  The end of a window of time. Data that intersects with this time
 *  window will be aggregated. The time is in milliseconds since epoch,
 *  inclusive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endTimeMillis;

/** DO NOT POPULATE THIS FIELD. It is ignored. */
@property(nonatomic, strong, nullable) NSArray<NSString *> *filteredDataQualityStandard;

/**
 *  The start of a window of time. Data that intersects with this time
 *  window will be aggregated. The time is in milliseconds since epoch,
 *  inclusive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startTimeMillis;

@end


/**
 *  GTLRFitness_AggregateResponse
 */
@interface GTLRFitness_AggregateResponse : GTLRObject

/** A list of buckets containing the aggregated data. */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_AggregateBucket *> *bucket;

@end


/**
 *  GTLRFitness_Application
 */
@interface GTLRFitness_Application : GTLRObject

/** An optional URI that can be used to link back to the application. */
@property(nonatomic, copy, nullable) NSString *detailsUrl;

/**
 *  The name of this application. This is required for REST clients, but we
 *  do not enforce uniqueness of this name. It is provided as a matter of
 *  convenience for other developers who would like to identify which REST
 *  created an Application or Data Source.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Package name for this application. This is used as a unique
 *  identifier when created by Android applications, but cannot be specified
 *  by REST clients. REST clients will have their developer project number
 *  reflected into the Data Source data stream IDs, instead of the packageName.
 */
@property(nonatomic, copy, nullable) NSString *packageName;

/**
 *  Version of the application. You should update this field whenever the
 *  application changes in a way that affects the computation of the data.
 */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  GTLRFitness_BucketByActivity
 */
@interface GTLRFitness_BucketByActivity : GTLRObject

/**
 *  The default activity stream will be used if a specific activityDataSourceId
 *  is not specified.
 */
@property(nonatomic, copy, nullable) NSString *activityDataSourceId;

/**
 *  Specifies that only activity segments of duration longer than
 *  minDurationMillis are considered and used as a container for aggregated
 *  data.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minDurationMillis;

@end


/**
 *  GTLRFitness_BucketBySession
 */
@interface GTLRFitness_BucketBySession : GTLRObject

/**
 *  Specifies that only sessions of duration longer than minDurationMillis are
 *  considered and used as a container for aggregated data.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minDurationMillis;

@end


/**
 *  GTLRFitness_BucketByTime
 */
@interface GTLRFitness_BucketByTime : GTLRObject

/**
 *  Specifies that result buckets aggregate data by exactly durationMillis time
 *  frames. Time frames that contain no data will be included in the response
 *  with an empty dataset.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *durationMillis;

@property(nonatomic, strong, nullable) GTLRFitness_BucketByTimePeriod *period;

@end


/**
 *  GTLRFitness_BucketByTimePeriod
 */
@interface GTLRFitness_BucketByTimePeriod : GTLRObject

/** org.joda.timezone.DateTimeZone */
@property(nonatomic, copy, nullable) NSString *timeZoneId;

/**
 *  type
 *
 *  Likely values:
 *    @arg @c kGTLRFitness_BucketByTimePeriod_Type_Day Value "day"
 *    @arg @c kGTLRFitness_BucketByTimePeriod_Type_Month Value "month"
 *    @arg @c kGTLRFitness_BucketByTimePeriod_Type_Week Value "week"
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  value
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *value;

@end


/**
 *  Represents a single data point, generated by a particular data source. A
 *  data point holds a value for each field, an end timestamp and an optional
 *  start time. The exact semantics of each of these attributes are specified in
 *  the documentation for the particular data type.
 *  A data point can represent an instantaneous measurement, reading or input
 *  observation, as well as averages or aggregates over a time interval. Check
 *  the data type documentation to determine which is the case for a particular
 *  data type.
 *  Data points always contain one value for each field of the data type.
 */
@interface GTLRFitness_DataPoint : GTLRObject

/**
 *  DO NOT USE THIS FIELD. It is ignored, and not stored.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *computationTimeMillis;

/** The data type defining the format of the values in this data point. */
@property(nonatomic, copy, nullable) NSString *dataTypeName;

/**
 *  The end time of the interval represented by this data point, in
 *  nanoseconds since epoch.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endTimeNanos;

/**
 *  Indicates the last time this data point was modified. Useful only in
 *  contexts where we are listing the data changes, rather than representing
 *  the current state of the data.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *modifiedTimeMillis;

/**
 *  If the data point is contained in a dataset for a derived data source,
 *  this field will be populated with the data source stream ID that created
 *  the data point originally.
 *  WARNING: do not rely on this field for anything other than debugging. The
 *  value of this field, if it is set at all, is an implementation detail and
 *  is not guaranteed to remain consistent.
 */
@property(nonatomic, copy, nullable) NSString *originDataSourceId;

/**
 *  The raw timestamp from the original SensorEvent.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *rawTimestampNanos;

/**
 *  The start time of the interval represented by this data point, in
 *  nanoseconds since epoch.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startTimeNanos;

/**
 *  Values of each data type field for the data point. It is expected that each
 *  value corresponding to a data type field will occur in the same order that
 *  the field is listed with in the data type specified in a data source.
 *  Only one of integer and floating point fields will be populated, depending
 *  on the format enum value within data source's type field.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_Value *> *value;

@end


/**
 *  A dataset represents a projection container for data points. They do not
 *  carry any info of their own. Datasets represent a set of data points from a
 *  particular data source. A data point can be found in more than one dataset.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "point" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRFitness_Dataset : GTLRCollectionObject

/**
 *  The data stream ID of the data source that created the points in this
 *  dataset.
 */
@property(nonatomic, copy, nullable) NSString *dataSourceId;

/**
 *  The largest end time of all data points in this possibly partial
 *  representation of the dataset. Time is in nanoseconds from epoch. This
 *  should also match the second part of the dataset identifier.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maxEndTimeNs;

/**
 *  The smallest start time of all data points in this possibly partial
 *  representation of the dataset. Time is in nanoseconds from epoch. This
 *  should also match the first part of the dataset identifier.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minStartTimeNs;

/**
 *  This token will be set when a dataset is received in response to a GET
 *  request and the dataset is too large to be included in a single response.
 *  Provide this value in a subsequent GET request to return the next page of
 *  data points within this dataset.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  A partial list of data points contained in the dataset, ordered by largest
 *  endTimeNanos first. This list is considered complete when retrieving a
 *  small dataset and partial when patching a dataset or retrieving a dataset
 *  that is too large to include in a single response.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_DataPoint *> *point;

@end


/**
 *  Definition of a unique source of sensor data. Data sources can expose raw
 *  data coming from hardware sensors on local or companion devices. They can
 *  also expose derived data, created by transforming or merging other data
 *  sources. Multiple data sources can exist for the same data type. Every data
 *  point inserted into or read from this service has an associated data
 *  source.
 *  The data source contains enough information to uniquely identify its data,
 *  including the hardware device and the application that collected and/or
 *  transformed the data. It also holds useful metadata, such as the hardware
 *  and
 *  application versions, and the device type.
 *  Each data source produces a unique stream of data, with a unique identifier.
 *  Not all changes to data source affect the stream identifier, so that data
 *  collected by updated versions of the same application/device can still be
 *  considered to belong to the same data stream.
 */
@interface GTLRFitness_DataSource : GTLRObject

/**
 *  Information about an application which feeds sensor data into the platform.
 */
@property(nonatomic, strong, nullable) GTLRFitness_Application *application;

/**
 *  DO NOT POPULATE THIS FIELD. It is never populated in responses from the
 *  platform, and is ignored in queries. It will be removed in a future version
 *  entirely.
 */
@property(nonatomic, strong, nullable) NSArray<NSString *> *dataQualityStandard;

/**
 *  A unique identifier for the data stream produced by this data source. The
 *  identifier includes:<br/><br/>
 *  <ul>
 *  <li>The physical device's manufacturer, model, and serial number
 *  (UID).</li>
 *  <li>The application's package name or name. Package name is used when the
 *  data source was created by an Android application. The developer project
 *  number is used when the data source was created by a REST client.</li>
 *  <li>The data source's type.</li>
 *  <li>The data source's stream name.</li>
 *  </ul>
 *  Note that not all attributes of the data source are used as part of the
 *  stream identifier. In particular, the version of the hardware/the
 *  application isn't used. This allows us to preserve the same stream through
 *  version updates. This also means that two DataSource objects may represent
 *  the same data stream even if they're not equal.
 *  The exact format of the data stream ID created by an Android application
 *  is:
 *  <var>type:dataType.name<wbr/>:application.packageName<wbr/>:device.manufacturer<wbr/>:device.model<wbr/>:device.uid<wbr/>:dataStreamName</var>
 *  The exact format of the data stream ID created by a REST client is:
 *  <var>type:dataType.name<wbr/>:developer project
 *  number<wbr/>:device.manufacturer<wbr/>:device.model:device.uid<wbr/>:dataStreamName</var>
 *  When any of the optional fields that make up the data stream ID are absent,
 *  they will be omitted from the data stream ID. The minimum viable data
 *  stream ID would be:
 *  type:dataType.name:developer project number
 *  Finally, the developer project number and device UID are obfuscated when
 *  read by any REST or Android client that did not create the data source.
 *  Only the data source creator will see the developer project number in clear
 *  and normal form. This means a client will see a different set of
 *  data_stream_ids than another client with different credentials.
 */
@property(nonatomic, copy, nullable) NSString *dataStreamId;

/**
 *  The stream name uniquely identifies this particular data source among
 *  other data sources of the same type from the same underlying producer.
 *  Setting the stream name is optional, but should be done whenever an
 *  application exposes two streams for the same data type, or when a device
 *  has two equivalent sensors.
 */
@property(nonatomic, copy, nullable) NSString *dataStreamName;

/**
 *  The data type defines the schema for a stream of data being collected by,
 *  inserted into, or queried from the Fitness API.
 */
@property(nonatomic, strong, nullable) GTLRFitness_DataType *dataType;

/**
 *  Representation of an integrated device (such as a phone or a wearable) that
 *  can hold sensors.
 */
@property(nonatomic, strong, nullable) GTLRFitness_Device *device;

/** An end-user visible name for this data source. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A constant describing the type of this data source. Indicates whether this
 *  data source produces raw or derived data.
 *
 *  Likely values:
 *    @arg @c kGTLRFitness_DataSource_Type_Derived Value "derived"
 *    @arg @c kGTLRFitness_DataSource_Type_Raw Value "raw"
 */
@property(nonatomic, copy, nullable) NSString *type;

@end


/**
 *  GTLRFitness_DataType
 */
@interface GTLRFitness_DataType : GTLRObject

/** A field represents one dimension of a data type. */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_DataTypeField *> *field;

/**
 *  Each data type has a unique, namespaced, name. All data types in the
 *  com.google namespace are shared as part of the platform.
 */
@property(nonatomic, copy, nullable) NSString *name;

@end


/**
 *  In case of multi-dimensional data (such as an accelerometer with x, y, and z
 *  axes) each field represents one dimension. Each data type field has a unique
 *  name which identifies it. The field also defines the format of the data
 *  (int,
 *  float, etc.).
 *  This message is only instantiated in code and not used for wire comms or
 *  stored in any way.
 */
@interface GTLRFitness_DataTypeField : GTLRObject

/**
 *  The different supported formats for each field in a data type.
 *
 *  Likely values:
 *    @arg @c kGTLRFitness_DataTypeField_Format_Blob Value "blob"
 *    @arg @c kGTLRFitness_DataTypeField_Format_FloatList Value "floatList"
 *    @arg @c kGTLRFitness_DataTypeField_Format_FloatPoint Value "floatPoint"
 *    @arg @c kGTLRFitness_DataTypeField_Format_Integer Value "integer"
 *    @arg @c kGTLRFitness_DataTypeField_Format_IntegerList Value "integerList"
 *    @arg @c kGTLRFitness_DataTypeField_Format_Map Value "map"
 *    @arg @c kGTLRFitness_DataTypeField_Format_String Value "string"
 */
@property(nonatomic, copy, nullable) NSString *format;

/**
 *  Defines the name and format of data. Unlike data type names, field names
 *  are not namespaced, and only need to be unique within the data type.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  optional
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *optional;

@end


/**
 *  Representation of an integrated device (such as a phone or a wearable) that
 *  can hold sensors. Each sensor is exposed as a data source.
 *  The main purpose of the device information contained in this class is to
 *  identify the hardware of a particular data source. This can be useful in
 *  different ways, including:
 *  <ul>
 *  <li>Distinguishing two similar sensors on different devices (the step
 *  counter on two nexus 5 phones, for instance)
 *  <li>Display the source of data to the user (by using the device make /
 *  model)
 *  <li>Treat data differently depending on sensor type (accelerometers on a
 *  watch may give different patterns than those on a phone)
 *  <li>Build different analysis models for each device/version.
 *  </ul>
 */
@interface GTLRFitness_Device : GTLRObject

/** Manufacturer of the product/hardware. */
@property(nonatomic, copy, nullable) NSString *manufacturer;

/** End-user visible model name for the device. */
@property(nonatomic, copy, nullable) NSString *model;

/**
 *  A constant representing the type of the device.
 *
 *  Likely values:
 *    @arg @c kGTLRFitness_Device_Type_ChestStrap A chest strap. (Value:
 *        "chestStrap")
 *    @arg @c kGTLRFitness_Device_Type_HeadMounted Glass or other head-mounted
 *        device. (Value: "headMounted")
 *    @arg @c kGTLRFitness_Device_Type_Phone An Android phone. (Value: "phone")
 *    @arg @c kGTLRFitness_Device_Type_Scale A scale. (Value: "scale")
 *    @arg @c kGTLRFitness_Device_Type_Tablet An Android tablet. (Value:
 *        "tablet")
 *    @arg @c kGTLRFitness_Device_Type_Unknown Device type is not known. (Value:
 *        "unknown")
 *    @arg @c kGTLRFitness_Device_Type_Watch A watch or other wrist-mounted
 *        band. (Value: "watch")
 */
@property(nonatomic, copy, nullable) NSString *type;

/**
 *  The serial number or other unique ID for the hardware. This field is
 *  obfuscated when read by any REST or Android client that did not create
 *  the data source. Only the data source creator will see the uid field in
 *  clear and normal form.
 *  The obfuscation preserves equality; that is, given two IDs, if id1 == id2,
 *  obfuscated(id1) == obfuscated(id2).
 */
@property(nonatomic, copy, nullable) NSString *uid;

/** Version string for the device hardware/software. */
@property(nonatomic, copy, nullable) NSString *version;

@end


/**
 *  GTLRFitness_ListDataPointChangesResponse
 */
@interface GTLRFitness_ListDataPointChangesResponse : GTLRObject

/** The data stream ID of the data source with data point changes. */
@property(nonatomic, copy, nullable) NSString *dataSourceId;

/**
 *  Deleted data points for the user. Note, for modifications this should be
 *  parsed before handling insertions.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_DataPoint *> *deletedDataPoint;

/** Inserted data points for the user. */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_DataPoint *> *insertedDataPoint;

/**
 *  The continuation token, which is used to page through large result sets.
 *  Provide this value in a subsequent request to return the next page of
 *  results.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

@end


/**
 *  GTLRFitness_ListDataSourcesResponse
 */
@interface GTLRFitness_ListDataSourcesResponse : GTLRObject

/** A previously created data source. */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_DataSource *> *dataSource;

@end


/**
 *  GTLRFitness_ListSessionsResponse
 */
@interface GTLRFitness_ListSessionsResponse : GTLRObject

/**
 *  If <code>includeDeleted</code> is set to true in the request, and
 *  <var>startTime</var> and <var>endTime</var> are omitted, this will include
 *  sessions which were deleted since the last sync.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_Session *> *deletedSession;

/**
 *  Flag to indicate server has more data to transfer.
 *  DO NOT USE THIS FIELD. It is never populated in responses from the server.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *hasMoreData;

/**
 *  The sync token which is used to sync further changes. This will only be
 *  provided if both <var>startTime</var> and <var>endTime</var> are omitted
 *  from the request.
 */
@property(nonatomic, copy, nullable) NSString *nextPageToken;

/**
 *  Sessions with an end time that is between <var>startTime</var> and
 *  <var>endTime</var> of the request.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_Session *> *session;

@end


/**
 *  Holder object for the value of an entry in a map field of a data point.
 *  A map value supports a subset of the formats that the regular Value
 *  supports.
 */
@interface GTLRFitness_MapValue : GTLRObject

/**
 *  Floating point value.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fpVal;

@end


/**
 *  Sessions contain metadata, such as a user-friendly name and time interval
 *  information.
 */
@interface GTLRFitness_Session : GTLRObject

/**
 *  Session active time. While start_time_millis and end_time_millis define
 *  the full session time, the active time can be shorter and specified by
 *  active_time_millis.
 *  If the inactive time during the session is known, it should also be
 *  inserted via a com.google.activity.segment data point with a STILL
 *  activity value
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *activeTimeMillis;

/**
 *  The type of activity this session represents.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *activityType;

/** The application that created the session. */
@property(nonatomic, strong, nullable) GTLRFitness_Application *application;

/**
 *  A description for this session.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(nonatomic, copy, nullable) NSString *descriptionProperty;

/**
 *  An end time, in milliseconds since epoch, inclusive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *endTimeMillis;

/**
 *  A client-generated identifier that is unique across all sessions owned by
 *  this particular user.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(nonatomic, copy, nullable) NSString *identifier;

/**
 *  A timestamp that indicates when the session was last modified.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *modifiedTimeMillis;

/** A human readable name of the session. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  A start time, in milliseconds since epoch, inclusive.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *startTimeMillis;

@end


/**
 *  Holder object for the value of a single field in a data point.
 *  A field value has a particular format and is only ever set to one of an
 *  integer or a floating point value.
 */
@interface GTLRFitness_Value : GTLRObject

/**
 *  Floating point value. When this is set, other values must not be set.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *fpVal;

/**
 *  Integer value. When this is set, other values must not be set.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *intVal;

/**
 *  Map value. The valid key space and units for the corresponding value
 *  of each entry should be documented as part of the data type definition.
 *  Keys should be kept small whenever possible. Data streams with large keys
 *  and high data frequency may be down sampled.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRFitness_ValueMapValEntry *> *mapVal;

/**
 *  String value. When this is set, other values must not be set.
 *  Strings should be kept small whenever possible. Data streams with large
 *  string values and high data frequency may be down sampled.
 */
@property(nonatomic, copy, nullable) NSString *stringVal;

@end


/**
 *  GTLRFitness_ValueMapValEntry
 */
@interface GTLRFitness_ValueMapValEntry : GTLRObject

@property(nonatomic, copy, nullable) NSString *key;
@property(nonatomic, strong, nullable) GTLRFitness_MapValue *value;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
