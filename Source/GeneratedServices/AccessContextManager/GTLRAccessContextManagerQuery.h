// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Access Context Manager API (accesscontextmanager/v1)
// Description:
//   An API for setting attribute based access control to requests to GCP
//   services.
// Documentation:
//   https://cloud.google.com/access-context-manager/docs/reference/rest/

#if SWIFT_PACKAGE || GTLR_USE_MODULAR_IMPORT
  @import GoogleAPIClientForRESTCore;
#elif GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRQuery.h"
#else
  #import "GTLRQuery.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRAccessContextManager_AccessLevel;
@class GTLRAccessContextManager_AccessPolicy;
@class GTLRAccessContextManager_CancelOperationRequest;
@class GTLRAccessContextManager_CommitServicePerimetersRequest;
@class GTLRAccessContextManager_GcpUserAccessBinding;
@class GTLRAccessContextManager_ReplaceAccessLevelsRequest;
@class GTLRAccessContextManager_ReplaceServicePerimetersRequest;
@class GTLRAccessContextManager_ServicePerimeter;

// Generated comments include content from the discovery document; avoid them
// causing warnings since clang's checks are some what arbitrary.
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the query classes' properties below.

// ----------------------------------------------------------------------------
// accessLevelFormat

/**
 *  Uses the format the resource was defined in. BasicLevels are returned as
 *  BasicLevels, CustomLevels are returned as CustomLevels.
 *
 *  Value: "AS_DEFINED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAccessContextManagerAccessLevelFormatAsDefined;
/**
 *  Use Cloud Common Expression Language when returning the resource. Both
 *  BasicLevels and CustomLevels are returned as CustomLevels.
 *
 *  Value: "CEL"
 */
FOUNDATION_EXTERN NSString * const kGTLRAccessContextManagerAccessLevelFormatCel;
/**
 *  The format was not specified.
 *
 *  Value: "LEVEL_FORMAT_UNSPECIFIED"
 */
FOUNDATION_EXTERN NSString * const kGTLRAccessContextManagerAccessLevelFormatLevelFormatUnspecified;

// ----------------------------------------------------------------------------
// Query Classes
//

/**
 *  Parent class for other Access Context Manager query classes.
 */
@interface GTLRAccessContextManagerQuery : GTLRQuery

/** Selector specifying which fields to include in a partial response. */
@property(nonatomic, copy, nullable) NSString *fields;

@end

/**
 *  Create an Access Level. The longrunning operation from this RPC will have a
 *  successful status once the Access Level has propagated to long-lasting
 *  storage. Access Levels containing errors will result in an error response
 *  for the first error encountered.
 *
 *  Method: accesscontextmanager.accessPolicies.accessLevels.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsCreate : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesAccessLevelsCreateWithObject:parent:]

/**
 *  Required. Resource name for the access policy which owns this Access Level.
 *  Format: `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Create an Access Level. The longrunning operation from this RPC will have a
 *  successful status once the Access Level has propagated to long-lasting
 *  storage. Access Levels containing errors will result in an error response
 *  for the first error encountered.
 *
 *  @param object The @c GTLRAccessContextManager_AccessLevel to include in the
 *    query.
 *  @param parent Required. Resource name for the access policy which owns this
 *    Access Level. Format: `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsCreate
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_AccessLevel *)object
                         parent:(NSString *)parent;

@end

/**
 *  Delete an Access Level by resource name. The longrunning operation from this
 *  RPC will have a successful status once the Access Level has been removed
 *  from long-lasting storage.
 *
 *  Method: accesscontextmanager.accessPolicies.accessLevels.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsDelete : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesAccessLevelsDeleteWithname:]

/**
 *  Required. Resource name for the Access Level. Format:
 *  `accessPolicies/{policy_id}/accessLevels/{access_level_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Delete an Access Level by resource name. The longrunning operation from this
 *  RPC will have a successful status once the Access Level has been removed
 *  from long-lasting storage.
 *
 *  @param name Required. Resource name for the Access Level. Format:
 *    `accessPolicies/{policy_id}/accessLevels/{access_level_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get an Access Level by resource name.
 *
 *  Method: accesscontextmanager.accessPolicies.accessLevels.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsGet : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesAccessLevelsGetWithname:]

/**
 *  Whether to return `BasicLevels` in the Cloud Common Expression Language
 *  rather than as `BasicLevels`. Defaults to AS_DEFINED, where Access Levels
 *  are returned as `BasicLevels` or `CustomLevels` based on how they were
 *  created. If set to CEL, all Access Levels are returned as `CustomLevels`. In
 *  the CEL case, `BasicLevels` are translated to equivalent `CustomLevels`.
 *
 *  Likely values:
 *    @arg @c kGTLRAccessContextManagerAccessLevelFormatLevelFormatUnspecified
 *        The format was not specified. (Value: "LEVEL_FORMAT_UNSPECIFIED")
 *    @arg @c kGTLRAccessContextManagerAccessLevelFormatAsDefined Uses the
 *        format the resource was defined in. BasicLevels are returned as
 *        BasicLevels, CustomLevels are returned as CustomLevels. (Value:
 *        "AS_DEFINED")
 *    @arg @c kGTLRAccessContextManagerAccessLevelFormatCel Use Cloud Common
 *        Expression Language when returning the resource. Both BasicLevels and
 *        CustomLevels are returned as CustomLevels. (Value: "CEL")
 */
@property(nonatomic, copy, nullable) NSString *accessLevelFormat;

/**
 *  Required. Resource name for the Access Level. Format:
 *  `accessPolicies/{policy_id}/accessLevels/{access_level_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_AccessLevel.
 *
 *  Get an Access Level by resource name.
 *
 *  @param name Required. Resource name for the Access Level. Format:
 *    `accessPolicies/{policy_id}/accessLevels/{access_level_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List all Access Levels for an access policy.
 *
 *  Method: accesscontextmanager.accessPolicies.accessLevels.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsList : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesAccessLevelsListWithparent:]

/**
 *  Whether to return `BasicLevels` in the Cloud Common Expression language, as
 *  `CustomLevels`, rather than as `BasicLevels`. Defaults to returning
 *  `AccessLevels` in the format they were defined.
 *
 *  Likely values:
 *    @arg @c kGTLRAccessContextManagerAccessLevelFormatLevelFormatUnspecified
 *        The format was not specified. (Value: "LEVEL_FORMAT_UNSPECIFIED")
 *    @arg @c kGTLRAccessContextManagerAccessLevelFormatAsDefined Uses the
 *        format the resource was defined in. BasicLevels are returned as
 *        BasicLevels, CustomLevels are returned as CustomLevels. (Value:
 *        "AS_DEFINED")
 *    @arg @c kGTLRAccessContextManagerAccessLevelFormatCel Use Cloud Common
 *        Expression Language when returning the resource. Both BasicLevels and
 *        CustomLevels are returned as CustomLevels. (Value: "CEL")
 */
@property(nonatomic, copy, nullable) NSString *accessLevelFormat;

/** Number of Access Levels to include in the list. Default 100. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Next page token for the next batch of Access Level instances. Defaults to
 *  the first page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Resource name for the access policy to list Access Levels from.
 *  Format: `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_ListAccessLevelsResponse.
 *
 *  List all Access Levels for an access policy.
 *
 *  @param parent Required. Resource name for the access policy to list Access
 *    Levels from. Format: `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Update an Access Level. The longrunning operation from this RPC will have a
 *  successful status once the changes to the Access Level have propagated to
 *  long-lasting storage. Access Levels containing errors will result in an
 *  error response for the first error encountered.
 *
 *  Method: accesscontextmanager.accessPolicies.accessLevels.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsPatch : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesAccessLevelsPatchWithObject:name:]

/**
 *  Required. Resource name for the Access Level. The `short_name` component
 *  must begin with a letter and only include alphanumeric and '_'. Format:
 *  `accessPolicies/{policy_id}/accessLevels/{short_name}`. The maximum length
 *  of the `short_name` component is 50 characters.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Mask to control which fields get updated. Must be non-empty.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Update an Access Level. The longrunning operation from this RPC will have a
 *  successful status once the changes to the Access Level have propagated to
 *  long-lasting storage. Access Levels containing errors will result in an
 *  error response for the first error encountered.
 *
 *  @param object The @c GTLRAccessContextManager_AccessLevel to include in the
 *    query.
 *  @param name Required. Resource name for the Access Level. The `short_name`
 *    component must begin with a letter and only include alphanumeric and '_'.
 *    Format: `accessPolicies/{policy_id}/accessLevels/{short_name}`. The
 *    maximum length of the `short_name` component is 50 characters.
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsPatch
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_AccessLevel *)object
                           name:(NSString *)name;

@end

/**
 *  Replace all existing Access Levels in an Access Policy with the Access
 *  Levels provided. This is done atomically. The longrunning operation from
 *  this RPC will have a successful status once all replacements have propagated
 *  to long-lasting storage. Replacements containing errors will result in an
 *  error response for the first error encountered. Replacement will be
 *  cancelled on error, existing Access Levels will not be affected.
 *  Operation.response field will contain ReplaceAccessLevelsResponse. Removing
 *  Access Levels contained in existing Service Perimeters will result in error.
 *
 *  Method: accesscontextmanager.accessPolicies.accessLevels.replaceAll
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsReplaceAll : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesAccessLevelsReplaceAllWithObject:parent:]

/**
 *  Required. Resource name for the access policy which owns these Access
 *  Levels. Format: `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Replace all existing Access Levels in an Access Policy with the Access
 *  Levels provided. This is done atomically. The longrunning operation from
 *  this RPC will have a successful status once all replacements have propagated
 *  to long-lasting storage. Replacements containing errors will result in an
 *  error response for the first error encountered. Replacement will be
 *  cancelled on error, existing Access Levels will not be affected.
 *  Operation.response field will contain ReplaceAccessLevelsResponse. Removing
 *  Access Levels contained in existing Service Perimeters will result in error.
 *
 *  @param object The @c GTLRAccessContextManager_ReplaceAccessLevelsRequest to
 *    include in the query.
 *  @param parent Required. Resource name for the access policy which owns these
 *    Access Levels. Format: `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesAccessLevelsReplaceAll
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_ReplaceAccessLevelsRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Create an `AccessPolicy`. Fails if this organization already has a
 *  `AccessPolicy`. The longrunning Operation will have a successful status once
 *  the `AccessPolicy` has propagated to long-lasting storage. Syntactic and
 *  basic semantic errors will be returned in `metadata` as a BadRequest proto.
 *
 *  Method: accesscontextmanager.accessPolicies.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesCreate : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesCreateWithObject:]

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Create an `AccessPolicy`. Fails if this organization already has a
 *  `AccessPolicy`. The longrunning Operation will have a successful status once
 *  the `AccessPolicy` has propagated to long-lasting storage. Syntactic and
 *  basic semantic errors will be returned in `metadata` as a BadRequest proto.
 *
 *  @param object The @c GTLRAccessContextManager_AccessPolicy to include in the
 *    query.
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesCreate
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_AccessPolicy *)object;

@end

/**
 *  Delete an AccessPolicy by resource name. The longrunning Operation will have
 *  a successful status once the AccessPolicy has been removed from long-lasting
 *  storage.
 *
 *  Method: accesscontextmanager.accessPolicies.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesDelete : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesDeleteWithname:]

/**
 *  Required. Resource name for the access policy to delete. Format
 *  `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Delete an AccessPolicy by resource name. The longrunning Operation will have
 *  a successful status once the AccessPolicy has been removed from long-lasting
 *  storage.
 *
 *  @param name Required. Resource name for the access policy to delete. Format
 *    `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get an AccessPolicy by name.
 *
 *  Method: accesscontextmanager.accessPolicies.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesGet : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesGetWithname:]

/**
 *  Required. Resource name for the access policy to get. Format
 *  `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_AccessPolicy.
 *
 *  Get an AccessPolicy by name.
 *
 *  @param name Required. Resource name for the access policy to get. Format
 *    `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List all AccessPolicies under a container.
 *
 *  Method: accesscontextmanager.accessPolicies.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesList : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesList]

/** Number of AccessPolicy instances to include in the list. Default 100. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Next page token for the next batch of AccessPolicy instances. Defaults to
 *  the first page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Resource name for the container to list AccessPolicy instances
 *  from. Format: `organizations/{org_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_ListAccessPoliciesResponse.
 *
 *  List all AccessPolicies under a container.
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)query;

@end

/**
 *  Update an AccessPolicy. The longrunning Operation from this RPC will have a
 *  successful status once the changes to the AccessPolicy have propagated to
 *  long-lasting storage. Syntactic and basic semantic errors will be returned
 *  in `metadata` as a BadRequest proto.
 *
 *  Method: accesscontextmanager.accessPolicies.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesPatch : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesPatchWithObject:name:]

/**
 *  Output only. Resource name of the `AccessPolicy`. Format:
 *  `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Mask to control which fields get updated. Must be non-empty.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Update an AccessPolicy. The longrunning Operation from this RPC will have a
 *  successful status once the changes to the AccessPolicy have propagated to
 *  long-lasting storage. Syntactic and basic semantic errors will be returned
 *  in `metadata` as a BadRequest proto.
 *
 *  @param object The @c GTLRAccessContextManager_AccessPolicy to include in the
 *    query.
 *  @param name Output only. Resource name of the `AccessPolicy`. Format:
 *    `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesPatch
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_AccessPolicy *)object
                           name:(NSString *)name;

@end

/**
 *  Commit the dry-run spec for all the Service Perimeters in an Access Policy.
 *  A commit operation on a Service Perimeter involves copying its `spec` field
 *  to that Service Perimeter's `status` field. Only Service Perimeters with
 *  `use_explicit_dry_run_spec` field set to true are affected by a commit
 *  operation. The longrunning operation from this RPC will have a successful
 *  status once the dry-run specs for all the Service Perimeters have been
 *  committed. If a commit fails, it will cause the longrunning operation to
 *  return an error response and the entire commit operation will be cancelled.
 *  When successful, Operation.response field will contain
 *  CommitServicePerimetersResponse. The `dry_run` and the `spec` fields will be
 *  cleared after a successful commit operation.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.commit
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersCommit : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersCommitWithObject:parent:]

/**
 *  Required. Resource name for the parent Access Policy which owns all Service
 *  Perimeters in scope for the commit operation. Format:
 *  `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Commit the dry-run spec for all the Service Perimeters in an Access Policy.
 *  A commit operation on a Service Perimeter involves copying its `spec` field
 *  to that Service Perimeter's `status` field. Only Service Perimeters with
 *  `use_explicit_dry_run_spec` field set to true are affected by a commit
 *  operation. The longrunning operation from this RPC will have a successful
 *  status once the dry-run specs for all the Service Perimeters have been
 *  committed. If a commit fails, it will cause the longrunning operation to
 *  return an error response and the entire commit operation will be cancelled.
 *  When successful, Operation.response field will contain
 *  CommitServicePerimetersResponse. The `dry_run` and the `spec` fields will be
 *  cleared after a successful commit operation.
 *
 *  @param object The @c GTLRAccessContextManager_CommitServicePerimetersRequest
 *    to include in the query.
 *  @param parent Required. Resource name for the parent Access Policy which
 *    owns all Service Perimeters in scope for the commit operation. Format:
 *    `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersCommit
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_CommitServicePerimetersRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Create a Service Perimeter. The longrunning operation from this RPC will
 *  have a successful status once the Service Perimeter has propagated to
 *  long-lasting storage. Service Perimeters containing errors will result in an
 *  error response for the first error encountered.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersCreate : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersCreateWithObject:parent:]

/**
 *  Required. Resource name for the access policy which owns this Service
 *  Perimeter. Format: `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Create a Service Perimeter. The longrunning operation from this RPC will
 *  have a successful status once the Service Perimeter has propagated to
 *  long-lasting storage. Service Perimeters containing errors will result in an
 *  error response for the first error encountered.
 *
 *  @param object The @c GTLRAccessContextManager_ServicePerimeter to include in
 *    the query.
 *  @param parent Required. Resource name for the access policy which owns this
 *    Service Perimeter. Format: `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersCreate
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_ServicePerimeter *)object
                         parent:(NSString *)parent;

@end

/**
 *  Delete a Service Perimeter by resource name. The longrunning operation from
 *  this RPC will have a successful status once the Service Perimeter has been
 *  removed from long-lasting storage.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersDelete : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersDeleteWithname:]

/**
 *  Required. Resource name for the Service Perimeter. Format:
 *  `accessPolicies/{policy_id}/servicePerimeters/{service_perimeter_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Delete a Service Perimeter by resource name. The longrunning operation from
 *  this RPC will have a successful status once the Service Perimeter has been
 *  removed from long-lasting storage.
 *
 *  @param name Required. Resource name for the Service Perimeter. Format:
 *    `accessPolicies/{policy_id}/servicePerimeters/{service_perimeter_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Get a Service Perimeter by resource name.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersGet : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersGetWithname:]

/**
 *  Required. Resource name for the Service Perimeter. Format:
 *  `accessPolicies/{policy_id}/servicePerimeters/{service_perimeters_id}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_ServicePerimeter.
 *
 *  Get a Service Perimeter by resource name.
 *
 *  @param name Required. Resource name for the Service Perimeter. Format:
 *    `accessPolicies/{policy_id}/servicePerimeters/{service_perimeters_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  List all Service Perimeters for an access policy.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersList : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersListWithparent:]

/** Number of Service Perimeters to include in the list. Default 100. */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Next page token for the next batch of Service Perimeter instances. Defaults
 *  to the first page of results.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Required. Resource name for the access policy to list Service Perimeters
 *  from. Format: `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_ListServicePerimetersResponse.
 *
 *  List all Service Perimeters for an access policy.
 *
 *  @param parent Required. Resource name for the access policy to list Service
 *    Perimeters from. Format: `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Update a Service Perimeter. The longrunning operation from this RPC will
 *  have a successful status once the changes to the Service Perimeter have
 *  propagated to long-lasting storage. Service Perimeter containing errors will
 *  result in an error response for the first error encountered.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersPatch : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersPatchWithObject:name:]

/**
 *  Required. Resource name for the ServicePerimeter. The `short_name` component
 *  must begin with a letter and only include alphanumeric and '_'. Format:
 *  `accessPolicies/{policy_id}/servicePerimeters/{short_name}`
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Mask to control which fields get updated. Must be non-empty.
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Update a Service Perimeter. The longrunning operation from this RPC will
 *  have a successful status once the changes to the Service Perimeter have
 *  propagated to long-lasting storage. Service Perimeter containing errors will
 *  result in an error response for the first error encountered.
 *
 *  @param object The @c GTLRAccessContextManager_ServicePerimeter to include in
 *    the query.
 *  @param name Required. Resource name for the ServicePerimeter. The
 *    `short_name` component must begin with a letter and only include
 *    alphanumeric and '_'. Format:
 *    `accessPolicies/{policy_id}/servicePerimeters/{short_name}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersPatch
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_ServicePerimeter *)object
                           name:(NSString *)name;

@end

/**
 *  Replace all existing Service Perimeters in an Access Policy with the Service
 *  Perimeters provided. This is done atomically. The longrunning operation from
 *  this RPC will have a successful status once all replacements have propagated
 *  to long-lasting storage. Replacements containing errors will result in an
 *  error response for the first error encountered. Replacement will be
 *  cancelled on error, existing Service Perimeters will not be affected.
 *  Operation.response field will contain ReplaceServicePerimetersResponse.
 *
 *  Method: accesscontextmanager.accessPolicies.servicePerimeters.replaceAll
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersReplaceAll : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForAccessPoliciesServicePerimetersReplaceAllWithObject:parent:]

/**
 *  Required. Resource name for the access policy which owns these Service
 *  Perimeters. Format: `accessPolicies/{policy_id}`
 */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Replace all existing Service Perimeters in an Access Policy with the Service
 *  Perimeters provided. This is done atomically. The longrunning operation from
 *  this RPC will have a successful status once all replacements have propagated
 *  to long-lasting storage. Replacements containing errors will result in an
 *  error response for the first error encountered. Replacement will be
 *  cancelled on error, existing Service Perimeters will not be affected.
 *  Operation.response field will contain ReplaceServicePerimetersResponse.
 *
 *  @param object The @c
 *    GTLRAccessContextManager_ReplaceServicePerimetersRequest to include in the
 *    query.
 *  @param parent Required. Resource name for the access policy which owns these
 *    Service Perimeters. Format: `accessPolicies/{policy_id}`
 *
 *  @return GTLRAccessContextManagerQuery_AccessPoliciesServicePerimetersReplaceAll
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_ReplaceServicePerimetersRequest *)object
                         parent:(NSString *)parent;

@end

/**
 *  Starts asynchronous cancellation on a long-running operation. The server
 *  makes a best effort to cancel the operation, but success is not guaranteed.
 *  If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or
 *  other methods to check whether the cancellation succeeded or whether the
 *  operation completed despite cancellation. On successful cancellation, the
 *  operation is not deleted; instead, it becomes an operation with an
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  Method: accesscontextmanager.operations.cancel
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OperationsCancel : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOperationsCancelWithObject:name:]

/** The name of the operation resource to be cancelled. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Empty.
 *
 *  Starts asynchronous cancellation on a long-running operation. The server
 *  makes a best effort to cancel the operation, but success is not guaranteed.
 *  If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or
 *  other methods to check whether the cancellation succeeded or whether the
 *  operation completed despite cancellation. On successful cancellation, the
 *  operation is not deleted; instead, it becomes an operation with an
 *  Operation.error value with a google.rpc.Status.code of 1, corresponding to
 *  `Code.CANCELLED`.
 *
 *  @param object The @c GTLRAccessContextManager_CancelOperationRequest to
 *    include in the query.
 *  @param name The name of the operation resource to be cancelled.
 *
 *  @return GTLRAccessContextManagerQuery_OperationsCancel
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_CancelOperationRequest *)object
                           name:(NSString *)name;

@end

/**
 *  Deletes a long-running operation. This method indicates that the client is
 *  no longer interested in the operation result. It does not cancel the
 *  operation. If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`.
 *
 *  Method: accesscontextmanager.operations.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OperationsDelete : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOperationsDeleteWithname:]

/** The name of the operation resource to be deleted. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Empty.
 *
 *  Deletes a long-running operation. This method indicates that the client is
 *  no longer interested in the operation result. It does not cancel the
 *  operation. If the server doesn't support this method, it returns
 *  `google.rpc.Code.UNIMPLEMENTED`.
 *
 *  @param name The name of the operation resource to be deleted.
 *
 *  @return GTLRAccessContextManagerQuery_OperationsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets the latest state of a long-running operation. Clients can use this
 *  method to poll the operation result at intervals as recommended by the API
 *  service.
 *
 *  Method: accesscontextmanager.operations.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OperationsGet : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOperationsGetWithname:]

/** The name of the operation resource. */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Gets the latest state of a long-running operation. Clients can use this
 *  method to poll the operation result at intervals as recommended by the API
 *  service.
 *
 *  @param name The name of the operation resource.
 *
 *  @return GTLRAccessContextManagerQuery_OperationsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists operations that match the specified filter in the request. If the
 *  server doesn't support this method, it returns `UNIMPLEMENTED`. NOTE: the
 *  `name` binding allows API services to override the binding to use different
 *  resource name schemes, such as `users/ * /operations`. To override the
 *  binding, API services can add a binding such as `"/v1/{name=users/
 *  *}/operations"` to their service configuration. For backwards compatibility,
 *  the default name includes the operations collection id, however overriding
 *  users must ensure the name binding is the parent resource, without the
 *  operations collection id.
 *
 *  Method: accesscontextmanager.operations.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OperationsList : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOperationsListWithname:]

/** The standard list filter. */
@property(nonatomic, copy, nullable) NSString *filter;

/** The name of the operation's parent resource. */
@property(nonatomic, copy, nullable) NSString *name;

/** The standard list page size. */
@property(nonatomic, assign) NSInteger pageSize;

/** The standard list page token. */
@property(nonatomic, copy, nullable) NSString *pageToken;

/**
 *  Fetches a @c GTLRAccessContextManager_ListOperationsResponse.
 *
 *  Lists operations that match the specified filter in the request. If the
 *  server doesn't support this method, it returns `UNIMPLEMENTED`. NOTE: the
 *  `name` binding allows API services to override the binding to use different
 *  resource name schemes, such as `users/ * /operations`. To override the
 *  binding, API services can add a binding such as `"/v1/{name=users/
 *  *}/operations"` to their service configuration. For backwards compatibility,
 *  the default name includes the operations collection id, however overriding
 *  users must ensure the name binding is the parent resource, without the
 *  operations collection id.
 *
 *  @param name The name of the operation's parent resource.
 *
 *  @return GTLRAccessContextManagerQuery_OperationsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Creates a GcpUserAccessBinding. If the client specifies a name, the server
 *  will ignore it. Fails if a resource already exists with the same group_key.
 *  Completion of this long-running operation does not necessarily signify that
 *  the new binding is deployed onto all affected users, which may take more
 *  time.
 *
 *  Method: accesscontextmanager.organizations.gcpUserAccessBindings.create
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsCreate : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOrganizationsGcpUserAccessBindingsCreateWithObject:parent:]

/** Required. Example: "organizations/256" */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Creates a GcpUserAccessBinding. If the client specifies a name, the server
 *  will ignore it. Fails if a resource already exists with the same group_key.
 *  Completion of this long-running operation does not necessarily signify that
 *  the new binding is deployed onto all affected users, which may take more
 *  time.
 *
 *  @param object The @c GTLRAccessContextManager_GcpUserAccessBinding to
 *    include in the query.
 *  @param parent Required. Example: "organizations/256"
 *
 *  @return GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsCreate
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_GcpUserAccessBinding *)object
                         parent:(NSString *)parent;

@end

/**
 *  Deletes a GcpUserAccessBinding. Completion of this long-running operation
 *  does not necessarily signify that the binding deletion is deployed onto all
 *  affected users, which may take more time.
 *
 *  Method: accesscontextmanager.organizations.gcpUserAccessBindings.delete
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsDelete : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOrganizationsGcpUserAccessBindingsDeleteWithname:]

/**
 *  Required. Example: "organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N"
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Deletes a GcpUserAccessBinding. Completion of this long-running operation
 *  does not necessarily signify that the binding deletion is deployed onto all
 *  affected users, which may take more time.
 *
 *  @param name Required. Example:
 *    "organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N"
 *
 *  @return GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsDelete
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Gets the GcpUserAccessBinding with the given name.
 *
 *  Method: accesscontextmanager.organizations.gcpUserAccessBindings.get
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsGet : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOrganizationsGcpUserAccessBindingsGetWithname:]

/**
 *  Required. Example: "organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N"
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Fetches a @c GTLRAccessContextManager_GcpUserAccessBinding.
 *
 *  Gets the GcpUserAccessBinding with the given name.
 *
 *  @param name Required. Example:
 *    "organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N"
 *
 *  @return GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsGet
 */
+ (instancetype)queryWithName:(NSString *)name;

@end

/**
 *  Lists all GcpUserAccessBindings for a Google Cloud organization.
 *
 *  Method: accesscontextmanager.organizations.gcpUserAccessBindings.list
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsList : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOrganizationsGcpUserAccessBindingsListWithparent:]

/**
 *  Optional. Maximum number of items to return. The server may return fewer
 *  items. If left blank, the server may return any number of items.
 */
@property(nonatomic, assign) NSInteger pageSize;

/**
 *  Optional. If left blank, returns the first page. To enumerate all items, use
 *  the next_page_token from your previous list operation.
 */
@property(nonatomic, copy, nullable) NSString *pageToken;

/** Required. Example: "organizations/256" */
@property(nonatomic, copy, nullable) NSString *parent;

/**
 *  Fetches a @c GTLRAccessContextManager_ListGcpUserAccessBindingsResponse.
 *
 *  Lists all GcpUserAccessBindings for a Google Cloud organization.
 *
 *  @param parent Required. Example: "organizations/256"
 *
 *  @return GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsList
 *
 *  @note Automatic pagination will be done when @c shouldFetchNextPages is
 *        enabled. See @c shouldFetchNextPages on @c GTLRService for more
 *        information.
 */
+ (instancetype)queryWithParent:(NSString *)parent;

@end

/**
 *  Updates a GcpUserAccessBinding. Completion of this long-running operation
 *  does not necessarily signify that the changed binding is deployed onto all
 *  affected users, which may take more time.
 *
 *  Method: accesscontextmanager.organizations.gcpUserAccessBindings.patch
 *
 *  Authorization scope(s):
 *    @c kGTLRAuthScopeAccessContextManagerCloudPlatform
 */
@interface GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsPatch : GTLRAccessContextManagerQuery
// Previous library name was
//   +[GTLQueryAccessContextManager queryForOrganizationsGcpUserAccessBindingsPatchWithObject:name:]

/**
 *  Immutable. Assigned by the server during creation. The last segment has an
 *  arbitrary length and has only URI unreserved characters (as defined by [RFC
 *  3986 Section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3)). Should
 *  not be specified by the client during creation. Example:
 *  "organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N"
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  Required. Only the fields specified in this mask are updated. Because name
 *  and group_key cannot be changed, update_mask is required and must always be:
 *  update_mask { paths: "access_levels" }
 *
 *  String format is a comma-separated list of fields.
 */
@property(nonatomic, copy, nullable) NSString *updateMask;

/**
 *  Fetches a @c GTLRAccessContextManager_Operation.
 *
 *  Updates a GcpUserAccessBinding. Completion of this long-running operation
 *  does not necessarily signify that the changed binding is deployed onto all
 *  affected users, which may take more time.
 *
 *  @param object The @c GTLRAccessContextManager_GcpUserAccessBinding to
 *    include in the query.
 *  @param name Immutable. Assigned by the server during creation. The last
 *    segment has an arbitrary length and has only URI unreserved characters (as
 *    defined by [RFC 3986 Section
 *    2.3](https://tools.ietf.org/html/rfc3986#section-2.3)). Should not be
 *    specified by the client during creation. Example:
 *    "organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N"
 *
 *  @return GTLRAccessContextManagerQuery_OrganizationsGcpUserAccessBindingsPatch
 */
+ (instancetype)queryWithObject:(GTLRAccessContextManager_GcpUserAccessBinding *)object
                           name:(NSString *)name;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop
