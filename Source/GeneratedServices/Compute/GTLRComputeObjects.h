// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Compute Engine API (compute/v1)
// Description:
//   Creates and runs virtual machines on Google Cloud Platform.
// Documentation:
//   https://developers.google.com/compute/docs/reference/latest/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRCompute_AccessConfig;
@class GTLRCompute_Address;
@class GTLRCompute_AddressAggregatedListItems;
@class GTLRCompute_AddressesScopedList;
@class GTLRCompute_AddressesScopedListWarning;
@class GTLRCompute_AddressesScopedListWarningDataItem;
@class GTLRCompute_AttachedDisk;
@class GTLRCompute_AttachedDiskInitializeParams;
@class GTLRCompute_Autoscaler;
@class GTLRCompute_AutoscalerAggregatedListItems;
@class GTLRCompute_AutoscalersScopedList;
@class GTLRCompute_AutoscalersScopedListWarning;
@class GTLRCompute_AutoscalersScopedListWarningDataItem;
@class GTLRCompute_AutoscalingPolicy;
@class GTLRCompute_AutoscalingPolicyCpuUtilization;
@class GTLRCompute_AutoscalingPolicyCustomMetricUtilization;
@class GTLRCompute_AutoscalingPolicyLoadBalancingUtilization;
@class GTLRCompute_Backend;
@class GTLRCompute_BackendService;
@class GTLRCompute_DeprecationStatus;
@class GTLRCompute_Disk;
@class GTLRCompute_DiskAggregatedListItems;
@class GTLRCompute_DisksScopedList;
@class GTLRCompute_DisksScopedListWarning;
@class GTLRCompute_DisksScopedListWarningDataItem;
@class GTLRCompute_DiskType;
@class GTLRCompute_DiskTypeAggregatedListItems;
@class GTLRCompute_DiskTypesScopedList;
@class GTLRCompute_DiskTypesScopedListWarning;
@class GTLRCompute_DiskTypesScopedListWarningDataItem;
@class GTLRCompute_Firewall;
@class GTLRCompute_FirewallAllowedItem;
@class GTLRCompute_ForwardingRule;
@class GTLRCompute_ForwardingRuleAggregatedListItems;
@class GTLRCompute_ForwardingRulesScopedList;
@class GTLRCompute_ForwardingRulesScopedListWarning;
@class GTLRCompute_ForwardingRulesScopedListWarningDataItem;
@class GTLRCompute_HealthCheckReference;
@class GTLRCompute_HealthStatus;
@class GTLRCompute_HostRule;
@class GTLRCompute_HttpHealthCheck;
@class GTLRCompute_HttpsHealthCheck;
@class GTLRCompute_Image;
@class GTLRCompute_ImageRawDisk;
@class GTLRCompute_Instance;
@class GTLRCompute_InstanceAggregatedListItems;
@class GTLRCompute_InstanceGroup;
@class GTLRCompute_InstanceGroupAggregatedListItems;
@class GTLRCompute_InstanceGroupManager;
@class GTLRCompute_InstanceGroupManagerActionsSummary;
@class GTLRCompute_InstanceGroupManagerAggregatedListItems;
@class GTLRCompute_InstanceGroupManagersScopedList;
@class GTLRCompute_InstanceGroupManagersScopedListWarning;
@class GTLRCompute_InstanceGroupManagersScopedListWarningDataItem;
@class GTLRCompute_InstanceGroupsScopedList;
@class GTLRCompute_InstanceGroupsScopedListWarning;
@class GTLRCompute_InstanceGroupsScopedListWarningDataItem;
@class GTLRCompute_InstanceProperties;
@class GTLRCompute_InstanceReference;
@class GTLRCompute_InstancesScopedList;
@class GTLRCompute_InstancesScopedListWarning;
@class GTLRCompute_InstancesScopedListWarningDataItem;
@class GTLRCompute_InstanceTemplate;
@class GTLRCompute_InstanceWithNamedPorts;
@class GTLRCompute_MachineType;
@class GTLRCompute_MachineTypeAggregatedListItems;
@class GTLRCompute_MachineTypeScratchDisksItem;
@class GTLRCompute_MachineTypesScopedList;
@class GTLRCompute_MachineTypesScopedListWarning;
@class GTLRCompute_MachineTypesScopedListWarningDataItem;
@class GTLRCompute_ManagedInstance;
@class GTLRCompute_ManagedInstanceLastAttempt;
@class GTLRCompute_ManagedInstanceLastAttemptErrors;
@class GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem;
@class GTLRCompute_Metadata;
@class GTLRCompute_MetadataItemsItem;
@class GTLRCompute_NamedPort;
@class GTLRCompute_Network;
@class GTLRCompute_NetworkInterface;
@class GTLRCompute_Operation;
@class GTLRCompute_OperationAggregatedListItems;
@class GTLRCompute_OperationError;
@class GTLRCompute_OperationErrorErrorsItem;
@class GTLRCompute_OperationsScopedList;
@class GTLRCompute_OperationsScopedListWarning;
@class GTLRCompute_OperationsScopedListWarningDataItem;
@class GTLRCompute_OperationWarningsItem;
@class GTLRCompute_OperationWarningsItemDataItem;
@class GTLRCompute_PathMatcher;
@class GTLRCompute_PathRule;
@class GTLRCompute_Quota;
@class GTLRCompute_Region;
@class GTLRCompute_Route;
@class GTLRCompute_RouteWarningsItem;
@class GTLRCompute_RouteWarningsItemDataItem;
@class GTLRCompute_Scheduling;
@class GTLRCompute_ServiceAccount;
@class GTLRCompute_Snapshot;
@class GTLRCompute_SslCertificate;
@class GTLRCompute_Subnetwork;
@class GTLRCompute_SubnetworkAggregatedListItems;
@class GTLRCompute_SubnetworksScopedList;
@class GTLRCompute_SubnetworksScopedListWarning;
@class GTLRCompute_SubnetworksScopedListWarningDataItem;
@class GTLRCompute_Tags;
@class GTLRCompute_TargetHttpProxy;
@class GTLRCompute_TargetHttpsProxy;
@class GTLRCompute_TargetInstance;
@class GTLRCompute_TargetInstanceAggregatedListItems;
@class GTLRCompute_TargetInstancesScopedList;
@class GTLRCompute_TargetInstancesScopedListWarning;
@class GTLRCompute_TargetInstancesScopedListWarningDataItem;
@class GTLRCompute_TargetPool;
@class GTLRCompute_TargetPoolAggregatedListItems;
@class GTLRCompute_TargetPoolsScopedList;
@class GTLRCompute_TargetPoolsScopedListWarning;
@class GTLRCompute_TargetPoolsScopedListWarningDataItem;
@class GTLRCompute_TargetVpnGateway;
@class GTLRCompute_TargetVpnGatewayAggregatedListItems;
@class GTLRCompute_TargetVpnGatewaysScopedList;
@class GTLRCompute_TargetVpnGatewaysScopedListWarning;
@class GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem;
@class GTLRCompute_TestFailure;
@class GTLRCompute_UrlMap;
@class GTLRCompute_UrlMapTest;
@class GTLRCompute_UrlMapValidationResult;
@class GTLRCompute_UsageExportLocation;
@class GTLRCompute_VpnTunnel;
@class GTLRCompute_VpnTunnelAggregatedListItems;
@class GTLRCompute_VpnTunnelsScopedList;
@class GTLRCompute_VpnTunnelsScopedListWarning;
@class GTLRCompute_VpnTunnelsScopedListWarningDataItem;
@class GTLRCompute_Zone;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRCompute_AccessConfig.type

/** Value: "ONE_TO_ONE_NAT" */
GTLR_EXTERN NSString * const kGTLRCompute_AccessConfig_Type_OneToOneNat;

// ----------------------------------------------------------------------------
// GTLRCompute_Address.status

/** Value: "IN_USE" */
GTLR_EXTERN NSString * const kGTLRCompute_Address_Status_InUse;
/** Value: "RESERVED" */
GTLR_EXTERN NSString * const kGTLRCompute_Address_Status_Reserved;

// ----------------------------------------------------------------------------
// GTLRCompute_AddressesScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_AddressesScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_AttachedDisk.interface

/** Value: "NVME" */
GTLR_EXTERN NSString * const kGTLRCompute_AttachedDisk_Interface_Nvme;
/** Value: "SCSI" */
GTLR_EXTERN NSString * const kGTLRCompute_AttachedDisk_Interface_Scsi;

// ----------------------------------------------------------------------------
// GTLRCompute_AttachedDisk.mode

/** Value: "READ_ONLY" */
GTLR_EXTERN NSString * const kGTLRCompute_AttachedDisk_Mode_ReadOnly;
/** Value: "READ_WRITE" */
GTLR_EXTERN NSString * const kGTLRCompute_AttachedDisk_Mode_ReadWrite;

// ----------------------------------------------------------------------------
// GTLRCompute_AttachedDisk.type

/** Value: "PERSISTENT" */
GTLR_EXTERN NSString * const kGTLRCompute_AttachedDisk_Type_Persistent;
/** Value: "SCRATCH" */
GTLR_EXTERN NSString * const kGTLRCompute_AttachedDisk_Type_Scratch;

// ----------------------------------------------------------------------------
// GTLRCompute_AutoscalersScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_AutoscalingPolicyCustomMetricUtilization.utilizationTargetType

/** Value: "DELTA_PER_MINUTE" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_DeltaPerMinute;
/** Value: "DELTA_PER_SECOND" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_DeltaPerSecond;
/** Value: "GAUGE" */
GTLR_EXTERN NSString * const kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_Gauge;

// ----------------------------------------------------------------------------
// GTLRCompute_Backend.balancingMode

/** Value: "RATE" */
GTLR_EXTERN NSString * const kGTLRCompute_Backend_BalancingMode_Rate;
/** Value: "UTILIZATION" */
GTLR_EXTERN NSString * const kGTLRCompute_Backend_BalancingMode_Utilization;

// ----------------------------------------------------------------------------
// GTLRCompute_BackendService.protocol

/** Value: "HTTP" */
GTLR_EXTERN NSString * const kGTLRCompute_BackendService_Protocol_Http;
/** Value: "HTTPS" */
GTLR_EXTERN NSString * const kGTLRCompute_BackendService_Protocol_Https;

// ----------------------------------------------------------------------------
// GTLRCompute_DeprecationStatus.state

/** Value: "DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_DeprecationStatus_State_Deleted;
/** Value: "DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_DeprecationStatus_State_Deprecated;
/** Value: "OBSOLETE" */
GTLR_EXTERN NSString * const kGTLRCompute_DeprecationStatus_State_Obsolete;

// ----------------------------------------------------------------------------
// GTLRCompute_Disk.status

/** Value: "CREATING" */
GTLR_EXTERN NSString * const kGTLRCompute_Disk_Status_Creating;
/** Value: "FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_Disk_Status_Failed;
/** Value: "READY" */
GTLR_EXTERN NSString * const kGTLRCompute_Disk_Status_Ready;
/** Value: "RESTORING" */
GTLR_EXTERN NSString * const kGTLRCompute_Disk_Status_Restoring;

// ----------------------------------------------------------------------------
// GTLRCompute_DisksScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_DisksScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_DiskTypesScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_ForwardingRule.IPProtocol

/** Value: "AH" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Ah;
/** Value: "ESP" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Esp;
/** Value: "SCTP" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Sctp;
/** Value: "TCP" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Tcp;
/** Value: "UDP" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Udp;

// ----------------------------------------------------------------------------
// GTLRCompute_ForwardingRulesScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_HealthStatus.healthState

/** Value: "HEALTHY" */
GTLR_EXTERN NSString * const kGTLRCompute_HealthStatus_HealthState_Healthy;
/** Value: "UNHEALTHY" */
GTLR_EXTERN NSString * const kGTLRCompute_HealthStatus_HealthState_Unhealthy;

// ----------------------------------------------------------------------------
// GTLRCompute_Image.sourceType

/** Value: "RAW" */
GTLR_EXTERN NSString * const kGTLRCompute_Image_SourceType_Raw;

// ----------------------------------------------------------------------------
// GTLRCompute_Image.status

/** Value: "FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_Image_Status_Failed;
/** Value: "PENDING" */
GTLR_EXTERN NSString * const kGTLRCompute_Image_Status_Pending;
/** Value: "READY" */
GTLR_EXTERN NSString * const kGTLRCompute_Image_Status_Ready;

// ----------------------------------------------------------------------------
// GTLRCompute_ImageRawDisk.containerType

/** Value: "TAR" */
GTLR_EXTERN NSString * const kGTLRCompute_ImageRawDisk_ContainerType_Tar;

// ----------------------------------------------------------------------------
// GTLRCompute_Instance.status

/** Value: "PROVISIONING" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Provisioning;
/** Value: "RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Running;
/** Value: "STAGING" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Staging;
/** Value: "STOPPED" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Stopped;
/** Value: "STOPPING" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Stopping;
/** Value: "SUSPENDED" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Suspended;
/** Value: "SUSPENDING" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Suspending;
/** Value: "TERMINATED" */
GTLR_EXTERN NSString * const kGTLRCompute_Instance_Status_Terminated;

// ----------------------------------------------------------------------------
// GTLRCompute_InstanceGroupManagersScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_InstanceGroupsListInstancesRequest.instanceState

/** Value: "ALL" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsListInstancesRequest_InstanceState_All;
/** Value: "RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsListInstancesRequest_InstanceState_Running;

// ----------------------------------------------------------------------------
// GTLRCompute_InstanceGroupsScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_InstancesScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_InstancesScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_InstanceWithNamedPorts.status

/** Value: "PROVISIONING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Provisioning;
/** Value: "RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Running;
/** Value: "STAGING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Staging;
/** Value: "STOPPED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Stopped;
/** Value: "STOPPING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Stopping;
/** Value: "SUSPENDED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Suspended;
/** Value: "SUSPENDING" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Suspending;
/** Value: "TERMINATED" */
GTLR_EXTERN NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Terminated;

// ----------------------------------------------------------------------------
// GTLRCompute_MachineTypesScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_ManagedInstance.currentAction

/** Value: "ABANDONING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Abandoning;
/** Value: "CREATING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Creating;
/** Value: "DELETING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Deleting;
/** Value: "NONE" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_None;
/** Value: "RECREATING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Recreating;
/** Value: "REFRESHING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Refreshing;
/** Value: "RESTARTING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Restarting;

// ----------------------------------------------------------------------------
// GTLRCompute_ManagedInstance.instanceStatus

/** Value: "PROVISIONING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Provisioning;
/** Value: "RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Running;
/** Value: "STAGING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Staging;
/** Value: "STOPPED" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Stopped;
/** Value: "STOPPING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Stopping;
/** Value: "SUSPENDED" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Suspended;
/** Value: "SUSPENDING" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Suspending;
/** Value: "TERMINATED" */
GTLR_EXTERN NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Terminated;

// ----------------------------------------------------------------------------
// GTLRCompute_Operation.status

/** Value: "DONE" */
GTLR_EXTERN NSString * const kGTLRCompute_Operation_Status_Done;
/** Value: "PENDING" */
GTLR_EXTERN NSString * const kGTLRCompute_Operation_Status_Pending;
/** Value: "RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_Operation_Status_Running;

// ----------------------------------------------------------------------------
// GTLRCompute_OperationsScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationsScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_OperationWarningsItem.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_OperationWarningsItem_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_Quota.metric

/** Value: "AUTOSCALERS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Autoscalers;
/** Value: "BACKEND_SERVICES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_BackendServices;
/** Value: "CPUS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Cpus;
/** Value: "DISKS_TOTAL_GB" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_DisksTotalGb;
/** Value: "FIREWALLS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Firewalls;
/** Value: "FORWARDING_RULES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_ForwardingRules;
/** Value: "HEALTH_CHECKS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_HealthChecks;
/** Value: "IMAGES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Images;
/** Value: "INSTANCE_GROUP_MANAGERS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_InstanceGroupManagers;
/** Value: "INSTANCE_GROUPS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_InstanceGroups;
/** Value: "INSTANCES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Instances;
/** Value: "INSTANCE_TEMPLATES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_InstanceTemplates;
/** Value: "IN_USE_ADDRESSES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_InUseAddresses;
/** Value: "LOCAL_SSD_TOTAL_GB" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_LocalSsdTotalGb;
/** Value: "NETWORKS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Networks;
/** Value: "ROUTES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Routes;
/** Value: "SNAPSHOTS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Snapshots;
/** Value: "SSD_TOTAL_GB" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_SsdTotalGb;
/** Value: "SSL_CERTIFICATES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_SslCertificates;
/** Value: "STATIC_ADDRESSES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_StaticAddresses;
/** Value: "SUBNETWORKS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_Subnetworks;
/** Value: "TARGET_HTTP_PROXIES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_TargetHttpProxies;
/** Value: "TARGET_HTTPS_PROXIES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_TargetHttpsProxies;
/** Value: "TARGET_INSTANCES" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_TargetInstances;
/** Value: "TARGET_POOLS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_TargetPools;
/** Value: "TARGET_VPN_GATEWAYS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_TargetVpnGateways;
/** Value: "URL_MAPS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_UrlMaps;
/** Value: "VPN_TUNNELS" */
GTLR_EXTERN NSString * const kGTLRCompute_Quota_Metric_VpnTunnels;

// ----------------------------------------------------------------------------
// GTLRCompute_Region.status

/** Value: "DOWN" */
GTLR_EXTERN NSString * const kGTLRCompute_Region_Status_Down;
/** Value: "UP" */
GTLR_EXTERN NSString * const kGTLRCompute_Region_Status_Up;

// ----------------------------------------------------------------------------
// GTLRCompute_RouteWarningsItem.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_RouteWarningsItem_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_Scheduling.onHostMaintenance

/** Value: "MIGRATE" */
GTLR_EXTERN NSString * const kGTLRCompute_Scheduling_OnHostMaintenance_Migrate;
/** Value: "TERMINATE" */
GTLR_EXTERN NSString * const kGTLRCompute_Scheduling_OnHostMaintenance_Terminate;

// ----------------------------------------------------------------------------
// GTLRCompute_Snapshot.status

/** Value: "CREATING" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_Status_Creating;
/** Value: "DELETING" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_Status_Deleting;
/** Value: "FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_Status_Failed;
/** Value: "READY" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_Status_Ready;
/** Value: "UPLOADING" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_Status_Uploading;

// ----------------------------------------------------------------------------
// GTLRCompute_Snapshot.storageBytesStatus

/** Value: "UPDATING" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_StorageBytesStatus_Updating;
/** Value: "UP_TO_DATE" */
GTLR_EXTERN NSString * const kGTLRCompute_Snapshot_StorageBytesStatus_UpToDate;

// ----------------------------------------------------------------------------
// GTLRCompute_SubnetworksScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_TargetInstance.natPolicy

/** Value: "NO_NAT" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstance_NatPolicy_NoNat;

// ----------------------------------------------------------------------------
// GTLRCompute_TargetInstancesScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_TargetPool.sessionAffinity

/** Value: "CLIENT_IP" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPool_SessionAffinity_ClientIp;
/** Value: "CLIENT_IP_PROTO" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPool_SessionAffinity_ClientIpProto;
/** Value: "NONE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPool_SessionAffinity_None;

// ----------------------------------------------------------------------------
// GTLRCompute_TargetPoolsScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_TargetVpnGateway.status

/** Value: "CREATING" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGateway_Status_Creating;
/** Value: "DELETING" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGateway_Status_Deleting;
/** Value: "FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGateway_Status_Failed;
/** Value: "READY" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGateway_Status_Ready;

// ----------------------------------------------------------------------------
// GTLRCompute_TargetVpnGatewaysScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_VpnTunnel.status

/** Value: "ALLOCATING_RESOURCES" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_AllocatingResources;
/** Value: "AUTHORIZATION_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_AuthorizationError;
/** Value: "DEPROVISIONING" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_Deprovisioning;
/** Value: "ESTABLISHED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_Established;
/** Value: "FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_Failed;
/** Value: "FIRST_HANDSHAKE" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_FirstHandshake;
/** Value: "NEGOTIATION_FAILURE" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_NegotiationFailure;
/** Value: "NETWORK_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_NetworkError;
/** Value: "NO_INCOMING_PACKETS" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_NoIncomingPackets;
/** Value: "PROVISIONING" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_Provisioning;
/** Value: "REJECTED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_Rejected;
/** Value: "WAITING_FOR_FULL_CONFIG" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnel_Status_WaitingForFullConfig;

// ----------------------------------------------------------------------------
// GTLRCompute_VpnTunnelsScopedListWarning.code

/** Value: "CLEANUP_FAILED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_CleanupFailed;
/** Value: "DEPRECATED_RESOURCE_USED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_DeprecatedResourceUsed;
/** Value: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_DiskSizeLargerThanImageSize;
/** Value: "INJECTED_KERNELS_DEPRECATED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_InjectedKernelsDeprecated;
/** Value: "NEXT_HOP_ADDRESS_NOT_ASSIGNED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopAddressNotAssigned;
/** Value: "NEXT_HOP_CANNOT_IP_FORWARD" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopCannotIpForward;
/** Value: "NEXT_HOP_INSTANCE_NOT_FOUND" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopInstanceNotFound;
/** Value: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopInstanceNotOnNetwork;
/** Value: "NEXT_HOP_NOT_RUNNING" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopNotRunning;
/** Value: "NO_RESULTS_ON_PAGE" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NoResultsOnPage;
/** Value: "NOT_CRITICAL_ERROR" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NotCriticalError;
/** Value: "REQUIRED_TOS_AGREEMENT" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_RequiredTosAgreement;
/** Value: "RESOURCE_NOT_DELETED" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_ResourceNotDeleted;
/** Value: "SINGLE_INSTANCE_PROPERTY_TEMPLATE" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_SingleInstancePropertyTemplate;
/** Value: "UNREACHABLE" */
GTLR_EXTERN NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_Unreachable;

// ----------------------------------------------------------------------------
// GTLRCompute_Zone.status

/** Value: "DOWN" */
GTLR_EXTERN NSString * const kGTLRCompute_Zone_Status_Down;
/** Value: "UP" */
GTLR_EXTERN NSString * const kGTLRCompute_Zone_Status_Up;

/**
 *  An access configuration attached to an instance's network interface.
 */
@interface GTLRCompute_AccessConfig : GTLRObject

/**
 *  [Output Only] Type of the resource. Always compute#accessConfig for access
 *  configs.
 */
@property(copy, nullable) NSString *kind;

/** Name of this access configuration. */
@property(copy, nullable) NSString *name;

/**
 *  An external IP address associated with this instance. Specify an unused
 *  static external IP address available to the project or leave this field
 *  undefined to use an IP from a shared ephemeral IP address pool. If you
 *  specify a static external IP address, it must live in the same region as the
 *  zone of the instance.
 */
@property(copy, nullable) NSString *natIP;

/**
 *  The type of configuration. The default and only option is ONE_TO_ONE_NAT.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AccessConfig_Type_OneToOneNat Value "ONE_TO_ONE_NAT"
 */
@property(copy, nullable) NSString *type;

@end


/**
 *  A reserved address resource.
 */
@interface GTLRCompute_Address : GTLRObject

/** The static external IP address represented by this resource. */
@property(copy, nullable) NSString *address;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#address for addresses.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  [Output Only] URL of the region where the regional address resides. This
 *  field is not applicable to global addresses.
 */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] The status of the address, which can be either IN_USE or
 *  RESERVED. An address that is RESERVED is currently reserved and available to
 *  use. An IN_USE address is currently being used by another resource and is
 *  not available.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Address_Status_InUse Value "IN_USE"
 *    @arg @c kGTLRCompute_Address_Status_Reserved Value "RESERVED"
 */
@property(copy, nullable) NSString *status;

/** [Output Only] The URLs of the resources that are using this address. */
@property(strong, nullable) NSArray<NSString *> *users;

@end


/**
 *  GTLRCompute_AddressAggregatedList
 */
@interface GTLRCompute_AddressAggregatedList : GTLRObject

/**
 *  [Output Only] Unique identifier for the resource; defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped address lists. */
@property(strong, nullable) GTLRCompute_AddressAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#addressAggregatedList for
 *  aggregated lists of addresses.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped address lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_AddressesScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_AddressAggregatedListItems : GTLRObject
@end


/**
 *  GTLRCompute_AddressesScopedList
 */
@interface GTLRCompute_AddressesScopedList : GTLRObject

/** [Output Only] List of addresses contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_Address *> *addresses;

/**
 *  [Output Only] Informational warning which replaces the list of addresses
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_AddressesScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of addresses
 *  when the list is empty.
 */
@interface GTLRCompute_AddressesScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NoResultsOnPage Value
 *        "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_AddressesScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_AddressesScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_AddressesScopedListWarningDataItem
 */
@interface GTLRCompute_AddressesScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  Contains a list of addresses.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_AddressList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of addresses.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Address *> *items;

/**
 *  [Output Only] Type of resource. Always compute#addressList for lists of
 *  addresses.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  An instance-attached disk resource.
 */
@interface GTLRCompute_AttachedDisk : GTLRObject

/**
 *  Specifies whether the disk will be auto-deleted when the instance is deleted
 *  (but not when the disk is detached from the instance).
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *autoDelete;

/**
 *  Indicates that this is a boot disk. The virtual machine will use the first
 *  partition of the disk for its root filesystem.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *boot;

/**
 *  Specifies a unique device name of your choice that is reflected into the
 *  /dev/disk/by-id/google-* tree of a Linux operating system running within the
 *  instance. This name can be used to reference the device for mounting,
 *  resizing, and so on, from within the instance.
 *  If not specified, the server chooses a default device name to apply to this
 *  disk, in the form persistent-disks-x, where x is a number assigned by Google
 *  Compute Engine. This field is only applicable for persistent disks.
 */
@property(copy, nullable) NSString *deviceName;

/**
 *  Assigns a zero-based index to this disk, where 0 is reserved for the boot
 *  disk. For example, if you have many disks attached to an instance, each disk
 *  would have a unique index number. If not specified, the server will choose
 *  an appropriate value.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *index;

/**
 *  [Input Only] Specifies the parameters for a new disk that will be created
 *  alongside the new instance. Use initialization parameters to create boot
 *  disks or local SSDs attached to the new instance.
 *  This property is mutually exclusive with the source property; you can only
 *  define one or the other, but not both.
 */
@property(strong, nullable) GTLRCompute_AttachedDiskInitializeParams *initializeParams;

/**
 *  Specifies the disk interface to use for attaching this disk, which is either
 *  SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and
 *  the request will fail if you attempt to attach a persistent disk in any
 *  other format than SCSI. Local SSDs can use either NVME or SCSI. For
 *  performance characteristics of SCSI over NVMe, see Local SSD performance.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AttachedDisk_Interface_Nvme Value "NVME"
 *    @arg @c kGTLRCompute_AttachedDisk_Interface_Scsi Value "SCSI"
 */
@property(copy, nullable) NSString *interface;

/**
 *  [Output Only] Type of the resource. Always compute#attachedDisk for attached
 *  disks.
 */
@property(copy, nullable) NSString *kind;

/** [Output Only] Any valid publicly visible licenses. */
@property(strong, nullable) NSArray<NSString *> *licenses;

/**
 *  The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
 *  not specified, the default is to attach the disk in READ_WRITE mode.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AttachedDisk_Mode_ReadOnly Value "READ_ONLY"
 *    @arg @c kGTLRCompute_AttachedDisk_Mode_ReadWrite Value "READ_WRITE"
 */
@property(copy, nullable) NSString *mode;

/**
 *  Specifies a valid partial or full URL to an existing Persistent Disk
 *  resource. This field is only applicable for persistent disks.
 */
@property(copy, nullable) NSString *source;

/**
 *  Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
 *  specified, the default is PERSISTENT.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AttachedDisk_Type_Persistent Value "PERSISTENT"
 *    @arg @c kGTLRCompute_AttachedDisk_Type_Scratch Value "SCRATCH"
 */
@property(copy, nullable) NSString *type;

@end


/**
 *  [Input Only] Specifies the parameters for a new disk that will be created
 *  alongside the new instance. Use initialization parameters to create boot
 *  disks or local SSDs attached to the new instance.
 *  This property is mutually exclusive with the source property; you can only
 *  define one or the other, but not both.
 */
@interface GTLRCompute_AttachedDiskInitializeParams : GTLRObject

/**
 *  Specifies the disk name. If not specified, the default is to use the name of
 *  the instance.
 */
@property(copy, nullable) NSString *diskName;

/**
 *  Specifies the size of the disk in base-2 GB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *diskSizeGb;

/**
 *  Specifies the disk type to use to create the instance. If not specified, the
 *  default is pd-standard, specified using the full URL. For example:
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/pd-standard
 *  Other values include pd-ssd and local-ssd. If you define this field, you can
 *  provide either the full or partial URL. For example, the following are valid
 *  values:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/diskType
 *  - projects/project/zones/zone/diskTypes/diskType
 *  - zones/zone/diskTypes/diskType
 */
@property(copy, nullable) NSString *diskType;

/**
 *  The source image used to create this disk. If the source image is deleted,
 *  this field will not be set.
 *  To create a disk with one of the public operating system images, specify the
 *  image by its family name. For example, specify family/debian-8 to use the
 *  latest Debian 8 image:
 *  projects/debian-cloud/global/images/family/debian-8
 *  Alternatively, use a specific version of a public operating system image:
 *  projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD
 *  To create a disk with a private image that you created, specify the image
 *  name in the following format:
 *  global/images/my-private-image
 *  You can also specify a private image by its image family, which returns the
 *  latest version of the image in that family. Replace the image name with
 *  family/family-name:
 *  global/images/family/my-private-family
 */
@property(copy, nullable) NSString *sourceImage;

@end


/**
 *  Represents an Autoscaler resource. Autoscalers allow you to automatically
 *  scale virtual machine instances in managed instance groups according to an
 *  autoscaling policy that you define. For more information, read Autoscaling
 *  Groups of Instances.
 */
@interface GTLRCompute_Autoscaler : GTLRObject

/**
 *  The configuration parameters for the autoscaling algorithm. You can define
 *  one or more of the policies for an autoscaler: cpuUtilization,
 *  customMetricUtilizations, and loadBalancingUtilization.
 *  If none of these are specified, the default will be to autoscale based on
 *  cpuUtilization to 0.8 or 80%.
 */
@property(strong, nullable) GTLRCompute_AutoscalingPolicy *autoscalingPolicy;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#autoscaler for
 *  autoscalers.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/** URL of the managed instance group that this autoscaler will scale. */
@property(copy, nullable) NSString *target;

/**
 *  [Output Only] URL of the zone where the instance group resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_AutoscalerAggregatedList
 */
@interface GTLRCompute_AutoscalerAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** A map of scoped autoscaler lists. */
@property(strong, nullable) GTLRCompute_AutoscalerAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#autoscalerAggregatedList for
 *  aggregated lists of autoscalers.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A map of scoped autoscaler lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_AutoscalersScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_AutoscalerAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of Autoscaler resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_AutoscalerList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of Autoscaler resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Autoscaler *> *items;

/**
 *  [Output Only] Type of resource. Always compute#autoscalerList for lists of
 *  autoscalers.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_AutoscalersScopedList
 */
@interface GTLRCompute_AutoscalersScopedList : GTLRObject

/** [Output Only] List of autoscalers contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_Autoscaler *> *autoscalers;

/**
 *  [Output Only] Informational warning which replaces the list of autoscalers
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_AutoscalersScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of autoscalers
 *  when the list is empty.
 */
@interface GTLRCompute_AutoscalersScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_AutoscalersScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_AutoscalersScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_AutoscalersScopedListWarningDataItem
 */
@interface GTLRCompute_AutoscalersScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  Cloud Autoscaler policy.
 */
@interface GTLRCompute_AutoscalingPolicy : GTLRObject

/**
 *  The number of seconds that the autoscaler should wait before it starts
 *  collecting information from a new instance. This prevents the autoscaler
 *  from collecting information when the instance is initializing, during which
 *  the collected usage would not be reliable. The default time autoscaler waits
 *  is 60 seconds.
 *  Virtual machine initialization times might vary because of numerous factors.
 *  We recommend that you test how long an instance may take to initialize. To
 *  do this, create an instance and time the startup process.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *coolDownPeriodSec;

/**
 *  Defines the CPU utilization policy that allows the autoscaler to scale based
 *  on the average CPU utilization of a managed instance group.
 */
@property(strong, nullable) GTLRCompute_AutoscalingPolicyCpuUtilization *cpuUtilization;

/** Configuration parameters of autoscaling based on a custom metric. */
@property(strong, nullable) NSArray<GTLRCompute_AutoscalingPolicyCustomMetricUtilization *> *customMetricUtilizations;

/** Configuration parameters of autoscaling based on load balancer. */
@property(strong, nullable) GTLRCompute_AutoscalingPolicyLoadBalancingUtilization *loadBalancingUtilization;

/**
 *  The maximum number of instances that the autoscaler can scale up to. This is
 *  required when creating or updating an autoscaler. The maximum number of
 *  replicas should not be lower than minimal number of replicas.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *maxNumReplicas;

/**
 *  The minimum number of replicas that the autoscaler can scale down to. This
 *  cannot be less than 0. If not provided, autoscaler will choose a default
 *  value depending on maximum number of instances allowed.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *minNumReplicas;

@end


/**
 *  CPU utilization policy.
 */
@interface GTLRCompute_AutoscalingPolicyCpuUtilization : GTLRObject

/**
 *  The target CPU utilization that the autoscaler should maintain. Must be a
 *  float value in the range (0, 1]. If not specified, the default is 0.8.
 *  If the CPU level is below the target utilization, the autoscaler scales down
 *  the number of instances until it reaches the minimum number of instances you
 *  specified or until the average CPU of your instances reaches the target
 *  utilization.
 *  If the average CPU is above the target utilization, the autoscaler scales up
 *  until it reaches the maximum number of instances you specified or until the
 *  average utilization reaches the target utilization.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *utilizationTarget;

@end


/**
 *  Custom utilization metric policy.
 */
@interface GTLRCompute_AutoscalingPolicyCustomMetricUtilization : GTLRObject

/**
 *  The identifier of the Cloud Monitoring metric. The metric cannot have
 *  negative values and should be a utilization metric, which means that the
 *  number of virtual machines handling requests should increase or decrease
 *  proportionally to the metric. The metric must also have a label of
 *  compute.googleapis.com/resource_id with the value of the instance's unique
 *  ID, although this alone does not guarantee that the metric is valid.
 *  For example, the following is a valid metric:
 *  compute.googleapis.com/instance/network/received_bytes_count
 *  The following is not a valid metric because it does not increase or decrease
 *  based on usage:
 *  compute.googleapis.com/instance/cpu/reserved_cores
 */
@property(copy, nullable) NSString *metric;

/**
 *  Target value of the metric which autoscaler should maintain. Must be a
 *  positive value.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *utilizationTarget;

/**
 *  Defines how target utilization value is expressed for a Cloud Monitoring
 *  metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE. If not
 *  specified, the default is GAUGE.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_DeltaPerMinute
 *        Value "DELTA_PER_MINUTE"
 *    @arg @c kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_DeltaPerSecond
 *        Value "DELTA_PER_SECOND"
 *    @arg @c kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_Gauge
 *        Value "GAUGE"
 */
@property(copy, nullable) NSString *utilizationTargetType;

@end


/**
 *  Configuration parameters of autoscaling based on load balancing.
 */
@interface GTLRCompute_AutoscalingPolicyLoadBalancingUtilization : GTLRObject

/**
 *  Fraction of backend capacity utilization (set in HTTP(s) load balancing
 *  configuration) that autoscaler should maintain. Must be a positive float
 *  value. If not defined, the default is 0.8.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *utilizationTarget;

@end


/**
 *  Message containing information of one individual backend.
 */
@interface GTLRCompute_Backend : GTLRObject

/**
 *  Specifies the balancing mode for this backend. For global HTTP(S) load
 *  balancing, the default is UTILIZATION. Valid values are UTILIZATION and
 *  RATE.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Backend_BalancingMode_Rate Value "RATE"
 *    @arg @c kGTLRCompute_Backend_BalancingMode_Utilization Value "UTILIZATION"
 */
@property(copy, nullable) NSString *balancingMode;

/**
 *  A multiplier applied to the group's maximum servicing capacity (either
 *  UTILIZATION or RATE). Default value is 1, which means the group will serve
 *  up to 100% of its configured CPU or RPS (depending on balancingMode). A
 *  setting of 0 means the group is completely drained, offering 0% of its
 *  available CPU or RPS. Valid range is [0.0,1.0].
 *
 *  Uses NSNumber of floatValue.
 */
@property(strong, nullable) NSNumber *capacityScaler;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  The fully-qualified URL of a zonal Instance Group resource. This instance
 *  group defines the list of instances that serve traffic. Member virtual
 *  machine instances from each instance group must live in the same zone as the
 *  instance group itself. No two backends in a backend service are allowed to
 *  use same Instance Group resource.
 *  Note that you must specify an Instance Group resource using the
 *  fully-qualified URL, rather than a partial URL.
 */
@property(copy, nullable) NSString *group;

/**
 *  The max requests per second (RPS) of the group. Can be used with either RATE
 *  or UTILIZATION balancing modes, but required if RATE mode. For RATE mode,
 *  either maxRate or maxRatePerInstance must be set.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *maxRate;

/**
 *  The max requests per second (RPS) that a single backend instance can
 *  handle.This is used to calculate the capacity of the group. Can be used in
 *  either balancing mode. For RATE mode, either maxRate or maxRatePerInstance
 *  must be set.
 *
 *  Uses NSNumber of floatValue.
 */
@property(strong, nullable) NSNumber *maxRatePerInstance;

/**
 *  Used when balancingMode is UTILIZATION. This ratio defines the CPU
 *  utilization target for the group. The default is 0.8. Valid range is [0.0,
 *  1.0].
 *
 *  Uses NSNumber of floatValue.
 */
@property(strong, nullable) NSNumber *maxUtilization;

@end


/**
 *  A BackendService resource. This resource defines a group of backend virtual
 *  machines and their serving capacity.
 */
@interface GTLRCompute_BackendService : GTLRObject

/** The list of backends that serve this BackendService. */
@property(strong, nullable) NSArray<GTLRCompute_Backend *> *backends;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  Fingerprint of this resource. A hash of the contents stored in this object.
 *  This field is used in optimistic locking. This field will be ignored when
 *  inserting a BackendService. An up-to-date fingerprint must be provided in
 *  order to update the BackendService.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/**
 *  The list of URLs to the HttpHealthCheck or HttpsHealthCheck resource for
 *  health checking this BackendService. Currently at most one health check can
 *  be specified, and a health check is required.
 */
@property(strong, nullable) NSArray<NSString *> *healthChecks;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of resource. Always compute#backendService for backend
 *  services.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  Deprecated in favor of portName. The TCP port to connect on the backend. The
 *  default value is 80.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *port;

/**
 *  Name of backend port. The same name should appear in the instance groups
 *  referenced by this service. Required.
 */
@property(copy, nullable) NSString *portName;

/**
 *  The protocol this BackendService uses to communicate with backends.
 *  Possible values are HTTP, HTTPS, HTTP2, TCP and SSL.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_BackendService_Protocol_Http Value "HTTP"
 *    @arg @c kGTLRCompute_BackendService_Protocol_Https Value "HTTPS"
 */
@property(copy, nullable) NSString *protocol;

/**
 *  [Output Only] URL of the region where the regional backend service resides.
 *  This field is not applicable to global backend services.
 */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  How many seconds to wait for the backend before considering it a failed
 *  request. Default is 30 seconds.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *timeoutSec;

@end


/**
 *  GTLRCompute_BackendServiceGroupHealth
 */
@interface GTLRCompute_BackendServiceGroupHealth : GTLRObject

@property(strong, nullable) NSArray<GTLRCompute_HealthStatus *> *healthStatus;

/**
 *  [Output Only] Type of resource. Always compute#backendServiceGroupHealth for
 *  the health of backend services.
 */
@property(copy, nullable) NSString *kind;

@end


/**
 *  Contains a list of BackendService resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_BackendServiceList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of BackendService resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_BackendService *> *items;

/**
 *  [Output Only] Type of resource. Always compute#backendServiceList for lists
 *  of backend services.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  Deprecation status for a public resource.
 */
@interface GTLRCompute_DeprecationStatus : GTLRObject

/**
 *  An optional RFC3339 timestamp on or after which the deprecation state of
 *  this resource will be changed to DELETED.
 */
@property(copy, nullable) NSString *deleted;

/**
 *  An optional RFC3339 timestamp on or after which the deprecation state of
 *  this resource will be changed to DEPRECATED.
 */
@property(copy, nullable) NSString *deprecated;

/**
 *  An optional RFC3339 timestamp on or after which the deprecation state of
 *  this resource will be changed to OBSOLETE.
 */
@property(copy, nullable) NSString *obsolete;

/**
 *  The URL of the suggested replacement for a deprecated resource. The
 *  suggested replacement resource must be the same kind of resource as the
 *  deprecated resource.
 */
@property(copy, nullable) NSString *replacement;

/**
 *  The deprecation state of this resource. This can be DEPRECATED, OBSOLETE, or
 *  DELETED. Operations which create a new resource using a DEPRECATED resource
 *  will return successfully, but with a warning indicating the deprecated
 *  resource and recommending its replacement. Operations which use OBSOLETE or
 *  DELETED resources will be rejected and result in an error.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_DeprecationStatus_State_Deleted Value "DELETED"
 *    @arg @c kGTLRCompute_DeprecationStatus_State_Deprecated Value "DEPRECATED"
 *    @arg @c kGTLRCompute_DeprecationStatus_State_Obsolete Value "OBSOLETE"
 */
@property(copy, nullable) NSString *state;

@end


/**
 *  A Disk resource.
 */
@interface GTLRCompute_Disk : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/** [Output Only] Type of the resource. Always compute#disk for disks. */
@property(copy, nullable) NSString *kind;

/** [Output Only] Last attach timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *lastAttachTimestamp;

/** [Output Only] Last detach timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *lastDetachTimestamp;

/** [Output Only] Any applicable publicly visible licenses. */
@property(strong, nullable) NSArray<NSString *> *licenses;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** Internal use only. */
@property(copy, nullable) NSString *options;

/** [Output Only] Server-defined fully-qualified URL for this resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  Size of the persistent disk, specified in GB. You can specify this field
 *  when creating a persistent disk using the sourceImage or sourceSnapshot
 *  parameter, or specify it alone to create an empty persistent disk.
 *  If you specify this field along with sourceImage or sourceSnapshot, the
 *  value of sizeGb must not be less than the size of the sourceImage or the
 *  size of the snapshot.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *sizeGb;

/**
 *  The source image used to create this disk. If the source image is deleted,
 *  this field will not be set.
 *  To create a disk with one of the public operating system images, specify the
 *  image by its family name. For example, specify family/debian-8 to use the
 *  latest Debian 8 image:
 *  projects/debian-cloud/global/images/family/debian-8
 *  Alternatively, use a specific version of a public operating system image:
 *  projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD
 *  To create a disk with a private image that you created, specify the image
 *  name in the following format:
 *  global/images/my-private-image
 *  You can also specify a private image by its image family, which returns the
 *  latest version of the image in that family. Replace the image name with
 *  family/family-name:
 *  global/images/family/my-private-family
 */
@property(copy, nullable) NSString *sourceImage;

/**
 *  [Output Only] The ID value of the image used to create this disk. This value
 *  identifies the exact image that was used to create this persistent disk. For
 *  example, if you created the persistent disk from an image that was later
 *  deleted and recreated under the same name, the source image ID would
 *  identify the exact version of the image that was used.
 */
@property(copy, nullable) NSString *sourceImageId;

/**
 *  The source snapshot used to create this disk. You can provide this as a
 *  partial or full URL to the resource. For example, the following are valid
 *  values:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot
 *  - projects/project/global/snapshots/snapshot
 *  - global/snapshots/snapshot
 */
@property(copy, nullable) NSString *sourceSnapshot;

/**
 *  [Output Only] The unique ID of the snapshot used to create this disk. This
 *  value identifies the exact snapshot that was used to create this persistent
 *  disk. For example, if you created the persistent disk from a snapshot that
 *  was later deleted and recreated under the same name, the source snapshot ID
 *  would identify the exact version of the snapshot that was used.
 */
@property(copy, nullable) NSString *sourceSnapshotId;

/**
 *  [Output Only] The status of disk creation. Applicable statuses includes:
 *  CREATING, FAILED, READY, RESTORING.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Disk_Status_Creating Value "CREATING"
 *    @arg @c kGTLRCompute_Disk_Status_Failed Value "FAILED"
 *    @arg @c kGTLRCompute_Disk_Status_Ready Value "READY"
 *    @arg @c kGTLRCompute_Disk_Status_Restoring Value "RESTORING"
 */
@property(copy, nullable) NSString *status;

/**
 *  URL of the disk type resource describing which disk type to use to create
 *  the disk. Provide this when creating the disk.
 */
@property(copy, nullable) NSString *type;

/**
 *  [Output Only] Links to the users of the disk (attached instances) in form:
 *  project/zones/zone/instances/instance
 */
@property(strong, nullable) NSArray<NSString *> *users;

/**
 *  [Output Only] URL of the zone where the disk resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_DiskAggregatedList
 */
@interface GTLRCompute_DiskAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped disk lists. */
@property(strong, nullable) GTLRCompute_DiskAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#diskAggregatedList for
 *  aggregated lists of persistent disks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped disk lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_DisksScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_DiskAggregatedListItems : GTLRObject
@end


/**
 *  A list of Disk resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_DiskList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of persistent disks.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Disk *> *items;

/**
 *  [Output Only] Type of resource. Always compute#diskList for lists of disks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_DiskMoveRequest
 */
@interface GTLRCompute_DiskMoveRequest : GTLRObject

/**
 *  The URL of the destination zone to move the disk. This can be a full or
 *  partial URL. For example, the following are all valid URLs to a zone:
 *  - https://www.googleapis.com/compute/v1/projects/project/zones/zone
 *  - projects/project/zones/zone
 *  - zones/zone
 */
@property(copy, nullable) NSString *destinationZone;

/**
 *  The URL of the target disk to move. This can be a full or partial URL. For
 *  example, the following are all valid URLs to a disk:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
 *  - projects/project/zones/zone/disks/disk
 *  - zones/zone/disks/disk
 */
@property(copy, nullable) NSString *targetDisk;

@end


/**
 *  GTLRCompute_DisksResizeRequest
 */
@interface GTLRCompute_DisksResizeRequest : GTLRObject

/**
 *  The new size of the persistent disk, which is specified in GB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *sizeGb;

@end


/**
 *  GTLRCompute_DisksScopedList
 */
@interface GTLRCompute_DisksScopedList : GTLRObject

/** [Output Only] List of disks contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_Disk *> *disks;

/**
 *  [Output Only] Informational warning which replaces the list of disks when
 *  the list is empty.
 */
@property(strong, nullable) GTLRCompute_DisksScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of disks when
 *  the list is empty.
 */
@interface GTLRCompute_DisksScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NextHopNotRunning Value
 *        "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NoResultsOnPage Value
 *        "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_NotCriticalError Value
 *        "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_ResourceNotDeleted Value
 *        "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_DisksScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_DisksScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_DisksScopedListWarningDataItem
 */
@interface GTLRCompute_DisksScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  A DiskType resource.
 */
@interface GTLRCompute_DiskType : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  [Output Only] Server-defined default disk size in GB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *defaultDiskSizeGb;

/** [Output Only] The deprecation status associated with this disk type. */
@property(strong, nullable) GTLRCompute_DeprecationStatus *deprecated;

/**
 *  [Output Only] An optional description of this resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#diskType for disk types.
 */
@property(copy, nullable) NSString *kind;

/** [Output Only] Name of the resource. */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] An optional textual description of the valid disk size, such
 *  as "10GB-10TB".
 */
@property(copy, nullable) NSString *validDiskSize;

/**
 *  [Output Only] URL of the zone where the disk type resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_DiskTypeAggregatedList
 */
@interface GTLRCompute_DiskTypeAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped disk type lists. */
@property(strong, nullable) GTLRCompute_DiskTypeAggregatedListItems *items;

/** [Output Only] Type of resource. Always compute#diskTypeAggregatedList. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped disk type lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_DiskTypesScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_DiskTypeAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of disk types.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_DiskTypeList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Disk Type resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_DiskType *> *items;

/**
 *  [Output Only] Type of resource. Always compute#diskTypeList for disk types.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_DiskTypesScopedList
 */
@interface GTLRCompute_DiskTypesScopedList : GTLRObject

/** [Output Only] List of disk types contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_DiskType *> *diskTypes;

/**
 *  [Output Only] Informational warning which replaces the list of disk types
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_DiskTypesScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of disk types
 *  when the list is empty.
 */
@interface GTLRCompute_DiskTypesScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NoResultsOnPage Value
 *        "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_DiskTypesScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_DiskTypesScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_DiskTypesScopedListWarningDataItem
 */
@interface GTLRCompute_DiskTypesScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  Represents a Firewall resource.
 */
@interface GTLRCompute_Firewall : GTLRObject

/**
 *  The list of rules specified by this firewall. Each rule specifies a protocol
 *  and port-range tuple that describes a permitted connection.
 */
@property(strong, nullable) NSArray<GTLRCompute_FirewallAllowedItem *> *allowed;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Ony] Type of the resource. Always compute#firewall for firewall
 *  rules.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource; provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  URL of the network resource for this firewall rule. If not specified when
 *  creating a firewall rule, the default network is used:
 *  global/networks/default
 *  If you choose to specify this property, you can specify the network as a
 *  full or partial URL. For example, the following are all valid URLs:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
 *  - projects/myproject/global/networks/my-network
 *  - global/networks/default
 */
@property(copy, nullable) NSString *network;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  The IP address blocks that this rule applies to, expressed in CIDR format.
 *  One or both of sourceRanges and sourceTags may be set.
 *  If both properties are set, an inbound connection is allowed if the range
 *  matches the sourceRanges OR the tag of the source matches the sourceTags
 *  property. The connection does not need to match both properties.
 */
@property(strong, nullable) NSArray<NSString *> *sourceRanges;

/**
 *  A list of instance tags which this rule applies to. One or both of
 *  sourceRanges and sourceTags may be set.
 *  If both properties are set, an inbound connection is allowed if the range
 *  matches the sourceRanges OR the tag of the source matches the sourceTags
 *  property. The connection does not need to match both properties.
 *  Source tags cannot be used to allow access to an instance's external IP
 *  address. Because tags are associated with an instance, not an IP address,
 *  source tags can only be used to control traffic traveling from an instance
 *  inside the same network as the firewall.
 */
@property(strong, nullable) NSArray<NSString *> *sourceTags;

/**
 *  A list of instance tags indicating sets of instances located in the network
 *  that may make network connections as specified in allowed[]. If no
 *  targetTags are specified, the firewall rule applies to all instances on the
 *  specified network.
 */
@property(strong, nullable) NSArray<NSString *> *targetTags;

@end


/**
 *  GTLRCompute_FirewallAllowedItem
 */
@interface GTLRCompute_FirewallAllowedItem : GTLRObject

/**
 *  The IP protocol that is allowed for this rule. The protocol type is required
 *  when creating a firewall rule. This value can either be one of the following
 *  well known protocol strings (tcp, udp, icmp, esp, ah, sctp), or the IP
 *  protocol number.
 */
@property(copy, nullable) NSString *IPProtocol;

/**
 *  An optional list of ports which are allowed. This field is only applicable
 *  for UDP or TCP protocol. Each entry must be either an integer or a range. If
 *  not specified, connections through any port are allowed
 *  Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
 */
@property(strong, nullable) NSArray<NSString *> *ports;

@end


/**
 *  Contains a list of firewalls.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_FirewallList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Firewall resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Firewall *> *items;

/**
 *  [Output Only] Type of resource. Always compute#firewallList for lists of
 *  firewalls.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A ForwardingRule resource. A ForwardingRule resource specifies which pool of
 *  target virtual machines to forward a packet to if it matches the given
 *  [IPAddress, IPProtocol, portRange] tuple.
 */
@interface GTLRCompute_ForwardingRule : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  Value of the reserved IP address that this forwarding rule is serving on
 *  behalf of. For global forwarding rules, the address must be a global IP; for
 *  regional forwarding rules, the address must live in the same region as the
 *  forwarding rule. If left empty (default value), an ephemeral IP from the
 *  same scope (global or regional) will be assigned.
 */
@property(copy, nullable) NSString *IPAddress;

/**
 *  The IP protocol to which this rule applies. Valid options are TCP, UDP, ESP,
 *  AH, SCTP or ICMP.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_ForwardingRule_IPProtocol_Ah Value "AH"
 *    @arg @c kGTLRCompute_ForwardingRule_IPProtocol_Esp Value "ESP"
 *    @arg @c kGTLRCompute_ForwardingRule_IPProtocol_Sctp Value "SCTP"
 *    @arg @c kGTLRCompute_ForwardingRule_IPProtocol_Tcp Value "TCP"
 *    @arg @c kGTLRCompute_ForwardingRule_IPProtocol_Udp Value "UDP"
 */
@property(copy, nullable) NSString *IPProtocol;

/**
 *  [Output Only] Type of the resource. Always compute#forwardingRule for
 *  Forwarding Rule resources.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource; provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets addressed
 *  to ports in the specified range will be forwarded to target. Forwarding
 *  rules with the same [IPAddress, IPProtocol] pair must have disjoint port
 *  ranges.
 */
@property(copy, nullable) NSString *portRange;

/**
 *  [Output Only] URL of the region where the regional forwarding rule resides.
 *  This field is not applicable to global forwarding rules.
 */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  The URL of the target resource to receive the matched traffic. For regional
 *  forwarding rules, this target must live in the same region as the forwarding
 *  rule. For global forwarding rules, this target must be a global
 *  TargetHttpProxy or TargetHttpsProxy resource. The forwarded traffic must be
 *  of a type appropriate to the target object. For example, TargetHttpProxy
 *  requires HTTP traffic, and TargetHttpsProxy requires HTTPS traffic.
 */
@property(copy, nullable) NSString *target;

@end


/**
 *  GTLRCompute_ForwardingRuleAggregatedList
 */
@interface GTLRCompute_ForwardingRuleAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** A map of scoped forwarding rule lists. */
@property(strong, nullable) GTLRCompute_ForwardingRuleAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#forwardingRuleAggregatedList
 *  for lists of forwarding rules.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A map of scoped forwarding rule lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_ForwardingRulesScopedList. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_ForwardingRuleAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of ForwardingRule resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_ForwardingRuleList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource. Set by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of ForwardingRule resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_ForwardingRule *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_ForwardingRulesScopedList
 */
@interface GTLRCompute_ForwardingRulesScopedList : GTLRObject

/** List of forwarding rules contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_ForwardingRule *> *forwardingRules;

/**
 *  Informational warning which replaces the list of forwarding rules when the
 *  list is empty.
 */
@property(strong, nullable) GTLRCompute_ForwardingRulesScopedListWarning *warning;

@end


/**
 *  Informational warning which replaces the list of forwarding rules when the
 *  list is empty.
 */
@interface GTLRCompute_ForwardingRulesScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_CleanupFailed
 *        Value "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_ForwardingRulesScopedListWarning_Code_Unreachable
 *        Value "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_ForwardingRulesScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_ForwardingRulesScopedListWarningDataItem
 */
@interface GTLRCompute_ForwardingRulesScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  A full or valid partial URL to a health check. For example, the following
 *  are valid URLs:
 *  -
 *  https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
 *  - projects/project-id/global/httpHealthChecks/health-check
 *  - global/httpHealthChecks/health-check
 */
@interface GTLRCompute_HealthCheckReference : GTLRObject

@property(copy, nullable) NSString *healthCheck;

@end


/**
 *  GTLRCompute_HealthStatus
 */
@interface GTLRCompute_HealthStatus : GTLRObject

/**
 *  Health state of the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_HealthStatus_HealthState_Healthy Value "HEALTHY"
 *    @arg @c kGTLRCompute_HealthStatus_HealthState_Unhealthy Value "UNHEALTHY"
 */
@property(copy, nullable) NSString *healthState;

/** URL of the instance resource. */
@property(copy, nullable) NSString *instance;

/** The IP address represented by this resource. */
@property(copy, nullable) NSString *ipAddress;

/**
 *  The port on the instance.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *port;

@end


/**
 *  UrlMaps A host-matching rule for a URL. If matched, will use the named
 *  PathMatcher to select the BackendService.
 */
@interface GTLRCompute_HostRule : GTLRObject

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  The list of host patterns to match. They must be valid hostnames, except *
 *  will match any string of ([a-z0-9-.]*). In that case, * must be the first
 *  character and must be followed in the pattern by either - or ..
 */
@property(strong, nullable) NSArray<NSString *> *hosts;

/**
 *  The name of the PathMatcher to use to match the path portion of the URL if
 *  the hostRule matches the URL's host portion.
 */
@property(copy, nullable) NSString *pathMatcher;

@end


/**
 *  An HttpHealthCheck resource. This resource defines a template for how
 *  individual instances should be checked for health, via HTTP.
 */
@interface GTLRCompute_HttpHealthCheck : GTLRObject

/**
 *  How often (in seconds) to send a health check. The default value is 5
 *  seconds.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *checkIntervalSec;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  A so-far unhealthy instance will be marked healthy after this many
 *  consecutive successes. The default value is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *healthyThreshold;

/**
 *  The value of the host header in the HTTP health check request. If left empty
 *  (default value), the public IP on behalf of which this health check is
 *  performed will be used.
 */
@property(copy, nullable) NSString *host;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#httpHealthCheck for HTTP
 *  health checks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  The TCP port number for the HTTP health check request. The default value is
 *  80.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *port;

/**
 *  The request path of the HTTP health check request. The default value is /.
 */
@property(copy, nullable) NSString *requestPath;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  How long (in seconds) to wait before claiming failure. The default value is
 *  5 seconds. It is invalid for timeoutSec to have greater value than
 *  checkIntervalSec.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *timeoutSec;

/**
 *  A so-far healthy instance will be marked unhealthy after this many
 *  consecutive failures. The default value is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *unhealthyThreshold;

@end


/**
 *  Contains a list of HttpHealthCheck resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_HttpHealthCheckList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource. Defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of HttpHealthCheck resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_HttpHealthCheck *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  An HttpsHealthCheck resource. This resource defines a template for how
 *  individual instances should be checked for health, via HTTPS.
 */
@interface GTLRCompute_HttpsHealthCheck : GTLRObject

/**
 *  How often (in seconds) to send a health check. The default value is 5
 *  seconds.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *checkIntervalSec;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  A so-far unhealthy instance will be marked healthy after this many
 *  consecutive successes. The default value is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *healthyThreshold;

/**
 *  The value of the host header in the HTTPS health check request. If left
 *  empty (default value), the public IP on behalf of which this health check is
 *  performed will be used.
 */
@property(copy, nullable) NSString *host;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/** Type of the resource. */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  The TCP port number for the HTTPS health check request. The default value is
 *  443.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *port;

/**
 *  The request path of the HTTPS health check request. The default value is
 *  "/".
 */
@property(copy, nullable) NSString *requestPath;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  How long (in seconds) to wait before claiming failure. The default value is
 *  5 seconds. It is invalid for timeoutSec to have a greater value than
 *  checkIntervalSec.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *timeoutSec;

/**
 *  A so-far healthy instance will be marked unhealthy after this many
 *  consecutive failures. The default value is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *unhealthyThreshold;

@end


/**
 *  Contains a list of HttpsHealthCheck resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_HttpsHealthCheckList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource; defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of HttpsHealthCheck resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_HttpsHealthCheck *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  An Image resource.
 */
@interface GTLRCompute_Image : GTLRObject

/**
 *  Size of the image tar.gz archive stored in Google Cloud Storage (in bytes).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *archiveSizeBytes;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/** The deprecation status associated with this image. */
@property(strong, nullable) GTLRCompute_DeprecationStatus *deprecated;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  Size of the image when restored onto a persistent disk (in GB).
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *diskSizeGb;

/**
 *  The name of the image family to which this image belongs. You can create
 *  disks by specifying an image family instead of a specific image name. The
 *  image family always returns its latest image that is not deprecated.
 */
@property(copy, nullable) NSString *family;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/** [Output Only] Type of the resource. Always compute#image for images. */
@property(copy, nullable) NSString *kind;

/** Any applicable publicly visible licenses. */
@property(strong, nullable) NSArray<NSString *> *licenses;

/**
 *  Name of the resource; provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** The parameters of the raw disk image. */
@property(strong, nullable) GTLRCompute_ImageRawDisk *rawDisk;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  URL of the The source disk used to create this image. This can be a full or
 *  valid partial URL. You must provide either this property or the
 *  rawDisk.source property but not both to create an image. For example, the
 *  following are valid values:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/disk/disk
 *  - projects/project/zones/zone/disk/disk
 *  - zones/zone/disks/disk
 */
@property(copy, nullable) NSString *sourceDisk;

/**
 *  The ID value of the disk used to create this image. This value may be used
 *  to determine whether the image was taken from the current or a previous
 *  instance of a given disk name.
 */
@property(copy, nullable) NSString *sourceDiskId;

/**
 *  The type of the image used to create this disk. The default and only value
 *  is RAW
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Image_SourceType_Raw Value "RAW"
 */
@property(copy, nullable) NSString *sourceType;

/**
 *  [Output Only] The status of the image. An image can be used to create other
 *  resources, such as instances, only after the image has been successfully
 *  created and the status is set to READY. Possible values are FAILED, PENDING,
 *  or READY.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Image_Status_Failed Value "FAILED"
 *    @arg @c kGTLRCompute_Image_Status_Pending Value "PENDING"
 *    @arg @c kGTLRCompute_Image_Status_Ready Value "READY"
 */
@property(copy, nullable) NSString *status;

@end


/**
 *  The parameters of the raw disk image.
 */
@interface GTLRCompute_ImageRawDisk : GTLRObject

/**
 *  The format used to encode and transmit the block device, which should be
 *  TAR. This is just a container and transmission format and not a runtime
 *  format. Provided by the client when the disk image is created.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_ImageRawDisk_ContainerType_Tar Value "TAR"
 */
@property(copy, nullable) NSString *containerType;

/**
 *  An optional SHA1 checksum of the disk image before unpackaging; provided by
 *  the client when the disk image is created.
 */
@property(copy, nullable) NSString *sha1Checksum;

/**
 *  The full Google Cloud Storage URL where the disk image is stored. You must
 *  provide either this property or the sourceDisk property but not both.
 */
@property(copy, nullable) NSString *source;

@end


/**
 *  Contains a list of images.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_ImageList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Image resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Image *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  An Instance resource.
 */
@interface GTLRCompute_Instance : GTLRObject

/**
 *  Allows this instance to send and receive packets with non-matching
 *  destination or source IPs. This is required if you plan to use this instance
 *  to forward routes. For more information, see Enabling IP Forwarding.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *canIpForward;

/** [Output Only] The CPU platform used by this instance. */
@property(copy, nullable) NSString *cpuPlatform;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  Array of disks associated with this instance. Persistent disks must be
 *  created before you can assign them.
 */
@property(strong, nullable) NSArray<GTLRCompute_AttachedDisk *> *disks;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#instance for instances.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Full or partial URL of the machine type resource to use for this instance,
 *  in the format: zones/zone/machineTypes/machine-type. This is provided by the
 *  client when the instance is created. For example, the following is a valid
 *  partial url to a predefined machine type:
 *  zones/us-central1-f/machineTypes/n1-standard-1
 *  To create a custom machine type, provide a URL to a machine type in the
 *  following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ...
 *  24, etc), and MEMORY is the total memory for this instance. Memory must be a
 *  multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is 5120
 *  MB):
 *  zones/zone/machineTypes/custom-CPUS-MEMORY
 *  For example: zones/us-central1-f/machineTypes/custom-4-5120
 *  For a full list of restrictions, read the Specifications for custom machine
 *  types.
 */
@property(copy, nullable) NSString *machineType;

/**
 *  The metadata key/value pairs assigned to this instance. This includes custom
 *  metadata and predefined keys.
 */
@property(strong, nullable) GTLRCompute_Metadata *metadata;

/**
 *  The name of the resource, provided by the client when initially creating the
 *  resource. The resource name must be 1-63 characters long, and comply with
 *  RFC1035. Specifically, the name must be 1-63 characters long and match the
 *  regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first
 *  character must be a lowercase letter, and all following characters must be a
 *  dash, lowercase letter, or digit, except the last character, which cannot be
 *  a dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  An array of configurations for this interface. This specifies how this
 *  interface is configured to interact with other network services, such as
 *  connecting to the internet.
 */
@property(strong, nullable) NSArray<GTLRCompute_NetworkInterface *> *networkInterfaces;

/** Scheduling options for this instance. */
@property(strong, nullable) GTLRCompute_Scheduling *scheduling;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  A list of service accounts, with their specified scopes, authorized for this
 *  instance. Service accounts generate access tokens that can be accessed
 *  through the metadata server and used to authenticate applications on the
 *  instance. See Authenticating from Google Compute Engine for more
 *  information.
 */
@property(strong, nullable) NSArray<GTLRCompute_ServiceAccount *> *serviceAccounts;

/**
 *  [Output Only] The status of the instance. One of the following values:
 *  PROVISIONING, STAGING, RUNNING, STOPPING, and TERMINATED.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Instance_Status_Provisioning Value "PROVISIONING"
 *    @arg @c kGTLRCompute_Instance_Status_Running Value "RUNNING"
 *    @arg @c kGTLRCompute_Instance_Status_Staging Value "STAGING"
 *    @arg @c kGTLRCompute_Instance_Status_Stopped Value "STOPPED"
 *    @arg @c kGTLRCompute_Instance_Status_Stopping Value "STOPPING"
 *    @arg @c kGTLRCompute_Instance_Status_Suspended Value "SUSPENDED"
 *    @arg @c kGTLRCompute_Instance_Status_Suspending Value "SUSPENDING"
 *    @arg @c kGTLRCompute_Instance_Status_Terminated Value "TERMINATED"
 */
@property(copy, nullable) NSString *status;

/** [Output Only] An optional, human-readable explanation of the status. */
@property(copy, nullable) NSString *statusMessage;

/**
 *  A list of tags to apply to this instance. Tags are used to identify valid
 *  sources or targets for network firewalls and are specified by the client
 *  during instance creation. The tags can be later modified by the setTags
 *  method. Each tag within the list must comply with RFC1035.
 */
@property(strong, nullable) GTLRCompute_Tags *tags;

/**
 *  [Output Only] URL of the zone where the instance resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_InstanceAggregatedList
 */
@interface GTLRCompute_InstanceAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped instance lists. */
@property(strong, nullable) GTLRCompute_InstanceAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#instanceAggregatedList for
 *  aggregated lists of Instance resources.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped instance lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_InstancesScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_InstanceAggregatedListItems : GTLRObject
@end


/**
 *  GTLRCompute_InstanceGroup
 */
@interface GTLRCompute_InstanceGroup : GTLRObject

/**
 *  [Output Only] The creation timestamp for this instance group in RFC3339 text
 *  format.
 */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The fingerprint of the named ports. The system uses this
 *  fingerprint to detect conflicts when multiple users change the named ports
 *  concurrently.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/**
 *  [Output Only] A unique identifier for this resource type. The server
 *  generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] The resource type, which is always compute#instanceGroup for
 *  instance groups.
 */
@property(copy, nullable) NSString *kind;

/**
 *  The name of the instance group. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(copy, nullable) NSString *name;

/**
 *  Assigns a name to a port number. For example: {name: "http", port: 80}
 *  This allows the system to reference ports by the assigned name instead of a
 *  port number. Named ports can also contain multiple ports. For example:
 *  [{name: "http", port: 80},{name: "http", port: 8080}]
 *  Named ports apply to all instances in this instance group.
 */
@property(strong, nullable) NSArray<GTLRCompute_NamedPort *> *namedPorts;

/**
 *  The URL of the network to which all instances in the instance group belong.
 */
@property(copy, nullable) NSString *network;

/**
 *  [Output Only] The URL for this instance group. The server generates this
 *  URL.
 */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] The total number of instances in the instance group.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *size;

/**
 *  The URL of the subnetwork to which all instances in the instance group
 *  belong.
 */
@property(copy, nullable) NSString *subnetwork;

/**
 *  [Output Only] The URL of the zone where the instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_InstanceGroupAggregatedList
 */
@interface GTLRCompute_InstanceGroupAggregatedList : GTLRObject

/**
 *  [Output Only] A unique identifier for this aggregated list of instance
 *  groups. The server generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** A map of scoped instance group lists. */
@property(strong, nullable) GTLRCompute_InstanceGroupAggregatedListItems *items;

/**
 *  [Output Only] The resource type, which is always
 *  compute#instanceGroupAggregatedList for aggregated lists of instance groups.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/**
 *  [Output Only] The URL for this resource type. The server generates this URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A map of scoped instance group lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_InstanceGroupsScopedList. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_InstanceGroupAggregatedListItems : GTLRObject
@end


/**
 *  A list of InstanceGroup resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_InstanceGroupList : GTLRCollectionObject

/**
 *  [Output Only] A unique identifier for this list of instance groups. The
 *  server generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of instance groups.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceGroup *> *items;

/**
 *  [Output Only] The resource type, which is always compute#instanceGroupList
 *  for instance group lists.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/**
 *  [Output Only] The URL for this resource type. The server generates this URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_InstanceGroupManager
 */
@interface GTLRCompute_InstanceGroupManager : GTLRObject

/**
 *  The base instance name to use for instances in this group. The value must be
 *  1-58 characters long. Instances are named by appending a hyphen and a random
 *  four-character string to the base instance name. The base instance name must
 *  comply with RFC1035.
 */
@property(copy, nullable) NSString *baseInstanceName;

/**
 *  [Output Only] The creation timestamp for this managed instance group in
 *  RFC3339 text format.
 */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  [Output Only] The list of instance actions and the number of instances in
 *  this managed instance group that are scheduled for each of those actions.
 */
@property(strong, nullable) GTLRCompute_InstanceGroupManagerActionsSummary *currentActions;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The fingerprint of the resource data. You can use this
 *  optional field for optimistic locking when you update the resource.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/**
 *  [Output Only] A unique identifier for this resource type. The server
 *  generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/** [Output Only] The URL of the Instance Group resource. */
@property(copy, nullable) NSString *instanceGroup;

/**
 *  The URL of the instance template that is specified for this managed instance
 *  group. The group uses this template to create all new instances in the
 *  managed instance group.
 */
@property(copy, nullable) NSString *instanceTemplate;

/**
 *  [Output Only] The resource type, which is always
 *  compute#instanceGroupManager for managed instance groups.
 */
@property(copy, nullable) NSString *kind;

/**
 *  The name of the managed instance group. The name must be 1-63 characters
 *  long, and comply with RFC1035.
 */
@property(copy, nullable) NSString *name;

/**
 *  Named ports configured for the Instance Groups complementary to this
 *  Instance Group Manager.
 */
@property(strong, nullable) NSArray<GTLRCompute_NamedPort *> *namedPorts;

/**
 *  [Output Only] The URL for this managed instance group. The server defines
 *  this URL.
 */
@property(copy, nullable) NSString *selfLink;

/**
 *  The URLs for all TargetPool resources to which instances in the
 *  instanceGroup field are added. The target pools automatically apply to all
 *  of the instances in the managed instance group.
 */
@property(strong, nullable) NSArray<NSString *> *targetPools;

/**
 *  The target number of running instances for this managed instance group.
 *  Deleting or abandoning instances reduces this number. Resizing the group
 *  changes this number.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *targetSize;

/**
 *  The name of the zone where the managed instance group is located.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_InstanceGroupManagerActionsSummary
 */
@interface GTLRCompute_InstanceGroupManagerActionsSummary : GTLRObject

/**
 *  [Output Only] The total number of instances in the managed instance group
 *  that are scheduled to be abandoned. Abandoning an instance removes it from
 *  the managed instance group without deleting it.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *abandoning;

/**
 *  [Output Only] The number of instances in the managed instance group that are
 *  scheduled to be created or are currently being created. If the group fails
 *  to create one of these instances, it tries again until it creates the
 *  instance successfully.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *creating;

/**
 *  [Output Only] The number of instances in the managed instance group that are
 *  scheduled to be deleted or are currently being deleted.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *deleting;

/**
 *  [Output Only] The number of instances in the managed instance group that are
 *  running and have no scheduled actions.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *none;

/**
 *  [Output Only] The number of instances in the managed instance group that are
 *  scheduled to be recreated or are currently being being recreated. Recreating
 *  an instance deletes the existing root persistent disk and creates a new disk
 *  from the image that is defined in the instance template.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *recreating;

/**
 *  [Output Only] The number of instances in the managed instance group that are
 *  being reconfigured with properties that do not require a restart or a
 *  recreate action. For example, setting or removing target pools for the
 *  instance.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *refreshing;

/**
 *  [Output Only] The number of instances in the managed instance group that are
 *  scheduled to be restarted or are currently being restarted.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *restarting;

@end


/**
 *  GTLRCompute_InstanceGroupManagerAggregatedList
 */
@interface GTLRCompute_InstanceGroupManagerAggregatedList : GTLRObject

/**
 *  [Output Only] A unique identifier for this aggregated list of managed
 *  instance groups. The server generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of filtered managed instance group lists. */
@property(strong, nullable) GTLRCompute_InstanceGroupManagerAggregatedListItems *items;

/**
 *  [Output Only] The resource type, which is always
 *  compute#instanceGroupManagerAggregatedList for an aggregated list of managed
 *  instance groups.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/**
 *  [Output Only] The URL for this resource type. The server generates this URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of filtered managed instance group lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_InstanceGroupManagersScopedList. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRCompute_InstanceGroupManagerAggregatedListItems : GTLRObject
@end


/**
 *  [Output Only] A list of managed instance groups.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_InstanceGroupManagerList : GTLRCollectionObject

/**
 *  [Output Only] A unique identifier for this resource type. The server
 *  generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of managed instance groups.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceGroupManager *> *items;

/**
 *  [Output Only] The resource type, which is always
 *  compute#instanceGroupManagerList for a list of managed instance groups.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/**
 *  [Output Only] The URL for this resource type. The server generates this URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_InstanceGroupManagersAbandonInstancesRequest
 */
@interface GTLRCompute_InstanceGroupManagersAbandonInstancesRequest : GTLRObject

/**
 *  The URL for one or more instances to abandon from the managed instance
 *  group.
 */
@property(strong, nullable) NSArray<NSString *> *instances;

@end


/**
 *  GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
 */
@interface GTLRCompute_InstanceGroupManagersDeleteInstancesRequest : GTLRObject

/**
 *  The list of instances to delete from this managed instance group. Specify
 *  one or more instance URLs.
 */
@property(strong, nullable) NSArray<NSString *> *instances;

@end


/**
 *  GTLRCompute_InstanceGroupManagersListManagedInstancesResponse
 */
@interface GTLRCompute_InstanceGroupManagersListManagedInstancesResponse : GTLRObject

/** [Output Only] The list of instances in the managed instance group. */
@property(strong, nullable) NSArray<GTLRCompute_ManagedInstance *> *managedInstances;

@end


/**
 *  GTLRCompute_InstanceGroupManagersRecreateInstancesRequest
 */
@interface GTLRCompute_InstanceGroupManagersRecreateInstancesRequest : GTLRObject

/** The URL for one or more instances to recreate. */
@property(strong, nullable) NSArray<NSString *> *instances;

@end


/**
 *  GTLRCompute_InstanceGroupManagersScopedList
 */
@interface GTLRCompute_InstanceGroupManagersScopedList : GTLRObject

/**
 *  [Output Only] The list of managed instance groups that are contained in the
 *  specified project and zone.
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceGroupManager *> *instanceGroupManagers;

/**
 *  [Output Only] The warning that replaces the list of managed instance groups
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_InstanceGroupManagersScopedListWarning *warning;

@end


/**
 *  [Output Only] The warning that replaces the list of managed instance groups
 *  when the list is empty.
 */
@interface GTLRCompute_InstanceGroupManagersScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_CleanupFailed
 *        Value "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_Unreachable
 *        Value "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceGroupManagersScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_InstanceGroupManagersScopedListWarningDataItem
 */
@interface GTLRCompute_InstanceGroupManagersScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest
 */
@interface GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest : GTLRObject

/**
 *  The URL of the instance template that is specified for this managed instance
 *  group. The group uses this template to create all new instances in the
 *  managed instance group.
 */
@property(copy, nullable) NSString *instanceTemplate;

@end


/**
 *  GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
 */
@interface GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest : GTLRObject

/**
 *  The fingerprint of the target pools information. Use this optional property
 *  to prevent conflicts when multiple users change the target pools settings
 *  concurrently. Obtain the fingerprint with the instanceGroupManagers.get
 *  method. Then, include the fingerprint in your request to ensure that you do
 *  not overwrite changes that were applied from another concurrent request.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/**
 *  The list of target pool URLs that instances in this managed instance group
 *  belong to. The managed instance group applies these target pools to all of
 *  the instances in the group. Existing instances and new instances in the
 *  group all receive these target pool settings.
 */
@property(strong, nullable) NSArray<NSString *> *targetPools;

@end


/**
 *  GTLRCompute_InstanceGroupsAddInstancesRequest
 */
@interface GTLRCompute_InstanceGroupsAddInstancesRequest : GTLRObject

/** The list of instances to add to the instance group. */
@property(strong, nullable) NSArray<GTLRCompute_InstanceReference *> *instances;

@end


/**
 *  GTLRCompute_InstanceGroupsListInstances
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_InstanceGroupsListInstances : GTLRCollectionObject

/**
 *  [Output Only] A unique identifier for this list of instance groups. The
 *  server generates this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of instances and any named ports that are assigned to
 *  those instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceWithNamedPorts *> *items;

/**
 *  [Output Only] The resource type, which is always
 *  compute#instanceGroupsListInstances for lists of instance groups.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/**
 *  [Output Only] The URL for this list of instance groups. The server generates
 *  this URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_InstanceGroupsListInstancesRequest
 */
@interface GTLRCompute_InstanceGroupsListInstancesRequest : GTLRObject

/**
 *  A filter for the state of the instances in the instance group. Valid options
 *  are ALL or RUNNING. If you do not specify this parameter the list includes
 *  all instances regardless of their state.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_InstanceGroupsListInstancesRequest_InstanceState_All
 *        Value "ALL"
 *    @arg @c kGTLRCompute_InstanceGroupsListInstancesRequest_InstanceState_Running
 *        Value "RUNNING"
 */
@property(copy, nullable) NSString *instanceState;

@end


/**
 *  GTLRCompute_InstanceGroupsRemoveInstancesRequest
 */
@interface GTLRCompute_InstanceGroupsRemoveInstancesRequest : GTLRObject

/** The list of instances to remove from the instance group. */
@property(strong, nullable) NSArray<GTLRCompute_InstanceReference *> *instances;

@end


/**
 *  GTLRCompute_InstanceGroupsScopedList
 */
@interface GTLRCompute_InstanceGroupsScopedList : GTLRObject

/**
 *  [Output Only] The list of instance groups that are contained in this scope.
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceGroup *> *instanceGroups;

/**
 *  [Output Only] An informational warning that replaces the list of instance
 *  groups when the list is empty.
 */
@property(strong, nullable) GTLRCompute_InstanceGroupsScopedListWarning *warning;

@end


/**
 *  [Output Only] An informational warning that replaces the list of instance
 *  groups when the list is empty.
 */
@interface GTLRCompute_InstanceGroupsScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_CleanupFailed
 *        Value "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_InstanceGroupsScopedListWarning_Code_Unreachable
 *        Value "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceGroupsScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_InstanceGroupsScopedListWarningDataItem
 */
@interface GTLRCompute_InstanceGroupsScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_InstanceGroupsSetNamedPortsRequest
 */
@interface GTLRCompute_InstanceGroupsSetNamedPortsRequest : GTLRObject

/**
 *  The fingerprint of the named ports information for this instance group. Use
 *  this optional property to prevent conflicts when multiple users change the
 *  named ports settings concurrently. Obtain the fingerprint with the
 *  instanceGroups.get method. Then, include the fingerprint in your request to
 *  ensure that you do not overwrite changes that were applied from another
 *  concurrent request.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/** The list of named ports to set for this instance group. */
@property(strong, nullable) NSArray<GTLRCompute_NamedPort *> *namedPorts;

@end


/**
 *  Contains a list of instances.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_InstanceList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of instances.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Instance *> *items;

/**
 *  [Output Only] Type of resource. Always compute#instanceList for lists of
 *  Instance resources.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_InstanceMoveRequest
 */
@interface GTLRCompute_InstanceMoveRequest : GTLRObject

/**
 *  The URL of the destination zone to move the instance. This can be a full or
 *  partial URL. For example, the following are all valid URLs to a zone:
 *  - https://www.googleapis.com/compute/v1/projects/project/zones/zone
 *  - projects/project/zones/zone
 *  - zones/zone
 */
@property(copy, nullable) NSString *destinationZone;

/**
 *  The URL of the target instance to move. This can be a full or partial URL.
 *  For example, the following are all valid URLs to an instance:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
 *  - projects/project/zones/zone/instances/instance
 *  - zones/zone/instances/instance
 */
@property(copy, nullable) NSString *targetInstance;

@end


/**
 *  GTLRCompute_InstanceProperties
 */
@interface GTLRCompute_InstanceProperties : GTLRObject

/**
 *  Enables instances created based on this template to send packets with source
 *  IP addresses other than their own and receive packets with destination IP
 *  addresses other than their own. If these instances will be used as an IP
 *  gateway or it will be set as the next-hop in a Route resource, specify true.
 *  If unsure, leave this set to false. See the canIpForward documentation for
 *  more information.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *canIpForward;

/**
 *  An optional text description for the instances that are created from this
 *  instance template.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  An array of disks that are associated with the instances that are created
 *  from this template.
 */
@property(strong, nullable) NSArray<GTLRCompute_AttachedDisk *> *disks;

/**
 *  The machine type to use for instances that are created from this template.
 */
@property(copy, nullable) NSString *machineType;

/**
 *  The metadata key/value pairs to assign to instances that are created from
 *  this template. These pairs can consist of custom metadata or predefined
 *  keys. See Project and instance metadata for more information.
 */
@property(strong, nullable) GTLRCompute_Metadata *metadata;

/** An array of network access configurations for this interface. */
@property(strong, nullable) NSArray<GTLRCompute_NetworkInterface *> *networkInterfaces;

/**
 *  Specifies the scheduling options for the instances that are created from
 *  this template.
 */
@property(strong, nullable) GTLRCompute_Scheduling *scheduling;

/**
 *  A list of service accounts with specified scopes. Access tokens for these
 *  service accounts are available to the instances that are created from this
 *  template. Use metadata queries to obtain the access tokens for these
 *  instances.
 */
@property(strong, nullable) NSArray<GTLRCompute_ServiceAccount *> *serviceAccounts;

/**
 *  A list of tags to apply to the instances that are created from this
 *  template. The tags identify valid sources or targets for network firewalls.
 *  The setTags method can modify this list of tags. Each tag within the list
 *  must comply with RFC1035.
 */
@property(strong, nullable) GTLRCompute_Tags *tags;

@end


/**
 *  GTLRCompute_InstanceReference
 */
@interface GTLRCompute_InstanceReference : GTLRObject

/** The URL for a specific instance. */
@property(copy, nullable) NSString *instance;

@end


/**
 *  GTLRCompute_InstancesScopedList
 */
@interface GTLRCompute_InstancesScopedList : GTLRObject

/** [Output Only] List of instances contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_Instance *> *instances;

/**
 *  [Output Only] Informational warning which replaces the list of instances
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_InstancesScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of instances
 *  when the list is empty.
 */
@interface GTLRCompute_InstancesScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NoResultsOnPage Value
 *        "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_InstancesScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_InstancesScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_InstancesScopedListWarningDataItem
 */
@interface GTLRCompute_InstancesScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_InstancesSetMachineTypeRequest
 */
@interface GTLRCompute_InstancesSetMachineTypeRequest : GTLRObject

/**
 *  Full or partial URL of the machine type resource. See Machine Types for a
 *  full list of machine types. For example:
 *  zones/us-central1-f/machineTypes/n1-standard-1
 */
@property(copy, nullable) NSString *machineType;

@end


/**
 *  An Instance Template resource.
 */
@interface GTLRCompute_InstanceTemplate : GTLRObject

/**
 *  [Output Only] The creation timestamp for this instance template in RFC3339
 *  text format.
 */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] A unique identifier for this instance template. The server
 *  defines this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] The resource type, which is always compute#instanceTemplate
 *  for instance templates.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource; provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** The instance properties for this instance template. */
@property(strong, nullable) GTLRCompute_InstanceProperties *properties;

/**
 *  [Output Only] The URL for this instance template. The server defines this
 *  URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A list of instance templates.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_InstanceTemplateList : GTLRCollectionObject

/**
 *  [Output Only] A unique identifier for this instance template. The server
 *  defines this identifier.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] list of InstanceTemplate resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceTemplate *> *items;

/**
 *  [Output Only] The resource type, which is always
 *  compute#instanceTemplatesListResponse for instance template lists.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/**
 *  [Output Only] The URL for this instance template list. The server defines
 *  this URL.
 */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_InstanceWithNamedPorts
 */
@interface GTLRCompute_InstanceWithNamedPorts : GTLRObject

/** [Output Only] The URL of the instance. */
@property(copy, nullable) NSString *instance;

/** [Output Only] The named ports that belong to this instance group. */
@property(strong, nullable) NSArray<GTLRCompute_NamedPort *> *namedPorts;

/**
 *  [Output Only] The status of the instance.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Provisioning Value
 *        "PROVISIONING"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Running Value "RUNNING"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Staging Value "STAGING"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Stopped Value "STOPPED"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Stopping Value
 *        "STOPPING"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Suspended Value
 *        "SUSPENDED"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Suspending Value
 *        "SUSPENDING"
 *    @arg @c kGTLRCompute_InstanceWithNamedPorts_Status_Terminated Value
 *        "TERMINATED"
 */
@property(copy, nullable) NSString *status;

@end


/**
 *  A license resource.
 */
@interface GTLRCompute_License : GTLRObject

/**
 *  [Output Only] If true, the customer will be charged license fee for running
 *  software that contains this license on an instance.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *chargesUseFee;

/** [Output Only] Type of resource. Always compute#license for licenses. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] Name of the resource. The name is 1-63 characters long and
 *  complies with RFC1035.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A Machine Type resource.
 */
@interface GTLRCompute_MachineType : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/** [Output Only] The deprecation status associated with this machine type. */
@property(strong, nullable) GTLRCompute_DeprecationStatus *deprecated;

/**
 *  [Output Only] An optional textual description of the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The number of virtual CPUs that are available to the instance.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *guestCpus;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Deprecated] This property is deprecated and will never be populated with
 *  any relevant values.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *imageSpaceGb;

/**
 *  [Output Only] The type of the resource. Always compute#machineType for
 *  machine types.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] Maximum persistent disks allowed.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *maximumPersistentDisks;

/**
 *  [Output Only] Maximum total persistent disks size (GB) allowed.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *maximumPersistentDisksSizeGb;

/**
 *  [Output Only] The amount of physical memory available to the instance,
 *  defined in MB.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *memoryMb;

/** [Output Only] Name of the resource. */
@property(copy, nullable) NSString *name;

/** [Output Only] List of extended scratch disks assigned to the instance. */
@property(strong, nullable) NSArray<GTLRCompute_MachineTypeScratchDisksItem *> *scratchDisks;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] The name of the zone where the machine type resides, such as
 *  us-central1-a.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_MachineTypeScratchDisksItem
 */
@interface GTLRCompute_MachineTypeScratchDisksItem : GTLRObject

/**
 *  Size of the scratch disk, defined in GB.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *diskGb;

@end


/**
 *  GTLRCompute_MachineTypeAggregatedList
 */
@interface GTLRCompute_MachineTypeAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped machine type lists. */
@property(strong, nullable) GTLRCompute_MachineTypeAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#machineTypeAggregatedList for
 *  aggregated lists of machine types.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped machine type lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_MachineTypesScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_MachineTypeAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of machine types.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_MachineTypeList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Machine Type resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_MachineType *> *items;

/**
 *  [Output Only] Type of resource. Always compute#machineTypeList for lists of
 *  machine types.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_MachineTypesScopedList
 */
@interface GTLRCompute_MachineTypesScopedList : GTLRObject

/** [Output Only] List of machine types contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_MachineType *> *machineTypes;

/**
 *  [Output Only] An informational warning that appears when the machine types
 *  list is empty.
 */
@property(strong, nullable) GTLRCompute_MachineTypesScopedListWarning *warning;

@end


/**
 *  [Output Only] An informational warning that appears when the machine types
 *  list is empty.
 */
@interface GTLRCompute_MachineTypesScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_CleanupFailed
 *        Value "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_MachineTypesScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_MachineTypesScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_MachineTypesScopedListWarningDataItem
 */
@interface GTLRCompute_MachineTypesScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_ManagedInstance
 */
@interface GTLRCompute_ManagedInstance : GTLRObject

/**
 *  [Output Only] The current action that the managed instance group has
 *  scheduled for the instance. Possible values:
 *  - NONE The instance is running, and the managed instance group does not have
 *  any scheduled actions for this instance.
 *  - CREATING The managed instance group is creating this instance. If the
 *  group fails to create this instance, it will try again until it is
 *  successful.
 *  - CREATING_WITHOUT_RETRIES The managed instance group is attempting to
 *  create this instance only once. If the group fails to create this instance,
 *  it does not try again and the group's target_size value is decreased.
 *  - RECREATING The managed instance group is recreating this instance.
 *  - DELETING The managed instance group is permanently deleting this instance.
 *  - ABANDONING The managed instance group is abandoning this instance. The
 *  instance will be removed from the instance group and from any target pools
 *  that are associated with this group.
 *  - RESTARTING The managed instance group is restarting the instance.
 *  - REFRESHING The managed instance group is applying configuration changes to
 *  the instance without stopping it. For example, the group can update the
 *  target pool list for an instance without stopping that instance.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_Abandoning Value
 *        "ABANDONING"
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_Creating Value
 *        "CREATING"
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_Deleting Value
 *        "DELETING"
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_None Value "NONE"
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_Recreating Value
 *        "RECREATING"
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_Refreshing Value
 *        "REFRESHING"
 *    @arg @c kGTLRCompute_ManagedInstance_CurrentAction_Restarting Value
 *        "RESTARTING"
 */
@property(copy, nullable) NSString *currentAction;

/**
 *  [Output only] The unique identifier for this resource. This field is empty
 *  when instance does not exist.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] The URL of the instance. The URL can exist even if the
 *  instance has not yet been created.
 */
@property(copy, nullable) NSString *instance;

/**
 *  [Output Only] The status of the instance. This field is empty when the
 *  instance does not exist.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Provisioning Value
 *        "PROVISIONING"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Running Value
 *        "RUNNING"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Staging Value
 *        "STAGING"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Stopped Value
 *        "STOPPED"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Stopping Value
 *        "STOPPING"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Suspended Value
 *        "SUSPENDED"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Suspending Value
 *        "SUSPENDING"
 *    @arg @c kGTLRCompute_ManagedInstance_InstanceStatus_Terminated Value
 *        "TERMINATED"
 */
@property(copy, nullable) NSString *instanceStatus;

/**
 *  [Output Only] Information about the last attempt to create or delete the
 *  instance.
 */
@property(strong, nullable) GTLRCompute_ManagedInstanceLastAttempt *lastAttempt;

@end


/**
 *  GTLRCompute_ManagedInstanceLastAttempt
 */
@interface GTLRCompute_ManagedInstanceLastAttempt : GTLRObject

/**
 *  [Output Only] Encountered errors during the last attempt to create or delete
 *  the instance.
 */
@property(strong, nullable) GTLRCompute_ManagedInstanceLastAttemptErrors *errors;

@end


/**
 *  [Output Only] Encountered errors during the last attempt to create or delete
 *  the instance.
 */
@interface GTLRCompute_ManagedInstanceLastAttemptErrors : GTLRObject

/**
 *  [Output Only] The array of errors encountered while processing this
 *  operation.
 */
@property(strong, nullable) NSArray<GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem *> *errors;

@end


/**
 *  GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem
 */
@interface GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem : GTLRObject

/** [Output Only] The error type identifier for this error. */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Indicates the field in the request that caused the error. This
 *  property is optional.
 */
@property(copy, nullable) NSString *location;

/** [Output Only] An optional, human-readable error message. */
@property(copy, nullable) NSString *message;

@end


/**
 *  A metadata key/value entry.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property.
 */
@interface GTLRCompute_Metadata : GTLRCollectionObject

/**
 *  Specifies a fingerprint for this request, which is essentially a hash of the
 *  metadata's contents and used for optimistic locking. The fingerprint is
 *  initially generated by Compute Engine and changes after every request to
 *  modify or update metadata. You must always provide an up-to-date fingerprint
 *  hash in order to update or change metadata.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/**
 *  Array of key/value pairs. The total size of all keys and values must be less
 *  than 512 KB.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_MetadataItemsItem *> *items;

/**
 *  [Output Only] Type of the resource. Always compute#metadata for metadata.
 */
@property(copy, nullable) NSString *kind;

@end


/**
 *  GTLRCompute_MetadataItemsItem
 */
@interface GTLRCompute_MetadataItemsItem : GTLRObject

/**
 *  Key for the metadata entry. Keys must conform to the following regexp:
 *  [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected as
 *  part of a URL in the metadata server. Additionally, to avoid ambiguity, keys
 *  must not conflict with any other metadata keys for the project.
 */
@property(copy, nullable) NSString *key;

/**
 *  Value for the metadata entry. These are free-form strings, and only have
 *  meaning as interpreted by the image running in the instance. The only
 *  restriction placed on values is that their size must be less than or equal
 *  to 32768 bytes.
 */
@property(copy, nullable) NSString *value;

@end


/**
 *  The named port. For example: .
 */
@interface GTLRCompute_NamedPort : GTLRObject

/**
 *  The name for this named port. The name must be 1-63 characters long, and
 *  comply with RFC1035.
 */
@property(copy, nullable) NSString *name;

/**
 *  The port number, which can be a value between 1 and 65535.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *port;

@end


/**
 *  Represents a Network resource. Read Networks and Firewalls for more
 *  information.
 */
@interface GTLRCompute_Network : GTLRObject

/**
 *  When set to true, the network is created in "auto subnet mode". When set to
 *  false, the network is in "custom subnet mode".
 *  In "auto subnet mode", a newly created network is assigned the default CIDR
 *  of 10.128.0.0/9 and it automatically creates one subnetwork per region.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *autoCreateSubnetworks;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  A gateway address for default routing to other networks. This value is read
 *  only and is selected by the Google Compute Engine, typically as the first
 *  usable address in the IPv4Range.
 */
@property(copy, nullable) NSString *gatewayIPv4;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  The range of internal addresses that are legal on this network. This range
 *  is a CIDR specification, for example: 192.168.0.0/16. Provided by the client
 *  when the network is created.
 */
@property(copy, nullable) NSString *IPv4Range;

/**
 *  [Output Only] Type of the resource. Always compute#network for networks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] Server-defined fully-qualified URLs for all subnetworks in
 *  this network.
 */
@property(strong, nullable) NSArray<NSString *> *subnetworks;

@end


/**
 *  A network interface resource attached to an instance.
 */
@interface GTLRCompute_NetworkInterface : GTLRObject

/**
 *  An array of configurations for this interface. Currently, ONE_TO_ONE_NAT is
 *  the only access config supported. If there are no accessConfigs specified,
 *  then this instance will have no external internet access.
 */
@property(strong, nullable) NSArray<GTLRCompute_AccessConfig *> *accessConfigs;

/**
 *  [Output Only] The name of the network interface, generated by the server.
 *  For network devices, these are eth0, eth1, etc.
 */
@property(copy, nullable) NSString *name;

/**
 *  URL of the network resource for this instance. This is required for creating
 *  an instance but optional when creating a firewall rule. If not specified
 *  when creating a firewall rule, the default network is used:
 *  global/networks/default
 *  If you specify this property, you can specify the network as a full or
 *  partial URL. For example, the following are all valid URLs:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/global/networks/network
 *  - projects/project/global/networks/network
 *  - global/networks/default
 */
@property(copy, nullable) NSString *network;

/**
 *  An IPv4 internal network address to assign to the instance for this network
 *  interface. If not specified by the user, an unused internal IP is assigned
 *  by the system.
 */
@property(copy, nullable) NSString *networkIP;

/**
 *  The URL of the Subnetwork resource for this instance. If the network
 *  resource is in legacy mode, do not provide this property. If the network is
 *  in auto subnet mode, providing the subnetwork is optional. If the network is
 *  in custom subnet mode, then this field should be specified. If you specify
 *  this property, you can specify the subnetwork as a full or partial URL. For
 *  example, the following are all valid URLs:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/regions/region/subnetworks/subnetwork
 *  - regions/region/subnetworks/subnetwork
 */
@property(copy, nullable) NSString *subnetwork;

@end


/**
 *  Contains a list of networks.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_NetworkList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Network resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Network *> *items;

/**
 *  [Output Only] Type of resource. Always compute#networkList for lists of
 *  networks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource . */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  An Operation resource, used to manage asynchronous API requests.
 */
@interface GTLRCompute_Operation : GTLRObject

/** [Output Only] Reserved for future use. */
@property(copy, nullable) NSString *clientOperationId;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  [Output Only] A textual description of the operation, which is set when the
 *  operation is created.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The time that this operation was completed. This value is in
 *  RFC3339 text format.
 */
@property(copy, nullable) NSString *endTime;

/**
 *  [Output Only] If errors are generated during processing of the operation,
 *  this field will be populated.
 */
@property(strong, nullable) GTLRCompute_OperationError *error;

/**
 *  [Output Only] If the operation fails, this field contains the HTTP error
 *  message that was returned, such as NOT FOUND.
 */
@property(copy, nullable) NSString *httpErrorMessage;

/**
 *  [Output Only] If the operation fails, this field contains the HTTP error
 *  status code that was returned. For example, a 404 means the resource was not
 *  found.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *httpErrorStatusCode;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] The time that this operation was requested. This value is in
 *  RFC3339 text format.
 */
@property(copy, nullable) NSString *insertTime;

/**
 *  [Output Only] Type of the resource. Always compute#operation for Operation
 *  resources.
 */
@property(copy, nullable) NSString *kind;

/** [Output Only] Name of the resource. */
@property(copy, nullable) NSString *name;

/**
 *  [Output Only] The type of operation, such as insert, update, or delete, and
 *  so on.
 */
@property(copy, nullable) NSString *operationType;

/**
 *  [Output Only] An optional progress indicator that ranges from 0 to 100.
 *  There is no requirement that this be linear or support any granularity of
 *  operations. This should not be used to guess when the operation will be
 *  complete. This number should monotonically increase as the operation
 *  progresses.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *progress;

/**
 *  [Output Only] The URL of the region where the operation resides. Only
 *  available when performing regional operations.
 */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] The time that this operation was started by the server. This
 *  value is in RFC3339 text format.
 */
@property(copy, nullable) NSString *startTime;

/**
 *  [Output Only] The status of the operation, which can be one of the
 *  following: PENDING, RUNNING, or DONE.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Operation_Status_Done Value "DONE"
 *    @arg @c kGTLRCompute_Operation_Status_Pending Value "PENDING"
 *    @arg @c kGTLRCompute_Operation_Status_Running Value "RUNNING"
 */
@property(copy, nullable) NSString *status;

/**
 *  [Output Only] An optional textual description of the current status of the
 *  operation.
 */
@property(copy, nullable) NSString *statusMessage;

/**
 *  [Output Only] The unique target ID, which identifies a specific incarnation
 *  of the target resource.
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *targetId;

/** [Output Only] The URL of the resource that the operation modifies. */
@property(copy, nullable) NSString *targetLink;

/**
 *  [Output Only] User who requested the operation, for example:
 *  user\@example.com.
 */
@property(copy, nullable) NSString *user;

/**
 *  [Output Only] If warning messages are generated during processing of the
 *  operation, this field will be populated.
 */
@property(strong, nullable) NSArray<GTLRCompute_OperationWarningsItem *> *warnings;

/**
 *  [Output Only] The URL of the zone where the operation resides. Only
 *  available when performing per-zone operations.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  [Output Only] If errors are generated during processing of the operation,
 *  this field will be populated.
 */
@interface GTLRCompute_OperationError : GTLRObject

/**
 *  [Output Only] The array of errors encountered while processing this
 *  operation.
 */
@property(strong, nullable) NSArray<GTLRCompute_OperationErrorErrorsItem *> *errors;

@end


/**
 *  GTLRCompute_OperationWarningsItem
 */
@interface GTLRCompute_OperationWarningsItem : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NextHopNotRunning Value
 *        "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NoResultsOnPage Value
 *        "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_NotCriticalError Value
 *        "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_RequiredTosAgreement Value
 *        "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_ResourceNotDeleted Value
 *        "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_OperationWarningsItem_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_OperationWarningsItemDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_OperationErrorErrorsItem
 */
@interface GTLRCompute_OperationErrorErrorsItem : GTLRObject

/** [Output Only] The error type identifier for this error. */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Indicates the field in the request that caused the error. This
 *  property is optional.
 */
@property(copy, nullable) NSString *location;

/** [Output Only] An optional, human-readable error message. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_OperationWarningsItemDataItem
 */
@interface GTLRCompute_OperationWarningsItemDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_OperationAggregatedList
 */
@interface GTLRCompute_OperationAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped operation lists. */
@property(strong, nullable) GTLRCompute_OperationAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#operationAggregatedList for
 *  aggregated lists of operations.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped operation lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_OperationsScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_OperationAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of Operation resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_OperationList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Operation resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Operation *> *items;

/**
 *  [Output Only] Type of resource. Always compute#operations for Operations
 *  resource.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_OperationsScopedList
 */
@interface GTLRCompute_OperationsScopedList : GTLRObject

/** [Output Only] List of operations contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_Operation *> *operations;

/**
 *  [Output Only] Informational warning which replaces the list of operations
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_OperationsScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of operations
 *  when the list is empty.
 */
@interface GTLRCompute_OperationsScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_OperationsScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_OperationsScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_OperationsScopedListWarningDataItem
 */
@interface GTLRCompute_OperationsScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  A matcher for the path portion of the URL. The BackendService from the
 *  longest-matched rule will serve the URL. If no rule was matched, the default
 *  service will be used.
 */
@interface GTLRCompute_PathMatcher : GTLRObject

/**
 *  The full or partial URL to the BackendService resource. This will be used if
 *  none of the pathRules defined by this PathMatcher is matched by the URL's
 *  path portion. For example, the following are all valid URLs to a
 *  BackendService resource:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
 *  - compute/v1/projects/project/global/backendServices/backendService
 *  - global/backendServices/backendService
 */
@property(copy, nullable) NSString *defaultService;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/** The name to which this PathMatcher is referred by the HostRule. */
@property(copy, nullable) NSString *name;

/** The list of path rules. */
@property(strong, nullable) NSArray<GTLRCompute_PathRule *> *pathRules;

@end


/**
 *  A path-matching rule for a URL. If matched, will use the specified
 *  BackendService to handle the traffic arriving at this URL.
 */
@interface GTLRCompute_PathRule : GTLRObject

/**
 *  The list of path patterns to match. Each must start with / and the only
 *  place a * is allowed is at the end following a /. The string fed to the path
 *  matcher does not include any text after the first ? or #, and those chars
 *  are not allowed here.
 */
@property(strong, nullable) NSArray<NSString *> *paths;

/** The URL of the BackendService resource if this rule is matched. */
@property(copy, nullable) NSString *service;

@end


/**
 *  A Project resource. Projects can only be created in the Google Cloud
 *  Platform Console. Unless marked otherwise, values can only be modified in
 *  the console.
 */
@interface GTLRCompute_Project : GTLRObject

/**
 *  Metadata key/value pairs available to all instances contained in this
 *  project. See Custom metadata for more information.
 */
@property(strong, nullable) GTLRCompute_Metadata *commonInstanceMetadata;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional textual description of the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/** Restricted features enabled for use on this project. */
@property(strong, nullable) NSArray<NSString *> *enabledFeatures;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server. This is not the project ID, and is just a unique ID
 *  used by Compute Engine to identify resources.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#project for projects.
 */
@property(copy, nullable) NSString *kind;

/**
 *  The project ID. For example: my-example-project. Use the project ID to make
 *  requests to Compute Engine.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Quotas assigned to this project. */
@property(strong, nullable) NSArray<GTLRCompute_Quota *> *quotas;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  The naming prefix for daily usage reports and the Google Cloud Storage
 *  bucket where they are stored.
 */
@property(strong, nullable) GTLRCompute_UsageExportLocation *usageExportLocation;

@end


/**
 *  A quotas entry.
 */
@interface GTLRCompute_Quota : GTLRObject

/**
 *  [Output Only] Quota limit for this metric.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *limit;

/**
 *  [Output Only] Name of the quota metric.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Quota_Metric_Autoscalers Value "AUTOSCALERS"
 *    @arg @c kGTLRCompute_Quota_Metric_BackendServices Value "BACKEND_SERVICES"
 *    @arg @c kGTLRCompute_Quota_Metric_Cpus Value "CPUS"
 *    @arg @c kGTLRCompute_Quota_Metric_DisksTotalGb Value "DISKS_TOTAL_GB"
 *    @arg @c kGTLRCompute_Quota_Metric_Firewalls Value "FIREWALLS"
 *    @arg @c kGTLRCompute_Quota_Metric_ForwardingRules Value "FORWARDING_RULES"
 *    @arg @c kGTLRCompute_Quota_Metric_HealthChecks Value "HEALTH_CHECKS"
 *    @arg @c kGTLRCompute_Quota_Metric_Images Value "IMAGES"
 *    @arg @c kGTLRCompute_Quota_Metric_InstanceGroupManagers Value
 *        "INSTANCE_GROUP_MANAGERS"
 *    @arg @c kGTLRCompute_Quota_Metric_InstanceGroups Value "INSTANCE_GROUPS"
 *    @arg @c kGTLRCompute_Quota_Metric_Instances Value "INSTANCES"
 *    @arg @c kGTLRCompute_Quota_Metric_InstanceTemplates Value
 *        "INSTANCE_TEMPLATES"
 *    @arg @c kGTLRCompute_Quota_Metric_InUseAddresses Value "IN_USE_ADDRESSES"
 *    @arg @c kGTLRCompute_Quota_Metric_LocalSsdTotalGb Value
 *        "LOCAL_SSD_TOTAL_GB"
 *    @arg @c kGTLRCompute_Quota_Metric_Networks Value "NETWORKS"
 *    @arg @c kGTLRCompute_Quota_Metric_Routes Value "ROUTES"
 *    @arg @c kGTLRCompute_Quota_Metric_Snapshots Value "SNAPSHOTS"
 *    @arg @c kGTLRCompute_Quota_Metric_SsdTotalGb Value "SSD_TOTAL_GB"
 *    @arg @c kGTLRCompute_Quota_Metric_SslCertificates Value "SSL_CERTIFICATES"
 *    @arg @c kGTLRCompute_Quota_Metric_StaticAddresses Value "STATIC_ADDRESSES"
 *    @arg @c kGTLRCompute_Quota_Metric_Subnetworks Value "SUBNETWORKS"
 *    @arg @c kGTLRCompute_Quota_Metric_TargetHttpProxies Value
 *        "TARGET_HTTP_PROXIES"
 *    @arg @c kGTLRCompute_Quota_Metric_TargetHttpsProxies Value
 *        "TARGET_HTTPS_PROXIES"
 *    @arg @c kGTLRCompute_Quota_Metric_TargetInstances Value "TARGET_INSTANCES"
 *    @arg @c kGTLRCompute_Quota_Metric_TargetPools Value "TARGET_POOLS"
 *    @arg @c kGTLRCompute_Quota_Metric_TargetVpnGateways Value
 *        "TARGET_VPN_GATEWAYS"
 *    @arg @c kGTLRCompute_Quota_Metric_UrlMaps Value "URL_MAPS"
 *    @arg @c kGTLRCompute_Quota_Metric_VpnTunnels Value "VPN_TUNNELS"
 */
@property(copy, nullable) NSString *metric;

/**
 *  [Output Only] Current usage of this metric.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(strong, nullable) NSNumber *usage;

@end


/**
 *  Region resource.
 */
@interface GTLRCompute_Region : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/** [Output Only] The deprecation status associated with this region. */
@property(strong, nullable) GTLRCompute_DeprecationStatus *deprecated;

/**
 *  [Output Only] Textual description of the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/** [Output Only] Type of the resource. Always compute#region for regions. */
@property(copy, nullable) NSString *kind;

/** [Output Only] Name of the resource. */
@property(copy, nullable) NSString *name;

/** [Output Only] Quotas assigned to this region. */
@property(strong, nullable) NSArray<GTLRCompute_Quota *> *quotas;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] Status of the region, either UP or DOWN.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Region_Status_Down Value "DOWN"
 *    @arg @c kGTLRCompute_Region_Status_Up Value "UP"
 */
@property(copy, nullable) NSString *status;

/**
 *  [Output Only] A list of zones available in this region, in the form of
 *  resource URLs.
 */
@property(strong, nullable) NSArray<NSString *> *zones;

@end


/**
 *  Contains a list of region resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_RegionList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Region resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Region *> *items;

/**
 *  [Output Only] Type of resource. Always compute#regionList for lists of
 *  regions.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_ResourceGroupReference
 */
@interface GTLRCompute_ResourceGroupReference : GTLRObject

/**
 *  A URI referencing one of the resource views listed in the backend service.
 */
@property(copy, nullable) NSString *group;

@end


/**
 *  Represents a Route resource. A route specifies how certain packets should be
 *  handled by the network. Routes are associated with instances by tags and the
 *  set of routes for a particular instance is called its routing table.
 *  For each packet leaving a instance, the system searches that instance's
 *  routing table for a single best matching route. Routes match packets by
 *  destination IP address, preferring smaller or more specific ranges over
 *  larger ones. If there is a tie, the system selects the route with the
 *  smallest priority value. If there is still a tie, it uses the layer three
 *  and four packet headers to select just one of the remaining matching routes.
 *  The packet is then forwarded as specified by the nextHop field of the
 *  winning route - either to another instance destination, a instance gateway
 *  or a Google Compute Engine-operated gateway.
 *  Packets that do not match any route in the sending instance's routing table
 *  are dropped.
 */
@interface GTLRCompute_Route : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/** The destination range of outgoing packets that this route applies to. */
@property(copy, nullable) NSString *destRange;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of this resource. Always compute#routes for Route
 *  resources.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** Fully-qualified URL of the network that this route applies to. */
@property(copy, nullable) NSString *network;

/**
 *  The URL to a gateway that should handle matching packets. You can only
 *  specify the internet gateway using a full or partial valid URL:
 *  projects/<project-id>/global/gateways/default-internet-gateway
 */
@property(copy, nullable) NSString *nextHopGateway;

/**
 *  The URL to an instance that should handle matching packets. You can specify
 *  this as a full or partial URL. For example:
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
 */
@property(copy, nullable) NSString *nextHopInstance;

/**
 *  The network IP address of an instance that should handle matching packets.
 */
@property(copy, nullable) NSString *nextHopIp;

/** The URL of the local network if it should handle matching packets. */
@property(copy, nullable) NSString *nextHopNetwork;

/** The URL to a VpnTunnel that should handle matching packets. */
@property(copy, nullable) NSString *nextHopVpnTunnel;

/**
 *  The priority of this route. Priority is used to break ties in cases where
 *  there is more than one matching route of equal prefix length. In the case of
 *  two routes with equal prefix length, the one with the lowest-numbered
 *  priority value wins. Default value is 1000. Valid range is 0 through 65535.
 *
 *  Uses NSNumber of unsignedIntValue.
 */
@property(strong, nullable) NSNumber *priority;

/** [Output Only] Server-defined fully-qualified URL for this resource. */
@property(copy, nullable) NSString *selfLink;

/** A list of instance tags to which this route applies. */
@property(strong, nullable) NSArray<NSString *> *tags;

/**
 *  [Output Only] If potential misconfigurations are detected for this route,
 *  this field will be populated with warning messages.
 */
@property(strong, nullable) NSArray<GTLRCompute_RouteWarningsItem *> *warnings;

@end


/**
 *  GTLRCompute_RouteWarningsItem
 */
@interface GTLRCompute_RouteWarningsItem : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_DeprecatedResourceUsed Value
 *        "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NextHopCannotIpForward Value
 *        "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NextHopInstanceNotFound Value
 *        "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NextHopNotRunning Value
 *        "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NoResultsOnPage Value
 *        "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_NotCriticalError Value
 *        "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_RequiredTosAgreement Value
 *        "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_ResourceNotDeleted Value
 *        "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_RouteWarningsItem_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_RouteWarningsItemDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_RouteWarningsItemDataItem
 */
@interface GTLRCompute_RouteWarningsItemDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  Contains a list of Route resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_RouteList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource. Defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Route resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Route *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  Sets the scheduling options for an Instance.
 */
@interface GTLRCompute_Scheduling : GTLRObject

/**
 *  Specifies whether the instance should be automatically restarted if it is
 *  terminated by Compute Engine (not terminated by a user). You can only set
 *  the automatic restart option for standard instances. Preemptible instances
 *  cannot be automatically restarted.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *automaticRestart;

/**
 *  Defines the maintenance behavior for this instance. For standard instances,
 *  the default behavior is MIGRATE. For preemptible instances, the default and
 *  only possible behavior is TERMINATE. For more information, see Setting
 *  Instance Scheduling Options.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Scheduling_OnHostMaintenance_Migrate Value "MIGRATE"
 *    @arg @c kGTLRCompute_Scheduling_OnHostMaintenance_Terminate Value
 *        "TERMINATE"
 */
@property(copy, nullable) NSString *onHostMaintenance;

/**
 *  Whether the instance is preemptible.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *preemptible;

@end


/**
 *  An instance's serial console output.
 */
@interface GTLRCompute_SerialPortOutput : GTLRObject

/** [Output Only] The contents of the console output. */
@property(copy, nullable) NSString *contents;

/**
 *  [Output Only] Type of the resource. Always compute#serialPortOutput for
 *  serial port output.
 */
@property(copy, nullable) NSString *kind;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A service account.
 */
@interface GTLRCompute_ServiceAccount : GTLRObject

/** Email address of the service account. */
@property(copy, nullable) NSString *email;

/** The list of scopes to be made available for this service account. */
@property(strong, nullable) NSArray<NSString *> *scopes;

@end


/**
 *  A persistent disk snapshot resource.
 */
@interface GTLRCompute_Snapshot : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] Size of the snapshot, specified in GB.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *diskSizeGb;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#snapshot for Snapshot
 *  resources.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] A list of public visible licenses that apply to this snapshot.
 *  This can be because the original image had licenses attached (such as a
 *  Windows image).
 */
@property(strong, nullable) NSArray<NSString *> *licenses;

/**
 *  Name of the resource; provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/** [Output Only] The source disk used to create this snapshot. */
@property(copy, nullable) NSString *sourceDisk;

/**
 *  [Output Only] The ID value of the disk used to create this snapshot. This
 *  value may be used to determine whether the snapshot was taken from the
 *  current or a previous instance of a given disk name.
 */
@property(copy, nullable) NSString *sourceDiskId;

/**
 *  [Output Only] The status of the snapshot. This can be CREATING, DELETING,
 *  FAILED, READY, or UPLOADING.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Snapshot_Status_Creating Value "CREATING"
 *    @arg @c kGTLRCompute_Snapshot_Status_Deleting Value "DELETING"
 *    @arg @c kGTLRCompute_Snapshot_Status_Failed Value "FAILED"
 *    @arg @c kGTLRCompute_Snapshot_Status_Ready Value "READY"
 *    @arg @c kGTLRCompute_Snapshot_Status_Uploading Value "UPLOADING"
 */
@property(copy, nullable) NSString *status;

/**
 *  [Output Only] A size of the the storage used by the snapshot. As snapshots
 *  share storage, this number is expected to change with snapshot
 *  creation/deletion.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(strong, nullable) NSNumber *storageBytes;

/**
 *  [Output Only] An indicator whether storageBytes is in a stable state or it
 *  is being adjusted as a result of shared storage reallocation. This status
 *  can either be UPDATING, meaning the size of the snapshot is being updated,
 *  or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Snapshot_StorageBytesStatus_Updating Value "UPDATING"
 *    @arg @c kGTLRCompute_Snapshot_StorageBytesStatus_UpToDate Value
 *        "UP_TO_DATE"
 */
@property(copy, nullable) NSString *storageBytesStatus;

@end


/**
 *  Contains a list of Snapshot resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_SnapshotList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Snapshot resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Snapshot *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  An SslCertificate resource. This resource provides a mechanism to upload an
 *  SSL key and certificate to the load balancer to serve secure connections
 *  from the user.
 */
@interface GTLRCompute_SslCertificate : GTLRObject

/**
 *  A local certificate file. The certificate must be in PEM format. The
 *  certificate chain must be no greater than 5 certs long. The chain must
 *  include at least one intermediate cert.
 */
@property(copy, nullable) NSString *certificate;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#sslCertificate for SSL
 *  certificates.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  A write-only private key in PEM format. Only insert RPCs will include this
 *  field.
 */
@property(copy, nullable) NSString *privateKey;

/** [Output only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  Contains a list of SslCertificate resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_SslCertificateList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource. Defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of SslCertificate resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_SslCertificate *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A Subnetwork resource.
 */
@interface GTLRCompute_Subnetwork : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The gateway address for default routes to reach destination
 *  addresses outside this subnetwork.
 */
@property(copy, nullable) NSString *gatewayAddress;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  The range of internal addresses that are owned by this subnetwork. Provide
 *  this property when you create the subnetwork. For example, 10.0.0.0/8 or
 *  192.168.0.0/16. Ranges must be unique and non-overlapping within a network.
 */
@property(copy, nullable) NSString *ipCidrRange;

/**
 *  [Output Only] Type of the resource. Always compute#subnetwork for Subnetwork
 *  resources.
 */
@property(copy, nullable) NSString *kind;

/**
 *  The name of the resource, provided by the client when initially creating the
 *  resource. The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  The URL of the network to which this subnetwork belongs, provided by the
 *  client when initially creating the subnetwork. Only networks that are in the
 *  distributed mode can have subnetworks.
 */
@property(copy, nullable) NSString *network;

/** URL of the region where the Subnetwork resides. */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_SubnetworkAggregatedList
 */
@interface GTLRCompute_SubnetworkAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output] A map of scoped Subnetwork lists. */
@property(strong, nullable) GTLRCompute_SubnetworkAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#subnetworkAggregatedList for
 *  aggregated lists of subnetworks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output] A map of scoped Subnetwork lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_SubnetworksScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_SubnetworkAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of Subnetwork resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_SubnetworkList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  The Subnetwork resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Subnetwork *> *items;

/**
 *  [Output Only] Type of resource. Always compute#subnetworkList for lists of
 *  subnetworks.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_SubnetworksScopedList
 */
@interface GTLRCompute_SubnetworksScopedList : GTLRObject

/** List of subnetworks contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_Subnetwork *> *subnetworks;

/**
 *  An informational warning that appears when the list of addresses is empty.
 */
@property(strong, nullable) GTLRCompute_SubnetworksScopedListWarning *warning;

@end


/**
 *  An informational warning that appears when the list of addresses is empty.
 */
@interface GTLRCompute_SubnetworksScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_SubnetworksScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_SubnetworksScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_SubnetworksScopedListWarningDataItem
 */
@interface GTLRCompute_SubnetworksScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  A set of instance tags.
 */
@interface GTLRCompute_Tags : GTLRObject

/**
 *  Specifies a fingerprint for this request, which is essentially a hash of the
 *  metadata's contents and used for optimistic locking. The fingerprint is
 *  initially generated by Compute Engine and changes after every request to
 *  modify or update metadata. You must always provide an up-to-date fingerprint
 *  hash in order to update or change metadata.
 *  To see the latest fingerprint, make get() request to the instance.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/**
 *  An array of tags. Each tag must be 1-63 characters long, and comply with
 *  RFC1035.
 */
@property(strong, nullable) NSArray<NSString *> *items;

@end


/**
 *  A TargetHttpProxy resource. This resource defines an HTTP proxy.
 */
@interface GTLRCompute_TargetHttpProxy : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of resource. Always compute#targetHttpProxy for target
 *  HTTP proxies.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  URL to the UrlMap resource that defines the mapping from URL to the
 *  BackendService.
 */
@property(copy, nullable) NSString *urlMap;

@end


/**
 *  A list of TargetHttpProxy resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_TargetHttpProxyList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of TargetHttpProxy resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetHttpProxy *> *items;

/**
 *  Type of resource. Always compute#targetHttpProxyList for lists of target
 *  HTTP proxies.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
 */
@interface GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest : GTLRObject

/**
 *  New set of SslCertificate resources to associate with this TargetHttpsProxy
 *  resource. Currently exactly one SslCertificate resource must be specified.
 */
@property(strong, nullable) NSArray<NSString *> *sslCertificates;

@end


/**
 *  A TargetHttpsProxy resource. This resource defines an HTTPS proxy.
 */
@interface GTLRCompute_TargetHttpsProxy : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of resource. Always compute#targetHttpsProxy for target
 *  HTTPS proxies.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  URLs to SslCertificate resources that are used to authenticate connections
 *  between users and the load balancer. Currently, exactly one SSL certificate
 *  must be specified.
 */
@property(strong, nullable) NSArray<NSString *> *sslCertificates;

/**
 *  A fully-qualified or valid partial URL to the UrlMap resource that defines
 *  the mapping from URL to the BackendService. For example, the following are
 *  all valid URLs for specifying a URL map:
 *  - https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
 *  - projects/project/global/urlMaps/url-map
 *  - global/urlMaps/url-map
 */
@property(copy, nullable) NSString *urlMap;

@end


/**
 *  Contains a list of TargetHttpsProxy resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_TargetHttpsProxyList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of TargetHttpsProxy resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetHttpsProxy *> *items;

/**
 *  Type of resource. Always compute#targetHttpsProxyList for lists of target
 *  HTTPS proxies.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A TargetInstance resource. This resource defines an endpoint instance that
 *  terminates traffic of certain protocols.
 */
@interface GTLRCompute_TargetInstance : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  A URL to the virtual machine instance that handles traffic for this target
 *  instance. When creating a target instance, you can provide the
 *  fully-qualified URL or a valid partial URL to the desired virtual machine.
 *  For example, the following are all valid URLs:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
 *  - projects/project/zones/zone/instances/instance
 *  - zones/zone/instances/instance
 */
@property(copy, nullable) NSString *instance;

/**
 *  [Output Only] The type of the resource. Always compute#targetInstance for
 *  target instances.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  NAT option controlling how IPs are NAT'ed to the instance. Currently only
 *  NO_NAT (default value) is supported.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_TargetInstance_NatPolicy_NoNat Value "NO_NAT"
 */
@property(copy, nullable) NSString *natPolicy;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] URL of the zone where the target instance resides.
 *
 *  Remapped to 'zoneProperty' to avoid NSObject's 'zone'.
 */
@property(copy, nullable) NSString *zoneProperty;

@end


/**
 *  GTLRCompute_TargetInstanceAggregatedList
 */
@interface GTLRCompute_TargetInstanceAggregatedList : GTLRObject

/**
 *  [Output Only] Unique identifier for the resource; defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** A map of scoped target instance lists. */
@property(strong, nullable) GTLRCompute_TargetInstanceAggregatedListItems *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A map of scoped target instance lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_TargetInstancesScopedList. Use @c -additionalJSONKeys and
 *        @c -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_TargetInstanceAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of TargetInstance resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_TargetInstanceList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of TargetInstance resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetInstance *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_TargetInstancesScopedList
 */
@interface GTLRCompute_TargetInstancesScopedList : GTLRObject

/** List of target instances contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_TargetInstance *> *targetInstances;

/**
 *  Informational warning which replaces the list of addresses when the list is
 *  empty.
 */
@property(strong, nullable) GTLRCompute_TargetInstancesScopedListWarning *warning;

@end


/**
 *  Informational warning which replaces the list of addresses when the list is
 *  empty.
 */
@interface GTLRCompute_TargetInstancesScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_CleanupFailed
 *        Value "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_TargetInstancesScopedListWarning_Code_Unreachable
 *        Value "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetInstancesScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_TargetInstancesScopedListWarningDataItem
 */
@interface GTLRCompute_TargetInstancesScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  A TargetPool resource. This resource defines a pool of instances, associated
 *  HttpHealthCheck resources, and the fallback target pool.
 */
@interface GTLRCompute_TargetPool : GTLRObject

/**
 *  This field is applicable only when the containing target pool is serving a
 *  forwarding rule as the primary pool, and its failoverRatio field is properly
 *  set to a value between [0, 1].
 *  backupPool and failoverRatio together define the fallback behavior of the
 *  primary target pool: if the ratio of the healthy instances in the primary
 *  pool is at or below failoverRatio, traffic arriving at the load-balanced IP
 *  will be directed to the backup pool.
 *  In case where failoverRatio and backupPool are not set, or all the instances
 *  in the backup pool are unhealthy, the traffic will be directed back to the
 *  primary pool in the "force" mode, where traffic will be spread to the
 *  healthy instances with the best effort, or to all instances when no instance
 *  is healthy.
 */
@property(copy, nullable) NSString *backupPool;

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  This field is applicable only when the containing target pool is serving a
 *  forwarding rule as the primary pool (i.e., not as a backup pool to some
 *  other target pool). The value of the field must be in [0, 1].
 *  If set, backupPool must also be set. They together define the fallback
 *  behavior of the primary target pool: if the ratio of the healthy instances
 *  in the primary pool is at or below this number, traffic arriving at the
 *  load-balanced IP will be directed to the backup pool.
 *  In case where failoverRatio is not set or all the instances in the backup
 *  pool are unhealthy, the traffic will be directed back to the primary pool in
 *  the "force" mode, where traffic will be spread to the healthy instances with
 *  the best effort, or to all instances when no instance is healthy.
 *
 *  Uses NSNumber of floatValue.
 */
@property(strong, nullable) NSNumber *failoverRatio;

/**
 *  A list of URLs to the HttpHealthCheck resource. A member instance in this
 *  pool is considered healthy if and only if all specified health checks pass.
 *  An empty list means all member instances will be considered healthy at all
 *  times.
 */
@property(strong, nullable) NSArray<NSString *> *healthChecks;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  A list of resource URLs to the virtual machine instances serving this pool.
 *  They must live in zones contained in the same region as this pool.
 */
@property(strong, nullable) NSArray<NSString *> *instances;

/**
 *  [Output Only] Type of the resource. Always compute#targetPool for target
 *  pools.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** [Output Only] URL of the region where the target pool resides. */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  Sesssion affinity option, must be one of the following values:
 *  NONE: Connections from the same client IP may go to any instance in the
 *  pool.
 *  CLIENT_IP: Connections from the same client IP will go to the same instance
 *  in the pool while that instance remains healthy.
 *  CLIENT_IP_PROTO: Connections from the same client IP with the same IP
 *  protocol will go to the same instance in the pool while that instance
 *  remains healthy.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_TargetPool_SessionAffinity_ClientIp Value "CLIENT_IP"
 *    @arg @c kGTLRCompute_TargetPool_SessionAffinity_ClientIpProto Value
 *        "CLIENT_IP_PROTO"
 *    @arg @c kGTLRCompute_TargetPool_SessionAffinity_None Value "NONE"
 */
@property(copy, nullable) NSString *sessionAffinity;

@end


/**
 *  GTLRCompute_TargetPoolAggregatedList
 */
@interface GTLRCompute_TargetPoolAggregatedList : GTLRObject

/**
 *  [Output Only] Unique identifier for the resource. Defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped target pool lists. */
@property(strong, nullable) GTLRCompute_TargetPoolAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#targetPoolAggregatedList for
 *  aggregated lists of target pools.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped target pool lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_TargetPoolsScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_TargetPoolAggregatedListItems : GTLRObject
@end


/**
 *  GTLRCompute_TargetPoolInstanceHealth
 */
@interface GTLRCompute_TargetPoolInstanceHealth : GTLRObject

@property(strong, nullable) NSArray<GTLRCompute_HealthStatus *> *healthStatus;

/**
 *  [Output Only] Type of resource. Always compute#targetPoolInstanceHealth when
 *  checking the health of an instance.
 */
@property(copy, nullable) NSString *kind;

@end


/**
 *  Contains a list of TargetPool resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_TargetPoolList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource. Defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of TargetPool resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetPool *> *items;

/**
 *  [Output Only] Type of resource. Always compute#targetPoolList for lists of
 *  target pools.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_TargetPoolsAddHealthCheckRequest
 */
@interface GTLRCompute_TargetPoolsAddHealthCheckRequest : GTLRObject

/** A list of HttpHealthCheck resources to add to the target pool. */
@property(strong, nullable) NSArray<GTLRCompute_HealthCheckReference *> *healthChecks;

@end


/**
 *  GTLRCompute_TargetPoolsAddInstanceRequest
 */
@interface GTLRCompute_TargetPoolsAddInstanceRequest : GTLRObject

/**
 *  A full or partial URL to an instance to add to this target pool. This can be
 *  a full or partial URL. For example, the following are valid URLs:
 *  -
 *  https://www.googleapis.com/compute/v1/projects/project-id/zones/zone/instances/instance-name
 *  - projects/project-id/zones/zone/instances/instance-name
 *  - zones/zone/instances/instance-name
 */
@property(strong, nullable) NSArray<GTLRCompute_InstanceReference *> *instances;

@end


/**
 *  GTLRCompute_TargetPoolsRemoveHealthCheckRequest
 */
@interface GTLRCompute_TargetPoolsRemoveHealthCheckRequest : GTLRObject

/**
 *  Health check URL to be removed. This can be a full or valid partial URL. For
 *  example, the following are valid URLs:
 *  -
 *  https://www.googleapis.com/compute/beta/projects/project/global/httpHealthChecks/health-check
 *  - projects/project/global/httpHealthChecks/health-check
 *  - global/httpHealthChecks/health-check
 */
@property(strong, nullable) NSArray<GTLRCompute_HealthCheckReference *> *healthChecks;

@end


/**
 *  GTLRCompute_TargetPoolsRemoveInstanceRequest
 */
@interface GTLRCompute_TargetPoolsRemoveInstanceRequest : GTLRObject

/** URLs of the instances to be removed from target pool. */
@property(strong, nullable) NSArray<GTLRCompute_InstanceReference *> *instances;

@end


/**
 *  GTLRCompute_TargetPoolsScopedList
 */
@interface GTLRCompute_TargetPoolsScopedList : GTLRObject

/** List of target pools contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_TargetPool *> *targetPools;

/**
 *  Informational warning which replaces the list of addresses when the list is
 *  empty.
 */
@property(strong, nullable) GTLRCompute_TargetPoolsScopedListWarning *warning;

@end


/**
 *  Informational warning which replaces the list of addresses when the list is
 *  empty.
 */
@interface GTLRCompute_TargetPoolsScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_TargetPoolsScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetPoolsScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_TargetPoolsScopedListWarningDataItem
 */
@interface GTLRCompute_TargetPoolsScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_TargetReference
 */
@interface GTLRCompute_TargetReference : GTLRObject

@property(copy, nullable) NSString *target;

@end


/**
 *  Represents a Target VPN gateway resource.
 */
@interface GTLRCompute_TargetVpnGateway : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] A list of URLs to the ForwardingRule resources.
 *  ForwardingRules are created using compute.forwardingRules.insert and
 *  associated to a VPN gateway.
 */
@property(strong, nullable) NSArray<NSString *> *forwardingRules;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of resource. Always compute#targetVpnGateway for target
 *  VPN gateways.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/**
 *  URL of the network to which this VPN gateway is attached. Provided by the
 *  client when the VPN gateway is created.
 */
@property(copy, nullable) NSString *network;

/** [Output Only] URL of the region where the target VPN gateway resides. */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] The status of the VPN gateway.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_TargetVpnGateway_Status_Creating Value "CREATING"
 *    @arg @c kGTLRCompute_TargetVpnGateway_Status_Deleting Value "DELETING"
 *    @arg @c kGTLRCompute_TargetVpnGateway_Status_Failed Value "FAILED"
 *    @arg @c kGTLRCompute_TargetVpnGateway_Status_Ready Value "READY"
 */
@property(copy, nullable) NSString *status;

/**
 *  [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are created
 *  using compute.vpntunnels.insert method and associated to a VPN gateway.
 */
@property(strong, nullable) NSArray<NSString *> *tunnels;

@end


/**
 *  GTLRCompute_TargetVpnGatewayAggregatedList
 */
@interface GTLRCompute_TargetVpnGatewayAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** A map of scoped target vpn gateway lists. */
@property(strong, nullable) GTLRCompute_TargetVpnGatewayAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#targetVpnGateway for target
 *  VPN gateways.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  A map of scoped target vpn gateway lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_TargetVpnGatewaysScopedList. Use @c -additionalJSONKeys
 *        and @c -additionalPropertyForName: to get the list of properties and
 *        then fetch them; or @c -additionalProperties to fetch them all at
 *        once.
 */
@interface GTLRCompute_TargetVpnGatewayAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of TargetVpnGateway resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_TargetVpnGatewayList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of TargetVpnGateway resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetVpnGateway *> *items;

/**
 *  [Output Only] Type of resource. Always compute#targetVpnGateway for target
 *  VPN gateways.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_TargetVpnGatewaysScopedList
 */
@interface GTLRCompute_TargetVpnGatewaysScopedList : GTLRObject

/** [Output Only] List of target vpn gateways contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_TargetVpnGateway *> *targetVpnGateways;

/**
 *  [Output Only] Informational warning which replaces the list of addresses
 *  when the list is empty.
 */
@property(strong, nullable) GTLRCompute_TargetVpnGatewaysScopedListWarning *warning;

@end


/**
 *  [Output Only] Informational warning which replaces the list of addresses
 *  when the list is empty.
 */
@interface GTLRCompute_TargetVpnGatewaysScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_CleanupFailed
 *        Value "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_Unreachable
 *        Value "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem
 */
@interface GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  GTLRCompute_TestFailure
 */
@interface GTLRCompute_TestFailure : GTLRObject

@property(copy, nullable) NSString *actualService;
@property(copy, nullable) NSString *expectedService;
@property(copy, nullable) NSString *host;
@property(copy, nullable) NSString *path;

@end


/**
 *  A UrlMap resource. This resource defines the mapping from URL to the
 *  BackendService resource, based on the "longest-match" of the URL's host and
 *  path.
 */
@interface GTLRCompute_UrlMap : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/** The URL of the BackendService resource if none of the hostRules match. */
@property(copy, nullable) NSString *defaultService;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  Fingerprint of this resource. A hash of the contents stored in this object.
 *  This field is used in optimistic locking. This field will be ignored when
 *  inserting a UrlMap. An up-to-date fingerprint must be provided in order to
 *  update the UrlMap.
 *
 *  Contains encoded binary data; GTLRBase64 can encode/decode (probably
 *  web-safe format).
 */
@property(copy, nullable) NSString *fingerprint;

/** The list of HostRules to use against the URL. */
@property(strong, nullable) NSArray<GTLRCompute_HostRule *> *hostRules;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  [Output Only] Type of the resource. Always compute#urlMaps for url maps.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** The list of named PathMatchers to use against the URL. */
@property(strong, nullable) NSArray<GTLRCompute_PathMatcher *> *pathMatchers;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  The list of expected URL mappings. Request to update this UrlMap will
 *  succeed only if all of the test cases pass.
 */
@property(strong, nullable) NSArray<GTLRCompute_UrlMapTest *> *tests;

@end


/**
 *  Contains a list of UrlMap resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_UrlMapList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource. Set by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  A list of UrlMap resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_UrlMap *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_UrlMapReference
 */
@interface GTLRCompute_UrlMapReference : GTLRObject

@property(copy, nullable) NSString *urlMap;

@end


/**
 *  GTLRCompute_UrlMapsValidateRequest
 */
@interface GTLRCompute_UrlMapsValidateRequest : GTLRObject

/** Content of the UrlMap to be validated. */
@property(strong, nullable) GTLRCompute_UrlMap *resource;

@end


/**
 *  GTLRCompute_UrlMapsValidateResponse
 */
@interface GTLRCompute_UrlMapsValidateResponse : GTLRObject

@property(strong, nullable) GTLRCompute_UrlMapValidationResult *result;

@end


/**
 *  Message for the expected URL mappings.
 */
@interface GTLRCompute_UrlMapTest : GTLRObject

/**
 *  Description of this test case.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/** Host portion of the URL. */
@property(copy, nullable) NSString *host;

/** Path portion of the URL. */
@property(copy, nullable) NSString *path;

/** Expected BackendService resource the given URL should be mapped to. */
@property(copy, nullable) NSString *service;

@end


/**
 *  Message representing the validation result for a UrlMap.
 */
@interface GTLRCompute_UrlMapValidationResult : GTLRObject

@property(strong, nullable) NSArray<NSString *> *loadErrors;

/**
 *  Whether the given UrlMap can be successfully loaded. If false, 'loadErrors'
 *  indicates the reasons.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *loadSucceeded;

@property(strong, nullable) NSArray<GTLRCompute_TestFailure *> *testFailures;

/**
 *  If successfully loaded, this field indicates whether the test passed. If
 *  false, 'testFailures's indicate the reason of failure.
 *
 *  Uses NSNumber of boolValue.
 */
@property(strong, nullable) NSNumber *testPassed;

@end


/**
 *  The location in Cloud Storage and naming method of the daily usage report.
 *  Contains bucket_name and report_name prefix.
 */
@interface GTLRCompute_UsageExportLocation : GTLRObject

/**
 *  The name of an existing bucket in Cloud Storage where the usage report
 *  object is stored. The Google Service Account is granted write access to this
 *  bucket. This can either be the bucket name by itself, such as
 *  example-bucket, or the bucket name with gs:// or
 *  https://storage.googleapis.com/ in front of it, such as gs://example-bucket.
 */
@property(copy, nullable) NSString *bucketName;

/**
 *  An optional prefix for the name of the usage report object stored in
 *  bucketName. If not supplied, defaults to usage. The report is stored as a
 *  CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the day
 *  of the usage according to Pacific Time. If you supply a prefix, it should
 *  conform to Cloud Storage object naming conventions.
 */
@property(copy, nullable) NSString *reportNamePrefix;

@end


/**
 *  GTLRCompute_VpnTunnel
 */
@interface GTLRCompute_VpnTunnel : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/**
 *  An optional description of this resource. Provide this property when you
 *  create the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/** [Output Only] Detailed status message for the VPN tunnel. */
@property(copy, nullable) NSString *detailedStatus;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/**
 *  IKE protocol version to use when establishing the VPN tunnel with peer VPN
 *  gateway. Acceptable IKE versions are 1 or 2. Default version is 2.
 *
 *  Uses NSNumber of intValue.
 */
@property(strong, nullable) NSNumber *ikeVersion;

/**
 *  [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
 */
@property(copy, nullable) NSString *kind;

/**
 *  Local traffic selector to use when establishing the VPN tunnel with peer VPN
 *  gateway. The value should be a CIDR formatted string, for example:
 *  192.168.0.0/16. The ranges should be disjoint.
 */
@property(strong, nullable) NSArray<NSString *> *localTrafficSelector;

/**
 *  Name of the resource. Provided by the client when the resource is created.
 *  The name must be 1-63 characters long, and comply with RFC1035.
 *  Specifically, the name must be 1-63 characters long and match the regular
 *  expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must
 *  be a lowercase letter, and all following characters must be a dash,
 *  lowercase letter, or digit, except the last character, which cannot be a
 *  dash.
 */
@property(copy, nullable) NSString *name;

/** IP address of the peer VPN gateway. */
@property(copy, nullable) NSString *peerIp;

/** [Output Only] URL of the region where the VPN tunnel resides. */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  Shared secret used to set the secure session between the Cloud VPN gateway
 *  and the peer VPN gateway.
 */
@property(copy, nullable) NSString *sharedSecret;

/** Hash of the shared secret. */
@property(copy, nullable) NSString *sharedSecretHash;

/**
 *  [Output Only] The status of the VPN tunnel.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_VpnTunnel_Status_AllocatingResources Value
 *        "ALLOCATING_RESOURCES"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_AuthorizationError Value
 *        "AUTHORIZATION_ERROR"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_Deprovisioning Value
 *        "DEPROVISIONING"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_Established Value "ESTABLISHED"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_Failed Value "FAILED"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_FirstHandshake Value
 *        "FIRST_HANDSHAKE"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_NegotiationFailure Value
 *        "NEGOTIATION_FAILURE"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_NetworkError Value "NETWORK_ERROR"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_NoIncomingPackets Value
 *        "NO_INCOMING_PACKETS"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_Provisioning Value "PROVISIONING"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_Rejected Value "REJECTED"
 *    @arg @c kGTLRCompute_VpnTunnel_Status_WaitingForFullConfig Value
 *        "WAITING_FOR_FULL_CONFIG"
 */
@property(copy, nullable) NSString *status;

/**
 *  URL of the VPN gateway with which this VPN tunnel is associated. Provided by
 *  the client when the VPN tunnel is created.
 */
@property(copy, nullable) NSString *targetVpnGateway;

@end


/**
 *  GTLRCompute_VpnTunnelAggregatedList
 */
@interface GTLRCompute_VpnTunnelAggregatedList : GTLRObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/** [Output Only] A map of scoped vpn tunnel lists. */
@property(strong, nullable) GTLRCompute_VpnTunnelAggregatedListItems *items;

/**
 *  [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  [Output Only] A map of scoped vpn tunnel lists.
 *
 *  @note This class is documented as having more properties of
 *        GTLRCompute_VpnTunnelsScopedList. Use @c -additionalJSONKeys and @c
 *        -additionalPropertyForName: to get the list of properties and then
 *        fetch them; or @c -additionalProperties to fetch them all at once.
 */
@interface GTLRCompute_VpnTunnelAggregatedListItems : GTLRObject
@end


/**
 *  Contains a list of VpnTunnel resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_VpnTunnelList : GTLRCollectionObject

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of VpnTunnel resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_VpnTunnel *> *items;

/**
 *  [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
 */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

@end


/**
 *  GTLRCompute_VpnTunnelsScopedList
 */
@interface GTLRCompute_VpnTunnelsScopedList : GTLRObject

/** List of vpn tunnels contained in this scope. */
@property(strong, nullable) NSArray<GTLRCompute_VpnTunnel *> *vpnTunnels;

/**
 *  Informational warning which replaces the list of addresses when the list is
 *  empty.
 */
@property(strong, nullable) GTLRCompute_VpnTunnelsScopedListWarning *warning;

@end


/**
 *  Informational warning which replaces the list of addresses when the list is
 *  empty.
 */
@interface GTLRCompute_VpnTunnelsScopedListWarning : GTLRObject

/**
 *  [Output Only] A warning code, if applicable. For example, Compute Engine
 *  returns NO_RESULTS_ON_PAGE if there are no results in the response.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_CleanupFailed Value
 *        "CLEANUP_FAILED"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_DeprecatedResourceUsed
 *        Value "DEPRECATED_RESOURCE_USED"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_DiskSizeLargerThanImageSize
 *        Value "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_InjectedKernelsDeprecated
 *        Value "INJECTED_KERNELS_DEPRECATED"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopAddressNotAssigned
 *        Value "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopCannotIpForward
 *        Value "NEXT_HOP_CANNOT_IP_FORWARD"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopInstanceNotFound
 *        Value "NEXT_HOP_INSTANCE_NOT_FOUND"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopInstanceNotOnNetwork
 *        Value "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopNotRunning
 *        Value "NEXT_HOP_NOT_RUNNING"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NoResultsOnPage
 *        Value "NO_RESULTS_ON_PAGE"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_NotCriticalError
 *        Value "NOT_CRITICAL_ERROR"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_RequiredTosAgreement
 *        Value "REQUIRED_TOS_AGREEMENT"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_ResourceNotDeleted
 *        Value "RESOURCE_NOT_DELETED"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_SingleInstancePropertyTemplate
 *        Value "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
 *    @arg @c kGTLRCompute_VpnTunnelsScopedListWarning_Code_Unreachable Value
 *        "UNREACHABLE"
 */
@property(copy, nullable) NSString *code;

/**
 *  [Output Only] Metadata about this warning in key: value format. For example:
 *  "data": [ { "key": "scope", "value": "zones/us-east1-d" }
 */
@property(strong, nullable) NSArray<GTLRCompute_VpnTunnelsScopedListWarningDataItem *> *data;

/** [Output Only] A human-readable description of the warning code. */
@property(copy, nullable) NSString *message;

@end


/**
 *  GTLRCompute_VpnTunnelsScopedListWarningDataItem
 */
@interface GTLRCompute_VpnTunnelsScopedListWarningDataItem : GTLRObject

/**
 *  [Output Only] A key that provides more detail on the warning being returned.
 *  For example, for warnings where there are no results in a list request for a
 *  particular zone, this key might be scope and the key value might be the zone
 *  name. Other examples might be a key indicating a deprecated resource and a
 *  suggested replacement, or a warning about invalid network settings (for
 *  example, if an instance attempts to perform IP forwarding but is not enabled
 *  for IP forwarding).
 */
@property(copy, nullable) NSString *key;

/** [Output Only] A warning data value corresponding to the key. */
@property(copy, nullable) NSString *value;

@end


/**
 *  A Zone resource.
 */
@interface GTLRCompute_Zone : GTLRObject

/** [Output Only] Creation timestamp in RFC3339 text format. */
@property(copy, nullable) NSString *creationTimestamp;

/** [Output Only] The deprecation status associated with this zone. */
@property(strong, nullable) GTLRCompute_DeprecationStatus *deprecated;

/**
 *  [Output Only] Textual description of the resource.
 *
 *  Remapped to 'descriptionProperty' to avoid NSObject's 'description'.
 */
@property(copy, nullable) NSString *descriptionProperty;

/**
 *  [Output Only] The unique identifier for the resource. This identifier is
 *  defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 *
 *  Uses NSNumber of unsignedLongLongValue.
 */
@property(strong, nullable) NSNumber *identifier;

/** [Output Only] Type of the resource. Always compute#zone for zones. */
@property(copy, nullable) NSString *kind;

/** [Output Only] Name of the resource. */
@property(copy, nullable) NSString *name;

/** [Output Only] Full URL reference to the region which hosts the zone. */
@property(copy, nullable) NSString *region;

/** [Output Only] Server-defined URL for the resource. */
@property(copy, nullable) NSString *selfLink;

/**
 *  [Output Only] Status of the zone, either UP or DOWN.
 *
 *  Likely values:
 *    @arg @c kGTLRCompute_Zone_Status_Down Value "DOWN"
 *    @arg @c kGTLRCompute_Zone_Status_Up Value "UP"
 */
@property(copy, nullable) NSString *status;

@end


/**
 *  Contains a list of zone resources.
 *
 *  @note This class supports NSFastEnumeration and indexed subscripting over
 *        its "items" property. If returned as the result of a query, it should
 *        support automatic pagination (when @c shouldFetchNextPages is
 *        enabled).
 */
@interface GTLRCompute_ZoneList : GTLRCollectionObject

/**
 *  [Output Only] Unique identifier for the resource; defined by the server.
 *
 *  identifier property maps to 'id' in JSON (to avoid Objective C's 'id').
 */
@property(copy, nullable) NSString *identifier;

/**
 *  [Output Only] A list of Zone resources.
 *
 *  @note This property is used to support NSFastEnumeration and indexed
 *        subscripting on this class.
 */
@property(strong, nullable) NSArray<GTLRCompute_Zone *> *items;

/** Type of resource. */
@property(copy, nullable) NSString *kind;

/**
 *  [Output Only] This token allows you to get the next page of results for list
 *  requests. If the number of results is larger than maxResults, use the
 *  nextPageToken as a value for the query parameter pageToken in the next list
 *  request. Subsequent list requests will have their own nextPageToken to
 *  continue paging through the results.
 */
@property(copy, nullable) NSString *nextPageToken;

/** [Output Only] Server-defined URL for this resource. */
@property(copy, nullable) NSString *selfLink;

@end

NS_ASSUME_NONNULL_END
